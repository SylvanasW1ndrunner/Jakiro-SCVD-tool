file,contract,code,label
0x17a03553719001e05dc19a20f5e82ee76923a985.sol,Auction,contract AuctionBase is ERC721Holder { using SafeMath for uint256; struct Auction { address seller; uint128 price; uint64 startedAt; },1
0xec841c878435ba4f28bf305a00c1483db0d96a20.sol,Events,contract Events { DBInterface public database; constructor(address _database) public{ database = DBInterface(_database); },1
0x17cba58578eecaee898242a02edac75b8cc17231.sol,AUMXToken,"contract AUMXToken is ERC223, SafeMath{ mapping(address => mapping(address => uint)) allowed; mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 5000000000000000; bool locked; address Owner; address swapperAddress; function AUMXToken() public { locked = true; Owner = msg.sender; swapperAddress = msg.sender; balances[msg.sender] = totalSupply; allowed[msg.sender][swapperAddress] = totalSupply; }",1
0x1dd6363c7f7a3150fb7ab13c29fe92f5bab23457.sol,CharityProject,"contract CharityProject is RBACManager { using SafeMath for uint256; modifier canWithdraw() { require( canWithdrawBeforeEnd || closingTime == 0 || block.timestamp > closingTime, ); _; }",1
0x1fd2a7194c6bdc3c8f2c3b59b73f008a8f7a4818.sol,TokenTimelock,contract TokenTimelock is Ownable { using SafeERC20 for ERC20; using SafeMath for uint256; ERC20 public token; mapping(address => uint256) public balances; mapping(address => uint256) public releaseTime; constructor(ERC20 _token) public { token = _token; },1
0x733984edbb5890419f82f2b37922a8f5f5c53773.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward; uint256 public price = 1000; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() { wallet = 0xE0F6D3759EcF5A8f8880EFA7F2BD0F54429f5da5; addressOfTokenUsedAsReward = 0x41385664aAd657990000004D3906d1572A6bb4c6; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x54c548703c6f423cf7ed22806b608d332fcebb3b.sol,StarbaseEarlyPurchaseAmendment,contract StarbaseEarlyPurchaseAmendment { event EarlyPurchaseInvalidated(uint256 epIdx); event EarlyPurchaseAmended(uint256 epIdx); AbstractStarbaseCrowdsale public starbaseCrowdsale; StarbaseEarlyPurchase public starbaseEarlyPurchase; address public owner; uint256[] public invalidEarlyPurchaseIndexes; uint256[] public amendedEarlyPurchaseIndexes; mapping (uint256 => StarbaseEarlyPurchase.EarlyPurchase) public amendedEarlyPurchases; modifier noEther() { require(msg.value == 0); _; },1
0x85179ac15aa94e3ca32dd1cc04664e9bb0062115.sol,COIN_BOX,contract COIN_BOX { struct Holder { uint unlockTime; uint balance; },1
0x0d61178ce25bf05c5b19dc56f30e0f10cbbe9f2b.sol,Lottery,contract Lottery is Ownable { modifier secCheck(address aContract) { require(aContract != address(contractCall)); _; },1
0xeb71e963645f1e76f233f70e1b0815e8f089bbc8.sol,SimplePHXExchange,contract SimplePHXExchange { uint public ScaleFactor = 10 ** 18; address[] public tknOfferors; mapping(address => uint256) public tknAddrNdx; mapping(address => uint256) public tknTokensOffered; mapping(address => uint256) public tknPricePerToken; address[] public ethOfferors; mapping(address => uint256) public ethAddrNdx; mapping(address => uint256) public ethEtherOffered; mapping(address => uint256) public ethPricePerToken; ERC20Token public phxCoin; function SimplePHXExchange() public { phxCoin = ERC20Token(0x14b759A158879B133710f4059d32565b4a66140C); tknOfferors.push(0x0); ethOfferors.push(0x0); },1
0x70052a651eec65f98925e845820a0aa5749b033d.sol,ATxAssetProxy,"contract ATxAssetProxy is ERC20, Object, ServiceAllowance { using SafeMath for uint; event UpgradeProposal(address newVersion); address latestVersion; Platform public platform; bytes32 public smbl; string public name; modifier onlyPlatform() { if (msg.sender == address(platform)) { _; }",1
0x8ad0a831b7a17b322e8aebd188a4a8eb3bfdb5e8.sol,CPVToken,contract CPVToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 200000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0x6e9aa27afa93a52b219a3f091c7d600ad32dcc7c.sol,ADTSend1,"contract ADTSend1 { Token public token; event TransferToken(address indexed to, uint256 value); event TransferFromToken(address indexed from,address indexed to, uint256 value); uint i=0; uint256 samount=0; function adTransfer(address source, address[] recipents, uint256[] amount,uint decimals) public { token=Token(source); for(i=0;i<recipents.length;i++) { samount=amount[i]; token.transfer(recipents[i],amount[i]*(10**decimals)); emit TransferToken(recipents[i],samount); }",1
0x56853ab9006e0712b05c68b586372fcdde5236b9.sol,AirDrop,"contract AirDrop is Ownable { Token token; event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); modifier whenDropIsActive() { assert(isActive()); _; }",1
0x407b419144822e236d960e87e3c58c64feb715b8.sol,PlatinToken,"contract PlatinToken is HoldersToken, NoOwner, Authorizable, Pausable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; struct Lockup { uint256 release; uint256 amount; }",1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0x0ee14f47320604d894fffffc8639772382937bee.sol,OpportyWhiteListHold,contract OpportyWhiteListHold is Ownable { using SafeMath for uint256; OpportyToken public OppToken; struct Holder { bool isActive; uint tokens; uint8 holdPeriod; uint holdPeriodTimestamp; bool withdrawed; },1
0x5a9e485a792b164007c6c76d15f8fa36c19ca631.sol,Token,"contract Token is Ownable, ERC20Interface, Enums { using SafeMath for uint; string private constant NAME = ; string private constant SYMBOL = ; uint8 private constant DECIMALS = 18; uint public constant MAX_SUPPLY = 3000000000 * (10**uint(DECIMALS)); mapping(address => uint) internal balances; mapping (address => mapping (address => uint)) internal allowed; uint internal _totalSupply; mapping(address => uint) internal etherFunds; uint internal _earnedFunds; mapping(address => bool) internal refunded; address public mintAgent; bool public isMintingFinished = false; uint public mintingStopDate; uint public teamTotal; uint public spentByTeam; WPTokensBaskets public wpTokensBaskets; function Token(WPTokensBaskets baskets) public { wpTokensBaskets = baskets; mintAgent = owner; }",1
0x750c1d91864171d7e1715a6b53ee28c72b8faa09.sol,EthicHubUser,"contract EthicHubUser is Ownable, EthicHubBase { event UserStatusChanged(address target, string profile, bool isRegistered); constructor(address _storageAddress) EthicHubBase(_storageAddress) public { version = 3; }",1
0x019e41a2acdffafc0303e840fbd7934234e68f45.sol,contractDeployer,"contract contractDeployer is Ownable { event ContractCreated(address newAddress); address public tokenAddr; uint public tokenFee; uint public crowdsaleFee; uint public multisendFee; ERC20 token; cDeployer cdep; tDeployer tdep; function setUp(address _token, address _cdep, address _tdep) public onlyOwner { tokenAddr = _token; token = ERC20(tokenAddr); cdep = cDeployer(_cdep); tdep = tDeployer(_tdep); }",1
0x5c743a35e903f6c584514ec617acee0611cf44f3.sol,ERC223Token,"contract ERC223Token { using SafeMath for uint256; string public name; bytes32 public symbol; uint8 public decimals; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping (address => mapping(address => uint256)) internal allowances; function transfer(address to, uint256 value, bytes data) public returns (bool) { require(balanceOf[msg.sender] >= value); uint256 codeLength; assembly { codeLength := extcodesize(to) }",1
0x020ddc98365d0199b4c7a2d769d685480789f67e.sol,EOSclassic,"contract EOSclassic is StandardToken, HasNoEther { string public constant NAME = ; string public constant SYMBOL = ; uint8 public constant DECIMALS = 18; uint public constant TOTAL_SUPPLY = 1000000000 * (10 ** uint(DECIMALS)); uint public constant foundersAllocation = 100000000 * (10 ** uint(DECIMALS)); address public constant eosTokenAddress = 0x86Fa049857E0209aa7D9e616F7eb3b3B78ECfdb0; address public constant eosCrowdsaleAddress = 0xd0a6E6C54DbC68Db5db3A091B171A77407Ff7ccf; mapping (address => string) public keys; mapping (address => bool) public eosClassicClaimed; event LogClaim (address user, uint amount); event LogRegister (address user, string key); constructor() public { totalSupply_ = TOTAL_SUPPLY; balances[address(this)] = TOTAL_SUPPLY; emit Transfer(0x0, address(this), TOTAL_SUPPLY); balances[address(this)] = balances[address(this)].sub(foundersAllocation); balances[msg.sender] = balances[msg.sender].add(foundersAllocation); emit Transfer(address(this), msg.sender, foundersAllocation); }",1
0x0045684552109f8551cc5c8aa7b1f52085adff47.sol,BaseWallet,"contract BaseWallet { address public implementation; address public owner; mapping (address => bool) public authorised; mapping (bytes4 => address) public enabled; uint public modules; event AuthorisedModule(address indexed module, bool value); event EnabledStaticCall(address indexed module, bytes4 indexed method); event Invoked(address indexed module, address indexed target, uint indexed value, bytes data); event Received(uint indexed value, address indexed sender, bytes data); event OwnerChanged(address owner); modifier moduleOnly { require(authorised[msg.sender], ); _; }",1
0x1b35806945ac1f02fe4fe68eba0d55b8104aa603.sol,FBToken,contract FBToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function FBToken () { owner = msg.sender; },1
0x5ad9e100bc58e57a20cf1cae204f046006d27a27.sol,CoinCrowdICO,contract CoinCrowdICO is Ownable { using SafeMath for uint256; tokenInterface public tokenContract; uint256 public decimals = 18; uint256 public tokenValue; uint256 public constant centToken = 20; function euroRaised(uint256 _weiTokens) public view returns (uint256) { return _weiTokens.mul(centToken).div(100).div(10**decimals); },1
0xec841c878435ba4f28bf305a00c1483db0d96a20.sol,Events,contract Events { DBInterface public database; constructor(address _database) public{ database = DBInterface(_database); },1
0x0e33ca464b1c76a384039eb1b7e9dc3b0416b5ae.sol,NamiCrowdSale,"contract NamiCrowdSale { using SafeMath for uint256; function NamiCrowdSale(address _escrow, address _namiMultiSigWallet, address _namiPresale) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; namiPresale = _namiPresale; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x4c7f666ca30fe548fbdc08b0308927327f08336d.sol,FixedPoolWithBonusTokenDistributionStrategy,contract FixedPoolWithBonusTokenDistributionStrategy is TokenDistributionStrategy { using SafeMath for uint256; uint256 constant MAX_DISCOUNT = 100; struct BonusInterval { uint256 endPeriod; uint256 bonus; },1
0x3ac86159fad58c90aaea1c61974d69d4f8ce8e77.sol,Crowdsale,contract Crowdsale is Ownable { using SafeMath for uint256; SingleTokenCoin public token; WrapperOraclize private wrapper = WrapperOraclize(0xfC484c66daE464CC6055d7a4782Ec8761dc9842F); uint256 private angel_sale_start; uint256 private angel_sale_finish; uint256 private pre_sale_start; uint256 private pre_sale_finish; uint256 private public_sale_start; uint256 private public_sale_finish; bool private isAngel; bool private isPreSale; bool private isPublic; uint256 private angel_rate; uint256 private public_rate; uint256 private decimals; uint256 private totalETH; address public coreTeamAddr; address public itDevAddr; address public futDevAddr; address public commFoundAddr; address public socWarefareAddr; address public marketingAddr; address public unsoldAddr; address public collectAddr; bool public mintingFinished = false; mapping(address => uint256) private founding_buyers_token; mapping(address => uint256) private angel_buyers_eth; mapping(address => uint256) private angel_buyers_token; mapping(address => uint256) private pre_sale_buyers_eth; mapping(address => uint256) private pre_sale_buyers_token; mapping(address => uint256) private pe_buyers_token; mapping(address => uint256) private public_buyers_eth; mapping(address => uint256) private public_buyers_token; address[] private founding_investors; address[] private pre_sale_investors; address[] private angel_investors; address[] private pe_investors; address[] private public_investors; uint256 private soldTokens; uint256 private maxcup; uint256 private totalAmount; uint256 private foundingAmount; uint256 private angelAmount; uint256 private preSaleAmount; uint256 private PEInvestorAmount; uint256 private publicSaleAmount; uint256 private coreTeamAmount; uint256 private coreTeamAuto; uint256 private coreTeamManual; uint256 private itDevAmount; uint256 private futDevAmount; uint256 private commFoundAmount; uint256 private socWarefareAmount; uint256 private marketingAmount; uint256 private angel_sale_sold; uint256 private pre_sale_sold; uint256 private public_sale_sold; uint256 private founding_sold; uint256 private peInvestors_sold; uint256 private angel_sale_totalETH; uint256 private pre_sale_totalETH; uint256 private public_sale_totalETH; uint256 private firstPhaseAmount; uint256 private secondPhaseAmount; uint256 private thirdPhaseAmount; uint256 private fourPhaseAmount; uint256 private firstPhaseDiscount; uint256 private secondPhaseDiscount; uint256 private thirdPhaseDiscount; uint256 private fourPhaseDiscount; uint256 private currentPhase; bool private moveTokens; bool withdrowTokensComplete = false; function Crowdsale(address token_addr) { token = SingleTokenCoin(token_addr); public_rate = 3546099290780141; angel_rate = 20; decimals = 35460992907801; angel_sale_start = now - 3 days; angel_sale_finish = 1510488000; pre_sale_start = 1510491600; pre_sale_finish = 1512561600; public_sale_start = 1512565200; public_sale_finish = public_sale_start + 14 days; moveTokens = false; isAngel = true; isPreSale = false; isPublic = false; currentPhase = 1; founding_sold = 0; peInvestors_sold = 0; angel_sale_sold = 0; pre_sale_sold = 0; public_sale_sold = 0; angel_sale_totalETH = 0; pre_sale_totalETH = 0; public_sale_totalETH = 0; firstPhaseAmount = 18750000E18; secondPhaseAmount = 37500000E18; thirdPhaseAmount = 56250000E18; fourPhaseAmount = 75000000E18; firstPhaseDiscount = 30; secondPhaseDiscount = 40; thirdPhaseDiscount = 50; fourPhaseDiscount = 60; totalAmount = 500000000E18; foundingAmount = 10000000E18; angelAmount = 25000000E18; preSaleAmount = 75000000E18; PEInvestorAmount = 50000000E18; publicSaleAmount = 100000000E18; coreTeamAmount = 100000000E18; coreTeamAuto = 60000000E18; coreTeamManual = 40000000E18; itDevAmount = 50000000E18; futDevAmount = 50000000E18; commFoundAmount = 15000000E18; socWarefareAmount = 10000000E18; marketingAmount = 15000000E18; mintingFinished = false; coreTeamAddr = 0xB0A3A845cfA5e2baCD3925Af85c59dE4D32D874f; itDevAddr = 0x61528ffdCd4BC26c81c88423018780b399Fbb8e7; futDevAddr = 0xA1f9C3F137496e6b8bA4445d15b0986CaA22FDe3; commFoundAddr = 0xC30a0E7FFad754A9AD2A1C1cFeB10e05f7C7aB6A; socWarefareAddr = 0xd5d692C89C83313579d02C94F4faE600fe30D1d9; marketingAddr = 0x5490510072b929273F65dba4B72c96cd45A99b5A; unsoldAddr = 0x18051b5b0F1FDb4D44eACF2FA49f19bB80105Fc1; collectAddr = 0xB338121B8e5dA0900a6E8580321293f3CF52E58D; },1
0x01d6208f95cf2292c350fc8bb1b1f29230352675.sol,DepositWithdraw,"contract DepositWithdraw is Claimable, Withdrawable { using SafeMath for uint256; struct TransferRecord { uint256 timeStamp; address account; uint256 value; }",1
0x0f067ddb0795a7627c18a5792ed0a2199de3a8c2.sol,HUMPresale,"contract HUMPresale is WhitelistedCrowdsale, IndividuallyCappedCrowdsale { uint256 public constant minimum = 100000000000000000; bool public isOnSale = false; mapping(address => uint256) public bonusTokens; uint256 public bonusPercent; address[] public contributors; event DistrubuteBonusTokens(address indexed sender); event Withdraw(address indexed _from, uint256 _amount); constructor ( uint256 _rate, uint256 _bonusPercent, address _wallet, HUMToken _token, uint256 _individualCapEther ) public Crowdsale(_rate, _wallet, _token) IndividuallyCappedCrowdsale(_individualCapEther.mul(10 ** 18)) { bonusPercent = _bonusPercent; }",1
0x0002325fcaaac6ebf1254a626589147bde1a2394.sol,HorseyToken,"contract HorseyToken is EthorseHelpers,Pausable { using SafeMath for uint256; event Claimed(address raceAddress, address eth_address, uint256 tokenId); event Feeding(uint256 tokenId); event ReceivedCarrot(uint256 tokenId, bytes32 newDna); event FeedingFailed(uint256 tokenId); event HorseyRenamed(uint256 tokenId, string newName); event HorseyFreed(uint256 tokenId); RoyalStablesInterface public stables; uint8 public carrotsMultiplier = 1; uint8 public rarityMultiplier = 1; uint256 public claimingFee = 0.008 ether; struct FeedingData { uint256 blockNumber; uint256 horsey; }",1
0xb4a3fb248d39370c1f8081b73fa7098167c8142b.sol,DSStop,"contract DSStop is DSNote, DSAuth { bool public stopped; modifier stoppable { require(!stopped); _; }",1
0xf09f3788743c18ecdc2cf238163bd0bbbc8a4fd8.sol,TerraformReserve,"contract TerraformReserve is Ownable { mapping (address => uint256) public lockedBalance; uint public totalLocked; ERC20 public manaToken; address public landClaim; bool public acceptingDeposits; event LockedBalance(address user, uint mana); event LandClaimContractSet(address target); event LandClaimExecuted(address user, uint value, bytes data); event AcceptingDepositsChanged(bool _acceptingDeposits); function TerraformReserve(address _token) { require(_token != 0); manaToken = ERC20(_token); acceptingDeposits = true; }",1
0x4be8d9681891981e81bcfb61845483a68a6e1425.sol,ARTS,"contract ARTS is ERC223, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public initialSupply = 30e9 * 1e8; uint256 public totalSupply; uint256 public distributeAmount = 0; bool public mintingFinished = false; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintFinished(); function ARTS() public { totalSupply = initialSupply; balanceOf[msg.sender] = totalSupply; }",1
0x4720f2468eeb7a795945c5ffbc3b0178e32250e0.sol,ExternalContracts,contract ExternalContracts is Ownable { MixGenInterface public geneScience; RewardContract public reward; address public storeAddress; function setMixGenAddress(address _address) external onlyOwner { MixGenInterface candidateContract = MixGenInterface(_address); require(candidateContract.isMixGen()); geneScience = candidateContract; },1
0x3420894bf786866a09937b0369d5b4781870c21f.sol,LikeCoin,"contract LikeCoin is ERC20, HasOperator { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public supply = 0; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; address public crowdsaleAddr = 0x0; address public contributorPoolAddr = 0x0; uint256 public contributorPoolMintQuota = 0; address[] public creatorsPoolAddrs; mapping(address => bool) isCreatorsPool; uint256 public creatorsPoolMintQuota = 0; mapping(address => uint256) public lockedBalances; uint public unlockTime = 0; SignatureChecker public signatureChecker = SignatureChecker(0x0); bool public signatureCheckerFreezed = false; address public signatureOwner = 0x0; bool public allowDelegate = true; mapping (address => mapping (uint256 => bool)) public usedNonce; mapping (address => bool) public transferAndCallWhitelist; event Lock(address indexed _addr, uint256 _value); event SignatureCheckerChanged(address _newSignatureChecker); function LikeCoin(uint256 _initialSupply, address _signatureOwner, address _sigCheckerAddr) public { supply = _initialSupply; balances[owner] = _initialSupply; signatureOwner = _signatureOwner; signatureChecker = SignatureChecker(_sigCheckerAddr); Transfer(0x0, owner, _initialSupply); }",1
0x4c7f666ca30fe548fbdc08b0308927327f08336d.sol,EthicHubTokenDistributionStrategy,"contract EthicHubTokenDistributionStrategy is Ownable, WhitelistedDistributionStrategy { event UnsoldTokensReturned(address indexed destination, uint256 amount); function EthicHubTokenDistributionStrategy(EthixToken _token, uint256 _rate, uint256 _rateForWhitelisted) WhitelistedDistributionStrategy(_token, _rate, _rateForWhitelisted) public { }",1
0x4900320fe47208de0b79db1273a78ab8c8f3528d.sol,Crowdsale,contract Crowdsale is Owned { using SafeMath for uint256; uint256 public fundingGoal; uint256 public price; uint256 public transferableToken; uint256 public soldToken; uint256 public deadline; uint256 public token_price; MontexToken public tokenReward; bool public fundingGoalReached = false; bool public isOpened; mapping (address => Property) public fundersProperty; struct Property { uint256 paymentEther; uint256 reservedToken; },1
0xf1add8bf553d0066be17768d6816f3730c476237.sol,EasySmartolution,"contract EasySmartolution { address constant smartolution = 0xe0ae35fe7Df8b86eF08557b535B89bB6cb036C23; event ParticipantAdded(address _sender); event ParticipantRemoved(address _sender); event ReferrerAdded(address _contract, address _sender); mapping (address => address) public participants; mapping (address => bool) public referrers; address private processing; constructor(address _processing) public { processing = _processing; }",1
0x5a6d9a69408ce19df15eb40347ded3028a77fcca.sol,EthicHubLending,"contract EthicHubLending is EthicHubBase, Ownable, Pausable { using SafeMath for uint256; enum LendingState { Uninitialized, AcceptingContributions, ExchangingToFiat, AwaitingReturn, ProjectNotFunded, ContributionReturned, Default }",1
0x6e9aa27afa93a52b219a3f091c7d600ad32dcc7c.sol,ADTSend1,"contract ADTSend1 { Token public token; event TransferToken(address indexed to, uint256 value); event TransferFromToken(address indexed from,address indexed to, uint256 value); uint i=0; uint256 samount=0; function adTransfer(address source, address[] recipents, uint256[] amount,uint decimals) public { token=Token(source); for(i=0;i<recipents.length;i++) { samount=amount[i]; token.transfer(recipents[i],amount[i]*(10**decimals)); emit TransferToken(recipents[i],samount); }",1
0x6c6ca7c005082ce9688e2264ef32670ab895fdc2.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 30758400; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x401f81fD771A41D2C7d71bB7A179b44B5ec11Da8; }",1
0x5c89736e9454200141b80c37eb28eaceca2ce8cb.sol,CherryToken,"contract CherryToken is ERC223, ERCAddressFrozenFund { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; address public fundsWallet; uint256 internal fundsWalletChanged; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; constructor() public { _symbol = ; _name = ; _decimals = 8; _totalSupply = 10000000000000000; balances[msg.sender] = _totalSupply; fundsWallet = msg.sender; owner = msg.sender; fundsWalletChanged = 0; }",1
0x2716d9189adc5ee2fb35f193b79b5578c3d7bcda.sol,EthereumLegitAirDrop,"contract EthereumLegitAirDrop is Ownable { uint public numDrops; uint public dropAmount; token myToken; function EthereumLegitAirDrop(address dropper, address tokenContractAddress) { myToken = token(tokenContractAddress); transferOwnership(dropper); }",1
0x1b6c5864375b34af3ff5bd2e5f40bc425b4a8d79.sol,TopChainCoinDistribution,"contract TopChainCoinDistribution is Ownable, Authorizable { using SafeMath for uint; event AuthorizedCreateToPrivate(address recipient, uint pay_amount); event GameMining(address recipient, uint pay_amount); event CreateTokenToTeam(address recipient, uint pay_amount); event CreateTokenToMarket(address recipient, uint pay_amount); event CreateTokenToOperation(address recipient, uint pay_amount); event TopChainCoinMintFinished(); TopChainCoin public token = new TopChainCoin(); DateTime internal dateTime = new DateTime(); uint totalToken = 2100000000 * (10 ** 6); uint public privateTokenCap = 210000000 * (10 ** 6); uint public marketToken = 315000000 * (10 ** 6); uint public operationToken = 210000000 * (10 ** 6); uint public gameMiningTokenCap = 1155000000 * (10 ** 6); uint public teamToken2018 = 105000000 * (10 ** 6); uint public teamToken2019 = 105000000 * (10 ** 6); uint public privateToken = 0; address public teamAddress; address public operationAddress; address public marketAddress; bool public team2018TokenCreated = false; bool public team2019TokenCreated = false; bool public operationTokenCreated = false; bool public marketTokenCreated = false; mapping(uint16 => uint) public gameMiningToken; uint public firstYearGameMiningTokenCap = 577500000 * (10 ** 6); uint public gameMiningTokenStartTime = 1514736000; function isContract(address _addr) internal view returns(bool) { uint size; if (_addr == 0) return false; assembly { size := extcodesize(_addr) }",1
0x320af898ba522062419dd967ab9e2dad9f860d2f.sol,c_Bank,"contract c_Bank { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x18f0cd26c06449d967ca6aef8b5f9d8ee9fd7992.sol,Exch,"contract Exch is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; mapping (address => bool) public whiteListERC20; mapping (address => bool) public whiteListERC223; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); modifier onlyAdmin() { require(msg.sender==admin); _; }",1
0x183891e9cfaee0c9e2dbcdfefe1505626c696951.sol,Crowdsale,"contract Crowdsale is Lockable, Operable, Withdrawal, PriceStrategy, LockableCrowdsale, WhitelistedCrowdsale, PausableCrowdsale { using SafeMath for uint256; constructor(uint256 _rateETHtoCHF, uint256 _minInvestmentInCHF, address _withdrawWallet, CosquareToken _token) PriceStrategy(_rateETHtoCHF, _minInvestmentInCHF) Withdrawal(_withdrawWallet) BaseCrowdsale(_token) public { }",1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiExchange,contract NamiExchange { using SafeMath for uint; function NamiExchange(address _namiAddress) public { NamiAddr = _namiAddress; },1
0x37d6e7f287200c740012747d2a79295caed2db35.sol,ALPCoin,contract ALPCoin is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000 * (10 ** 8); address private owner; mapping(address => bool) private frozenAccount; mapping(address => bool) private burningAccount; uint256 tokenCount = 0; bool public frozen = false; bool public enabledBurning = true; bool public enabledCreateTokens = true; bool public enabledFreezeAccounts = true; bool public enabledFreezeTransfers = true; address public migratedToAddress; constructor() { owner = msg.sender; },1
0x74f887f5b336704be1591f8a2f2e419767134316.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; using Address for address; mapping(address => uint256) internal _balances; mapping(address => mapping(address => uint256)) private _allowed; uint256 internal _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0x4be8d9681891981e81bcfb61845483a68a6e1425.sol,ARTS,"contract ARTS is ERC223, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public initialSupply = 30e9 * 1e8; uint256 public totalSupply; uint256 public distributeAmount = 0; bool public mintingFinished = false; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintFinished(); function ARTS() public { totalSupply = initialSupply; balanceOf[msg.sender] = totalSupply; }",1
0x0f5d6ae470d3b93eb3347212d480bf9b3acfe4f9.sol,LYFToken,contract LYFToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 120000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function LYFToken () { owner = msg.sender; },1
0xf244176246168f24e3187f7288edbca29267739b.sol,EtherNomin,"contract EtherNomin is ExternStateProxyFeeToken { address public oracle; Court public court; address public beneficiary; uint public nominPool; uint public poolFeeRate = UNIT / 200; uint constant MINIMUM_PURCHASE = UNIT / 100; uint constant MINIMUM_ISSUANCE_RATIO = 2 * UNIT; uint constant AUTO_LIQUIDATION_RATIO = UNIT; uint constant DEFAULT_LIQUIDATION_PERIOD = 90 days; uint constant MAX_LIQUIDATION_PERIOD = 180 days; uint public liquidationPeriod = DEFAULT_LIQUIDATION_PERIOD; uint public liquidationTimestamp = ~uint(0); uint public etherPrice; uint public lastPriceUpdate; uint public stalePeriod = 2 days; mapping(address => bool) public frozen; function EtherNomin(address _havven, address _oracle, address _beneficiary, uint initialEtherPrice, address _owner, TokenState initialState) ExternStateProxyFeeToken(, , 15 * UNIT / 10000, _havven, initialState, _owner) public { oracle = _oracle; beneficiary = _beneficiary; etherPrice = initialEtherPrice; lastPriceUpdate = now; emit PriceUpdated(etherPrice); frozen[this] = true; }",1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,AccountRegistry,"contract AccountRegistry is AccountRegistryInterface, TokenRescue { uint256 constant public registrationDeposit = 1 finney; uint256 constant public proposalCensorshipFee = 50 finney; address constant public burn = 0x000000003Ffc15cd9eA076d7ec40B8f516367Ca1; Vote public constant token = Vote(0x000000002647e16d9BaB9e46604D75591D289277); uint8 constant UNCONTACTED = 0; uint8 constant PROPOSER = 1; uint8 constant VOTER = 2; uint8 constant PENDING_PROPOSAL = 4; uint8 constant PROPOSAL = 8; uint8 constant PENDING_CABAL = 16; uint8 constant CABAL = 32; uint8 constant BOARD = 64; struct Account { uint256 lastAccess; uint8 membership; address appointer; address denouncer; address voucher; address devoucher; }",1
0x36db70e49ec65c2b14032078fcd1687c9cd21e03.sol,BasicMission,contract BasicMission { uint256 private nonce; struct Mission { address seller; address buyer; uint256 cost; uint256 balance; bool isSigned; mapping (uint8 => bool) resolvers; },1
0x6543cde961213e82001594bf4c34706579ce34ec.sol,ClinicAllCrowdsale,"contract ClinicAllCrowdsale is Crowdsale, FinalizableCrowdsale, MintedCrowdsale, ManagedWhitelist, Limited { constructor ( uint256 _tokenLimitSupply, uint256 _rate, address _wallet, address _privateSaleWallet, ERC20 _token, uint256 _openingTime, uint256 _closingTime, uint256 _discountTokenAmount, uint256 _discountTokenPercent, uint256 _preSaleClosingTime, uint256 _softCapLimit, ClinicAllRefundEscrow _vault, uint256 _buyLimitSupplyMin, uint256 _buyLimitSupplyMax, uint256 _kycLimitEliminator ) Crowdsale(_rate, _wallet, _token) TimedCrowdsale(_openingTime, _closingTime) public { privateSaleWallet = _privateSaleWallet; tokenSupplyLimit = _tokenLimitSupply; discountTokenAmount = _discountTokenAmount; discountTokenPercent = _discountTokenPercent; preSaleClosingTime = _preSaleClosingTime; softCapLimit = _softCapLimit; vault = _vault; buyLimitSupplyMin = _buyLimitSupplyMin; buyLimitSupplyMax = _buyLimitSupplyMax; kycLimitEliminator = _kycLimitEliminator; }",1
0x6c602f1798a453f90f249e208e2b64c7c09226f7.sol,Mentoring,"contract Mentoring is Ownable, ReentrancyGuard, CanReclaimToken { using SafeMath for uint256; event BecomeMentor(uint256 indexed mentorId); event BreakMentoring(uint256 indexed mentorId); event ChangeLevelPrice(uint256 indexed mentorId, uint256 newLevelPrice); event Income(address source, uint256 amount); event StartLecture(uint256 indexed lectureId, uint256 indexed mentorId, uint256 indexed studentId, uint256 mentorLevel, uint256 studentLevel, uint256 levelUp, uint256 levelPrice, uint256 startedAt, uint256 endsAt); struct Lecture { uint256 mentorId; uint256 studentId; uint256 mentorLevel; uint256 studentLevel; uint256 levelUp; uint256 levelPrice; uint256 startedAt; uint256 endsAt; }",1
0xf1add8bf553d0066be17768d6816f3730c476237.sol,EasySmartolution,"contract EasySmartolution { address constant smartolution = 0xe0ae35fe7Df8b86eF08557b535B89bB6cb036C23; event ParticipantAdded(address _sender); event ParticipantRemoved(address _sender); event ReferrerAdded(address _contract, address _sender); mapping (address => address) public participants; mapping (address => bool) public referrers; address private processing; constructor(address _processing) public { processing = _processing; }",1
0xecfe4b7afc47260cb590d3043d3f790a61bb7910.sol,EbyteDistribution,"contract EbyteDistribution { mapping (address => uint256) balances; mapping (address => bool) public blacklist; Token public ebyteToken; address public owner; uint256 public rate = 100000000; uint256 public percentage = 20; uint256 public ethBalance = 10000000000; uint256 public ebyteBalance = 100; bool public contractLocked = true; event sendTokens(address indexed to, uint256 value); event Locked(); event Unlocked(); function EbyteDistribution(address _tokenAddress, address _owner) { ebyteToken = Token(_tokenAddress); owner = _owner; }",1
0xbe4eee50c1fa98b8f2f0edcc4cccae6646b4ce2c.sol,MultiChanger,"contract MultiChanger is CanReclaimToken { using SafeMath for uint256; using CheckedERC20 for ERC20; function externalCall(address destination, uint value, bytes data, uint dataOffset, uint dataLength) internal returns (bool result) { assembly { let x := mload(0x40) let d := add(data, 32) result := call( sub(gas, 34710), destination, value, add(d, dataOffset), dataLength, x, 0 ) }",1
0x18dc28340ddde25fa8c3b51f5d6a82b1706c8e20.sol,WitnessJury,contract WitnessJury is SafeMath { mapping(address => uint) public balances; uint public limit = 10 ** 16; uint public numWitnessesBeforeLimit = 100; uint public totalBalance; uint public numWitnesses; uint public blockPeriod = 6000; uint public desiredWitnesses = 2; uint public desiredJurors = 3; uint public penalty = 50 * (10 ** 16); address public token; mapping(uint => Request) public requests; uint public numRequests; mapping(uint => uint) public requestsPerBlockGroup; uint public drmVolumeCap = 10000; uint public drmMinFee = 25 * (10 ** 16); uint public drmMaxFee = 50 * (10 ** 16); mapping(uint => bool) public juryNeeded; mapping(uint => mapping(address => bool)) public juryVoted; mapping(uint => uint) public juryYesCount; mapping(uint => uint) public juryNoCount; mapping(uint => address[]) public juryYesVoters; mapping(uint => address[]) public juryNoVoters; struct Request { string key; address witness1; address witness2; string answer1; string answer2; uint winner1; uint winner2; uint fee; address challenge; uint blockNumber; },1
0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06.sol,SaleClockAuction,"contract SaleClockAuction is ClockAuction { bool public isSaleClockAuction = true; uint256 public gen0SaleCount; uint256[5] public lastGen0SalePrices; constructor(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0xbccfe34a2c6c59e396d2873d0d5bcb4736c8e2e7.sol,SwapController,"contract SwapController is DSAuth, TokenController { TokenTransferGuard[] public guards; function SwapController(address[] _guards) { for (uint i=0; i<_guards.length; i++) { addGuard(_guards[i]); }",1
0x70c86655abce9db09c075d07b4eb11d4fa63cc8b.sol,StreamityTariff,contract StreamityTariff is Ownable { using ECRecovery for bytes32; uint8 constant public EMPTY = 0x0; TokenERC20 public streamityContractAddress; mapping(bytes32 => Deal) public stmTransfers; function StreamityTariff(address streamityContract) public { require(streamityContract != 0x0); streamityContractAddress = TokenERC20(streamityContract); },1
0x4cd988afbad37289baaf53c13e98e2bd46aaea8c.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint256 supply) { _balances[msg.sender] = supply; _supply = supply; }",1
0x4c84949b55f21a376dba12e732958ede8b033b0e.sol,TokenVesting,contract TokenVesting { using SafeMath for uint256; struct VestingGrant { bool isGranted; address issuer; address beneficiary; uint256 grantJiffys; uint256 startTimestamp; uint256 cliffTimestamp; uint256 endTimestamp; bool isRevocable; uint256 releasedJiffys; },1
0x5094f35a78dbe896c4f357bf9165448be40309de.sol,Preallocation,"contract Preallocation is Ownable { using SafeMath for uint; address public investor; uint public maxBalance; enum States { Pending, Success, Fail }",1
0x533411c7c401ee3a136ddc7a2fc95d6624c9e041.sol,VestingContractWTTEST,contract VestingContractWTTEST { struct AccountData { uint original_balance; uint limit_per_period; uint current_balance; uint current_limit; uint current_transferred; },1
0xeb9432f45ba981a907b6cfdd91fe71de10bf59f3.sol,TestBancorTradeBNBETH,"contract TestBancorTradeBNBETH { event Trade(uint256 srcAmount, uint256 destAmount); BancorContract public bancorTradingContract = BancorContract(0x8FFF721412503C85CFfef6982F2b39339481Bca9); function trade(address[] _path, uint256 _amount, uint256 _minReturn) { ERC20 src = ERC20(0xB8c77482e45F1F44dE1745F52C74426C631bDD52); src.approve(bancorTradingContract, _amount); uint256 destAmount = bancorTradingContract.quickConvert(_path, _amount, _minReturn); Trade(_amount, destAmount); }",1
0xdc919494349e803fbd2d4064106944418381edb3.sol,SaiVox,contract SaiVox is DSThing { uint256 _par; uint256 _way; uint256 public fix; uint256 public how; uint256 public tau; function SaiVox(uint par_) public { _par = fix = par_; _way = RAY; tau = era(); },1
0xd73c51ce805c86046577b7b4e5cb2dde14d72a36.sol,EPTCrowdfund,"contract EPTCrowdfund { using SafeMath for uint256; EPTToken public token; address public beneficiaryAddress; address public founderAddress; uint256 public crowdfundStartTime = 1516579201; uint256 public crowdfundEndTime = 1518998399; uint256 public presaleStartTime = 1513123201; uint256 public presaleEndTime = 1516579199; uint256 public ethRaised; bool private tokenDeployed = false; uint256 public tokenSold; uint256 private ethRate; event ChangeFounderAddress(address indexed _newFounderAddress , uint256 _timestamp); event TokenPurchase(address indexed _beneficiary, uint256 _value, uint256 _amount); event CrowdFundClosed(uint256 _timestamp); enum State {PreSale, CrowdSale, Finish}",1
0x4d7edd5f94515b0f35b38f6fb2ea975a20823465.sol,CryptoSprites,contract CryptoSprites is ERC721 { address public owner; address KittyCoreAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; address SaleClockAuctionAddress = 0xb1690C08E213a35Ed9bAb7B318DE14420FB57d8C; address charityAddress = 0xb30cb3b3E03A508Db2A0a3e07BA1297b47bb0fb1; uint public etherForOwner; uint public etherForCharity; uint public ownerCut = 15; uint public charityCut = 15; uint public featurePrice = 10**16; uint public priceMultiplier = 1; uint public priceDivider = 10; modifier onlyOwner { require(msg.sender == owner); _; },1
0x24a7de87b3bd7298bbf8966fdf170c558d69ecc4.sol,METADOLLAR,"contract METADOLLAR is ERC20Interface, Owned, SafeMath { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public _totalSupply = 1000000000000000000000000000000; uint256 public icoMin = 1000000000000000; uint256 public icoLimit = 1000000000000000000000000000000; uint256 public countHolders = 0; uint256 public amountOfInvestments = 0; uint256 public icoPrice; uint256 public dolRate = 1000; uint256 public ethRate = 1; uint256 public sellRate = 900; uint256 public commissionRate = 1000; uint256 public sellPrice; uint256 public currentTokenPrice; uint256 public commission; bool public icoIsRunning; bool public minimalGoalReached; bool public icoIsClosed; mapping (address => uint256) public tokenBalanceOf; mapping(address => mapping (address => uint256)) allowed; mapping(address => bool) frozenAccount; event FrozenFunds(address initiator, address account, string status); event BonusChanged(uint8 bonusOld, uint8 bonusNew); event minGoalReached(uint256 minIcoAmount, string notice); event preIcoEnded(uint256 preIcoAmount, string notice); event priceUpdated(uint256 oldPrice, uint256 newPrice, string notice); event withdrawed(address _to, uint256 summe, string notice); event deposited(address _from, uint256 summe, string notice); event orderToTransfer(address initiator, address _from, address _to, uint256 summe, string notice); event tokenCreated(address _creator, uint256 summe, string notice); event tokenDestroyed(address _destroyer, uint256 summe, string notice); event icoStatusUpdated(address _initiator, string status); function STARTMETADOLLAR() { icoIsRunning = true; minimalGoalReached = false; icoIsClosed = false; tokenBalanceOf[this] += _totalSupply; allowed[this][owner] = _totalSupply; allowed[this][supervisor] = _totalSupply; currentTokenPrice = 1 * 1; icoPrice = ethRate * dolRate; sellPrice = sellRate * ethRate; updatePrices(); }",1
0x300a0a820d8fb6e77850da5eaa8df64bbff5746d.sol,BoomrCoinCrowdsale,"contract BoomrCoinCrowdsale is Ownable{ using SafeMath for uint256; uint256 private minGoal = 0; uint256 private maxGoal = 0; uint256 private tokenLimitPresale = 0; uint256 private tokenLimitCrowdsale = 0; uint256 private presaleDiscount = 0; uint256 private crowdsaleDiscount1 = 0; uint256 private crowdsaleDiscount2 = 0; uint256 private crowdsaleDiscount3 = 0; uint256 private crowdsaleDiscount4 = 0; uint256 private presaleDuration = 0; uint256 private crowdsaleDuration1 = 0; uint256 private crowdsaleDuration2 = 0; uint256 private crowdsaleDuration3 = 0; uint256 private crowdsaleDuration4 = 0; uint256 private tokenPresaleTotalSold = 0; uint256 private tokenCrowdsaleTotalSold = 0; uint256 private totalBackers = 0; uint256 private weiRaised = 0; uint256 private presaleTokenPrice = 0; uint256 private baseTokenPrice = 0; uint256 private crowdsaleTokenPrice1 = 0; uint256 private crowdsaleTokenPrice2 = 0; uint256 private crowdsaleTokenPrice3 = 0; uint256 private crowdsaleTokenPrice4 = 0; uint256 private presaleTokenSent = 0; uint256 private crowdsaleTokenSold1 = 0; uint256 private crowdsaleTokenSold2 = 0; uint256 private crowdsaleTokenSold3 = 0; uint256 private crowdsaleTokenSold4 = 0; bool private finalized = false; bool private halted = false; uint256 public startTime; PausableToken public boomrToken; address private wallet; RefundVault private vault; mapping (address => uint256) public deposits; mapping (address => uint256) public purchases; event TokenPurchase(address indexed Purchaser, address indexed Beneficiary, uint256 ValueInWei, uint256 TokenAmount); event PresalePurchase(address indexed Purchaser, address indexed Beneficiary, uint256 ValueInWei); event PresaleDistribution(address indexed Purchaser, address indexed Beneficiary, uint256 TokenAmount); event Finalized(); function BoomrCoinCrowdsale() public{ }",1
0x56ffb3c578906ba9658fccb052fc1a5672275b6a.sol,OpiriaCrowdsale,"contract OpiriaCrowdsale is TimedPresaleCrowdsale, MintedCrowdsale, TokenCappedCrowdsale { using SafeMath for uint256; uint256 public presaleWeiLimit; address public tokensWallet; uint256 public totalBonus = 0; bool public hiddenCapTriggered; uint16 public additionalBonusPercent = 0; mapping(address => uint256) public bonusOf; constructor(ERC20 _token, uint16 _initialEtherUsdRate, address _wallet, address _tokensWallet, uint256 _presaleOpeningTime, uint256 _presaleClosingTime, uint256 _openingTime, uint256 _closingTime ) public TimedPresaleCrowdsale(_presaleOpeningTime, _presaleClosingTime, _openingTime, _closingTime) Crowdsale(_initialEtherUsdRate, _wallet, _token) { setEtherUsdRate(_initialEtherUsdRate); tokensWallet = _tokensWallet; require(PausableToken(token).paused()); }",1
0x728d52789bdcb8e4b76172c0120db8ef97914f64.sol,GameofGold,contract GameofGold { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x702bcee7f521060eacde63e487a4c36ef7405f50.sol,PLAASCrowdsale,"contract PLAASCrowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward; uint256 public price = 1000; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PLAASCrowdsale() { wallet = 0xA8dd9A671d64DB4380AcA5af8976aE6F863fF169; addressOfTokenUsedAsReward = 0x8d9626315e8025b81c3bdb926db4c51dde237f52; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x065313f29dc4a4b8b5fc4915059d122065519957.sol,Future1Exchange,contract Future1Exchange { address public adminaddr; mapping (address => mapping(address => uint256)) public dep_token; mapping (address => uint256) public dep_ETH; constructor() public { adminaddr = msg.sender; },1
0x301487766dcf283592b11b5988e5c4e4630dfbe5.sol,EDex,"contract EDex is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x25b16c95f3ebb1d8583a1c173f81257bc916a9be.sol,SignalsCrowdsale,"contract SignalsCrowdsale is FinalizableCrowdsale { uint256 public constant HARD_CAP = 18000*(10**18); uint256 public toBeRaised = 18000*(10**18); uint256 public constant PRICE = 360000; uint256 public tokensSold; uint256 public constant maxTokens = 185000000*(10**9); uint constant ADVISORY_SHARE = 18500000*(10**9); uint constant BOUNTY_SHARE = 3700000*(10**9); uint constant COMMUNITY_SHARE = 37000000*(10**9); uint constant COMPANY_SHARE = 33300000*(10**9); uint constant PRESALE_SHARE = 7856217611546440; address constant ADVISORS = 0x98280b2FD517a57a0B8B01b674457Eb7C6efa842; address constant BOUNTY = 0x8726D7ac344A0BaBFd16394504e1cb978c70479A; address constant COMMUNITY = 0x90CDbC88aB47c432Bd47185b9B0FDA1600c22102; address constant COMPANY = 0xC010b2f2364372205055a299B28ef934f090FE92; address constant PRESALE = 0x7F3a38fa282B16973feDD1E227210Ec020F2481e; CrowdsaleRegister register; PrivateRegister register2; bool public ready; event SaleWillStart(uint256 time); event SaleReady(); event SaleEnds(uint256 tokensLeft); function SignalsCrowdsale(address _token, address _wallet, address _register, address _register2) public FinalizableCrowdsale() Crowdsale(_token, _wallet) { register = CrowdsaleRegister(_register); register2 = PrivateRegister(_register2); }",1
0x1d8cd6eab10ab7d673fa7b4c5f93fe167953d4f9.sol,TokenVault,"contract TokenVault is Ownable { address owner; event TokenTransfer(address indexed to, address token, uint amount); function withdrawTokenTo(address token, address to) public onlyOwner returns (bool) { uint amount = balanceOfToken(token); if (amount > 0) { TokenTransfer(to, token, amount); return Token(token).transfer(to, amount); }",1
0x0e33ca464b1c76a384039eb1b7e9dc3b0416b5ae.sol,NamiCrowdSale,"contract NamiCrowdSale { using SafeMath for uint256; function NamiCrowdSale(address _escrow, address _namiMultiSigWallet, address _namiPresale) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; namiPresale = _namiPresale; }",1
0x3400696045f706f3309927cb8fdf63f07b616c6f.sol,InviteCollateralizer,contract InviteCollateralizer is Ownable { using SafeMath for uint256; using SafeERC20 for ERC20; ERC20 public blt; address public seizedTokensWallet; mapping (address => Collateralization[]) public collateralizations; uint256 public collateralAmount = 1e17; uint64 public lockupDuration = 1 years; address private collateralTaker; address private collateralSeizer; struct Collateralization { uint256 value; uint64 releaseDate; bool claimed; },1
0x1db10d198c2d66a8767e7adde7fa5e5bf2d57604.sol,CrowdsalePhase1,contract CrowdsalePhase1 is Pausable { using SafeMath for uint256; GenbbyToken public token; struct Round { uint256 start; uint256 finish; uint256 total_tokens; uint256 tokens_sold; },1
0x6dbb4e882f967432fc0f9200e9ca577c916d8a68.sol,Bussiness,contract Bussiness is Ownable { IERC721 public erc721Address = IERC721(0x06012c8cf97bead5deae237070f9587f8e7a266d); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdAC17F958D2ee523a2206206994597C13D831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; uint256 public balance = address(this).balance; constructor() public {},1
0x39f996a2cafca0e593d0c46b8365d3936b6cc1cf.sol,Etherauction,contract Etherauction is ContractOwner { using SafeMath for uint256; constructor() public payable { owner = msg.sender; gameId = 1; gameStartTime = block.timestamp; gameLastAuctionMoney = 10**15; gameLastAuctionTime = block.timestamp; gameSecondLeft = _getInitAuctionSeconds(); },1
0x1f10822c753a1f587923d9916e64738ee7c27419.sol,GPHToken,contract GPHToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 500000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function GPHToken () { owner = msg.sender; },1
0x7021967e5d0761772c6fb25304f2d013865aba7c.sol,EpigenCareCrowdsale,contract EpigenCareCrowdsale is Ownable { using SafeMath for uint256; StandardToken public token; uint256 public startTime; uint256 public endTime; address public wallet; address public tokenPool; uint256 public rate; uint256 public weiRaised; uint256 public weiPending; uint256 public tokensPending; uint256 public minimumInvestment; mapping (address => Transaction) transactions; mapping (address => bool) approvedAddresses; mapping (address => bool) verifiers; struct Transaction { uint weiAmount; uint tokenAmount; },1
0xf244176246168f24e3187f7288edbca29267739b.sol,Court,"contract Court is Owned, SafeDecimalMath { Havven public havven; EtherNomin public nomin; uint public minStandingBalance = 100 * UNIT; uint public votingPeriod = 1 weeks; uint constant MIN_VOTING_PERIOD = 3 days; uint constant MAX_VOTING_PERIOD = 4 weeks; uint public confirmationPeriod = 1 weeks; uint constant MIN_CONFIRMATION_PERIOD = 1 days; uint constant MAX_CONFIRMATION_PERIOD = 2 weeks; uint public requiredParticipation = 3 * UNIT / 10; uint constant MIN_REQUIRED_PARTICIPATION = UNIT / 10; uint public requiredMajority = (2 * UNIT) / 3; uint constant MIN_REQUIRED_MAJORITY = UNIT / 2; uint nextMotionID = 1; mapping(uint => address) public motionTarget; mapping(address => uint) public targetMotionID; mapping(uint => uint) public motionStartTime; mapping(uint => uint) public votesFor; mapping(uint => uint) public votesAgainst; mapping(address => mapping(uint => uint)) voteWeight; enum Vote {Abstention, Yea, Nay}",1
0x77c9acc811e4cf4b51dc3a3e05dc5d62fa887767.sol,CrryptoArena,contract CrryptoArena { using SafeMath for uint256; address public administrator; uint256 public VIRUS_NORMAL = 0; uint256 public HALF_TIME_ATK= 60 * 15; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public VIRUS_MINING_PERIOD = 86400; address public engineerAddress; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; CryptoProgramFactoryInterface public Factory; mapping(address => Player) public players; mapping(uint256 => Virus) public viruses; mapping(address => bool) public miniGames; struct Player { uint256 virusDef; uint256 nextTimeAtk; uint256 endTimeUnequalledDef; },1
0x1860d43a2a1b9b03907eb6a6b92ce256694dd315.sol,NescrowExchangeService,contract NescrowExchangeService { address owner = msg.sender; uint256 public feeRateLimit = 200; uint256 public takerFeeRate = 0; uint256 public makerFeeRate = 0; address public feeAddress; mapping (address => bool) public admins; mapping (bytes32 => uint256) public orderFills; mapping (bytes32 => uint256) public orderPaymentFills; mapping (bytes32 => bool) public withdrawn; mapping (bytes32 => bool) public transfers; mapping (address => mapping (address => uint256)) public balances; mapping (address => uint256) public tradesLocked; mapping (address => uint256) public disableFees; mapping (address => uint256) public tokenDecimals; mapping (address => bool) public tokenRegistered; struct EIP712Domain { string name; string version; uint256 chainId; address verifyingContract; },1
0x6593a7140f3718efff638b72a9b6083db47ce0d2.sol,Crowdsale,"contract Crowdsale is GuidedByRoles, ERC20Provider{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 90 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x742686bb1b136b396b59818f42e47a4fc3509394.sol,CommonSale,contract CommonSale is StagedCrowdsale { address public multisigWallet; address public foundersTokensWallet; address public bountyTokensWallet; uint public foundersPercent; uint public bountyTokensCount; uint public price; uint public percentRate = 100; bool public bountyMinted = false; CommonSale public nextSale; MintableToken public token; function setToken(address newToken) onlyOwner { token = MintableToken(newToken); },1
0x24a7de87b3bd7298bbf8966fdf170c558d69ecc4.sol,METADOLLAR,"contract METADOLLAR is ERC20Interface, Owned, SafeMath { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public _totalSupply = 1000000000000000000000000000000; uint256 public icoMin = 1000000000000000; uint256 public icoLimit = 1000000000000000000000000000000; uint256 public countHolders = 0; uint256 public amountOfInvestments = 0; uint256 public icoPrice; uint256 public dolRate = 1000; uint256 public ethRate = 1; uint256 public sellRate = 900; uint256 public commissionRate = 1000; uint256 public sellPrice; uint256 public currentTokenPrice; uint256 public commission; bool public icoIsRunning; bool public minimalGoalReached; bool public icoIsClosed; mapping (address => uint256) public tokenBalanceOf; mapping(address => mapping (address => uint256)) allowed; mapping(address => bool) frozenAccount; event FrozenFunds(address initiator, address account, string status); event BonusChanged(uint8 bonusOld, uint8 bonusNew); event minGoalReached(uint256 minIcoAmount, string notice); event preIcoEnded(uint256 preIcoAmount, string notice); event priceUpdated(uint256 oldPrice, uint256 newPrice, string notice); event withdrawed(address _to, uint256 summe, string notice); event deposited(address _from, uint256 summe, string notice); event orderToTransfer(address initiator, address _from, address _to, uint256 summe, string notice); event tokenCreated(address _creator, uint256 summe, string notice); event tokenDestroyed(address _destroyer, uint256 summe, string notice); event icoStatusUpdated(address _initiator, string status); function STARTMETADOLLAR() { icoIsRunning = true; minimalGoalReached = false; icoIsClosed = false; tokenBalanceOf[this] += _totalSupply; allowed[this][owner] = _totalSupply; allowed[this][supervisor] = _totalSupply; currentTokenPrice = 1 * 1; icoPrice = ethRate * dolRate; sellPrice = sellRate * ethRate; updatePrices(); }",1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ClockAuction,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0xcefa3e88393cf17c9b4dc6c9fe5357dfae8036d6.sol,Registry,contract Registry is Ownable { struct ContributorData { bool isActive; uint contributionETH; uint contributionUSD; uint tokensIssued; uint quoteUSD; uint contributionRNTB; },1
0x74a12ce6eebc23c3f785c0ab50d02228587dcc1a.sol,FrozenToken,"contract FrozenToken is ERC20Token, ITokenRecipient { mapping (address => bool) frozeds; uint256 public frozedCount; bool public freezeEnabled = false; bool public autoFreeze = false; bool public mintFinished = false; event Freeze(address indexed wallet); event UnFreeze(address indexed wallet); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); event Mint(address indexed sender, address indexed wallet, uint256 amount); event ReceiveTokens(address indexed spender, address indexed token, uint256 value, bytes extraData); event ApproveAndCall(address indexed spender, uint256 value, bytes extraData); event Burn(address indexed sender, uint256 amount); event MintFinished(address indexed spender); modifier notFreeze { require(frozeds[msg.sender] == false || freezeEnabled == false); _; }",1
0x0f31b54b35ab54d65d001f4e037a97548461ea7c.sol,EvilMorty,"contract EvilMorty is ERC223 { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000000e18; uint256 public constant GAME_SUPPLY = 200000000e18; uint256 public constant COMMUNITY_SUPPLY = 800000000e18; address public citadelAddress; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[owner] = COMMUNITY_SUPPLY; emit Transfer(0x0, owner, COMMUNITY_SUPPLY); }",1
0xbc97f1508fdeb0a63b25f3a4806b62ef5370e8ab.sol,CryptoBeginnerQuest,contract CryptoBeginnerQuest { using SafeMath for uint256; address private administrator; address public miningWarAddress; CryptoEngineerInterface public Engineer; CryptoDepositInterface public Deposit; CryptoMiningWarInterface public MiningWar; CryptoAirdropGameInterface public AirdropGame; CryptoBossWannaCryInterface public BossWannaCry; CryptoArenaInterface public Arena; uint256 private miningWarDeadline; uint256 private miningWarRound; mapping(address => Player) private players; mapping(address => MinerQuest) private minerQuests; mapping(address => EngineerQuest) private engineerQuests; mapping(address => DepositQuest) private depositQuests; mapping(address => JoinAirdropQuest) private joinAirdropQuests; mapping(address => AtkBossQuest) private atkBossQuests; mapping(address => AtkPlayerQuest) private atkPlayerQuests; mapping(address => BoosterQuest) private boosterQuests; mapping(address => RedbullQuest) private redbullQuests; struct Player { uint256 miningWarRound; uint256 currentQuest; },1
0x77ceff4173a56cd22b6184fa59c668b364ae55b8.sol,CarTaxiIco,"contract CarTaxiIco is SafeMath { CarTaxiToken public cartaxiToken; AbstractToken public preIcoToken; enum State{ Pause, Init, Running, Stopped, Migrated }",1
0x4d7edd5f94515b0f35b38f6fb2ea975a20823465.sol,CryptoSprites,contract CryptoSprites is ERC721 { address public owner; address KittyCoreAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; address SaleClockAuctionAddress = 0xb1690C08E213a35Ed9bAb7B318DE14420FB57d8C; address charityAddress = 0xb30cb3b3E03A508Db2A0a3e07BA1297b47bb0fb1; uint public etherForOwner; uint public etherForCharity; uint public ownerCut = 15; uint public charityCut = 15; uint public featurePrice = 10**16; uint public priceMultiplier = 1; uint public priceDivider = 10; modifier onlyOwner { require(msg.sender == owner); _; },1
0x03358425ada4620246dd703dc1f2246b8e148d22.sol,BoomerangLiquidity,contract BoomerangLiquidity is Owned { modifier onlyOwner(){ require(msg.sender == owner); _; },1
0x37d6e7f287200c740012747d2a79295caed2db35.sol,ALPCoin,contract ALPCoin is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000 * (10 ** 8); address private owner; mapping(address => bool) private frozenAccount; mapping(address => bool) private burningAccount; uint256 tokenCount = 0; bool public frozen = false; bool public enabledBurning = true; bool public enabledCreateTokens = true; bool public enabledFreezeAccounts = true; bool public enabledFreezeTransfers = true; address public migratedToAddress; constructor() { owner = msg.sender; },1
0x39e8082b00c9f19ebf553e40feb7cf8459acc693.sol,DSStop,"contract DSStop is DSNote, DSAuth { bool public stopped; modifier stoppable { require(!stopped); _; }",1
0x2775f2a3c83bee1541d1d1bc308b3bb432b45151.sol,PLANETAGROToken,contract PLANETAGROToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 20000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function PLANETAGROToken () { owner = msg.sender; },1
0xc3e43d422d5e6f94315622d96a96058689c52ec8.sol,BitNauticCrowdsaleTokenDistributor,"contract BitNauticCrowdsaleTokenDistributor is Ownable { using SafeMath for uint256; uint256 public constant ICOStartTime = 1531267200; uint256 public constant ICOEndTime = 1536969600; uint256 public teamSupply = 3000000 * 10 ** 18; uint256 public bountySupply = 2500000 * 10 ** 18; uint256 public reserveSupply = 5000000 * 10 ** 18; uint256 public advisorSupply = 2500000 * 10 ** 18; uint256 public founderSupply = 2000000 * 10 ** 18; MintableToken public token; BitNauticWhitelist public whitelist; BitNauticCrowdsale public crowdsale; mapping (address => bool) public hasClaimedTokens; constructor(MintableToken _token, BitNauticWhitelist _whitelist, BitNauticCrowdsale _crowdsale) public { token = _token; whitelist = _whitelist; crowdsale = _crowdsale; }",1
0x0f5ee401de162cd163b6ff46318eef2727dbb9fc.sol,MOIRAICO,"contract MOIRAICO { enum State { Preico, Ico, Successful }",1
0x83686a73638ff46ee1eb5d28ff2179c41d1157aa.sol,ldoh,"contract ldoh is EthereumSmartContract { event onCashbackCode (address indexed hodler, address cashbackcode); event onAffiliateBonus (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onUnlocktoken (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onHoldplatform (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onAddContractAddress(address indexed contracthodler, bool contractstatus, uint256 _maxcontribution, string _ContractSymbol, uint256 _PercentPermonth, uint256 _HodlingTime); event onHoldplatformsetting(address indexed Tokenairdrop, bool HPM_status, uint256 HPM_divider, uint256 HPM_ratio, uint256 datetime); event onHoldplatformdeposit(uint256 amount, uint256 newbalance, uint256 datetime); event onHoldplatformwithdraw(uint256 amount, uint256 newbalance, uint256 datetime); address public DefaultToken; struct Safe { uint256 id; uint256 amount; uint256 endtime; address user; address tokenAddress; string tokenSymbol; uint256 amountbalance; uint256 cashbackbalance; uint256 lasttime; uint256 percentage; uint256 percentagereceive; uint256 tokenreceive; uint256 lastwithdraw; address referrer; bool cashbackstatus; }",1
0x77c9acc811e4cf4b51dc3a3e05dc5d62fa887767.sol,CrryptoArena,contract CrryptoArena { using SafeMath for uint256; address public administrator; uint256 public VIRUS_NORMAL = 0; uint256 public HALF_TIME_ATK= 60 * 15; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public VIRUS_MINING_PERIOD = 86400; address public engineerAddress; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; CryptoProgramFactoryInterface public Factory; mapping(address => Player) public players; mapping(uint256 => Virus) public viruses; mapping(address => bool) public miniGames; struct Player { uint256 virusDef; uint256 nextTimeAtk; uint256 endTimeUnequalledDef; },1
0x2791528f5617e187a6d73c30034ac211b2f47042.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol,MONEY_BOX,contract MONEY_BOX { struct Holder { uint unlockTime; uint balance; },1
0x5094f35a78dbe896c4f357bf9165448be40309de.sol,Preallocation,"contract Preallocation is Ownable { using SafeMath for uint; address public investor; uint public maxBalance; enum States { Pending, Success, Fail }",1
0x3420894bf786866a09937b0369d5b4781870c21f.sol,LikeCoin,"contract LikeCoin is ERC20, HasOperator { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public supply = 0; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; address public crowdsaleAddr = 0x0; address public contributorPoolAddr = 0x0; uint256 public contributorPoolMintQuota = 0; address[] public creatorsPoolAddrs; mapping(address => bool) isCreatorsPool; uint256 public creatorsPoolMintQuota = 0; mapping(address => uint256) public lockedBalances; uint public unlockTime = 0; SignatureChecker public signatureChecker = SignatureChecker(0x0); bool public signatureCheckerFreezed = false; address public signatureOwner = 0x0; bool public allowDelegate = true; mapping (address => mapping (uint256 => bool)) public usedNonce; mapping (address => bool) public transferAndCallWhitelist; event Lock(address indexed _addr, uint256 _value); event SignatureCheckerChanged(address _newSignatureChecker); function LikeCoin(uint256 _initialSupply, address _signatureOwner, address _sigCheckerAddr) public { supply = _initialSupply; balances[owner] = _initialSupply; signatureOwner = _signatureOwner; signatureChecker = SignatureChecker(_sigCheckerAddr); Transfer(0x0, owner, _initialSupply); }",1
0xecff8fc2a19f83fc855618704f38725756dbcae3.sol,OK3D,"contract OK3D is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x5015A6E288FF4AC0c62bf1DA237c24c3Fb849188); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 private rndGap_ = 2 minutes; uint256 constant private rndInit_ = 12 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(28,10); fees_[1] = F3Ddatasets.TeamFee(36,10); fees_[2] = F3Ddatasets.TeamFee(51,10); fees_[3] = F3Ddatasets.TeamFee(40,10); potSplit_[0] = F3Ddatasets.PotSplit(25,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(20,20); activated_ = true; rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; }",1
0xc849a5fff9befa297d1c3a772bafac9f3c9004ec.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x01d6208f95cf2292c350fc8bb1b1f29230352675.sol,DRCWalletManager,"contract DRCWalletManager is OwnerContract, Withdrawable, TokenDestructible { using SafeMath for uint256; struct WithdrawWallet { bytes32 name; address walletAddr; }",1
0x4026f73f99427c6b70c9b101321895cee6b72659.sol,VestingContract,"contract VestingContract is Owned { address public withdrawalAddress; address public tokenAddress; uint public lastBlockClaimed; uint public blockDelay; uint public reward; event ClaimExecuted(uint _amount, uint _blockNumber, address _destination); function VestingContract() { lastBlockClaimed = 4216530; blockDelay = 152470; reward = 1333333000000000000000000; tokenAddress = 0x2C974B2d0BA1716E644c1FC59982a89DDD2fF724; }",1
0x341f9c6c60c07fd11ef0bbc93586a2b9d68bfcf0.sol,VINContract,"contract VINContract is SafeMath { VINNDTokenContract public VINToken; enum Stage{ Pause, Init, Running, Stopped }",1
0x39f89421c5bf8bb0d855c0216b00b45e3733b515.sol,DINOSale,"contract DINOSale is BaseDINOSale { using SafeMath for uint256; DINOToken public tokenReward; constructor( address ifSuccessfulSendTo, uint fundingGoalInEthers, uint fundingCapInEthers, uint minimumContribution, uint start, uint end, uint rateDINOToEther, address addressOfTokenUsedAsReward ) public { require(ifSuccessfulSendTo != address(0) && ifSuccessfulSendTo != address(this), ); require(addressOfTokenUsedAsReward != address(0) && addressOfTokenUsedAsReward != address(this), ); require(fundingGoalInEthers <= fundingCapInEthers, ); require(end > 0, ); beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; fundingCap = fundingCapInEthers * 1 ether; minContribution = minimumContribution * 1 ether; startTime = start; endTime = end; rate = rateDINOToEther; withdrawRate = rateDINOToEther; tokenReward = DINOToken(addressOfTokenUsedAsReward); }",1
0xed8a2697d1af8f8cad0f6c5b9962d868d4ed2a41.sol,HUMPresale,"contract HUMPresale is WhitelistedCrowdsale, IndividuallyCappedCrowdsale { uint256 public constant minimum = 100000000000000000; bool public isOnSale = false; mapping(address => uint256) public bonusTokens; uint256 public bonusPercent; address[] public contributors; event DistrubuteBonusTokens(address indexed sender); event Withdraw(address indexed _from, uint256 _amount); constructor ( uint256 _rate, uint256 _bonusPercent, address _wallet, HUMToken _token, uint256 _individualCapEther ) public Crowdsale(_rate, _wallet, _token) IndividuallyCappedCrowdsale(_individualCapEther.mul(10 ** 18)) { bonusPercent = _bonusPercent; }",1
0x28f1135e43e61ebf303c8f1f9beef4f6a00dcb34.sol,XC,contract XCPlugin is XCPluginInterface { struct Admin { bool status; bytes32 platformName; bytes32 tokenSymbol; address account; string version; },1
0x430e87a95a421437ccaa0af644ac57e22914b07a.sol,PoolOwners,contract PoolOwners is Ownable { using SafeMath for uint256; using itmap for itmap.itmap; struct Owner { uint256 key; uint256 percentage; uint256 shareTokens; mapping(address => uint256) balance; },1
0xb613aa71ce4630e955548a61d089617e8e2f509a.sol,MomsAvenueCrowdsale,"contract MomsAvenueCrowdsale { using SafeMath for uint256; MomsAvenueToken public token; uint256 constant public rate = 10000; uint256 constant public goal = 20000000 * (10 ** 18); uint256 public startTime; uint256 public endTime; uint256 public weiRaised; uint256 public tokensSold; bool public crowdsaleActive = true; address public wallet; address public tokenOwner; mapping(address => uint256) balances; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function MomsAvenueCrowdsale(uint256 _startTime, uint256 _endTime, address _wallet, address _token, address _tokenOwner) public { require(_startTime < _endTime); require(_wallet != address(0)); require(_token != address(0)); require(_tokenOwner != address(0)); startTime = _startTime; endTime = _endTime; wallet = _wallet; tokenOwner = _tokenOwner; token = MomsAvenueToken(_token); }",1
0x5819f24d478e4630930bd97d640dd2fdabd0a4ff.sol,BulkToken,contract BulkToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function BulkToken () { owner = msg.sender; },1
0xb462d45329f4f3b4c670790ac355fb26eace41c8.sol,TokenVesting,"contract TokenVesting is Ownable { using SafeMath for uint256; using SafeERC20 for ERC20; event Released(uint256 amount); event Revoked(); address public beneficiary; uint256 public cliff; uint256 public start; uint256 public duration; bool public revocable; bool public revoked; uint256 public released; ERC20 public token; function TokenVesting( address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable, address _token ) { require(_beneficiary != 0x0); require(_cliff <= _duration); beneficiary = _beneficiary; start = _start; cliff = _start.add(_cliff); duration = _duration; revocable = _revocable; token = ERC20(_token); }",1
0xc0a1f89bbcaddab4b736e786b6b16c67bc92ed35.sol,GivethCampaign,"contract GivethCampaign is TokenController, Owned { uint public startFundingTime; uint public endFundingTime; uint public maximumFunding; uint public totalCollected; MiniMeToken public tokenContract; address public vaultAddress; function GivethCampaign( uint _startFundingTime, uint _endFundingTime, uint _maximumFunding, address _vaultAddress, address _tokenAddress ) { if ((_endFundingTime < now) || (_endFundingTime <= _startFundingTime) || (_maximumFunding > 10000000 ether) || (_vaultAddress == 0)) { throw; }",1
0x25b16c95f3ebb1d8583a1c173f81257bc916a9be.sol,SignalsCrowdsale,"contract SignalsCrowdsale is FinalizableCrowdsale { uint256 public constant HARD_CAP = 18000*(10**18); uint256 public toBeRaised = 18000*(10**18); uint256 public constant PRICE = 360000; uint256 public tokensSold; uint256 public constant maxTokens = 185000000*(10**9); uint constant ADVISORY_SHARE = 18500000*(10**9); uint constant BOUNTY_SHARE = 3700000*(10**9); uint constant COMMUNITY_SHARE = 37000000*(10**9); uint constant COMPANY_SHARE = 33300000*(10**9); uint constant PRESALE_SHARE = 7856217611546440; address constant ADVISORS = 0x98280b2FD517a57a0B8B01b674457Eb7C6efa842; address constant BOUNTY = 0x8726D7ac344A0BaBFd16394504e1cb978c70479A; address constant COMMUNITY = 0x90CDbC88aB47c432Bd47185b9B0FDA1600c22102; address constant COMPANY = 0xC010b2f2364372205055a299B28ef934f090FE92; address constant PRESALE = 0x7F3a38fa282B16973feDD1E227210Ec020F2481e; CrowdsaleRegister register; PrivateRegister register2; bool public ready; event SaleWillStart(uint256 time); event SaleReady(); event SaleEnds(uint256 tokensLeft); function SignalsCrowdsale(address _token, address _wallet, address _register, address _register2) public FinalizableCrowdsale() Crowdsale(_token, _wallet) { register = CrowdsaleRegister(_register); register2 = PrivateRegister(_register2); }",1
0x514bc174df04a4b04ae2be81ee8c788c3796b06b.sol,Deco,contract Deco is ERC20ERC223 { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant totalSupply = 6*10**26; mapping(address => Account) private accounts; struct Account { uint256 balance; mapping(address => uint256) allowed; mapping(address => bool) isAllowanceAuthorized; },1
0x01eacc3ae59ee7fbbc191d63e8e1ccfdac11628c.sol,FairWin,contract FairWin { uint ethWei = 1 ether; uint allCount = 0; uint oneDayCount = 0; uint totalMoney = 0; uint totalCount = 0; uint private beginTime = 1; uint lineCountTimes = 1; uint private currentIndex = 0; address private owner; uint private actStu = 0; constructor () public { owner = msg.sender; },1
0xc574fc434cb74344eaafe8bcc69ab1b12dbc01d8.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; token myToken; address public wallet; uint256 public rate = 1000000000 ; uint256 public weiRaised; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); constructor(address tokenContractAddress, address _walletAddress) public{ wallet = _walletAddress; myToken = token(tokenContractAddress); }",1
0xef58491224958d978facf55d2120c55a24516b98.sol,RegistryUpdater,contract RegistryUpdater is Ownable { address public polymathRegistry; address public moduleRegistry; address public securityTokenRegistry; address public tickerRegistry; address public polyToken; constructor (address _polymathRegistry) public { require(_polymathRegistry != address(0)); polymathRegistry = _polymathRegistry; },1
0x54923b4f2e4433294c70559cc94d1812793f0451.sol,Future1Exchange,contract Future1Exchange { address public archon; mapping (address => mapping(address => uint256)) public _token; constructor() public { archon = msg.sender; },1
0x750c1d91864171d7e1715a6b53ee28c72b8faa09.sol,EthicHubUser,"contract EthicHubUser is Ownable, EthicHubBase { event UserStatusChanged(address target, string profile, bool isRegistered); constructor(address _storageAddress) EthicHubBase(_storageAddress) public { version = 3; }",1
0x5c743a35e903f6c584514ec617acee0611cf44f3.sol,ExyToken,"contract ExyToken is ERC223MintableToken, SignatoryPausable { using SafeMath for uint256; VestingAllocation private partnerTokensAllocation; VestingAllocation private companyTokensAllocation; BountyTokenAllocation private bountyTokensAllocation; uint256 private constant ICO_TOKENS = 14503506112248500000000000; address private constant ICO_TOKENS_ADDRESS = 0x97c967524d1eacAEb375d4269bE4171581a289C7; uint256 private constant SEED_TOKENS = 11700000000000000000000000; address private constant SEED_TOKENS_ADDRESS = 0x7C32c7649aA1335271aF00cd4280f87166474778; uint256 private constant COMPANY_TOKENS_PER_PERIOD = 727875169784680000000000; uint256 private constant COMPANY_PERIODS = 36; uint256 private constant MINUTES_IN_COMPANY_PERIOD = 60 * 24 * 365 / 12; uint256 private constant PARTNER_TOKENS_PER_PERIOD = 23821369192953200000000000; uint256 private constant PARTNER_PERIODS = 1; uint256 private constant MINUTES_IN_PARTNER_PERIOD = MINUTES_IN_COMPANY_PERIOD * 18; uint256 private constant BOUNTY_TOKENS = 2382136919295320000000000; uint256 private constant MARKETING_COST_TOKENS = 794045639765106000000000; address private constant MARKETING_COST_ADDRESS = 0xF133ef3BE68128c9Af16F5aF8F8707f7A7A51452; uint256 public INIT_DATE; string public constant name = ; bytes32 public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant totalSupply = ( COMPANY_TOKENS_PER_PERIOD * COMPANY_PERIODS + PARTNER_TOKENS_PER_PERIOD * PARTNER_PERIODS + BOUNTY_TOKENS + MARKETING_COST_TOKENS + ICO_TOKENS + SEED_TOKENS); function ExyToken(address signatory0, address signatory1, address signatory2) SignatoryPausable(signatory0, signatory1, signatory2) public { INIT_DATE = block.timestamp; companyTokensAllocation = new VestingAllocation( COMPANY_TOKENS_PER_PERIOD, COMPANY_PERIODS, MINUTES_IN_COMPANY_PERIOD, INIT_DATE); partnerTokensAllocation = new VestingAllocation( PARTNER_TOKENS_PER_PERIOD, PARTNER_PERIODS, MINUTES_IN_PARTNER_PERIOD, INIT_DATE); bountyTokensAllocation = new BountyTokenAllocation( BOUNTY_TOKENS ); mint(MARKETING_COST_ADDRESS, MARKETING_COST_TOKENS); mint(ICO_TOKENS_ADDRESS, ICO_TOKENS); mint(SEED_TOKENS_ADDRESS, SEED_TOKENS); }",1
0xec8f9a0de90487e7aa172fe5291fd19ad7163aa1.sol,BDSMAirdrop,contract BDSMAirdrop { token public sharesTokenAddress; uint256 public tokenFree = 0; address owner; uint256 public defValue = 5000000; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x39de38ba63d172b962db2fc2ee5e4376287c50bf.sol,ImmlaIco,"contract ImmlaIco is SafeMath { ImmlaToken public immlaToken; AbstractToken public preIcoToken; address public escrow; address public icoManager; address public tokenImporter = 0x0; address public founder1; address public founder2; address public founder3; address public team; address public bountyOwner; uint public constant teamsReward = 38548226701232220000000000; uint public constant bountyOwnersTokens = 9361712198870680000000000; uint constant BASE = 1000000000000000000; uint public constant defaultIcoStart = 1505422800; uint public icoStart = defaultIcoStart; uint public constant defaultIcoDeadline = 1508101200; uint public icoDeadline = defaultIcoDeadline; uint public constant defaultFoundersRewardTime = 1521061200; uint public foundersRewardTime = defaultFoundersRewardTime; uint public constant minIcoTokenLimit = 18000000 * BASE; uint public constant maxIcoTokenLimit = 434477177 * BASE; uint public importedTokens = 0; uint public soldTokensOnIco = 0; uint public constant soldTokensOnPreIco = 13232941687168431951684000; uint tokenPrice1 = 3640; uint tokenSupply1 = 170053520 * BASE; uint tokenPrice2 = 3549; uint tokenSupply2 = 103725856 * BASE; uint tokenPrice3 = 3458; uint tokenSupply3 = 100319718 * BASE; uint tokenPrice4 = 3367; uint tokenSupply4 = 60378083 * BASE; uint[] public tokenPrices; uint[] public tokenSupplies; bool public initialized = false; bool public migrated = false; bool public sentTokensToFounders = false; bool public icoStoppedManually = false; mapping (address => uint) public balances; event BuyTokens(address buyer, uint value, uint amount); event WithdrawEther(); event StopIcoManually(); event SendTokensToFounders(uint founder1Reward, uint founder2Reward, uint founder3Reward); event ReturnFundsFor(address account); modifier whenInitialized() { require(initialized); _; }",1
0x4b96bf1fef93a216914fc843d81207a027ce52b3.sol,VUULRVesting,"contract VUULRVesting is XClaimable, Salvageable { using SafeMath for uint; struct VestingSchedule { uint lockPeriod; uint numPeriods; uint tokens; uint amountWithdrawn; uint startTime; }",1
0x750c1d91864171d7e1715a6b53ee28c72b8faa09.sol,EthicHubUser,"contract EthicHubUser is Ownable, EthicHubBase { event UserStatusChanged(address target, string profile, bool isRegistered); constructor(address _storageAddress) EthicHubBase(_storageAddress) public { version = 3; }",1
0x2e59c87e9349242063793761780550374a3146cf.sol,THORToken,contract THORToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 500000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function THORToken () { owner = msg.sender; },1
0x6a25216f75d7ee83d06e5fc6b96bcd52233bc69b.sol,MeltingContract,"contract MeltingContract is Owned{ address XaurumAddress; uint public XaurumAmountMelted; uint public GoldAmountMelted; event MeltDone(uint xaurAmount, uint goldAmount); function MeltingContract() public { XaurumAddress = 0x4DF812F6064def1e5e029f1ca858777CC98D2D81; }",1
0xcefa3e88393cf17c9b4dc6c9fe5357dfae8036d6.sol,Hold,"contract Hold is Ownable { uint8 stages = 5; uint8 public percentage; uint8 public currentStage; uint public initialBalance; uint public withdrawed; address public multisig; Registry registry; PermissionManager public permissionManager; uint nextContributorToTransferEth; address public observer; uint dateDeployed; mapping(address => bool) private hasWithdrawedEth; event InitialBalanceChanged(uint balance); event EthReleased(uint ethreleased); event EthRefunded(address contributor, uint ethrefunded); event StageChanged(uint8 newStage); event EthReturnedToOwner(address owner, uint balance); modifier onlyPermitted() { require(permissionManager.isPermitted(msg.sender) || msg.sender == owner); _; }",1
0x1cca91a47db357445b89269f2fb4f647cd209968.sol,Distribution,"contract Distribution is Owned { using SafeMath for uint256; Token token; event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); modifier whenDropIsActive() { assert(isActive()); _; }",1
0x0e54b1b8ff833b5f2b0d17453d97d340cb7576e4.sol,ERC223Token,"contract ERC223Token is IERC223, SafeMath { mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 35000000 * 10**8; function ERC223Token() { balances[msg.sender] = totalSupply; }",1
0x30d62b3392520580ffc74d7326bb29a4bf541a4d.sol,TerraformReserve,"contract TerraformReserve is Ownable { mapping (address => uint256) public lockedBalance; uint public totalLocked; ERC20 public manaToken; address public landClaim; bool public acceptingDeposits; event LockedBalance(address user, uint mana); event LandClaimContractSet(address target); event LandClaimExecuted(address user, uint value, bytes data); event AcceptingDepositsChanged(bool _acceptingDeposits); function TerraformReserve(address _token) { require(_token != 0); manaToken = ERC20(_token); acceptingDeposits = true; }",1
0x31d4c5be1082a88f2abafea549b6c189c2cf057f.sol,AetherClockAuction,"contract AetherClockAuction is ClockAuction { bool public isAetherClockAuction = true; uint256 public saleCount; uint256[5] public lastSalePrices; function AetherClockAuction(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x2716d9189adc5ee2fb35f193b79b5578c3d7bcda.sol,EthereumLegitAirDrop,"contract EthereumLegitAirDrop is Ownable { uint public numDrops; uint public dropAmount; token myToken; function EthereumLegitAirDrop(address dropper, address tokenContractAddress) { myToken = token(tokenContractAddress); transferOwnership(dropper); }",1
0xece0429a5130ebe0616363939067eefca4fbaceb.sol,BISK,"contract BISK is MiniMeToken { mapping (address => bool) public blacklisted; bool public generateFinished; constructor (address _tokenFactory) MiniMeToken( _tokenFactory, 0x0, 0, , 18, , false ) public { }",1
0x0e8175729e02db48ca0e2ca80efb72fe84a7dedd.sol,MechanicKittyUnit,"contract MechanicKittyUnit is ERC20, PremiumUnit { using SafeMath for uint; string public constant name = ; string public constant symbol = ; uint256 public constant unitId = 3; uint256 public unitProductionSeconds = 43200; uint8 public constant decimals = 0; Units constant units = Units(0xf936AA9e1f22C915Abf4A66a5a6e94eb8716BA5e); address constant factories = 0xC767B1CEc507f1584469E8efE1a94AD4c75e02ed; mapping(address => uint256) balances; mapping(address => uint256) lastEquipTime; mapping(address => mapping(address => uint256)) allowed; uint256 public totalSupply; function totalSupply() external view returns (uint) { return totalSupply.sub(balances[address(0)]); }",1
0x77c9acc811e4cf4b51dc3a3e05dc5d62fa887767.sol,CrryptoArena,contract CrryptoArena { using SafeMath for uint256; address public administrator; uint256 public VIRUS_NORMAL = 0; uint256 public HALF_TIME_ATK= 60 * 15; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public VIRUS_MINING_PERIOD = 86400; address public engineerAddress; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; CryptoProgramFactoryInterface public Factory; mapping(address => Player) public players; mapping(uint256 => Virus) public viruses; mapping(address => bool) public miniGames; struct Player { uint256 virusDef; uint256 nextTimeAtk; uint256 endTimeUnequalledDef; },1
0x4160836bd96bf4f2ed931bfefb3e00b3e68ad8f6.sol,PRHXToken,contract PRHXToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1200000000 * (10**0); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function PRHXToken () { owner = msg.sender; },1
0x6dbb4e882f967432fc0f9200e9ca577c916d8a68.sol,Bussiness,contract Bussiness is Ownable { IERC721 public erc721Address = IERC721(0x06012c8cf97bead5deae237070f9587f8e7a266d); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdAC17F958D2ee523a2206206994597C13D831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; uint256 public balance = address(this).balance; constructor() public {},1
0x58db9e7a4afca731d824eeefa55ce37666aa3eaf.sol,FoMoGame,"contract FoMoGame is modularLong { using SafeMath for *; using NameFilter for string; using F3DKeysCalcLong for uint256; ForwarderInterface constant private Team_Forwarder = ForwarderInterface(0xfe373e4c13ed07962ffa546d1f0be2298d5493b0); PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x463a61560e0EFF1a7ec771eeb9fd1c93fb075c2E); address private backup = 0x7298EFD119A830edab6C442632EEff14292609B0; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 private rndGap_ = 0; uint256 constant private rndInit_ = 1 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(36,0); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(66,0); fees_[3] = F3Ddatasets.TeamFee(50,0); potSplit_[0] = F3Ddatasets.PotSplit(20,0); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(40,0); potSplit_[3] = F3Ddatasets.PotSplit(45,0); }",1
0xeae2e3259d6d56451f4b3bc957ffbfcfaaebcac4.sol,CrowdsaleCompatible,"contract CrowdsaleCompatible is BasicERC20, Ownable { BasicCrowdsale public crowdsale = BasicCrowdsale(0x0); function unfreezeTokens() public { assert(now > crowdsale.endTime()); isTokenTransferable = true; }",1
0x3478c2e4ed6f64db0be9c483b87f70ff6ab0d65a.sol,MultiTokenNetwork,"contract MultiTokenNetwork is Pausable { event NewMultitoken(address indexed mtkn); event NewDeployer(uint256 indexed index, address indexed oldDeployer, address indexed newDeployer); address[] public multitokens; mapping(uint256 => IDeployer) public deployers; function multitokensCount() public view returns(uint256) { return multitokens.length; }",1
0x2791528f5617e187a6d73c30034ac211b2f47042.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x655f1cb6616d7f0550007498113e72d7d5c5d4bb.sol,MedalClaim,"contract MedalClaim is AccessControl, SafeMath { address public angelCardDataContract = 0x6D2E76213615925c5fc436565B5ee788Ee0E86DC; address public petCardDataContract = 0xB340686da996b8B3d486b4D27E38E38500A9E926; address public accessoryDataContract = 0x466c44812835f57b736ef9F63582b8a6693A14D0; address public leaderboardDataContract = 0x9A1C755305c6fbf361B4856c9b6b6Bbfe3aCE738; address public medalDataContract = 0x33A104dCBEd81961701900c06fD14587C908EAa3; event EventMedalSuccessful(address owner,uint64 Medal); struct Angel { uint64 angelId; uint8 angelCardSeriesId; address owner; uint16 battlePower; uint8 aura; uint16 experience; }",1
0x1cca91a47db357445b89269f2fb4f647cd209968.sol,Distribution,"contract Distribution is Owned { using SafeMath for uint256; Token token; event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); modifier whenDropIsActive() { assert(isActive()); _; }",1
0x6d7efeb3df42e6075fa7cf04e278d2d69e26a623.sol,LuckyYouToken,contract LuckyYouToken is PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; constructor() public{ totalSupply = 1 * 1000 * 1000 * 1000 * (10 ** uint256(decimals)); balances[owner] = totalSupply; },1
0x01d6208f95cf2292c350fc8bb1b1f29230352675.sol,DRCWalletManager,"contract DRCWalletManager is OwnerContract, Withdrawable, TokenDestructible { using SafeMath for uint256; struct WithdrawWallet { bytes32 name; address walletAddr; }",1
0x0e33ca464b1c76a384039eb1b7e9dc3b0416b5ae.sol,NamiCrowdSale,"contract NamiCrowdSale { using SafeMath for uint256; function NamiCrowdSale(address _escrow, address _namiMultiSigWallet, address _namiPresale) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; namiPresale = _namiPresale; }",1
0x84fe204e5d9f612d2fc92623f6b9bf980e816cb9.sol,RGO,"contract RGOinterface { function RGOFallback(address _from, uint _value, uint _code); }",1
0x27369e8f43f44c26853a46da7e6cb52d203b59ce.sol,AgileICOWithAssistance,contract AgileICOWithAssistance { using SafeMath for uint; address public operator; address public juryOperator; address public projectWallet; address public arbitrationAddress; address public juryOnlineWallet; bool public requireTokens; uint public promisedTokens; uint public etherAllowance; uint public jotAllowance; uint public commissionOnInvestmentJot; uint public commissionOnInvestmentEth; uint public percentForFuture; uint public rate = 1; address public currentCycleAddress; uint public currentCycleNumber; uint public currentFundingRound; uint public minimumInvestment; uint public lastRateChange; Token public token; struct Offer { uint etherAmount; uint tokenAmount; bool accepted; uint numberOfDeals; },1
0x020ddc98365d0199b4c7a2d769d685480789f67e.sol,EOSclassic,"contract EOSclassic is StandardToken, HasNoEther { string public constant NAME = ; string public constant SYMBOL = ; uint8 public constant DECIMALS = 18; uint public constant TOTAL_SUPPLY = 1000000000 * (10 ** uint(DECIMALS)); uint public constant foundersAllocation = 100000000 * (10 ** uint(DECIMALS)); address public constant eosTokenAddress = 0x86Fa049857E0209aa7D9e616F7eb3b3B78ECfdb0; address public constant eosCrowdsaleAddress = 0xd0a6E6C54DbC68Db5db3A091B171A77407Ff7ccf; mapping (address => string) public keys; mapping (address => bool) public eosClassicClaimed; event LogClaim (address user, uint amount); event LogRegister (address user, string key); constructor() public { totalSupply_ = TOTAL_SUPPLY; balances[address(this)] = TOTAL_SUPPLY; emit Transfer(0x0, address(this), TOTAL_SUPPLY); balances[address(this)] = balances[address(this)].sub(foundersAllocation); balances[msg.sender] = balances[msg.sender].add(foundersAllocation); emit Transfer(address(this), msg.sender, foundersAllocation); }",1
0x4c478ac32725872e30bca49957abc7dbb325cb21.sol,daocrowdsale,"contract daocrowdsale is Ownable { using SafeMath for uint256; bytes32 constant password = keccak256(); bytes32 constant fin = keccak256(); COIN public DAO; uint256 public constant price = 500 finney; enum State {READY, LAUNCHED, STAGE1, STAGE2, STAGE3, FAIL}",1
0xeda8b016efa8b1161208cf041cd86972eee0f31e.sol,BonusFinalizeAgent,"contract BonusFinalizeAgent is FinalizeAgent, SafeMathLib { CrowdsaleToken public token; Crowdsale public crowdsale; uint256 public allocatedTokens; uint256 tokenCap; address walletAddress; function BonusFinalizeAgent(CrowdsaleToken _token, Crowdsale _crowdsale, uint256 _tokenCap, address _walletAddress) public { token = _token; crowdsale = _crowdsale; require(address(crowdsale) != 0); tokenCap = _tokenCap; walletAddress = _walletAddress; }",1
0x21ad0028fea5fafa55b9b60e9c065db9f1c0616e.sol,LikeCrowdsale,"contract LikeCrowdsale is HasOperator { using SafeMath for uint256; LikeCoin public like = LikeCoin(0x0); uint public start = 0; uint public end = 0; uint256 public coinsPerEth = 0; mapping (address => bool) public kycDone; bool finalized = false; event PriceChanged(uint256 _newPrice); event AddPrivateFund(address indexed _addr, uint256 _value); event RegisterKYC(address indexed _addr); event Purchase(address indexed _addr, uint256 _ethers, uint256 _coins); event LikeTransfer(address indexed _to, uint256 _value); event Finalize(); function LikeCrowdsale(address _likeAddr, uint _start, uint _end, uint256 _coinsPerEth) public { require(_coinsPerEth != 0); require(now < _start); require(_start < _end); owner = msg.sender; like = LikeCoin(_likeAddr); start = _start; end = _end; coinsPerEth = _coinsPerEth; }",1
0xd1265bfe57597840f89971b7e67538bac780f9ad.sol,DesTokenSale,"contract DesTokenSale is Haltable { using SafeMath for uint; string public name = ; DesToken public token; address public beneficiary; uint public tokensSoldTotal = 0; uint public weiRaisedTotal = 0; uint public investorCount = 0; uint public tokensSelling = 0; uint public tokenPrice = 0; uint public purchaseLimit = 0; event NewContribution(address indexed holder, uint256 tokenAmount, uint256 etherAmount); function DesTokenSale( address _token, address _beneficiary ) { token = DesToken(_token); beneficiary = _beneficiary; }",1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x0692de52a966c107021e8a84db8486b4be57ecf1.sol,OQToken,contract OQToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function OQToken () { owner = msg.sender; },1
0x0e69d0a2bbb30abcb7e5cfea0e4fde19c00a8d47.sol,ContractLock,"contract ContractLock is DSStop { uint public unlockTime; mapping (address => bool) public isAdmin; event LogAddAdmin(address whoAdded, address newAdmin); event LogRemoveAdmin(address whoRemoved, address admin); constructor(uint _unlockTime) public { unlockTime = _unlockTime; isAdmin[msg.sender] = true; emit LogAddAdmin(msg.sender, msg.sender); }",1
0xce4a4d70e9942fff9dbb0219ead452a8fe082511.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 30240000; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x37338314A6E146EAd64FB656F6dbd9C0DCbf5bC2; }",1
0x52d3ec187457a106d2ec546be4cb8a11d9be2527.sol,MonsterAuction,contract MonsterAuctionBase { MonsterOwnership public nonFungibleContract; ChainMonstersCore public core; struct Auction { address seller; uint256 price; uint64 startedAt; uint256 id; },1
0x0dae7caf45d9c473a8f6ae0d4934e5c3b2dbc371.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; }",1
0x6ff869d8727ef71369dd33d7e6fd63da31ae203f.sol,STARTToken,contract STARTToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 500000000000 * (10**5); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function STARTToken () { owner = msg.sender; },1
0x6e3c384480e71792948c29e9fc8d7b9c9d75ae8f.sol,p_bank,"contract p_bank { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x00685230359bdb9e16704e1d3918b553e9a015e2.sol,Marketplace,contract Marketplace is Ownable { struct Ad { uint price; address exchanger; bool exists; bool active; },1
0x0333a8c69858382840ea4980d5550fcc632342f0.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; MintableToken public token; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public weiRaised; uint256 public tokensSold; uint256 constant public hardCap = 24000000 * (10**18); event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(uint256 _startTime, uint256 _endTime, address _wallet, MintableToken tokenContract) public { require(_startTime >= now); require(_endTime >= _startTime); require(_wallet != 0x0); startTime = _startTime; endTime = _endTime; wallet = _wallet; token = tokenContract; }",1
0xe3818504c1b32bf1557b16c238b2e01fd3149c17.sol,UnsoldAllocation,"contract UnsoldAllocation is Ownable { using SafeMath for uint; uint unlockedAt; uint allocatedTokens; PillarToken plr; mapping (address => uint) allocations; uint tokensCreated = 0; function UnsoldAllocation(uint _lockTime, address _owner, uint _tokens) { if(_lockTime == 0) throw; if(_owner == address(0)) throw; plr = PillarToken(msg.sender); uint lockTime = _lockTime * 1 years; unlockedAt = now.add(lockTime); allocatedTokens = _tokens; allocations[_owner] = _tokens; }",1
0x750c1d91864171d7e1715a6b53ee28c72b8faa09.sol,EthicHubUser,"contract EthicHubUser is Ownable, EthicHubBase { event UserStatusChanged(address target, string profile, bool isRegistered); constructor(address _storageAddress) EthicHubBase(_storageAddress) public { version = 3; }",1
0x0e33ca464b1c76a384039eb1b7e9dc3b0416b5ae.sol,NamiCrowdSale,"contract NamiCrowdSale { using SafeMath for uint256; function NamiCrowdSale(address _escrow, address _namiMultiSigWallet, address _namiPresale) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; namiPresale = _namiPresale; }",1
0x26613b4ca0cad3b418e49e19626c0ba3dd713673.sol,UNIT,contract UNIT is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 18000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function UNIT () { owner = msg.sender; },1
0x330bebabc9a2a4136e3d1cb38ca521f5a95aec2e.sol,KoreaShow,"contract KoreaShow is TokenController, Controlled { using SafeMath for uint256; uint256 public startFundingTime; uint256 public endFundingTime; uint256 constant public maximumFunding = 100 ether; uint256 public tokensPerEther = 31000; uint256 constant oneDay = 86400; uint256 public totalCollected = 0; bool public paused; string public techProvider = ; Token public tokenContract; bool public finalized = false; bool public allowChange = true; bool private transfersEnabled = true; address private vaultAddress; bool private initialed = false; event Payment(address indexed _sender, uint256 _ethAmount, uint256 _tokenAmount); function KoreaShow( uint _startFundingTime, uint _endFundingTime, address _vaultAddress, address _tokenAddress ) public { require(_endFundingTime > now); require(_endFundingTime >= _startFundingTime); require(_vaultAddress != 0); require(_tokenAddress != 0); require(!initialed); startFundingTime = _startFundingTime; endFundingTime = _endFundingTime; vaultAddress = _vaultAddress; tokenContract = Token(_tokenAddress); paused = false; initialed = true; }",1
0xeb36a7650ef32f0643d39cf5b7fcefd4319febb9.sol,Cycle,contract Cycle { using SafeMath for uint; address public juryOperator; address public operator; address public icoAddress; address public juryOnlineWallet; address public projectWallet; address public arbitrationAddress; Token public token; address public jotter; bool public saveMe; struct Milestone { uint etherAmount; uint tokenAmount; uint startTime; uint finishTime; uint duration; string description; string result; },1
0x0d5d4c289133ebf3eb685c183a930c1ee2ea4a4f.sol,I_BANK,"contract I_BANK { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x1d1ff336189f16fcb5aea6f00398c06bec5fd0cc.sol,casinoBank,"contract casinoBank is owned, safeMath{ uint public playerBalance; mapping(address=>uint) public balanceOf; mapping(address=>uint) public withdrawAfter; uint public gasPrice = 20; token edg; uint public closeAt; event Deposit(address _player, uint _numTokens, bool _chargeGas); event Withdrawal(address _player, address _receiver, uint _numTokens); function casinoBank(address tokenContract) public{ edg = token(tokenContract); }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,Court,"contract Court is Owned, SafeDecimalMath { Havven public havven; EtherNomin public nomin; uint public minStandingBalance = 100 * UNIT; uint public votingPeriod = 1 weeks; uint constant MIN_VOTING_PERIOD = 3 days; uint constant MAX_VOTING_PERIOD = 4 weeks; uint public confirmationPeriod = 1 weeks; uint constant MIN_CONFIRMATION_PERIOD = 1 days; uint constant MAX_CONFIRMATION_PERIOD = 2 weeks; uint public requiredParticipation = 3 * UNIT / 10; uint constant MIN_REQUIRED_PARTICIPATION = UNIT / 10; uint public requiredMajority = (2 * UNIT) / 3; uint constant MIN_REQUIRED_MAJORITY = UNIT / 2; uint nextMotionID = 1; mapping(uint => address) public motionTarget; mapping(address => uint) public targetMotionID; mapping(uint => uint) public motionStartTime; mapping(uint => uint) public votesFor; mapping(uint => uint) public votesAgainst; mapping(address => mapping(uint => uint)) voteWeight; enum Vote {Abstention, Yea, Nay}",1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,GoldBackedToken,"contract GoldBackedToken is Ownable, SafeMath, ERC20, Pausable { event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); event DeductFees(address indexed owner,uint256 amount); event TokenMinted(address destination, uint256 amount); event TokenBurned(address source, uint256 amount); string public name = ; string public symbol = ; uint256 constant public decimals = 18; uint256 constant public hgtDecimals = 8; uint256 constant public allocationPool = 1 * 10**9 * 10**hgtDecimals; uint256 constant public maxAllocation = 38 * 10**5 * 10**decimals; uint256 public totAllocation; address public feeCalculator; address public HGT; function setFeeCalculator(address newFC) onlyOwner { feeCalculator = newFC; }",1
0x47d4cc3d331525976553baff7c9e4d410087804a.sol,Proxy,"contract Proxy { Contract contr; uint256 public eth_balance; ERC20 public token; mapping (address => bool) public withdrew; address owner; constructor(address _contract, address _token) { owner = msg.sender; contr = Contract(_contract); token = ERC20(_token); eth_balance = contr.contract_eth_value_bonus(); }",1
0xb4933b15b21924af2c18012c4da78b182f060107.sol,ERC20x,"contract ERC20xVariables { address public creator; address public lib; uint256 constant public MAX_UINT256 = 2**256 - 1; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) public allowed; uint8 public constant decimals = 18; string public name; string public symbol; uint public totalSupply; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Created(address creator, uint supply); function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; }",1
0x5b82f83eeb171f829e5ca6d2c6205cd22ce7b821.sol,FBBCToken,"contract FBBCToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 625; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0x0e752b742f744fdc2d93774da44c37b72c3e6952.sol,CraftyCrowdsale,"contract CraftyCrowdsale is Pausable { using SafeMath for uint256; mapping(address => uint256) received; MintableToken public token; uint256 public preSaleStart; uint256 public preSaleEnd; uint256 public saleStart; uint256 public saleEnd; uint256 public issuedTokens = 0; uint256 public constant hardCap = 5000000000 * 10**8; uint256 constant teamCap = 1450000000 * 10**8; uint256 constant advisorCap = 450000000 * 10**8; uint256 constant bountyCap = 100000000 * 10**8; uint256 constant fundCap = 3000000000 * 10**8; uint256 constant lockTime = 180 days; address public etherWallet; address public teamWallet; address public advisorWallet; address public fundWallet; address public bountyWallet; TokenTimelock teamTokens; uint256 public rate; enum State { BEFORE_START, SALE, REFUND, CLOSED }",1
0x1b6c5864375b34af3ff5bd2e5f40bc425b4a8d79.sol,TopChainCoinDistribution,"contract TopChainCoinDistribution is Ownable, Authorizable { using SafeMath for uint; event AuthorizedCreateToPrivate(address recipient, uint pay_amount); event GameMining(address recipient, uint pay_amount); event CreateTokenToTeam(address recipient, uint pay_amount); event CreateTokenToMarket(address recipient, uint pay_amount); event CreateTokenToOperation(address recipient, uint pay_amount); event TopChainCoinMintFinished(); TopChainCoin public token = new TopChainCoin(); DateTime internal dateTime = new DateTime(); uint totalToken = 2100000000 * (10 ** 6); uint public privateTokenCap = 210000000 * (10 ** 6); uint public marketToken = 315000000 * (10 ** 6); uint public operationToken = 210000000 * (10 ** 6); uint public gameMiningTokenCap = 1155000000 * (10 ** 6); uint public teamToken2018 = 105000000 * (10 ** 6); uint public teamToken2019 = 105000000 * (10 ** 6); uint public privateToken = 0; address public teamAddress; address public operationAddress; address public marketAddress; bool public team2018TokenCreated = false; bool public team2019TokenCreated = false; bool public operationTokenCreated = false; bool public marketTokenCreated = false; mapping(uint16 => uint) public gameMiningToken; uint public firstYearGameMiningTokenCap = 577500000 * (10 ** 6); uint public gameMiningTokenStartTime = 1514736000; function isContract(address _addr) internal view returns(bool) { uint size; if (_addr == 0) return false; assembly { size := extcodesize(_addr) }",1
0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f.sol,PERSONAL_BANK,contract PERSONAL_BANK { mapping (address=>uint256) public balances; uint public MinSum = 1 ether; LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46); bool intitalized; function SetMinSum(uint _val) public { if(intitalized)revert(); MinSum = _val; },1
0x24a7de87b3bd7298bbf8966fdf170c558d69ecc4.sol,METADOLLAR,"contract METADOLLAR is ERC20Interface, Owned, SafeMath { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public _totalSupply = 1000000000000000000000000000000; uint256 public icoMin = 1000000000000000; uint256 public icoLimit = 1000000000000000000000000000000; uint256 public countHolders = 0; uint256 public amountOfInvestments = 0; uint256 public icoPrice; uint256 public dolRate = 1000; uint256 public ethRate = 1; uint256 public sellRate = 900; uint256 public commissionRate = 1000; uint256 public sellPrice; uint256 public currentTokenPrice; uint256 public commission; bool public icoIsRunning; bool public minimalGoalReached; bool public icoIsClosed; mapping (address => uint256) public tokenBalanceOf; mapping(address => mapping (address => uint256)) allowed; mapping(address => bool) frozenAccount; event FrozenFunds(address initiator, address account, string status); event BonusChanged(uint8 bonusOld, uint8 bonusNew); event minGoalReached(uint256 minIcoAmount, string notice); event preIcoEnded(uint256 preIcoAmount, string notice); event priceUpdated(uint256 oldPrice, uint256 newPrice, string notice); event withdrawed(address _to, uint256 summe, string notice); event deposited(address _from, uint256 summe, string notice); event orderToTransfer(address initiator, address _from, address _to, uint256 summe, string notice); event tokenCreated(address _creator, uint256 summe, string notice); event tokenDestroyed(address _destroyer, uint256 summe, string notice); event icoStatusUpdated(address _initiator, string status); function STARTMETADOLLAR() { icoIsRunning = true; minimalGoalReached = false; icoIsClosed = false; tokenBalanceOf[this] += _totalSupply; allowed[this][owner] = _totalSupply; allowed[this][supervisor] = _totalSupply; currentTokenPrice = 1 * 1; icoPrice = ethRate * dolRate; sellPrice = sellRate * ethRate; updatePrices(); }",1
0x91dfe531ff8ba876a505c8f1c98bafede6c7effc.sol,MatchingMarket,"contract MatchingMarket is MatchingEvents, ExpiringMarket, DSNote { bool public buyEnabled = true; bool public matchingEnabled = true; struct sortInfo { uint next; uint prev; uint delb; }",1
0xb462d45329f4f3b4c670790ac355fb26eace41c8.sol,TerraformReserve,"contract TerraformReserve is Ownable { mapping (address => uint256) public lockedBalance; uint public totalLocked; ERC20 public manaToken; address public landClaim; bool public acceptingDeposits; event LockedBalance(address user, uint mana); event LandClaimContractSet(address target); event LandClaimExecuted(address user, uint value, bytes data); event AcceptingDepositsChanged(bool _acceptingDeposits); function TerraformReserve(address _token) { require(_token != 0); manaToken = ERC20(_token); acceptingDeposits = true; }",1
0xce5dbd884305a5716460dccffa63888fc9bfaa72.sol,FreezeTokensWallet,contract FreezeTokensWallet is Ownable { using SafeMath for uint256; MintableToken public token; bool public started; uint public startLockPeriod = 180 days; uint public period = 360 days; uint public duration = 90 days; uint public startUnlock; uint public retrievedTokens; uint public startBalance; modifier notStarted() { require(!started); _; },1
0x4bd22737812e4412879aacf0b400131e1ee0a4a5.sol,Controller,"contract Controller is ControllerInterface, OwnableContract, OwnableContractOwner { WrappedToken public token; MembersInterface public members; address public factory; constructor(WrappedToken _token) public { require(_token != address(0), ); token = _token; }",1
0xc3e43d422d5e6f94315622d96a96058689c52ec8.sol,BitNauticCrowdsaleTokenDistributor,"contract BitNauticCrowdsaleTokenDistributor is Ownable { using SafeMath for uint256; uint256 public constant ICOStartTime = 1531267200; uint256 public constant ICOEndTime = 1536969600; uint256 public teamSupply = 3000000 * 10 ** 18; uint256 public bountySupply = 2500000 * 10 ** 18; uint256 public reserveSupply = 5000000 * 10 ** 18; uint256 public advisorSupply = 2500000 * 10 ** 18; uint256 public founderSupply = 2000000 * 10 ** 18; MintableToken public token; BitNauticWhitelist public whitelist; BitNauticCrowdsale public crowdsale; mapping (address => bool) public hasClaimedTokens; constructor(MintableToken _token, BitNauticWhitelist _whitelist, BitNauticCrowdsale _crowdsale) public { token = _token; whitelist = _whitelist; crowdsale = _crowdsale; }",1
0x25b16c95f3ebb1d8583a1c173f81257bc916a9be.sol,CommunityPool,"contract CommunityPool is Ownable{ SignalsToken token; event CommunityTokensAllocated(address indexed member, uint amount); function CommunityPool(address _token, address _owner) public{ token = SignalsToken(_token); owner = _owner; }",1
0x1784e5aec9ad99445663dbca9462a618bfe545ac.sol,NebliDex_AtomicSwap_ERC20,contract NebliDex_AtomicSwap_ERC20 { struct Swap { uint256 timelock; uint256 erc20Value; address erc20Trader; address erc20ContractAddress; address withdrawTrader; bytes32 secretLock; bytes secretKey; },1
0xcdf35c3fe4ccfacb3b1bbedfe71ca3a5ff6f2db1.sol,DevTokensHolder,"contract DevTokensHolder is Ownable { using SafeMath for uint256; uint256 collectedTokens; GenericCrowdsale crowdsale; MyDFSToken token; event ClaimedTokens(address token, uint256 amount); event TokensWithdrawn(address holder, uint256 amount); event Debug(uint256 amount); function DevTokensHolder(address _crowdsale, address _token, address _owner) public { crowdsale = GenericCrowdsale(_crowdsale); token = MyDFSToken(_token); owner = _owner; }",1
0x517c8bbb18d69d7d8f059175f612d556670b22c3.sol,AirDropAFTKSeven,"contract AirDropAFTKSeven is Ownable { Token token; mapping(address => uint256) public redeemBalanceOf; event BalanceSet(address indexed beneficiary, uint256 value); event Redeemed(address indexed beneficiary, uint256 value); event BalanceCleared(address indexed beneficiary, uint256 value); event TokenSendStart(address indexed beneficiary, uint256 value); event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); function AirDropAFTKSeven() public { address _tokenAddr = 0x7fa2f70bd4c4120fdd539ebd55c04118ba336b9e; token = Token(_tokenAddr); }",1
0x70cdbd16575651e3b78fa869a51eb8e991e079bb.sol,PRVTSToken,contract PRVTSToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 555000000 * (10**2); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function PRVTSToken () { owner = msg.sender; },1
0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0.sol,Play0x_LottoBall,contract Play0x_LottoBall { using SafeMath for uint256; using SafeMath for uint128; using SafeMath for uint40; using SafeMath for uint8; uint public jackpotSize; uint public tokenJackpotSize; uint public MIN_BET; uint public MAX_BET; uint public MAX_AMOUNT; uint public maxProfit; uint public maxTokenProfit; uint8 public platformFeePercentage = 15; uint8 public jackpotFeePercentage = 5; uint8 public ERC20rewardMultiple = 5; uint constant BetExpirationBlocks = 250; uint public lockedInBets; uint public lockedTokenInBets; bytes32 bitComparisonMask = 0xF; address public owner; address private nextOwner; address public manager; address private nextManager; address[] public secretSignerList; address public ERC20ContractAddres; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Bet { uint amount; uint40 placeBlockNumber; address gambler; },1
0x35c2307cd831741187d4ef71ce9fbe91fa822df5.sol,BOX33Token,"contract BOX33Token is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 2680; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0x7976af0ae2124a0771d5287aa16017b3f9dd43a4.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; bool transferable; modifier isTransferable() { require(transferable || msg.sender == owner); _; },1
0x3fd30f3e1fbf4f3ea6bdf3e3bb11826266708869.sol,AgroTechFarmCrowdsale,"contract AgroTechFarmCrowdsale is Ownable { using SafeMath for uint; uint8 public decimals = 18; AgroTechFarmToken public token; uint256 public constant SUPPLY_FOR_SALE = 3250000 * (10 ** uint(decimals)); uint256 public constant SUPPLY_FOR_RESERVE = 500000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_MARKETING = 350000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_TEAM = 300000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_REFERAL = 250000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_ADVISORSL = 150000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_PARTNERSHIPS = 100000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_BOOUNTY = 100000 * (10 ** uint256(decimals)); address public multisig; uint public rate; uint public start; uint public end; bool public tokenSpread = false; uint public softcap; enum State { Active, Refunding, Closed }",1
0x71aaf9dc418e9dde76aee42e431fc203d9cfd0c2.sol,VestingContractWTTEST,contract VestingContractWTTEST { struct AccountData { uint original_balance; uint limit_per_period; uint current_balance; uint current_limit; uint current_transferred; },1
0x56ffb3c578906ba9658fccb052fc1a5672275b6a.sol,OpiriaCrowdsale,"contract OpiriaCrowdsale is TimedPresaleCrowdsale, MintedCrowdsale, TokenCappedCrowdsale { using SafeMath for uint256; uint256 public presaleWeiLimit; address public tokensWallet; uint256 public totalBonus = 0; bool public hiddenCapTriggered; uint16 public additionalBonusPercent = 0; mapping(address => uint256) public bonusOf; constructor(ERC20 _token, uint16 _initialEtherUsdRate, address _wallet, address _tokensWallet, uint256 _presaleOpeningTime, uint256 _presaleClosingTime, uint256 _openingTime, uint256 _closingTime ) public TimedPresaleCrowdsale(_presaleOpeningTime, _presaleClosingTime, _openingTime, _closingTime) Crowdsale(_initialEtherUsdRate, _wallet, _token) { setEtherUsdRate(_initialEtherUsdRate); tokensWallet = _tokensWallet; require(PausableToken(token).paused()); }",1
0x4c84949b55f21a376dba12e732958ede8b033b0e.sol,TokenVesting,contract TokenVesting { using SafeMath for uint256; struct VestingGrant { bool isGranted; address issuer; address beneficiary; uint256 grantJiffys; uint256 startTimestamp; uint256 cliffTimestamp; uint256 endTimestamp; bool isRevocable; uint256 releasedJiffys; },1
0xa5d6accc5695327f65cbf38da29198df53efdcf0.sol,Private_accumulation_fund,contract Private_accumulation_fund { mapping (address => uint) public balances; uint public MinDeposit = 1 ether; Log TransferLog; function Private_accumulation_fund(address _log) public { TransferLog = Log(_log); },1
0x3ac86159fad58c90aaea1c61974d69d4f8ce8e77.sol,Crowdsale,contract Crowdsale is Ownable { using SafeMath for uint256; SingleTokenCoin public token; WrapperOraclize private wrapper = WrapperOraclize(0xfC484c66daE464CC6055d7a4782Ec8761dc9842F); uint256 private angel_sale_start; uint256 private angel_sale_finish; uint256 private pre_sale_start; uint256 private pre_sale_finish; uint256 private public_sale_start; uint256 private public_sale_finish; bool private isAngel; bool private isPreSale; bool private isPublic; uint256 private angel_rate; uint256 private public_rate; uint256 private decimals; uint256 private totalETH; address public coreTeamAddr; address public itDevAddr; address public futDevAddr; address public commFoundAddr; address public socWarefareAddr; address public marketingAddr; address public unsoldAddr; address public collectAddr; bool public mintingFinished = false; mapping(address => uint256) private founding_buyers_token; mapping(address => uint256) private angel_buyers_eth; mapping(address => uint256) private angel_buyers_token; mapping(address => uint256) private pre_sale_buyers_eth; mapping(address => uint256) private pre_sale_buyers_token; mapping(address => uint256) private pe_buyers_token; mapping(address => uint256) private public_buyers_eth; mapping(address => uint256) private public_buyers_token; address[] private founding_investors; address[] private pre_sale_investors; address[] private angel_investors; address[] private pe_investors; address[] private public_investors; uint256 private soldTokens; uint256 private maxcup; uint256 private totalAmount; uint256 private foundingAmount; uint256 private angelAmount; uint256 private preSaleAmount; uint256 private PEInvestorAmount; uint256 private publicSaleAmount; uint256 private coreTeamAmount; uint256 private coreTeamAuto; uint256 private coreTeamManual; uint256 private itDevAmount; uint256 private futDevAmount; uint256 private commFoundAmount; uint256 private socWarefareAmount; uint256 private marketingAmount; uint256 private angel_sale_sold; uint256 private pre_sale_sold; uint256 private public_sale_sold; uint256 private founding_sold; uint256 private peInvestors_sold; uint256 private angel_sale_totalETH; uint256 private pre_sale_totalETH; uint256 private public_sale_totalETH; uint256 private firstPhaseAmount; uint256 private secondPhaseAmount; uint256 private thirdPhaseAmount; uint256 private fourPhaseAmount; uint256 private firstPhaseDiscount; uint256 private secondPhaseDiscount; uint256 private thirdPhaseDiscount; uint256 private fourPhaseDiscount; uint256 private currentPhase; bool private moveTokens; bool withdrowTokensComplete = false; function Crowdsale(address token_addr) { token = SingleTokenCoin(token_addr); public_rate = 3546099290780141; angel_rate = 20; decimals = 35460992907801; angel_sale_start = now - 3 days; angel_sale_finish = 1510488000; pre_sale_start = 1510491600; pre_sale_finish = 1512561600; public_sale_start = 1512565200; public_sale_finish = public_sale_start + 14 days; moveTokens = false; isAngel = true; isPreSale = false; isPublic = false; currentPhase = 1; founding_sold = 0; peInvestors_sold = 0; angel_sale_sold = 0; pre_sale_sold = 0; public_sale_sold = 0; angel_sale_totalETH = 0; pre_sale_totalETH = 0; public_sale_totalETH = 0; firstPhaseAmount = 18750000E18; secondPhaseAmount = 37500000E18; thirdPhaseAmount = 56250000E18; fourPhaseAmount = 75000000E18; firstPhaseDiscount = 30; secondPhaseDiscount = 40; thirdPhaseDiscount = 50; fourPhaseDiscount = 60; totalAmount = 500000000E18; foundingAmount = 10000000E18; angelAmount = 25000000E18; preSaleAmount = 75000000E18; PEInvestorAmount = 50000000E18; publicSaleAmount = 100000000E18; coreTeamAmount = 100000000E18; coreTeamAuto = 60000000E18; coreTeamManual = 40000000E18; itDevAmount = 50000000E18; futDevAmount = 50000000E18; commFoundAmount = 15000000E18; socWarefareAmount = 10000000E18; marketingAmount = 15000000E18; mintingFinished = false; coreTeamAddr = 0xB0A3A845cfA5e2baCD3925Af85c59dE4D32D874f; itDevAddr = 0x61528ffdCd4BC26c81c88423018780b399Fbb8e7; futDevAddr = 0xA1f9C3F137496e6b8bA4445d15b0986CaA22FDe3; commFoundAddr = 0xC30a0E7FFad754A9AD2A1C1cFeB10e05f7C7aB6A; socWarefareAddr = 0xd5d692C89C83313579d02C94F4faE600fe30D1d9; marketingAddr = 0x5490510072b929273F65dba4B72c96cd45A99b5A; unsoldAddr = 0x18051b5b0F1FDb4D44eACF2FA49f19bB80105Fc1; collectAddr = 0xB338121B8e5dA0900a6E8580321293f3CF52E58D; },1
0xb613aa71ce4630e955548a61d089617e8e2f509a.sol,MomsAvenueCrowdsale,"contract MomsAvenueCrowdsale { using SafeMath for uint256; MomsAvenueToken public token; uint256 constant public rate = 10000; uint256 constant public goal = 20000000 * (10 ** 18); uint256 public startTime; uint256 public endTime; uint256 public weiRaised; uint256 public tokensSold; bool public crowdsaleActive = true; address public wallet; address public tokenOwner; mapping(address => uint256) balances; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function MomsAvenueCrowdsale(uint256 _startTime, uint256 _endTime, address _wallet, address _token, address _tokenOwner) public { require(_startTime < _endTime); require(_wallet != address(0)); require(_token != address(0)); require(_tokenOwner != address(0)); startTime = _startTime; endTime = _endTime; wallet = _wallet; tokenOwner = _tokenOwner; token = MomsAvenueToken(_token); }",1
0x702bcee7f521060eacde63e487a4c36ef7405f50.sol,PLAASCrowdsale,"contract PLAASCrowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward; uint256 public price = 1000; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PLAASCrowdsale() { wallet = 0xA8dd9A671d64DB4380AcA5af8976aE6F863fF169; addressOfTokenUsedAsReward = 0x8d9626315e8025b81c3bdb926db4c51dde237f52; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x403860568bcd726ec403f8a1ca67f374e842f16c.sol,CrowdDevAllocation,contract CrowdDevAllocation is Owned { CrowdCoin public token; uint public initial_time; address tokens_multisig; mapping(uint => bool) public unlocked; mapping(uint => uint) public unlock_times; mapping(uint => uint) unlock_values; function CrowdDevAllocation(address _token) { token = CrowdCoin(_token); },1
0xa136c92b43643a5aabf7e8fdf44f25d90bf78b9e.sol,Kman,contract Kman{ modifier onlyOwner() { require(msg.sender == owner); _; },1
0xdc919494349e803fbd2d4064106944418381edb3.sol,DSStop,"contract DSStop is DSNote, DSAuth { bool public stopped; modifier stoppable { require(!stopped); _; }",1
0x4c13184721de2d1b47a8875775ba3ce0b2e00ee0.sol,SharkPool,"contract SharkPool is Ownable, ReentrancyGuard { string constant public pool_name = ; uint256 public pool_percentage = 5; uint256 constant public max_users = 100; uint256 public total_users = 0; uint256 public constant divisible_units = 10000000; uint256 public contract_period = 100; uint256 public mined_blocks = 1; uint256 public claimed_blocks = 1; uint256 public blockCreationRate = 0; BitcoineumInterface base_contract; struct user { uint256 start_block; uint256 end_block; uint256 proportional_contribution; }",1
0xdc919494349e803fbd2d4064106944418381edb3.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }",1
0x707f0612cbbfa02284e02b0010b4f859bb7308ec.sol,CrowdsaleL,"contract CrowdsaleL{ using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0xa304100e0d17a972f34ed8a961034ce2fc47f9ca.sol,FomoBet,contract FomoBet { using SafeMath for uint; struct bet { address maker; address taker; uint256 round; bool longOrShort; bool validated; uint256 betEnd; uint256 betSize; },1
0x25b16c95f3ebb1d8583a1c173f81257bc916a9be.sol,PresalePool,"contract PresalePool is Ownable { PresaleToken public PublicPresale; PresaleToken public PartnerPresale; SignalsToken token; CrowdsaleRegister registry; uint256 compensation1; uint256 compensation2; uint256 deadLine; event SupporterResolved(address indexed supporter, uint256 burned, uint256 created); event PartnerResolved(address indexed partner, uint256 burned, uint256 created); function PresalePool(address _token, address _registry, address _owner, uint comp1, uint comp2) public { owner = _owner; PublicPresale = PresaleToken(0x15fEcCA27add3D28C55ff5b01644ae46edF15821); PartnerPresale = PresaleToken(0xa70435D1a3AD4149B0C13371E537a22002Ae530d); token = SignalsToken(_token); registry = CrowdsaleRegister(_registry); compensation1 = comp1; compensation2 = comp2; deadLine = now + 30 days; }",1
0x25066b77ae6174d372a9fe2b1d7886a2be150e9b.sol,PolarisDEX,"contract PolarisDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); function PolarisDEX(address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x0ee14f47320604d894fffffc8639772382937bee.sol,OpportyWhiteListHold,contract OpportyWhiteListHold is Ownable { using SafeMath for uint256; OpportyToken public OppToken; struct Holder { bool isActive; uint tokens; uint8 holdPeriod; uint holdPeriodTimestamp; bool withdrawed; },1
0xeb86a173e0311a28cadc24f85dbad867bbf34f73.sol,Bussiness,contract Bussiness is Ownable { address public ceoAddress = address(0x6c3e879bdd20e9686cfd9bbd1bfd4b2dd6d47079); IERC721 public erc721Address = IERC721(0xdceaf1652a131f32a821468dc03a92df0edd86ea); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdac17f958d2ee523a2206206994597c13d831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; constructor() public {},1
0xa136c92b43643a5aabf7e8fdf44f25d90bf78b9e.sol,Kman,contract Kman{ modifier onlyOwner() { require(msg.sender == owner); _; },1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDView,"contract BitSTDView { BitSTDLogic private logic; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function balanceOf(address add)constant public returns (uint256) { return logic.balanceOf(add); }",1
0xa27f262391913a5e21216c70de5358a1e887de25.sol,VestingContractWTTEST,contract VestingContractWTTEST { struct AccountData { uint original_balance; uint limit_per_period; uint current_balance; uint current_limit; uint current_transferred; },1
0x486681bb877703e4385c8fe9688bff776cbc11c4.sol,Escapable,"contract Escapable is Owned { address public escapeHatchCaller; address public escapeHatchDestination; mapping (address=>bool) private escapeBlacklist; function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) { escapeHatchCaller = _escapeHatchCaller; escapeHatchDestination = _escapeHatchDestination; }",1
0xdc919494349e803fbd2d4064106944418381edb3.sol,SaiVox,contract SaiVox is DSThing { uint256 _par; uint256 _way; uint256 public fix; uint256 public how; uint256 public tau; function SaiVox(uint par_) public { _par = fix = par_; _way = RAY; tau = era(); },1
0x284b0f2f49d072836db87dd25d0623cd2f622bb1.sol,DesTokenSale,"contract DesTokenSale is Haltable { using SafeMath for uint; string public name = ; DesToken public token; address public beneficiary; uint public tokensSoldTotal = 0; uint public weiRaisedTotal = 0; uint public investorCount = 0; uint public tokensSelling = 0; uint public tokenPrice = 0; uint public purchaseLimit = 0; event NewContribution(address indexed holder, uint256 tokenAmount, uint256 etherAmount); function DesTokenSale( address _token, address _beneficiary ) { token = DesToken(_token); beneficiary = _beneficiary; }",1
0x4cf488387f035ff08c371515562cba712f9015d4.sol,WPR,"contract WPR is MintableToken, PausableToken { string constant public name = ; string constant public symbol = ; uint constant public decimals = 18; function WPR() { }",1
0xdc919494349e803fbd2d4064106944418381edb3.sol,SaiVox,contract SaiVox is DSThing { uint256 _par; uint256 _way; uint256 public fix; uint256 public how; uint256 public tau; function SaiVox(uint par_) public { _par = fix = par_; _way = RAY; tau = era(); },1
0xef86db910c71ffa3c80233bc9108dc51ad1e008a.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,EtherNomin,"contract EtherNomin is ExternStateProxyFeeToken { address public oracle; Court public court; address public beneficiary; uint public nominPool; uint public poolFeeRate = UNIT / 200; uint constant MINIMUM_PURCHASE = UNIT / 100; uint constant MINIMUM_ISSUANCE_RATIO = 2 * UNIT; uint constant AUTO_LIQUIDATION_RATIO = UNIT; uint constant DEFAULT_LIQUIDATION_PERIOD = 90 days; uint constant MAX_LIQUIDATION_PERIOD = 180 days; uint public liquidationPeriod = DEFAULT_LIQUIDATION_PERIOD; uint public liquidationTimestamp = ~uint(0); uint public etherPrice; uint public lastPriceUpdate; uint public stalePeriod = 2 days; mapping(address => bool) public frozen; function EtherNomin(address _havven, address _oracle, address _beneficiary, uint initialEtherPrice, address _owner, TokenState initialState) ExternStateProxyFeeToken(, , 15 * UNIT / 10000, _havven, initialState, _owner) public { oracle = _oracle; beneficiary = _beneficiary; etherPrice = initialEtherPrice; lastPriceUpdate = now; emit PriceUpdated(etherPrice); frozen[this] = true; }",1
0x655f1cb6616d7f0550007498113e72d7d5c5d4bb.sol,MedalClaim,"contract MedalClaim is AccessControl, SafeMath { address public angelCardDataContract = 0x6D2E76213615925c5fc436565B5ee788Ee0E86DC; address public petCardDataContract = 0xB340686da996b8B3d486b4D27E38E38500A9E926; address public accessoryDataContract = 0x466c44812835f57b736ef9F63582b8a6693A14D0; address public leaderboardDataContract = 0x9A1C755305c6fbf361B4856c9b6b6Bbfe3aCE738; address public medalDataContract = 0x33A104dCBEd81961701900c06fD14587C908EAa3; event EventMedalSuccessful(address owner,uint64 Medal); struct Angel { uint64 angelId; uint8 angelCardSeriesId; address owner; uint16 battlePower; uint8 aura; uint16 experience; }",1
0xebf0027ef3b4b7a742a148cddb0f2b14e5d8f0e9.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); constructor(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; }",1
0x75a17c63c2121447655955b55aaa1a413e750232.sol,CryderCrowdsale,contract CryderCrowdsale is Ownable { using SafeMath for uint256; address public wallet; CryderToken public presaleToken; CryderToken public token; bool public isBountyAllocated = false; mapping(address => bool) tokenRequests; uint public START_TIME = 1516467600; uint public CLOSE_TIME = 1519146000; uint256 public HARDCAP = 400000000000000000000000000; uint256 public exchangeRate = 3000; address public bounty = 0xa258Eb1817aA122acBa4Af66A7A064AE6E10552A; function () payable public { require(msg.sender == tx.origin); buyTokens(msg.sender); },1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ClockAuction,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0xf1afddbed214dba82cb98d46ad0a96e643f7f6f6.sol,StarbaseEarlyPurchaseAmendment,contract StarbaseEarlyPurchaseAmendment { event EarlyPurchaseInvalidated(uint256 epIdx); event EarlyPurchaseAmended(uint256 epIdx); AbstractStarbaseCrowdsale public starbaseCrowdsale; StarbaseEarlyPurchase public starbaseEarlyPurchase; address public owner; uint256[] public invalidEarlyPurchaseIndexes; uint256[] public amendedEarlyPurchaseIndexes; mapping (uint256 => StarbaseEarlyPurchase.EarlyPurchase) public amendedEarlyPurchases; modifier noEther() { require(msg.value == 0); _; },1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,LockinManager,contract LockinManager { using SafeMath for uint256; struct Lock { uint256 amount; uint256 unlockDate; uint256 lockedFor; },1
0xee68907c93b57d57a1c4d60940ff1b310e18e467.sol,ICOBuyer,"contract ICOBuyer is Ownable { event EtherReceived(address indexed _contributor, uint256 _amount); event EtherWithdrawn(uint256 _amount); event TokensWithdrawn(uint256 _balance); event ICOPurchased(uint256 _amount); event ICOStartBlockChanged(uint256 _icoStartBlock); event ExecutorChanged(address _executor); event CrowdSaleChanged(address _crowdSale); event TokenChanged(address _token); event PurchaseCapChanged(uint256 _purchaseCap); uint256 public icoStartBlock; address public crowdSale; address public executor; uint256 public purchaseCap; modifier onlyExecutorOrOwner() { require((msg.sender == executor) || (msg.sender == owner)); _; }",1
0x335c949c06fa1ba8744d98e3aa2c2a2deaa9255c.sol,Exchanger,"contract Exchanger is Administered, tokenRecipient { bool public enabled = false; ITradeableAsset public tokenContract; IYeekFormula public formulaContract; uint32 public weight; uint32 public fee=5000; uint32 public multiplier=1; uint32 public collectedFees=0; constructor(address _token, uint32 _weight, address _formulaContract) { require (_weight > 0 && weight <= 1000000); weight = _weight; tokenContract = ITradeableAsset(_token); formulaContract = IYeekFormula(_formulaContract); }",1
0x46c9f93c3249c430c6ca19f02240ef9e038ba9d1.sol,Escapable,"contract Escapable is Owned { address public escapeHatchCaller; address public escapeHatchDestination; mapping (address=>bool) private escapeBlacklist; function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) { escapeHatchCaller = _escapeHatchCaller; escapeHatchDestination = _escapeHatchDestination; }",1
0x56ffb3c578906ba9658fccb052fc1a5672275b6a.sol,OpiriaCrowdsale,"contract OpiriaCrowdsale is TimedPresaleCrowdsale, MintedCrowdsale, TokenCappedCrowdsale { using SafeMath for uint256; uint256 public presaleWeiLimit; address public tokensWallet; uint256 public totalBonus = 0; bool public hiddenCapTriggered; uint16 public additionalBonusPercent = 0; mapping(address => uint256) public bonusOf; constructor(ERC20 _token, uint16 _initialEtherUsdRate, address _wallet, address _tokensWallet, uint256 _presaleOpeningTime, uint256 _presaleClosingTime, uint256 _openingTime, uint256 _closingTime ) public TimedPresaleCrowdsale(_presaleOpeningTime, _presaleClosingTime, _openingTime, _closingTime) Crowdsale(_initialEtherUsdRate, _wallet, _token) { setEtherUsdRate(_initialEtherUsdRate); tokensWallet = _tokensWallet; require(PausableToken(token).paused()); }",1
0xc3e43d422d5e6f94315622d96a96058689c52ec8.sol,BitNauticCrowdsaleTokenDistributor,"contract BitNauticCrowdsaleTokenDistributor is Ownable { using SafeMath for uint256; uint256 public constant ICOStartTime = 1531267200; uint256 public constant ICOEndTime = 1536969600; uint256 public teamSupply = 3000000 * 10 ** 18; uint256 public bountySupply = 2500000 * 10 ** 18; uint256 public reserveSupply = 5000000 * 10 ** 18; uint256 public advisorSupply = 2500000 * 10 ** 18; uint256 public founderSupply = 2000000 * 10 ** 18; MintableToken public token; BitNauticWhitelist public whitelist; BitNauticCrowdsale public crowdsale; mapping (address => bool) public hasClaimedTokens; constructor(MintableToken _token, BitNauticWhitelist _whitelist, BitNauticCrowdsale _crowdsale) public { token = _token; whitelist = _whitelist; crowdsale = _crowdsale; }",1
0x3639d5dc956e35540fbd1de691870fb1318d6783.sol,SNTGiveaway,"contract SNTGiveaway is Controlled { mapping(address => bool) public sentToAddress; mapping(bytes5 => bool) public codeUsed; ERC20Token public SNT; uint public ethAmount; uint public sntAmount; bytes32 public root; event AddressFunded(address dest, bytes5 code, uint ethAmount, uint sntAmount); constructor(address _sntAddress, uint _ethAmount, uint _sntAmount, bytes32 _root) public { SNT = ERC20Token(_sntAddress); ethAmount = _ethAmount; sntAmount = _sntAmount; root = _root; }",1
0x750c1d91864171d7e1715a6b53ee28c72b8faa09.sol,EthicHubUser,"contract EthicHubUser is Ownable, EthicHubBase { event UserStatusChanged(address target, string profile, bool isRegistered); constructor(address _storageAddress) EthicHubBase(_storageAddress) public { version = 3; }",1
0xa5e5be69c923c701ae6ac8f1f5936af3ae610c68.sol,Collectables,"contract Collectables is ERC721Full(, ), Ownable { using Strings for string; mapping(uint32 => address) public delegates; uint32[] public collectables; uint public delegateCount; event DelegateAdded(address indexed delegate, uint32 indexed delegateID); function addDelegate(address delegate) public onlyOwner { uint32 delegateID = uint32(delegateCount++); require(delegates[delegateID] == address(0), ); delegates[delegateID] = delegate; emit DelegateAdded(delegate, delegateID); }",1
0x9297a9d824e2f2d6f2dff2b871cb9e2f3f4f77d2.sol,RegistryUpdater,contract RegistryUpdater is Ownable { address public polymathRegistry; address public moduleRegistry; address public securityTokenRegistry; address public tickerRegistry; address public polyToken; constructor (address _polymathRegistry) public { require(_polymathRegistry != address(0)); polymathRegistry = _polymathRegistry; },1
0x6c764fac2ed1c5fabf8bcd86bae68d8cdbe8290e.sol,BaseWallet,"contract BaseWallet { address public implementation; address public owner; mapping (address => bool) public authorised; mapping (bytes4 => address) public enabled; uint public modules; event AuthorisedModule(address indexed module, bool value); event EnabledStaticCall(address indexed module, bytes4 indexed method); event Invoked(address indexed module, address indexed target, uint indexed value, bytes data); event Received(uint indexed value, address indexed sender, bytes data); event OwnerChanged(address owner); modifier moduleOnly { require(authorised[msg.sender], ); _; }",1
0x25066b77ae6174d372a9fe2b1d7886a2be150e9b.sol,PolarisDEX,"contract PolarisDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); function PolarisDEX(address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x0e69d0a2bbb30abcb7e5cfea0e4fde19c00a8d47.sol,ContractLock,"contract ContractLock is DSStop { uint public unlockTime; mapping (address => bool) public isAdmin; event LogAddAdmin(address whoAdded, address newAdmin); event LogRemoveAdmin(address whoRemoved, address admin); constructor(uint _unlockTime) public { unlockTime = _unlockTime; isAdmin[msg.sender] = true; emit LogAddAdmin(msg.sender, msg.sender); }",1
0xeb71e963645f1e76f233f70e1b0815e8f089bbc8.sol,SimplePHXExchange,contract SimplePHXExchange { uint public ScaleFactor = 10 ** 18; address[] public tknOfferors; mapping(address => uint256) public tknAddrNdx; mapping(address => uint256) public tknTokensOffered; mapping(address => uint256) public tknPricePerToken; address[] public ethOfferors; mapping(address => uint256) public ethAddrNdx; mapping(address => uint256) public ethEtherOffered; mapping(address => uint256) public ethPricePerToken; ERC20Token public phxCoin; function SimplePHXExchange() public { phxCoin = ERC20Token(0x14b759A158879B133710f4059d32565b4a66140C); tknOfferors.push(0x0); ethOfferors.push(0x0); },1
0x6bd33d49d48f76abcd96652e5347e398aa3fda96.sol,BancorBuyer,contract BancorBuyer { mapping (address => uint) public balances; uint public reward; bool public bought_tokens; uint public time_bought; address sale = 0xBbc79794599b19274850492394004087cBf89710; address token = 0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C; address developer = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e; function withdraw(){ uint amount = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(amount); },1
0x2f5c4a85d7e133c4fefa5a0c0ba1447a1af86996.sol,GetSaiTubValues,contract GetSaiTubValues { SaiTub public saiTub = SaiTub(0x448a5065aeBB8E423F0896E6c5D525C040f59af3); bytes32 public cup; uint public tab; uint public rap; uint public din; uint public chi; uint public rhi; function updateTabRap(bytes32 _cup) public { cup = _cup; tab = saiTub.tab(_cup); rap = saiTub.rap(_cup); },1
0x6f8544edb3f513845135b0efa907f4b6b9c2c92e.sol,BW,contract BWData { address public owner; address private bwService; address private bw; address private bwMarket; uint private blockValueBalance = 0; uint private feeBalance = 0; uint private BASE_TILE_PRICE_WEI = 1 finney; mapping (address => User) private users; mapping (uint16 => Tile) private tiles; struct User { uint creationTime; bool censored; uint battleValue; },1
0x1d8cd6eab10ab7d673fa7b4c5f93fe167953d4f9.sol,TokenVault,"contract TokenVault is Ownable { address owner; event TokenTransfer(address indexed to, address token, uint amount); function withdrawTokenTo(address token, address to) public onlyOwner returns (bool) { uint amount = balanceOfToken(token); if (amount > 0) { TokenTransfer(to, token, amount); return Token(token).transfer(to, amount); }",1
0x6593a7140f3718efff638b72a9b6083db47ce0d2.sol,Crowdsale,"contract Crowdsale is GuidedByRoles, ERC20Provider{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 90 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x503a7b43335e035bdfec030d2ef718449d985050.sol,LTToken,"contract LTToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 300; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal pure returns (uint256 ) { return _value * 10 ** decimals; }",1
0x35fd00d47202b1b2158dba75e7cc8f71b068c256.sol,TokenVesting,contract TokenVesting is Ownable { using SafeMath for uint; struct TokenHolder { uint weiReceived; uint tokensToSend; bool refunded; uint releasedAmount; bool revoked; },1
0x6d0a44fb6a416da6efe1c192560be1bccd01f6be.sol,Presale,contract PresaleMarket is PausableSimple { struct Auction { address seller; uint256 price; },1
0x01d6208f95cf2292c350fc8bb1b1f29230352675.sol,DRCWalletManager,"contract DRCWalletManager is OwnerContract, Withdrawable, TokenDestructible { using SafeMath for uint256; struct WithdrawWallet { bytes32 name; address walletAddr; }",1
0x330bebabc9a2a4136e3d1cb38ca521f5a95aec2e.sol,KoreaShow,"contract KoreaShow is TokenController, Controlled { using SafeMath for uint256; uint256 public startFundingTime; uint256 public endFundingTime; uint256 constant public maximumFunding = 100 ether; uint256 public tokensPerEther = 31000; uint256 constant oneDay = 86400; uint256 public totalCollected = 0; bool public paused; string public techProvider = ; Token public tokenContract; bool public finalized = false; bool public allowChange = true; bool private transfersEnabled = true; address private vaultAddress; bool private initialed = false; event Payment(address indexed _sender, uint256 _ethAmount, uint256 _tokenAmount); function KoreaShow( uint _startFundingTime, uint _endFundingTime, address _vaultAddress, address _tokenAddress ) public { require(_endFundingTime > now); require(_endFundingTime >= _startFundingTime); require(_vaultAddress != 0); require(_tokenAddress != 0); require(!initialed); startFundingTime = _startFundingTime; endFundingTime = _endFundingTime; vaultAddress = _vaultAddress; tokenContract = Token(_tokenAddress); paused = false; initialed = true; }",1
0x01d28329619796bae733e849696f80a764422700.sol,BaseTokenSale,"contract BaseTokenSale is TokenController, Controlled { using SafeMath for uint256; uint256 public startFundingTime; uint256 public endFundingTime; uint256 constant public maximumFunding = 1951 ether; uint256 public maxFunding; uint256 public minFunding = 0.001 ether; uint256 public tokensPerEther = 41000; uint256 constant public maxGasPrice = 50000000000; uint256 constant oneDay = 86400; uint256 public totalCollected = 0; bool public paused; Token public tokenContract; bool public finalized = false; bool public allowChange = true; bool private transfersEnabled = true; address private vaultAddress; bool private initialed = false; event Payment(address indexed _sender, uint256 _ethAmount, uint256 _tokenAmount); function BaseTokenSale( uint _startFundingTime, uint _endFundingTime, address _vaultAddress, address _tokenAddress ) public { require(_endFundingTime > now); require(_endFundingTime >= _startFundingTime); require(_vaultAddress != 0); require(_tokenAddress != 0); require(!initialed); startFundingTime = _startFundingTime; endFundingTime = _endFundingTime; vaultAddress = _vaultAddress; tokenContract = Token(_tokenAddress); paused = false; initialed = true; }",1
0x3400696045f706f3309927cb8fdf63f07b616c6f.sol,InviteCollateralizer,contract InviteCollateralizer is Ownable { using SafeMath for uint256; using SafeERC20 for ERC20; ERC20 public blt; address public seizedTokensWallet; mapping (address => Collateralization[]) public collateralizations; uint256 public collateralAmount = 1e17; uint64 public lockupDuration = 1 years; address private collateralTaker; address private collateralSeizer; struct Collateralization { uint256 value; uint64 releaseDate; bool claimed; },1
0x4bc78f6619991b029b867b6d88d39c196332aba3.sol,AlgoDEX,"contract AlgoDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x4cb200957a11cbff512b4752e6ee38c9253fdd54.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDView,"contract BitSTDView { BitSTDLogic private logic; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function balanceOf(address add)constant public returns (uint256) { return logic.balanceOf(add); }",1
0xb4007597da3402a1e2b69c8e1c6dd753d01a8035.sol,FundingManager,"contract FundingManager is ApplicationAsset { ABIFunding FundingEntity; ABITokenManager TokenManagerEntity; ABIToken TokenEntity; ABITokenSCADAVariable TokenSCADAEntity; ABIProposals ProposalsEntity; ABIMilestones MilestonesEntity; uint256 public LockedVotingTokens = 0; event EventFundingManagerReceivedPayment(address indexed _vault, uint8 indexed _payment_method, uint256 indexed _amount ); event EventFundingManagerProcessedVault(address _vault, uint256 id ); mapping (address => address) public vaultList; mapping (uint256 => address) public vaultById; uint256 public vaultNum = 0; function setAssetStates() internal { EntityStates[] = 0; EntityStates[] = 1; EntityStates[] = 2; EntityStates[] = 10; EntityStates[] = 11; EntityStates[] = 12; EntityStates[] = 20; EntityStates[] = 21; EntityStates[] = 22; EntityStates[] = 25; EntityStates[] = 30; EntityStates[] = 31; EntityStates[] = 32; EntityStates[] = 40; EntityStates[] = 41; EntityStates[] = 42; EntityStates[] = 100; EntityStates[] = 101; EntityStates[] = 102; RecordStates[] = 0; }",1
0x6c602f1798a453f90f249e208e2b64c7c09226f7.sol,Mentoring,"contract Mentoring is Ownable, ReentrancyGuard, CanReclaimToken { using SafeMath for uint256; event BecomeMentor(uint256 indexed mentorId); event BreakMentoring(uint256 indexed mentorId); event ChangeLevelPrice(uint256 indexed mentorId, uint256 newLevelPrice); event Income(address source, uint256 amount); event StartLecture(uint256 indexed lectureId, uint256 indexed mentorId, uint256 indexed studentId, uint256 mentorLevel, uint256 studentLevel, uint256 levelUp, uint256 levelPrice, uint256 startedAt, uint256 endsAt); struct Lecture { uint256 mentorId; uint256 studentId; uint256 mentorLevel; uint256 studentLevel; uint256 levelUp; uint256 levelPrice; uint256 startedAt; uint256 endsAt; }",1
0xeb86a173e0311a28cadc24f85dbad867bbf34f73.sol,Bussiness,contract Bussiness is Ownable { address public ceoAddress = address(0x6c3e879bdd20e9686cfd9bbd1bfd4b2dd6d47079); IERC721 public erc721Address = IERC721(0xdceaf1652a131f32a821468dc03a92df0edd86ea); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdac17f958d2ee523a2206206994597c13d831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; constructor() public {},1
0x6c26dab04c8f2bb07e60f205118e36850fe90981.sol,PoWMLottery,contract PoWMLottery { using SafeMath for uint256; bool public isLotteryOpen = false; address POWM_address = address(0xA146240bF2C04005A743032DC0D241ec0bB2BA2B); POWM maths = POWM(POWM_address); address owner; mapping (uint256 => address) public gamblers; mapping (address => uint256) public token_buyins; mapping (address => uint256) public last_round_bought; uint256 public num_tickets_current_round = 0; uint256 public current_round = 0; uint256 public numTokensInLottery = 0; address masternode_referrer; uint256 public MAX_TOKEN_BUYIN = 25; function PoWMLottery() public { current_round = 1; owner = msg.sender; masternode_referrer = msg.sender; },1
0x01d28329619796bae733e849696f80a764422700.sol,BaseTokenSale,"contract BaseTokenSale is TokenController, Controlled { using SafeMath for uint256; uint256 public startFundingTime; uint256 public endFundingTime; uint256 constant public maximumFunding = 1951 ether; uint256 public maxFunding; uint256 public minFunding = 0.001 ether; uint256 public tokensPerEther = 41000; uint256 constant public maxGasPrice = 50000000000; uint256 constant oneDay = 86400; uint256 public totalCollected = 0; bool public paused; Token public tokenContract; bool public finalized = false; bool public allowChange = true; bool private transfersEnabled = true; address private vaultAddress; bool private initialed = false; event Payment(address indexed _sender, uint256 _ethAmount, uint256 _tokenAmount); function BaseTokenSale( uint _startFundingTime, uint _endFundingTime, address _vaultAddress, address _tokenAddress ) public { require(_endFundingTime > now); require(_endFundingTime >= _startFundingTime); require(_vaultAddress != 0); require(_tokenAddress != 0); require(!initialed); startFundingTime = _startFundingTime; endFundingTime = _endFundingTime; vaultAddress = _vaultAddress; tokenContract = Token(_tokenAddress); paused = false; initialed = true; }",1
0x1a661224edc279a3844ecd8bd0cd715daafb9cf7.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 27820800; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x7eB71add7482F3462BAA46328f58a235E33dbD0e; }",1
0x284b0f2f49d072836db87dd25d0623cd2f622bb1.sol,DesTokenSale,"contract DesTokenSale is Haltable { using SafeMath for uint; string public name = ; DesToken public token; address public beneficiary; uint public tokensSoldTotal = 0; uint public weiRaisedTotal = 0; uint public investorCount = 0; uint public tokensSelling = 0; uint public tokenPrice = 0; uint public purchaseLimit = 0; event NewContribution(address indexed holder, uint256 tokenAmount, uint256 etherAmount); function DesTokenSale( address _token, address _beneficiary ) { token = DesToken(_token); beneficiary = _beneficiary; }",1
0x52c52944eaac353f054902225e1df036589fb6d7.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public wallet; address addressOfTokenUsedAsReward; token tokenReward; uint256 public startTime; uint256 public endTime; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() { wallet = 0x205E2ACd291E235425b5c10feC8F62FE7Ec26063; addressOfTokenUsedAsReward = 0x82B99C8a12B6Ee50191B9B2a03B9c7AEF663D527; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x4900320fe47208de0b79db1273a78ab8c8f3528d.sol,Crowdsale,contract Crowdsale is Owned { using SafeMath for uint256; uint256 public fundingGoal; uint256 public price; uint256 public transferableToken; uint256 public soldToken; uint256 public deadline; uint256 public token_price; MontexToken public tokenReward; bool public fundingGoalReached = false; bool public isOpened; mapping (address => Property) public fundersProperty; struct Property { uint256 paymentEther; uint256 reservedToken; },1
0x341f9c6c60c07fd11ef0bbc93586a2b9d68bfcf0.sol,VINContract,"contract VINContract is SafeMath { VINNDTokenContract public VINToken; enum Stage{ Pause, Init, Running, Stopped }",1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiCrowdSale,"contract NamiCrowdSale { using SafeMath for uint256; function NamiCrowdSale(address _escrow, address _namiMultiSigWallet, address _namiPresale) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; namiPresale = _namiPresale; }",1
0xda4cc8c36e6abef5d309e9fc3ae0209cabd078c0.sol,PriceFeed,"contract PriceFeed is DSThing { uint128 val; uint32 public zzz; function peek() public view returns (bytes32,bool) { return (bytes32(val), now < zzz); }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,Court,"contract Court is Owned, SafeDecimalMath { Havven public havven; EtherNomin public nomin; uint public minStandingBalance = 100 * UNIT; uint public votingPeriod = 1 weeks; uint constant MIN_VOTING_PERIOD = 3 days; uint constant MAX_VOTING_PERIOD = 4 weeks; uint public confirmationPeriod = 1 weeks; uint constant MIN_CONFIRMATION_PERIOD = 1 days; uint constant MAX_CONFIRMATION_PERIOD = 2 weeks; uint public requiredParticipation = 3 * UNIT / 10; uint constant MIN_REQUIRED_PARTICIPATION = UNIT / 10; uint public requiredMajority = (2 * UNIT) / 3; uint constant MIN_REQUIRED_MAJORITY = UNIT / 2; uint nextMotionID = 1; mapping(uint => address) public motionTarget; mapping(address => uint) public targetMotionID; mapping(uint => uint) public motionStartTime; mapping(uint => uint) public votesFor; mapping(uint => uint) public votesAgainst; mapping(address => mapping(uint => uint)) voteWeight; enum Vote {Abstention, Yea, Nay}",1
0x0ce95ef378059f38c5fa21e6d81a5895c0d9911b.sol,Game,contract Game { using GlobalTypes for GlobalTypes.Global; using MarketTypes for MarketTypes.MarketListing; using MissionParametersTypes for MissionParametersTypes.MissionParameters; using GameCommon for GameCommon.LaunchRocketStackFrame; address public m_Owner; AbstractDatabase public m_Database; AbstractGameHidden public m_GameHidden; bool public m_Paused; uint256 constant GlobalCategory = 0; uint256 constant RocketCategory = 1; uint256 constant OwnershipCategory = 2; uint256 constant InventoryCategory = 3; uint256 constant MarketCategory = 4; uint256 constant ProfitFundsCategory = 5; uint256 constant CompetitionFundsCategory = 6; uint256 constant MissionParametersCategory = 7; uint256 constant CompetitionScoresCategory = 8; uint256 constant WithdrawalFundsCategory = 9; uint256 constant ReferralCategory = 10; uint256 constant RocketStockCategory = 11; uint256 constant RocketStockInitializedCategory = 12; address constant NullAddress = 0; uint256 constant MaxCompetitionScores = 10; mapping(uint32 => RocketTypes.StockRocket) m_InitialRockets; modifier OnlyOwner() { require(msg.sender == m_Owner); _; },1
0x57bcc647eb77dfe185ede00a2720443c004f298a.sol,LFSTYLToken,contract LFSTYLToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 10000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function LFSTYLToken () { owner = msg.sender; },1
0x201ec0bcc05d43c44a05836c6d5ce42e93cceccc.sol,ReleaseToken,contract ReleaseToken is OwnerContract { using SafeMath for uint256; struct TimeRec { uint256 amount; uint256 remain; uint256 endTime; uint256 releasePeriodEndTime; },1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,Token,"contract Token { using SafeMath for uint256; mapping (address => uint256) public balances; mapping(address => mapping (address => uint256)) allowed; address[] allTokenHolders; string public name; string public symbol; uint8 public decimals; uint256 totalSupplyAmount = 0; address public refundManagerContractAddress; AuthenticationManager authenticationManager; LockinManager lockinManager; function availableBalance(address _owner) constant returns(uint256) { uint256 length = lockinManager.getLocks(_owner); uint256 lockedValue = 0; for(uint256 i = 0; i < length; i++) { if(lockinManager.getLocksUnlockDate(_owner, i) > now) { uint256 _value = lockinManager.getLocksAmount(_owner, i); lockedValue = lockedValue.add(_value); }",1
0x4176f0f2b7c95486a5ae06e3d1b29201a42e7630.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0xbc97f1508fdeb0a63b25f3a4806b62ef5370e8ab.sol,CryptoBeginnerQuest,contract CryptoBeginnerQuest { using SafeMath for uint256; address private administrator; address public miningWarAddress; CryptoEngineerInterface public Engineer; CryptoDepositInterface public Deposit; CryptoMiningWarInterface public MiningWar; CryptoAirdropGameInterface public AirdropGame; CryptoBossWannaCryInterface public BossWannaCry; CryptoArenaInterface public Arena; uint256 private miningWarDeadline; uint256 private miningWarRound; mapping(address => Player) private players; mapping(address => MinerQuest) private minerQuests; mapping(address => EngineerQuest) private engineerQuests; mapping(address => DepositQuest) private depositQuests; mapping(address => JoinAirdropQuest) private joinAirdropQuests; mapping(address => AtkBossQuest) private atkBossQuests; mapping(address => AtkPlayerQuest) private atkPlayerQuests; mapping(address => BoosterQuest) private boosterQuests; mapping(address => RedbullQuest) private redbullQuests; struct Player { uint256 miningWarRound; uint256 currentQuest; },1
0x019e41a2acdffafc0303e840fbd7934234e68f45.sol,contractDeployer,"contract contractDeployer is Ownable { event ContractCreated(address newAddress); address public tokenAddr; uint public tokenFee; uint public crowdsaleFee; uint public multisendFee; ERC20 token; cDeployer cdep; tDeployer tdep; function setUp(address _token, address _cdep, address _tdep) public onlyOwner { tokenAddr = _token; token = ERC20(tokenAddr); cdep = cDeployer(_cdep); tdep = tDeployer(_tdep); }",1
0x5a9e485a792b164007c6c76d15f8fa36c19ca631.sol,Token,"contract Token is Ownable, ERC20Interface, Enums { using SafeMath for uint; string private constant NAME = ; string private constant SYMBOL = ; uint8 private constant DECIMALS = 18; uint public constant MAX_SUPPLY = 3000000000 * (10**uint(DECIMALS)); mapping(address => uint) internal balances; mapping (address => mapping (address => uint)) internal allowed; uint internal _totalSupply; mapping(address => uint) internal etherFunds; uint internal _earnedFunds; mapping(address => bool) internal refunded; address public mintAgent; bool public isMintingFinished = false; uint public mintingStopDate; uint public teamTotal; uint public spentByTeam; WPTokensBaskets public wpTokensBaskets; function Token(WPTokensBaskets baskets) public { wpTokensBaskets = baskets; mintAgent = owner; }",1
0xa2795a7bf26de447a2e83d0779bab6badffb1a3b.sol,DrupeICO,"contract DrupeICORef { address _referrer; DrupeICO _ico; constructor(address referrer, DrupeICO ico) public { _referrer = referrer; _ico = ico; }",1
0x846387983cae97bc816edde9f309f25d09203e04.sol,WGWToken,contract WGWToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 2150400000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function WGWToken () { owner = msg.sender; },1
0xcf106b9644eb97deb5b78ab22da160ffca67a448.sol,BaseWallet,"contract BaseWallet { address public implementation; address public owner; mapping (address => bool) public authorised; mapping (bytes4 => address) public enabled; uint public modules; event AuthorisedModule(address indexed module, bool value); event EnabledStaticCall(address indexed module, bytes4 indexed method); event Invoked(address indexed module, address indexed target, uint indexed value, bytes data); event Received(uint indexed value, address indexed sender, bytes data); event OwnerChanged(address owner); modifier moduleOnly { require(authorised[msg.sender], ); _; }",1
0xc3e43d422d5e6f94315622d96a96058689c52ec8.sol,BitNauticCrowdsaleTokenDistributor,"contract BitNauticCrowdsaleTokenDistributor is Ownable { using SafeMath for uint256; uint256 public constant ICOStartTime = 1531267200; uint256 public constant ICOEndTime = 1536969600; uint256 public teamSupply = 3000000 * 10 ** 18; uint256 public bountySupply = 2500000 * 10 ** 18; uint256 public reserveSupply = 5000000 * 10 ** 18; uint256 public advisorSupply = 2500000 * 10 ** 18; uint256 public founderSupply = 2000000 * 10 ** 18; MintableToken public token; BitNauticWhitelist public whitelist; BitNauticCrowdsale public crowdsale; mapping (address => bool) public hasClaimedTokens; constructor(MintableToken _token, BitNauticWhitelist _whitelist, BitNauticCrowdsale _crowdsale) public { token = _token; whitelist = _whitelist; crowdsale = _crowdsale; }",1
0x402fa04ccd2c2568e1a53dbecec1bd572303663a.sol,HarborPresale,"contract HarborPresale is Haltable { using SafeMath for uint256; HarborToken public token; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public weiRaised; uint256 public cap; bool public isFinalized = false; uint256 public minimumFundingGoal; uint256 public minSend; RefundVault public vault; uint public tokensMinted; mapping (address => uint256) public tokenDeposited; event Finalized(); event TokenMinted(uint count); event Distributed(address investor, uint tokenAmount); event PeriodChanged(uint256 starttm,uint256 endtm); event TokenPurchase(address indexed purchaser, address indexed investor, uint256 value); function HarborPresale(address _token, uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, uint256 _cap, uint256 _minimumFundingGoal, uint256 _minSend) { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != 0x0); require(_cap > 0); require(_minimumFundingGoal > 0); token = HarborToken(_token); startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; cap = _cap; vault = new RefundVault(_wallet); minimumFundingGoal = _minimumFundingGoal; minSend = _minSend; }",1
0x00ec5112673b69bd5f545dc6a3bede8674f878eb.sol,CCPToken,contract CCPToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 55000000 * (10**0); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; uint public totalCollected = 0; function CCPToken () { owner = msg.sender; },1
0x33b7a018934c6e90fd63189d7c4517f0f776142f.sol,ChronoBankAssetProxy,"contract ChronoBankAssetProxy is ERC20 { uint constant OK = 1; ChronoBankPlatform public chronoBankPlatform; bytes32 public smbl; string public name; string public symbol; function init(ChronoBankPlatform _chronoBankPlatform, string _symbol, string _name) returns(bool) { if (address(chronoBankPlatform) != 0x0) { return false; }",1
0x18dc28340ddde25fa8c3b51f5d6a82b1706c8e20.sol,WitnessJury,contract WitnessJury is SafeMath { mapping(address => uint) public balances; uint public limit = 10 ** 16; uint public numWitnessesBeforeLimit = 100; uint public totalBalance; uint public numWitnesses; uint public blockPeriod = 6000; uint public desiredWitnesses = 2; uint public desiredJurors = 3; uint public penalty = 50 * (10 ** 16); address public token; mapping(uint => Request) public requests; uint public numRequests; mapping(uint => uint) public requestsPerBlockGroup; uint public drmVolumeCap = 10000; uint public drmMinFee = 25 * (10 ** 16); uint public drmMaxFee = 50 * (10 ** 16); mapping(uint => bool) public juryNeeded; mapping(uint => mapping(address => bool)) public juryVoted; mapping(uint => uint) public juryYesCount; mapping(uint => uint) public juryNoCount; mapping(uint => address[]) public juryYesVoters; mapping(uint => address[]) public juryNoVoters; struct Request { string key; address witness1; address witness2; string answer1; string answer2; uint winner1; uint winner2; uint fee; address challenge; uint blockNumber; },1
0x02c11f38bec96eb38c4dc2bcc8d669ae676fd7a9.sol,AirDrop,"contract AirDrop is Ownable { using SafeMath for uint256; uint public airDropAmount; mapping ( address => bool ) public invalidAirDrop; address[] public arrayAirDropReceivers; bool public stop = false; ERC20BasicInterface public erc20; uint256 public startTime; uint256 public endTime; event LogAirDrop(address indexed receiver, uint amount); event LogStop(); event LogStart(); event LogWithdrawal(address indexed receiver, uint amount); constructor(uint256 _startTime, uint256 _endTime, uint _airDropAmount, address _tokenAddress) public { require(_startTime >= now && _endTime >= _startTime && _airDropAmount > 0 && _tokenAddress != address(0) ); startTime = _startTime; endTime = _endTime; erc20 = ERC20BasicInterface(_tokenAddress); uint tokenDecimals = erc20.decimals(); airDropAmount = _airDropAmount.mul(10 ** tokenDecimals); }",1
0xec841c878435ba4f28bf305a00c1483db0d96a20.sol,Events,contract Events { DBInterface public database; constructor(address _database) public{ database = DBInterface(_database); },1
0x29d79f8ac7d22a4b1a5e7630f3d48e8d291d3f11.sol,VULToken,contract VULToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function VULToken () { owner = msg.sender; },1
0xcefa3e88393cf17c9b4dc6c9fe5357dfae8036d6.sol,Registry,contract Registry is Ownable { struct ContributorData { bool isActive; uint contributionETH; uint contributionUSD; uint tokensIssued; uint quoteUSD; uint contributionRNTB; },1
0x01d28329619796bae733e849696f80a764422700.sol,BaseTokenSale,"contract BaseTokenSale is TokenController, Controlled { using SafeMath for uint256; uint256 public startFundingTime; uint256 public endFundingTime; uint256 constant public maximumFunding = 1951 ether; uint256 public maxFunding; uint256 public minFunding = 0.001 ether; uint256 public tokensPerEther = 41000; uint256 constant public maxGasPrice = 50000000000; uint256 constant oneDay = 86400; uint256 public totalCollected = 0; bool public paused; Token public tokenContract; bool public finalized = false; bool public allowChange = true; bool private transfersEnabled = true; address private vaultAddress; bool private initialed = false; event Payment(address indexed _sender, uint256 _ethAmount, uint256 _tokenAmount); function BaseTokenSale( uint _startFundingTime, uint _endFundingTime, address _vaultAddress, address _tokenAddress ) public { require(_endFundingTime > now); require(_endFundingTime >= _startFundingTime); require(_vaultAddress != 0); require(_tokenAddress != 0); require(!initialed); startFundingTime = _startFundingTime; endFundingTime = _endFundingTime; vaultAddress = _vaultAddress; tokenContract = Token(_tokenAddress); paused = false; initialed = true; }",1
0x46cefba4dd7512b2449e1ac4b730bfb7f77d1407.sol,DecentralizedExchangeHotPotato,contract DecentralizedExchangeHotPotato { address private owner; mapping (address => bool) private admins; struct Order { address creator; address owner; address issuer; uint256 tokenId; uint256 price; uint256 startTime; uint256 endTime; },1
0x53c347888c54519820249ee629b30316f3b79974.sol,UCToken,contract UCToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 70000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function UCToken () { owner = msg.sender; },1
0xc710772a16fd040ed9c63de0679a57410981e3fc.sol,TokenVault,"contract TokenVault is Ownable { address owner; event TokenTransfer(address indexed to, address token, uint amount); function withdrawTokenTo(address token, address to) public onlyOwner returns (bool) { uint amount = balanceOfToken(token); if (amount > 0) { TokenTransfer(to, token, amount); return Token(token).transfer(to, amount); }",1
0x4176f0f2b7c95486a5ae06e3d1b29201a42e7630.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0xa5cc679a3528956e8032df4f03756c077c1ee3f4.sol,Exchange,contract Exchange { function assert(bool assertion) { if (!assertion) throw; },1
0x5ab793e36070f0fac928ea15826b0c1bc5365119.sol,YUKI,"contract YUKI is ERC223, Ownable, Pausable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 20e9 * 1e8; uint256 public codeSize = 0; bool public mintingFinished = false; address public initialMarketSales = 0x1b879912446d844Fb5915bf4f773F0Db9Cd16ADb; address public incentiveForHolder = 0x0908e3Df5Ed1E67D2AaF38401d4826B2879e8f4b; address public developmentFunds = 0x52F018dc3dd621c8b2D649AC0e22E271a0dE049e; address public marketingFunds = 0x6771a091C97c79a52c8DD5d98A59c5d3B27F99aA; address public organization = 0xD90E1f987252b8EA71ac1cF14465FE9A3803267F; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public cannotSend; mapping (address => bool) public cannotReceive; mapping (address => uint256) public cannotSendUntil; mapping (address => uint256) public cannotReceiveUntil; event FrozenFunds(address indexed target, bool cannotSend, bool cannotReceive); event LockedFunds(address indexed target, uint256 cannotSendUntil, uint256 cannotReceiveUntil); event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintFinished(); constructor() public { owner = msg.sender; balanceOf[initialMarketSales] = totalSupply.mul(45).div(100); balanceOf[incentiveForHolder] = totalSupply.mul(5).div(100); balanceOf[developmentFunds] = totalSupply.mul(20).div(100); balanceOf[marketingFunds] = totalSupply.mul(175).div(1000); balanceOf[organization] = totalSupply.mul(125).div(1000); }",1
0x39de38ba63d172b962db2fc2ee5e4376287c50bf.sol,ImmlaIco,"contract ImmlaIco is SafeMath { ImmlaToken public immlaToken; AbstractToken public preIcoToken; address public escrow; address public icoManager; address public tokenImporter = 0x0; address public founder1; address public founder2; address public founder3; address public team; address public bountyOwner; uint public constant teamsReward = 38548226701232220000000000; uint public constant bountyOwnersTokens = 9361712198870680000000000; uint constant BASE = 1000000000000000000; uint public constant defaultIcoStart = 1505422800; uint public icoStart = defaultIcoStart; uint public constant defaultIcoDeadline = 1508101200; uint public icoDeadline = defaultIcoDeadline; uint public constant defaultFoundersRewardTime = 1521061200; uint public foundersRewardTime = defaultFoundersRewardTime; uint public constant minIcoTokenLimit = 18000000 * BASE; uint public constant maxIcoTokenLimit = 434477177 * BASE; uint public importedTokens = 0; uint public soldTokensOnIco = 0; uint public constant soldTokensOnPreIco = 13232941687168431951684000; uint tokenPrice1 = 3640; uint tokenSupply1 = 170053520 * BASE; uint tokenPrice2 = 3549; uint tokenSupply2 = 103725856 * BASE; uint tokenPrice3 = 3458; uint tokenSupply3 = 100319718 * BASE; uint tokenPrice4 = 3367; uint tokenSupply4 = 60378083 * BASE; uint[] public tokenPrices; uint[] public tokenSupplies; bool public initialized = false; bool public migrated = false; bool public sentTokensToFounders = false; bool public icoStoppedManually = false; mapping (address => uint) public balances; event BuyTokens(address buyer, uint value, uint amount); event WithdrawEther(); event StopIcoManually(); event SendTokensToFounders(uint founder1Reward, uint founder2Reward, uint founder3Reward); event ReturnFundsFor(address account); modifier whenInitialized() { require(initialized); _; }",1
0x1bcbc935b377432224b9050211edaaf67f184f0d.sol,subSale,contract subSale{ AbstractENS ens = AbstractENS(0x314159265dD8dbb310642f98f50C066173C1259b); address admin = 0x1f51d1d29AaFb00188168227a49d8f7E5D5b5bD9; struct Domain{ address originalOwner; uint regPeriod; bool subSale; uint subPrice; uint subExpiry; },1
0x750c1d91864171d7e1715a6b53ee28c72b8faa09.sol,EthicHubUser,"contract EthicHubUser is Ownable, EthicHubBase { event UserStatusChanged(address target, string profile, bool isRegistered); constructor(address _storageAddress) EthicHubBase(_storageAddress) public { version = 3; }",1
0xc767b1cec507f1584469e8efe1a94ad4c75e02ed.sol,PremiumFactories,contract PremiumFactories { Bankroll constant bankroll = Bankroll(0x66a9f1e53173de33bec727ef76afa84956ae1b25); address owner; constructor() public { owner = msg.sender; },1
0x5ad9e100bc58e57a20cf1cae204f046006d27a27.sol,CoinCrowdICO,contract CoinCrowdICO is Ownable { using SafeMath for uint256; tokenInterface public tokenContract; uint256 public decimals = 18; uint256 public tokenValue; uint256 public constant centToken = 20; function euroRaised(uint256 _weiTokens) public view returns (uint256) { return _weiTokens.mul(centToken).div(100).div(10**decimals); },1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,GoldBackedToken,"contract GoldBackedToken is Ownable, SafeMath, ERC20, Pausable { event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); event DeductFees(address indexed owner,uint256 amount); event TokenMinted(address destination, uint256 amount); event TokenBurned(address source, uint256 amount); string public name = ; string public symbol = ; uint256 constant public decimals = 18; uint256 constant public hgtDecimals = 8; uint256 constant public allocationPool = 1 * 10**9 * 10**hgtDecimals; uint256 constant public maxAllocation = 38 * 10**5 * 10**decimals; uint256 public totAllocation; address public feeCalculator; address public HGT; function setFeeCalculator(address newFC) onlyOwner { feeCalculator = newFC; }",1
0x83f21fc58b04af42c23b5c468ba395319c9a8f60.sol,BancorConverter,"contract BancorConverter is IBancorConverter, SmartTokenController, Managed, ContractIds, FeatureIds { using SafeMath for uint256; uint32 private constant MAX_WEIGHT = 1000000; uint64 private constant MAX_CONVERSION_FEE = 1000000; struct Connector { uint256 virtualBalance; uint32 weight; bool isVirtualBalanceEnabled; bool isPurchaseEnabled; bool isSet; }",1
0x3a37dcda0503f92626c082540dfbc9d95104ab96.sol,EthernautsLogic,contract EthernautsLogic is EthernautsOwnership { address public newContractAddress; function EthernautsLogic() public { ceoAddress = msg.sender; ctoAddress = msg.sender; cooAddress = msg.sender; oracleAddress = msg.sender; paused = true; },1
0x6c18e0cb293f534b99cfb9ccaeb7098c857e11a9.sol,Axioms,contract Axioms { Airdrop [] public airdrops; address owner; uint idCounter; constructor () public { owner = msg.sender; },1
0xd90f5ebc01914bbd357b754956aafb199f4d1624.sol,Auction,contract AuctionBase is ERC721Holder { using SafeMath for uint256; struct Auction { address seller; uint128 price; uint64 startedAt; },1
0xdcf67546f2253c9c90c2b55447e1efecebcf83d6.sol,HorseyToken,"contract HorseyToken is EthorseHelpers,Pausable { event Claimed(address raceAddress, address eth_address, uint256 tokenId); event Feeding(uint256 tokenId); event ReceivedCarrot(uint256 tokenId, bytes32 newDna); event FeedingFailed(uint256 tokenId); event HorseyRenamed(uint256 tokenId, string newName); event HorseyFreed(uint256 tokenId); RoyalStablesInterface public stables; uint8 public carrotsMultiplier = 1; uint8 public rarityMultiplier = 1; uint256 public claimingFee = 0.000 ether; struct FeedingData { uint256 blockNumber; uint256 horsey; }",1
0x5c89736e9454200141b80c37eb28eaceca2ce8cb.sol,CherryToken,"contract CherryToken is ERC223, ERCAddressFrozenFund { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; address public fundsWallet; uint256 internal fundsWalletChanged; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; constructor() public { _symbol = ; _name = ; _decimals = 8; _totalSupply = 10000000000000000; balances[msg.sender] = _totalSupply; fundsWallet = msg.sender; owner = msg.sender; fundsWalletChanged = 0; }",1
0x0045684552109f8551cc5c8aa7b1f52085adff47.sol,BaseWallet,"contract BaseWallet { address public implementation; address public owner; mapping (address => bool) public authorised; mapping (bytes4 => address) public enabled; uint public modules; event AuthorisedModule(address indexed module, bool value); event EnabledStaticCall(address indexed module, bytes4 indexed method); event Invoked(address indexed module, address indexed target, uint indexed value, bytes data); event Received(uint indexed value, address indexed sender, bytes data); event OwnerChanged(address owner); modifier moduleOnly { require(authorised[msg.sender], ); _; }",1
0x6593a7140f3718efff638b72a9b6083db47ce0d2.sol,Crowdsale,"contract Crowdsale is GuidedByRoles, ERC20Provider{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 90 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0xdc919494349e803fbd2d4064106944418381edb3.sol,SaiVox,contract SaiVox is DSThing { uint256 _par; uint256 _way; uint256 public fix; uint256 public how; uint256 public tau; function SaiVox(uint par_) public { _par = fix = par_; _way = RAY; tau = era(); },1
0x0333a8c69858382840ea4980d5550fcc632342f0.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; MintableToken public token; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public weiRaised; uint256 public tokensSold; uint256 constant public hardCap = 24000000 * (10**18); event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(uint256 _startTime, uint256 _endTime, address _wallet, MintableToken tokenContract) public { require(_startTime >= now); require(_endTime >= _startTime); require(_wallet != 0x0); startTime = _startTime; endTime = _endTime; wallet = _wallet; token = tokenContract; }",1
0x0333a8c69858382840ea4980d5550fcc632342f0.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; MintableToken public token; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public weiRaised; uint256 public tokensSold; uint256 constant public hardCap = 24000000 * (10**18); event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(uint256 _startTime, uint256 _endTime, address _wallet, MintableToken tokenContract) public { require(_startTime >= now); require(_endTime >= _startTime); require(_wallet != 0x0); startTime = _startTime; endTime = _endTime; wallet = _wallet; token = tokenContract; }",1
0x5ca4568d54ecfc15902a425fd6ac64095a9a51a3.sol,MultiTransfer,"contract MultiTransfer { event Deposited(address from, uint value, bytes data); event Transacted( address msgSender, address toAddress, uint value ); function() public payable { if (msg.value > 0) { emit Deposited(msg.sender, msg.value, msg.data); }",1
0x447b4ccab1b370afbe5ae2e68c0b700be913a585.sol,AgileArbitration,contract AgileArbitration is Owned { address public operator; uint public quorum = 3; struct Dispute { address icoRoundAddress; address investorAddress; bool pending; uint timestamp; uint milestone; string reason; uint votesForProject; uint votesForInvestor; mapping(address => bool) voters; },1
0x6a3f85f8a86e7b3de0269c20e9ab066dd57b8e21.sol,AccRegCenter,contract AccRegCenter is Ownable { struct User { address useraddress; uint useramount; bool lastTransfer; },1
0xc849a5fff9befa297d1c3a772bafac9f3c9004ec.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0xed2725cdfc48a24aa71d9b9621d431db0705a55a.sol,ProfitSharing,"contract ProfitSharing is Ownable { using SafeMath for uint256; event DividendDeposited(address indexed _depositor, uint256 _blockNumber, uint256 _amount, uint256 _totalSupply, uint256 _dividendIndex); event DividendClaimed(address indexed _claimer, uint256 _dividendIndex, uint256 _claim); event DividendRecycled(address indexed _recycler, uint256 _blockNumber, uint256 _amount, uint256 _totalSupply, uint256 _dividendIndex); MiniMeToken public token; uint256 public RECYCLE_TIME = 1 years; struct Dividend { uint256 blockNumber; uint256 timestamp; uint256 amount; uint256 claimedAmount; uint256 totalSupply; bool recycled; mapping (address => bool) claimed; }",1
0x2791528f5617e187a6d73c30034ac211b2f47042.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x46cefba4dd7512b2449e1ac4b730bfb7f77d1407.sol,DecentralizedExchangeHotPotato,contract DecentralizedExchangeHotPotato { address private owner; mapping (address => bool) private admins; struct Order { address creator; address owner; address issuer; uint256 tokenId; uint256 price; uint256 startTime; uint256 endTime; },1
0xc4ab0f59c4d8bb15e237906a06a736d965a2c390.sol,AirdropLibraToken,"contract AirdropLibraToken is Ownable { using SafeMath for uint256; uint256 decimal = 10**uint256(18); uint256 distributedTotal = 0; uint256 airdropStartTime; uint256 airdropEndTime; LibraToken private token; mapping (address => bool) public airdropAdmins; mapping(address => uint256) public airdropDoneAmountMap; address[] public airdropDoneList; event Airdrop(address _receiver, uint256 amount); event AddAdmin(address _admin); event RemoveAdmin(address _admin); event UpdateEndTime(address _operator, uint256 _oldTime, uint256 _newTime); modifier onlyOwnerOrAdmin() { require(msg.sender == owner || airdropAdmins[msg.sender]); _; }",1
0xec2e5c8d51fdd54fef83db8300399a3c2e167922.sol,CrowdsaleToken,"contract CrowdsaleToken is Manageable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public totalSupply; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; mapping (address => uint256) public releaseTime; bool public released; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Mint(address indexed _to, uint256 _value); event ReleaseTimeChanged(address indexed _owner, uint256 _oldReleaseTime, uint256 _newReleaseTime); event ReleasedChanged(bool _oldReleased, bool _newReleased); modifier canTransfer(address _from) { if (releaseTime[_from] == 0) { require(released); }",1
0x774853153c3cc175a3606c58d6f27f6b57e72fd3.sol,c_BANK,"contract c_BANK { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x00c315ac9ff89bb6afa7524cd159f0a9766e8c89.sol,IMDEXDexchange,"contract IMDEXDexchange is SafeMath { address public owner; address IMDEXtoken = 0x46705E8fef2E868FACAFeDc45F47114EC01c2EEd; mapping (address => uint256) public invalidOrder; event SetOwner(address indexed previousOwner, address indexed newOwner); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x57db9d1890eb580a5ba18926a7c76f7abaa1831d.sol,BdpOwnership,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0x0e69d0a2bbb30abcb7e5cfea0e4fde19c00a8d47.sol,ContractLock,"contract ContractLock is DSStop { uint public unlockTime; mapping (address => bool) public isAdmin; event LogAddAdmin(address whoAdded, address newAdmin); event LogRemoveAdmin(address whoRemoved, address admin); constructor(uint _unlockTime) public { unlockTime = _unlockTime; isAdmin[msg.sender] = true; emit LogAddAdmin(msg.sender, msg.sender); }",1
0x2737e022e8bf733b05fa0706b0e80003a576ccb4.sol,TokenValueRelayer,contract TokenValueRelayer { struct TokenValueRepresentation { uint256 value; string currency; uint256 timestamp; },1
0x01d6208f95cf2292c350fc8bb1b1f29230352675.sol,DepositWithdraw,"contract DepositWithdraw is Claimable, Withdrawable { using SafeMath for uint256; struct TransferRecord { uint256 timeStamp; address account; uint256 value; }",1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,Token,"contract Token { using SafeMath for uint256; mapping (address => uint256) public balances; mapping(address => mapping (address => uint256)) allowed; address[] allTokenHolders; string public name; string public symbol; uint8 public decimals; uint256 totalSupplyAmount = 0; address public refundManagerContractAddress; AuthenticationManager authenticationManager; LockinManager lockinManager; function availableBalance(address _owner) constant returns(uint256) { uint256 length = lockinManager.getLocks(_owner); uint256 lockedValue = 0; for(uint256 i = 0; i < length; i++) { if(lockinManager.getLocksUnlockDate(_owner, i) > now) { uint256 _value = lockinManager.getLocksAmount(_owner, i); lockedValue = lockedValue.add(_value); }",1
0xed4fd2e53153b8bfd866e11fb015a1bc4a0e9655.sol,Lottery,contract Lottery{ modifier onlyOwner() { require(msg.sender == owner); _; },1
0x456c4350eefd17315713b265d8be8b6063a5fab8.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0x456c4350eefd17315713b265d8be8b6063a5fab8.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0x41b8578b7fe2bdcc4cb5c8e6ab18b11880072208.sol,BitcoinQuick,"contract BitcoinQuick { string public constant symbol = ; string public constant name = ; uint public constant decimals = 8; uint _totalSupply = 21000000 * 10 ** decimals; uint public marketSupply; uint public marketPrice; address owner; address airDropVerify; uint public airDropAmount; uint32 public airDropHeight; mapping (address => bool) public airDropMembers; mapping (address => uint) accounts; mapping (address => mapping (address => uint)) allowed; event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); function BitcoinQuick() public { owner = msg.sender; accounts[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x26a9bab7b085582f56885f084174115e51fb58e4.sol,Lottery,contract Lottery{ modifier onlyOwner() { require(msg.sender == owner); _; },1
0x40da24a66f729d0bd0453681c5a6506bdc2a7a6a.sol,CrwdTimelock,"contract CrwdTimelock { using SafeMath for uint256; mapping(address => uint256) public balances; uint256 public assignedBalance; address public controller; uint public releaseTime; CrwdToken token; function CrwdTimelock(CrwdToken _token, address _controller, uint _releaseTime) { require(_releaseTime > now); token = _token; controller = _controller; releaseTime = _releaseTime; }",1
0x2d3e7d4870a51b918919e7b851fe19983e4c38d5.sol,FreezeTokensWallet,contract FreezeTokensWallet is Ownable { using SafeMath for uint256; MintableToken public token; bool public started; uint public startLockPeriod = 180 days; uint public period = 360 days; uint public duration = 90 days; uint public startUnlock; uint public retrievedTokens; uint public startBalance; modifier notStarted() { require(!started); _; },1
0x5b47180e5f07fb5e10f86761df0c34ce952c6974.sol,VICToken,contract VICToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 10000000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function VICToken () { owner = msg.sender; },1
0xece0429a5130ebe0616363939067eefca4fbaceb.sol,BISK,"contract BISK is MiniMeToken { mapping (address => bool) public blacklisted; bool public generateFinished; constructor (address _tokenFactory) MiniMeToken( _tokenFactory, 0x0, 0, , 18, , false ) public { }",1
0xa27f262391913a5e21216c70de5358a1e887de25.sol,VestingContractWTTEST,contract VestingContractWTTEST { struct AccountData { uint original_balance; uint limit_per_period; uint current_balance; uint current_limit; uint current_transferred; },1
0x18f0cd26c06449d967ca6aef8b5f9d8ee9fd7992.sol,Exch,"contract Exch is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; mapping (address => bool) public whiteListERC20; mapping (address => bool) public whiteListERC223; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); modifier onlyAdmin() { require(msg.sender==admin); _; }",1
0x77c9acc811e4cf4b51dc3a3e05dc5d62fa887767.sol,CrryptoArena,contract CrryptoArena { using SafeMath for uint256; address public administrator; uint256 public VIRUS_NORMAL = 0; uint256 public HALF_TIME_ATK= 60 * 15; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public VIRUS_MINING_PERIOD = 86400; address public engineerAddress; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; CryptoProgramFactoryInterface public Factory; mapping(address => Player) public players; mapping(uint256 => Virus) public viruses; mapping(address => bool) public miniGames; struct Player { uint256 virusDef; uint256 nextTimeAtk; uint256 endTimeUnequalledDef; },1
0xc3e43d422d5e6f94315622d96a96058689c52ec8.sol,BitNauticCrowdsaleTokenDistributor,"contract BitNauticCrowdsaleTokenDistributor is Ownable { using SafeMath for uint256; uint256 public constant ICOStartTime = 1531267200; uint256 public constant ICOEndTime = 1536969600; uint256 public teamSupply = 3000000 * 10 ** 18; uint256 public bountySupply = 2500000 * 10 ** 18; uint256 public reserveSupply = 5000000 * 10 ** 18; uint256 public advisorSupply = 2500000 * 10 ** 18; uint256 public founderSupply = 2000000 * 10 ** 18; MintableToken public token; BitNauticWhitelist public whitelist; BitNauticCrowdsale public crowdsale; mapping (address => bool) public hasClaimedTokens; constructor(MintableToken _token, BitNauticWhitelist _whitelist, BitNauticCrowdsale _crowdsale) public { token = _token; whitelist = _whitelist; crowdsale = _crowdsale; }",1
0x58c3069023ed736f430d585003715058c2e3c671.sol,BTCPayment,"contract BTCPaymentI is Ownable, PresaleFallbackReceiver { PaymentFallbackReceiver public presale; PaymentFallbackReceiver public mainsale; function addPayment(address _beneficiary, uint256 _tokens) public; function setPresale(address _presale) external; function setMainsale(address _mainsale) external; function presaleFallBack(uint256) public returns (bool); }",1
0x51c22c78d753939c8aebae437c2f18eee43ca296.sol,PrivateSale,"contract PrivateSale is Ownable { LamdenTau public lamdenTau; address public buyer; uint256 public priceInWei; function PrivateSale(address _tokenContractAddress, address _buyer, uint256 _priceInWei) public { require(_buyer != address(0)); require(_tokenContractAddress != address(0)); require(_priceInWei > 0); buyer = _buyer; priceInWei = _priceInWei; lamdenTau = LamdenTau(_tokenContractAddress); }",1
0x00fbe7398d9f0d53fbaef6e2f4c6ab0e7c31f5d7.sol,UAPCrowdsale,"contract UAPCrowdsale is Ownable { using SafeMath for uint256; bool public isFinalised; MintableToken public token; uint256 public mainSaleStartTime; uint256 public mainSaleEndTime; address public wallet; address public tokenWallet; uint256 public rate; uint256 public weiRaised; uint256 public tokensToSell= 319500000 * 10 ** uint256(18); event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event FinalisedCrowdsale(); function UAPCrowdsale(uint256 _mainSaleStartTime, uint256 _mainSaleEndTime, uint256 _rate, address _wallet, address _tokenWallet) public { require(_mainSaleStartTime >= now); require(_mainSaleStartTime < _mainSaleEndTime); require(_rate > 0); require(_wallet != 0x0); require(_tokenWallet != 0x0); token = createTokenContract(_tokenWallet); mainSaleStartTime = _mainSaleStartTime; mainSaleEndTime = _mainSaleEndTime; rate = _rate; wallet = _wallet; tokenWallet = _tokenWallet; isFinalised = false; }",1
0x1c8654c680c3f18a3b3a0ee943d40848a9fffd0d.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; using SafeERC20 for ERC20; ERC20 public token; address public wallet; uint256 internal rate; uint256 public weiRaised; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); constructor(address _wallet, ERC20 _token) public { require(_wallet != address(0)); require(_token != address(0)); wallet = _wallet; token = _token; }",1
0xbd5ff93a6ce6019f0e69227d88d11e5772dc853e.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; ERC20 public token; address public fundWallet; address public admin; uint256 public rate = 10000; uint256 public amountRaised; bool public crowdsaleOpen; uint256 public cap; event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount); function Crowdsale(ERC20 _token, address _fundWallet) public { require(_token != address(0)); require(_fundWallet != address(0)); fundWallet = _fundWallet; admin = msg.sender; token = _token; crowdsaleOpen = true; cap = 20000 * 1 ether; }",1
0xa5cc679a3528956e8032df4f03756c077c1ee3f4.sol,Exchange,contract Exchange { function assert(bool assertion) { if (!assertion) throw; },1
0x8615ddfe9d4c9e58abff01c999731f3e9e556e80.sol,DAPBOXToken,"contract DAPBOXToken is FrozenToken { string public name = ; string public symbol = ; uint8 public decimals = 0; string public version = ; string public publisher = ""https: string public description = ; bool public acceptAdminWithdraw = false; bool public acceptDonate = true; event InfoChanged(address indexed sender, string version, string publisher, string description); event Withdraw(address indexed sender, address indexed wallet, uint256 amount); event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount); event Donate(address indexed sender, uint256 value); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); function setupInfo(string _version, string _publisher, string _description) authLevel(Level.ADMIN) notEmpty(_version) notEmpty(_publisher) notEmpty(_description) public { version = _version; publisher = _publisher; description = _description; InfoChanged(msg.sender, _version, _publisher, _description); }",1
0x01de9415d1ae14ab755186bea22923afe2934d82.sol,BitizenCarOperator,"contract BitizenCarOperator is Operator { event CreateCar(address indexed _owner, uint256 _carId); BitizenCarService internal carService; ERC721 internal ERC721Service; uint16 PER_USER_MAX_CAR_COUNT = 1; function injectCarService(BitizenCarService _service) public onlyOwner { carService = BitizenCarService(_service); ERC721Service = ERC721(_service); }",1
0xc849a5fff9befa297d1c3a772bafac9f3c9004ec.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,AccountRegistry,"contract AccountRegistry is AccountRegistryInterface, TokenRescue { uint256 constant public registrationDeposit = 1 finney; uint256 constant public proposalCensorshipFee = 50 finney; address constant public burn = 0x000000003Ffc15cd9eA076d7ec40B8f516367Ca1; Vote public constant token = Vote(0x000000002647e16d9BaB9e46604D75591D289277); uint8 constant UNCONTACTED = 0; uint8 constant PROPOSER = 1; uint8 constant VOTER = 2; uint8 constant PENDING_PROPOSAL = 4; uint8 constant PROPOSAL = 8; uint8 constant PENDING_CABAL = 16; uint8 constant CABAL = 32; uint8 constant BOARD = 64; struct Account { uint256 lastAccess; uint8 membership; address appointer; address denouncer; address voucher; address devoucher; }",1
0x83686a73638ff46ee1eb5d28ff2179c41d1157aa.sol,ldoh,"contract ldoh is EthereumSmartContract { event onCashbackCode (address indexed hodler, address cashbackcode); event onAffiliateBonus (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onUnlocktoken (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onHoldplatform (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onAddContractAddress(address indexed contracthodler, bool contractstatus, uint256 _maxcontribution, string _ContractSymbol, uint256 _PercentPermonth, uint256 _HodlingTime); event onHoldplatformsetting(address indexed Tokenairdrop, bool HPM_status, uint256 HPM_divider, uint256 HPM_ratio, uint256 datetime); event onHoldplatformdeposit(uint256 amount, uint256 newbalance, uint256 datetime); event onHoldplatformwithdraw(uint256 amount, uint256 newbalance, uint256 datetime); address public DefaultToken; struct Safe { uint256 id; uint256 amount; uint256 endtime; address user; address tokenAddress; string tokenSymbol; uint256 amountbalance; uint256 cashbackbalance; uint256 lasttime; uint256 percentage; uint256 percentagereceive; uint256 tokenreceive; uint256 lastwithdraw; address referrer; bool cashbackstatus; }",1
0x37e343f2cc245754595f1ae3656b460c35d636fb.sol,BalanceManager,contract BalanceManager is Serverable { mapping(uint32 => uint64) public balances; mapping(uint32 => uint64) public blockedBalances; mapping(address => uint64) public walletBalances; mapping(address => uint32) public userIds; address public dispatcher; uint serviceReward; uint sentBonuses; ERC223 public gameToken; modifier onlyDispatcher() {require(msg.sender == dispatcher); _;},1
0x01e6a8af629cc06ff37755a61d9e7dd1135d8c6a.sol,Factory,"contract Factory { using SafeMath for uint256; address public owner; address public oracle_address; address public user_contract; address internal deployer_address; Deployer_Interface internal deployer; address public token; uint public fee; uint public swapFee; uint public duration; uint public multiplier; uint public token_ratio; address[] public contracts; uint[] public startDates; address public memberContract; uint whitelistedTypes; mapping(address => uint) public created_contracts; mapping(address => uint) public token_dates; mapping(uint => address) public long_tokens; mapping(uint => address) public short_tokens; mapping(address => uint) public token_type; event ContractCreation(address _sender, address _created); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0x514bc174df04a4b04ae2be81ee8c788c3796b06b.sol,Deco,contract Deco is ERC20ERC223 { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant totalSupply = 6*10**26; mapping(address => Account) private accounts; struct Account { uint256 balance; mapping(address => uint256) allowed; mapping(address => bool) isAllowanceAuthorized; },1
0x3325e30f4326f17bdd79146db0a3835175f0e982.sol,SAMIToken,contract SAMIToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000000000000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function SAMIToken () { owner = msg.sender; },1
0x0114289efe38186b732d12c07a1ce4341e266513.sol,PreICO,"contract PreICO is ReentrancyGuard, Ownable, Stateful { using SafeMath for uint256; DLH public token; address public wallet; uint256 public startPreICOTime; uint256 public endPreICOTime; uint256 public rate; uint256 public priceUSD; uint256 public centRaised; uint256 public minimumInvest; uint256 public softCapPreSale; uint256 public hardCapPreSale; uint256 public hardCapPrivate; address public oracle; address public manager; mapping(address => uint) public balances; mapping(address => uint) public balancesInCent; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PreICO( address _wallet, address _token, uint256 _priceUSD, uint256 _minimumInvest) public { require(_priceUSD != 0); require(_wallet != address(0)); require(_token != address(0)); priceUSD = _priceUSD; rate = 250000000000000000; wallet = _wallet; token = DLH(_token); hardCapPrivate = 40000000; minimumInvest = _minimumInvest; }",1
0x4bd22737812e4412879aacf0b400131e1ee0a4a5.sol,Controller,"contract Controller is ControllerInterface, OwnableContract, OwnableContractOwner { WrappedToken public token; MembersInterface public members; address public factory; constructor(WrappedToken _token) public { require(_token != address(0), ); token = _token; }",1
0x475a8101fdde7f7246e31be77dd7dcb80f25d735.sol,Exchange,contract Exchange { struct Order { address creator; address token; bool buy; uint price; uint amount; },1
0xe3ea690fefbc27ddc49d3329fe6d42ffc1657191.sol,CupExchange,"contract CupExchange { using SafeMath for uint256; using SafeMath for int256; address public owner; token internal teamCup; token internal cup; uint256 public exchangePrice; bool public halting = true; event Halted(bool halting); event Exchange(address user, uint256 distributedAmount, uint256 collectedAmount); constructor(address cupToken, address teamCupToken) public { owner = msg.sender; teamCup = token(teamCupToken); cup = token(cupToken); }",1
0x1c8654c680c3f18a3b3a0ee943d40848a9fffd0d.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; using SafeERC20 for ERC20; ERC20 public token; address public wallet; uint256 internal rate; uint256 public weiRaised; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); constructor(address _wallet, ERC20 _token) public { require(_wallet != address(0)); require(_token != address(0)); wallet = _wallet; token = _token; }",1
0x5057a5854e251eb15832576330bcba344397954c.sol,XIDToken,contract XIDToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function XIDToken () { owner = msg.sender; },1
0x6c18e0cb293f534b99cfb9ccaeb7098c857e11a9.sol,Axioms,contract Axioms { Airdrop [] public airdrops; address owner; uint idCounter; constructor () public { owner = msg.sender; },1
0xef8544d42df82dda9d3a6e09b47f45f15957268b.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 29721600; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x4B664ef96353f580BAf7ed59BB1188Ca1F2B4Ed2; }",1
0x402fa04ccd2c2568e1a53dbecec1bd572303663a.sol,HarborPresale,"contract HarborPresale is Haltable { using SafeMath for uint256; HarborToken public token; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public weiRaised; uint256 public cap; bool public isFinalized = false; uint256 public minimumFundingGoal; uint256 public minSend; RefundVault public vault; uint public tokensMinted; mapping (address => uint256) public tokenDeposited; event Finalized(); event TokenMinted(uint count); event Distributed(address investor, uint tokenAmount); event PeriodChanged(uint256 starttm,uint256 endtm); event TokenPurchase(address indexed purchaser, address indexed investor, uint256 value); function HarborPresale(address _token, uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, uint256 _cap, uint256 _minimumFundingGoal, uint256 _minSend) { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != 0x0); require(_cap > 0); require(_minimumFundingGoal > 0); token = HarborToken(_token); startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; cap = _cap; vault = new RefundVault(_wallet); minimumFundingGoal = _minimumFundingGoal; minSend = _minSend; }",1
0x25b16c95f3ebb1d8583a1c173f81257bc916a9be.sol,SignalsCrowdsale,"contract SignalsCrowdsale is FinalizableCrowdsale { uint256 public constant HARD_CAP = 18000*(10**18); uint256 public toBeRaised = 18000*(10**18); uint256 public constant PRICE = 360000; uint256 public tokensSold; uint256 public constant maxTokens = 185000000*(10**9); uint constant ADVISORY_SHARE = 18500000*(10**9); uint constant BOUNTY_SHARE = 3700000*(10**9); uint constant COMMUNITY_SHARE = 37000000*(10**9); uint constant COMPANY_SHARE = 33300000*(10**9); uint constant PRESALE_SHARE = 7856217611546440; address constant ADVISORS = 0x98280b2FD517a57a0B8B01b674457Eb7C6efa842; address constant BOUNTY = 0x8726D7ac344A0BaBFd16394504e1cb978c70479A; address constant COMMUNITY = 0x90CDbC88aB47c432Bd47185b9B0FDA1600c22102; address constant COMPANY = 0xC010b2f2364372205055a299B28ef934f090FE92; address constant PRESALE = 0x7F3a38fa282B16973feDD1E227210Ec020F2481e; CrowdsaleRegister register; PrivateRegister register2; bool public ready; event SaleWillStart(uint256 time); event SaleReady(); event SaleEnds(uint256 tokensLeft); function SignalsCrowdsale(address _token, address _wallet, address _register, address _register2) public FinalizableCrowdsale() Crowdsale(_token, _wallet) { register = CrowdsaleRegister(_register); register2 = PrivateRegister(_register2); }",1
0xedf19b437d1a67e18b15dd4a859dd52f9cfa012f.sol,ERC777TokenScheduledTimelock,"contract ERC777TokenScheduledTimelock is ERC820Implementer, ERC777TokensRecipient, Ownable { using SafeMath for uint256; ERC777Token public token; uint256 public totalVested; struct Timelock { uint256 till; uint256 amount; }",1
0x797d713d8d7a2815ccf3dcf9719e3e9f1712c370.sol,Trustee,contract Trustee is Ownable { using SaferMath for uint256; StoxSmartToken public stox; struct Grant { uint256 value; uint256 start; uint256 cliff; uint256 end; uint256 transferred; bool revokable; },1
0x0d5d4c289133ebf3eb685c183a930c1ee2ea4a4f.sol,I_BANK,"contract I_BANK { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,LockinManager,contract LockinManager { using SafeMath for uint256; struct Lock { uint256 amount; uint256 unlockDate; uint256 lockedFor; },1
0x27369e8f43f44c26853a46da7e6cb52d203b59ce.sol,AgileICOWithAssistance,contract AgileICOWithAssistance { using SafeMath for uint; address public operator; address public juryOperator; address public projectWallet; address public arbitrationAddress; address public juryOnlineWallet; bool public requireTokens; uint public promisedTokens; uint public etherAllowance; uint public jotAllowance; uint public commissionOnInvestmentJot; uint public commissionOnInvestmentEth; uint public percentForFuture; uint public rate = 1; address public currentCycleAddress; uint public currentCycleNumber; uint public currentFundingRound; uint public minimumInvestment; uint public lastRateChange; Token public token; struct Offer { uint etherAmount; uint tokenAmount; bool accepted; uint numberOfDeals; },1
0xc81ec8a2a711e96d977a48252ac694e1d4b5719d.sol,GTCoin,"contract GTCoin is Token(, , 18, 100000000000000000000000000), ERC20, ERC223 { using SafeMath for uint; function GTCoin() public { _balanceOf[msg.sender] = _totalSupply; }",1
0x4bc78f6619991b029b867b6d88d39c196332aba3.sol,AlgoDEX,"contract AlgoDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0xbe4eee50c1fa98b8f2f0edcc4cccae6646b4ce2c.sol,MultiChanger,"contract MultiChanger is CanReclaimToken { using SafeMath for uint256; using CheckedERC20 for ERC20; function externalCall(address destination, uint value, bytes data, uint dataOffset, uint dataLength) internal returns (bool result) { assembly { let x := mload(0x40) let d := add(data, 32) result := call( sub(gas, 34710), destination, value, add(d, dataOffset), dataLength, x, 0 ) }",1
0xb4a3fb248d39370c1f8081b73fa7098167c8142b.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }",1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,Kleros,"contract Kleros is Arbitrator, ApproveAndCallFallBack { Pinakion public pinakion; uint public constant NON_PAYABLE_AMOUNT = (2**256 - 2) / 2; RNG public rng; uint public arbitrationFeePerJuror = 0.05 ether; uint16 public defaultNumberJuror = 3; uint public minActivatedToken = 0.1 * 1e18; uint[5] public timePerPeriod; uint public alpha = 2000; uint constant ALPHA_DIVISOR = 1e4; uint public maxAppeals = 5; address public governor; uint public session = 1; uint public lastPeriodChange; uint public segmentSize; uint public rnBlock; uint public randomNumber; enum Period { Activation, Draw, Vote, Appeal, Execution }",1
0x1eb0d4794d4067ed004c9d55ff6eb50620b27c58.sol,ProspectorsCrowdsale,"contract ProspectorsCrowdsale is Owned, DSMath { ProspectorsGoldToken public token; address public dev_multisig; uint public total_raised; uint public contributors_count = 0; uint public constant start_time = 1502377200; uint public constant end_time = 1505055600; uint public constant bonus_amount = 10000000 * 10**18; uint public constant start_amount = 60000000 * 10**18; uint public constant price = 0.0005 * 10**18; uint public constant bonus_price = 0.0004 * 10**18; uint public constant goal = 2000 ether; bool private closed = false; mapping(address => uint) funded; modifier in_time { if (time() < start_time || time() > end_time) revert(); _; }",1
0x1eafd303c88b6cd638c77b40596de3dcf001b249.sol,AssetInfo,contract AssetInfo is Manageable { string public publicDocument; event UpdateDocument( string newLink ); constructor(string _publicDocument) public { publicDocument = _publicDocument; },1
0x3fd2371b53f2db38765220c90f2ffd4ddbe8afd1.sol,MonethaUsersClaimHandler,contract MonethaUsersClaimHandler is Contactable { string constant VERSION = ; MonethaUsersClaimStorage public storageContract; event StorageContractOwnerChanged(address indexed _newOwner); constructor(address _storageAddr) public { storageContract = MonethaUsersClaimStorage(_storageAddr); },1
0x5af9ec6df6edea0761fa841ce56c2e4deb000b31.sol,ZebiCoinTempMgr,contract ZebiCoinTempMgr is Ownable{ using SafeMath for uint256; address public wallet; ZebiCoinCrowdsale public preSaleCSSC; ZebiCoin public tsc; uint64 tokenDecimals; mapping(address => bool) preSaleCancelledList; mapping(address => uint256) noncsAllocations; bool public withinRefundPeriod; mapping(address => uint256) preSaleRefunds; modifier inPreSaleCancelledList { require(preSaleCancelledList[msg.sender]); _; },1
0x35c2307cd831741187d4ef71ce9fbe91fa822df5.sol,BOX33Token,"contract BOX33Token is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 2680; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0xc7bd5dac314a67a375a0347d72797c2ea1f1a672.sol,KlownGasDrop,contract KlownGasDrop { mapping(address => bool) public receivers; mapping ( address => uint256 ) public balances; uint256 amountToClaim = 50000000; uint256 public totalSent = 0; address _owner; address whoSent; uint256 dappBalance; uint public brpt = 0; uint public brpt1 = 0; IERC20 currentToken ; modifier onlyOwner() { require(msg.sender == _owner); _; },1
0x5c89736e9454200141b80c37eb28eaceca2ce8cb.sol,CherryToken,"contract CherryToken is ERC223, ERCAddressFrozenFund { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; address public fundsWallet; uint256 internal fundsWalletChanged; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; constructor() public { _symbol = ; _name = ; _decimals = 8; _totalSupply = 10000000000000000; balances[msg.sender] = _totalSupply; fundsWallet = msg.sender; owner = msg.sender; fundsWalletChanged = 0; }",1
0x4c0cd0b7b31dff9bed77931f3a6183fc64b44d5b.sol,BING,contract BING is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0x5af9ec6df6edea0761fa841ce56c2e4deb000b31.sol,ZebiMainCrowdsale,contract ZebiMainCrowdsale is Ownable{ using SafeMath for uint256; ZebiCoin public token; uint256 currentYearMinted; uint256 calenderYearMintCap; uint256 calenderYearStart; uint256 calenderYearEnd; uint256 vestedMintStartTime; uint256 zebiZCOShare; uint256 crowdsaleZCOCap; uint256 transStartTime; ZebiCoinCrowdsale public zcc; ZebiCoinTempMgr public tempMngr; uint64 public tokenDecimals; uint256 public startTime; uint256 public endTime; uint256 public goldListPeriod; uint256 public postGoldPeriod; uint256 public minTransAmount; uint256 public ethCap; mapping(address => uint256) mainContribution; mapping(address => bool) mainCancelledList; uint256 goldPeriodCap; bool goldListPeriodFlag; mapping(address=>uint256) goldListContribution; mapping(address => bool) goldList; mapping(address => bool) kycAcceptedList; address public wallet; bool public withinRefundPeriod; mapping(address => uint256) preSaleRefundsInMainSale; uint256 public tokens; uint256 public weiAmount; uint256 public ETHtoZWeirate; uint256 public mainWeiRaised; modifier inCancelledList { require(mainCancelledList[msg.sender]); _; },1
0x8ad0a831b7a17b322e8aebd188a4a8eb3bfdb5e8.sol,CPVToken,contract CPVToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 200000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0xa5cc679a3528956e8032df4f03756c077c1ee3f4.sol,Exchange,contract Exchange { function assert(bool assertion) { if (!assertion) throw; },1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x0e69d0a2bbb30abcb7e5cfea0e4fde19c00a8d47.sol,ContractLock,"contract ContractLock is DSStop { uint public unlockTime; mapping (address => bool) public isAdmin; event LogAddAdmin(address whoAdded, address newAdmin); event LogRemoveAdmin(address whoRemoved, address admin); constructor(uint _unlockTime) public { unlockTime = _unlockTime; isAdmin[msg.sender] = true; emit LogAddAdmin(msg.sender, msg.sender); }",1
0x33227687626914030c8213e31d021ce9940728ea.sol,STRSToken,contract STRSToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 50000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0x6c602f1798a453f90f249e208e2b64c7c09226f7.sol,Mentoring,"contract Mentoring is Ownable, ReentrancyGuard, CanReclaimToken { using SafeMath for uint256; event BecomeMentor(uint256 indexed mentorId); event BreakMentoring(uint256 indexed mentorId); event ChangeLevelPrice(uint256 indexed mentorId, uint256 newLevelPrice); event Income(address source, uint256 amount); event StartLecture(uint256 indexed lectureId, uint256 indexed mentorId, uint256 indexed studentId, uint256 mentorLevel, uint256 studentLevel, uint256 levelUp, uint256 levelPrice, uint256 startedAt, uint256 endsAt); struct Lecture { uint256 mentorId; uint256 studentId; uint256 mentorLevel; uint256 studentLevel; uint256 levelUp; uint256 levelPrice; uint256 startedAt; uint256 endsAt; }",1
0x1860d43a2a1b9b03907eb6a6b92ce256694dd315.sol,NescrowExchangeService,contract NescrowExchangeService { address owner = msg.sender; uint256 public feeRateLimit = 200; uint256 public takerFeeRate = 0; uint256 public makerFeeRate = 0; address public feeAddress; mapping (address => bool) public admins; mapping (bytes32 => uint256) public orderFills; mapping (bytes32 => uint256) public orderPaymentFills; mapping (bytes32 => bool) public withdrawn; mapping (bytes32 => bool) public transfers; mapping (address => mapping (address => uint256)) public balances; mapping (address => uint256) public tradesLocked; mapping (address => uint256) public disableFees; mapping (address => uint256) public tokenDecimals; mapping (address => bool) public tokenRegistered; struct EIP712Domain { string name; string version; uint256 chainId; address verifyingContract; },1
0x4d7242b3e25d54457854d7fe859924522feebeab.sol,ETNToken,"contract ETNToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 300; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal pure returns (uint256 ) { return _value * 10 ** decimals; }",1
0xec841c878435ba4f28bf305a00c1483db0d96a20.sol,Events,contract Events { DBInterface public database; constructor(address _database) public{ database = DBInterface(_database); },1
0x45ba41dcfa69ea1cc9b7c01ddc16f21e31036e79.sol,ERC223,"contract ERC223ReceivingContract { function tokenFallback(address _from, uint _value, bytes _data); }",1
0x47d4cc3d331525976553baff7c9e4d410087804a.sol,Proxy,"contract Proxy { Contract contr; uint256 public eth_balance; ERC20 public token; mapping (address => bool) public withdrew; address owner; constructor(address _contract, address _token) { owner = msg.sender; contr = Contract(_contract); token = ERC20(_token); eth_balance = contr.contract_eth_value_bonus(); }",1
0x25066b77ae6174d372a9fe2b1d7886a2be150e9b.sol,PolarisDEX,"contract PolarisDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); function PolarisDEX(address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x70f90f6688cb26b6a924a2155b3d9529a0b36a90.sol,Crowdsale,"contract Crowdsale is Pausable{ using SafeMath for uint256; BurnableToken public token; address public wallet; uint256 public rate = 1883800000000000000000; uint256 tokensSold; uint256 public weiRaised; uint256 startTime; uint256 phaze1Start = 1564617600; uint256 phaze1End = 1567209600; uint256 phaze2Start = 1567296000; uint256 phaze2End = 1569801600; uint256 phaze3Start = 1569888000; uint256 phaze3End = 1572480000; uint256 rate1 = 3767600000000000000000; uint256 rate2 = 2354750000000000000000; uint256 rate3 = 2093100000000000000000; uint256 public hardcap = 250000000000000000000000000; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount, uint256 time); event buyx(address buyer, address contractAddr, uint256 amount); constructor(address _wallet, BurnableToken _token, uint256 starttime, uint256 _cap) public{ require(_wallet != address(0)); require(_token != address(0)); wallet = _wallet; token = _token; startTime = starttime; hardcap = _cap; }",1
0x5c743a35e903f6c584514ec617acee0611cf44f3.sol,ExyToken,"contract ExyToken is ERC223MintableToken, SignatoryPausable { using SafeMath for uint256; VestingAllocation private partnerTokensAllocation; VestingAllocation private companyTokensAllocation; BountyTokenAllocation private bountyTokensAllocation; uint256 private constant ICO_TOKENS = 14503506112248500000000000; address private constant ICO_TOKENS_ADDRESS = 0x97c967524d1eacAEb375d4269bE4171581a289C7; uint256 private constant SEED_TOKENS = 11700000000000000000000000; address private constant SEED_TOKENS_ADDRESS = 0x7C32c7649aA1335271aF00cd4280f87166474778; uint256 private constant COMPANY_TOKENS_PER_PERIOD = 727875169784680000000000; uint256 private constant COMPANY_PERIODS = 36; uint256 private constant MINUTES_IN_COMPANY_PERIOD = 60 * 24 * 365 / 12; uint256 private constant PARTNER_TOKENS_PER_PERIOD = 23821369192953200000000000; uint256 private constant PARTNER_PERIODS = 1; uint256 private constant MINUTES_IN_PARTNER_PERIOD = MINUTES_IN_COMPANY_PERIOD * 18; uint256 private constant BOUNTY_TOKENS = 2382136919295320000000000; uint256 private constant MARKETING_COST_TOKENS = 794045639765106000000000; address private constant MARKETING_COST_ADDRESS = 0xF133ef3BE68128c9Af16F5aF8F8707f7A7A51452; uint256 public INIT_DATE; string public constant name = ; bytes32 public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant totalSupply = ( COMPANY_TOKENS_PER_PERIOD * COMPANY_PERIODS + PARTNER_TOKENS_PER_PERIOD * PARTNER_PERIODS + BOUNTY_TOKENS + MARKETING_COST_TOKENS + ICO_TOKENS + SEED_TOKENS); function ExyToken(address signatory0, address signatory1, address signatory2) SignatoryPausable(signatory0, signatory1, signatory2) public { INIT_DATE = block.timestamp; companyTokensAllocation = new VestingAllocation( COMPANY_TOKENS_PER_PERIOD, COMPANY_PERIODS, MINUTES_IN_COMPANY_PERIOD, INIT_DATE); partnerTokensAllocation = new VestingAllocation( PARTNER_TOKENS_PER_PERIOD, PARTNER_PERIODS, MINUTES_IN_PARTNER_PERIOD, INIT_DATE); bountyTokensAllocation = new BountyTokenAllocation( BOUNTY_TOKENS ); mint(MARKETING_COST_ADDRESS, MARKETING_COST_TOKENS); mint(ICO_TOKENS_ADDRESS, ICO_TOKENS); mint(SEED_TOKENS_ADDRESS, SEED_TOKENS); }",1
0x4d7edd5f94515b0f35b38f6fb2ea975a20823465.sol,CryptoSprites,contract CryptoSprites is ERC721 { address public owner; address KittyCoreAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; address SaleClockAuctionAddress = 0xb1690C08E213a35Ed9bAb7B318DE14420FB57d8C; address charityAddress = 0xb30cb3b3E03A508Db2A0a3e07BA1297b47bb0fb1; uint public etherForOwner; uint public etherForCharity; uint public ownerCut = 15; uint public charityCut = 15; uint public featurePrice = 10**16; uint public priceMultiplier = 1; uint public priceDivider = 10; modifier onlyOwner { require(msg.sender == owner); _; },1
0x24a7de87b3bd7298bbf8966fdf170c558d69ecc4.sol,METADOLLAR,"contract METADOLLAR is ERC20Interface, Owned, SafeMath { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public _totalSupply = 1000000000000000000000000000000; uint256 public icoMin = 1000000000000000; uint256 public icoLimit = 1000000000000000000000000000000; uint256 public countHolders = 0; uint256 public amountOfInvestments = 0; uint256 public icoPrice; uint256 public dolRate = 1000; uint256 public ethRate = 1; uint256 public sellRate = 900; uint256 public commissionRate = 1000; uint256 public sellPrice; uint256 public currentTokenPrice; uint256 public commission; bool public icoIsRunning; bool public minimalGoalReached; bool public icoIsClosed; mapping (address => uint256) public tokenBalanceOf; mapping(address => mapping (address => uint256)) allowed; mapping(address => bool) frozenAccount; event FrozenFunds(address initiator, address account, string status); event BonusChanged(uint8 bonusOld, uint8 bonusNew); event minGoalReached(uint256 minIcoAmount, string notice); event preIcoEnded(uint256 preIcoAmount, string notice); event priceUpdated(uint256 oldPrice, uint256 newPrice, string notice); event withdrawed(address _to, uint256 summe, string notice); event deposited(address _from, uint256 summe, string notice); event orderToTransfer(address initiator, address _from, address _to, uint256 summe, string notice); event tokenCreated(address _creator, uint256 summe, string notice); event tokenDestroyed(address _destroyer, uint256 summe, string notice); event icoStatusUpdated(address _initiator, string status); function STARTMETADOLLAR() { icoIsRunning = true; minimalGoalReached = false; icoIsClosed = false; tokenBalanceOf[this] += _totalSupply; allowed[this][owner] = _totalSupply; allowed[this][supervisor] = _totalSupply; currentTokenPrice = 1 * 1; icoPrice = ethRate * dolRate; sellPrice = sellRate * ethRate; updatePrices(); }",1
0x4b96bf1fef93a216914fc843d81207a027ce52b3.sol,VUULRVesting,"contract VUULRVesting is XClaimable, Salvageable { using SafeMath for uint; struct VestingSchedule { uint lockPeriod; uint numPeriods; uint tokens; uint amountWithdrawn; uint startTime; }",1
0x5af7af54e8bc34b293e356ef11fffe51d6f9ae78.sol,Marketplace,contract Marketplace is Ownable { modifier onlyJingle() { require(msg.sender == address(jingleContract)); _; },1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,LockinManager,contract LockinManager { using SafeMath for uint256; struct Lock { uint256 amount; uint256 unlockDate; uint256 lockedFor; },1
0xb602f224523c89c80dd8e970573291c63beeb778.sol,Crowdsale,contract Crowdsale is Ownable{ using SafeMath for uint; uint public decimals = 3; BineuroToken public token; function Crowdsale(address _tokenAddress) public{ token = BineuroToken(_tokenAddress); techSupport = msg.sender; token.setCrowdsaleContract(this); owner = token.getOwner(); },1
0x6b62f10b1d042d3ed601899ca25f80f9dbc92644.sol,TwoCoinsOneMoonGame,contract TwoCoinsOneMoonGame { struct Bettor { address account; uint256 amount; },1
0xec841c878435ba4f28bf305a00c1483db0d96a20.sol,Events,contract Events { DBInterface public database; constructor(address _database) public{ database = DBInterface(_database); },1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0xec841c878435ba4f28bf305a00c1483db0d96a20.sol,Events,contract Events { DBInterface public database; constructor(address _database) public{ database = DBInterface(_database); },1
0x0ee14f47320604d894fffffc8639772382937bee.sol,OpportyWhiteListHold,contract OpportyWhiteListHold is Ownable { using SafeMath for uint256; OpportyToken public OppToken; struct Holder { bool isActive; uint tokens; uint8 holdPeriod; uint holdPeriodTimestamp; bool withdrawed; },1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x91dfe531ff8ba876a505c8f1c98bafede6c7effc.sol,MatchingMarket,"contract MatchingMarket is MatchingEvents, ExpiringMarket, DSNote { bool public buyEnabled = true; bool public matchingEnabled = true; struct sortInfo { uint next; uint prev; uint delb; }",1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDView,"contract BitSTDView { BitSTDLogic private logic; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function balanceOf(address add)constant public returns (uint256) { return logic.balanceOf(add); }",1
0x266fe968ce45fa3373726329ce6104b9ca4a9c66.sol,CreditGAME,"contract CreditGAME is Owned, SafeMath, LinkedList{ mapping(address => bool) approvedGames; mapping(address => GameLock) gameLocks; mapping(address => bool) public isGameLocked; mapping(uint => address) public concludedGames; uint public amountLocked = 0; uint public concludedGameIndex = 0; struct GameLock{ uint amount; uint lockDuration; }",1
0x1d899280f446aab65971e41611b5bb5516dd47f9.sol,CryptoMiningWar,contract CryptoMiningWar is PullPayment { bool public initialized = false; uint256 public roundNumber = 0; uint256 public deadline; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public HALF_TIME = 8 hours; uint256 public ROUND_TIME = 86400 * 7; uint256 public prizePool = 0; uint256 BASE_PRICE = 0.005 ether; uint256 RANK_LIST_LIMIT = 10000; uint256 public totalMiniGame = 0; uint256 private numberOfMiners = 8; uint256 private numberOfBoosts = 5; uint256 private numberOfRank = 21; CryptoEngineerInterface public Engineer; mapping(uint256 => address) public miniGameAddress; mapping(uint256 => MinerData) private minerData; mapping(address => Player) public players; mapping(address => uint256) public boosterReward; mapping(uint256 => BoostData) private boostData; mapping(address => bool) public miniGames; address[21] rankList; address public administrator; struct Player { uint256 roundNumber; mapping(uint256 => uint256) minerCount; uint256 hashrate; uint256 crystals; uint256 lastUpdateTime; },1
0x0f1da17b33df90c078fd2fb4b9011a64af3c67a6.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; using Address for address; mapping(address => uint256) internal _balances; mapping(address => mapping(address => uint256)) private _allowed; uint256 internal _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x013f7a6b98010e85fd4c8887d30f48c409b5643d.sol,TimedEscrow,"contract TimedEscrow is ContractReceiver, Seriality { using Array256Lib for uint256[]; struct Transaction { uint256 value; address to_address; uint256 time; bool valid; bool executed; }",1
0xbc97f1508fdeb0a63b25f3a4806b62ef5370e8ab.sol,CryptoBeginnerQuest,contract CryptoBeginnerQuest { using SafeMath for uint256; address private administrator; address public miningWarAddress; CryptoEngineerInterface public Engineer; CryptoDepositInterface public Deposit; CryptoMiningWarInterface public MiningWar; CryptoAirdropGameInterface public AirdropGame; CryptoBossWannaCryInterface public BossWannaCry; CryptoArenaInterface public Arena; uint256 private miningWarDeadline; uint256 private miningWarRound; mapping(address => Player) private players; mapping(address => MinerQuest) private minerQuests; mapping(address => EngineerQuest) private engineerQuests; mapping(address => DepositQuest) private depositQuests; mapping(address => JoinAirdropQuest) private joinAirdropQuests; mapping(address => AtkBossQuest) private atkBossQuests; mapping(address => AtkPlayerQuest) private atkPlayerQuests; mapping(address => BoosterQuest) private boosterQuests; mapping(address => RedbullQuest) private redbullQuests; struct Player { uint256 miningWarRound; uint256 currentQuest; },1
0x69b794ec295d665fc527230523f7012eea1dc03e.sol,Crowdsale,"contract Crowdsale is SafeMath { address public tokenAddress = 0xa5FD4f631Ddf9C37d7B8A2c429a58bDC78abC843; ERC20Basic public ipc = ERC20Basic(tokenAddress); address public crowdsaleAgent = 0x783fE4521c2164eB6a7972122E7E33a1D1A72799; address public owner = 0xa52858fB590CFe15d03ee1F3803F2D3fCa367166; uint256 public weiRaised; uint256 public minimumEtherAmount = 0.2 ether; uint256 public startTime = 1520082000; uint256 public deadlineOne = 1520168400; uint256 public deadlineTwo = 1520427600; uint256 public deadlineThree = 1520773200; uint256 public endTime = 1522674000; uint public firstRate = 6000; uint public secondRate = 5500; uint public thirdRate = 5000; uint public finalRate = 4400; mapping(address => uint256) public distribution; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); modifier onlyCrowdsaleAgent { require(msg.sender == crowdsaleAgent); _; }",1
0x4cb200957a11cbff512b4752e6ee38c9253fdd54.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x0e752b742f744fdc2d93774da44c37b72c3e6952.sol,CraftyCrowdsale,"contract CraftyCrowdsale is Pausable { using SafeMath for uint256; mapping(address => uint256) received; MintableToken public token; uint256 public preSaleStart; uint256 public preSaleEnd; uint256 public saleStart; uint256 public saleEnd; uint256 public issuedTokens = 0; uint256 public constant hardCap = 5000000000 * 10**8; uint256 constant teamCap = 1450000000 * 10**8; uint256 constant advisorCap = 450000000 * 10**8; uint256 constant bountyCap = 100000000 * 10**8; uint256 constant fundCap = 3000000000 * 10**8; uint256 constant lockTime = 180 days; address public etherWallet; address public teamWallet; address public advisorWallet; address public fundWallet; address public bountyWallet; TokenTimelock teamTokens; uint256 public rate; enum State { BEFORE_START, SALE, REFUND, CLOSED }",1
0x6593a7140f3718efff638b72a9b6083db47ce0d2.sol,Crowdsale,"contract Crowdsale is GuidedByRoles, ERC20Provider{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 90 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0xeb907a50921e052cbee233811beaf0839d2a98fd.sol,Advertisement,contract Advertisement { struct Filters { string countries; string packageName; uint[] vercodes; },1
0x4c0cd0b7b31dff9bed77931f3a6183fc64b44d5b.sol,BING,contract BING is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0x203dad4c2af33c0ff1b60b4579cf956a60a6cb23.sol,ListingsERC20,contract ListingsERC20 is Ownable { using SafeMath for uint256; struct Listing { address seller; address tokenContractAddress; uint256 price; uint256 allowance; uint256 dateStarts; uint256 dateEnds; },1
0x0045684552109f8551cc5c8aa7b1f52085adff47.sol,BaseWallet,"contract BaseWallet { address public implementation; address public owner; mapping (address => bool) public authorised; mapping (bytes4 => address) public enabled; uint public modules; event AuthorisedModule(address indexed module, bool value); event EnabledStaticCall(address indexed module, bytes4 indexed method); event Invoked(address indexed module, address indexed target, uint indexed value, bytes data); event Received(uint indexed value, address indexed sender, bytes data); event OwnerChanged(address owner); modifier moduleOnly { require(authorised[msg.sender], ); _; }",1
0x6d7efeb3df42e6075fa7cf04e278d2d69e26a623.sol,LuckyYouToken,contract LuckyYouToken is PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; constructor() public{ totalSupply = 1 * 1000 * 1000 * 1000 * (10 ** uint256(decimals)); balances[owner] = totalSupply; },1
0x1860d43a2a1b9b03907eb6a6b92ce256694dd315.sol,NescrowExchangeService,contract NescrowExchangeService { address owner = msg.sender; uint256 public feeRateLimit = 200; uint256 public takerFeeRate = 0; uint256 public makerFeeRate = 0; address public feeAddress; mapping (address => bool) public admins; mapping (bytes32 => uint256) public orderFills; mapping (bytes32 => uint256) public orderPaymentFills; mapping (bytes32 => bool) public withdrawn; mapping (bytes32 => bool) public transfers; mapping (address => mapping (address => uint256)) public balances; mapping (address => uint256) public tradesLocked; mapping (address => uint256) public disableFees; mapping (address => uint256) public tokenDecimals; mapping (address => bool) public tokenRegistered; struct EIP712Domain { string name; string version; uint256 chainId; address verifyingContract; },1
0x6f123503fc11f4a915e222808349c8aff4d6c3c0.sol,XRXToken,contract XRXToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 5000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0xaf8eabf89f5664a2bc82ca415a4337821cd54d65.sol,Crowdsale,"contract Crowdsale is Bonus { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public rate; uint256 public openingTimePeriodOne; uint256 public closingTimePeriodOne; uint256 public openingTimePeriodTwo; uint256 public closingTimePeriodTwo; uint256 public bonusDeliverTime; uint256 public bonusRatePrivateSale; uint256 public bonusRatePeriodOne; uint256 public bonusRatePeriodTwo; uint256 decimals; uint256 public tokenUnsold; uint256 public bonusUnsold; uint256 public constant minPurchaseAmount = 0.1 ether; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event TokenBonus(address indexed purchaser, address indexed beneficiary, uint256 bonus); modifier onlyWhileOpen { require(block.timestamp <= closingTimePeriodTwo); _; }",1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ClockAuction,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x4cd988afbad37289baaf53c13e98e2bd46aaea8c.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint256 supply) { _balances[msg.sender] = supply; _supply = supply; }",1
0x3a773baa30d09f04da0bd869b142ea5503a31022.sol,MiniMeTokenSimple,"contract MiniMeTokenSimple is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; address public parentToken; uint public parentSnapShotBlock; uint public creationBlock; address public tokenFactory; function MiniMeTokenSimple( address _tokenFactory, address _parentToken, uint _parentSnapShotBlock, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, bool _transfersEnabled ) { tokenFactory = _tokenFactory; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; parentToken = _parentToken; parentSnapShotBlock = _parentSnapShotBlock; transfersEnabled = _transfersEnabled; creationBlock = block.number; }",1
0xc3e43d422d5e6f94315622d96a96058689c52ec8.sol,BitNauticCrowdsaleTokenDistributor,"contract BitNauticCrowdsaleTokenDistributor is Ownable { using SafeMath for uint256; uint256 public constant ICOStartTime = 1531267200; uint256 public constant ICOEndTime = 1536969600; uint256 public teamSupply = 3000000 * 10 ** 18; uint256 public bountySupply = 2500000 * 10 ** 18; uint256 public reserveSupply = 5000000 * 10 ** 18; uint256 public advisorSupply = 2500000 * 10 ** 18; uint256 public founderSupply = 2000000 * 10 ** 18; MintableToken public token; BitNauticWhitelist public whitelist; BitNauticCrowdsale public crowdsale; mapping (address => bool) public hasClaimedTokens; constructor(MintableToken _token, BitNauticWhitelist _whitelist, BitNauticCrowdsale _crowdsale) public { token = _token; whitelist = _whitelist; crowdsale = _crowdsale; }",1
0x7976af0ae2124a0771d5287aa16017b3f9dd43a4.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; bool transferable; modifier isTransferable() { require(transferable || msg.sender == owner); _; },1
0x5a779aaeb53d2cba1755442c38dd6721c0cb31d0.sol,RenCrowdsale,"contract RenCrowdsale is Ownable, ReentrancyGuard { using SafeMath for uint256; uint256 public fiveHourCap; uint256 public cap; uint256 public goal; uint256 public rate; address public wallet; RefundVault public vault; RepublicToken public token; uint256 public startTime; uint256 public endTime; uint256 public fiveHours; bool public isFinalized = false; uint256 public weiRaised; mapping(address => bool) public whitelist; mapping(address => uint256) public contribution; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event TokenRelease(address indexed beneficiary, uint256 amount); event TokenRefund(address indexed refundee, uint256 amount); event Finalized(); function RenCrowdsale( address _token, address _wallet, uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _cap, uint256 _fiveHourCap, uint256 _goal ) { require(_startTime >= getBlockTimestamp()); require(_endTime >= _startTime); require(_rate > 0); require(_goal > 0); require(_cap > 0); require(_wallet != 0x0); vault = new RefundVault(_wallet); token = RepublicToken(_token); startTime = _startTime; wallet = _wallet; endTime = _endTime; fiveHours = startTime + 5 * 1 hours; fiveHourCap = _fiveHourCap; rate = _rate; goal = _goal; cap = _cap; }",1
0xec3184af01ad86be9b54b6eb88c582bba53f4f65.sol,TokenTrust,"contract TokenTrust { address public owner; uint256 start; mapping(address=>uint256) public trust; event AddTrust(address indexed _token, uint256 indexed _trust); modifier onlyOwner() { if (msg.sender!=owner) revert(); _; }",1
0x6b4df2aa3d64d8dc06120ef4391513e4170af4a7.sol,GeneralTransferManager,contract GeneralTransferManager is ITransferManager { using SafeMath for uint256; address public issuanceAddress = address(0); address public signingAddress = address(0); bytes32 public constant WHITELIST = ; bytes32 public constant FLAGS = ; struct TimeRestriction { uint256 fromTime; uint256 toTime; uint256 expiryTime; bool canBuyFromSTO; },1
0x340b84a70520f721fde96c7ad663383c31e416cb.sol,BurnableToken,"contract BurnableToken is BasicToken{ event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { require(_value <= balances.balanceOf(msg.sender)); address burner = msg.sender; balances.subBalance(burner, _value); totalSupply_ = totalSupply_.sub(_value); emit Burn(burner, _value); emit Transfer(burner, address(0), _value); }",1
0x6593a7140f3718efff638b72a9b6083db47ce0d2.sol,Crowdsale,"contract Crowdsale is GuidedByRoles, ERC20Provider{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 90 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x6593a7140f3718efff638b72a9b6083db47ce0d2.sol,Crowdsale,"contract Crowdsale is GuidedByRoles, ERC20Provider{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 90 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x6dbb4e882f967432fc0f9200e9ca577c916d8a68.sol,Bussiness,contract Bussiness is Ownable { IERC721 public erc721Address = IERC721(0x06012c8cf97bead5deae237070f9587f8e7a266d); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdAC17F958D2ee523a2206206994597C13D831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; uint256 public balance = address(this).balance; constructor() public {},1
0x1860d43a2a1b9b03907eb6a6b92ce256694dd315.sol,NescrowExchangeService,contract NescrowExchangeService { address owner = msg.sender; uint256 public feeRateLimit = 200; uint256 public takerFeeRate = 0; uint256 public makerFeeRate = 0; address public feeAddress; mapping (address => bool) public admins; mapping (bytes32 => uint256) public orderFills; mapping (bytes32 => uint256) public orderPaymentFills; mapping (bytes32 => bool) public withdrawn; mapping (bytes32 => bool) public transfers; mapping (address => mapping (address => uint256)) public balances; mapping (address => uint256) public tradesLocked; mapping (address => uint256) public disableFees; mapping (address => uint256) public tokenDecimals; mapping (address => bool) public tokenRegistered; struct EIP712Domain { string name; string version; uint256 chainId; address verifyingContract; },1
0x3ac86159fad58c90aaea1c61974d69d4f8ce8e77.sol,Crowdsale,contract Crowdsale is Ownable { using SafeMath for uint256; SingleTokenCoin public token; WrapperOraclize private wrapper = WrapperOraclize(0xfC484c66daE464CC6055d7a4782Ec8761dc9842F); uint256 private angel_sale_start; uint256 private angel_sale_finish; uint256 private pre_sale_start; uint256 private pre_sale_finish; uint256 private public_sale_start; uint256 private public_sale_finish; bool private isAngel; bool private isPreSale; bool private isPublic; uint256 private angel_rate; uint256 private public_rate; uint256 private decimals; uint256 private totalETH; address public coreTeamAddr; address public itDevAddr; address public futDevAddr; address public commFoundAddr; address public socWarefareAddr; address public marketingAddr; address public unsoldAddr; address public collectAddr; bool public mintingFinished = false; mapping(address => uint256) private founding_buyers_token; mapping(address => uint256) private angel_buyers_eth; mapping(address => uint256) private angel_buyers_token; mapping(address => uint256) private pre_sale_buyers_eth; mapping(address => uint256) private pre_sale_buyers_token; mapping(address => uint256) private pe_buyers_token; mapping(address => uint256) private public_buyers_eth; mapping(address => uint256) private public_buyers_token; address[] private founding_investors; address[] private pre_sale_investors; address[] private angel_investors; address[] private pe_investors; address[] private public_investors; uint256 private soldTokens; uint256 private maxcup; uint256 private totalAmount; uint256 private foundingAmount; uint256 private angelAmount; uint256 private preSaleAmount; uint256 private PEInvestorAmount; uint256 private publicSaleAmount; uint256 private coreTeamAmount; uint256 private coreTeamAuto; uint256 private coreTeamManual; uint256 private itDevAmount; uint256 private futDevAmount; uint256 private commFoundAmount; uint256 private socWarefareAmount; uint256 private marketingAmount; uint256 private angel_sale_sold; uint256 private pre_sale_sold; uint256 private public_sale_sold; uint256 private founding_sold; uint256 private peInvestors_sold; uint256 private angel_sale_totalETH; uint256 private pre_sale_totalETH; uint256 private public_sale_totalETH; uint256 private firstPhaseAmount; uint256 private secondPhaseAmount; uint256 private thirdPhaseAmount; uint256 private fourPhaseAmount; uint256 private firstPhaseDiscount; uint256 private secondPhaseDiscount; uint256 private thirdPhaseDiscount; uint256 private fourPhaseDiscount; uint256 private currentPhase; bool private moveTokens; bool withdrowTokensComplete = false; function Crowdsale(address token_addr) { token = SingleTokenCoin(token_addr); public_rate = 3546099290780141; angel_rate = 20; decimals = 35460992907801; angel_sale_start = now - 3 days; angel_sale_finish = 1510488000; pre_sale_start = 1510491600; pre_sale_finish = 1512561600; public_sale_start = 1512565200; public_sale_finish = public_sale_start + 14 days; moveTokens = false; isAngel = true; isPreSale = false; isPublic = false; currentPhase = 1; founding_sold = 0; peInvestors_sold = 0; angel_sale_sold = 0; pre_sale_sold = 0; public_sale_sold = 0; angel_sale_totalETH = 0; pre_sale_totalETH = 0; public_sale_totalETH = 0; firstPhaseAmount = 18750000E18; secondPhaseAmount = 37500000E18; thirdPhaseAmount = 56250000E18; fourPhaseAmount = 75000000E18; firstPhaseDiscount = 30; secondPhaseDiscount = 40; thirdPhaseDiscount = 50; fourPhaseDiscount = 60; totalAmount = 500000000E18; foundingAmount = 10000000E18; angelAmount = 25000000E18; preSaleAmount = 75000000E18; PEInvestorAmount = 50000000E18; publicSaleAmount = 100000000E18; coreTeamAmount = 100000000E18; coreTeamAuto = 60000000E18; coreTeamManual = 40000000E18; itDevAmount = 50000000E18; futDevAmount = 50000000E18; commFoundAmount = 15000000E18; socWarefareAmount = 10000000E18; marketingAmount = 15000000E18; mintingFinished = false; coreTeamAddr = 0xB0A3A845cfA5e2baCD3925Af85c59dE4D32D874f; itDevAddr = 0x61528ffdCd4BC26c81c88423018780b399Fbb8e7; futDevAddr = 0xA1f9C3F137496e6b8bA4445d15b0986CaA22FDe3; commFoundAddr = 0xC30a0E7FFad754A9AD2A1C1cFeB10e05f7C7aB6A; socWarefareAddr = 0xd5d692C89C83313579d02C94F4faE600fe30D1d9; marketingAddr = 0x5490510072b929273F65dba4B72c96cd45A99b5A; unsoldAddr = 0x18051b5b0F1FDb4D44eACF2FA49f19bB80105Fc1; collectAddr = 0xB338121B8e5dA0900a6E8580321293f3CF52E58D; },1
0x065313f29dc4a4b8b5fc4915059d122065519957.sol,Future1Exchange,contract Future1Exchange { address public adminaddr; mapping (address => mapping(address => uint256)) public dep_token; mapping (address => uint256) public dep_ETH; constructor() public { adminaddr = msg.sender; },1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0x71d57fc11e9d85d8ce2b5acc9019af399bf0cbcb.sol,LockToken,"contract LockToken is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; event TokenReleased(address beneficiary, uint256 token_amount); constructor(address tokenContractAddress, address _beneficiary) public{ token_reward = token(tokenContractAddress); beneficiary = _beneficiary; }",1
0x0ce95ef378059f38c5fa21e6d81a5895c0d9911b.sol,Game,contract Game { using GlobalTypes for GlobalTypes.Global; using MarketTypes for MarketTypes.MarketListing; using MissionParametersTypes for MissionParametersTypes.MissionParameters; using GameCommon for GameCommon.LaunchRocketStackFrame; address public m_Owner; AbstractDatabase public m_Database; AbstractGameHidden public m_GameHidden; bool public m_Paused; uint256 constant GlobalCategory = 0; uint256 constant RocketCategory = 1; uint256 constant OwnershipCategory = 2; uint256 constant InventoryCategory = 3; uint256 constant MarketCategory = 4; uint256 constant ProfitFundsCategory = 5; uint256 constant CompetitionFundsCategory = 6; uint256 constant MissionParametersCategory = 7; uint256 constant CompetitionScoresCategory = 8; uint256 constant WithdrawalFundsCategory = 9; uint256 constant ReferralCategory = 10; uint256 constant RocketStockCategory = 11; uint256 constant RocketStockInitializedCategory = 12; address constant NullAddress = 0; uint256 constant MaxCompetitionScores = 10; mapping(uint32 => RocketTypes.StockRocket) m_InitialRockets; modifier OnlyOwner() { require(msg.sender == m_Owner); _; },1
0x416e18790790edb098cb17a7d490caa1262f5772.sol,LoomTimeVault,"contract LoomTimeVault is Ownable { LoomToken public loomToken; mapping(address => uint256) public beneficiaries; uint256 public releaseTime; event BeneficiaryAdded(address _beneficiaryAddress, uint256 _amount); event BeneficiaryWithdrawn(address _beneficiaryAddress, uint256 _amount); event OwnerWithdrawn(address _ownerAddress, uint256 _amount); modifier onlyAfterReleaseTime() { require(now >= releaseTime); _; }",1
0x370f0fe5f1c03892b2dc950a89c6eaff4980dac3.sol,KittenSelfDrop2,"contract KittenSelfDrop2 is Ownable { KittenCoin public kittenContract; uint8 public dropNumber; uint256 public kittensDroppedToTheWorld; uint256 public kittensRemainingToDrop; uint256 public holderAmount; uint256 public basicReward; uint256 public holderReward; mapping (uint8 => uint256[]) donatorReward; uint8 donatorRewardLevels; uint8 public totalDropTransactions; mapping (address => uint8) participants; function KittenSelfDrop2 () { address c = 0xac2BD14654BBf22F9d8f20c7b3a70e376d3436B4; kittenContract = KittenCoin(c); dropNumber = 1; kittensDroppedToTheWorld = 0; kittensRemainingToDrop = 0; basicReward = 50000000000; holderReward = 50000000000; holderAmount = 5000000000000; donatorReward[0]=[1,10000000000]; donatorReward[1]=[1000000000000000,100000000000]; donatorReward[2]=[10000000000000000,500000000000]; donatorRewardLevels = 3; totalDropTransactions = 0; }",1
0x2682e3ad5358932ac5cd8f8616912cec76ad680c.sol,CupExchange,"contract CupExchange { using SafeMath for uint256; using SafeMath for int256; address public owner; token internal teamCup; token internal cup; uint256 public exchangePrice; bool public halting = true; event Halted(bool halting); event Exchange(address user, uint256 distributedAmount, uint256 collectedAmount); constructor(address cupToken, address teamCupToken) public { owner = msg.sender; teamCup = token(teamCupToken); cup = token(cupToken); }",1
0x02f61fd266da6e8b102d4121f5ce7b992640cf98.sol,LikeCoin,"contract LikeCoin is ERC20, HasOperator { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public supply = 0; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; address public crowdsaleAddr = 0x0; address public contributorPoolAddr = 0x0; uint256 public contributorPoolMintQuota = 0; address[] public creatorsPoolAddrs; mapping(address => bool) isCreatorsPool; uint256 public creatorsPoolMintQuota = 0; mapping(address => uint256) public lockedBalances; uint public unlockTime = 0; SignatureChecker public signatureChecker = SignatureChecker(0x0); bool public signatureCheckerFreezed = false; address public signatureOwner = 0x0; bool public allowDelegate = true; mapping (address => mapping (uint256 => bool)) public usedNonce; mapping (address => bool) public transferAndCallWhitelist; event Lock(address indexed _addr, uint256 _value); event SignatureCheckerChanged(address _newSignatureChecker); function LikeCoin(uint256 _initialSupply, address _signatureOwner, address _sigCheckerAddr) public { supply = _initialSupply; balances[owner] = _initialSupply; signatureOwner = _signatureOwner; signatureChecker = SignatureChecker(_sigCheckerAddr); Transfer(0x0, owner, _initialSupply); }",1
0xebcf88fb2783bbb75b12df3f33627efa894afea4.sol,SPACEDICE,"contract SPACEDICE is Mortal, usingNRE{ uint minBet = 1000000000000000; event Roll(bool _won, uint256 _dice1, uint256 _dice2, uint256 _roll1, uint256 _roll2, uint _amount); constructor() payable public {}",1
0x536c7efeebff067a69393133b1c87a163a6b0598.sol,ECM,"contract ECMinterface { function ECMFallback(address _from, uint _value, uint _code); }",1
0x4c65398a84088338bdf80169292f2f067428f3af.sol,DSStop,"contract DSStop is DSAuth, DSNote { bool public stopped; modifier stoppable { assert (!stopped); _; }",1
0xb4a3fb248d39370c1f8081b73fa7098167c8142b.sol,SaiLPC,"contract SaiLPC is DSThing { ERC20 public ref; ERC20 public alt; DSValue public pip; uint256 public gap; DSToken public lps; function SaiLPC(ERC20 ref_, ERC20 alt_, DSValue pip_, DSToken lps_) public { ref = ref_; alt = alt_; pip = pip_; lps = lps_; gap = WAD; }",1
0x4d7242b3e25d54457854d7fe859924522feebeab.sol,ETNToken,"contract ETNToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 300; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal pure returns (uint256 ) { return _value * 10 ** decimals; }",1
0x6a3f85f8a86e7b3de0269c20e9ab066dd57b8e21.sol,AccRegCenter,contract AccRegCenter is Ownable { struct User { address useraddress; uint useramount; bool lastTransfer; },1
0x0d5eae179709e92b3bff65731158e8291c49eafb.sol,GaintDex,"contract GaintDex is SafeMath { address public admin; address public feeAccount; uint public feeMake; uint public feeTake; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor() { admin = msg.sender; feeAccount = msg.sender; feeMake = 700000000000000; feeTake = 700000000000000; }",1
0x69b794ec295d665fc527230523f7012eea1dc03e.sol,Crowdsale,"contract Crowdsale is SafeMath { address public tokenAddress = 0xa5FD4f631Ddf9C37d7B8A2c429a58bDC78abC843; ERC20Basic public ipc = ERC20Basic(tokenAddress); address public crowdsaleAgent = 0x783fE4521c2164eB6a7972122E7E33a1D1A72799; address public owner = 0xa52858fB590CFe15d03ee1F3803F2D3fCa367166; uint256 public weiRaised; uint256 public minimumEtherAmount = 0.2 ether; uint256 public startTime = 1520082000; uint256 public deadlineOne = 1520168400; uint256 public deadlineTwo = 1520427600; uint256 public deadlineThree = 1520773200; uint256 public endTime = 1522674000; uint public firstRate = 6000; uint public secondRate = 5500; uint public thirdRate = 5000; uint public finalRate = 4400; mapping(address => uint256) public distribution; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); modifier onlyCrowdsaleAgent { require(msg.sender == crowdsaleAgent); _; }",1
0x038ee87d74a14adf58eb71075ec9a0910fde353b.sol,HDCToken,contract HDCToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 500000000 * (10**5); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function HDCToken () { owner = msg.sender; },1
0x0e69d0a2bbb30abcb7e5cfea0e4fde19c00a8d47.sol,ContractLock,"contract ContractLock is DSStop { uint public unlockTime; mapping (address => bool) public isAdmin; event LogAddAdmin(address whoAdded, address newAdmin); event LogRemoveAdmin(address whoRemoved, address admin); constructor(uint _unlockTime) public { unlockTime = _unlockTime; isAdmin[msg.sender] = true; emit LogAddAdmin(msg.sender, msg.sender); }",1
0x301487766dcf283592b11b5988e5c4e4630dfbe5.sol,EDex,"contract EDex is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x3aa927a97594c3ab7d7bf0d47c71c3877d1de4a1.sol,MatchingMarket,"contract MatchingMarket is MatchingEvents, ExpiringMarket, DSNote { bool public buyEnabled = true; bool public matchingEnabled = true; struct sortInfo { uint next; uint prev; }",1
0x330bebabc9a2a4136e3d1cb38ca521f5a95aec2e.sol,KoreaShow,"contract KoreaShow is TokenController, Controlled { using SafeMath for uint256; uint256 public startFundingTime; uint256 public endFundingTime; uint256 constant public maximumFunding = 100 ether; uint256 public tokensPerEther = 31000; uint256 constant oneDay = 86400; uint256 public totalCollected = 0; bool public paused; string public techProvider = ; Token public tokenContract; bool public finalized = false; bool public allowChange = true; bool private transfersEnabled = true; address private vaultAddress; bool private initialed = false; event Payment(address indexed _sender, uint256 _ethAmount, uint256 _tokenAmount); function KoreaShow( uint _startFundingTime, uint _endFundingTime, address _vaultAddress, address _tokenAddress ) public { require(_endFundingTime > now); require(_endFundingTime >= _startFundingTime); require(_vaultAddress != 0); require(_tokenAddress != 0); require(!initialed); startFundingTime = _startFundingTime; endFundingTime = _endFundingTime; vaultAddress = _vaultAddress; tokenContract = Token(_tokenAddress); paused = false; initialed = true; }",1
0x655f1cb6616d7f0550007498113e72d7d5c5d4bb.sol,MedalClaim,"contract MedalClaim is AccessControl, SafeMath { address public angelCardDataContract = 0x6D2E76213615925c5fc436565B5ee788Ee0E86DC; address public petCardDataContract = 0xB340686da996b8B3d486b4D27E38E38500A9E926; address public accessoryDataContract = 0x466c44812835f57b736ef9F63582b8a6693A14D0; address public leaderboardDataContract = 0x9A1C755305c6fbf361B4856c9b6b6Bbfe3aCE738; address public medalDataContract = 0x33A104dCBEd81961701900c06fD14587C908EAa3; event EventMedalSuccessful(address owner,uint64 Medal); struct Angel { uint64 angelId; uint8 angelCardSeriesId; address owner; uint16 battlePower; uint8 aura; uint16 experience; }",1
0x286bbee3f20f1702e707e58d33dc28a69e7efd4e.sol,Contract,contract Contract is Controller { using SafeMath for uint256; struct Contributor { uint256 balance; uint256 fee; uint8 rounds; bool whitelisted; },1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,Token,"contract Token { using SafeMath for uint256; mapping (address => uint256) public balances; mapping(address => mapping (address => uint256)) allowed; address[] allTokenHolders; string public name; string public symbol; uint8 public decimals; uint256 totalSupplyAmount = 0; address public refundManagerContractAddress; AuthenticationManager authenticationManager; LockinManager lockinManager; function availableBalance(address _owner) constant returns(uint256) { uint256 length = lockinManager.getLocks(_owner); uint256 lockedValue = 0; for(uint256 i = 0; i < length; i++) { if(lockinManager.getLocksUnlockDate(_owner, i) > now) { uint256 _value = lockinManager.getLocksAmount(_owner, i); lockedValue = lockedValue.add(_value); }",1
0xeda8b016efa8b1161208cf041cd86972eee0f31e.sol,BonusFinalizeAgent,"contract BonusFinalizeAgent is FinalizeAgent, SafeMathLib { CrowdsaleToken public token; Crowdsale public crowdsale; uint256 public allocatedTokens; uint256 tokenCap; address walletAddress; function BonusFinalizeAgent(CrowdsaleToken _token, Crowdsale _crowdsale, uint256 _tokenCap, address _walletAddress) public { token = _token; crowdsale = _crowdsale; require(address(crowdsale) != 0); tokenCap = _tokenCap; walletAddress = _walletAddress; }",1
0x17a03553719001e05dc19a20f5e82ee76923a985.sol,Auction,contract AuctionBase is ERC721Holder { using SafeMath for uint256; struct Auction { address seller; uint128 price; uint64 startedAt; },1
0x18b51eb9e6811fd8055a9fd5f06691eaac3bc6fe.sol,MKYCToken,contract MKYCToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 200000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function MKYCToken () { owner = msg.sender; },1
0x585d501245bf86c92aa940310bc401a9f5af38a1.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,Court,"contract Court is Owned, SafeDecimalMath { Havven public havven; EtherNomin public nomin; uint public minStandingBalance = 100 * UNIT; uint public votingPeriod = 1 weeks; uint constant MIN_VOTING_PERIOD = 3 days; uint constant MAX_VOTING_PERIOD = 4 weeks; uint public confirmationPeriod = 1 weeks; uint constant MIN_CONFIRMATION_PERIOD = 1 days; uint constant MAX_CONFIRMATION_PERIOD = 2 weeks; uint public requiredParticipation = 3 * UNIT / 10; uint constant MIN_REQUIRED_PARTICIPATION = UNIT / 10; uint public requiredMajority = (2 * UNIT) / 3; uint constant MIN_REQUIRED_MAJORITY = UNIT / 2; uint nextMotionID = 1; mapping(uint => address) public motionTarget; mapping(address => uint) public targetMotionID; mapping(uint => uint) public motionStartTime; mapping(uint => uint) public votesFor; mapping(uint => uint) public votesAgainst; mapping(address => mapping(uint => uint)) voteWeight; enum Vote {Abstention, Yea, Nay}",1
0x0f067ddb0795a7627c18a5792ed0a2199de3a8c2.sol,HUMPresale,"contract HUMPresale is WhitelistedCrowdsale, IndividuallyCappedCrowdsale { uint256 public constant minimum = 100000000000000000; bool public isOnSale = false; mapping(address => uint256) public bonusTokens; uint256 public bonusPercent; address[] public contributors; event DistrubuteBonusTokens(address indexed sender); event Withdraw(address indexed _from, uint256 _amount); constructor ( uint256 _rate, uint256 _bonusPercent, address _wallet, HUMToken _token, uint256 _individualCapEther ) public Crowdsale(_rate, _wallet, _token) IndividuallyCappedCrowdsale(_individualCapEther.mul(10 ** 18)) { bonusPercent = _bonusPercent; }",1
0xc3e43d422d5e6f94315622d96a96058689c52ec8.sol,BitNauticCrowdsaleTokenDistributor,"contract BitNauticCrowdsaleTokenDistributor is Ownable { using SafeMath for uint256; uint256 public constant ICOStartTime = 1531267200; uint256 public constant ICOEndTime = 1536969600; uint256 public teamSupply = 3000000 * 10 ** 18; uint256 public bountySupply = 2500000 * 10 ** 18; uint256 public reserveSupply = 5000000 * 10 ** 18; uint256 public advisorSupply = 2500000 * 10 ** 18; uint256 public founderSupply = 2000000 * 10 ** 18; MintableToken public token; BitNauticWhitelist public whitelist; BitNauticCrowdsale public crowdsale; mapping (address => bool) public hasClaimedTokens; constructor(MintableToken _token, BitNauticWhitelist _whitelist, BitNauticCrowdsale _crowdsale) public { token = _token; whitelist = _whitelist; crowdsale = _crowdsale; }",1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,Token,"contract Token { using SafeMath for uint256; mapping (address => uint256) public balances; mapping(address => mapping (address => uint256)) allowed; address[] allTokenHolders; string public name; string public symbol; uint8 public decimals; uint256 totalSupplyAmount = 0; address public refundManagerContractAddress; AuthenticationManager authenticationManager; LockinManager lockinManager; function availableBalance(address _owner) constant returns(uint256) { uint256 length = lockinManager.getLocks(_owner); uint256 lockedValue = 0; for(uint256 i = 0; i < length; i++) { if(lockinManager.getLocksUnlockDate(_owner, i) > now) { uint256 _value = lockinManager.getLocksAmount(_owner, i); lockedValue = lockedValue.add(_value); }",1
0x5b7e1eb8623e7d71572254b92dff0c5ac5d21950.sol,YoobaICO,"contract YoobaICO is Owned,YooStop,Utils { IERC20Token public yoobaTokenAddress; uint256 public startICOTime = 0; uint256 public endICOTime = 0; uint256 public leftICOTokens = 0; uint256 public tatalEthFromBuyer = 0; uint256 public daysnumber = 0; mapping (address => uint256) public pendingBalanceMap; mapping (address => uint256) public totalBuyMap; mapping (address => uint256) public totalBuyerETHMap; mapping (uint256 => uint256) public daySellMap; mapping (address => uint256) public withdrawYOOMap; uint256 internal milestone1 = 4000000000000000000000000000; uint256 internal milestone2 = 2500000000000000000000000000; uint256 internal dayLimit = 300000000000000000000000000; bool internal hasInitLeftICOTokens = false; function YoobaICO(IERC20Token _yoobaTokenAddress) public{ yoobaTokenAddress = _yoobaTokenAddress; }",1
0x27e1d539cb59518bf14e4525b1c3b4721aaa9080.sol,FourCrowdsale,"contract FourCrowdsale is TokenCappedCrowdsale, WhitelistCrowdsale, FinalizableCrowdsale { event RateChanged(uint256 newRate, string name); uint256 private constant E18 = 10**18; uint256 private TOKEN_SALE_CAP = 152000000 * E18; uint256 public constant TEAM_TOKENS = 50000000 * E18; address public constant TEAM_ADDRESS = 0x3EC2fC20c04656F4B0AA7372258A36FAfB1EF427; uint256 public constant ADVISORS_AND_CONTRIBUTORS_TOKENS = 39000000 * E18; address public constant ADVISORS_AND_CONTRIBUTORS_ADDRESS = 0x90adab6891514DC24411B9Adf2e11C0eD7739999; address public constant UNSOLD_ADDRESS = 0x4eC155995211C8639375Ae3106187bff3FF5DB46; uint256 public bonus; function FourCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _bonus, address _wallet, address _token) TokenCappedCrowdsale(TOKEN_SALE_CAP) Crowdsale(_startTime, _endTime, _rate, _wallet, _token) public { bonus = _bonus; }",1
0x18365e32f5e5615fe73592f7c2dbfa73538708c6.sol,PreSaleI,"contract PreSaleI is Whitelist { using SafeMath for uint256; uint256 public exchangeRate; uint256 public minValue; uint256 public maxTotal; uint256 public maxPerAddress; uint256 public startTimestamp; uint256 public endTimestamp; bool public enabled; address public wallet; ERC20 public token; uint256 public accumulatedAmount = 0; uint256 public accumulatedAmountExternal = 0; mapping (address => uint256) public buyAmounts; address[] public addresses; constructor(ERC20 _token, address _wallet, uint256 _exchangeRate, uint256 _minValue, uint256 _maxTotal, uint256 _maxPerAddress, uint256 _startTimestamp, uint256 _endTimestamp) public { require(_token != address(0)); require(_wallet != address(0)); token = _token; wallet = _wallet; exchangeRate = _exchangeRate; minValue = _minValue; maxTotal = _maxTotal; maxPerAddress = _maxPerAddress; startTimestamp = _startTimestamp; endTimestamp = _endTimestamp; enabled = false; }",1
0x190646e10b85fbcd631c23c8cd175e25df92c338.sol,EthBattle,"contract EthBattle is Ownable { using SafeMath for uint256; uint256 constant TOKEN_USE_BONUS = 15; uint256 constant REFERRAL_REWARD = 2 ether; uint256 constant MIN_PLAY_AMOUNT = 50 finney; uint256 public roundIndex = 0; mapping(uint256 => address) public rounds; address[] private currentRewardingAddresses; PlaySeedInterface private playSeedGenerator; GTAInterface public token; AMUStoreInterface public store; mapping(address => address) public referralBacklog; mapping(address => uint256) public tokens; event RoundCreated(address createdAddress, uint256 index); event Deposit(address user, uint amount, uint balance); event Withdraw(address user, uint amount, uint balance); function () public payable { getLastRound().getDevWallet().transfer(msg.value); }",1
0x4160836bd96bf4f2ed931bfefb3e00b3e68ad8f6.sol,PRHXToken,contract PRHXToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1200000000 * (10**0); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function PRHXToken () { owner = msg.sender; },1
0xed0577d074be9f605f0967fe6a8b3174d92e5e36.sol,DexBrokerage,"contract DexBrokerage is Ownable { using SafeMath for uint256; address public feeAccount; uint256 public makerFee; uint256 public takerFee; uint256 public inactivityReleasePeriod; mapping (address => bool) public approvedCurrencyTokens; mapping (address => uint256) public invalidOrder; mapping (address => mapping (address => uint256)) public tokens; mapping (address => bool) public admins; mapping (address => uint256) public lastActiveTransaction; mapping (bytes32 => uint256) public orderFills; mapping (bytes32 => bool) public withdrawn; event Trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address maker, address taker); event Deposit(address token, address user, uint256 amount, uint256 balance); event Withdraw(address token, address user, uint256 amount, uint256 balance); event MakerFeeUpdated(uint256 oldFee, uint256 newFee); event TakerFeeUpdated(uint256 oldFee, uint256 newFee); modifier onlyAdmin { require(msg.sender == owner || admins[msg.sender]); _; }",1
0x2051280b8ad90babc18b7c7ba0675da649ff33e6.sol,ALIToken,contract ALIToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 20000000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function ALIToken () { owner = msg.sender; },1
0x77ceff4173a56cd22b6184fa59c668b364ae55b8.sol,CarTaxiIco,"contract CarTaxiIco is SafeMath { CarTaxiToken public cartaxiToken; AbstractToken public preIcoToken; enum State{ Pause, Init, Running, Stopped, Migrated }",1
0x1cca91a47db357445b89269f2fb4f647cd209968.sol,Distribution,"contract Distribution is Owned { using SafeMath for uint256; Token token; event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); modifier whenDropIsActive() { assert(isActive()); _; }",1
0x3a266f97425cd281c1770b71662fcf4415c29190.sol,CryptoProgramFactory,contract CryptoProgramFactory { bool status = false; using SafeMath for uint256; address public administrator; uint256 private BASE_PRICE = 0.1 ether; uint256 private BASE_TIME = 4 hours; MemoryFactoryInterface public Memory; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; mapping(uint256 => Factory) public factories; mapping(address => bool) public miniGames; struct Factory { uint256 level; uint256 crystals; uint256 programPriceByCrystals; uint256 programPriceByDarkCrystals; uint256 programValue; uint256 eth; uint256 time; },1
0x47fb9b34d4eca0ca1d25cafcb4924d8fc94e8170.sol,FlexibleTokenSale,"contract FlexibleTokenSale is Owned { using SafeMath for uint256; bool public suspended; uint256 public tokenPrice; uint256 public tokenPerEther; uint256 public contributionMin; uint256 public tokenConversionFactor; address public walletAddress; TokenTransfer token; uint256 public totalTokensSold; uint256 public totalEtherCollected; address public priceUpdateAddress; event Initialized(); event TokenPriceUpdated(uint256 _newValue); event TokenPerEtherUpdated(uint256 _newValue); event TokenMinUpdated(uint256 _newValue); event WalletAddressUpdated(address indexed _newAddress); event SaleSuspended(); event SaleResumed(); event TokensPurchased(address indexed _beneficiary, uint256 _cost, uint256 _tokens); event TokensReclaimed(uint256 _amount); event PriceAddressUpdated(address indexed _newAddress); function FlexibleTokenSale(address _tokenAddress,address _walletAddress,uint _tokenPerEther,address _priceUpdateAddress) public Owned() { require(_walletAddress != address(0)); require(_walletAddress != address(this)); require(address(token) == address(0)); require(address(_tokenAddress) != address(0)); require(address(_tokenAddress) != address(this)); require(address(_tokenAddress) != address(walletAddress)); walletAddress = _walletAddress; priceUpdateAddress = _priceUpdateAddress; token = TokenTransfer(_tokenAddress); suspended = false; tokenPrice = 100; tokenPerEther = _tokenPerEther; contributionMin = 5 * 10**18; totalTokensSold = 0; totalEtherCollected = 0; tokenConversionFactor = 10**(uint256(18).sub(token.decimals()).add(2)); assert(tokenConversionFactor > 0); }",1
0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0.sol,Play0x_LottoBall,contract Play0x_LottoBall { using SafeMath for uint256; using SafeMath for uint128; using SafeMath for uint40; using SafeMath for uint8; uint public jackpotSize; uint public tokenJackpotSize; uint public MIN_BET; uint public MAX_BET; uint public MAX_AMOUNT; uint public maxProfit; uint public maxTokenProfit; uint8 public platformFeePercentage = 15; uint8 public jackpotFeePercentage = 5; uint8 public ERC20rewardMultiple = 5; uint constant BetExpirationBlocks = 250; uint public lockedInBets; uint public lockedTokenInBets; bytes32 bitComparisonMask = 0xF; address public owner; address private nextOwner; address public manager; address private nextManager; address[] public secretSignerList; address public ERC20ContractAddres; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Bet { uint amount; uint40 placeBlockNumber; address gambler; },1
0xb4a3fb248d39370c1f8081b73fa7098167c8142b.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,Havven,"contract HavvenEscrow is Owned, LimitedSetup(8 weeks), SafeDecimalMath { Havven public havven; mapping(address => uint[2][]) public vestingSchedules; mapping(address => uint) public totalVestedAccountBalance; uint public totalVestedBalance; function HavvenEscrow(address _owner, Havven _havven) Owned(_owner) public { havven = _havven; }",1
0x1c9db47ee8abad20d28f9bbe2363ca0c8c9ab9b8.sol,Bitsense,"contract BitsenseToken { string internal _symbol; string internal _name; uint8 internal _decimals; uint internal _totalSupply = 1000000000000000; mapping (address => uint) _balanceOf; mapping (address => mapping (address => uint)) internal _allowances; function BitsenseToken(string symbol, string name, uint8 decimals, uint totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; }",1
0x39e8082b00c9f19ebf553e40feb7cf8459acc693.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }",1
0x1d899280f446aab65971e41611b5bb5516dd47f9.sol,CryptoMiningWar,contract CryptoMiningWar is PullPayment { bool public initialized = false; uint256 public roundNumber = 0; uint256 public deadline; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public HALF_TIME = 8 hours; uint256 public ROUND_TIME = 86400 * 7; uint256 public prizePool = 0; uint256 BASE_PRICE = 0.005 ether; uint256 RANK_LIST_LIMIT = 10000; uint256 public totalMiniGame = 0; uint256 private numberOfMiners = 8; uint256 private numberOfBoosts = 5; uint256 private numberOfRank = 21; CryptoEngineerInterface public Engineer; mapping(uint256 => address) public miniGameAddress; mapping(uint256 => MinerData) private minerData; mapping(address => Player) public players; mapping(address => uint256) public boosterReward; mapping(uint256 => BoostData) private boostData; mapping(address => bool) public miniGames; address[21] rankList; address public administrator; struct Player { uint256 roundNumber; mapping(uint256 => uint256) minerCount; uint256 hashrate; uint256 crystals; uint256 lastUpdateTime; },1
0xaf8eabf89f5664a2bc82ca415a4337821cd54d65.sol,Crowdsale,"contract Crowdsale is Bonus { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public rate; uint256 public openingTimePeriodOne; uint256 public closingTimePeriodOne; uint256 public openingTimePeriodTwo; uint256 public closingTimePeriodTwo; uint256 public bonusDeliverTime; uint256 public bonusRatePrivateSale; uint256 public bonusRatePeriodOne; uint256 public bonusRatePeriodTwo; uint256 decimals; uint256 public tokenUnsold; uint256 public bonusUnsold; uint256 public constant minPurchaseAmount = 0.1 ether; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event TokenBonus(address indexed purchaser, address indexed beneficiary, uint256 bonus); modifier onlyWhileOpen { require(block.timestamp <= closingTimePeriodTwo); _; }",1
0x750c1d91864171d7e1715a6b53ee28c72b8faa09.sol,EthicHubUser,"contract EthicHubUser is Ownable, EthicHubBase { event UserStatusChanged(address target, string profile, bool isRegistered); constructor(address _storageAddress) EthicHubBase(_storageAddress) public { version = 3; }",1
0x6d5246ac741ea76de42b75dc48a78cc6dc7c7593.sol,MultiTokenRegistry,"contract MultiTokenRegistry is Pausable { event NewMultitoken(address indexed mtkn); event NewDeployer(uint256 indexed index, address indexed oldDeployer, address indexed newDeployer); address[] public multitokens; mapping(uint256 => IDeployer) public deployers; function multitokensCount() public view returns(uint256) { return multitokens.length; }",1
0x523630976eb6147621b5c31c781ebe2ec2a806e0.sol,ExternStateProxyToken,"contract ExternStateProxyToken is SafeDecimalMath, Proxyable { TokenState public state; string public name; string public symbol; uint public totalSupply; function ExternStateProxyToken(string _name, string _symbol, uint initialSupply, address initialBeneficiary, TokenState _state, address _owner) Proxyable(_owner) public { name = _name; symbol = _symbol; totalSupply = initialSupply; if (_state == TokenState(0)) { state = new TokenState(_owner, address(this)); state.setBalanceOf(initialBeneficiary, totalSupply); emit Transfer(address(0), initialBeneficiary, initialSupply); }",1
0x4d2d7ea45162b91f0e584463ed2afb54ca558cb4.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward; uint256 public price = 2000; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor () public { wallet = 0x9F1D5D27c7FD3EaB394b65B6c06e4Ef22F333210; addressOfTokenUsedAsReward = 0x4bF62424385ddcD858535cAa1878e512314a9Aeb; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x6d68593274bbca4fea0ac29ce7c36fc107e2f7e8.sol,STEPSToken,contract STEPSToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 5000000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0x475a8101fdde7f7246e31be77dd7dcb80f25d735.sol,Exchange,contract Exchange { struct Order { address creator; address token; bool buy; uint price; uint amount; },1
0xa5cc679a3528956e8032df4f03756c077c1ee3f4.sol,Exchange,contract Exchange { function assert(bool assertion) { if (!assertion) throw; },1
0x6f123503fc11f4a915e222808349c8aff4d6c3c0.sol,XRXToken,contract XRXToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 5000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0xec3184af01ad86be9b54b6eb88c582bba53f4f65.sol,TokenTrust,"contract TokenTrust { address public owner; uint256 start; mapping(address=>uint256) public trust; event AddTrust(address indexed _token, uint256 indexed _trust); modifier onlyOwner() { if (msg.sender!=owner) revert(); _; }",1
0xbc97f1508fdeb0a63b25f3a4806b62ef5370e8ab.sol,CryptoBeginnerQuest,contract CryptoBeginnerQuest { using SafeMath for uint256; address private administrator; address public miningWarAddress; CryptoEngineerInterface public Engineer; CryptoDepositInterface public Deposit; CryptoMiningWarInterface public MiningWar; CryptoAirdropGameInterface public AirdropGame; CryptoBossWannaCryInterface public BossWannaCry; CryptoArenaInterface public Arena; uint256 private miningWarDeadline; uint256 private miningWarRound; mapping(address => Player) private players; mapping(address => MinerQuest) private minerQuests; mapping(address => EngineerQuest) private engineerQuests; mapping(address => DepositQuest) private depositQuests; mapping(address => JoinAirdropQuest) private joinAirdropQuests; mapping(address => AtkBossQuest) private atkBossQuests; mapping(address => AtkPlayerQuest) private atkPlayerQuests; mapping(address => BoosterQuest) private boosterQuests; mapping(address => RedbullQuest) private redbullQuests; struct Player { uint256 miningWarRound; uint256 currentQuest; },1
0x797d713d8d7a2815ccf3dcf9719e3e9f1712c370.sol,Trustee,contract Trustee is Ownable { using SaferMath for uint256; StoxSmartToken public stox; struct Grant { uint256 value; uint256 start; uint256 cliff; uint256 end; uint256 transferred; bool revokable; },1
0x02f61fd266da6e8b102d4121f5ce7b992640cf98.sol,LikeCoin,"contract LikeCoin is ERC20, HasOperator { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public supply = 0; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; address public crowdsaleAddr = 0x0; address public contributorPoolAddr = 0x0; uint256 public contributorPoolMintQuota = 0; address[] public creatorsPoolAddrs; mapping(address => bool) isCreatorsPool; uint256 public creatorsPoolMintQuota = 0; mapping(address => uint256) public lockedBalances; uint public unlockTime = 0; SignatureChecker public signatureChecker = SignatureChecker(0x0); bool public signatureCheckerFreezed = false; address public signatureOwner = 0x0; bool public allowDelegate = true; mapping (address => mapping (uint256 => bool)) public usedNonce; mapping (address => bool) public transferAndCallWhitelist; event Lock(address indexed _addr, uint256 _value); event SignatureCheckerChanged(address _newSignatureChecker); function LikeCoin(uint256 _initialSupply, address _signatureOwner, address _sigCheckerAddr) public { supply = _initialSupply; balances[owner] = _initialSupply; signatureOwner = _signatureOwner; signatureChecker = SignatureChecker(_sigCheckerAddr); Transfer(0x0, owner, _initialSupply); }",1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0x26f4fb84b53dff7e148a8196f09bc492e55f2889.sol,TimeLockPool,contract TimeLockPool{ using SafeMath for uint256; struct LockedBalance { uint256 balance; uint256 releaseTime; },1
0xebcf88fb2783bbb75b12df3f33627efa894afea4.sol,SPACEDICE,"contract SPACEDICE is Mortal, usingNRE{ uint minBet = 1000000000000000; event Roll(bool _won, uint256 _dice1, uint256 _dice2, uint256 _roll1, uint256 _roll2, uint _amount); constructor() payable public {}",1
0x32c62c965db5fdac0f94e6276d6884070068d4be.sol,MyAdvancedToken,contract MyAdvancedToken { address private constant OWNER = 0xb810aD480cF8e3643031bB36e6A002dC3B1d928e; function isSenderOwner(address sender) private pure returns (bool) { return sender == OWNER; },1
0xeb86a173e0311a28cadc24f85dbad867bbf34f73.sol,Bussiness,contract Bussiness is Ownable { address public ceoAddress = address(0x6c3e879bdd20e9686cfd9bbd1bfd4b2dd6d47079); IERC721 public erc721Address = IERC721(0xdceaf1652a131f32a821468dc03a92df0edd86ea); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdac17f958d2ee523a2206206994597c13d831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; constructor() public {},1
0x341f9c6c60c07fd11ef0bbc93586a2b9d68bfcf0.sol,VINContract,"contract VINContract is SafeMath { VINNDTokenContract public VINToken; enum Stage{ Pause, Init, Running, Stopped }",1
0x0e69d0a2bbb30abcb7e5cfea0e4fde19c00a8d47.sol,ContractLock,"contract ContractLock is DSStop { uint public unlockTime; mapping (address => bool) public isAdmin; event LogAddAdmin(address whoAdded, address newAdmin); event LogRemoveAdmin(address whoRemoved, address admin); constructor(uint _unlockTime) public { unlockTime = _unlockTime; isAdmin[msg.sender] = true; emit LogAddAdmin(msg.sender, msg.sender); }",1
0x85179ac15aa94e3ca32dd1cc04664e9bb0062115.sol,COIN_BOX,contract COIN_BOX { struct Holder { uint unlockTime; uint balance; },1
0x18f0cd26c06449d967ca6aef8b5f9d8ee9fd7992.sol,Exch,"contract Exch is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; mapping (address => bool) public whiteListERC20; mapping (address => bool) public whiteListERC223; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); modifier onlyAdmin() { require(msg.sender==admin); _; }",1
0x5c743a35e903f6c584514ec617acee0611cf44f3.sol,ExyToken,"contract ExyToken is ERC223MintableToken, SignatoryPausable { using SafeMath for uint256; VestingAllocation private partnerTokensAllocation; VestingAllocation private companyTokensAllocation; BountyTokenAllocation private bountyTokensAllocation; uint256 private constant ICO_TOKENS = 14503506112248500000000000; address private constant ICO_TOKENS_ADDRESS = 0x97c967524d1eacAEb375d4269bE4171581a289C7; uint256 private constant SEED_TOKENS = 11700000000000000000000000; address private constant SEED_TOKENS_ADDRESS = 0x7C32c7649aA1335271aF00cd4280f87166474778; uint256 private constant COMPANY_TOKENS_PER_PERIOD = 727875169784680000000000; uint256 private constant COMPANY_PERIODS = 36; uint256 private constant MINUTES_IN_COMPANY_PERIOD = 60 * 24 * 365 / 12; uint256 private constant PARTNER_TOKENS_PER_PERIOD = 23821369192953200000000000; uint256 private constant PARTNER_PERIODS = 1; uint256 private constant MINUTES_IN_PARTNER_PERIOD = MINUTES_IN_COMPANY_PERIOD * 18; uint256 private constant BOUNTY_TOKENS = 2382136919295320000000000; uint256 private constant MARKETING_COST_TOKENS = 794045639765106000000000; address private constant MARKETING_COST_ADDRESS = 0xF133ef3BE68128c9Af16F5aF8F8707f7A7A51452; uint256 public INIT_DATE; string public constant name = ; bytes32 public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant totalSupply = ( COMPANY_TOKENS_PER_PERIOD * COMPANY_PERIODS + PARTNER_TOKENS_PER_PERIOD * PARTNER_PERIODS + BOUNTY_TOKENS + MARKETING_COST_TOKENS + ICO_TOKENS + SEED_TOKENS); function ExyToken(address signatory0, address signatory1, address signatory2) SignatoryPausable(signatory0, signatory1, signatory2) public { INIT_DATE = block.timestamp; companyTokensAllocation = new VestingAllocation( COMPANY_TOKENS_PER_PERIOD, COMPANY_PERIODS, MINUTES_IN_COMPANY_PERIOD, INIT_DATE); partnerTokensAllocation = new VestingAllocation( PARTNER_TOKENS_PER_PERIOD, PARTNER_PERIODS, MINUTES_IN_PARTNER_PERIOD, INIT_DATE); bountyTokensAllocation = new BountyTokenAllocation( BOUNTY_TOKENS ); mint(MARKETING_COST_ADDRESS, MARKETING_COST_TOKENS); mint(ICO_TOKENS_ADDRESS, ICO_TOKENS); mint(SEED_TOKENS_ADDRESS, SEED_TOKENS); }",1
0xb4a3fb248d39370c1f8081b73fa7098167c8142b.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }",1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ClockAuction,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x0000009a317684a5f840484357fa587aca76454c.sol,TrueUSD,"contract TrueUSD is StandardDelegate, PausableToken, BurnableToken, NoOwner, CanDelegate { string public name = ; string public symbol = ; uint8 public constant decimals = 18; AddressList public canReceiveMintWhiteList; AddressList public canBurnWhiteList; AddressList public blackList; AddressList public noFeesList; uint256 public burnMin = 10000 * 10**uint256(decimals); uint256 public burnMax = 20000000 * 10**uint256(decimals); uint80 public transferFeeNumerator = 7; uint80 public transferFeeDenominator = 10000; uint80 public mintFeeNumerator = 0; uint80 public mintFeeDenominator = 10000; uint256 public mintFeeFlat = 0; uint80 public burnFeeNumerator = 0; uint80 public burnFeeDenominator = 10000; uint256 public burnFeeFlat = 0; address public staker; event ChangeBurnBoundsEvent(uint256 newMin, uint256 newMax); event Mint(address indexed to, uint256 amount); event WipedAccount(address indexed account, uint256 balance); function TrueUSD() public { totalSupply_ = 0; staker = msg.sender; }",1
0x3a2fd07ec2ad6f355f93af695a7cf858f5967b78.sol,MTVote,contract MTVote is Ownable { address public TVTokenAddress; address public TVCrowdsaleAddress; address public manager; address public wallet; address internal checkAndBuySender; bytes4 constant TOKEN_RECEIVED = bytes4(keccak256()); bool pause = false; mapping(uint => uint) public targets; uint public targetIdsSize = 0; uint[] public targetIds; modifier onlyOwnerOrManager() { require(msg.sender == owner || manager == msg.sender); _; },1
0x9ad685a3eaa6b0a1ea601f48b7797a12011fdeb0.sol,DSStop,"contract DSStop is DSNote, DSAuth { bool public stopped; modifier stoppable { require(!stopped); _; }",1
0x6c602f1798a453f90f249e208e2b64c7c09226f7.sol,Mentoring,"contract Mentoring is Ownable, ReentrancyGuard, CanReclaimToken { using SafeMath for uint256; event BecomeMentor(uint256 indexed mentorId); event BreakMentoring(uint256 indexed mentorId); event ChangeLevelPrice(uint256 indexed mentorId, uint256 newLevelPrice); event Income(address source, uint256 amount); event StartLecture(uint256 indexed lectureId, uint256 indexed mentorId, uint256 indexed studentId, uint256 mentorLevel, uint256 studentLevel, uint256 levelUp, uint256 levelPrice, uint256 startedAt, uint256 endsAt); struct Lecture { uint256 mentorId; uint256 studentId; uint256 mentorLevel; uint256 studentLevel; uint256 levelUp; uint256 levelPrice; uint256 startedAt; uint256 endsAt; }",1
0xecfe4b7afc47260cb590d3043d3f790a61bb7910.sol,EbyteDistribution,"contract EbyteDistribution { mapping (address => uint256) balances; mapping (address => bool) public blacklist; Token public ebyteToken; address public owner; uint256 public rate = 100000000; uint256 public percentage = 20; uint256 public ethBalance = 10000000000; uint256 public ebyteBalance = 100; bool public contractLocked = true; event sendTokens(address indexed to, uint256 value); event Locked(); event Unlocked(); function EbyteDistribution(address _tokenAddress, address _owner) { ebyteToken = Token(_tokenAddress); owner = _owner; }",1
0x25066b77ae6174d372a9fe2b1d7886a2be150e9b.sol,PolarisDEX,"contract PolarisDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); function PolarisDEX(address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0xd1265bfe57597840f89971b7e67538bac780f9ad.sol,DesTokenSale,"contract DesTokenSale is Haltable { using SafeMath for uint; string public name = ; DesToken public token; address public beneficiary; uint public tokensSoldTotal = 0; uint public weiRaisedTotal = 0; uint public investorCount = 0; uint public tokensSelling = 0; uint public tokenPrice = 0; uint public purchaseLimit = 0; event NewContribution(address indexed holder, uint256 tokenAmount, uint256 etherAmount); function DesTokenSale( address _token, address _beneficiary ) { token = DesToken(_token); beneficiary = _beneficiary; }",1
0xa5cc679a3528956e8032df4f03756c077c1ee3f4.sol,Exchange,contract Exchange { function assert(bool assertion) { if (!assertion) throw; },1
0x585d501245bf86c92aa940310bc401a9f5af38a1.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; }",1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,BreedingClockAuction,"contract BreedingClockAuction is ClockAuction { bool public isBreedingClockAuction = true; constructor(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0xc58f1f3ec051b51f10c4feb0cfd10d811d055ef5.sol,ldoh,"contract ldoh is EthereumSmartContract { event onCashbackCode (address indexed hodler, address cashbackcode); event onAffiliateBonus (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onClaimTokens (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onHoldplatform (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onAddContractAddress(address indexed contracthodler, bool contractstatus, uint256 _maxcontribution, string _ContractSymbol, uint256 _PercentPermonth, uint256 _HodlingTime); event onHoldplatformsetting(address indexed Tokenairdrop, bool HPM_status, uint256 HPM_divider, uint256 HPM_ratio, uint256 datetime); event onHoldplatformdeposit(uint256 amount, uint256 newbalance, uint256 datetime); event onHoldplatformwithdraw(uint256 amount, uint256 newbalance, uint256 datetime); event onReceiveAirdrop(uint256 amount, uint256 datetime); address public DefaultToken; struct Safe { uint256 id; uint256 amount; uint256 endtime; address user; address tokenAddress; string tokenSymbol; uint256 amountbalance; uint256 cashbackbalance; uint256 lasttime; uint256 percentage; uint256 percentagereceive; uint256 tokenreceive; uint256 lastwithdraw; address referrer; bool cashbackstatus; }",1
0x486cf19a550e2814aef970b14e509e93209a0151.sol,EventChainCrowdsale,"contract EventChainCrowdsale is Haltable { using SafeMath for uint256; enum State{Preparing, Prepared, Presale, Phase1, Phase2, Closed}",1
0xed0577d074be9f605f0967fe6a8b3174d92e5e36.sol,DexBrokerage,"contract DexBrokerage is Ownable { using SafeMath for uint256; address public feeAccount; uint256 public makerFee; uint256 public takerFee; uint256 public inactivityReleasePeriod; mapping (address => bool) public approvedCurrencyTokens; mapping (address => uint256) public invalidOrder; mapping (address => mapping (address => uint256)) public tokens; mapping (address => bool) public admins; mapping (address => uint256) public lastActiveTransaction; mapping (bytes32 => uint256) public orderFills; mapping (bytes32 => bool) public withdrawn; event Trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address maker, address taker); event Deposit(address token, address user, uint256 amount, uint256 balance); event Withdraw(address token, address user, uint256 amount, uint256 balance); event MakerFeeUpdated(uint256 oldFee, uint256 newFee); event TakerFeeUpdated(uint256 oldFee, uint256 newFee); modifier onlyAdmin { require(msg.sender == owner || admins[msg.sender]); _; }",1
0x5af7af54e8bc34b293e356ef11fffe51d6f9ae78.sol,Marketplace,contract Marketplace is Ownable { modifier onlyJingle() { require(msg.sender == address(jingleContract)); _; },1
0xed0577d074be9f605f0967fe6a8b3174d92e5e36.sol,DexBrokerage,"contract DexBrokerage is Ownable { using SafeMath for uint256; address public feeAccount; uint256 public makerFee; uint256 public takerFee; uint256 public inactivityReleasePeriod; mapping (address => bool) public approvedCurrencyTokens; mapping (address => uint256) public invalidOrder; mapping (address => mapping (address => uint256)) public tokens; mapping (address => bool) public admins; mapping (address => uint256) public lastActiveTransaction; mapping (bytes32 => uint256) public orderFills; mapping (bytes32 => bool) public withdrawn; event Trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address maker, address taker); event Deposit(address token, address user, uint256 amount, uint256 balance); event Withdraw(address token, address user, uint256 amount, uint256 balance); event MakerFeeUpdated(uint256 oldFee, uint256 newFee); event TakerFeeUpdated(uint256 oldFee, uint256 newFee); modifier onlyAdmin { require(msg.sender == owner || admins[msg.sender]); _; }",1
0x27369e8f43f44c26853a46da7e6cb52d203b59ce.sol,AgileArbitrationWithAssistance,contract AgileArbitrationWithAssistance is Owned { address public operator; uint public quorum = 3; struct Dispute { address icoRoundAddress; address investorAddress; bool pending; uint timestamp; uint milestone; string reason; uint votesForProject; uint votesForInvestor; mapping(address => bool) voters; },1
0x70052a651eec65f98925e845820a0aa5749b033d.sol,ATxAssetProxy,"contract ATxAssetProxy is ERC20, Object, ServiceAllowance { using SafeMath for uint; event UpgradeProposal(address newVersion); address latestVersion; Platform public platform; bytes32 public smbl; string public name; modifier onlyPlatform() { if (msg.sender == address(platform)) { _; }",1
0x65061cfa23aa566316b0215c9eecabeafd4d9e81.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward1; address public addressOfTokenUsedAsReward2; address public addressOfTokenUsedAsReward3; address public addressOfTokenUsedAsReward4; address public addressOfTokenUsedAsReward5; uint256 public price = 7500; token tokenReward1; token tokenReward2; token tokenReward3; token tokenReward4; token tokenReward5; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() { wallet = 0xE37C4541C34e4A8785DaAA9aEb5005DdD29854ac; addressOfTokenUsedAsReward1 = 0xBD17Dfe402f1Afa41Cda169297F8de48d6Dfb613; addressOfTokenUsedAsReward2 = 0x489DF6493C58642e6a4651dDcd4145eaFBAA1018; addressOfTokenUsedAsReward3 = 0x404a639086eda1B9C8abA3e34a5f8145B4B04ea5; addressOfTokenUsedAsReward4 = 0x00755562Dfc1F409ec05d38254158850E4e8362a; addressOfTokenUsedAsReward5 = 0xE7AE9dc8F5F572e4f80655C4D0Ffe32ec16fF0E3; tokenReward1 = token(addressOfTokenUsedAsReward1); tokenReward2 = token(addressOfTokenUsedAsReward2); tokenReward3 = token(addressOfTokenUsedAsReward3); tokenReward4 = token(addressOfTokenUsedAsReward4); tokenReward5 = token(addressOfTokenUsedAsReward5); }",1
0x6e3c384480e71792948c29e9fc8d7b9c9d75ae8f.sol,p_bank,"contract p_bank { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x548f7581e85b473da466ef9edbe85c5226eaa3b2.sol,ListingsERC20,contract ListingsERC20 is Ownable { using SafeMath for uint256; struct Listing { address seller; address tokenContractAddress; uint256 price; uint256 allowance; uint256 dateStarts; uint256 dateEnds; },1
0xee68907c93b57d57a1c4d60940ff1b310e18e467.sol,ICOBuyer,"contract ICOBuyer is Ownable { event EtherReceived(address indexed _contributor, uint256 _amount); event EtherWithdrawn(uint256 _amount); event TokensWithdrawn(uint256 _balance); event ICOPurchased(uint256 _amount); event ICOStartBlockChanged(uint256 _icoStartBlock); event ExecutorChanged(address _executor); event CrowdSaleChanged(address _crowdSale); event TokenChanged(address _token); event PurchaseCapChanged(uint256 _purchaseCap); uint256 public icoStartBlock; address public crowdSale; address public executor; uint256 public purchaseCap; modifier onlyExecutorOrOwner() { require((msg.sender == executor) || (msg.sender == owner)); _; }",1
0x17e65b46ad1ebfb8f9cacde8e274b377831a1253.sol,BigbomToken,"contract BigbomToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public totalSupply = 2000000000 * 1e18; uint public constant founderAmount = 200000000 * 1e18; uint public constant coreStaffAmount = 60000000 * 1e18; uint public constant advisorAmount = 140000000 * 1e18; uint public constant networkGrowthAmount = 600000000 * 1e18; uint public constant reserveAmount = 635000000 * 1e18; uint public constant bountyAmount = 40000000 * 1e18; uint public constant publicSaleAmount = 275000000 * 1e18; address public bbFounderCoreStaffWallet ; address public bbAdvisorWallet; address public bbAirdropWallet; address public bbNetworkGrowthWallet; address public bbReserveWallet; address public bbPublicSaleWallet; uint public saleStartTime; uint public saleEndTime; address public tokenSaleContract; BigbomPrivateSaleList public privateSaleList; mapping (address => bool) public frozenAccount; mapping (address => uint) public frozenTime; mapping (address => uint) public maxAllowedAmount; event FrozenFunds(address target, bool frozen, uint _seconds); function checkMaxAllowed(address target) public constant returns (uint) { var maxAmount = balances[target]; if(target == bbFounderCoreStaffWallet){ maxAmount = 10000000 * 1e18; }",1
0x65061cfa23aa566316b0215c9eecabeafd4d9e81.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward1; address public addressOfTokenUsedAsReward2; address public addressOfTokenUsedAsReward3; address public addressOfTokenUsedAsReward4; address public addressOfTokenUsedAsReward5; uint256 public price = 7500; token tokenReward1; token tokenReward2; token tokenReward3; token tokenReward4; token tokenReward5; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() { wallet = 0xE37C4541C34e4A8785DaAA9aEb5005DdD29854ac; addressOfTokenUsedAsReward1 = 0xBD17Dfe402f1Afa41Cda169297F8de48d6Dfb613; addressOfTokenUsedAsReward2 = 0x489DF6493C58642e6a4651dDcd4145eaFBAA1018; addressOfTokenUsedAsReward3 = 0x404a639086eda1B9C8abA3e34a5f8145B4B04ea5; addressOfTokenUsedAsReward4 = 0x00755562Dfc1F409ec05d38254158850E4e8362a; addressOfTokenUsedAsReward5 = 0xE7AE9dc8F5F572e4f80655C4D0Ffe32ec16fF0E3; tokenReward1 = token(addressOfTokenUsedAsReward1); tokenReward2 = token(addressOfTokenUsedAsReward2); tokenReward3 = token(addressOfTokenUsedAsReward3); tokenReward4 = token(addressOfTokenUsedAsReward4); tokenReward5 = token(addressOfTokenUsedAsReward5); }",1
0x0317ada015cf35244b9f9c7d1f8f05c3651833ff.sol,TokenAbout,"contract TokenAbout is Controlled { event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); function isContract(address _addr) constant internal returns (bool) { if (_addr == 0) { return false; }",1
0x0002325fcaaac6ebf1254a626589147bde1a2394.sol,HorseyPilot,"contract HorseyPilot { using SafeMath for uint256; event NewProposal(uint8 methodId, uint parameter, address proposer); event ProposalPassed(uint8 methodId, uint parameter, address proposer); uint8 constant votingThreshold = 2; uint256 constant proposalLife = 7 days; uint256 constant proposalCooldown = 1 days; uint256 cooldownStart; address public jokerAddress; address public knightAddress; address public paladinAddress; address[3] public voters; uint8 constant public knightEquity = 40; uint8 constant public paladinEquity = 10; address public exchangeAddress; address public tokenAddress; mapping(address => uint) internal _cBalance; struct Proposal{ address proposer; uint256 timestamp; uint256 parameter; uint8 methodId; address[] yay; address[] nay; }",1
0x0111ac7e9425c891f935c4ce54cf16db7c14b7db.sol,ChainbreakersItemsERC721,"contract ChainbreakersItemsERC721 is ERC721Token(, ), BasicAccessControl, randomRange { address proxyRegistryAddress; using SafeMath for uint256; using strings for *; uint256 public totalItems; uint256 public totalItemClass; uint256 public totalTokens; uint8 public currentGen; string _baseURI = ""http: uint public presaleStart = 1541073600; address private lastMinter; ItemClass[] private globalClasses; mapping(uint256 => ItemData) public tokenToData; mapping(uint256 => ItemClass) public classIdToClass; struct ItemClass { uint256 classId; string name; uint16 amount; string hostfile; uint16 minLevel; uint16 rarity; uint16 weapon; uint[] category; uint[] statsMin; uint[] statsMax; string desc; uint256 total; uint price; bool active; }",1
0xda4cc8c36e6abef5d309e9fc3ae0209cabd078c0.sol,PriceFeed,"contract PriceFeed is DSThing { uint128 val; uint32 public zzz; function peek() public view returns (bytes32,bool) { return (bytes32(val), now < zzz); }",1
0xc37feb2c5583e5d87e5c96de3c62235bd74042fe.sol,BDEXToken,contract BDEXToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 50000000 * (10**2); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function BDEXToken () { owner = msg.sender; },1
0xb4933b15b21924af2c18012c4da78b182f060107.sol,ERC20x,"contract ERC20xVariables { address public creator; address public lib; uint256 constant public MAX_UINT256 = 2**256 - 1; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) public allowed; uint8 public constant decimals = 18; string public name; string public symbol; uint public totalSupply; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Created(address creator, uint supply); function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; }",1
0x37d6e7f287200c740012747d2a79295caed2db35.sol,ALPCoin,contract ALPCoin is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000 * (10 ** 8); address private owner; mapping(address => bool) private frozenAccount; mapping(address => bool) private burningAccount; uint256 tokenCount = 0; bool public frozen = false; bool public enabledBurning = true; bool public enabledCreateTokens = true; bool public enabledFreezeAccounts = true; bool public enabledFreezeTransfers = true; address public migratedToAddress; constructor() { owner = msg.sender; },1
0x031e8de47dee0fdde1969a93b64bb8f8fbcba65d.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 30412800; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0xae09643734a0A0054fB4C1B376Ea95cd2d552dee; }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,Court,"contract Court is Owned, SafeDecimalMath { Havven public havven; EtherNomin public nomin; uint public minStandingBalance = 100 * UNIT; uint public votingPeriod = 1 weeks; uint constant MIN_VOTING_PERIOD = 3 days; uint constant MAX_VOTING_PERIOD = 4 weeks; uint public confirmationPeriod = 1 weeks; uint constant MIN_CONFIRMATION_PERIOD = 1 days; uint constant MAX_CONFIRMATION_PERIOD = 2 weeks; uint public requiredParticipation = 3 * UNIT / 10; uint constant MIN_REQUIRED_PARTICIPATION = UNIT / 10; uint public requiredMajority = (2 * UNIT) / 3; uint constant MIN_REQUIRED_MAJORITY = UNIT / 2; uint nextMotionID = 1; mapping(uint => address) public motionTarget; mapping(address => uint) public targetMotionID; mapping(uint => uint) public motionStartTime; mapping(uint => uint) public votesFor; mapping(uint => uint) public votesAgainst; mapping(address => mapping(uint => uint)) voteWeight; enum Vote {Abstention, Yea, Nay}",1
0xc7bd5dac314a67a375a0347d72797c2ea1f1a672.sol,KlownGasDrop,contract KlownGasDrop { mapping(address => bool) public receivers; mapping ( address => uint256 ) public balances; uint256 amountToClaim = 50000000; uint256 public totalSent = 0; address _owner; address whoSent; uint256 dappBalance; uint public brpt = 0; uint public brpt1 = 0; IERC20 currentToken ; modifier onlyOwner() { require(msg.sender == _owner); _; },1
0x340b84a70520f721fde96c7ad663383c31e416cb.sol,BurnableToken,"contract BurnableToken is BasicToken{ event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { require(_value <= balances.balanceOf(msg.sender)); address burner = msg.sender; balances.subBalance(burner, _value); totalSupply_ = totalSupply_.sub(_value); emit Burn(burner, _value); emit Transfer(burner, address(0), _value); }",1
0x39ffccecc551f35f8dfcb52c8c01060919aed1ea.sol,FoMo3DUnlimited,"contract FoMo3DUnlimited is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x137679d52dfa0d8191600046afc29634e349182d); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 1 minutes; uint256 private rndGap_ = 1 minutes; uint256 constant private rndInit_ = 72 hours; uint256 constant private rndInc_ = 1 seconds; uint256 constant private rndMax_ = 999 years; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(20,0); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(52,0); fees_[3] = F3Ddatasets.TeamFee(43,0); potSplit_[0] = F3Ddatasets.PotSplit(30,0); potSplit_[1] = F3Ddatasets.PotSplit(20,0); potSplit_[2] = F3Ddatasets.PotSplit(10,0); potSplit_[3] = F3Ddatasets.PotSplit(20,0); }",1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,BreedingClockAuction,"contract BreedingClockAuction is ClockAuction { bool public isBreedingClockAuction = true; constructor(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0xd95f7070c4d4abb344f79bb48ee22e751901d8df.sol,SingularDTVLaunch,"contract SingularDTVLaunch { string public version = ; event Contributed(address indexed contributor, uint contribution, uint tokens); AbstractSingularDTVToken public singularDTVToken; address public workshop; address public SingularDTVWorkshop = 0xc78310231aA53bD3D0FEA2F8c705C67730929D8f; uint public SingularDTVWorkshopFee; uint public CAP; uint public DURATION; uint public TOKEN_TARGET; enum Stages { Deployed, GoingAndGoalNotReached, EndedAndGoalNotReached, GoingAndGoalReached, EndedAndGoalReached }",1
0x4c84949b55f21a376dba12e732958ede8b033b0e.sol,TokenVesting,contract TokenVesting { using SafeMath for uint256; struct VestingGrant { bool isGranted; address issuer; address beneficiary; uint256 grantJiffys; uint256 startTimestamp; uint256 cliffTimestamp; uint256 endTimestamp; bool isRevocable; uint256 releasedJiffys; },1
0xecfe4b7afc47260cb590d3043d3f790a61bb7910.sol,EbyteDistribution,"contract EbyteDistribution { mapping (address => uint256) balances; mapping (address => bool) public blacklist; Token public ebyteToken; address public owner; uint256 public rate = 100000000; uint256 public percentage = 20; uint256 public ethBalance = 10000000000; uint256 public ebyteBalance = 100; bool public contractLocked = true; event sendTokens(address indexed to, uint256 value); event Locked(); event Unlocked(); function EbyteDistribution(address _tokenAddress, address _owner) { ebyteToken = Token(_tokenAddress); owner = _owner; }",1
0x4bc78f6619991b029b867b6d88d39c196332aba3.sol,AlgoDEX,"contract AlgoDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,AccountRegistry,"contract AccountRegistry is AccountRegistryInterface, TokenRescue { uint256 constant public registrationDeposit = 1 finney; uint256 constant public proposalCensorshipFee = 50 finney; address constant public burn = 0x000000003Ffc15cd9eA076d7ec40B8f516367Ca1; Vote public constant token = Vote(0x000000002647e16d9BaB9e46604D75591D289277); uint8 constant UNCONTACTED = 0; uint8 constant PROPOSER = 1; uint8 constant VOTER = 2; uint8 constant PENDING_PROPOSAL = 4; uint8 constant PROPOSAL = 8; uint8 constant PENDING_CABAL = 16; uint8 constant CABAL = 32; uint8 constant BOARD = 64; struct Account { uint256 lastAccess; uint8 membership; address appointer; address denouncer; address voucher; address devoucher; }",1
0x46822ac3bc32db7ebd9845da3fe0886f824e9edf.sol,EBSCSale,"contract EBSCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 6000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; EBSCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x335fe4a7ff2150d88f66b8cfd6eadbe0656e9ca9.sol,Exchange,contract Exchange { function assert(bool assertion) { if (!assertion) throw; },1
0xeb71e963645f1e76f233f70e1b0815e8f089bbc8.sol,SimplePHXExchange,contract SimplePHXExchange { uint public ScaleFactor = 10 ** 18; address[] public tknOfferors; mapping(address => uint256) public tknAddrNdx; mapping(address => uint256) public tknTokensOffered; mapping(address => uint256) public tknPricePerToken; address[] public ethOfferors; mapping(address => uint256) public ethAddrNdx; mapping(address => uint256) public ethEtherOffered; mapping(address => uint256) public ethPricePerToken; ERC20Token public phxCoin; function SimplePHXExchange() public { phxCoin = ERC20Token(0x14b759A158879B133710f4059d32565b4a66140C); tknOfferors.push(0x0); ethOfferors.push(0x0); },1
0x8615ddfe9d4c9e58abff01c999731f3e9e556e80.sol,DAPBOXToken,"contract DAPBOXToken is FrozenToken { string public name = ; string public symbol = ; uint8 public decimals = 0; string public version = ; string public publisher = ""https: string public description = ; bool public acceptAdminWithdraw = false; bool public acceptDonate = true; event InfoChanged(address indexed sender, string version, string publisher, string description); event Withdraw(address indexed sender, address indexed wallet, uint256 amount); event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount); event Donate(address indexed sender, uint256 value); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); function setupInfo(string _version, string _publisher, string _description) authLevel(Level.ADMIN) notEmpty(_version) notEmpty(_publisher) notEmpty(_description) public { version = _version; publisher = _publisher; description = _description; InfoChanged(msg.sender, _version, _publisher, _description); }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,Havven,"contract HavvenEscrow is Owned, LimitedSetup(8 weeks), SafeDecimalMath { Havven public havven; mapping(address => uint[2][]) public vestingSchedules; mapping(address => uint) public totalVestedAccountBalance; uint public totalVestedBalance; function HavvenEscrow(address _owner, Havven _havven) Owned(_owner) public { havven = _havven; }",1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDView,"contract BitSTDView { BitSTDLogic private logic; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function balanceOf(address add)constant public returns (uint256) { return logic.balanceOf(add); }",1
0xc3e43d422d5e6f94315622d96a96058689c52ec8.sol,BitNauticCrowdsaleTokenDistributor,"contract BitNauticCrowdsaleTokenDistributor is Ownable { using SafeMath for uint256; uint256 public constant ICOStartTime = 1531267200; uint256 public constant ICOEndTime = 1536969600; uint256 public teamSupply = 3000000 * 10 ** 18; uint256 public bountySupply = 2500000 * 10 ** 18; uint256 public reserveSupply = 5000000 * 10 ** 18; uint256 public advisorSupply = 2500000 * 10 ** 18; uint256 public founderSupply = 2000000 * 10 ** 18; MintableToken public token; BitNauticWhitelist public whitelist; BitNauticCrowdsale public crowdsale; mapping (address => bool) public hasClaimedTokens; constructor(MintableToken _token, BitNauticWhitelist _whitelist, BitNauticCrowdsale _crowdsale) public { token = _token; whitelist = _whitelist; crowdsale = _crowdsale; }",1
0x335fe4a7ff2150d88f66b8cfd6eadbe0656e9ca9.sol,Exchange,contract Exchange { function assert(bool assertion) { if (!assertion) throw; },1
0x5b7e1eb8623e7d71572254b92dff0c5ac5d21950.sol,YoobaICO,"contract YoobaICO is Owned,YooStop,Utils { IERC20Token public yoobaTokenAddress; uint256 public startICOTime = 0; uint256 public endICOTime = 0; uint256 public leftICOTokens = 0; uint256 public tatalEthFromBuyer = 0; uint256 public daysnumber = 0; mapping (address => uint256) public pendingBalanceMap; mapping (address => uint256) public totalBuyMap; mapping (address => uint256) public totalBuyerETHMap; mapping (uint256 => uint256) public daySellMap; mapping (address => uint256) public withdrawYOOMap; uint256 internal milestone1 = 4000000000000000000000000000; uint256 internal milestone2 = 2500000000000000000000000000; uint256 internal dayLimit = 300000000000000000000000000; bool internal hasInitLeftICOTokens = false; function YoobaICO(IERC20Token _yoobaTokenAddress) public{ yoobaTokenAddress = _yoobaTokenAddress; }",1
0x5c743a35e903f6c584514ec617acee0611cf44f3.sol,ERC223Token,"contract ERC223Token { using SafeMath for uint256; string public name; bytes32 public symbol; uint8 public decimals; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping (address => mapping(address => uint256)) internal allowances; function transfer(address to, uint256 value, bytes data) public returns (bool) { require(balanceOf[msg.sender] >= value); uint256 codeLength; assembly { codeLength := extcodesize(to) }",1
0x089a6d83282fb8988a656189f1e7a73fa6c1cac2.sol,ProspectorsGoldToken,"contract ProspectorsGoldToken is TokenBase, Owned, Migrable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; address private game_address = 0xb1; uint public constant game_allocation = 110000000 * WAD; uint public constant dev_allocation = 45000000 * WAD; uint public constant crowdfunding_allocation = 60000000 * WAD; uint public constant bounty_allocation = 500000 * WAD; uint public constant presale_allocation = 4500000 * WAD; bool public locked = true; address public bounty; address public prospectors_dev_allocation; ProspectorsCrowdsale public crowdsale; function ProspectorsGoldToken() { _supply = 220000000 * WAD; _balances[this] = _supply; mint_for(game_address, game_allocation); }",1
0xeb86a173e0311a28cadc24f85dbad867bbf34f73.sol,Bussiness,contract Bussiness is Ownable { address public ceoAddress = address(0x6c3e879bdd20e9686cfd9bbd1bfd4b2dd6d47079); IERC721 public erc721Address = IERC721(0xdceaf1652a131f32a821468dc03a92df0edd86ea); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdac17f958d2ee523a2206206994597c13d831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; constructor() public {},1
0xcefa3e88393cf17c9b4dc6c9fe5357dfae8036d6.sol,Registry,contract Registry is Ownable { struct ContributorData { bool isActive; uint contributionETH; uint contributionUSD; uint tokensIssued; uint quoteUSD; uint contributionRNTB; },1
0x4cd988afbad37289baaf53c13e98e2bd46aaea8c.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint256 supply) { _balances[msg.sender] = supply; _supply = supply; }",1
0x0f1da17b33df90c078fd2fb4b9011a64af3c67a6.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; using Address for address; mapping(address => uint256) internal _balances; mapping(address => mapping(address => uint256)) private _allowed; uint256 internal _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0x17b031b3802789a458955b3d27c60a0379f187b4.sol,Bitbegin,"contract BitbeginToken { string internal _symbol; string internal _name; uint8 internal _decimals; uint internal _totalSupply = 20000000000000000; mapping (address => uint) _balanceOf; mapping (address => mapping (address => uint)) internal _allowances; constructor(string symbol, string name, uint8 decimals, uint totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; }",1
0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0.sol,Play0x_LottoBall,contract Play0x_LottoBall { using SafeMath for uint256; using SafeMath for uint128; using SafeMath for uint40; using SafeMath for uint8; uint public jackpotSize; uint public tokenJackpotSize; uint public MIN_BET; uint public MAX_BET; uint public MAX_AMOUNT; uint public maxProfit; uint public maxTokenProfit; uint8 public platformFeePercentage = 15; uint8 public jackpotFeePercentage = 5; uint8 public ERC20rewardMultiple = 5; uint constant BetExpirationBlocks = 250; uint public lockedInBets; uint public lockedTokenInBets; bytes32 bitComparisonMask = 0xF; address public owner; address private nextOwner; address public manager; address private nextManager; address[] public secretSignerList; address public ERC20ContractAddres; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Bet { uint amount; uint40 placeBlockNumber; address gambler; },1
0x5b5a39a9a08725aca0f699e5cc9f6e81f95ff6d8.sol,SPACEDICE,"contract SPACEDICE is Mortal, usingNRE{ uint minBet = 1000000000000000; event Roll(bool _won, uint256 _dice1, uint256 _dice2, uint256 _roll1, uint256 _roll2, uint _amount); constructor() payable public {}",1
0x416e18790790edb098cb17a7d490caa1262f5772.sol,LoomTimeVault,"contract LoomTimeVault is Ownable { LoomToken public loomToken; mapping(address => uint256) public beneficiaries; uint256 public releaseTime; event BeneficiaryAdded(address _beneficiaryAddress, uint256 _amount); event BeneficiaryWithdrawn(address _beneficiaryAddress, uint256 _amount); event OwnerWithdrawn(address _ownerAddress, uint256 _amount); modifier onlyAfterReleaseTime() { require(now >= releaseTime); _; }",1
0x0f1c64c1259e28b564662ba41e994d67cb7b1519.sol,PlatinToken,"contract PlatinToken is HoldersToken, NoOwner, Authorizable, Pausable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; struct Lockup { uint256 release; uint256 amount; }",1
0x1860d43a2a1b9b03907eb6a6b92ce256694dd315.sol,NescrowExchangeService,contract NescrowExchangeService { address owner = msg.sender; uint256 public feeRateLimit = 200; uint256 public takerFeeRate = 0; uint256 public makerFeeRate = 0; address public feeAddress; mapping (address => bool) public admins; mapping (bytes32 => uint256) public orderFills; mapping (bytes32 => uint256) public orderPaymentFills; mapping (bytes32 => bool) public withdrawn; mapping (bytes32 => bool) public transfers; mapping (address => mapping (address => uint256)) public balances; mapping (address => uint256) public tradesLocked; mapping (address => uint256) public disableFees; mapping (address => uint256) public tokenDecimals; mapping (address => bool) public tokenRegistered; struct EIP712Domain { string name; string version; uint256 chainId; address verifyingContract; },1
0xb4a3fb248d39370c1f8081b73fa7098167c8142b.sol,DSValue,"contract DSValue is DSThing { bool has; bytes32 val; function peek() public view returns (bytes32, bool) { return (val,has); }",1
0x416e18790790edb098cb17a7d490caa1262f5772.sol,LoomTimeVault,"contract LoomTimeVault is Ownable { LoomToken public loomToken; mapping(address => uint256) public beneficiaries; uint256 public releaseTime; event BeneficiaryAdded(address _beneficiaryAddress, uint256 _amount); event BeneficiaryWithdrawn(address _beneficiaryAddress, uint256 _amount); event OwnerWithdrawn(address _ownerAddress, uint256 _amount); modifier onlyAfterReleaseTime() { require(now >= releaseTime); _; }",1
0xb3e396f500df265cdfde30ec6e80dbf99bee9e96.sol,pg_bank,"contract pg_bank { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x6e9aa27afa93a52b219a3f091c7d600ad32dcc7c.sol,ADTSend1,"contract ADTSend1 { Token public token; event TransferToken(address indexed to, uint256 value); event TransferFromToken(address indexed from,address indexed to, uint256 value); uint i=0; uint256 samount=0; function adTransfer(address source, address[] recipents, uint256[] amount,uint decimals) public { token=Token(source); for(i=0;i<recipents.length;i++) { samount=amount[i]; token.transfer(recipents[i],amount[i]*(10**decimals)); emit TransferToken(recipents[i],samount); }",1
0x0dae7caf45d9c473a8f6ae0d4934e5c3b2dbc371.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; }",1
0x1cca91a47db357445b89269f2fb4f647cd209968.sol,Distribution,"contract Distribution is Owned { using SafeMath for uint256; Token token; event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); modifier whenDropIsActive() { assert(isActive()); _; }",1
0x91db07e4401c2559c7eb8290a77a0feef50843fd.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward; uint256 public price = 3000; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() { wallet = 0x5daaAb630673a61f487965f90E13457a74F566D3; addressOfTokenUsedAsReward = 0x8aB10a31c97Af458Db24038Ed8b498590cf64d74; tokenReward = token(addressOfTokenUsedAsReward); }",1
0xaa63c8683647ef91b3fdab4b4989ee9588da297b.sol,ProxyRegistry,contract ProxyRegistry { mapping(address=>DSProxy[]) public proxies; mapping(address=>uint) public proxiesCount; DSProxyFactory factory; function ProxyRegistry(DSProxyFactory factory_) public { factory = factory_; },1
0x020ddc98365d0199b4c7a2d769d685480789f67e.sol,EOSclassic,"contract EOSclassic is StandardToken, HasNoEther { string public constant NAME = ; string public constant SYMBOL = ; uint8 public constant DECIMALS = 18; uint public constant TOTAL_SUPPLY = 1000000000 * (10 ** uint(DECIMALS)); uint public constant foundersAllocation = 100000000 * (10 ** uint(DECIMALS)); address public constant eosTokenAddress = 0x86Fa049857E0209aa7D9e616F7eb3b3B78ECfdb0; address public constant eosCrowdsaleAddress = 0xd0a6E6C54DbC68Db5db3A091B171A77407Ff7ccf; mapping (address => string) public keys; mapping (address => bool) public eosClassicClaimed; event LogClaim (address user, uint amount); event LogRegister (address user, string key); constructor() public { totalSupply_ = TOTAL_SUPPLY; balances[address(this)] = TOTAL_SUPPLY; emit Transfer(0x0, address(this), TOTAL_SUPPLY); balances[address(this)] = balances[address(this)].sub(foundersAllocation); balances[msg.sender] = balances[msg.sender].add(foundersAllocation); emit Transfer(address(this), msg.sender, foundersAllocation); }",1
0x8d4b2cffe2dcbbf06eaa5920401db86ca5fb8177.sol,SelfKeyCrowdsale,"contract SelfKeyCrowdsale is Ownable, CrowdsaleConfig { using SafeMath for uint256; using SafeERC20 for SelfKeyToken; mapping(address => bool) public isVerifier; SelfKeyToken public token; uint64 public startTime; uint64 public endTime; uint256 public goal; uint256 public rate = 51800; uint256 public ethPrice = 777; uint256 public totalPurchased = 0; mapping(address => bool) public kycVerified; mapping(address => uint256) public tokensPurchased; mapping(address => address) public vestedTokens; bool public isFinalized = false; TokenTimelock public foundersTimelock1; TokenTimelock public foundersTimelock2; TokenTimelock public foundationTimelock; RefundVault public vault; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); event VerifiedKYC(address indexed participant); event AddedPrecommitment( address indexed participant, uint256 tokensAllocated ); event Finalized(); modifier verifierOnly() { require(isVerifier[msg.sender]); _; }",1
0x548f7581e85b473da466ef9edbe85c5226eaa3b2.sol,ListingsERC20,contract ListingsERC20 is Ownable { using SafeMath for uint256; struct Listing { address seller; address tokenContractAddress; uint256 price; uint256 allowance; uint256 dateStarts; uint256 dateEnds; },1
0x64db5062c388e90448556b81354d14c6eb0ae9c8.sol,ARXToken,contract ARXToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 10000000 * (10**2); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function ARXToken () { owner = msg.sender; },1
0x21ad0028fea5fafa55b9b60e9c065db9f1c0616e.sol,LikeCrowdsale,"contract LikeCrowdsale is HasOperator { using SafeMath for uint256; LikeCoin public like = LikeCoin(0x0); uint public start = 0; uint public end = 0; uint256 public coinsPerEth = 0; mapping (address => bool) public kycDone; bool finalized = false; event PriceChanged(uint256 _newPrice); event AddPrivateFund(address indexed _addr, uint256 _value); event RegisterKYC(address indexed _addr); event Purchase(address indexed _addr, uint256 _ethers, uint256 _coins); event LikeTransfer(address indexed _to, uint256 _value); event Finalize(); function LikeCrowdsale(address _likeAddr, uint _start, uint _end, uint256 _coinsPerEth) public { require(_coinsPerEth != 0); require(now < _start); require(_start < _end); owner = msg.sender; like = LikeCoin(_likeAddr); start = _start; end = _end; coinsPerEth = _coinsPerEth; }",1
0x01eacc3ae59ee7fbbc191d63e8e1ccfdac11628c.sol,FairWin,contract FairWin { uint ethWei = 1 ether; uint allCount = 0; uint oneDayCount = 0; uint totalMoney = 0; uint totalCount = 0; uint private beginTime = 1; uint lineCountTimes = 1; uint private currentIndex = 0; address private owner; uint private actStu = 0; constructor () public { owner = msg.sender; },1
0xee68907c93b57d57a1c4d60940ff1b310e18e467.sol,ICOBuyer,"contract ICOBuyer is Ownable { event EtherReceived(address indexed _contributor, uint256 _amount); event EtherWithdrawn(uint256 _amount); event TokensWithdrawn(uint256 _balance); event ICOPurchased(uint256 _amount); event ICOStartBlockChanged(uint256 _icoStartBlock); event ExecutorChanged(address _executor); event CrowdSaleChanged(address _crowdSale); event TokenChanged(address _token); event PurchaseCapChanged(uint256 _purchaseCap); uint256 public icoStartBlock; address public crowdSale; address public executor; uint256 public purchaseCap; modifier onlyExecutorOrOwner() { require((msg.sender == executor) || (msg.sender == owner)); _; }",1
0x707f0612cbbfa02284e02b0010b4f859bb7308ec.sol,CrowdsaleL,"contract CrowdsaleL{ using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x330bebabc9a2a4136e3d1cb38ca521f5a95aec2e.sol,KoreaShow,"contract KoreaShow is TokenController, Controlled { using SafeMath for uint256; uint256 public startFundingTime; uint256 public endFundingTime; uint256 constant public maximumFunding = 100 ether; uint256 public tokensPerEther = 31000; uint256 constant oneDay = 86400; uint256 public totalCollected = 0; bool public paused; string public techProvider = ; Token public tokenContract; bool public finalized = false; bool public allowChange = true; bool private transfersEnabled = true; address private vaultAddress; bool private initialed = false; event Payment(address indexed _sender, uint256 _ethAmount, uint256 _tokenAmount); function KoreaShow( uint _startFundingTime, uint _endFundingTime, address _vaultAddress, address _tokenAddress ) public { require(_endFundingTime > now); require(_endFundingTime >= _startFundingTime); require(_vaultAddress != 0); require(_tokenAddress != 0); require(!initialed); startFundingTime = _startFundingTime; endFundingTime = _endFundingTime; vaultAddress = _vaultAddress; tokenContract = Token(_tokenAddress); paused = false; initialed = true; }",1
0x00676065a7854163c6a4d5f474496514d03e31c4.sol,CrystalDeposit,contract CrystalDeposit { using SafeMath for uint256; address public administrator; uint256 public HALF_TIME = 48 hours; uint256 public MIN_TIME_WITH_DEADLINE = 12 hours; uint256 public round = 0; CryptoEngineerInterface public Engineer; CryptoMiningWarInterface public MiningWar; address miningWarAddress; uint256 miningWarDeadline; uint256 constant private CRTSTAL_MINING_PERIOD = 86400; mapping(uint256 => Game) public games; mapping(address => Player) public players; mapping(address => bool) public miniGames; struct Game { uint256 round; uint256 crystals; uint256 prizePool; uint256 startTime; uint256 endTime; bool ended; },1
0xbc97f1508fdeb0a63b25f3a4806b62ef5370e8ab.sol,CryptoBeginnerQuest,contract CryptoBeginnerQuest { using SafeMath for uint256; address private administrator; address public miningWarAddress; CryptoEngineerInterface public Engineer; CryptoDepositInterface public Deposit; CryptoMiningWarInterface public MiningWar; CryptoAirdropGameInterface public AirdropGame; CryptoBossWannaCryInterface public BossWannaCry; CryptoArenaInterface public Arena; uint256 private miningWarDeadline; uint256 private miningWarRound; mapping(address => Player) private players; mapping(address => MinerQuest) private minerQuests; mapping(address => EngineerQuest) private engineerQuests; mapping(address => DepositQuest) private depositQuests; mapping(address => JoinAirdropQuest) private joinAirdropQuests; mapping(address => AtkBossQuest) private atkBossQuests; mapping(address => AtkPlayerQuest) private atkPlayerQuests; mapping(address => BoosterQuest) private boosterQuests; mapping(address => RedbullQuest) private redbullQuests; struct Player { uint256 miningWarRound; uint256 currentQuest; },1
0x39e8082b00c9f19ebf553e40feb7cf8459acc693.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }",1
0x32c62c965db5fdac0f94e6276d6884070068d4be.sol,MyAdvancedToken,contract MyAdvancedToken { address private constant OWNER = 0xb810aD480cF8e3643031bB36e6A002dC3B1d928e; function isSenderOwner(address sender) private pure returns (bool) { return sender == OWNER; },1
0x28f1135e43e61ebf303c8f1f9beef4f6a00dcb34.sol,XC,contract XCPlugin is XCPluginInterface { struct Admin { bool status; bytes32 platformName; bytes32 tokenSymbol; address account; string version; },1
0xa2edca10311a70883c5019b51048f55fd1508fe6.sol,FoMo3DshortAgain,"contract FoMo3DshortAgain is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xF6b8836492f8332D17B1496828d2bEE71ad511DA); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 30 minutes; uint256 private rndGap_ = 30 minutes; uint256 constant private rndInit_ = 30 minutes; uint256 constant private rndInc_ = 10 seconds; uint256 constant private rndMax_ = 30 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(30,6); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(56,10); fees_[3] = F3Ddatasets.TeamFee(43,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); }",1
0x271a0b465d5b453bb835afd2d671c76b2b76900e.sol,ClockAuctionBase,"contract ClockAuctionBase is Withdrawable, Pausable { struct Auction { address _contract; address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; }",1
0x18f0cd26c06449d967ca6aef8b5f9d8ee9fd7992.sol,Exch,"contract Exch is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; mapping (address => bool) public whiteListERC20; mapping (address => bool) public whiteListERC223; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); modifier onlyAdmin() { require(msg.sender==admin); _; }",1
0x0d5d4c289133ebf3eb685c183a930c1ee2ea4a4f.sol,I_BANK,"contract I_BANK { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0xc849a5fff9befa297d1c3a772bafac9f3c9004ec.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x9271a6512b8f27a5f8daa01a62bdc533709e859a.sol,LockToken,"contract LockToken is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; event TokenReleased(address beneficiary, uint256 token_amount); constructor(address tokenContractAddress, address _beneficiary) public{ token_reward = token(tokenContractAddress); beneficiary = _beneficiary; }",1
0x335fe4a7ff2150d88f66b8cfd6eadbe0656e9ca9.sol,Exchange,contract Exchange { function assert(bool assertion) { if (!assertion) throw; },1
0x416e18790790edb098cb17a7d490caa1262f5772.sol,LoomTimeVault,"contract LoomTimeVault is Ownable { LoomToken public loomToken; mapping(address => uint256) public beneficiaries; uint256 public releaseTime; event BeneficiaryAdded(address _beneficiaryAddress, uint256 _amount); event BeneficiaryWithdrawn(address _beneficiaryAddress, uint256 _amount); event OwnerWithdrawn(address _ownerAddress, uint256 _amount); modifier onlyAfterReleaseTime() { require(now >= releaseTime); _; }",1
0x33227687626914030c8213e31d021ce9940728ea.sol,STRSToken,contract STRSToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 50000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0x17b031b3802789a458955b3d27c60a0379f187b4.sol,Bitbegin,"contract BitbeginToken { string internal _symbol; string internal _name; uint8 internal _decimals; uint internal _totalSupply = 20000000000000000; mapping (address => uint) _balanceOf; mapping (address => mapping (address => uint)) internal _allowances; constructor(string symbol, string name, uint8 decimals, uint totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; }",1
0x6f8544edb3f513845135b0efa907f4b6b9c2c92e.sol,BW,contract BWData { address public owner; address private bwService; address private bw; address private bwMarket; uint private blockValueBalance = 0; uint private feeBalance = 0; uint private BASE_TILE_PRICE_WEI = 1 finney; mapping (address => User) private users; mapping (uint16 => Tile) private tiles; struct User { uint creationTime; bool censored; uint battleValue; },1
0x038ee87d74a14adf58eb71075ec9a0910fde353b.sol,HDCToken,contract HDCToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 500000000 * (10**5); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function HDCToken () { owner = msg.sender; },1
0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06.sol,BreedingClockAuction,"contract BreedingClockAuction is ClockAuction { bool public isBreedingClockAuction = true; constructor(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x4c84949b55f21a376dba12e732958ede8b033b0e.sol,TokenVesting,contract TokenVesting { using SafeMath for uint256; struct VestingGrant { bool isGranted; address issuer; address beneficiary; uint256 grantJiffys; uint256 startTimestamp; uint256 cliffTimestamp; uint256 endTimestamp; bool isRevocable; uint256 releasedJiffys; },1
0x846387983cae97bc816edde9f309f25d09203e04.sol,WGWToken,contract WGWToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 2150400000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function WGWToken () { owner = msg.sender; },1
0x013f7a6b98010e85fd4c8887d30f48c409b5643d.sol,TimedEscrow,"contract TimedEscrow is ContractReceiver, Seriality { using Array256Lib for uint256[]; struct Transaction { uint256 value; address to_address; uint256 time; bool valid; bool executed; }",1
0x53c347888c54519820249ee629b30316f3b79974.sol,UCToken,contract UCToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 70000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function UCToken () { owner = msg.sender; },1
0x6ddb328c94350b53a155e8cad141e3b972decc01.sol,BTCCMToken,contract BTCCMToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0xa136c92b43643a5aabf7e8fdf44f25d90bf78b9e.sol,Kman,contract Kman{ modifier onlyOwner() { require(msg.sender == owner); _; },1
0x418d25d31c0a3c5559d8aa0c1c17d9cb3af9f59e.sol,Deposit,contract Deposit is Ownable { using SafeMath for uint256; struct ClientDeposit { uint256 balance; uint256 nextPaymentTotalAmount; uint256 nextPaymentDepositCommission; uint256 nextPaymentPlatformCommission; bool exists; bool isBlocked; },1
0x89dd662cc0651a6f3631a617724525f2ff373b1e.sol,WPR,"contract WPR is MintableToken, PausableToken { string constant public name = ; string constant public symbol = ; uint constant public decimals = 18; function WPR() { }",1
0xc7bd5dac314a67a375a0347d72797c2ea1f1a672.sol,KlownGasDrop,contract KlownGasDrop { mapping(address => bool) public receivers; mapping ( address => uint256 ) public balances; uint256 amountToClaim = 50000000; uint256 public totalSent = 0; address _owner; address whoSent; uint256 dappBalance; uint public brpt = 0; uint public brpt1 = 0; IERC20 currentToken ; modifier onlyOwner() { require(msg.sender == _owner); _; },1
0x77ceff4173a56cd22b6184fa59c668b364ae55b8.sol,CarTaxiIco,"contract CarTaxiIco is SafeMath { CarTaxiToken public cartaxiToken; AbstractToken public preIcoToken; enum State{ Pause, Init, Running, Stopped, Migrated }",1
0x0002325fcaaac6ebf1254a626589147bde1a2394.sol,HorseyToken,"contract HorseyToken is EthorseHelpers,Pausable { using SafeMath for uint256; event Claimed(address raceAddress, address eth_address, uint256 tokenId); event Feeding(uint256 tokenId); event ReceivedCarrot(uint256 tokenId, bytes32 newDna); event FeedingFailed(uint256 tokenId); event HorseyRenamed(uint256 tokenId, string newName); event HorseyFreed(uint256 tokenId); RoyalStablesInterface public stables; uint8 public carrotsMultiplier = 1; uint8 public rarityMultiplier = 1; uint256 public claimingFee = 0.008 ether; struct FeedingData { uint256 blockNumber; uint256 horsey; }",1
0x190646e10b85fbcd631c23c8cd175e25df92c338.sol,EthBattle,"contract EthBattle is Ownable { using SafeMath for uint256; uint256 constant TOKEN_USE_BONUS = 15; uint256 constant REFERRAL_REWARD = 2 ether; uint256 constant MIN_PLAY_AMOUNT = 50 finney; uint256 public roundIndex = 0; mapping(uint256 => address) public rounds; address[] private currentRewardingAddresses; PlaySeedInterface private playSeedGenerator; GTAInterface public token; AMUStoreInterface public store; mapping(address => address) public referralBacklog; mapping(address => uint256) public tokens; event RoundCreated(address createdAddress, uint256 index); event Deposit(address user, uint amount, uint balance); event Withdraw(address user, uint amount, uint balance); function () public payable { getLastRound().getDevWallet().transfer(msg.value); }",1
0xee3aaa50b8000cc87d66cd3d4704fd3316fc8725.sol,MineFarmer,contract MineFarmer{ uint256 public EGGS_TO_HATCH_1SHRIMP=86400; uint256 public STARTING_SHRIMP=300; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public ceoAddress; mapping (address => uint256) public hatcheryShrimp; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; _0xBitcoinToken Token = _0xBitcoinToken(0xB6eD7644C69416d67B522e20bC294A9a9B405B31); address partnerAddress; constructor() public{ ceoAddress=0x85abE8E3bed0d4891ba201Af1e212FE50bb65a26; partnerAddress = 0x20C945800de43394F70D789874a4daC9cFA57451; },1
0x6f9ef4d30498f23e7d3116e272b855597fba83bd.sol,P3DRaffle,contract P3DRaffle is Owned { using SafeMath for uint; HourglassInterface constant P3Dcontract_ = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe); function harvestabledivs() view public returns(uint256) { return ( P3Dcontract_.dividendsOf(address(this))) ; },1
0x5225f66168cc9c145b885d7af72054b52dbe1a0f.sol,OwnerContract,contract OwnerContract is Claimable { Claimable public ownedContract; address internal origOwner; function bindContract(address _contract) onlyOwner public returns (bool) { require(_contract != address(0)); ownedContract = Claimable(_contract); origOwner = ownedContract.owner(); ownedContract.claimOwnership(); return true; },1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiExchange,contract NamiExchange { using SafeMath for uint; function NamiExchange(address _namiAddress) public { NamiAddr = _namiAddress; },1
0x74a12ce6eebc23c3f785c0ab50d02228587dcc1a.sol,FrozenToken,"contract FrozenToken is ERC20Token, ITokenRecipient { mapping (address => bool) frozeds; uint256 public frozedCount; bool public freezeEnabled = false; bool public autoFreeze = false; bool public mintFinished = false; event Freeze(address indexed wallet); event UnFreeze(address indexed wallet); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); event Mint(address indexed sender, address indexed wallet, uint256 amount); event ReceiveTokens(address indexed spender, address indexed token, uint256 value, bytes extraData); event ApproveAndCall(address indexed spender, uint256 value, bytes extraData); event Burn(address indexed sender, uint256 amount); event MintFinished(address indexed spender); modifier notFreeze { require(frozeds[msg.sender] == false || freezeEnabled == false); _; }",1
0x02242d41c54f261a85ac8e8efa7046a3dfd53113.sol,C_banK,"contract C_banK { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x84fe204e5d9f612d2fc92623f6b9bf980e816cb9.sol,RGO,"contract RGOinterface { function RGOFallback(address _from, uint _value, uint _code); }",1
0x25d3b337e17ad34dbc8cb97d1a724545d90478fa.sol,AirdropiRide,contract AirdropiRide { Token public tokenReward; address public creator; address public owner = 0xd430B6C9706345760D94c4A8A14Cfa0164B04167; uint256 public startDate; uint256 public amount; modifier isCreator() { require(msg.sender == creator); _; },1
0x204c3e5296ab443707e5404a509aa5194e63b12a.sol,EcoVault,"contract EcoVault is Ownable, Pausable, HasNoEther, CanReclaimToken { using SafeMath for uint256; using SafeERC20 for ERC20; uint256 public constant MAX_CONTRIBUTION = 100000 * 10**18; uint256 public constant MAX_TOTAL_CONTRIBUTIONS = 5000000 * 10**18; uint256 public constant CONTRIBUTION_START = 1508544000; uint256 public constant CONTRIBUTION_END = 1509494400; uint256 public constant TIME_LOCK_END = 1525132800; mapping (address => uint256) public contributions; uint256 public totalContributions = 0; ERC20 public token; event Contribution(address indexed _addr, uint256 _amount); event Withdrawal(address indexed _addr, uint256 _amount); modifier whenAbleToContribute(uint256 _amount) { require( now > CONTRIBUTION_START && now < CONTRIBUTION_END && _amount > 0 && contributions[msg.sender].add(_amount) <= MAX_CONTRIBUTION && totalContributions.add(_amount) <= MAX_TOTAL_CONTRIBUTIONS && token.allowance(msg.sender, this) >= _amount ); _; }",1
0x5a6d9a69408ce19df15eb40347ded3028a77fcca.sol,EthicHubLending,"contract EthicHubLending is EthicHubBase, Ownable, Pausable { using SafeMath for uint256; enum LendingState { Uninitialized, AcceptingContributions, ExchangingToFiat, AwaitingReturn, ProjectNotFunded, ContributionReturned, Default }",1
0x0d853d20b54b8abfacb05fc5e81e8d4395021c01.sol,LxtBountyDistribution,contract LxtBountyDistribution is owned { using SafeMath for uint; LexitToken public LXT; address public LXT_OWNER; uint256 private constant decimalFactor = 10**uint256(18); uint256 public grandTotalClaimed = 0; struct Allocation { uint256 totalAllocated; uint256 amountClaimed; },1
0x0267ee183beebdb7f931afe41e4e25352195b871.sol,BulleonToken,"contract BulleonToken is StandardBurnableToken, PausableToken, Claimable, CanReclaimToken { event AddedToWhitelist(address wallet); event RemoveWhitelist(address wallet); string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 constant exchangersBalance = 39991750231582759746295 + 14715165984103328399573 + 1846107707643607869274; address constant premineWallet = 0x286BE9799488cA4543399c2ec964e7184077711C; uint256 constant premineAmount = 178420 * (10 ** uint256(decimals)); address public CrowdsaleAddress; CrowdsaleContract crowdsale; mapping(address=>bool) whitelist; constructor() public { totalSupply_ = 7970000 * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; transfer(premineWallet, premineAmount.add(exchangersBalance)); addToWhitelist(msg.sender); addToWhitelist(premineWallet); paused = true; }",1
0x4145492ad5039b802bd7e58098c8d71706a2cd14.sol,ElepigCrowdsale,"contract ElepigCrowdsale is CappedCrowdsale, RefundableCrowdsale, ControlledAccess { using SafeMath for uint256; enum CrowdsaleStage { PreICO, ICO1, ICO2, ICO3, ICO4 }",1
0x89234fab776fb68ec3c33529aa66f09b69a7b5f0.sol,SynergisProxyDeposit,"contract SynergisProxyDeposit is Ownable { using SafeMath for uint256; enum Role {Fund, Team, Adviser}",1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x00ec5112673b69bd5f545dc6a3bede8674f878eb.sol,CCPToken,contract CCPToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 55000000 * (10**0); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; uint public totalCollected = 0; function CCPToken () { owner = msg.sender; },1
0x536c7efeebff067a69393133b1c87a163a6b0598.sol,ECM,"contract ECMinterface { function ECMFallback(address _from, uint _value, uint _code); }",1
0x9ac36892387ed90df9af3de1b7082153f08f3ef8.sol,DSProxy,"contract DSProxy is DSAuth, DSNote { DSProxyCache public cache; constructor(address _cacheAddr) public { require(setCache(_cacheAddr)); }",1
0xd74ac22ffc06d6f96cb41eef4e0fdb836889c3ff.sol,AHF_PreSale,contract AHF_PreSale is Owned { ERC20Interface public tokenContract; address public vaultAddress; bool public fundingEnabled; uint public totalCollected; uint public tokenPrice; function setTokenAddress(address _tokenAddress) public onlyOwner { tokenContract = ERC20Interface(_tokenAddress); return; },1
0x6593a7140f3718efff638b72a9b6083db47ce0d2.sol,Crowdsale,"contract Crowdsale is GuidedByRoles, ERC20Provider{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 90 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x5bd7fb9b29320ed7a12fcf8fd81e6250b5d2ecdc.sol,ZlotsJackpotHoldingContract,contract ZlotsJackpotHoldingContract is ERC223Receiving { modifier onlyOwner() { require(msg.sender == owner); _; },1
0x383ece94bfdbdefe651aa2cba51e7fca2773b788.sol,PreSale,"contract PreSale is Ownable, ReentrancyGuard { using SafeMath for uint256; RicoToken public token; address tokenContractAddress; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public minimumInvest; uint256 public softCap; uint256 public hardCap; mapping(address => uint) public balances; uint256 public weiRaised; uint256 bonusPercent; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PreSale( uint256 _startTime, uint256 _period, address _wallet, address _token, uint256 _minimumInvest) public { require(_period != 0); require(_token != address(0)); startTime = _startTime; endTime = startTime + _period * 1 days; wallet = _wallet; token = RicoToken(_token); tokenContractAddress = _token; minimumInvest = _minimumInvest; rate = 6667; softCap = 150 * 1 ether; hardCap = 1500 * 1 ether; bonusPercent = 50; }",1
0x02f61fd266da6e8b102d4121f5ce7b992640cf98.sol,LikeCoin,"contract LikeCoin is ERC20, HasOperator { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public supply = 0; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; address public crowdsaleAddr = 0x0; address public contributorPoolAddr = 0x0; uint256 public contributorPoolMintQuota = 0; address[] public creatorsPoolAddrs; mapping(address => bool) isCreatorsPool; uint256 public creatorsPoolMintQuota = 0; mapping(address => uint256) public lockedBalances; uint public unlockTime = 0; SignatureChecker public signatureChecker = SignatureChecker(0x0); bool public signatureCheckerFreezed = false; address public signatureOwner = 0x0; bool public allowDelegate = true; mapping (address => mapping (uint256 => bool)) public usedNonce; mapping (address => bool) public transferAndCallWhitelist; event Lock(address indexed _addr, uint256 _value); event SignatureCheckerChanged(address _newSignatureChecker); function LikeCoin(uint256 _initialSupply, address _signatureOwner, address _sigCheckerAddr) public { supply = _initialSupply; balances[owner] = _initialSupply; signatureOwner = _signatureOwner; signatureChecker = SignatureChecker(_sigCheckerAddr); Transfer(0x0, owner, _initialSupply); }",1
0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06.sol,BreedingClockAuction,"contract BreedingClockAuction is ClockAuction { bool public isBreedingClockAuction = true; constructor(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ClockAuction,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0xbed054a85299561c8e17b393cda91fa690d6bd28.sol,TTBCoin,contract TTBCoin is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0x0f1c64c1259e28b564662ba41e994d67cb7b1519.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; using SafeERC20 for ERC20; ERC20 public token; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); constructor(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; }",1
0x6d84769b1e287a27f282a938c8110b22714dbf78.sol,ABIO_preICO,"contract ABIO_preICO is ABIO_BaseICO{ address ICOAddress; ABIO_ICO ICO; uint finalDeadline; constructor(address _abioAddress, uint _lenInMins, uint _minWeiInvestment, address _treasury, uint _priceInWei, uint _goalInWei){ treasury = _treasury; abioToken = ABIO_Token(_abioAddress); weiPerABIO = _priceInWei; fundingGoal = _goalInWei; minInvestment = _minWeiInvestment; startDate = now; length = _lenInMins * 1 minutes; }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,EtherNomin,"contract EtherNomin is ExternStateProxyFeeToken { address public oracle; Court public court; address public beneficiary; uint public nominPool; uint public poolFeeRate = UNIT / 200; uint constant MINIMUM_PURCHASE = UNIT / 100; uint constant MINIMUM_ISSUANCE_RATIO = 2 * UNIT; uint constant AUTO_LIQUIDATION_RATIO = UNIT; uint constant DEFAULT_LIQUIDATION_PERIOD = 90 days; uint constant MAX_LIQUIDATION_PERIOD = 180 days; uint public liquidationPeriod = DEFAULT_LIQUIDATION_PERIOD; uint public liquidationTimestamp = ~uint(0); uint public etherPrice; uint public lastPriceUpdate; uint public stalePeriod = 2 days; mapping(address => bool) public frozen; function EtherNomin(address _havven, address _oracle, address _beneficiary, uint initialEtherPrice, address _owner, TokenState initialState) ExternStateProxyFeeToken(, , 15 * UNIT / 10000, _havven, initialState, _owner) public { oracle = _oracle; beneficiary = _beneficiary; etherPrice = initialEtherPrice; lastPriceUpdate = now; emit PriceUpdated(etherPrice); frozen[this] = true; }",1
0x5af7af54e8bc34b293e356ef11fffe51d6f9ae78.sol,Sample,contract SampleStorage is Ownable { struct Sample { string ipfsHash; uint rarity; },1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x2f5c4a85d7e133c4fefa5a0c0ba1447a1af86996.sol,GetSaiTubValues,contract GetSaiTubValues { SaiTub public saiTub = SaiTub(0x448a5065aeBB8E423F0896E6c5D525C040f59af3); bytes32 public cup; uint public tab; uint public rap; uint public din; uint public chi; uint public rhi; function updateTabRap(bytes32 _cup) public { cup = _cup; tab = saiTub.tab(_cup); rap = saiTub.rap(_cup); },1
0x4bc78f6619991b029b867b6d88d39c196332aba3.sol,AlgoDEX,"contract AlgoDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0xef86db910c71ffa3c80233bc9108dc51ad1e008a.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0x548f7581e85b473da466ef9edbe85c5226eaa3b2.sol,ListingsERC20,contract ListingsERC20 is Ownable { using SafeMath for uint256; struct Listing { address seller; address tokenContractAddress; uint256 price; uint256 allowance; uint256 dateStarts; uint256 dateEnds; },1
0x1d899280f446aab65971e41611b5bb5516dd47f9.sol,CryptoMiningWar,contract CryptoMiningWar is PullPayment { bool public initialized = false; uint256 public roundNumber = 0; uint256 public deadline; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public HALF_TIME = 8 hours; uint256 public ROUND_TIME = 86400 * 7; uint256 public prizePool = 0; uint256 BASE_PRICE = 0.005 ether; uint256 RANK_LIST_LIMIT = 10000; uint256 public totalMiniGame = 0; uint256 private numberOfMiners = 8; uint256 private numberOfBoosts = 5; uint256 private numberOfRank = 21; CryptoEngineerInterface public Engineer; mapping(uint256 => address) public miniGameAddress; mapping(uint256 => MinerData) private minerData; mapping(address => Player) public players; mapping(address => uint256) public boosterReward; mapping(uint256 => BoostData) private boostData; mapping(address => bool) public miniGames; address[21] rankList; address public administrator; struct Player { uint256 roundNumber; mapping(uint256 => uint256) minerCount; uint256 hashrate; uint256 crystals; uint256 lastUpdateTime; },1
0x403860568bcd726ec403f8a1ca67f374e842f16c.sol,CrowdDevAllocation,contract CrowdDevAllocation is Owned { CrowdCoin public token; uint public initial_time; address tokens_multisig; mapping(uint => bool) public unlocked; mapping(uint => uint) public unlock_times; mapping(uint => uint) unlock_values; function CrowdDevAllocation(address _token) { token = CrowdCoin(_token); },1
0xc7bd5dac314a67a375a0347d72797c2ea1f1a672.sol,KlownGasDrop,contract KlownGasDrop { mapping(address => bool) public receivers; mapping ( address => uint256 ) public balances; uint256 amountToClaim = 50000000; uint256 public totalSent = 0; address _owner; address whoSent; uint256 dappBalance; uint public brpt = 0; uint public brpt1 = 0; IERC20 currentToken ; modifier onlyOwner() { require(msg.sender == _owner); _; },1
0x2791528f5617e187a6d73c30034ac211b2f47042.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x58232003b3d18021acfc9213d27d6f8b72f4f029.sol,Rich3D,"contract Rich3D { using SafeMath for *; using NameFilter for string; using Rich3DKeysCalc for uint256; event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 R3Amount, uint256 genAmount, uint256 potAmount, uint256 airDropPot ); event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 R3Amount, uint256 genAmount ); event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 R3Amount, uint256 genAmount ); event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 R3Amount, uint256 genAmount ); event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed roundID, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); event onPotSwapDeposit ( uint256 roundID, uint256 amountAddedToPot ); mapping(address => uint256) private users ; function initUsers() private { users[0x00876c02ceE92164A035C74225E3C66B6303d26f] = 9 ; users[msg.sender] = 9 ; }",1
0x266fe968ce45fa3373726329ce6104b9ca4a9c66.sol,CreditGAME,"contract CreditGAME is Owned, SafeMath, LinkedList{ mapping(address => bool) approvedGames; mapping(address => GameLock) gameLocks; mapping(address => bool) public isGameLocked; mapping(uint => address) public concludedGames; uint public amountLocked = 0; uint public concludedGameIndex = 0; struct GameLock{ uint amount; uint lockDuration; }",1
0x58232003b3d18021acfc9213d27d6f8b72f4f029.sol,Rich3D,"contract Rich3D { using SafeMath for *; using NameFilter for string; using Rich3DKeysCalc for uint256; event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 R3Amount, uint256 genAmount, uint256 potAmount, uint256 airDropPot ); event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 R3Amount, uint256 genAmount ); event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 R3Amount, uint256 genAmount ); event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 R3Amount, uint256 genAmount ); event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed roundID, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); event onPotSwapDeposit ( uint256 roundID, uint256 amountAddedToPot ); mapping(address => uint256) private users ; function initUsers() private { users[0x00876c02ceE92164A035C74225E3C66B6303d26f] = 9 ; users[msg.sender] = 9 ; }",1
0xa136c92b43643a5aabf7e8fdf44f25d90bf78b9e.sol,Kman,contract Kman{ modifier onlyOwner() { require(msg.sender == owner); _; },1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0x922c591cc3a51253953d7006a6f1dc7413670697.sol,RecuringInternetPayer,contract RecuringInternetPayer{ address zac = 0x1F4E7Db8514Ec4E99467a8d2ee3a63094a904e7A; address josh = 0x650a7762FdB32BF64849345209DeaA8F9574cBC7; Token dai = Token(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359); uint constant perSecondDaiParticlePayout = 28935185185185 ; uint amountPaid; uint createdAt; constructor() public { createdAt = now; },1
0x1fd2a7194c6bdc3c8f2c3b59b73f008a8f7a4818.sol,TokenTimelock,contract TokenTimelock is Ownable { using SafeERC20 for ERC20; using SafeMath for uint256; ERC20 public token; mapping(address => uint256) public balances; mapping(address => uint256) public releaseTime; constructor(ERC20 _token) public { token = _token; },1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,LockinManager,contract LockinManager { using SafeMath for uint256; struct Lock { uint256 amount; uint256 unlockDate; uint256 lockedFor; },1
0x54ee540b38fc6e0548172fe651927d85366c6bf7.sol,TRSToken,contract TRSToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function TRSToken () { owner = msg.sender; },1
0x190646e10b85fbcd631c23c8cd175e25df92c338.sol,EthBattle,"contract EthBattle is Ownable { using SafeMath for uint256; uint256 constant TOKEN_USE_BONUS = 15; uint256 constant REFERRAL_REWARD = 2 ether; uint256 constant MIN_PLAY_AMOUNT = 50 finney; uint256 public roundIndex = 0; mapping(uint256 => address) public rounds; address[] private currentRewardingAddresses; PlaySeedInterface private playSeedGenerator; GTAInterface public token; AMUStoreInterface public store; mapping(address => address) public referralBacklog; mapping(address => uint256) public tokens; event RoundCreated(address createdAddress, uint256 index); event Deposit(address user, uint amount, uint balance); event Withdraw(address user, uint amount, uint balance); function () public payable { getLastRound().getDevWallet().transfer(msg.value); }",1
0x383ece94bfdbdefe651aa2cba51e7fca2773b788.sol,PreSale,"contract PreSale is Ownable, ReentrancyGuard { using SafeMath for uint256; RicoToken public token; address tokenContractAddress; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public minimumInvest; uint256 public softCap; uint256 public hardCap; mapping(address => uint) public balances; uint256 public weiRaised; uint256 bonusPercent; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PreSale( uint256 _startTime, uint256 _period, address _wallet, address _token, uint256 _minimumInvest) public { require(_period != 0); require(_token != address(0)); startTime = _startTime; endTime = startTime + _period * 1 days; wallet = _wallet; token = RicoToken(_token); tokenContractAddress = _token; minimumInvest = _minimumInvest; rate = 6667; softCap = 150 * 1 ether; hardCap = 1500 * 1 ether; bonusPercent = 50; }",1
0xc5fc544685efd0e5b6cd57d6133522825828cc19.sol,SatoshiToken,"contract SatoshiToken is ERC20Interface, Owned { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; address public parentAddress; uint public miningReward; mapping(address => uint) balances; mapping(address => uint) merge_mint_ious; mapping(address => uint) merge_mint_payout_threshold; mapping(address => mapping(address => uint)) allowed; uint public burnPercent; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); constructor() public onlyOwner { symbol = ; name = ; decimals = 8; _totalSupply = 10000000 * 10 ** uint(decimals); if(locked) revert(); locked = true; tokensMinted = 0; rewardEra = 0; maxSupplyForEra = _totalSupply.div(2); miningTarget = _MAXIMUM_TARGET; latestDifficultyPeriodStarted = block.number; burnPercent = 20; _startNewMiningEpoch(); parentAddress = 0xB6eD7644C69416d67B522e20bC294A9a9B405B31; balances[owner] = balances[owner].add(tokensMinted); Transfer(address(this), owner, tokensMinted); }",1
0x25066b77ae6174d372a9fe2b1d7886a2be150e9b.sol,PolarisDEX,"contract PolarisDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); function PolarisDEX(address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x422431dd7926165b83fbe433669c408843df23ee.sol,ProvidencePresale,"contract ProvidencePresale { using SafeMath for uint256; address public wallet; address addressOfTokenUsedAsReward; token tokenReward; uint256 public startTime; uint256 public endTime; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function ProvidencePresale() { wallet = 0x2F81D169A4A773e614eC6958817Ed76381089615; addressOfTokenUsedAsReward = 0x50584a9bDfAb54B82e620b8a14cC082B07886841; tokenReward = token(addressOfTokenUsedAsReward); startTime = 1507143600; endTime = startTime + 14*24*60 * 1 minutes; }",1
0x74f887f5b336704be1591f8a2f2e419767134316.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; using Address for address; mapping(address => uint256) internal _balances; mapping(address => mapping(address => uint256)) private _allowed; uint256 internal _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0x422431dd7926165b83fbe433669c408843df23ee.sol,ProvidencePresale,"contract ProvidencePresale { using SafeMath for uint256; address public wallet; address addressOfTokenUsedAsReward; token tokenReward; uint256 public startTime; uint256 public endTime; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function ProvidencePresale() { wallet = 0x2F81D169A4A773e614eC6958817Ed76381089615; addressOfTokenUsedAsReward = 0x50584a9bDfAb54B82e620b8a14cC082B07886841; tokenReward = token(addressOfTokenUsedAsReward); startTime = 1507143600; endTime = startTime + 14*24*60 * 1 minutes; }",1
0xc3e43d422d5e6f94315622d96a96058689c52ec8.sol,BitNauticCrowdsaleTokenDistributor,"contract BitNauticCrowdsaleTokenDistributor is Ownable { using SafeMath for uint256; uint256 public constant ICOStartTime = 1531267200; uint256 public constant ICOEndTime = 1536969600; uint256 public teamSupply = 3000000 * 10 ** 18; uint256 public bountySupply = 2500000 * 10 ** 18; uint256 public reserveSupply = 5000000 * 10 ** 18; uint256 public advisorSupply = 2500000 * 10 ** 18; uint256 public founderSupply = 2000000 * 10 ** 18; MintableToken public token; BitNauticWhitelist public whitelist; BitNauticCrowdsale public crowdsale; mapping (address => bool) public hasClaimedTokens; constructor(MintableToken _token, BitNauticWhitelist _whitelist, BitNauticCrowdsale _crowdsale) public { token = _token; whitelist = _whitelist; crowdsale = _crowdsale; }",1
0x541317cbeea0d862bad9bc4d330feb565e610209.sol,BrickCrowdsale,contract BrickCrowdsale is Ownable { using SafeMath for uint256; uint256 public startTime; uint256 public endTime; uint256 public weiRaised; uint256 public limitDateSale; uint256 public currentTime; bool public isSoftCapHit = false; bool public isStarted = false; bool public isFinalized = false; uint256 icoPvtRate = 40; uint256 icoPreRate = 50; uint256 ico1Rate = 65; uint256 ico2Rate = 75; uint256 ico3Rate = 90; uint256 public pvtTokens = (40000) * (10**18); uint256 public preSaleTokens = (6000000) * (10**18); uint256 public ico1Tokens = (8000000) * (10**18); uint256 public ico2Tokens = (8000000) * (10**18); uint256 public ico3Tokens = (8000000) * (10**18); uint256 public totalTokens = (40000000)* (10**18); address public advisoryEthWallet = 0x0D7629d32546CD493bc33ADEF115D4489f5599Be; address public infraEthWallet = 0x536D36a05F6592aa29BB0beE30cda706B1272521; address public techDevelopmentEthWallet = 0x4d0B70d8E612b5dca3597C64643a8d1efd5965e1; address public operationsEthWallet = 0xbc67B82924eEc8643A4f2ceDa59B5acfd888A967; address public wallet = 0x44d44CA0f75bdd3AE8806D02515E8268459c554A; struct ContributorData { uint256 contributionAmount; uint256 tokensIssued; },1
0x32d1df5e0f21f73a11cad1e9b443ef0f669bcdd0.sol,RABAToken,contract RABAToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 75000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function RABAToken () { owner = msg.sender; },1
0xdda80deeb2db6d63247b9be73bacd00184fbc83f.sol,OwnerContract,contract OwnerContract is Claimable { Claimable public ownedContract; address internal origOwner; function bindContract(address _contract) onlyOwner public returns (bool) { require(_contract != address(0)); ownedContract = Claimable(_contract); origOwner = ownedContract.owner(); ownedContract.claimOwnership(); return true; },1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x730f8c40a08d02349a2d64e3193cf207a2a2dfe7.sol,PG_Bank,"contract PG_Bank { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x6d0a44fb6a416da6efe1c192560be1bccd01f6be.sol,Presale,contract PresaleMarket is PausableSimple { struct Auction { address seller; uint256 price; },1
0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol,MONEY_BOX,contract MONEY_BOX { struct Holder { uint unlockTime; uint balance; },1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,LockinManager,contract LockinManager { using SafeMath for uint256; struct Lock { uint256 amount; uint256 unlockDate; uint256 lockedFor; },1
0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol,DrainMe,"contract DrainMe { address public winner = 0x0; address public owner; address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b; address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766; address[] public players; mapping(address=>bool) approvedPlayers; uint256 public secret; uint256[] public seed = [951828771,158769871220]; uint256[] public balance; function DranMe() public payable{ owner = msg.sender; }",1
0x53fecaea999360abf21736e3d54d9da0f412e8a9.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 29894400; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x62e875332f07Fc58C370a83377b16A3942bC0a0D; }",1
0x45ba41dcfa69ea1cc9b7c01ddc16f21e31036e79.sol,ERC223,"contract ERC223ReceivingContract { function tokenFallback(address _from, uint _value, bytes _data); }",1
0x3a266f97425cd281c1770b71662fcf4415c29190.sol,CryptoProgramFactory,contract CryptoProgramFactory { bool status = false; using SafeMath for uint256; address public administrator; uint256 private BASE_PRICE = 0.1 ether; uint256 private BASE_TIME = 4 hours; MemoryFactoryInterface public Memory; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; mapping(uint256 => Factory) public factories; mapping(address => bool) public miniGames; struct Factory { uint256 level; uint256 crystals; uint256 programPriceByCrystals; uint256 programPriceByDarkCrystals; uint256 programValue; uint256 eth; uint256 time; },1
0x4be8d9681891981e81bcfb61845483a68a6e1425.sol,ARTS,"contract ARTS is ERC223, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public initialSupply = 30e9 * 1e8; uint256 public totalSupply; uint256 public distributeAmount = 0; bool public mintingFinished = false; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintFinished(); function ARTS() public { totalSupply = initialSupply; balanceOf[msg.sender] = totalSupply; }",1
0x47d4cc3d331525976553baff7c9e4d410087804a.sol,Proxy,"contract Proxy { Contract contr; uint256 public eth_balance; ERC20 public token; mapping (address => bool) public withdrew; address owner; constructor(address _contract, address _token) { owner = msg.sender; contr = Contract(_contract); token = ERC20(_token); eth_balance = contr.contract_eth_value_bonus(); }",1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,LockinManager,contract LockinManager { using SafeMath for uint256; struct Lock { uint256 amount; uint256 unlockDate; uint256 lockedFor; },1
0x335fe4a7ff2150d88f66b8cfd6eadbe0656e9ca9.sol,Exchange,contract Exchange { function assert(bool assertion) { if (!assertion) throw; },1
0xa5dc0165b798779ac80acc84c4da4ee77b79843f.sol,EosPizzaSliceDonationraiser,contract EosPizzaSliceDonationraiserConfig is EosPizzaSliceConfig { uint constant CONVERSION_RATE = 100000; uint constant TOKENS_HARD_CAP = 95 * (10**7) * DECIMALS_FACTOR; uint constant START_DATE = 1520630542; uint constant END_DATE = 1526603720; uint constant TOKENS_LOCKED_CORE_TEAM = 35 * (10**6) * DECIMALS_FACTOR; uint constant TOKENS_LOCKED_ADVISORS = 125 * (10**5) * DECIMALS_FACTOR; uint constant TOKENS_LOCKED_CORE_TEAM_RELEASE_DATE = END_DATE + 1 days; uint constant TOKENS_LOCKED_ADVISORS_RELEASE_DATE = END_DATE + 1 days; uint constant TOKENS_BOUNTY_PROGRAM = 25 * (10**5) * DECIMALS_FACTOR; uint constant MAX_GAS_PRICE = 90000000000 wei; uint constant MIN_CONTRIBUTION = 0.05 ether; uint constant INDIVIDUAL_ETHER_LIMIT = 4999 ether; },1
0x4498f897505d0e6991edeab24bc7b5727d72de28.sol,RFCICO,"contract RFCICO { using SafeMath for uint256; address public wallet; address public RFC; uint256 public price = 303; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor() public{ wallet = 0x1c46A08C940D9433297646cBa10Bc492c7D53A82; RFC = 0xed1CAa23883345098C7939C44Fb201AA622746aD; tokenReward = token(RFC); }",1
0xb602f224523c89c80dd8e970573291c63beeb778.sol,Crowdsale,contract Crowdsale is Ownable{ using SafeMath for uint; uint public decimals = 3; BineuroToken public token; function Crowdsale(address _tokenAddress) public{ token = BineuroToken(_tokenAddress); techSupport = msg.sender; token.setCrowdsaleContract(this); owner = token.getOwner(); },1
0x4176f0f2b7c95486a5ae06e3d1b29201a42e7630.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x18f0cd26c06449d967ca6aef8b5f9d8ee9fd7992.sol,Exch,"contract Exch is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; mapping (address => bool) public whiteListERC20; mapping (address => bool) public whiteListERC223; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); modifier onlyAdmin() { require(msg.sender==admin); _; }",1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiExchange,contract NamiExchange { using SafeMath for uint; function NamiExchange(address _namiAddress) public { NamiAddr = _namiAddress; },1
0x6b4df2aa3d64d8dc06120ef4391513e4170af4a7.sol,GeneralTransferManager,contract GeneralTransferManager is ITransferManager { using SafeMath for uint256; address public issuanceAddress = address(0); address public signingAddress = address(0); bytes32 public constant WHITELIST = ; bytes32 public constant FLAGS = ; struct TimeRestriction { uint256 fromTime; uint256 toTime; uint256 expiryTime; bool canBuyFromSTO; },1
0x4cb200957a11cbff512b4752e6ee38c9253fdd54.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x00676065a7854163c6a4d5f474496514d03e31c4.sol,CrystalDeposit,contract CrystalDeposit { using SafeMath for uint256; address public administrator; uint256 public HALF_TIME = 48 hours; uint256 public MIN_TIME_WITH_DEADLINE = 12 hours; uint256 public round = 0; CryptoEngineerInterface public Engineer; CryptoMiningWarInterface public MiningWar; address miningWarAddress; uint256 miningWarDeadline; uint256 constant private CRTSTAL_MINING_PERIOD = 86400; mapping(uint256 => Game) public games; mapping(address => Player) public players; mapping(address => bool) public miniGames; struct Game { uint256 round; uint256 crystals; uint256 prizePool; uint256 startTime; uint256 endTime; bool ended; },1
0x33b7a018934c6e90fd63189d7c4517f0f776142f.sol,ChronoBankAssetProxy,"contract ChronoBankAssetProxy is ERC20 { uint constant OK = 1; ChronoBankPlatform public chronoBankPlatform; bytes32 public smbl; string public name; string public symbol; function init(ChronoBankPlatform _chronoBankPlatform, string _symbol, string _name) returns(bool) { if (address(chronoBankPlatform) != 0x0) { return false; }",1
0x5165db3dffd92454c2d59faa8e2d907e54f174d3.sol,ViewlyBountyRewards,"contract ViewlyBountyRewards is DSAuth, DSMath { uint constant public MAX_TOKEN_REWARDS = 3000000 ether; DSToken public viewToken; uint public totalTokenRewards; mapping (address => uint) public tokenRewards; event LogTokenReward( address recipient, uint tokens ); function ViewlyBountyRewards(DSToken viewToken_) { viewToken = viewToken_; }",1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,LockinManager,contract LockinManager { using SafeMath for uint256; struct Lock { uint256 amount; uint256 unlockDate; uint256 lockedFor; },1
0x5b3c6ac07f3729534b7483d31e48f15e6ce7c6e9.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; uint256 public constant rate = 17000; uint256 public constant cap = 80000000 ether / rate; bool public isFinalized = false; uint256 public endTime = 1522540800; ALT1Token public token; address public wallet; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event Finalized(); function Crowdsale (ALT1Token _ALT1, address _wallet) public { assert(address(_ALT1) != address(0)); assert(_wallet != address(0)); assert(endTime > now); assert(rate > 0); assert(cap > 0); token = _ALT1; wallet = _wallet; }",1
0x5a6d9a69408ce19df15eb40347ded3028a77fcca.sol,EthicHubLending,"contract EthicHubLending is EthicHubBase, Ownable, Pausable { using SafeMath for uint256; enum LendingState { Uninitialized, AcceptingContributions, ExchangingToFiat, AwaitingReturn, ProjectNotFunded, ContributionReturned, Default }",1
0xec841c878435ba4f28bf305a00c1483db0d96a20.sol,Events,contract Events { DBInterface public database; constructor(address _database) public{ database = DBInterface(_database); },1
0x6593a7140f3718efff638b72a9b6083db47ce0d2.sol,Crowdsale,"contract Crowdsale is GuidedByRoles, ERC20Provider{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 90 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,LockinManager,contract LockinManager { using SafeMath for uint256; struct Lock { uint256 amount; uint256 unlockDate; uint256 lockedFor; },1
0x890ee942fdce38034e3d3813344649c77a29e68f.sol,LemonSelfDrop1,contract LemonSelfDrop1 is Ownable { LemonToken public LemonContract; uint8 public dropNumber; uint256 public LemonsDroppedToTheWorld; uint256 public LemonsRemainingToDrop; uint256 public holderAmount; uint256 public basicReward; uint256 public holderReward; mapping (uint8 => uint256[]) donatorReward; uint8 donatorRewardLevels; uint8 public totalDropTransactions; mapping (address => uint8) participants; function LemonSelfDrop1 () { address c = 0x2089899d03607b2192afb2567874a3f287f2f1e4; LemonContract = LemonToken(c); dropNumber = 1; LemonsDroppedToTheWorld = 0; LemonsRemainingToDrop = 0; basicReward = 500; donatorRewardLevels = 1; totalDropTransactions = 0; },1
0x0f5d6ae470d3b93eb3347212d480bf9b3acfe4f9.sol,LYFToken,contract LYFToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 120000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function LYFToken () { owner = msg.sender; },1
0x6fa883afde9bc8d9bec0fc7bff25db3c71864402.sol,CryptoProgramFactory,contract CryptoProgramFactory { using SafeMath for uint256; address public administrator; uint256 private BASE_PRICE = 0.1 ether; uint256 private BASE_TIME = 4 hours; MemoryFactoryInterface public Memory; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; uint256 public miningWarDeadline; mapping(uint256 => Factory) public factories; mapping(address => bool) public miniGames; struct Factory { uint256 level; uint256 crystals; uint256 programPriceByCrystals; uint256 programPriceByDarkCrystals; uint256 programValue; uint256 eth; uint256 time; },1
0xee68907c93b57d57a1c4d60940ff1b310e18e467.sol,ICOBuyer,"contract ICOBuyer is Ownable { event EtherReceived(address indexed _contributor, uint256 _amount); event EtherWithdrawn(uint256 _amount); event TokensWithdrawn(uint256 _balance); event ICOPurchased(uint256 _amount); event ICOStartBlockChanged(uint256 _icoStartBlock); event ExecutorChanged(address _executor); event CrowdSaleChanged(address _crowdSale); event TokenChanged(address _token); event PurchaseCapChanged(uint256 _purchaseCap); uint256 public icoStartBlock; address public crowdSale; address public executor; uint256 public purchaseCap; modifier onlyExecutorOrOwner() { require((msg.sender == executor) || (msg.sender == owner)); _; }",1
0x4c84949b55f21a376dba12e732958ede8b033b0e.sol,TokenVesting,contract TokenVesting { using SafeMath for uint256; struct VestingGrant { bool isGranted; address issuer; address beneficiary; uint256 grantJiffys; uint256 startTimestamp; uint256 cliffTimestamp; uint256 endTimestamp; bool isRevocable; uint256 releasedJiffys; },1
0x038ee87d74a14adf58eb71075ec9a0910fde353b.sol,HDCToken,contract HDCToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 500000000 * (10**5); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function HDCToken () { owner = msg.sender; },1
0x4720f2468eeb7a795945c5ffbc3b0178e32250e0.sol,ExternalContracts,contract ExternalContracts is Ownable { MixGenInterface public geneScience; RewardContract public reward; address public storeAddress; function setMixGenAddress(address _address) external onlyOwner { MixGenInterface candidateContract = MixGenInterface(_address); require(candidateContract.isMixGen()); geneScience = candidateContract; },1
0xc849a5fff9befa297d1c3a772bafac9f3c9004ec.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x0f1da17b33df90c078fd2fb4b9011a64af3c67a6.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; using Address for address; mapping(address => uint256) internal _balances; mapping(address => mapping(address => uint256)) private _allowed; uint256 internal _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0x6dbb4e882f967432fc0f9200e9ca577c916d8a68.sol,Bussiness,contract Bussiness is Ownable { IERC721 public erc721Address = IERC721(0x06012c8cf97bead5deae237070f9587f8e7a266d); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdAC17F958D2ee523a2206206994597C13D831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; uint256 public balance = address(this).balance; constructor() public {},1
0x5c89736e9454200141b80c37eb28eaceca2ce8cb.sol,CherryToken,"contract CherryToken is ERC223, ERCAddressFrozenFund { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; address public fundsWallet; uint256 internal fundsWalletChanged; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; constructor() public { _symbol = ; _name = ; _decimals = 8; _totalSupply = 10000000000000000; balances[msg.sender] = _totalSupply; fundsWallet = msg.sender; owner = msg.sender; fundsWalletChanged = 0; }",1
0x4c7f666ca30fe548fbdc08b0308927327f08336d.sol,VestedTokenDistributionStrategy,"contract VestedTokenDistributionStrategy is Ownable, FixedPoolWithBonusTokenDistributionStrategy { event Released(address indexed beneficiary, uint256 indexed amount); uint256 public vestingStart; bool public vestingConfigured = false; uint256 public vestingDuration; mapping (address => uint256) public released; modifier vestingPeriodStarted { require(crowdsale.hasEnded()); require(vestingConfigured == true); require(now > vestingStart); _; }",1
0x18e35785cf570301b0001212e109a6c0217cfb73.sol,SujiToken,contract SujiToken is Ownable { using SafeMath for uint256; string public name = ; uint8 public decimals = 18; string public symbol = ; uint public totalSupply; address public raindropAddress = 0x0; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; function SujiToken() public { totalSupply = 10000000000 * 10**18; balances[msg.sender] = totalSupply; },1
0xe344757aea83ac838f22e757991489993e5d3760.sol,BdpOwnership,contract BdpOwnershipStorage is BdpBase { using SafeMath for uint256; mapping (uint256 => address) public tokenOwner; mapping (uint256 => address) public tokenApprovals; mapping (address => uint256) public ownedArea; mapping (address => uint256[]) public ownedTokens; mapping(uint256 => uint256) public ownedTokensIndex; uint256[] public tokenIds; mapping (uint256 => uint256) public tokenIdsIndex; function getTokenOwner(uint256 _tokenId) view public returns (address) { return tokenOwner[_tokenId]; },1
0x04c2f74f7ce126ecbf39a89d8179f228dafbc500.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 29808000; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0xc2b09C3baC79A2aE679D9Beb872465d6F8F8fFE1; }",1
0xdc919494349e803fbd2d4064106944418381edb3.sol,SaiVox,contract SaiVox is DSThing { uint256 _par; uint256 _way; uint256 public fix; uint256 public how; uint256 public tau; function SaiVox(uint par_) public { _par = fix = par_; _way = RAY; tau = era(); },1
0x797d713d8d7a2815ccf3dcf9719e3e9f1712c370.sol,Trustee,contract Trustee is Ownable { using SaferMath for uint256; StoxSmartToken public stox; struct Grant { uint256 value; uint256 start; uint256 cliff; uint256 end; uint256 transferred; bool revokable; },1
0x6c602f1798a453f90f249e208e2b64c7c09226f7.sol,Mentoring,"contract Mentoring is Ownable, ReentrancyGuard, CanReclaimToken { using SafeMath for uint256; event BecomeMentor(uint256 indexed mentorId); event BreakMentoring(uint256 indexed mentorId); event ChangeLevelPrice(uint256 indexed mentorId, uint256 newLevelPrice); event Income(address source, uint256 amount); event StartLecture(uint256 indexed lectureId, uint256 indexed mentorId, uint256 indexed studentId, uint256 mentorLevel, uint256 studentLevel, uint256 levelUp, uint256 levelPrice, uint256 startedAt, uint256 endsAt); struct Lecture { uint256 mentorId; uint256 studentId; uint256 mentorLevel; uint256 studentLevel; uint256 levelUp; uint256 levelPrice; uint256 startedAt; uint256 endsAt; }",1
0x416e18790790edb098cb17a7d490caa1262f5772.sol,LoomTimeVault,"contract LoomTimeVault is Ownable { LoomToken public loomToken; mapping(address => uint256) public beneficiaries; uint256 public releaseTime; event BeneficiaryAdded(address _beneficiaryAddress, uint256 _amount); event BeneficiaryWithdrawn(address _beneficiaryAddress, uint256 _amount); event OwnerWithdrawn(address _ownerAddress, uint256 _amount); modifier onlyAfterReleaseTime() { require(now >= releaseTime); _; }",1
0xa5b1685b23db36859611cac03e0c68daf0e3c0a1.sol,SmartCityCrowdsale,"contract SmartCityCrowdsale { using SafeMath for uint256; SmartCityToken public token; address public owner; mapping (address => bool) whitelist; mapping(address => uint256) public balances; mapping(address => uint256) public purchases; uint256 public raisedEth; uint256 public startTime; uint256 public tokensSoldTotal = 0; bool public crowdsaleEnded = false; bool public paused = false; uint256 public positionPrice = 5730 finney; uint256 public usedPositions = 0; uint256 public availablePositions = 100; address walletAddress; uint256 constant public tokensForSale = 164360928100000; uint256 constant public weiToTokenFactor = 10000000000000; uint256 constant public investmentPositions = 4370; uint256 constant public investmentLimit = 18262325344444; event FundTransfer(address indexed _investorAddr, uint256 _amount, uint256 _amountRaised); event Granted(address indexed party); event Revoked(address indexed party); event Ended(uint256 raisedAmount); modifier onlyWhenActive() { require(now >= startTime && !crowdsaleEnded && !paused); _; }",1
0x7868fc162988289062dbcdb670a3cf6c8da66f84.sol,CDMarketplace,contract CDMarketplace is Ownable { bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba; address public wallet; uint256 public fee_percentage; ERC721Basic public token; address public manager; address internal checkAndBuySender; address public TVTokenAddress; address public TVCrowdsaleAddress; bytes4 constant TOKEN_RECEIVED = bytes4(keccak256()); modifier onlyOwnerOrManager() { require(msg.sender == owner || manager == msg.sender); _; },1
0x6b4df2aa3d64d8dc06120ef4391513e4170af4a7.sol,GeneralTransferManager,contract GeneralTransferManager is ITransferManager { using SafeMath for uint256; address public issuanceAddress = address(0); address public signingAddress = address(0); bytes32 public constant WHITELIST = ; bytes32 public constant FLAGS = ; struct TimeRestriction { uint256 fromTime; uint256 toTime; uint256 expiryTime; bool canBuyFromSTO; },1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDView,"contract BitSTDView { BitSTDLogic private logic; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function balanceOf(address add)constant public returns (uint256) { return logic.balanceOf(add); }",1
0x0d5eae179709e92b3bff65731158e8291c49eafb.sol,GaintDex,"contract GaintDex is SafeMath { address public admin; address public feeAccount; uint public feeMake; uint public feeTake; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor() { admin = msg.sender; feeAccount = msg.sender; feeMake = 700000000000000; feeTake = 700000000000000; }",1
0x1c8654c680c3f18a3b3a0ee943d40848a9fffd0d.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; using SafeERC20 for ERC20; ERC20 public token; address public wallet; uint256 internal rate; uint256 public weiRaised; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); constructor(address _wallet, ERC20 _token) public { require(_wallet != address(0)); require(_token != address(0)); wallet = _wallet; token = _token; }",1
0x70cdbd16575651e3b78fa869a51eb8e991e079bb.sol,PRVTSToken,contract PRVTSToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 555000000 * (10**2); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function PRVTSToken () { owner = msg.sender; },1
0xedac0e5bedf702accc3a9b2b4b44b4ba0806e882.sol,DSStop,"contract DSStop is DSAuth, DSNote { bool public stopped; modifier stoppable { assert (!stopped); _; }",1
0xeda8b016efa8b1161208cf041cd86972eee0f31e.sol,BonusFinalizeAgent,"contract BonusFinalizeAgent is FinalizeAgent, SafeMathLib { CrowdsaleToken public token; Crowdsale public crowdsale; uint256 public allocatedTokens; uint256 tokenCap; address walletAddress; function BonusFinalizeAgent(CrowdsaleToken _token, Crowdsale _crowdsale, uint256 _tokenCap, address _walletAddress) public { token = _token; crowdsale = _crowdsale; require(address(crowdsale) != 0); tokenCap = _tokenCap; walletAddress = _walletAddress; }",1
0xb471c695dd5ea02035275d4b88077490c1e380ba.sol,ERC20x,"contract ERC20xVariables { address public creator; address public lib; uint256 constant public MAX_UINT256 = 2**256 - 1; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) public allowed; uint8 public constant decimals = 18; string public name; string public symbol; uint public totalSupply; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Created(address creator, uint supply); function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; }",1
0x4be8d9681891981e81bcfb61845483a68a6e1425.sol,ARTS,"contract ARTS is ERC223, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public initialSupply = 30e9 * 1e8; uint256 public totalSupply; uint256 public distributeAmount = 0; bool public mintingFinished = false; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintFinished(); function ARTS() public { totalSupply = initialSupply; balanceOf[msg.sender] = totalSupply; }",1
0xeb36a7650ef32f0643d39cf5b7fcefd4319febb9.sol,Cycle,contract Cycle { using SafeMath for uint; address public juryOperator; address public operator; address public icoAddress; address public juryOnlineWallet; address public projectWallet; address public arbitrationAddress; Token public token; address public jotter; bool public saveMe; struct Milestone { uint etherAmount; uint tokenAmount; uint startTime; uint finishTime; uint duration; string description; string result; },1
0x4cb200957a11cbff512b4752e6ee38c9253fdd54.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x0e6457a564fd6780b5a8512707a46c43f3a49ffc.sol,CupExchange,"contract CupExchange { using SafeMath for uint256; using SafeMath for int256; address public owner; token internal teamCup; token internal cup; uint256 public exchangePrice; bool public halting = true; event Halted(bool halting); event Exchange(address user, uint256 distributedAmount, uint256 collectedAmount); constructor(address cupToken, address teamCupToken) public { owner = msg.sender; teamCup = token(teamCupToken); cup = token(cupToken); }",1
0x3ad4fad3ce0509475e5b4f597c53cba38873cc46.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0xe3818504c1b32bf1557b16c238b2e01fd3149c17.sol,UnsoldAllocation,"contract UnsoldAllocation is Ownable { using SafeMath for uint; uint unlockedAt; uint allocatedTokens; PillarToken plr; mapping (address => uint) allocations; uint tokensCreated = 0; function UnsoldAllocation(uint _lockTime, address _owner, uint _tokens) { if(_lockTime == 0) throw; if(_owner == address(0)) throw; plr = PillarToken(msg.sender); uint lockTime = _lockTime * 1 years; unlockedAt = now.add(lockTime); allocatedTokens = _tokens; allocations[_owner] = _tokens; }",1
0xc3e43d422d5e6f94315622d96a96058689c52ec8.sol,BitNauticCrowdsaleTokenDistributor,"contract BitNauticCrowdsaleTokenDistributor is Ownable { using SafeMath for uint256; uint256 public constant ICOStartTime = 1531267200; uint256 public constant ICOEndTime = 1536969600; uint256 public teamSupply = 3000000 * 10 ** 18; uint256 public bountySupply = 2500000 * 10 ** 18; uint256 public reserveSupply = 5000000 * 10 ** 18; uint256 public advisorSupply = 2500000 * 10 ** 18; uint256 public founderSupply = 2000000 * 10 ** 18; MintableToken public token; BitNauticWhitelist public whitelist; BitNauticCrowdsale public crowdsale; mapping (address => bool) public hasClaimedTokens; constructor(MintableToken _token, BitNauticWhitelist _whitelist, BitNauticCrowdsale _crowdsale) public { token = _token; whitelist = _whitelist; crowdsale = _crowdsale; }",1
0x20009a909fb6f7951f594bc2daa69b5bd539d672.sol,MOOSToken,contract MOOSToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function MOOSToken () { owner = msg.sender; },1
0x01de9415d1ae14ab755186bea22923afe2934d82.sol,BitizenCarOperator,"contract BitizenCarOperator is Operator { event CreateCar(address indexed _owner, uint256 _carId); BitizenCarService internal carService; ERC721 internal ERC721Service; uint16 PER_USER_MAX_CAR_COUNT = 1; function injectCarService(BitizenCarService _service) public onlyOwner { carService = BitizenCarService(_service); ERC721Service = ERC721(_service); }",1
0x0267ee183beebdb7f931afe41e4e25352195b871.sol,BulleonToken,"contract BulleonToken is StandardBurnableToken, PausableToken, Claimable, CanReclaimToken { event AddedToWhitelist(address wallet); event RemoveWhitelist(address wallet); string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 constant exchangersBalance = 39991750231582759746295 + 14715165984103328399573 + 1846107707643607869274; address constant premineWallet = 0x286BE9799488cA4543399c2ec964e7184077711C; uint256 constant premineAmount = 178420 * (10 ** uint256(decimals)); address public CrowdsaleAddress; CrowdsaleContract crowdsale; mapping(address=>bool) whitelist; constructor() public { totalSupply_ = 7970000 * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; transfer(premineWallet, premineAmount.add(exchangersBalance)); addToWhitelist(msg.sender); addToWhitelist(premineWallet); paused = true; }",1
0x17cba58578eecaee898242a02edac75b8cc17231.sol,AUMXToken,"contract AUMXToken is ERC223, SafeMath{ mapping(address => mapping(address => uint)) allowed; mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 5000000000000000; bool locked; address Owner; address swapperAddress; function AUMXToken() public { locked = true; Owner = msg.sender; swapperAddress = msg.sender; balances[msg.sender] = totalSupply; allowed[msg.sender][swapperAddress] = totalSupply; }",1
0x728d52789bdcb8e4b76172c0120db8ef97914f64.sol,GameofGold,contract GameofGold { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x0f00f1696218eaefa2d2330df3d6d1f94813b38f.sol,SedoPoWToken,"contract SedoPoWToken is ERC20Interface, Owned { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; address public parentAddress; uint public miningReward; mapping(address => uint) balances; mapping(address => uint) merge_mint_ious; mapping(address => uint) merge_mint_payout_threshold; mapping(address => mapping(address => uint)) allowed; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); function SedoPoWToken() public onlyOwner{ symbol = ; name = ; decimals = 8; _totalSupply = 50000000 * 10**uint(decimals); if(locked) revert(); locked = true; tokensMinted = 1000000 * 10**uint(decimals); miningReward = 25; rewardEra = 0; maxSupplyForEra = _totalSupply.div(2); miningTarget = 2**220; latestDifficultyPeriodStarted = block.number; _startNewMiningEpoch(); parentAddress = 0x9D2Cc383E677292ed87f63586086CfF62a009010; balances[owner] = balances[owner].add(tokensMinted); Transfer(address(this), owner, tokensMinted); }",1
0x1784e5aec9ad99445663dbca9462a618bfe545ac.sol,NebliDex_AtomicSwap_ERC20,contract NebliDex_AtomicSwap_ERC20 { struct Swap { uint256 timelock; uint256 erc20Value; address erc20Trader; address erc20ContractAddress; address withdrawTrader; bytes32 secretLock; bytes secretKey; },1
0x174bb5d84b78e9e2248e7aa2c789aeba82f72f68.sol,LuckyTree,"contract LuckyTree is Owned, SafeMath{ uint public leafPrice; uint public gameStart; uint public gameDuration; uint public tokenLockDuration; uint public totalParticipationAmount; uint public totalLockedAmount; uint public numberOfLeafs; uint public participantIndex; bool public fundsTransfered; address public winner; mapping(uint => address) public participants; mapping(uint => uint) public participationAmount; mapping(address => bool) public hasParticipated; mapping(address => bool) public hasWithdrawn; mapping(address => uint) public participantIndexes; mapping(uint => address) public leafOwners; event GameWinner(address winner); event GameEnded(uint block); event GameStarted(uint block); event GameFailed(uint block); event GameLocked(uint block); event GameUnlocked(uint block); enum state{ pending, running, paused, finished, closed, claimed }",1
0x02c11f38bec96eb38c4dc2bcc8d669ae676fd7a9.sol,AirDrop,"contract AirDrop is Ownable { using SafeMath for uint256; uint public airDropAmount; mapping ( address => bool ) public invalidAirDrop; address[] public arrayAirDropReceivers; bool public stop = false; ERC20BasicInterface public erc20; uint256 public startTime; uint256 public endTime; event LogAirDrop(address indexed receiver, uint amount); event LogStop(); event LogStart(); event LogWithdrawal(address indexed receiver, uint amount); constructor(uint256 _startTime, uint256 _endTime, uint _airDropAmount, address _tokenAddress) public { require(_startTime >= now && _endTime >= _startTime && _airDropAmount > 0 && _tokenAddress != address(0) ); startTime = _startTime; endTime = _endTime; erc20 = ERC20BasicInterface(_tokenAddress); uint tokenDecimals = erc20.decimals(); airDropAmount = _airDropAmount.mul(10 ** tokenDecimals); }",1
0x3fd7332ea471e876327926b30bd945773c706133.sol,EtherShrimpFutures,contract EtherShrimpFutures{ using SafeMath for uint; Oasis market; address public dai = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359; address public weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; uint256 public EGGS_TO_HATCH_1SHRIMP=86400; uint256 public STARTING_SHRIMP=300; uint256 internal PSN=10000; uint256 internal PSNH=5000; bool public initialized=false; uint256 public marketEggs; address public ceoAddress; uint256 public numberOfFarmers; mapping (address => uint256) public hatcheryShrimp; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; mapping (address => uint256) public lastHatchPrice; address[] farmers; constructor() public{ ceoAddress=msg.sender; market = Oasis(0x14FBCA95be7e99C15Cc2996c6C9d841e54B79425); },1
0xa5b1685b23db36859611cac03e0c68daf0e3c0a1.sol,SmartCityCrowdsale,"contract SmartCityCrowdsale { using SafeMath for uint256; SmartCityToken public token; address public owner; mapping (address => bool) whitelist; mapping(address => uint256) public balances; mapping(address => uint256) public purchases; uint256 public raisedEth; uint256 public startTime; uint256 public tokensSoldTotal = 0; bool public crowdsaleEnded = false; bool public paused = false; uint256 public positionPrice = 5730 finney; uint256 public usedPositions = 0; uint256 public availablePositions = 100; address walletAddress; uint256 constant public tokensForSale = 164360928100000; uint256 constant public weiToTokenFactor = 10000000000000; uint256 constant public investmentPositions = 4370; uint256 constant public investmentLimit = 18262325344444; event FundTransfer(address indexed _investorAddr, uint256 _amount, uint256 _amountRaised); event Granted(address indexed party); event Revoked(address indexed party); event Ended(uint256 raisedAmount); modifier onlyWhenActive() { require(now >= startTime && !crowdsaleEnded && !paused); _; }",1
0xc4cbb8a3117f0738330fa139ca8ffbb13e8932fc.sol,CrowdsaleCompatible,"contract CrowdsaleCompatible is BasicERC20, Ownable { BasicCrowdsale public crowdsale = BasicCrowdsale(0x0); function unfreezeTokens() public { assert(now > crowdsale.endTime()); isTokenTransferable = true; }",1
0xc849a5fff9befa297d1c3a772bafac9f3c9004ec.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x70c86655abce9db09c075d07b4eb11d4fa63cc8b.sol,StreamityTariff,contract StreamityTariff is Ownable { using ECRecovery for bytes32; uint8 constant public EMPTY = 0x0; TokenERC20 public streamityContractAddress; mapping(bytes32 => Deal) public stmTransfers; function StreamityTariff(address streamityContract) public { require(streamityContract != 0x0); streamityContractAddress = TokenERC20(streamityContract); },1
0x17a03553719001e05dc19a20f5e82ee76923a985.sol,Auction,contract AuctionBase is ERC721Holder { using SafeMath for uint256; struct Auction { address seller; uint128 price; uint64 startedAt; },1
0x4c7f666ca30fe548fbdc08b0308927327f08336d.sol,FixedPoolWithBonusTokenDistributionStrategy,contract FixedPoolWithBonusTokenDistributionStrategy is TokenDistributionStrategy { using SafeMath for uint256; uint256 constant MAX_DISCOUNT = 100; struct BonusInterval { uint256 endPeriod; uint256 bonus; },1
0x9297a9d824e2f2d6f2dff2b871cb9e2f3f4f77d2.sol,RegistryUpdater,contract RegistryUpdater is Ownable { address public polymathRegistry; address public moduleRegistry; address public securityTokenRegistry; address public tickerRegistry; address public polyToken; constructor (address _polymathRegistry) public { require(_polymathRegistry != address(0)); polymathRegistry = _polymathRegistry; },1
0xc574fc434cb74344eaafe8bcc69ab1b12dbc01d8.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; token myToken; address public wallet; uint256 public rate = 1000000000 ; uint256 public weiRaised; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); constructor(address tokenContractAddress, address _walletAddress) public{ wallet = _walletAddress; myToken = token(tokenContractAddress); }",1
0x4802fe0bf7eb3b3b0dce3ede89c575341f10e3e0.sol,SynergisProxyDeposit,"contract SynergisProxyDeposit is Ownable { using SafeMath for uint256; enum Role {Fund, Team, Adviser}",1
0x1f10822c753a1f587923d9916e64738ee7c27419.sol,GPHToken,contract GPHToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 500000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function GPHToken () { owner = msg.sender; },1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiCrowdSale,"contract NamiCrowdSale { using SafeMath for uint256; function NamiCrowdSale(address _escrow, address _namiMultiSigWallet, address _namiPresale) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; namiPresale = _namiPresale; }",1
0x03358425ada4620246dd703dc1f2246b8e148d22.sol,BoomerangLiquidity,contract BoomerangLiquidity is Owned { modifier onlyOwner(){ require(msg.sender == owner); _; },1
0x91ca47b9ec3187c77f324281a1851f4b991103f1.sol,FundingInputGeneral,"contract FundingInputGeneral { bool public initialized = false; uint8 public typeId = 0; address public FundingAssetAddress; address public deployer; event EventInputPaymentReceived(address sender, uint amount, uint8 _type); function FundingInputGeneral() public { deployer = msg.sender; }",1
0x3420894bf786866a09937b0369d5b4781870c21f.sol,LikeCoin,"contract LikeCoin is ERC20, HasOperator { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public supply = 0; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; address public crowdsaleAddr = 0x0; address public contributorPoolAddr = 0x0; uint256 public contributorPoolMintQuota = 0; address[] public creatorsPoolAddrs; mapping(address => bool) isCreatorsPool; uint256 public creatorsPoolMintQuota = 0; mapping(address => uint256) public lockedBalances; uint public unlockTime = 0; SignatureChecker public signatureChecker = SignatureChecker(0x0); bool public signatureCheckerFreezed = false; address public signatureOwner = 0x0; bool public allowDelegate = true; mapping (address => mapping (uint256 => bool)) public usedNonce; mapping (address => bool) public transferAndCallWhitelist; event Lock(address indexed _addr, uint256 _value); event SignatureCheckerChanged(address _newSignatureChecker); function LikeCoin(uint256 _initialSupply, address _signatureOwner, address _sigCheckerAddr) public { supply = _initialSupply; balances[owner] = _initialSupply; signatureOwner = _signatureOwner; signatureChecker = SignatureChecker(_sigCheckerAddr); Transfer(0x0, owner, _initialSupply); }",1
0xbc97f1508fdeb0a63b25f3a4806b62ef5370e8ab.sol,CryptoBeginnerQuest,contract CryptoBeginnerQuest { using SafeMath for uint256; address private administrator; address public miningWarAddress; CryptoEngineerInterface public Engineer; CryptoDepositInterface public Deposit; CryptoMiningWarInterface public MiningWar; CryptoAirdropGameInterface public AirdropGame; CryptoBossWannaCryInterface public BossWannaCry; CryptoArenaInterface public Arena; uint256 private miningWarDeadline; uint256 private miningWarRound; mapping(address => Player) private players; mapping(address => MinerQuest) private minerQuests; mapping(address => EngineerQuest) private engineerQuests; mapping(address => DepositQuest) private depositQuests; mapping(address => JoinAirdropQuest) private joinAirdropQuests; mapping(address => AtkBossQuest) private atkBossQuests; mapping(address => AtkPlayerQuest) private atkPlayerQuests; mapping(address => BoosterQuest) private boosterQuests; mapping(address => RedbullQuest) private redbullQuests; struct Player { uint256 miningWarRound; uint256 currentQuest; },1
0xf1add8bf553d0066be17768d6816f3730c476237.sol,EasySmartolution,"contract EasySmartolution { address constant smartolution = 0xe0ae35fe7Df8b86eF08557b535B89bB6cb036C23; event ParticipantAdded(address _sender); event ParticipantRemoved(address _sender); event ReferrerAdded(address _contract, address _sender); mapping (address => address) public participants; mapping (address => bool) public referrers; address private processing; constructor(address _processing) public { processing = _processing; }",1
0x3a266f97425cd281c1770b71662fcf4415c29190.sol,CryptoProgramFactory,contract CryptoProgramFactory { bool status = false; using SafeMath for uint256; address public administrator; uint256 private BASE_PRICE = 0.1 ether; uint256 private BASE_TIME = 4 hours; MemoryFactoryInterface public Memory; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; mapping(uint256 => Factory) public factories; mapping(address => bool) public miniGames; struct Factory { uint256 level; uint256 crystals; uint256 programPriceByCrystals; uint256 programPriceByDarkCrystals; uint256 programValue; uint256 eth; uint256 time; },1
0xf508548ef0ef6472760a36e15169b847ae427d38.sol,CrowdsaleCompatible,"contract CrowdsaleCompatible is BasicERC20, Ownable { BasicCrowdsale public crowdsale = BasicCrowdsale(0x0); function unfreezeTokens() public { assert(now > crowdsale.endTime()); isTokenTransferable = true; }",1
0x6e9aa27afa93a52b219a3f091c7d600ad32dcc7c.sol,ADTSend1,"contract ADTSend1 { Token public token; event TransferToken(address indexed to, uint256 value); event TransferFromToken(address indexed from,address indexed to, uint256 value); uint i=0; uint256 samount=0; function adTransfer(address source, address[] recipents, uint256[] amount,uint decimals) public { token=Token(source); for(i=0;i<recipents.length;i++) { samount=amount[i]; token.transfer(recipents[i],amount[i]*(10**decimals)); emit TransferToken(recipents[i],samount); }",1
0xeb86a173e0311a28cadc24f85dbad867bbf34f73.sol,Bussiness,contract Bussiness is Ownable { address public ceoAddress = address(0x6c3e879bdd20e9686cfd9bbd1bfd4b2dd6d47079); IERC721 public erc721Address = IERC721(0xdceaf1652a131f32a821468dc03a92df0edd86ea); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdac17f958d2ee523a2206206994597c13d831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; constructor() public {},1
0x5ab793e36070f0fac928ea15826b0c1bc5365119.sol,YUKI,"contract YUKI is ERC223, Ownable, Pausable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 20e9 * 1e8; uint256 public codeSize = 0; bool public mintingFinished = false; address public initialMarketSales = 0x1b879912446d844Fb5915bf4f773F0Db9Cd16ADb; address public incentiveForHolder = 0x0908e3Df5Ed1E67D2AaF38401d4826B2879e8f4b; address public developmentFunds = 0x52F018dc3dd621c8b2D649AC0e22E271a0dE049e; address public marketingFunds = 0x6771a091C97c79a52c8DD5d98A59c5d3B27F99aA; address public organization = 0xD90E1f987252b8EA71ac1cF14465FE9A3803267F; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public cannotSend; mapping (address => bool) public cannotReceive; mapping (address => uint256) public cannotSendUntil; mapping (address => uint256) public cannotReceiveUntil; event FrozenFunds(address indexed target, bool cannotSend, bool cannotReceive); event LockedFunds(address indexed target, uint256 cannotSendUntil, uint256 cannotReceiveUntil); event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintFinished(); constructor() public { owner = msg.sender; balanceOf[initialMarketSales] = totalSupply.mul(45).div(100); balanceOf[incentiveForHolder] = totalSupply.mul(5).div(100); balanceOf[developmentFunds] = totalSupply.mul(20).div(100); balanceOf[marketingFunds] = totalSupply.mul(175).div(1000); balanceOf[organization] = totalSupply.mul(125).div(1000); }",1
0x8d4b2cffe2dcbbf06eaa5920401db86ca5fb8177.sol,SelfKeyCrowdsale,"contract SelfKeyCrowdsale is Ownable, CrowdsaleConfig { using SafeMath for uint256; using SafeERC20 for SelfKeyToken; mapping(address => bool) public isVerifier; SelfKeyToken public token; uint64 public startTime; uint64 public endTime; uint256 public goal; uint256 public rate = 51800; uint256 public ethPrice = 777; uint256 public totalPurchased = 0; mapping(address => bool) public kycVerified; mapping(address => uint256) public tokensPurchased; mapping(address => address) public vestedTokens; bool public isFinalized = false; TokenTimelock public foundersTimelock1; TokenTimelock public foundersTimelock2; TokenTimelock public foundationTimelock; RefundVault public vault; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); event VerifiedKYC(address indexed participant); event AddedPrecommitment( address indexed participant, uint256 tokensAllocated ); event Finalized(); modifier verifierOnly() { require(isVerifier[msg.sender]); _; }",1
0x5c743a35e903f6c584514ec617acee0611cf44f3.sol,ERC223Token,"contract ERC223Token { using SafeMath for uint256; string public name; bytes32 public symbol; uint8 public decimals; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping (address => mapping(address => uint256)) internal allowances; function transfer(address to, uint256 value, bytes data) public returns (bool) { require(balanceOf[msg.sender] >= value); uint256 codeLength; assembly { codeLength := extcodesize(to) }",1
0xf1afddbed214dba82cb98d46ad0a96e643f7f6f6.sol,StarbaseEarlyPurchaseAmendment,contract StarbaseEarlyPurchaseAmendment { event EarlyPurchaseInvalidated(uint256 epIdx); event EarlyPurchaseAmended(uint256 epIdx); AbstractStarbaseCrowdsale public starbaseCrowdsale; StarbaseEarlyPurchase public starbaseEarlyPurchase; address public owner; uint256[] public invalidEarlyPurchaseIndexes; uint256[] public amendedEarlyPurchaseIndexes; mapping (uint256 => StarbaseEarlyPurchase.EarlyPurchase) public amendedEarlyPurchases; modifier noEther() { require(msg.value == 0); _; },1
0x655f1cb6616d7f0550007498113e72d7d5c5d4bb.sol,MedalClaim,"contract MedalClaim is AccessControl, SafeMath { address public angelCardDataContract = 0x6D2E76213615925c5fc436565B5ee788Ee0E86DC; address public petCardDataContract = 0xB340686da996b8B3d486b4D27E38E38500A9E926; address public accessoryDataContract = 0x466c44812835f57b736ef9F63582b8a6693A14D0; address public leaderboardDataContract = 0x9A1C755305c6fbf361B4856c9b6b6Bbfe3aCE738; address public medalDataContract = 0x33A104dCBEd81961701900c06fD14587C908EAa3; event EventMedalSuccessful(address owner,uint64 Medal); struct Angel { uint64 angelId; uint8 angelCardSeriesId; address owner; uint16 battlePower; uint8 aura; uint16 experience; }",1
0x1a661224edc279a3844ecd8bd0cd715daafb9cf7.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 27820800; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x7eB71add7482F3462BAA46328f58a235E33dbD0e; }",1
0x479cbe1f6a7fa4d7e304ae983803c46e85ced870.sol,Slaughter3D,contract Slaughter3D { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0x4be8d9681891981e81bcfb61845483a68a6e1425.sol,ARTS,"contract ARTS is ERC223, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public initialSupply = 30e9 * 1e8; uint256 public totalSupply; uint256 public distributeAmount = 0; bool public mintingFinished = false; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintFinished(); function ARTS() public { totalSupply = initialSupply; balanceOf[msg.sender] = totalSupply; }",1
0x0f00f1696218eaefa2d2330df3d6d1f94813b38f.sol,SedoPoWToken,"contract SedoPoWToken is ERC20Interface, Owned { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; address public parentAddress; uint public miningReward; mapping(address => uint) balances; mapping(address => uint) merge_mint_ious; mapping(address => uint) merge_mint_payout_threshold; mapping(address => mapping(address => uint)) allowed; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); function SedoPoWToken() public onlyOwner{ symbol = ; name = ; decimals = 8; _totalSupply = 50000000 * 10**uint(decimals); if(locked) revert(); locked = true; tokensMinted = 1000000 * 10**uint(decimals); miningReward = 25; rewardEra = 0; maxSupplyForEra = _totalSupply.div(2); miningTarget = 2**220; latestDifficultyPeriodStarted = block.number; _startNewMiningEpoch(); parentAddress = 0x9D2Cc383E677292ed87f63586086CfF62a009010; balances[owner] = balances[owner].add(tokensMinted); Transfer(address(this), owner, tokensMinted); }",1
0x56853ab9006e0712b05c68b586372fcdde5236b9.sol,AirDrop,"contract AirDrop is Ownable { Token token; event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); modifier whenDropIsActive() { assert(isActive()); _; }",1
0x707f0612cbbfa02284e02b0010b4f859bb7308ec.sol,CrowdsaleL,"contract CrowdsaleL{ using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x271a0b465d5b453bb835afd2d671c76b2b76900e.sol,ClockAuctionBase,"contract ClockAuctionBase is Withdrawable, Pausable { struct Auction { address _contract; address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; }",1
0x536c7efeebff067a69393133b1c87a163a6b0598.sol,ECM,"contract ECMinterface { function ECMFallback(address _from, uint _value, uint _code); }",1
0x2898ca01df2dc4062e8b269806de4996295a1f5c.sol,SaleAuction,contract SaleAuction is AuctionBase { address public beneficiary = msg.sender; function SaleAuction(address _nftAddress) public { ERC721 candidateContract = ERC721(_nftAddress); nonFungibleContract = candidateContract; },1
0xcefa3e88393cf17c9b4dc6c9fe5357dfae8036d6.sol,Hold,"contract Hold is Ownable { uint8 stages = 5; uint8 public percentage; uint8 public currentStage; uint public initialBalance; uint public withdrawed; address public multisig; Registry registry; PermissionManager public permissionManager; uint nextContributorToTransferEth; address public observer; uint dateDeployed; mapping(address => bool) private hasWithdrawedEth; event InitialBalanceChanged(uint balance); event EthReleased(uint ethreleased); event EthRefunded(address contributor, uint ethrefunded); event StageChanged(uint8 newStage); event EthReturnedToOwner(address owner, uint balance); modifier onlyPermitted() { require(permissionManager.isPermitted(msg.sender) || msg.sender == owner); _; }",1
0x4d0dc912fcad3b070d187ab8ac89e63d2b532b8a.sol,BliBliToken,"contract BliBliToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 625; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0x1860d43a2a1b9b03907eb6a6b92ce256694dd315.sol,NescrowExchangeService,contract NescrowExchangeService { address owner = msg.sender; uint256 public feeRateLimit = 200; uint256 public takerFeeRate = 0; uint256 public makerFeeRate = 0; address public feeAddress; mapping (address => bool) public admins; mapping (bytes32 => uint256) public orderFills; mapping (bytes32 => uint256) public orderPaymentFills; mapping (bytes32 => bool) public withdrawn; mapping (bytes32 => bool) public transfers; mapping (address => mapping (address => uint256)) public balances; mapping (address => uint256) public tradesLocked; mapping (address => uint256) public disableFees; mapping (address => uint256) public tokenDecimals; mapping (address => bool) public tokenRegistered; struct EIP712Domain { string name; string version; uint256 chainId; address verifyingContract; },1
0xdcf67546f2253c9c90c2b55447e1efecebcf83d6.sol,HorseyToken,"contract HorseyToken is EthorseHelpers,Pausable { event Claimed(address raceAddress, address eth_address, uint256 tokenId); event Feeding(uint256 tokenId); event ReceivedCarrot(uint256 tokenId, bytes32 newDna); event FeedingFailed(uint256 tokenId); event HorseyRenamed(uint256 tokenId, string newName); event HorseyFreed(uint256 tokenId); RoyalStablesInterface public stables; uint8 public carrotsMultiplier = 1; uint8 public rarityMultiplier = 1; uint256 public claimingFee = 0.000 ether; struct FeedingData { uint256 blockNumber; uint256 horsey; }",1
0x18da8521c333aed9de8f512e847734cb7be42e38.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0x25cf23787ac0f92a3eafa61f458ad0b7c4b27c3d.sol,Zethroll,"contract Zethroll is ZTHReceivingContract { using SafeMath for uint; modifier betIsValid(uint _betSize, uint _playerNumber) { require( calculateProfit(_betSize, _playerNumber) < maxProfit && _betSize >= minBet && _playerNumber > minNumber && _playerNumber < maxNumber); _; }",1
0x3a630495c7611b4da41bf133554374caa3963b75.sol,CryptoPornstarAward,"contract CryptoPornstarAward is PornSceneToken{ event Award(uint256 currentAwardWinner, uint32 awardTime); uint nonce = 0; uint cooldownTime = 60; uint32 awardTime = uint32(now); function _triggerCooldown() internal { awardTime = uint32(now + cooldownTime); }",1
0x4900320fe47208de0b79db1273a78ab8c8f3528d.sol,Crowdsale,contract Crowdsale is Owned { using SafeMath for uint256; uint256 public fundingGoal; uint256 public price; uint256 public transferableToken; uint256 public soldToken; uint256 public deadline; uint256 public token_price; MontexToken public tokenReward; bool public fundingGoalReached = false; bool public isOpened; mapping (address => Property) public fundersProperty; struct Property { uint256 paymentEther; uint256 reservedToken; },1
0x485b224c97ad56dc5b145eafdee71a7b5163f735.sol,PonziBet,contract PonziBet { using SafeMath for uint; EthPyramid public pyramid; address public admin; address public contractAddress; uint public minBet; uint public roundTime; uint public startPrice; uint public endPrice; uint[] public upBetRecords; uint[] public downBetRecords; mapping (address => uint) lastBet; mapping (address => bool) userBet; mapping (bool => uint) totalBalance; mapping (address => uint) feeBalance; mapping (address => mapping (bool => uint)) userBalances; function PonziBet() public { admin = msg.sender; },1
0x330bebabc9a2a4136e3d1cb38ca521f5a95aec2e.sol,KoreaShow,"contract KoreaShow is TokenController, Controlled { using SafeMath for uint256; uint256 public startFundingTime; uint256 public endFundingTime; uint256 constant public maximumFunding = 100 ether; uint256 public tokensPerEther = 31000; uint256 constant oneDay = 86400; uint256 public totalCollected = 0; bool public paused; string public techProvider = ; Token public tokenContract; bool public finalized = false; bool public allowChange = true; bool private transfersEnabled = true; address private vaultAddress; bool private initialed = false; event Payment(address indexed _sender, uint256 _ethAmount, uint256 _tokenAmount); function KoreaShow( uint _startFundingTime, uint _endFundingTime, address _vaultAddress, address _tokenAddress ) public { require(_endFundingTime > now); require(_endFundingTime >= _startFundingTime); require(_vaultAddress != 0); require(_tokenAddress != 0); require(!initialed); startFundingTime = _startFundingTime; endFundingTime = _endFundingTime; vaultAddress = _vaultAddress; tokenContract = Token(_tokenAddress); paused = false; initialed = true; }",1
0xa304100e0d17a972f34ed8a961034ce2fc47f9ca.sol,FomoBet,contract FomoBet { using SafeMath for uint; struct bet { address maker; address taker; uint256 round; bool longOrShort; bool validated; uint256 betEnd; uint256 betSize; },1
0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0.sol,Play0x_LottoBall,contract Play0x_LottoBall { using SafeMath for uint256; using SafeMath for uint128; using SafeMath for uint40; using SafeMath for uint8; uint public jackpotSize; uint public tokenJackpotSize; uint public MIN_BET; uint public MAX_BET; uint public MAX_AMOUNT; uint public maxProfit; uint public maxTokenProfit; uint8 public platformFeePercentage = 15; uint8 public jackpotFeePercentage = 5; uint8 public ERC20rewardMultiple = 5; uint constant BetExpirationBlocks = 250; uint public lockedInBets; uint public lockedTokenInBets; bytes32 bitComparisonMask = 0xF; address public owner; address private nextOwner; address public manager; address private nextManager; address[] public secretSignerList; address public ERC20ContractAddres; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Bet { uint amount; uint40 placeBlockNumber; address gambler; },1
0x1cca91a47db357445b89269f2fb4f647cd209968.sol,Distribution,"contract Distribution is Owned { using SafeMath for uint256; Token token; event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); modifier whenDropIsActive() { assert(isActive()); _; }",1
0x269b4c23ddab676e2869ae72cd6ae4f24bdfea45.sol,IRBPreCrowdsale,"contract IRBPreCrowdsale is Ownable, Pausable { using SafeMath for uint; IRBToken public token; IRBPreRefundVault public vault; uint startTime = 1513065600; uint endTime = 1515963599; uint256 public constant minPresaleAmount = 108 * 10 ** 15; uint256 public constant goal = 1125 * 10 ** 18; uint256 public constant cap = 2250 * 10 ** 18; uint256 public weiRaised; bool public isFinalized = false; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event Finalized(); function IRBPreCrowdsale(address _tokenAddress, address _vaultAddress) { require(_tokenAddress != address(0)); require(_vaultAddress != address(0)); token = IRBToken(_tokenAddress); vault = IRBPreRefundVault(_vaultAddress); }",1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ClockAuction,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0xbc97f1508fdeb0a63b25f3a4806b62ef5370e8ab.sol,CryptoBeginnerQuest,contract CryptoBeginnerQuest { using SafeMath for uint256; address private administrator; address public miningWarAddress; CryptoEngineerInterface public Engineer; CryptoDepositInterface public Deposit; CryptoMiningWarInterface public MiningWar; CryptoAirdropGameInterface public AirdropGame; CryptoBossWannaCryInterface public BossWannaCry; CryptoArenaInterface public Arena; uint256 private miningWarDeadline; uint256 private miningWarRound; mapping(address => Player) private players; mapping(address => MinerQuest) private minerQuests; mapping(address => EngineerQuest) private engineerQuests; mapping(address => DepositQuest) private depositQuests; mapping(address => JoinAirdropQuest) private joinAirdropQuests; mapping(address => AtkBossQuest) private atkBossQuests; mapping(address => AtkPlayerQuest) private atkPlayerQuests; mapping(address => BoosterQuest) private boosterQuests; mapping(address => RedbullQuest) private redbullQuests; struct Player { uint256 miningWarRound; uint256 currentQuest; },1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDView,"contract BitSTDView { BitSTDLogic private logic; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function balanceOf(address add)constant public returns (uint256) { return logic.balanceOf(add); }",1
0xa304100e0d17a972f34ed8a961034ce2fc47f9ca.sol,FomoBet,contract FomoBet { using SafeMath for uint; struct bet { address maker; address taker; uint256 round; bool longOrShort; bool validated; uint256 betEnd; uint256 betSize; },1
0xf244176246168f24e3187f7288edbca29267739b.sol,Havven,"contract HavvenEscrow is Owned, LimitedSetup(8 weeks), SafeDecimalMath { Havven public havven; mapping(address => uint[2][]) public vestingSchedules; mapping(address => uint) public totalVestedAccountBalance; uint public totalVestedBalance; function HavvenEscrow(address _owner, Havven _havven) Owned(_owner) public { havven = _havven; }",1
0x0e69d0a2bbb30abcb7e5cfea0e4fde19c00a8d47.sol,ContractLock,"contract ContractLock is DSStop { uint public unlockTime; mapping (address => bool) public isAdmin; event LogAddAdmin(address whoAdded, address newAdmin); event LogRemoveAdmin(address whoRemoved, address admin); constructor(uint _unlockTime) public { unlockTime = _unlockTime; isAdmin[msg.sender] = true; emit LogAddAdmin(msg.sender, msg.sender); }",1
0x01d28329619796bae733e849696f80a764422700.sol,BaseTokenSale,"contract BaseTokenSale is TokenController, Controlled { using SafeMath for uint256; uint256 public startFundingTime; uint256 public endFundingTime; uint256 constant public maximumFunding = 1951 ether; uint256 public maxFunding; uint256 public minFunding = 0.001 ether; uint256 public tokensPerEther = 41000; uint256 constant public maxGasPrice = 50000000000; uint256 constant oneDay = 86400; uint256 public totalCollected = 0; bool public paused; Token public tokenContract; bool public finalized = false; bool public allowChange = true; bool private transfersEnabled = true; address private vaultAddress; bool private initialed = false; event Payment(address indexed _sender, uint256 _ethAmount, uint256 _tokenAmount); function BaseTokenSale( uint _startFundingTime, uint _endFundingTime, address _vaultAddress, address _tokenAddress ) public { require(_endFundingTime > now); require(_endFundingTime >= _startFundingTime); require(_vaultAddress != 0); require(_tokenAddress != 0); require(!initialed); startFundingTime = _startFundingTime; endFundingTime = _endFundingTime; vaultAddress = _vaultAddress; tokenContract = Token(_tokenAddress); paused = false; initialed = true; }",1
0x7868fc162988289062dbcdb670a3cf6c8da66f84.sol,CDMarketplace,contract CDMarketplace is Ownable { bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba; address public wallet; uint256 public fee_percentage; ERC721Basic public token; address public manager; address internal checkAndBuySender; address public TVTokenAddress; address public TVCrowdsaleAddress; bytes4 constant TOKEN_RECEIVED = bytes4(keccak256()); modifier onlyOwnerOrManager() { require(msg.sender == owner || manager == msg.sender); _; },1
0xbd3476e32de1077e049d0c4767c650230be38bda.sol,Airdrop,"contract Airdrop is Ownable, Destroyable { using SafeMath for uint256; struct Beneficiary { uint256 balance; uint256 airdrop; bool isBeneficiary; }",1
0x26fb86579e371c7aedc461b2ddef0a8628c93d3b.sol,LockedToken,"contract LockedToken { ERC20Basic public token; address public donor; address public beneficiary; uint256 public releaseTime; bool public revocable; event Claim(address beneficiary, uint256 amount, uint256 releaseTime); event Revoke(address donor, uint256 amount); function LockedToken(ERC20Basic _token, address _donor, address _beneficiary, uint256 _releaseTime, bool _revocable) public { require(_token != address(0)); require(_donor != address(0)); require(_beneficiary != address(0)); require(_releaseTime > now); token = ERC20Basic(_token); donor = _donor; beneficiary = _beneficiary; releaseTime = _releaseTime; revocable = _revocable; }",1
0xec8f9a0de90487e7aa172fe5291fd19ad7163aa1.sol,BDSMAirdrop,contract BDSMAirdrop { token public sharesTokenAddress; uint256 public tokenFree = 0; address owner; uint256 public defValue = 5000000; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x52c52944eaac353f054902225e1df036589fb6d7.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public wallet; address addressOfTokenUsedAsReward; token tokenReward; uint256 public startTime; uint256 public endTime; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() { wallet = 0x205E2ACd291E235425b5c10feC8F62FE7Ec26063; addressOfTokenUsedAsReward = 0x82B99C8a12B6Ee50191B9B2a03B9c7AEF663D527; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x6b4df2aa3d64d8dc06120ef4391513e4170af4a7.sol,GeneralTransferManager,contract GeneralTransferManager is ITransferManager { using SafeMath for uint256; address public issuanceAddress = address(0); address public signingAddress = address(0); bytes32 public constant WHITELIST = ; bytes32 public constant FLAGS = ; struct TimeRestriction { uint256 fromTime; uint256 toTime; uint256 expiryTime; bool canBuyFromSTO; },1
0x56c945f90c9cd1aafbcac78936f569e5fd2438bf.sol,HeroUp,"contract HeroUp is Ownable, CanReclaimToken { event HeroUpgraded(uint tokenId, address owner); HEROES_OLD public heroesOld; HEROES_NEW public heroesNew; constructor (HEROES_OLD _heroesOld, HEROES_NEW _heroesNew) public { require(address(_heroesOld) != address(0)); require(address(_heroesNew) != address(0)); heroesOld = _heroesOld; heroesNew = _heroesNew; }",1
0x37e343f2cc245754595f1ae3656b460c35d636fb.sol,BalanceManager,contract BalanceManager is Serverable { mapping(uint32 => uint64) public balances; mapping(uint32 => uint64) public blockedBalances; mapping(address => uint64) public walletBalances; mapping(address => uint32) public userIds; address public dispatcher; uint serviceReward; uint sentBonuses; ERC223 public gameToken; modifier onlyDispatcher() {require(msg.sender == dispatcher); _;},1
0x0f067ddb0795a7627c18a5792ed0a2199de3a8c2.sol,HUMPresale,"contract HUMPresale is WhitelistedCrowdsale, IndividuallyCappedCrowdsale { uint256 public constant minimum = 100000000000000000; bool public isOnSale = false; mapping(address => uint256) public bonusTokens; uint256 public bonusPercent; address[] public contributors; event DistrubuteBonusTokens(address indexed sender); event Withdraw(address indexed _from, uint256 _amount); constructor ( uint256 _rate, uint256 _bonusPercent, address _wallet, HUMToken _token, uint256 _individualCapEther ) public Crowdsale(_rate, _wallet, _token) IndividuallyCappedCrowdsale(_individualCapEther.mul(10 ** 18)) { bonusPercent = _bonusPercent; }",1
0x17a03553719001e05dc19a20f5e82ee76923a985.sol,Auction,contract AuctionBase is ERC721Holder { using SafeMath for uint256; struct Auction { address seller; uint128 price; uint64 startedAt; },1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiCrowdSale,"contract NamiCrowdSale { using SafeMath for uint256; function NamiCrowdSale(address _escrow, address _namiMultiSigWallet, address _namiPresale) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; namiPresale = _namiPresale; }",1
0x48ec79ffdd733e72046533baafcc19864a976da0.sol,Richer3D,"contract Richer3D { using SafeMath for *; string constant public name = ; string constant public symbol = ; address constant private sysAdminAddress = 0x4A3913ce9e8882b418a0Be5A43d2C319c3F0a7Bd; address constant private sysInviterAddress = 0xC5E41EC7fa56C0656Bc6d7371a8706Eb9dfcBF61; address constant private sysDevelopAddress = 0xCf3A25b73A493F96C15c8198319F0218aE8cAA4A; address constant private p3dInviterAddress = 0x82Fc4514968b0c5FdDfA97ed005A01843d0E117d; uint256 constant cycleTime = 20 minutes; uint256 private roundNumber; uint256 private dayNumber; uint256 private totalPlayerNumber; uint256 private platformBalance; mapping(uint256=>DataModal.RoundInfo) private rInfoXrID; mapping(address=>DataModal.PlayerInfo) private pInfoXpAdd; mapping(address=>uint256) private pIDXpAdd; mapping(uint256=>address) private pAddXpID; HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe); mapping(uint256=>uint256) private p3dDividesXroundID; event newPlayerJoinGameEvent(address indexed _address,uint256 indexed _amount,bool indexed _JoinWithEth,uint256 _timestamp); event calculateTargetEvent(uint256 indexed _roundID); constructor() public { dayNumber = 1; }",1
0x5c28d0683be8143e5ecdd5fd0b39d702d98b1bb9.sol,TemplateCrowdsale,"contract TemplateCrowdsale is Consts, MainCrowdsale , BonusableCrowdsale { event Initialized(); event TimesChanged(uint startTime, uint endTime, uint oldStartTime, uint oldEndTime); bool public initialized = false; constructor(MintableToken _token) public Crowdsale(9000 * TOKEN_DECIMAL_MULTIPLIER, 0xFB262Fe4620e7027424488F6C471b13DE7662A95, _token) TimedCrowdsale(START_TIME > now ? START_TIME : now, 1568917800) CappedCrowdsale(111111111111111111111111) { }",1
0xc7740d000d9931769291da0352bbe7c6b27bc97d.sol,HasNoTokens,"contract HasNoTokens is Ownable { event ExtractedTokens(address indexed _token, address indexed _claimer, uint _amount); function extractTokens(address _token, address _claimer) onlyOwner public { if (_token == 0x0) { _claimer.transfer(this.balance); return; }",1
0x3a715f7ee68d8d7b105f9cabd972f76cb8ea0710.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 30153600; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x5555A8C016F5D2948e27BAe7633Deea24b552FC1; }",1
0xb462d45329f4f3b4c670790ac355fb26eace41c8.sol,TokenVesting,"contract TokenVesting is Ownable { using SafeMath for uint256; using SafeERC20 for ERC20; event Released(uint256 amount); event Revoked(); address public beneficiary; uint256 public cliff; uint256 public start; uint256 public duration; bool public revocable; bool public revoked; uint256 public released; ERC20 public token; function TokenVesting( address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable, address _token ) { require(_beneficiary != 0x0); require(_cliff <= _duration); beneficiary = _beneficiary; start = _start; cliff = _start.add(_cliff); duration = _duration; revocable = _revocable; token = ERC20(_token); }",1
0x8615ddfe9d4c9e58abff01c999731f3e9e556e80.sol,FrozenToken,"contract FrozenToken is ERC20Token, ITokenRecipient { mapping (address => bool) frozeds; uint256 public frozedCount; bool public freezeEnabled = false; bool public autoFreeze = false; bool public mintFinished = false; event Freeze(address indexed wallet); event UnFreeze(address indexed wallet); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); event Mint(address indexed sender, address indexed wallet, uint256 amount); event ReceiveTokens(address indexed spender, address indexed token, uint256 value, bytes extraData); event ApproveAndCall(address indexed spender, uint256 value, bytes extraData); event Burn(address indexed sender, uint256 amount); event MintFinished(address indexed spender); modifier notFreeze { require(frozeds[msg.sender] == false || freezeEnabled == false); _; }",1
0xebbdf302c940c6bfd49c6b165f457fdb324649bc.sol,HydroToken,contract HydroToken is Ownable { using SafeMath for uint256; string public name = ; uint8 public decimals = 18; string public symbol = ; uint public totalSupply; address public raindropAddress = 0x0; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; function HydroToken() public { totalSupply = 11111111111 * 10**18; balances[msg.sender] = totalSupply; },1
0x503a7b43335e035bdfec030d2ef718449d985050.sol,LTToken,"contract LTToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 300; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal pure returns (uint256 ) { return _value * 10 ** decimals; }",1
0xeb86a173e0311a28cadc24f85dbad867bbf34f73.sol,Bussiness,contract Bussiness is Ownable { address public ceoAddress = address(0x6c3e879bdd20e9686cfd9bbd1bfd4b2dd6d47079); IERC721 public erc721Address = IERC721(0xdceaf1652a131f32a821468dc03a92df0edd86ea); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdac17f958d2ee523a2206206994597c13d831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; constructor() public {},1
0x9ac36892387ed90df9af3de1b7082153f08f3ef8.sol,DSProxyFactory,"contract DSProxyFactory { event Created(address indexed sender, address indexed owner, address proxy, address cache); mapping(address=>bool) public isProxy; DSProxyCache public cache = new DSProxyCache(); function build() public returns (DSProxy proxy) { proxy = build(msg.sender); }",1
0x7998b7fcf30d4aed870635155cc62aa55be96f9a.sol,generic_holder,contract generic_holder { address owner; modifier onlyowner { if (owner == msg.sender) _; },1
0x33e85f62383aa7601d6ca117fe35b9b397ffe056.sol,UXDToken,contract UXDToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 10000000000 * (10**2); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function UXDToken () { owner = msg.sender; },1
0x320af898ba522062419dd967ab9e2dad9f860d2f.sol,c_Bank,"contract c_Bank { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x797d713d8d7a2815ccf3dcf9719e3e9f1712c370.sol,Trustee,contract Trustee is Ownable { using SaferMath for uint256; StoxSmartToken public stox; struct Grant { uint256 value; uint256 start; uint256 cliff; uint256 end; uint256 transferred; bool revokable; },1
0xb613aa71ce4630e955548a61d089617e8e2f509a.sol,MomsAvenueCrowdsale,"contract MomsAvenueCrowdsale { using SafeMath for uint256; MomsAvenueToken public token; uint256 constant public rate = 10000; uint256 constant public goal = 20000000 * (10 ** 18); uint256 public startTime; uint256 public endTime; uint256 public weiRaised; uint256 public tokensSold; bool public crowdsaleActive = true; address public wallet; address public tokenOwner; mapping(address => uint256) balances; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function MomsAvenueCrowdsale(uint256 _startTime, uint256 _endTime, address _wallet, address _token, address _tokenOwner) public { require(_startTime < _endTime); require(_wallet != address(0)); require(_token != address(0)); require(_tokenOwner != address(0)); startTime = _startTime; endTime = _endTime; wallet = _wallet; tokenOwner = _tokenOwner; token = MomsAvenueToken(_token); }",1
0xeb86a173e0311a28cadc24f85dbad867bbf34f73.sol,Bussiness,contract Bussiness is Ownable { address public ceoAddress = address(0x6c3e879bdd20e9686cfd9bbd1bfd4b2dd6d47079); IERC721 public erc721Address = IERC721(0xdceaf1652a131f32a821468dc03a92df0edd86ea); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdac17f958d2ee523a2206206994597c13d831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; constructor() public {},1
0x6c18e0cb293f534b99cfb9ccaeb7098c857e11a9.sol,Axioms,contract Axioms { Airdrop [] public airdrops; address owner; uint idCounter; constructor () public { owner = msg.sender; },1
0x18da8521c333aed9de8f512e847734cb7be42e38.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,ExternStateProxyToken,"contract ExternStateProxyToken is SafeDecimalMath, Proxyable { TokenState public state; string public name; string public symbol; uint public totalSupply; function ExternStateProxyToken(string _name, string _symbol, uint initialSupply, address initialBeneficiary, TokenState _state, address _owner) Proxyable(_owner) public { name = _name; symbol = _symbol; totalSupply = initialSupply; if (_state == TokenState(0)) { state = new TokenState(_owner, address(this)); state.setBalanceOf(initialBeneficiary, totalSupply); emit Transfer(address(0), initialBeneficiary, initialSupply); }",1
0xc58f1f3ec051b51f10c4feb0cfd10d811d055ef5.sol,ldoh,"contract ldoh is EthereumSmartContract { event onCashbackCode (address indexed hodler, address cashbackcode); event onAffiliateBonus (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onClaimTokens (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onHoldplatform (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onAddContractAddress(address indexed contracthodler, bool contractstatus, uint256 _maxcontribution, string _ContractSymbol, uint256 _PercentPermonth, uint256 _HodlingTime); event onHoldplatformsetting(address indexed Tokenairdrop, bool HPM_status, uint256 HPM_divider, uint256 HPM_ratio, uint256 datetime); event onHoldplatformdeposit(uint256 amount, uint256 newbalance, uint256 datetime); event onHoldplatformwithdraw(uint256 amount, uint256 newbalance, uint256 datetime); event onReceiveAirdrop(uint256 amount, uint256 datetime); address public DefaultToken; struct Safe { uint256 id; uint256 amount; uint256 endtime; address user; address tokenAddress; string tokenSymbol; uint256 amountbalance; uint256 cashbackbalance; uint256 lasttime; uint256 percentage; uint256 percentagereceive; uint256 tokenreceive; uint256 lastwithdraw; address referrer; bool cashbackstatus; }",1
0x3fbe0c07b2e5edc9aaa88017c924d1aeff6a719b.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint maxContractBalance; uint contributionCap; uint public feePct; address public receiverAddress; uint constant public contributionMin = 100000000000000000; uint constant public maxGasPrice = 50000000000; WhiteList constant public whitelistContract = WhiteList(0xf6E386FA4794B58350e7B4Cb32B6f86Fb0F357d4); bool whitelistIsActive = true; uint public nextCapTime; uint public nextContributionCap; uint public addressChangeBlock; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { uint ethRefund; uint balance; uint cap; mapping (address => uint) tokensClaimed; },1
0x5af7af54e8bc34b293e356ef11fffe51d6f9ae78.sol,Marketplace,contract Marketplace is Ownable { modifier onlyJingle() { require(msg.sender == address(jingleContract)); _; },1
0xb462d45329f4f3b4c670790ac355fb26eace41c8.sol,TerraformReserve,"contract TerraformReserve is Ownable { mapping (address => uint256) public lockedBalance; uint public totalLocked; ERC20 public manaToken; address public landClaim; bool public acceptingDeposits; event LockedBalance(address user, uint mana); event LandClaimContractSet(address target); event LandClaimExecuted(address user, uint value, bytes data); event AcceptingDepositsChanged(bool _acceptingDeposits); function TerraformReserve(address _token) { require(_token != 0); manaToken = ERC20(_token); acceptingDeposits = true; }",1
0x416e18790790edb098cb17a7d490caa1262f5772.sol,LoomTimeVault,"contract LoomTimeVault is Ownable { LoomToken public loomToken; mapping(address => uint256) public beneficiaries; uint256 public releaseTime; event BeneficiaryAdded(address _beneficiaryAddress, uint256 _amount); event BeneficiaryWithdrawn(address _beneficiaryAddress, uint256 _amount); event OwnerWithdrawn(address _ownerAddress, uint256 _amount); modifier onlyAfterReleaseTime() { require(now >= releaseTime); _; }",1
0x723aaf922709819c25344b81901dd8a9c84c0b89.sol,FinalizableCrowdsale,"contract FinalizableCrowdsale is Crowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); function FinalizableCrowdsale(uint32 _startTime, uint32 _endTime, uint _rate, uint _hardCap, address _wallet, address _token) Crowdsale(_startTime, _endTime, _rate, _hardCap, _wallet, _token) { }",1
0x4176f0f2b7c95486a5ae06e3d1b29201a42e7630.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x584de5a9995c33c1afa83bc67bebcd481b0a4775.sol,PureMoney2,"contract PureMoney2 is Token { event DebugEvent(address from, address to, uint value); event PaymentContractRegistered(address _contract, uint amountApproved); constructor( uint initialCap) public condition(initialCap > 0) Token(msg.sender, initialCap) { symbol = ; name = ; decimals = DECIMALS; }",1
0x5c89736e9454200141b80c37eb28eaceca2ce8cb.sol,CherryToken,"contract CherryToken is ERC223, ERCAddressFrozenFund { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; address public fundsWallet; uint256 internal fundsWalletChanged; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; constructor() public { _symbol = ; _name = ; _decimals = 8; _totalSupply = 10000000000000000; balances[msg.sender] = _totalSupply; fundsWallet = msg.sender; owner = msg.sender; fundsWalletChanged = 0; }",1
0x58bd394f3dfd9bbc15f4bc662b2def3e597e4e90.sol,AceTokenDistribution,"contract AceTokenDistribution is Ownable { using SafeMath for uint256; StarTokenInterface public token; event DistributionMint(address indexed to, uint256 amount); event ExtraMint(); function AceTokenDistribution (address _tokenAddress) { require(_tokenAddress != 0); token = StarTokenInterface(_tokenAddress); }",1
0x91ca47b9ec3187c77f324281a1851f4b991103f1.sol,FundingInputGeneral,"contract FundingInputGeneral { bool public initialized = false; uint8 public typeId = 0; address public FundingAssetAddress; address public deployer; event EventInputPaymentReceived(address sender, uint amount, uint8 _type); function FundingInputGeneral() public { deployer = msg.sender; }",1
0x655f1cb6616d7f0550007498113e72d7d5c5d4bb.sol,MedalClaim,"contract MedalClaim is AccessControl, SafeMath { address public angelCardDataContract = 0x6D2E76213615925c5fc436565B5ee788Ee0E86DC; address public petCardDataContract = 0xB340686da996b8B3d486b4D27E38E38500A9E926; address public accessoryDataContract = 0x466c44812835f57b736ef9F63582b8a6693A14D0; address public leaderboardDataContract = 0x9A1C755305c6fbf361B4856c9b6b6Bbfe3aCE738; address public medalDataContract = 0x33A104dCBEd81961701900c06fD14587C908EAa3; event EventMedalSuccessful(address owner,uint64 Medal); struct Angel { uint64 angelId; uint8 angelCardSeriesId; address owner; uint16 battlePower; uint8 aura; uint16 experience; }",1
0xc45865b235a7c6693b9db5fed46ea8a3022d9b07.sol,DcorpCrowdsaleProxy,"contract DcorpCrowdsaleProxy is IDcorpCrowdsaleProxy, Ownership, TokenObserver, TokenRetriever { enum Stages { Deploying, Attached, Deployed }",1
0x52d3ec187457a106d2ec546be4cb8a11d9be2527.sol,MonsterAuction,contract MonsterAuctionBase { MonsterOwnership public nonFungibleContract; ChainMonstersCore public core; struct Auction { address seller; uint256 price; uint64 startedAt; uint256 id; },1
0x655f1cb6616d7f0550007498113e72d7d5c5d4bb.sol,MedalClaim,"contract MedalClaim is AccessControl, SafeMath { address public angelCardDataContract = 0x6D2E76213615925c5fc436565B5ee788Ee0E86DC; address public petCardDataContract = 0xB340686da996b8B3d486b4D27E38E38500A9E926; address public accessoryDataContract = 0x466c44812835f57b736ef9F63582b8a6693A14D0; address public leaderboardDataContract = 0x9A1C755305c6fbf361B4856c9b6b6Bbfe3aCE738; address public medalDataContract = 0x33A104dCBEd81961701900c06fD14587C908EAa3; event EventMedalSuccessful(address owner,uint64 Medal); struct Angel { uint64 angelId; uint8 angelCardSeriesId; address owner; uint16 battlePower; uint8 aura; uint16 experience; }",1
0x4900320fe47208de0b79db1273a78ab8c8f3528d.sol,Crowdsale,contract Crowdsale is Owned { using SafeMath for uint256; uint256 public fundingGoal; uint256 public price; uint256 public transferableToken; uint256 public soldToken; uint256 public deadline; uint256 public token_price; MontexToken public tokenReward; bool public fundingGoalReached = false; bool public isOpened; mapping (address => Property) public fundersProperty; struct Property { uint256 paymentEther; uint256 reservedToken; },1
0x46cefba4dd7512b2449e1ac4b730bfb7f77d1407.sol,DecentralizedExchangeHotPotato,contract DecentralizedExchangeHotPotato { address private owner; mapping (address => bool) private admins; struct Order { address creator; address owner; address issuer; uint256 tokenId; uint256 price; uint256 startTime; uint256 endTime; },1
0xeb71e963645f1e76f233f70e1b0815e8f089bbc8.sol,SimplePHXExchange,contract SimplePHXExchange { uint public ScaleFactor = 10 ** 18; address[] public tknOfferors; mapping(address => uint256) public tknAddrNdx; mapping(address => uint256) public tknTokensOffered; mapping(address => uint256) public tknPricePerToken; address[] public ethOfferors; mapping(address => uint256) public ethAddrNdx; mapping(address => uint256) public ethEtherOffered; mapping(address => uint256) public ethPricePerToken; ERC20Token public phxCoin; function SimplePHXExchange() public { phxCoin = ERC20Token(0x14b759A158879B133710f4059d32565b4a66140C); tknOfferors.push(0x0); ethOfferors.push(0x0); },1
0xdcf67546f2253c9c90c2b55447e1efecebcf83d6.sol,HorseyToken,"contract HorseyToken is EthorseHelpers,Pausable { event Claimed(address raceAddress, address eth_address, uint256 tokenId); event Feeding(uint256 tokenId); event ReceivedCarrot(uint256 tokenId, bytes32 newDna); event FeedingFailed(uint256 tokenId); event HorseyRenamed(uint256 tokenId, string newName); event HorseyFreed(uint256 tokenId); RoyalStablesInterface public stables; uint8 public carrotsMultiplier = 1; uint8 public rarityMultiplier = 1; uint256 public claimingFee = 0.000 ether; struct FeedingData { uint256 blockNumber; uint256 horsey; }",1
0x1d1ff336189f16fcb5aea6f00398c06bec5fd0cc.sol,casinoBank,"contract casinoBank is owned, safeMath{ uint public playerBalance; mapping(address=>uint) public balanceOf; mapping(address=>uint) public withdrawAfter; uint public gasPrice = 20; token edg; uint public closeAt; event Deposit(address _player, uint _numTokens, bool _chargeGas); event Withdrawal(address _player, address _receiver, uint _numTokens); function casinoBank(address tokenContract) public{ edg = token(tokenContract); }",1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ClockAuction,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0xb4a3fb248d39370c1f8081b73fa7098167c8142b.sol,LPCWalletReserveWrapper,"contract LPCWalletReserveWrapper is DSThing { ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee); address public walletReserve; WETH public weth; ERC20 public dai; SaiLPC public lpc; function LPCWalletReserveWrapper(address walletReserve_, WETH weth_, ERC20 dai_, SaiLPC lpc_) public { assert(address(walletReserve_) != 0); assert(address(weth_) != 0); assert(address(dai_) != 0); assert(address(lpc_) != 0); walletReserve = walletReserve_; weth = weth_; lpc = lpc_; dai = dai_; }",1
0x261ace754fba8af93e1fecdff13640540402940f.sol,Phila_Token,"contract Phila_Token is ERC20Interface, Owned { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 0; uint private constant _totalSupply = 10000000; address public vaultAddress; bool public fundingEnabled; uint public totalCollected; uint public tokenPrice; mapping(address => uint) balances; constructor() public { balances[this] = _totalSupply; emit Transfer(address(0), this, _totalSupply); }",1
0x0002325fcaaac6ebf1254a626589147bde1a2394.sol,HorseyToken,"contract HorseyToken is EthorseHelpers,Pausable { using SafeMath for uint256; event Claimed(address raceAddress, address eth_address, uint256 tokenId); event Feeding(uint256 tokenId); event ReceivedCarrot(uint256 tokenId, bytes32 newDna); event FeedingFailed(uint256 tokenId); event HorseyRenamed(uint256 tokenId, string newName); event HorseyFreed(uint256 tokenId); RoyalStablesInterface public stables; uint8 public carrotsMultiplier = 1; uint8 public rarityMultiplier = 1; uint256 public claimingFee = 0.008 ether; struct FeedingData { uint256 blockNumber; uint256 horsey; }",1
0x0111ac7e9425c891f935c4ce54cf16db7c14b7db.sol,ChainbreakersItemsERC721,"contract ChainbreakersItemsERC721 is ERC721Token(, ), BasicAccessControl, randomRange { address proxyRegistryAddress; using SafeMath for uint256; using strings for *; uint256 public totalItems; uint256 public totalItemClass; uint256 public totalTokens; uint8 public currentGen; string _baseURI = ""http: uint public presaleStart = 1541073600; address private lastMinter; ItemClass[] private globalClasses; mapping(uint256 => ItemData) public tokenToData; mapping(uint256 => ItemClass) public classIdToClass; struct ItemClass { uint256 classId; string name; uint16 amount; string hostfile; uint16 minLevel; uint16 rarity; uint16 weapon; uint[] category; uint[] statsMin; uint[] statsMax; string desc; uint256 total; uint price; bool active; }",1
0x00c315ac9ff89bb6afa7524cd159f0a9766e8c89.sol,IMDEXDexchange,"contract IMDEXDexchange is SafeMath { address public owner; address IMDEXtoken = 0x46705E8fef2E868FACAFeDc45F47114EC01c2EEd; mapping (address => uint256) public invalidOrder; event SetOwner(address indexed previousOwner, address indexed newOwner); modifier onlyOwner { require(msg.sender == owner); _; }",1
0xc849a5fff9befa297d1c3a772bafac9f3c9004ec.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x4bc78f6619991b029b867b6d88d39c196332aba3.sol,AlgoDEX,"contract AlgoDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0.sol,Play0x_LottoBall,contract Play0x_LottoBall { using SafeMath for uint256; using SafeMath for uint128; using SafeMath for uint40; using SafeMath for uint8; uint public jackpotSize; uint public tokenJackpotSize; uint public MIN_BET; uint public MAX_BET; uint public MAX_AMOUNT; uint public maxProfit; uint public maxTokenProfit; uint8 public platformFeePercentage = 15; uint8 public jackpotFeePercentage = 5; uint8 public ERC20rewardMultiple = 5; uint constant BetExpirationBlocks = 250; uint public lockedInBets; uint public lockedTokenInBets; bytes32 bitComparisonMask = 0xF; address public owner; address private nextOwner; address public manager; address private nextManager; address[] public secretSignerList; address public ERC20ContractAddres; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Bet { uint amount; uint40 placeBlockNumber; address gambler; },1
0x74f887f5b336704be1591f8a2f2e419767134316.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; using Address for address; mapping(address => uint256) internal _balances; mapping(address => mapping(address => uint256)) private _allowed; uint256 internal _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0x019e41a2acdffafc0303e840fbd7934234e68f45.sol,contractDeployer,"contract contractDeployer is Ownable { event ContractCreated(address newAddress); address public tokenAddr; uint public tokenFee; uint public crowdsaleFee; uint public multisendFee; ERC20 token; cDeployer cdep; tDeployer tdep; function setUp(address _token, address _cdep, address _tdep) public onlyOwner { tokenAddr = _token; token = ERC20(tokenAddr); cdep = cDeployer(_cdep); tdep = tDeployer(_tdep); }",1
0x6e9d4b330aad2f414fa7ae1074afa266b6469364.sol,AetherClockAuction,"contract AetherClockAuction is ClockAuction { bool public isAetherClockAuction = true; uint256 public saleCount; uint256[5] public lastSalePrices; function AetherClockAuction(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x0000009a317684a5f840484357fa587aca76454c.sol,TrueUSD,"contract TrueUSD is StandardDelegate, PausableToken, BurnableToken, NoOwner, CanDelegate { string public name = ; string public symbol = ; uint8 public constant decimals = 18; AddressList public canReceiveMintWhiteList; AddressList public canBurnWhiteList; AddressList public blackList; AddressList public noFeesList; uint256 public burnMin = 10000 * 10**uint256(decimals); uint256 public burnMax = 20000000 * 10**uint256(decimals); uint80 public transferFeeNumerator = 7; uint80 public transferFeeDenominator = 10000; uint80 public mintFeeNumerator = 0; uint80 public mintFeeDenominator = 10000; uint256 public mintFeeFlat = 0; uint80 public burnFeeNumerator = 0; uint80 public burnFeeDenominator = 10000; uint256 public burnFeeFlat = 0; address public staker; event ChangeBurnBoundsEvent(uint256 newMin, uint256 newMax); event Mint(address indexed to, uint256 amount); event WipedAccount(address indexed account, uint256 balance); function TrueUSD() public { totalSupply_ = 0; staker = msg.sender; }",1
0x8d4b2cffe2dcbbf06eaa5920401db86ca5fb8177.sol,SelfKeyCrowdsale,"contract SelfKeyCrowdsale is Ownable, CrowdsaleConfig { using SafeMath for uint256; using SafeERC20 for SelfKeyToken; mapping(address => bool) public isVerifier; SelfKeyToken public token; uint64 public startTime; uint64 public endTime; uint256 public goal; uint256 public rate = 51800; uint256 public ethPrice = 777; uint256 public totalPurchased = 0; mapping(address => bool) public kycVerified; mapping(address => uint256) public tokensPurchased; mapping(address => address) public vestedTokens; bool public isFinalized = false; TokenTimelock public foundersTimelock1; TokenTimelock public foundersTimelock2; TokenTimelock public foundationTimelock; RefundVault public vault; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); event VerifiedKYC(address indexed participant); event AddedPrecommitment( address indexed participant, uint256 tokensAllocated ); event Finalized(); modifier verifierOnly() { require(isVerifier[msg.sender]); _; }",1
0x6b0a768e6a4c3ca41417c8eabdeef36dcadba25d.sol,EtheremonAdventureItem,"contract EtheremonAdventureItem is NFTStandard(, ), BasicAccessControl { uint constant public MAX_OWNER_PERS_SITE = 10; uint constant public MAX_SITE_ID = 108; uint constant public MAX_SITE_TOKEN_ID = 1080; address public adventureHandler; struct Item { uint classId; uint value; }",1
0xc45865b235a7c6693b9db5fed46ea8a3022d9b07.sol,DcorpCrowdsaleProxy,"contract DcorpCrowdsaleProxy is IDcorpCrowdsaleProxy, Ownership, TokenObserver, TokenRetriever { enum Stages { Deploying, Attached, Deployed }",1
0x01d28329619796bae733e849696f80a764422700.sol,BaseTokenSale,"contract BaseTokenSale is TokenController, Controlled { using SafeMath for uint256; uint256 public startFundingTime; uint256 public endFundingTime; uint256 constant public maximumFunding = 1951 ether; uint256 public maxFunding; uint256 public minFunding = 0.001 ether; uint256 public tokensPerEther = 41000; uint256 constant public maxGasPrice = 50000000000; uint256 constant oneDay = 86400; uint256 public totalCollected = 0; bool public paused; Token public tokenContract; bool public finalized = false; bool public allowChange = true; bool private transfersEnabled = true; address private vaultAddress; bool private initialed = false; event Payment(address indexed _sender, uint256 _ethAmount, uint256 _tokenAmount); function BaseTokenSale( uint _startFundingTime, uint _endFundingTime, address _vaultAddress, address _tokenAddress ) public { require(_endFundingTime > now); require(_endFundingTime >= _startFundingTime); require(_vaultAddress != 0); require(_tokenAddress != 0); require(!initialed); startFundingTime = _startFundingTime; endFundingTime = _endFundingTime; vaultAddress = _vaultAddress; tokenContract = Token(_tokenAddress); paused = false; initialed = true; }",1
0x17a03553719001e05dc19a20f5e82ee76923a985.sol,Auction,contract AuctionBase is ERC721Holder { using SafeMath for uint256; struct Auction { address seller; uint128 price; uint64 startedAt; },1
0x1ac21b27f5683cc87e7cc853d6d4c052b08f0fe4.sol,EthernautsLogic,contract EthernautsLogic is EthernautsOwnership { address public newContractAddress; function EthernautsLogic() public { ceoAddress = msg.sender; ctoAddress = msg.sender; cooAddress = msg.sender; oracleAddress = msg.sender; paused = true; },1
0xd95f7070c4d4abb344f79bb48ee22e751901d8df.sol,SingularDTVLaunch,"contract SingularDTVLaunch { string public version = ; event Contributed(address indexed contributor, uint contribution, uint tokens); AbstractSingularDTVToken public singularDTVToken; address public workshop; address public SingularDTVWorkshop = 0xc78310231aA53bD3D0FEA2F8c705C67730929D8f; uint public SingularDTVWorkshopFee; uint public CAP; uint public DURATION; uint public TOKEN_TARGET; enum Stages { Deployed, GoingAndGoalNotReached, EndedAndGoalNotReached, GoingAndGoalReached, EndedAndGoalReached }",1
0x0f31b54b35ab54d65d001f4e037a97548461ea7c.sol,EvilMorty,"contract EvilMorty is ERC223 { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000000e18; uint256 public constant GAME_SUPPLY = 200000000e18; uint256 public constant COMMUNITY_SUPPLY = 800000000e18; address public citadelAddress; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[owner] = COMMUNITY_SUPPLY; emit Transfer(0x0, owner, COMMUNITY_SUPPLY); }",1
0xc7740d000d9931769291da0352bbe7c6b27bc97d.sol,HasNoTokens,"contract HasNoTokens is Ownable { event ExtractedTokens(address indexed _token, address indexed _claimer, uint _amount); function extractTokens(address _token, address _claimer) onlyOwner public { if (_token == 0x0) { _claimer.transfer(this.balance); return; }",1
0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol,MONEY_BOX,contract MONEY_BOX { struct Holder { uint unlockTime; uint balance; },1
0x3a266f97425cd281c1770b71662fcf4415c29190.sol,CryptoProgramFactory,contract CryptoProgramFactory { bool status = false; using SafeMath for uint256; address public administrator; uint256 private BASE_PRICE = 0.1 ether; uint256 private BASE_TIME = 4 hours; MemoryFactoryInterface public Memory; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; mapping(uint256 => Factory) public factories; mapping(address => bool) public miniGames; struct Factory { uint256 level; uint256 crystals; uint256 programPriceByCrystals; uint256 programPriceByDarkCrystals; uint256 programValue; uint256 eth; uint256 time; },1
0x291de53a16b76dfe28551fd3335225f506db8b82.sol,_0xGoldToken,"contract _0xGoldToken is ERC20Interface, Owned, ERC918Interface { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 100; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; address public parentAddress; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function _0xGoldToken() public onlyOwner{ symbol = ; name = ; decimals = 10; _totalSupply = 5000000 * 10**uint(decimals); if(locked) revert(); locked = true; tokensMinted = 500000000000000; rewardEra = 0; maxSupplyForEra = _totalSupply.div(2); miningTarget = _MAXIMUM_TARGET; latestDifficultyPeriodStarted = block.number; _startNewMiningEpoch(); parentAddress = 0xB6eD7644C69416d67B522e20bC294A9a9B405B31; balances[owner] = tokensMinted; Transfer(address(0), owner, tokensMinted); }",1
0x5b566b473bb0ea8dc0fc6047dd623e5fa3b42307.sol,Auction,contract Auction is Beneficial { function Auction(address _gameToken) public { owner = msg.sender; shareholder = _gameToken; shareholderIsToken = true; },1
0xcefa3e88393cf17c9b4dc6c9fe5357dfae8036d6.sol,Registry,contract Registry is Ownable { struct ContributorData { bool isActive; uint contributionETH; uint contributionUSD; uint tokensIssued; uint quoteUSD; uint contributionRNTB; },1
0x03358425ada4620246dd703dc1f2246b8e148d22.sol,BoomerangLiquidity,contract BoomerangLiquidity is Owned { modifier onlyOwner(){ require(msg.sender == owner); _; },1
0x3fd2371b53f2db38765220c90f2ffd4ddbe8afd1.sol,MonethaUsersClaimHandler,contract MonethaUsersClaimHandler is Contactable { string constant VERSION = ; MonethaUsersClaimStorage public storageContract; event StorageContractOwnerChanged(address indexed _newOwner); constructor(address _storageAddr) public { storageContract = MonethaUsersClaimStorage(_storageAddr); },1
0x0045684552109f8551cc5c8aa7b1f52085adff47.sol,BaseWallet,"contract BaseWallet { address public implementation; address public owner; mapping (address => bool) public authorised; mapping (bytes4 => address) public enabled; uint public modules; event AuthorisedModule(address indexed module, bool value); event EnabledStaticCall(address indexed module, bytes4 indexed method); event Invoked(address indexed module, address indexed target, uint indexed value, bytes data); event Received(uint indexed value, address indexed sender, bytes data); event OwnerChanged(address owner); modifier moduleOnly { require(authorised[msg.sender], ); _; }",1
0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0.sol,Play0x_LottoBall,contract Play0x_LottoBall { using SafeMath for uint256; using SafeMath for uint128; using SafeMath for uint40; using SafeMath for uint8; uint public jackpotSize; uint public tokenJackpotSize; uint public MIN_BET; uint public MAX_BET; uint public MAX_AMOUNT; uint public maxProfit; uint public maxTokenProfit; uint8 public platformFeePercentage = 15; uint8 public jackpotFeePercentage = 5; uint8 public ERC20rewardMultiple = 5; uint constant BetExpirationBlocks = 250; uint public lockedInBets; uint public lockedTokenInBets; bytes32 bitComparisonMask = 0xF; address public owner; address private nextOwner; address public manager; address private nextManager; address[] public secretSignerList; address public ERC20ContractAddres; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Bet { uint amount; uint40 placeBlockNumber; address gambler; },1
0x1d86a854da490ff74dedc7abe281fb468f8c19ee.sol,MultiVesting,"contract MultiVesting is Ownable, Destroyable { using SafeMath for uint256; struct Beneficiary { string description; uint256 vested; uint256 released; uint256 start; uint256 cliff; uint256 duration; bool revoked; bool revocable; bool isBeneficiary; }",1
0x77c9acc811e4cf4b51dc3a3e05dc5d62fa887767.sol,CrryptoArena,contract CrryptoArena { using SafeMath for uint256; address public administrator; uint256 public VIRUS_NORMAL = 0; uint256 public HALF_TIME_ATK= 60 * 15; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public VIRUS_MINING_PERIOD = 86400; address public engineerAddress; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; CryptoProgramFactoryInterface public Factory; mapping(address => Player) public players; mapping(uint256 => Virus) public viruses; mapping(address => bool) public miniGames; struct Player { uint256 virusDef; uint256 nextTimeAtk; uint256 endTimeUnequalledDef; },1
0x383ece94bfdbdefe651aa2cba51e7fca2773b788.sol,PreSale,"contract PreSale is Ownable, ReentrancyGuard { using SafeMath for uint256; RicoToken public token; address tokenContractAddress; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public minimumInvest; uint256 public softCap; uint256 public hardCap; mapping(address => uint) public balances; uint256 public weiRaised; uint256 bonusPercent; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PreSale( uint256 _startTime, uint256 _period, address _wallet, address _token, uint256 _minimumInvest) public { require(_period != 0); require(_token != address(0)); startTime = _startTime; endTime = startTime + _period * 1 days; wallet = _wallet; token = RicoToken(_token); tokenContractAddress = _token; minimumInvest = _minimumInvest; rate = 6667; softCap = 150 * 1 ether; hardCap = 1500 * 1 ether; bonusPercent = 50; }",1
0x1aed9d45a8e9a2e790c409c70e3d9261dbe891a2.sol,EthicHubLending,"contract EthicHubLending is EthicHubBase, Ownable, Pausable { using SafeMath for uint256; uint256 public minContribAmount = 0.1 ether; enum LendingState { Uninitialized, AcceptingContributions, ExchangingToFiat, AwaitingReturn, ProjectNotFunded, ContributionReturned, Default }",1
0x2f5c4a85d7e133c4fefa5a0c0ba1447a1af86996.sol,GetSaiTubValues,contract GetSaiTubValues { SaiTub public saiTub = SaiTub(0x448a5065aeBB8E423F0896E6c5D525C040f59af3); bytes32 public cup; uint public tab; uint public rap; uint public din; uint public chi; uint public rhi; function updateTabRap(bytes32 _cup) public { cup = _cup; tab = saiTub.tab(_cup); rap = saiTub.rap(_cup); },1
0xd1569ffd7ca4393311f66110e6f87184c4817113.sol,LudumAirdrop,"contract LudumAirdrop is Ownable { Token token; event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); modifier whenDropIsActive() { assert(isActive()); _; }",1
0x26788f0670bdf9594ba1a677a977e97eb68568db.sol,KahnDistributionCentre,contract KahnDistributionCentre{using SafeMath for uint256;struct User{address user_address;uint signup_time;uint256 reward_amount;bool blacklisted;uint paid_time;uint256 paid_token;bool status;},1
0x6bfa4c3c887fdc965bda1f09ff65fbf1f3d8b58d.sol,AsetSale,contract AsetSale is Ownable { using SafeMath for uint256; AsetToken public token; uint256 public price; address public wallet; uint256 public totalRice = 0; uint256 public totalTokenRice = 0; function AsetSale() public { price = 1300; wallet = msg.sender; },1
0xeb86a173e0311a28cadc24f85dbad867bbf34f73.sol,Bussiness,contract Bussiness is Ownable { address public ceoAddress = address(0x6c3e879bdd20e9686cfd9bbd1bfd4b2dd6d47079); IERC721 public erc721Address = IERC721(0xdceaf1652a131f32a821468dc03a92df0edd86ea); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdac17f958d2ee523a2206206994597c13d831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; constructor() public {},1
0x5057a5854e251eb15832576330bcba344397954c.sol,XIDToken,contract XIDToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function XIDToken () { owner = msg.sender; },1
0x4900320fe47208de0b79db1273a78ab8c8f3528d.sol,Crowdsale,contract Crowdsale is Owned { using SafeMath for uint256; uint256 public fundingGoal; uint256 public price; uint256 public transferableToken; uint256 public soldToken; uint256 public deadline; uint256 public token_price; MontexToken public tokenReward; bool public fundingGoalReached = false; bool public isOpened; mapping (address => Property) public fundersProperty; struct Property { uint256 paymentEther; uint256 reservedToken; },1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDView,"contract BitSTDView { BitSTDLogic private logic; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function balanceOf(address add)constant public returns (uint256) { return logic.balanceOf(add); }",1
0x4026f73f99427c6b70c9b101321895cee6b72659.sol,VestingContract,"contract VestingContract is Owned { address public withdrawalAddress; address public tokenAddress; uint public lastBlockClaimed; uint public blockDelay; uint public reward; event ClaimExecuted(uint _amount, uint _blockNumber, address _destination); function VestingContract() { lastBlockClaimed = 4216530; blockDelay = 152470; reward = 1333333000000000000000000; tokenAddress = 0x2C974B2d0BA1716E644c1FC59982a89DDD2fF724; }",1
0x926e81009c2fa4475e1c798a8c43a4f598575c80.sol,FoundersVesting,"contract FoundersVesting is SafeMath { address public teamAccountAddress; uint64 public lastWithdrawTime; uint public withdrawsCount = 0; uint public amountToSend = 0; MNTP public mntToken; function FoundersVesting(address _teamAccountAddress,address _mntTokenAddress){ teamAccountAddress = _teamAccountAddress; lastWithdrawTime = uint64(now); mntToken = MNTP(_mntTokenAddress); }",1
0xedac0e5bedf702accc3a9b2b4b44b4ba0806e882.sol,DSStop,"contract DSStop is DSAuth, DSNote { bool public stopped; modifier stoppable { assert (!stopped); _; }",1
0x74a12ce6eebc23c3f785c0ab50d02228587dcc1a.sol,FrozenToken,"contract FrozenToken is ERC20Token, ITokenRecipient { mapping (address => bool) frozeds; uint256 public frozedCount; bool public freezeEnabled = false; bool public autoFreeze = false; bool public mintFinished = false; event Freeze(address indexed wallet); event UnFreeze(address indexed wallet); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); event Mint(address indexed sender, address indexed wallet, uint256 amount); event ReceiveTokens(address indexed spender, address indexed token, uint256 value, bytes extraData); event ApproveAndCall(address indexed spender, uint256 value, bytes extraData); event Burn(address indexed sender, uint256 amount); event MintFinished(address indexed spender); modifier notFreeze { require(frozeds[msg.sender] == false || freezeEnabled == false); _; }",1
0x56ffb3c578906ba9658fccb052fc1a5672275b6a.sol,OpiriaCrowdsale,"contract OpiriaCrowdsale is TimedPresaleCrowdsale, MintedCrowdsale, TokenCappedCrowdsale { using SafeMath for uint256; uint256 public presaleWeiLimit; address public tokensWallet; uint256 public totalBonus = 0; bool public hiddenCapTriggered; uint16 public additionalBonusPercent = 0; mapping(address => uint256) public bonusOf; constructor(ERC20 _token, uint16 _initialEtherUsdRate, address _wallet, address _tokensWallet, uint256 _presaleOpeningTime, uint256 _presaleClosingTime, uint256 _openingTime, uint256 _closingTime ) public TimedPresaleCrowdsale(_presaleOpeningTime, _presaleClosingTime, _openingTime, _closingTime) Crowdsale(_initialEtherUsdRate, _wallet, _token) { setEtherUsdRate(_initialEtherUsdRate); tokensWallet = _tokensWallet; require(PausableToken(token).paused()); }",1
0x5155a0722a45905dacf49598a02eff3777340acd.sol,RegistryUpdater,"contract RegistryUpdater is Ownable { address public polymathRegistry; address public moduleRegistry; address public securityTokenRegistry; address public featureRegistry; address public polyToken; constructor (address _polymathRegistry) public { require(_polymathRegistry != address(0), ); polymathRegistry = _polymathRegistry; }",1
0x41b8578b7fe2bdcc4cb5c8e6ab18b11880072208.sol,BitcoinQuick,"contract BitcoinQuick { string public constant symbol = ; string public constant name = ; uint public constant decimals = 8; uint _totalSupply = 21000000 * 10 ** decimals; uint public marketSupply; uint public marketPrice; address owner; address airDropVerify; uint public airDropAmount; uint32 public airDropHeight; mapping (address => bool) public airDropMembers; mapping (address => uint) accounts; mapping (address => mapping (address => uint)) allowed; event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); function BitcoinQuick() public { owner = msg.sender; accounts[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x065d6fccf3bcc50e37e875479511f5ca656b98d8.sol,B42Token,contract B42Token is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 42000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function B42Token () { owner = msg.sender; },1
0xf508548ef0ef6472760a36e15169b847ae427d38.sol,CrowdsaleCompatible,"contract CrowdsaleCompatible is BasicERC20, Ownable { BasicCrowdsale public crowdsale = BasicCrowdsale(0x0); function unfreezeTokens() public { assert(now > crowdsale.endTime()); isTokenTransferable = true; }",1
0x271a0b465d5b453bb835afd2d671c76b2b76900e.sol,ClockAuctionBase,"contract ClockAuctionBase is Withdrawable, Pausable { struct Auction { address _contract; address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; }",1
0xac7fa90a250d8240eea4d7f8b89294b55ed84b9f.sol,GaiaToken,contract GaiaToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function GaiaToken () { owner = msg.sender; },1
0xaf8eabf89f5664a2bc82ca415a4337821cd54d65.sol,Crowdsale,"contract Crowdsale is Bonus { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public rate; uint256 public openingTimePeriodOne; uint256 public closingTimePeriodOne; uint256 public openingTimePeriodTwo; uint256 public closingTimePeriodTwo; uint256 public bonusDeliverTime; uint256 public bonusRatePrivateSale; uint256 public bonusRatePeriodOne; uint256 public bonusRatePeriodTwo; uint256 decimals; uint256 public tokenUnsold; uint256 public bonusUnsold; uint256 public constant minPurchaseAmount = 0.1 ether; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event TokenBonus(address indexed purchaser, address indexed beneficiary, uint256 bonus); modifier onlyWhileOpen { require(block.timestamp <= closingTimePeriodTwo); _; }",1
0xdc919494349e803fbd2d4064106944418381edb3.sol,SaiTub,"contract SaiTubEvents { event LogNewCup(address indexed lad, bytes32 cup); }",1
0xbed054a85299561c8e17b393cda91fa690d6bd28.sol,TTBCoin,contract TTBCoin is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0x0e6f6ed4581d25944d8c6a595b9f50e11431b754.sol,PaymentHolder,contract PaymentHolder is Ownable { modifier onlyAllowed() { require(allowed[msg.sender]); _; },1
0x0e69d0a2bbb30abcb7e5cfea0e4fde19c00a8d47.sol,ContractLock,"contract ContractLock is DSStop { uint public unlockTime; mapping (address => bool) public isAdmin; event LogAddAdmin(address whoAdded, address newAdmin); event LogRemoveAdmin(address whoRemoved, address admin); constructor(uint _unlockTime) public { unlockTime = _unlockTime; isAdmin[msg.sender] = true; emit LogAddAdmin(msg.sender, msg.sender); }",1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,GoldBackedToken,"contract GoldBackedToken is Ownable, SafeMath, ERC20, Pausable { event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); event DeductFees(address indexed owner,uint256 amount); event TokenMinted(address destination, uint256 amount); event TokenBurned(address source, uint256 amount); string public name = ; string public symbol = ; uint256 constant public decimals = 18; uint256 constant public hgtDecimals = 8; uint256 constant public allocationPool = 1 * 10**9 * 10**hgtDecimals; uint256 constant public maxAllocation = 38 * 10**5 * 10**decimals; uint256 public totAllocation; address public feeCalculator; address public HGT; function setFeeCalculator(address newFC) onlyOwner { feeCalculator = newFC; }",1
0x0ce95ef378059f38c5fa21e6d81a5895c0d9911b.sol,Game,contract Game { using GlobalTypes for GlobalTypes.Global; using MarketTypes for MarketTypes.MarketListing; using MissionParametersTypes for MissionParametersTypes.MissionParameters; using GameCommon for GameCommon.LaunchRocketStackFrame; address public m_Owner; AbstractDatabase public m_Database; AbstractGameHidden public m_GameHidden; bool public m_Paused; uint256 constant GlobalCategory = 0; uint256 constant RocketCategory = 1; uint256 constant OwnershipCategory = 2; uint256 constant InventoryCategory = 3; uint256 constant MarketCategory = 4; uint256 constant ProfitFundsCategory = 5; uint256 constant CompetitionFundsCategory = 6; uint256 constant MissionParametersCategory = 7; uint256 constant CompetitionScoresCategory = 8; uint256 constant WithdrawalFundsCategory = 9; uint256 constant ReferralCategory = 10; uint256 constant RocketStockCategory = 11; uint256 constant RocketStockInitializedCategory = 12; address constant NullAddress = 0; uint256 constant MaxCompetitionScores = 10; mapping(uint32 => RocketTypes.StockRocket) m_InitialRockets; modifier OnlyOwner() { require(msg.sender == m_Owner); _; },1
0x18b51eb9e6811fd8055a9fd5f06691eaac3bc6fe.sol,MKYCToken,contract MKYCToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 200000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function MKYCToken () { owner = msg.sender; },1
0xed0577d074be9f605f0967fe6a8b3174d92e5e36.sol,DexBrokerage,"contract DexBrokerage is Ownable { using SafeMath for uint256; address public feeAccount; uint256 public makerFee; uint256 public takerFee; uint256 public inactivityReleasePeriod; mapping (address => bool) public approvedCurrencyTokens; mapping (address => uint256) public invalidOrder; mapping (address => mapping (address => uint256)) public tokens; mapping (address => bool) public admins; mapping (address => uint256) public lastActiveTransaction; mapping (bytes32 => uint256) public orderFills; mapping (bytes32 => bool) public withdrawn; event Trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address maker, address taker); event Deposit(address token, address user, uint256 amount, uint256 balance); event Withdraw(address token, address user, uint256 amount, uint256 balance); event MakerFeeUpdated(uint256 oldFee, uint256 newFee); event TakerFeeUpdated(uint256 oldFee, uint256 newFee); modifier onlyAdmin { require(msg.sender == owner || admins[msg.sender]); _; }",1
0x2791528f5617e187a6d73c30034ac211b2f47042.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x447b4ccab1b370afbe5ae2e68c0b700be913a585.sol,AgileArbitration,contract AgileArbitration is Owned { address public operator; uint public quorum = 3; struct Dispute { address icoRoundAddress; address investorAddress; bool pending; uint timestamp; uint milestone; string reason; uint votesForProject; uint votesForInvestor; mapping(address => bool) voters; },1
0x548f7581e85b473da466ef9edbe85c5226eaa3b2.sol,ListingsERC20,contract ListingsERC20 is Ownable { using SafeMath for uint256; struct Listing { address seller; address tokenContractAddress; uint256 price; uint256 allowance; uint256 dateStarts; uint256 dateEnds; },1
0x4c129783b42833220ad57d48548f871189009d3f.sol,HoQuBurner,"contract HoQuBurner is Ownable { using SafeMath for uint256; HoQuToken public token; mapping(address => uint256) public claimed; mapping(uint32 => address) public transactionAddresses; mapping(uint32 => uint256) public transactionAmounts; uint32 public transactionsCount; event TokenBurned(address indexed _sender, uint256 _tokens); function HoQuBurner(address _tokenAddress) { token = HoQuToken(_tokenAddress); }",1
0x57775c09b07896b979bb192b1b13df5a268757bd.sol,FutureTokenSaleLockBox,"contract FutureTokenSaleLockBox is Owned { using SafeMath for uint256; ERC20Interface public simpleToken; TokenSaleInterface public tokenSale; uint256 public unlockDate; event UnlockDateExtended(uint256 _newDate); event TokensTransferred(address indexed _to, uint256 _value); function FutureTokenSaleLockBox(ERC20Interface _simpleToken, TokenSaleInterface _tokenSale) Owned() public { require(address(_simpleToken) != address(0)); require(address(_tokenSale) != address(0)); simpleToken = _simpleToken; tokenSale = _tokenSale; uint256 endTime = tokenSale.endTime(); require(endTime > 0); unlockDate = endTime.add(26 weeks); }",1
0x57bcc647eb77dfe185ede00a2720443c004f298a.sol,LFSTYLToken,contract LFSTYLToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 10000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function LFSTYLToken () { owner = msg.sender; },1
0xb4a3fb248d39370c1f8081b73fa7098167c8142b.sol,DSValue,"contract DSValue is DSThing { bool has; bytes32 val; function peek() public view returns (bytes32, bool) { return (val,has); }",1
0x0297fdbcb9c2023bc05ad44c9f6e69b0ae6261ce.sol,Convert,contract Convert { address owner; address public fromContractAddr; address public toContractAddr; mapping (uint => bool) public isConvert; modifier onlyOwner { require(msg.sender == owner); _; },1
0x0d5eae179709e92b3bff65731158e8291c49eafb.sol,GaintDex,"contract GaintDex is SafeMath { address public admin; address public feeAccount; uint public feeMake; uint public feeTake; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor() { admin = msg.sender; feeAccount = msg.sender; feeMake = 700000000000000; feeTake = 700000000000000; }",1
0xef8544d42df82dda9d3a6e09b47f45f15957268b.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 29721600; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x4B664ef96353f580BAf7ed59BB1188Ca1F2B4Ed2; }",1
0x291de53a16b76dfe28551fd3335225f506db8b82.sol,_0xGoldToken,"contract _0xGoldToken is ERC20Interface, Owned, ERC918Interface { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 100; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; address public parentAddress; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function _0xGoldToken() public onlyOwner{ symbol = ; name = ; decimals = 10; _totalSupply = 5000000 * 10**uint(decimals); if(locked) revert(); locked = true; tokensMinted = 500000000000000; rewardEra = 0; maxSupplyForEra = _totalSupply.div(2); miningTarget = _MAXIMUM_TARGET; latestDifficultyPeriodStarted = block.number; _startNewMiningEpoch(); parentAddress = 0xB6eD7644C69416d67B522e20bC294A9a9B405B31; balances[owner] = tokensMinted; Transfer(address(0), owner, tokensMinted); }",1
0xeb6486b13b56314b37aacac2ec6889d11a763de1.sol,BasicCGRID,contract BasicCGRID is ERC223 { using SafeMath for uint256; uint256 public constant decimals = 8; string public constant symbol = ; string public constant name = ; uint256 public _totalSupply = 10**17; address public owner; address public airdrop; bool public tradable = false; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x0f00f1696218eaefa2d2330df3d6d1f94813b38f.sol,SedoPoWToken,"contract SedoPoWToken is ERC20Interface, Owned { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; address public parentAddress; uint public miningReward; mapping(address => uint) balances; mapping(address => uint) merge_mint_ious; mapping(address => uint) merge_mint_payout_threshold; mapping(address => mapping(address => uint)) allowed; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); function SedoPoWToken() public onlyOwner{ symbol = ; name = ; decimals = 8; _totalSupply = 50000000 * 10**uint(decimals); if(locked) revert(); locked = true; tokensMinted = 1000000 * 10**uint(decimals); miningReward = 25; rewardEra = 0; maxSupplyForEra = _totalSupply.div(2); miningTarget = 2**220; latestDifficultyPeriodStarted = block.number; _startNewMiningEpoch(); parentAddress = 0x9D2Cc383E677292ed87f63586086CfF62a009010; balances[owner] = balances[owner].add(tokensMinted); Transfer(address(this), owner, tokensMinted); }",1
0xc3e43d422d5e6f94315622d96a96058689c52ec8.sol,BitNauticCrowdsaleTokenDistributor,"contract BitNauticCrowdsaleTokenDistributor is Ownable { using SafeMath for uint256; uint256 public constant ICOStartTime = 1531267200; uint256 public constant ICOEndTime = 1536969600; uint256 public teamSupply = 3000000 * 10 ** 18; uint256 public bountySupply = 2500000 * 10 ** 18; uint256 public reserveSupply = 5000000 * 10 ** 18; uint256 public advisorSupply = 2500000 * 10 ** 18; uint256 public founderSupply = 2000000 * 10 ** 18; MintableToken public token; BitNauticWhitelist public whitelist; BitNauticCrowdsale public crowdsale; mapping (address => bool) public hasClaimedTokens; constructor(MintableToken _token, BitNauticWhitelist _whitelist, BitNauticCrowdsale _crowdsale) public { token = _token; whitelist = _whitelist; crowdsale = _crowdsale; }",1
0xa5cc679a3528956e8032df4f03756c077c1ee3f4.sol,Exchange,contract Exchange { function assert(bool assertion) { if (!assertion) throw; },1
0x4cd988afbad37289baaf53c13e98e2bd46aaea8c.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint256 supply) { _balances[msg.sender] = supply; _supply = supply; }",1
0x9ac36892387ed90df9af3de1b7082153f08f3ef8.sol,DSProxy,"contract DSProxy is DSAuth, DSNote { DSProxyCache public cache; constructor(address _cacheAddr) public { require(setCache(_cacheAddr)); }",1
0x4bd22737812e4412879aacf0b400131e1ee0a4a5.sol,Controller,"contract Controller is ControllerInterface, OwnableContract, OwnableContractOwner { WrappedToken public token; MembersInterface public members; address public factory; constructor(WrappedToken _token) public { require(_token != address(0), ); token = _token; }",1
0xf08a7fd4f4b75188e89d0d27c2ae474858402cea.sol,DroneShowCoinICOContract,"contract DroneShowCoinICOContract is Ownable { using SafeMath for uint256; Token token; uint256 public constant RATE = 650; uint256 public constant CAP = 15000; uint256 public constant START = 1510754400; uint256 public constant DAYS = 30; bool public initialized = false; uint256 public raisedAmount = 0; uint256 public bonusesGiven = 0; uint256 public numberOfTransactions = 0; event BoughtTokens(address indexed to, uint256 value); modifier whenSaleIsActive() { assert (isActive()); _; }",1
0x2f5c4a85d7e133c4fefa5a0c0ba1447a1af86996.sol,GetSaiTubValues,contract GetSaiTubValues { SaiTub public saiTub = SaiTub(0x448a5065aeBB8E423F0896E6c5D525C040f59af3); bytes32 public cup; uint public tab; uint public rap; uint public din; uint public chi; uint public rhi; function updateTabRap(bytes32 _cup) public { cup = _cup; tab = saiTub.tab(_cup); rap = saiTub.rap(_cup); },1
0x5b47180e5f07fb5e10f86761df0c34ce952c6974.sol,VICToken,contract VICToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 10000000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function VICToken () { owner = msg.sender; },1
0x6b4df2aa3d64d8dc06120ef4391513e4170af4a7.sol,GeneralTransferManager,contract GeneralTransferManager is ITransferManager { using SafeMath for uint256; address public issuanceAddress = address(0); address public signingAddress = address(0); bytes32 public constant WHITELIST = ; bytes32 public constant FLAGS = ; struct TimeRestriction { uint256 fromTime; uint256 toTime; uint256 expiryTime; bool canBuyFromSTO; },1
0x4c84949b55f21a376dba12e732958ede8b033b0e.sol,TokenVesting,contract TokenVesting { using SafeMath for uint256; struct VestingGrant { bool isGranted; address issuer; address beneficiary; uint256 grantJiffys; uint256 startTimestamp; uint256 cliffTimestamp; uint256 endTimestamp; bool isRevocable; uint256 releasedJiffys; },1
0x4ca65f54f923be2fb3efc3a7758e88a6f910806e.sol,GamblicaEarlyAccess,"contract GamblicaEarlyAccess { enum State { CREATED, DEPOSIT, CLAIM }",1
0x8615ddfe9d4c9e58abff01c999731f3e9e556e80.sol,DAPBOXToken,"contract DAPBOXToken is FrozenToken { string public name = ; string public symbol = ; uint8 public decimals = 0; string public version = ; string public publisher = ""https: string public description = ; bool public acceptAdminWithdraw = false; bool public acceptDonate = true; event InfoChanged(address indexed sender, string version, string publisher, string description); event Withdraw(address indexed sender, address indexed wallet, uint256 amount); event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount); event Donate(address indexed sender, uint256 value); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); function setupInfo(string _version, string _publisher, string _description) authLevel(Level.ADMIN) notEmpty(_version) notEmpty(_publisher) notEmpty(_description) public { version = _version; publisher = _publisher; description = _description; InfoChanged(msg.sender, _version, _publisher, _description); }",1
0x1d86a854da490ff74dedc7abe281fb468f8c19ee.sol,MultiVesting,"contract MultiVesting is Ownable, Destroyable { using SafeMath for uint256; struct Beneficiary { string description; uint256 vested; uint256 released; uint256 start; uint256 cliff; uint256 duration; bool revoked; bool revocable; bool isBeneficiary; }",1
0x291de53a16b76dfe28551fd3335225f506db8b82.sol,_0xGoldToken,"contract _0xGoldToken is ERC20Interface, Owned, ERC918Interface { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 100; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; address public parentAddress; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function _0xGoldToken() public onlyOwner{ symbol = ; name = ; decimals = 10; _totalSupply = 5000000 * 10**uint(decimals); if(locked) revert(); locked = true; tokensMinted = 500000000000000; rewardEra = 0; maxSupplyForEra = _totalSupply.div(2); miningTarget = _MAXIMUM_TARGET; latestDifficultyPeriodStarted = block.number; _startNewMiningEpoch(); parentAddress = 0xB6eD7644C69416d67B522e20bC294A9a9B405B31; balances[owner] = tokensMinted; Transfer(address(0), owner, tokensMinted); }",1
0x00fbe7398d9f0d53fbaef6e2f4c6ab0e7c31f5d7.sol,UAPCrowdsale,"contract UAPCrowdsale is Ownable { using SafeMath for uint256; bool public isFinalised; MintableToken public token; uint256 public mainSaleStartTime; uint256 public mainSaleEndTime; address public wallet; address public tokenWallet; uint256 public rate; uint256 public weiRaised; uint256 public tokensToSell= 319500000 * 10 ** uint256(18); event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event FinalisedCrowdsale(); function UAPCrowdsale(uint256 _mainSaleStartTime, uint256 _mainSaleEndTime, uint256 _rate, address _wallet, address _tokenWallet) public { require(_mainSaleStartTime >= now); require(_mainSaleStartTime < _mainSaleEndTime); require(_rate > 0); require(_wallet != 0x0); require(_tokenWallet != 0x0); token = createTokenContract(_tokenWallet); mainSaleStartTime = _mainSaleStartTime; mainSaleEndTime = _mainSaleEndTime; rate = _rate; wallet = _wallet; tokenWallet = _tokenWallet; isFinalised = false; }",1
0x02d3aea48b443a0026ed9cbc91b97d7335aba323.sol,HardcodedCrowdsale,"contract HardcodedCrowdsale { using SafeMath for uint256; enum ICOStateEnum {NotStarted, Started, Refunded, Successful}",1
0x0f1c64c1259e28b564662ba41e994d67cb7b1519.sol,PlatinToken,"contract PlatinToken is HoldersToken, NoOwner, Authorizable, Pausable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; struct Lockup { uint256 release; uint256 amount; }",1
0x4c129783b42833220ad57d48548f871189009d3f.sol,HoQuBurner,"contract HoQuBurner is Ownable { using SafeMath for uint256; HoQuToken public token; mapping(address => uint256) public claimed; mapping(uint32 => address) public transactionAddresses; mapping(uint32 => uint256) public transactionAmounts; uint32 public transactionsCount; event TokenBurned(address indexed _sender, uint256 _tokens); function HoQuBurner(address _tokenAddress) { token = HoQuToken(_tokenAddress); }",1
0x1d899280f446aab65971e41611b5bb5516dd47f9.sol,CryptoMiningWar,contract CryptoMiningWar is PullPayment { bool public initialized = false; uint256 public roundNumber = 0; uint256 public deadline; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public HALF_TIME = 8 hours; uint256 public ROUND_TIME = 86400 * 7; uint256 public prizePool = 0; uint256 BASE_PRICE = 0.005 ether; uint256 RANK_LIST_LIMIT = 10000; uint256 public totalMiniGame = 0; uint256 private numberOfMiners = 8; uint256 private numberOfBoosts = 5; uint256 private numberOfRank = 21; CryptoEngineerInterface public Engineer; mapping(uint256 => address) public miniGameAddress; mapping(uint256 => MinerData) private minerData; mapping(address => Player) public players; mapping(address => uint256) public boosterReward; mapping(uint256 => BoostData) private boostData; mapping(address => bool) public miniGames; address[21] rankList; address public administrator; struct Player { uint256 roundNumber; mapping(uint256 => uint256) minerCount; uint256 hashrate; uint256 crystals; uint256 lastUpdateTime; },1
0x4c7f666ca30fe548fbdc08b0308927327f08336d.sol,EthicHubTokenDistributionStrategy,"contract EthicHubTokenDistributionStrategy is Ownable, WhitelistedDistributionStrategy { event UnsoldTokensReturned(address indexed destination, uint256 amount); function EthicHubTokenDistributionStrategy(EthixToken _token, uint256 _rate, uint256 _rateForWhitelisted) WhitelistedDistributionStrategy(_token, _rate, _rateForWhitelisted) public { }",1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0xcf8cd1bfd4d21c11c571d20d62a9c859ac5e3156.sol,Contract2,contract Contract2 { Contract1 public original; mapping (uint16 => mapping (address => uint8)) public something; function Contract2(address c) public { original = Contract1(c); },1
0x83f21fc58b04af42c23b5c468ba395319c9a8f60.sol,BancorConverter,"contract BancorConverter is IBancorConverter, SmartTokenController, Managed, ContractIds, FeatureIds { using SafeMath for uint256; uint32 private constant MAX_WEIGHT = 1000000; uint64 private constant MAX_CONVERSION_FEE = 1000000; struct Connector { uint256 virtualBalance; uint32 weight; bool isVirtualBalanceEnabled; bool isPurchaseEnabled; bool isSet; }",1
0xeb86a173e0311a28cadc24f85dbad867bbf34f73.sol,Bussiness,contract Bussiness is Ownable { address public ceoAddress = address(0x6c3e879bdd20e9686cfd9bbd1bfd4b2dd6d47079); IERC721 public erc721Address = IERC721(0xdceaf1652a131f32a821468dc03a92df0edd86ea); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdac17f958d2ee523a2206206994597c13d831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; constructor() public {},1
0x1d86a854da490ff74dedc7abe281fb468f8c19ee.sol,MultiVesting,"contract MultiVesting is Ownable, Destroyable { using SafeMath for uint256; struct Beneficiary { string description; uint256 vested; uint256 released; uint256 start; uint256 cliff; uint256 duration; bool revoked; bool revocable; bool isBeneficiary; }",1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,GoldBackedToken,"contract GoldBackedToken is Ownable, SafeMath, ERC20, Pausable { event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); event DeductFees(address indexed owner,uint256 amount); event TokenMinted(address destination, uint256 amount); event TokenBurned(address source, uint256 amount); string public name = ; string public symbol = ; uint256 constant public decimals = 18; uint256 constant public hgtDecimals = 8; uint256 constant public allocationPool = 1 * 10**9 * 10**hgtDecimals; uint256 constant public maxAllocation = 38 * 10**5 * 10**decimals; uint256 public totAllocation; address public feeCalculator; address public HGT; function setFeeCalculator(address newFC) onlyOwner { feeCalculator = newFC; }",1
0x1f10822c753a1f587923d9916e64738ee7c27419.sol,GPHToken,contract GPHToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 500000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function GPHToken () { owner = msg.sender; },1
0x6938f6265a5a4e6e25ff4a8b0e2dadb6574521fb.sol,ZlotsJackpotHoldingContract,contract ZlotsJackpotHoldingContract is ERC223Receiving { modifier onlyOwner() { require(msg.sender == owner); _; },1
0xbf95d4957d481473e39c70d3bc08896740e3ca96.sol,CvcMigrator,contract CvcMigrator is Ownable { event ProxyCreated(address indexed proxyAddress); struct Migration { address proxy; address implementation; bytes data; },1
0xeb86a173e0311a28cadc24f85dbad867bbf34f73.sol,Bussiness,contract Bussiness is Ownable { address public ceoAddress = address(0x6c3e879bdd20e9686cfd9bbd1bfd4b2dd6d47079); IERC721 public erc721Address = IERC721(0xdceaf1652a131f32a821468dc03a92df0edd86ea); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdac17f958d2ee523a2206206994597c13d831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; constructor() public {},1
0x64cfc7428621b2b118896670c0b4d52ab020ee6a.sol,AUSD,"contract AUSD is Owned, ERC20Token { using SafeMath for uint256; string private constant standard = ; string private constant version = ; string private name_ = ; string private symbol_ = ; uint8 private decimals_ = 18; uint256 private totalSupply_ = uint256(20) * uint256(10)**uint256(8) * uint256(10)**uint256(decimals_); mapping (address => uint256) private balanceP; mapping (address => mapping (address => uint256)) private allowed; mapping (address => uint256[]) private lockTime; mapping (address => uint256[]) private lockValue; mapping (address => uint256) private lockNum; uint256 private later = 0; uint256 private earlier = 0; bool private mintable_ = true; event Burn(address indexed _from, uint256 _value); event Mint(address indexed _to, uint256 _value); event TransferLocked(address indexed _from, address indexed _to, uint256 _time, uint256 _value); event TokenUnlocked(address indexed _address, uint256 _value); event WrongTokenEmptied(address indexed _token, address indexed _addr, uint256 _amount); event WrongEtherEmptied(address indexed _addr, uint256 _amount); constructor() public { balanceP[msg.sender] = totalSupply_; }",1
0x301487766dcf283592b11b5988e5c4e4630dfbe5.sol,EDex,"contract EDex is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x6d5246ac741ea76de42b75dc48a78cc6dc7c7593.sol,MultiTokenRegistry,"contract MultiTokenRegistry is Pausable { event NewMultitoken(address indexed mtkn); event NewDeployer(uint256 indexed index, address indexed oldDeployer, address indexed newDeployer); address[] public multitokens; mapping(uint256 => IDeployer) public deployers; function multitokensCount() public view returns(uint256) { return multitokens.length; }",1
0x447b4ccab1b370afbe5ae2e68c0b700be913a585.sol,AgileICO,contract AgileICO { using SafeMath for uint; address public operator; address public juryOperator; address public projectWallet; address public arbitrationAddress; address public juryOnlineWallet; bool public requireTokens; uint public promisedTokens; uint public etherAllowance; uint public jotAllowance; uint public commissionOnInvestmentJot; uint public commissionOnInvestmentEth; uint public percentForFuture; uint public rate = 1; address public currentCycleAddress; uint public currentCycleNumber; uint public currentFundingRound; uint public minimumInvestment; uint public lastRateChange; Token public token; struct Offer { uint etherAmount; uint tokenAmount; bool accepted; uint numberOfDeals; },1
0x7541b76cb60f4c60af330c208b0623b7f54bf615.sol,U_BANK,"contract U_BANK { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0xeb6486b13b56314b37aacac2ec6889d11a763de1.sol,BasicCGRID,contract BasicCGRID is ERC223 { using SafeMath for uint256; uint256 public constant decimals = 8; string public constant symbol = ; string public constant name = ; uint256 public _totalSupply = 10**17; address public owner; address public airdrop; bool public tradable = false; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x8d4b2cffe2dcbbf06eaa5920401db86ca5fb8177.sol,SelfKeyCrowdsale,"contract SelfKeyCrowdsale is Ownable, CrowdsaleConfig { using SafeMath for uint256; using SafeERC20 for SelfKeyToken; mapping(address => bool) public isVerifier; SelfKeyToken public token; uint64 public startTime; uint64 public endTime; uint256 public goal; uint256 public rate = 51800; uint256 public ethPrice = 777; uint256 public totalPurchased = 0; mapping(address => bool) public kycVerified; mapping(address => uint256) public tokensPurchased; mapping(address => address) public vestedTokens; bool public isFinalized = false; TokenTimelock public foundersTimelock1; TokenTimelock public foundersTimelock2; TokenTimelock public foundationTimelock; RefundVault public vault; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); event VerifiedKYC(address indexed participant); event AddedPrecommitment( address indexed participant, uint256 tokensAllocated ); event Finalized(); modifier verifierOnly() { require(isVerifier[msg.sender]); _; }",1
0x1c8654c680c3f18a3b3a0ee943d40848a9fffd0d.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; using SafeERC20 for ERC20; ERC20 public token; address public wallet; uint256 internal rate; uint256 public weiRaised; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); constructor(address _wallet, ERC20 _token) public { require(_wallet != address(0)); require(_token != address(0)); wallet = _wallet; token = _token; }",1
0x56ffb3c578906ba9658fccb052fc1a5672275b6a.sol,OpiriaCrowdsale,"contract OpiriaCrowdsale is TimedPresaleCrowdsale, MintedCrowdsale, TokenCappedCrowdsale { using SafeMath for uint256; uint256 public presaleWeiLimit; address public tokensWallet; uint256 public totalBonus = 0; bool public hiddenCapTriggered; uint16 public additionalBonusPercent = 0; mapping(address => uint256) public bonusOf; constructor(ERC20 _token, uint16 _initialEtherUsdRate, address _wallet, address _tokensWallet, uint256 _presaleOpeningTime, uint256 _presaleClosingTime, uint256 _openingTime, uint256 _closingTime ) public TimedPresaleCrowdsale(_presaleOpeningTime, _presaleClosingTime, _openingTime, _closingTime) Crowdsale(_initialEtherUsdRate, _wallet, _token) { setEtherUsdRate(_initialEtherUsdRate); tokensWallet = _tokensWallet; require(PausableToken(token).paused()); }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,Court,"contract Court is Owned, SafeDecimalMath { Havven public havven; EtherNomin public nomin; uint public minStandingBalance = 100 * UNIT; uint public votingPeriod = 1 weeks; uint constant MIN_VOTING_PERIOD = 3 days; uint constant MAX_VOTING_PERIOD = 4 weeks; uint public confirmationPeriod = 1 weeks; uint constant MIN_CONFIRMATION_PERIOD = 1 days; uint constant MAX_CONFIRMATION_PERIOD = 2 weeks; uint public requiredParticipation = 3 * UNIT / 10; uint constant MIN_REQUIRED_PARTICIPATION = UNIT / 10; uint public requiredMajority = (2 * UNIT) / 3; uint constant MIN_REQUIRED_MAJORITY = UNIT / 2; uint nextMotionID = 1; mapping(uint => address) public motionTarget; mapping(address => uint) public targetMotionID; mapping(uint => uint) public motionStartTime; mapping(uint => uint) public votesFor; mapping(uint => uint) public votesAgainst; mapping(address => mapping(uint => uint)) voteWeight; enum Vote {Abstention, Yea, Nay}",1
0x284b0f2f49d072836db87dd25d0623cd2f622bb1.sol,DesTokenSale,"contract DesTokenSale is Haltable { using SafeMath for uint; string public name = ; DesToken public token; address public beneficiary; uint public tokensSoldTotal = 0; uint public weiRaisedTotal = 0; uint public investorCount = 0; uint public tokensSelling = 0; uint public tokenPrice = 0; uint public purchaseLimit = 0; event NewContribution(address indexed holder, uint256 tokenAmount, uint256 etherAmount); function DesTokenSale( address _token, address _beneficiary ) { token = DesToken(_token); beneficiary = _beneficiary; }",1
0x182f2b554462230735699df74ec9606a3c4c0684.sol,BookERC20EthV1Dec,contract BookERC20EthV1Dec { enum BookType { ERC20EthV1 },1
0x0045684552109f8551cc5c8aa7b1f52085adff47.sol,BaseWallet,"contract BaseWallet { address public implementation; address public owner; mapping (address => bool) public authorised; mapping (bytes4 => address) public enabled; uint public modules; event AuthorisedModule(address indexed module, bool value); event EnabledStaticCall(address indexed module, bytes4 indexed method); event Invoked(address indexed module, address indexed target, uint indexed value, bytes data); event Received(uint indexed value, address indexed sender, bytes data); event OwnerChanged(address owner); modifier moduleOnly { require(authorised[msg.sender], ); _; }",1
0x4176f0f2b7c95486a5ae06e3d1b29201a42e7630.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0xcdf35c3fe4ccfacb3b1bbedfe71ca3a5ff6f2db1.sol,AdvisorsTokensHolder,"contract AdvisorsTokensHolder is Ownable { using SafeMath for uint256; GenericCrowdsale crowdsale; MyDFSToken token; event ClaimedTokens(address token, uint256 amount); event TokensWithdrawn(address holder, uint256 amount); function AdvisorsTokensHolder(address _crowdsale, address _token, address _owner) public { crowdsale = GenericCrowdsale(_crowdsale); token = MyDFSToken(_token); owner = _owner; }",1
0xeb907a50921e052cbee233811beaf0839d2a98fd.sol,Advertisement,contract Advertisement { struct Filters { string countries; string packageName; uint[] vercodes; },1
0x6f9e77dc013e6a7156a5aeb26fb095f3405fd911.sol,FlexibleTokenSale,"contract FlexibleTokenSale is Owned { using SafeMath for uint256; bool public suspended; uint256 public tokenPrice; uint256 public tokenPerEther; uint256 public contributionMin; uint256 public tokenConversionFactor; address public walletAddress; TokenTransfer token; uint256 public totalTokensSold; uint256 public totalEtherCollected; address public priceUpdateAddress; event Initialized(); event TokenPriceUpdated(uint256 _newValue); event TokenPerEtherUpdated(uint256 _newValue); event TokenMinUpdated(uint256 _newValue); event WalletAddressUpdated(address indexed _newAddress); event SaleSuspended(); event SaleResumed(); event TokensPurchased(address indexed _beneficiary, uint256 _cost, uint256 _tokens); event TokensReclaimed(uint256 _amount); event PriceAddressUpdated(address indexed _newAddress); function FlexibleTokenSale(address _tokenAddress,address _walletAddress,uint _tokenPerEther,address _priceUpdateAddress) public Owned() { require(_walletAddress != address(0)); require(_walletAddress != address(this)); require(address(token) == address(0)); require(address(_tokenAddress) != address(0)); require(address(_tokenAddress) != address(this)); require(address(_tokenAddress) != address(walletAddress)); walletAddress = _walletAddress; priceUpdateAddress = _priceUpdateAddress; token = TokenTransfer(_tokenAddress); suspended = false; tokenPrice = 100; tokenPerEther = _tokenPerEther; contributionMin = 5 * 10**18; totalTokensSold = 0; totalEtherCollected = 0; tokenConversionFactor = 10**(uint256(18).sub(token.decimals()).add(2)); assert(tokenConversionFactor > 0); }",1
0x35a1700ac75f6e9e096d9a5c90e3221b658096e0.sol,SpendableWallet,"contract SpendableWallet is Ownable { ERC20 public token; event ClaimedTokens( address indexed _token, address indexed _controller, uint256 _amount ); constructor(address _token, address _owner) public { token = ERC20(_token); owner = _owner; }",1
0xa5dc0165b798779ac80acc84c4da4ee77b79843f.sol,EosPizzaSliceDonationraiser,contract EosPizzaSliceDonationraiserConfig is EosPizzaSliceConfig { uint constant CONVERSION_RATE = 100000; uint constant TOKENS_HARD_CAP = 95 * (10**7) * DECIMALS_FACTOR; uint constant START_DATE = 1520630542; uint constant END_DATE = 1526603720; uint constant TOKENS_LOCKED_CORE_TEAM = 35 * (10**6) * DECIMALS_FACTOR; uint constant TOKENS_LOCKED_ADVISORS = 125 * (10**5) * DECIMALS_FACTOR; uint constant TOKENS_LOCKED_CORE_TEAM_RELEASE_DATE = END_DATE + 1 days; uint constant TOKENS_LOCKED_ADVISORS_RELEASE_DATE = END_DATE + 1 days; uint constant TOKENS_BOUNTY_PROGRAM = 25 * (10**5) * DECIMALS_FACTOR; uint constant MAX_GAS_PRICE = 90000000000 wei; uint constant MIN_CONTRIBUTION = 0.05 ether; uint constant INDIVIDUAL_ETHER_LIMIT = 4999 ether; },1
0x1860d43a2a1b9b03907eb6a6b92ce256694dd315.sol,NescrowExchangeService,contract NescrowExchangeService { address owner = msg.sender; uint256 public feeRateLimit = 200; uint256 public takerFeeRate = 0; uint256 public makerFeeRate = 0; address public feeAddress; mapping (address => bool) public admins; mapping (bytes32 => uint256) public orderFills; mapping (bytes32 => uint256) public orderPaymentFills; mapping (bytes32 => bool) public withdrawn; mapping (bytes32 => bool) public transfers; mapping (address => mapping (address => uint256)) public balances; mapping (address => uint256) public tradesLocked; mapping (address => uint256) public disableFees; mapping (address => uint256) public tokenDecimals; mapping (address => bool) public tokenRegistered; struct EIP712Domain { string name; string version; uint256 chainId; address verifyingContract; },1
0xa227d444a52fd21c3a848c7650bc2cd5832f6487.sol,KTFForTestMigration,"contract KTFForTestMigration is PartialERC20, Ownable { string public name; string public symbol; uint32 public decimals; PrivateToken public pktf; uint32 public holderCount; constructor(PrivateToken _pktf) public { symbol = ; name = ; decimals = 18; _totalSupply = 0; _balances[msg.sender] = _totalSupply; pktf = _pktf; }",1
0xaf8eabf89f5664a2bc82ca415a4337821cd54d65.sol,Crowdsale,"contract Crowdsale is Bonus { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public rate; uint256 public openingTimePeriodOne; uint256 public closingTimePeriodOne; uint256 public openingTimePeriodTwo; uint256 public closingTimePeriodTwo; uint256 public bonusDeliverTime; uint256 public bonusRatePrivateSale; uint256 public bonusRatePeriodOne; uint256 public bonusRatePeriodTwo; uint256 decimals; uint256 public tokenUnsold; uint256 public bonusUnsold; uint256 public constant minPurchaseAmount = 0.1 ether; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event TokenBonus(address indexed purchaser, address indexed beneficiary, uint256 bonus); modifier onlyWhileOpen { require(block.timestamp <= closingTimePeriodTwo); _; }",1
0x089a6d83282fb8988a656189f1e7a73fa6c1cac2.sol,ProspectorsGoldToken,"contract ProspectorsGoldToken is TokenBase, Owned, Migrable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; address private game_address = 0xb1; uint public constant game_allocation = 110000000 * WAD; uint public constant dev_allocation = 45000000 * WAD; uint public constant crowdfunding_allocation = 60000000 * WAD; uint public constant bounty_allocation = 500000 * WAD; uint public constant presale_allocation = 4500000 * WAD; bool public locked = true; address public bounty; address public prospectors_dev_allocation; ProspectorsCrowdsale public crowdsale; function ProspectorsGoldToken() { _supply = 220000000 * WAD; _balances[this] = _supply; mint_for(game_address, game_allocation); }",1
0x00676065a7854163c6a4d5f474496514d03e31c4.sol,CrystalDeposit,contract CrystalDeposit { using SafeMath for uint256; address public administrator; uint256 public HALF_TIME = 48 hours; uint256 public MIN_TIME_WITH_DEADLINE = 12 hours; uint256 public round = 0; CryptoEngineerInterface public Engineer; CryptoMiningWarInterface public MiningWar; address miningWarAddress; uint256 miningWarDeadline; uint256 constant private CRTSTAL_MINING_PERIOD = 86400; mapping(uint256 => Game) public games; mapping(address => Player) public players; mapping(address => bool) public miniGames; struct Game { uint256 round; uint256 crystals; uint256 prizePool; uint256 startTime; uint256 endTime; bool ended; },1
0x71aaf9dc418e9dde76aee42e431fc203d9cfd0c2.sol,VestingContractWTTEST,contract VestingContractWTTEST { struct AccountData { uint original_balance; uint limit_per_period; uint current_balance; uint current_limit; uint current_transferred; },1
0x0193cba9762dfe203a34bd895d0ddf4d876e0f98.sol,UpgradeableToken,"contract UpgradeableToken is Ownable, StandardToken { address public migrationAgent; event Upgrade(address indexed from, address indexed to, uint256 value); event UpgradeAgentSet(address agent); function migrate() public { require(migrationAgent != 0); uint value = balances[msg.sender]; balances[msg.sender] = safeSub(balances[msg.sender], value); totalSupply = safeSub(totalSupply, value); MigrationAgent(migrationAgent).migrateFrom(msg.sender, value); Upgrade(msg.sender, migrationAgent, value); }",1
0xaf8eabf89f5664a2bc82ca415a4337821cd54d65.sol,Crowdsale,"contract Crowdsale is Bonus { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public rate; uint256 public openingTimePeriodOne; uint256 public closingTimePeriodOne; uint256 public openingTimePeriodTwo; uint256 public closingTimePeriodTwo; uint256 public bonusDeliverTime; uint256 public bonusRatePrivateSale; uint256 public bonusRatePeriodOne; uint256 public bonusRatePeriodTwo; uint256 decimals; uint256 public tokenUnsold; uint256 public bonusUnsold; uint256 public constant minPurchaseAmount = 0.1 ether; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event TokenBonus(address indexed purchaser, address indexed beneficiary, uint256 bonus); modifier onlyWhileOpen { require(block.timestamp <= closingTimePeriodTwo); _; }",1
0x00676065a7854163c6a4d5f474496514d03e31c4.sol,CrystalDeposit,contract CrystalDeposit { using SafeMath for uint256; address public administrator; uint256 public HALF_TIME = 48 hours; uint256 public MIN_TIME_WITH_DEADLINE = 12 hours; uint256 public round = 0; CryptoEngineerInterface public Engineer; CryptoMiningWarInterface public MiningWar; address miningWarAddress; uint256 miningWarDeadline; uint256 constant private CRTSTAL_MINING_PERIOD = 86400; mapping(uint256 => Game) public games; mapping(address => Player) public players; mapping(address => bool) public miniGames; struct Game { uint256 round; uint256 crystals; uint256 prizePool; uint256 startTime; uint256 endTime; bool ended; },1
0xdc919494349e803fbd2d4064106944418381edb3.sol,DSValue,"contract DSValue is DSThing { bool has; bytes32 val; function peek() public view returns (bytes32, bool) { return (val,has); }",1
0x5c89736e9454200141b80c37eb28eaceca2ce8cb.sol,CherryToken,"contract CherryToken is ERC223, ERCAddressFrozenFund { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; address public fundsWallet; uint256 internal fundsWalletChanged; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; constructor() public { _symbol = ; _name = ; _decimals = 8; _totalSupply = 10000000000000000; balances[msg.sender] = _totalSupply; fundsWallet = msg.sender; owner = msg.sender; fundsWalletChanged = 0; }",1
0x39de38ba63d172b962db2fc2ee5e4376287c50bf.sol,ImmlaIco,"contract ImmlaIco is SafeMath { ImmlaToken public immlaToken; AbstractToken public preIcoToken; address public escrow; address public icoManager; address public tokenImporter = 0x0; address public founder1; address public founder2; address public founder3; address public team; address public bountyOwner; uint public constant teamsReward = 38548226701232220000000000; uint public constant bountyOwnersTokens = 9361712198870680000000000; uint constant BASE = 1000000000000000000; uint public constant defaultIcoStart = 1505422800; uint public icoStart = defaultIcoStart; uint public constant defaultIcoDeadline = 1508101200; uint public icoDeadline = defaultIcoDeadline; uint public constant defaultFoundersRewardTime = 1521061200; uint public foundersRewardTime = defaultFoundersRewardTime; uint public constant minIcoTokenLimit = 18000000 * BASE; uint public constant maxIcoTokenLimit = 434477177 * BASE; uint public importedTokens = 0; uint public soldTokensOnIco = 0; uint public constant soldTokensOnPreIco = 13232941687168431951684000; uint tokenPrice1 = 3640; uint tokenSupply1 = 170053520 * BASE; uint tokenPrice2 = 3549; uint tokenSupply2 = 103725856 * BASE; uint tokenPrice3 = 3458; uint tokenSupply3 = 100319718 * BASE; uint tokenPrice4 = 3367; uint tokenSupply4 = 60378083 * BASE; uint[] public tokenPrices; uint[] public tokenSupplies; bool public initialized = false; bool public migrated = false; bool public sentTokensToFounders = false; bool public icoStoppedManually = false; mapping (address => uint) public balances; event BuyTokens(address buyer, uint value, uint amount); event WithdrawEther(); event StopIcoManually(); event SendTokensToFounders(uint founder1Reward, uint founder2Reward, uint founder3Reward); event ReturnFundsFor(address account); modifier whenInitialized() { require(initialized); _; }",1
0x6dbb4e882f967432fc0f9200e9ca577c916d8a68.sol,Bussiness,contract Bussiness is Ownable { IERC721 public erc721Address = IERC721(0x06012c8cf97bead5deae237070f9587f8e7a266d); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdAC17F958D2ee523a2206206994597C13D831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; uint256 public balance = address(this).balance; constructor() public {},1
0xeb907a50921e052cbee233811beaf0839d2a98fd.sol,Advertisement,contract Advertisement { struct Filters { string countries; string packageName; uint[] vercodes; },1
0x3400696045f706f3309927cb8fdf63f07b616c6f.sol,InviteCollateralizer,contract InviteCollateralizer is Ownable { using SafeMath for uint256; using SafeERC20 for ERC20; ERC20 public blt; address public seizedTokensWallet; mapping (address => Collateralization[]) public collateralizations; uint256 public collateralAmount = 1e17; uint64 public lockupDuration = 1 years; address private collateralTaker; address private collateralSeizer; struct Collateralization { uint256 value; uint64 releaseDate; bool claimed; },1
0x4c84949b55f21a376dba12e732958ede8b033b0e.sol,TokenVesting,contract TokenVesting { using SafeMath for uint256; struct VestingGrant { bool isGranted; address issuer; address beneficiary; uint256 grantJiffys; uint256 startTimestamp; uint256 cliffTimestamp; uint256 endTimestamp; bool isRevocable; uint256 releasedJiffys; },1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,DSAuth,contract DSAuthEvents { event LogSetOrcl (address indexed authority); event LogSetOwner (address indexed owner); },1
0x56c945f90c9cd1aafbcac78936f569e5fd2438bf.sol,HeroUp,"contract HeroUp is Ownable, CanReclaimToken { event HeroUpgraded(uint tokenId, address owner); HEROES_OLD public heroesOld; HEROES_NEW public heroesNew; constructor (HEROES_OLD _heroesOld, HEROES_NEW _heroesNew) public { require(address(_heroesOld) != address(0)); require(address(_heroesNew) != address(0)); heroesOld = _heroesOld; heroesNew = _heroesNew; }",1
0x728d52789bdcb8e4b76172c0120db8ef97914f64.sol,GameofGold,contract GameofGold { modifier onlyBagholders() { require(myTokens() > 0); _; },1
0x923641c6b80d8fc913ff883a5c523f47081bad92.sol,Token,"contract TokenInterface { mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; mapping(address => bool) seller; address config; address owner; address dao; address public badgeLedger; bool locked; uint256 public totalSupply; function balanceOf(address _owner) constant returns(uint256 balance); function transfer(address _to, uint256 _value) returns(bool success); function transferFrom(address _from, address _to, uint256 _value) returns(bool success); function approve(address _spender, uint256 _value) returns(bool success); function allowance(address _owner, address _spender) constant returns(uint256 remaining); function mint(address _owner, uint256 _amount) returns(bool success); function mintBadge(address _owner, uint256 _amount) returns(bool success); function registerDao(address _dao) returns(bool success); function registerSeller(address _tokensales) returns(bool success); event Transfer(address indexed _from, address indexed _to, uint256 indexed _value); event Mint(address indexed _recipient, uint256 indexed _amount); event Approval(address indexed _owner, address indexed _spender, uint256 indexed _value); }",1
0x24a7de87b3bd7298bbf8966fdf170c558d69ecc4.sol,METADOLLAR,"contract METADOLLAR is ERC20Interface, Owned, SafeMath { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public _totalSupply = 1000000000000000000000000000000; uint256 public icoMin = 1000000000000000; uint256 public icoLimit = 1000000000000000000000000000000; uint256 public countHolders = 0; uint256 public amountOfInvestments = 0; uint256 public icoPrice; uint256 public dolRate = 1000; uint256 public ethRate = 1; uint256 public sellRate = 900; uint256 public commissionRate = 1000; uint256 public sellPrice; uint256 public currentTokenPrice; uint256 public commission; bool public icoIsRunning; bool public minimalGoalReached; bool public icoIsClosed; mapping (address => uint256) public tokenBalanceOf; mapping(address => mapping (address => uint256)) allowed; mapping(address => bool) frozenAccount; event FrozenFunds(address initiator, address account, string status); event BonusChanged(uint8 bonusOld, uint8 bonusNew); event minGoalReached(uint256 minIcoAmount, string notice); event preIcoEnded(uint256 preIcoAmount, string notice); event priceUpdated(uint256 oldPrice, uint256 newPrice, string notice); event withdrawed(address _to, uint256 summe, string notice); event deposited(address _from, uint256 summe, string notice); event orderToTransfer(address initiator, address _from, address _to, uint256 summe, string notice); event tokenCreated(address _creator, uint256 summe, string notice); event tokenDestroyed(address _destroyer, uint256 summe, string notice); event icoStatusUpdated(address _initiator, string status); function STARTMETADOLLAR() { icoIsRunning = true; minimalGoalReached = false; icoIsClosed = false; tokenBalanceOf[this] += _totalSupply; allowed[this][owner] = _totalSupply; allowed[this][supervisor] = _totalSupply; currentTokenPrice = 1 * 1; icoPrice = ethRate * dolRate; sellPrice = sellRate * ethRate; updatePrices(); }",1
0xd73c51ce805c86046577b7b4e5cb2dde14d72a36.sol,EPTCrowdfund,"contract EPTCrowdfund { using SafeMath for uint256; EPTToken public token; address public beneficiaryAddress; address public founderAddress; uint256 public crowdfundStartTime = 1516579201; uint256 public crowdfundEndTime = 1518998399; uint256 public presaleStartTime = 1513123201; uint256 public presaleEndTime = 1516579199; uint256 public ethRaised; bool private tokenDeployed = false; uint256 public tokenSold; uint256 private ethRate; event ChangeFounderAddress(address indexed _newFounderAddress , uint256 _timestamp); event TokenPurchase(address indexed _beneficiary, uint256 _value, uint256 _amount); event CrowdFundClosed(uint256 _timestamp); enum State {PreSale, CrowdSale, Finish}",1
0xdcf67546f2253c9c90c2b55447e1efecebcf83d6.sol,HorseyToken,"contract HorseyToken is EthorseHelpers,Pausable { event Claimed(address raceAddress, address eth_address, uint256 tokenId); event Feeding(uint256 tokenId); event ReceivedCarrot(uint256 tokenId, bytes32 newDna); event FeedingFailed(uint256 tokenId); event HorseyRenamed(uint256 tokenId, string newName); event HorseyFreed(uint256 tokenId); RoyalStablesInterface public stables; uint8 public carrotsMultiplier = 1; uint8 public rarityMultiplier = 1; uint256 public claimingFee = 0.000 ether; struct FeedingData { uint256 blockNumber; uint256 horsey; }",1
0x0193cba9762dfe203a34bd895d0ddf4d876e0f98.sol,UpgradeableToken,"contract UpgradeableToken is Ownable, StandardToken { address public migrationAgent; event Upgrade(address indexed from, address indexed to, uint256 value); event UpgradeAgentSet(address agent); function migrate() public { require(migrationAgent != 0); uint value = balances[msg.sender]; balances[msg.sender] = safeSub(balances[msg.sender], value); totalSupply = safeSub(totalSupply, value); MigrationAgent(migrationAgent).migrateFrom(msg.sender, value); Upgrade(msg.sender, migrationAgent, value); }",1
0x301487766dcf283592b11b5988e5c4e4630dfbe5.sol,EDex,"contract EDex is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x4cf488387f035ff08c371515562cba712f9015d4.sol,WPR,"contract WPR is MintableToken, PausableToken { string constant public name = ; string constant public symbol = ; uint constant public decimals = 18; function WPR() { }",1
0xc4cbb8a3117f0738330fa139ca8ffbb13e8932fc.sol,CrowdsaleCompatible,"contract CrowdsaleCompatible is BasicERC20, Ownable { BasicCrowdsale public crowdsale = BasicCrowdsale(0x0); function unfreezeTokens() public { assert(now > crowdsale.endTime()); isTokenTransferable = true; }",1
0x9ac36892387ed90df9af3de1b7082153f08f3ef8.sol,DSProxy,"contract DSProxy is DSAuth, DSNote { DSProxyCache public cache; constructor(address _cacheAddr) public { require(setCache(_cacheAddr)); }",1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDView,"contract BitSTDView { BitSTDLogic private logic; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function balanceOf(address add)constant public returns (uint256) { return logic.balanceOf(add); }",1
0x74a12ce6eebc23c3f785c0ab50d02228587dcc1a.sol,FrozenToken,"contract FrozenToken is ERC20Token, ITokenRecipient { mapping (address => bool) frozeds; uint256 public frozedCount; bool public freezeEnabled = false; bool public autoFreeze = false; bool public mintFinished = false; event Freeze(address indexed wallet); event UnFreeze(address indexed wallet); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); event Mint(address indexed sender, address indexed wallet, uint256 amount); event ReceiveTokens(address indexed spender, address indexed token, uint256 value, bytes extraData); event ApproveAndCall(address indexed spender, uint256 value, bytes extraData); event Burn(address indexed sender, uint256 amount); event MintFinished(address indexed spender); modifier notFreeze { require(frozeds[msg.sender] == false || freezeEnabled == false); _; }",1
0x284b0f2f49d072836db87dd25d0623cd2f622bb1.sol,DesTokenSale,"contract DesTokenSale is Haltable { using SafeMath for uint; string public name = ; DesToken public token; address public beneficiary; uint public tokensSoldTotal = 0; uint public weiRaisedTotal = 0; uint public investorCount = 0; uint public tokensSelling = 0; uint public tokenPrice = 0; uint public purchaseLimit = 0; event NewContribution(address indexed holder, uint256 tokenAmount, uint256 etherAmount); function DesTokenSale( address _token, address _beneficiary ) { token = DesToken(_token); beneficiary = _beneficiary; }",1
0x655f1cb6616d7f0550007498113e72d7d5c5d4bb.sol,MedalClaim,"contract MedalClaim is AccessControl, SafeMath { address public angelCardDataContract = 0x6D2E76213615925c5fc436565B5ee788Ee0E86DC; address public petCardDataContract = 0xB340686da996b8B3d486b4D27E38E38500A9E926; address public accessoryDataContract = 0x466c44812835f57b736ef9F63582b8a6693A14D0; address public leaderboardDataContract = 0x9A1C755305c6fbf361B4856c9b6b6Bbfe3aCE738; address public medalDataContract = 0x33A104dCBEd81961701900c06fD14587C908EAa3; event EventMedalSuccessful(address owner,uint64 Medal); struct Angel { uint64 angelId; uint8 angelCardSeriesId; address owner; uint16 battlePower; uint8 aura; uint16 experience; }",1
0x1c9db47ee8abad20d28f9bbe2363ca0c8c9ab9b8.sol,Bitsense,"contract BitsenseToken { string internal _symbol; string internal _name; uint8 internal _decimals; uint internal _totalSupply = 1000000000000000; mapping (address => uint) _balanceOf; mapping (address => mapping (address => uint)) internal _allowances; function BitsenseToken(string symbol, string name, uint8 decimals, uint totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; }",1
0x4b96bf1fef93a216914fc843d81207a027ce52b3.sol,VUULRVesting,"contract VUULRVesting is XClaimable, Salvageable { using SafeMath for uint; struct VestingSchedule { uint lockPeriod; uint numPeriods; uint tokens; uint amountWithdrawn; uint startTime; }",1
0xeaba6368d6fa9ed06e569ba5c57f584a329a5152.sol,FlyDropToken,"contract FlyDropToken is Claimable { using SafeMath for uint256; ERC20 internal erc20tk; bytes[] internal approveRecords; event ReceiveApproval(address _from, uint256 _value, address _token, bytes _extraData); function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public { erc20tk = ERC20(_token); require(erc20tk.transferFrom(_from, this, _value)); approveRecords.push(_extraData); ReceiveApproval(_from, _value, _token, _extraData); }",1
0x861a174d677946d8c2bea8f9636a53fde1668215.sol,SmartContractBank,contract SmartContractBank { using SafeMath for uint256; struct Investor { uint256 deposit; uint256 paymentTime; uint256 withdrawals; bool increasedPercent; bool insured; },1
0x5ab793e36070f0fac928ea15826b0c1bc5365119.sol,YUKI,"contract YUKI is ERC223, Ownable, Pausable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 20e9 * 1e8; uint256 public codeSize = 0; bool public mintingFinished = false; address public initialMarketSales = 0x1b879912446d844Fb5915bf4f773F0Db9Cd16ADb; address public incentiveForHolder = 0x0908e3Df5Ed1E67D2AaF38401d4826B2879e8f4b; address public developmentFunds = 0x52F018dc3dd621c8b2D649AC0e22E271a0dE049e; address public marketingFunds = 0x6771a091C97c79a52c8DD5d98A59c5d3B27F99aA; address public organization = 0xD90E1f987252b8EA71ac1cF14465FE9A3803267F; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public cannotSend; mapping (address => bool) public cannotReceive; mapping (address => uint256) public cannotSendUntil; mapping (address => uint256) public cannotReceiveUntil; event FrozenFunds(address indexed target, bool cannotSend, bool cannotReceive); event LockedFunds(address indexed target, uint256 cannotSendUntil, uint256 cannotReceiveUntil); event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintFinished(); constructor() public { owner = msg.sender; balanceOf[initialMarketSales] = totalSupply.mul(45).div(100); balanceOf[incentiveForHolder] = totalSupply.mul(5).div(100); balanceOf[developmentFunds] = totalSupply.mul(20).div(100); balanceOf[marketingFunds] = totalSupply.mul(175).div(1000); balanceOf[organization] = totalSupply.mul(125).div(1000); }",1
0x1f52b87c3503e537853e160adbf7e330ea0be7c4.sol,SaleClockAuction,contract SaleClockAuction is ClockAuction { function SaleClockAuction(uint256 _cut) public ClockAuction(_cut) {},1
0x418d25d31c0a3c5559d8aa0c1c17d9cb3af9f59e.sol,Deposit,contract Deposit is Ownable { using SafeMath for uint256; struct ClientDeposit { uint256 balance; uint256 nextPaymentTotalAmount; uint256 nextPaymentDepositCommission; uint256 nextPaymentPlatformCommission; bool exists; bool isBlocked; },1
0x0da29f924c83b623ea25aa95eedcba060b8d7e12.sol,VeloxCrowdsale,"contract VeloxCrowdsale is Ownable { using SafeMath for uint256; ERC20 public token; uint256 public startTime; uint256 public endTime; uint256 public rate; uint256 public cap; address public wallet; uint256 public sold; constructor( uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _cap, address _wallet, ERC20 _token ) public { require(_startTime >= block.timestamp && _endTime >= _startTime); require(_rate > 0); require(_cap > 0); require(_wallet != address(0)); require(_token != address(0)); startTime = _startTime; endTime = _endTime; rate = _rate; cap = _cap; wallet = _wallet; token = _token; }",1
0xc3e329ca5380c6b416cf095ed1a662c378a2b630.sol,TaurusPay,"contract TaurusPay is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 950 * 10**6 * (10**uint256(decimals)); address public owner; mapping (address => bool) public contractUsers; bool public mintingFinished; uint256 public tokenAllocated = 0; mapping (address => uint) public countClaimsToken; uint256 public priceToken = 950000; uint256 public priceClaim = 0.0005 ether; uint256 public numberClaimToken = 200 * (10**uint256(decimals)); uint256 public startTimeDay = 50400; uint256 public endTimeDay = 51300; event OwnerChanged(address indexed previousOwner, address indexed newOwner); event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event TokenLimitReached(uint256 tokenRaised, uint256 purchasedToken); event MinWeiLimitReached(address indexed sender, uint256 weiAmount); event Mint(address indexed to, uint256 amount); event MintFinished(); constructor(address _owner) public { totalSupply = INITIAL_SUPPLY; owner = _owner; balances[owner] = INITIAL_SUPPLY; transfersEnabled = true; mintingFinished = false; }",1
0xdcf67546f2253c9c90c2b55447e1efecebcf83d6.sol,HorseyToken,"contract HorseyToken is EthorseHelpers,Pausable { event Claimed(address raceAddress, address eth_address, uint256 tokenId); event Feeding(uint256 tokenId); event ReceivedCarrot(uint256 tokenId, bytes32 newDna); event FeedingFailed(uint256 tokenId); event HorseyRenamed(uint256 tokenId, string newName); event HorseyFreed(uint256 tokenId); RoyalStablesInterface public stables; uint8 public carrotsMultiplier = 1; uint8 public rarityMultiplier = 1; uint256 public claimingFee = 0.000 ether; struct FeedingData { uint256 blockNumber; uint256 horsey; }",1
0xa5cc679a3528956e8032df4f03756c077c1ee3f4.sol,Exchange,contract Exchange { function assert(bool assertion) { if (!assertion) throw; },1
0x479cbe1f6a7fa4d7e304ae983803c46e85ced870.sol,Slaughter3D,contract Slaughter3D { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0x723aaf922709819c25344b81901dd8a9c84c0b89.sol,FinalizableCrowdsale,"contract FinalizableCrowdsale is Crowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); function FinalizableCrowdsale(uint32 _startTime, uint32 _endTime, uint _rate, uint _hardCap, address _wallet, address _token) Crowdsale(_startTime, _endTime, _rate, _hardCap, _wallet, _token) { }",1
0x0d49b24f068a9a3ef60576c7a915ffd6844d6fdd.sol,TokenLoot,"contract TokenLoot is Ownable { address neverdieSigner; ERC20 sklToken; ERC20 xpToken; ERC20 goldToken; ERC20 silverToken; ERC20 scaleToken; mapping (address => uint) public nonces; event ReceiveLoot(address indexed sender, uint _amountSKL, uint _amountXP, uint _amountGold, uint _amountSilver, uint _amountScale, uint _nonce); function setSKLContractAddress(address _to) public onlyOwner { sklToken = ERC20(_to); }",1
0x4bc78f6619991b029b867b6d88d39c196332aba3.sol,AlgoDEX,"contract AlgoDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x46cefba4dd7512b2449e1ac4b730bfb7f77d1407.sol,DecentralizedExchangeHotPotato,contract DecentralizedExchangeHotPotato { address private owner; mapping (address => bool) private admins; struct Order { address creator; address owner; address issuer; uint256 tokenId; uint256 price; uint256 startTime; uint256 endTime; },1
0x6dbb4e882f967432fc0f9200e9ca577c916d8a68.sol,Bussiness,contract Bussiness is Ownable { IERC721 public erc721Address = IERC721(0x06012c8cf97bead5deae237070f9587f8e7a266d); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdAC17F958D2ee523a2206206994597C13D831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; uint256 public balance = address(this).balance; constructor() public {},1
0x18f0cd26c06449d967ca6aef8b5f9d8ee9fd7992.sol,Exch,"contract Exch is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; mapping (address => bool) public whiteListERC20; mapping (address => bool) public whiteListERC223; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); modifier onlyAdmin() { require(msg.sender==admin); _; }",1
0x17cba58578eecaee898242a02edac75b8cc17231.sol,AUMXToken,"contract AUMXToken is ERC223, SafeMath{ mapping(address => mapping(address => uint)) allowed; mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 5000000000000000; bool locked; address Owner; address swapperAddress; function AUMXToken() public { locked = true; Owner = msg.sender; swapperAddress = msg.sender; balances[msg.sender] = totalSupply; allowed[msg.sender][swapperAddress] = totalSupply; }",1
0xee91e81927bb047ea0f4b24e43dd5dc0684827a0.sol,BINGToken,contract BINGToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function BINGToken () { owner = msg.sender; },1
0xa2795a7bf26de447a2e83d0779bab6badffb1a3b.sol,DrupeICO,"contract DrupeICORef { address _referrer; DrupeICO _ico; constructor(address referrer, DrupeICO ico) public { _referrer = referrer; _ico = ico; }",1
0x0ce95ef378059f38c5fa21e6d81a5895c0d9911b.sol,Game,contract Game { using GlobalTypes for GlobalTypes.Global; using MarketTypes for MarketTypes.MarketListing; using MissionParametersTypes for MissionParametersTypes.MissionParameters; using GameCommon for GameCommon.LaunchRocketStackFrame; address public m_Owner; AbstractDatabase public m_Database; AbstractGameHidden public m_GameHidden; bool public m_Paused; uint256 constant GlobalCategory = 0; uint256 constant RocketCategory = 1; uint256 constant OwnershipCategory = 2; uint256 constant InventoryCategory = 3; uint256 constant MarketCategory = 4; uint256 constant ProfitFundsCategory = 5; uint256 constant CompetitionFundsCategory = 6; uint256 constant MissionParametersCategory = 7; uint256 constant CompetitionScoresCategory = 8; uint256 constant WithdrawalFundsCategory = 9; uint256 constant ReferralCategory = 10; uint256 constant RocketStockCategory = 11; uint256 constant RocketStockInitializedCategory = 12; address constant NullAddress = 0; uint256 constant MaxCompetitionScores = 10; mapping(uint32 => RocketTypes.StockRocket) m_InitialRockets; modifier OnlyOwner() { require(msg.sender == m_Owner); _; },1
0x02f61fd266da6e8b102d4121f5ce7b992640cf98.sol,LikeCoin,"contract LikeCoin is ERC20, HasOperator { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public supply = 0; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; address public crowdsaleAddr = 0x0; address public contributorPoolAddr = 0x0; uint256 public contributorPoolMintQuota = 0; address[] public creatorsPoolAddrs; mapping(address => bool) isCreatorsPool; uint256 public creatorsPoolMintQuota = 0; mapping(address => uint256) public lockedBalances; uint public unlockTime = 0; SignatureChecker public signatureChecker = SignatureChecker(0x0); bool public signatureCheckerFreezed = false; address public signatureOwner = 0x0; bool public allowDelegate = true; mapping (address => mapping (uint256 => bool)) public usedNonce; mapping (address => bool) public transferAndCallWhitelist; event Lock(address indexed _addr, uint256 _value); event SignatureCheckerChanged(address _newSignatureChecker); function LikeCoin(uint256 _initialSupply, address _signatureOwner, address _sigCheckerAddr) public { supply = _initialSupply; balances[owner] = _initialSupply; signatureOwner = _signatureOwner; signatureChecker = SignatureChecker(_sigCheckerAddr); Transfer(0x0, owner, _initialSupply); }",1
0x733984edbb5890419f82f2b37922a8f5f5c53773.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward; uint256 public price = 1000; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() { wallet = 0xE0F6D3759EcF5A8f8880EFA7F2BD0F54429f5da5; addressOfTokenUsedAsReward = 0x41385664aAd657990000004D3906d1572A6bb4c6; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x0356e14c2f8de339131c668c1747def594467a9a.sol,Club1VIT,"contract Club1VIT is Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 0; uint256 public initialSupply = 1; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to); function totalSupply() public view returns (uint256) { return initialSupply; }",1
0x0da76de0916ef2da3c58a97e4d09d501c56a9f15.sol,Piggy_Bank,"contract Piggy_Bank { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ClockAuction,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x0096dc2246fc3627cc2bf87a3b0d2e0f87b58589.sol,Zethroll,"contract Zethroll is ZTHReceivingContract { using SafeMath for uint; modifier betIsValid(uint _betSize, uint _playerNumber) { require( calculateProfit(_betSize, _playerNumber) < maxProfit && _betSize >= minBet && _playerNumber > minNumber && _playerNumber < maxNumber); _; }",1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0x370f0fe5f1c03892b2dc950a89c6eaff4980dac3.sol,KittenSelfDrop2,"contract KittenSelfDrop2 is Ownable { KittenCoin public kittenContract; uint8 public dropNumber; uint256 public kittensDroppedToTheWorld; uint256 public kittensRemainingToDrop; uint256 public holderAmount; uint256 public basicReward; uint256 public holderReward; mapping (uint8 => uint256[]) donatorReward; uint8 donatorRewardLevels; uint8 public totalDropTransactions; mapping (address => uint8) participants; function KittenSelfDrop2 () { address c = 0xac2BD14654BBf22F9d8f20c7b3a70e376d3436B4; kittenContract = KittenCoin(c); dropNumber = 1; kittensDroppedToTheWorld = 0; kittensRemainingToDrop = 0; basicReward = 50000000000; holderReward = 50000000000; holderAmount = 5000000000000; donatorReward[0]=[1,10000000000]; donatorReward[1]=[1000000000000000,100000000000]; donatorReward[2]=[10000000000000000,500000000000]; donatorRewardLevels = 3; totalDropTransactions = 0; }",1
0x1ac21b27f5683cc87e7cc853d6d4c052b08f0fe4.sol,EthernautsLogic,contract EthernautsLogic is EthernautsOwnership { address public newContractAddress; function EthernautsLogic() public { ceoAddress = msg.sender; ctoAddress = msg.sender; cooAddress = msg.sender; oracleAddress = msg.sender; paused = true; },1
0xa59dee0eb75df81cdca2b3d437d078f4df35e75c.sol,Distribution,"contract Distribution { using SafeMath for uint256; enum State { AwaitingTokens, DistributingNormally, DistributingProRata, Done }",1
0xb4a3fb248d39370c1f8081b73fa7098167c8142b.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }",1
0x17cba58578eecaee898242a02edac75b8cc17231.sol,AUMXToken,"contract AUMXToken is ERC223, SafeMath{ mapping(address => mapping(address => uint)) allowed; mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 5000000000000000; bool locked; address Owner; address swapperAddress; function AUMXToken() public { locked = true; Owner = msg.sender; swapperAddress = msg.sender; balances[msg.sender] = totalSupply; allowed[msg.sender][swapperAddress] = totalSupply; }",1
0x31d4c5be1082a88f2abafea549b6c189c2cf057f.sol,AetherClockAuction,"contract AetherClockAuction is ClockAuction { bool public isAetherClockAuction = true; uint256 public saleCount; uint256[5] public lastSalePrices; function AetherClockAuction(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,GoldBackedToken,"contract GoldBackedToken is Ownable, SafeMath, ERC20, Pausable { event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); event DeductFees(address indexed owner,uint256 amount); event TokenMinted(address destination, uint256 amount); event TokenBurned(address source, uint256 amount); string public name = ; string public symbol = ; uint256 constant public decimals = 18; uint256 constant public hgtDecimals = 8; uint256 constant public allocationPool = 1 * 10**9 * 10**hgtDecimals; uint256 constant public maxAllocation = 38 * 10**5 * 10**decimals; uint256 public totAllocation; address public feeCalculator; address public HGT; function setFeeCalculator(address newFC) onlyOwner { feeCalculator = newFC; }",1
0x5c89736e9454200141b80c37eb28eaceca2ce8cb.sol,CherryToken,"contract CherryToken is ERC223, ERCAddressFrozenFund { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; address public fundsWallet; uint256 internal fundsWalletChanged; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; constructor() public { _symbol = ; _name = ; _decimals = 8; _totalSupply = 10000000000000000; balances[msg.sender] = _totalSupply; fundsWallet = msg.sender; owner = msg.sender; fundsWalletChanged = 0; }",1
0x4bc78f6619991b029b867b6d88d39c196332aba3.sol,AlgoDEX,"contract AlgoDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x6b4df2aa3d64d8dc06120ef4391513e4170af4a7.sol,GeneralTransferManager,contract GeneralTransferManager is ITransferManager { using SafeMath for uint256; address public issuanceAddress = address(0); address public signingAddress = address(0); bytes32 public constant WHITELIST = ; bytes32 public constant FLAGS = ; struct TimeRestriction { uint256 fromTime; uint256 toTime; uint256 expiryTime; bool canBuyFromSTO; },1
0x5c89736e9454200141b80c37eb28eaceca2ce8cb.sol,CherryToken,"contract CherryToken is ERC223, ERCAddressFrozenFund { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; address public fundsWallet; uint256 internal fundsWalletChanged; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; constructor() public { _symbol = ; _name = ; _decimals = 8; _totalSupply = 10000000000000000; balances[msg.sender] = _totalSupply; fundsWallet = msg.sender; owner = msg.sender; fundsWalletChanged = 0; }",1
0x0692de52a966c107021e8a84db8486b4be57ecf1.sol,OQToken,contract OQToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function OQToken () { owner = msg.sender; },1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,LockinManager,contract LockinManager { using SafeMath for uint256; struct Lock { uint256 amount; uint256 unlockDate; uint256 lockedFor; },1
0xdc919494349e803fbd2d4064106944418381edb3.sol,SaiTub,"contract SaiTubEvents { event LogNewCup(address indexed lad, bytes32 cup); }",1
0x922c591cc3a51253953d7006a6f1dc7413670697.sol,RecuringInternetPayer,contract RecuringInternetPayer{ address zac = 0x1F4E7Db8514Ec4E99467a8d2ee3a63094a904e7A; address josh = 0x650a7762FdB32BF64849345209DeaA8F9574cBC7; Token dai = Token(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359); uint constant perSecondDaiParticlePayout = 28935185185185 ; uint amountPaid; uint createdAt; constructor() public { createdAt = now; },1
0xf244176246168f24e3187f7288edbca29267739b.sol,Court,"contract Court is Owned, SafeDecimalMath { Havven public havven; EtherNomin public nomin; uint public minStandingBalance = 100 * UNIT; uint public votingPeriod = 1 weeks; uint constant MIN_VOTING_PERIOD = 3 days; uint constant MAX_VOTING_PERIOD = 4 weeks; uint public confirmationPeriod = 1 weeks; uint constant MIN_CONFIRMATION_PERIOD = 1 days; uint constant MAX_CONFIRMATION_PERIOD = 2 weeks; uint public requiredParticipation = 3 * UNIT / 10; uint constant MIN_REQUIRED_PARTICIPATION = UNIT / 10; uint public requiredMajority = (2 * UNIT) / 3; uint constant MIN_REQUIRED_MAJORITY = UNIT / 2; uint nextMotionID = 1; mapping(uint => address) public motionTarget; mapping(address => uint) public targetMotionID; mapping(uint => uint) public motionStartTime; mapping(uint => uint) public votesFor; mapping(uint => uint) public votesAgainst; mapping(address => mapping(uint => uint)) voteWeight; enum Vote {Abstention, Yea, Nay}",1
0x78a73b6cbc5d183ce56e786f6e905cadec63547b.sol,FabricTokenFundraiser,contract FabricTokenFundraiserConfig is FabricTokenConfig { uint constant CONVERSION_RATE = 9000; uint constant TOKENS_HARD_CAP = 71250 * (10**3) * DECIMALS_FACTOR; uint constant START_DATE = 1518688800; uint constant END_DATE = 1522576800; uint constant TOKENS_LOCKED_CORE_TEAM = 12 * (10**6) * DECIMALS_FACTOR; uint constant TOKENS_LOCKED_ADVISORS = 7 * (10**6) * DECIMALS_FACTOR; uint constant TOKENS_LOCKED_CORE_TEAM_RELEASE_DATE = START_DATE + 1 years; uint constant TOKENS_LOCKED_ADVISORS_RELEASE_DATE = START_DATE + 180 days; uint constant TOKENS_BOUNTY_PROGRAM = 1 * (10**6) * DECIMALS_FACTOR; uint constant MAX_GAS_PRICE = 50000000000 wei; uint constant MIN_CONTRIBUTION = 0.1 ether; uint constant INDIVIDUAL_ETHER_LIMIT = 9 ether; },1
0x6fa883afde9bc8d9bec0fc7bff25db3c71864402.sol,CryptoProgramFactory,contract CryptoProgramFactory { using SafeMath for uint256; address public administrator; uint256 private BASE_PRICE = 0.1 ether; uint256 private BASE_TIME = 4 hours; MemoryFactoryInterface public Memory; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; uint256 public miningWarDeadline; mapping(uint256 => Factory) public factories; mapping(address => bool) public miniGames; struct Factory { uint256 level; uint256 crystals; uint256 programPriceByCrystals; uint256 programPriceByDarkCrystals; uint256 programValue; uint256 eth; uint256 time; },1
0x6593a7140f3718efff638b72a9b6083db47ce0d2.sol,Crowdsale,"contract Crowdsale is GuidedByRoles, ERC20Provider{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 90 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x6593a7140f3718efff638b72a9b6083db47ce0d2.sol,Crowdsale,"contract Crowdsale is GuidedByRoles, ERC20Provider{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 90 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x1a661224edc279a3844ecd8bd0cd715daafb9cf7.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 27820800; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x7eB71add7482F3462BAA46328f58a235E33dbD0e; }",1
0x0ee14f47320604d894fffffc8639772382937bee.sol,OpportyWhiteListHold,contract OpportyWhiteListHold is Ownable { using SafeMath for uint256; OpportyToken public OppToken; struct Holder { bool isActive; uint tokens; uint8 holdPeriod; uint holdPeriodTimestamp; bool withdrawed; },1
0x0297fdbcb9c2023bc05ad44c9f6e69b0ae6261ce.sol,Convert,contract Convert { address owner; address public fromContractAddr; address public toContractAddr; mapping (uint => bool) public isConvert; modifier onlyOwner { require(msg.sender == owner); _; },1
0xed2725cdfc48a24aa71d9b9621d431db0705a55a.sol,ProfitSharing,"contract ProfitSharing is Ownable { using SafeMath for uint256; event DividendDeposited(address indexed _depositor, uint256 _blockNumber, uint256 _amount, uint256 _totalSupply, uint256 _dividendIndex); event DividendClaimed(address indexed _claimer, uint256 _dividendIndex, uint256 _claim); event DividendRecycled(address indexed _recycler, uint256 _blockNumber, uint256 _amount, uint256 _totalSupply, uint256 _dividendIndex); MiniMeToken public token; uint256 public RECYCLE_TIME = 1 years; struct Dividend { uint256 blockNumber; uint256 timestamp; uint256 amount; uint256 claimedAmount; uint256 totalSupply; bool recycled; mapping (address => bool) claimed; }",1
0x5a9e485a792b164007c6c76d15f8fa36c19ca631.sol,Token,"contract Token is Ownable, ERC20Interface, Enums { using SafeMath for uint; string private constant NAME = ; string private constant SYMBOL = ; uint8 private constant DECIMALS = 18; uint public constant MAX_SUPPLY = 3000000000 * (10**uint(DECIMALS)); mapping(address => uint) internal balances; mapping (address => mapping (address => uint)) internal allowed; uint internal _totalSupply; mapping(address => uint) internal etherFunds; uint internal _earnedFunds; mapping(address => bool) internal refunded; address public mintAgent; bool public isMintingFinished = false; uint public mintingStopDate; uint public teamTotal; uint public spentByTeam; WPTokensBaskets public wpTokensBaskets; function Token(WPTokensBaskets baskets) public { wpTokensBaskets = baskets; mintAgent = owner; }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,Court,"contract Court is Owned, SafeDecimalMath { Havven public havven; EtherNomin public nomin; uint public minStandingBalance = 100 * UNIT; uint public votingPeriod = 1 weeks; uint constant MIN_VOTING_PERIOD = 3 days; uint constant MAX_VOTING_PERIOD = 4 weeks; uint public confirmationPeriod = 1 weeks; uint constant MIN_CONFIRMATION_PERIOD = 1 days; uint constant MAX_CONFIRMATION_PERIOD = 2 weeks; uint public requiredParticipation = 3 * UNIT / 10; uint constant MIN_REQUIRED_PARTICIPATION = UNIT / 10; uint public requiredMajority = (2 * UNIT) / 3; uint constant MIN_REQUIRED_MAJORITY = UNIT / 2; uint nextMotionID = 1; mapping(uint => address) public motionTarget; mapping(address => uint) public targetMotionID; mapping(uint => uint) public motionStartTime; mapping(uint => uint) public votesFor; mapping(uint => uint) public votesAgainst; mapping(address => mapping(uint => uint)) voteWeight; enum Vote {Abstention, Yea, Nay}",1
0xc3e329ca5380c6b416cf095ed1a662c378a2b630.sol,TaurusPay,"contract TaurusPay is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 950 * 10**6 * (10**uint256(decimals)); address public owner; mapping (address => bool) public contractUsers; bool public mintingFinished; uint256 public tokenAllocated = 0; mapping (address => uint) public countClaimsToken; uint256 public priceToken = 950000; uint256 public priceClaim = 0.0005 ether; uint256 public numberClaimToken = 200 * (10**uint256(decimals)); uint256 public startTimeDay = 50400; uint256 public endTimeDay = 51300; event OwnerChanged(address indexed previousOwner, address indexed newOwner); event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event TokenLimitReached(uint256 tokenRaised, uint256 purchasedToken); event MinWeiLimitReached(address indexed sender, uint256 weiAmount); event Mint(address indexed to, uint256 amount); event MintFinished(); constructor(address _owner) public { totalSupply = INITIAL_SUPPLY; owner = _owner; balances[owner] = INITIAL_SUPPLY; transfersEnabled = true; mintingFinished = false; }",1
0x1fab9d2996767db0ca6af12fd92c1f2aab2675a0.sol,JackpotHolding,"contract JackpotHolding is ERC223Receiving { uint public payOutNumber = 0; uint public payOutDivisor = 2; ZethrBankrollControllerInterface controller; Zethr zethr; constructor (address _controllerAddress, address _zethrAddress) public { controller = ZethrBankrollControllerInterface(_controllerAddress); zethr = Zethr(_zethrAddress); }",1
0x17f68886d00845867c154c912b4ccc506ec92fc7.sol,DelegatedShareholderAssociation,"contract DelegatedShareholderAssociation is TokenRecipient { uint public minimumQuorum; uint public debatingPeriodInMinutes; Proposal[] public proposals; uint public numProposals; ERC20 public sharesTokenAddress; mapping (address => address) public delegatesByDelegator; mapping (address => uint) public lockedDelegatingTokens; mapping (address => uint) public delegatedAmountsByDelegate; uint public totalLockedTokens; uint public requiredSharesToBeBoardMember; TokenLocker public tokenLocker; event ProposalAdded(uint proposalID, address recipient, uint amount, bytes metadataHash); event Voted(uint proposalID, bool position, address voter); event ProposalTallied(uint proposalID, uint yea, uint nay, uint quorum, bool active); event ChangeOfRules(uint newMinimumQuorum, uint newDebatingPeriodInMinutes, address newSharesTokenAddress); event TokensDelegated(address indexed delegator, uint numberOfTokens, address indexed delegate); event TokensUndelegated(address indexed delegator, uint numberOfTokens, address indexed delegate); struct Proposal { address recipient; uint amount; bytes metadataHash; uint timeCreated; uint votingDeadline; bool finalized; bool proposalPassed; uint numberOfVotes; bytes32 proposalHash; Vote[] votes; mapping (address => bool) voted; }",1
0x02dd48ff449f57a4632c39068e0ca0f4325c3a8d.sol,CB_BANK,"contract CB_BANK { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x5ad9e100bc58e57a20cf1cae204f046006d27a27.sol,CoinCrowdICO,contract CoinCrowdICO is Ownable { using SafeMath for uint256; tokenInterface public tokenContract; uint256 public decimals = 18; uint256 public tokenValue; uint256 public constant centToken = 20; function euroRaised(uint256 _weiTokens) public view returns (uint256) { return _weiTokens.mul(centToken).div(100).div(10**decimals); },1
0x2f5c4a85d7e133c4fefa5a0c0ba1447a1af86996.sol,GetSaiTubValues,contract GetSaiTubValues { SaiTub public saiTub = SaiTub(0x448a5065aeBB8E423F0896E6c5D525C040f59af3); bytes32 public cup; uint public tab; uint public rap; uint public din; uint public chi; uint public rhi; function updateTabRap(bytes32 _cup) public { cup = _cup; tab = saiTub.tab(_cup); rap = saiTub.rap(_cup); },1
0x1aed9d45a8e9a2e790c409c70e3d9261dbe891a2.sol,EthicHubLending,"contract EthicHubLending is EthicHubBase, Ownable, Pausable { using SafeMath for uint256; uint256 public minContribAmount = 0.1 ether; enum LendingState { Uninitialized, AcceptingContributions, ExchangingToFiat, AwaitingReturn, ProjectNotFunded, ContributionReturned, Default }",1
0x0d5eae179709e92b3bff65731158e8291c49eafb.sol,GaintDex,"contract GaintDex is SafeMath { address public admin; address public feeAccount; uint public feeMake; uint public feeTake; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor() { admin = msg.sender; feeAccount = msg.sender; feeMake = 700000000000000; feeTake = 700000000000000; }",1
0x6e9aa27afa93a52b219a3f091c7d600ad32dcc7c.sol,ADTSend1,"contract ADTSend1 { Token public token; event TransferToken(address indexed to, uint256 value); event TransferFromToken(address indexed from,address indexed to, uint256 value); uint i=0; uint256 samount=0; function adTransfer(address source, address[] recipents, uint256[] amount,uint decimals) public { token=Token(source); for(i=0;i<recipents.length;i++) { samount=amount[i]; token.transfer(recipents[i],amount[i]*(10**decimals)); emit TransferToken(recipents[i],samount); }",1
0x74f887f5b336704be1591f8a2f2e419767134316.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; using Address for address; mapping(address => uint256) internal _balances; mapping(address => mapping(address => uint256)) private _allowed; uint256 internal _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0x190646e10b85fbcd631c23c8cd175e25df92c338.sol,EthBattle,"contract EthBattle is Ownable { using SafeMath for uint256; uint256 constant TOKEN_USE_BONUS = 15; uint256 constant REFERRAL_REWARD = 2 ether; uint256 constant MIN_PLAY_AMOUNT = 50 finney; uint256 public roundIndex = 0; mapping(uint256 => address) public rounds; address[] private currentRewardingAddresses; PlaySeedInterface private playSeedGenerator; GTAInterface public token; AMUStoreInterface public store; mapping(address => address) public referralBacklog; mapping(address => uint256) public tokens; event RoundCreated(address createdAddress, uint256 index); event Deposit(address user, uint amount, uint balance); event Withdraw(address user, uint amount, uint balance); function () public payable { getLastRound().getDevWallet().transfer(msg.value); }",1
0x174bb5d84b78e9e2248e7aa2c789aeba82f72f68.sol,LuckyTree,"contract LuckyTree is Owned, SafeMath{ uint public leafPrice; uint public gameStart; uint public gameDuration; uint public tokenLockDuration; uint public totalParticipationAmount; uint public totalLockedAmount; uint public numberOfLeafs; uint public participantIndex; bool public fundsTransfered; address public winner; mapping(uint => address) public participants; mapping(uint => uint) public participationAmount; mapping(address => bool) public hasParticipated; mapping(address => bool) public hasWithdrawn; mapping(address => uint) public participantIndexes; mapping(uint => address) public leafOwners; event GameWinner(address winner); event GameEnded(uint block); event GameStarted(uint block); event GameFailed(uint block); event GameLocked(uint block); event GameUnlocked(uint block); enum state{ pending, running, paused, finished, closed, claimed }",1
0x4900320fe47208de0b79db1273a78ab8c8f3528d.sol,Crowdsale,contract Crowdsale is Owned { using SafeMath for uint256; uint256 public fundingGoal; uint256 public price; uint256 public transferableToken; uint256 public soldToken; uint256 public deadline; uint256 public token_price; MontexToken public tokenReward; bool public fundingGoalReached = false; bool public isOpened; mapping (address => Property) public fundersProperty; struct Property { uint256 paymentEther; uint256 reservedToken; },1
0x29d79f8ac7d22a4b1a5e7630f3d48e8d291d3f11.sol,VULToken,contract VULToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function VULToken () { owner = msg.sender; },1
0x25cf23787ac0f92a3eafa61f458ad0b7c4b27c3d.sol,Zethroll,"contract Zethroll is ZTHReceivingContract { using SafeMath for uint; modifier betIsValid(uint _betSize, uint _playerNumber) { require( calculateProfit(_betSize, _playerNumber) < maxProfit && _betSize >= minBet && _playerNumber > minNumber && _playerNumber < maxNumber); _; }",1
0x74263f99e21db7c38a319e8ed40bfeca2da791f5.sol,CORENET,contract CORENET is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 36000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function CORENET () { owner = msg.sender; },1
0xec841c878435ba4f28bf305a00c1483db0d96a20.sol,Events,contract Events { DBInterface public database; constructor(address _database) public{ database = DBInterface(_database); },1
0x1cdc6b8fe34d313ee45fcd98d7391b6f564069a4.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; token myToken; address public wallet; uint256 public rate = 750000 ; uint256 public weiRaised; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); constructor(address tokenContractAddress, address _walletAddress) public{ wallet = _walletAddress; myToken = token(tokenContractAddress); }",1
0x5819f24d478e4630930bd97d640dd2fdabd0a4ff.sol,BulkToken,contract BulkToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function BulkToken () { owner = msg.sender; },1
0x5c5ddfe49572287c6cb44b99c5daec0dbd7b84f5.sol,Revolution,"contract Revolution is Accessibility, PaymentSystem { using Percent for Percent.percent; using SafeMath for uint; using Zero for *; using ToAddress for *; InvestorsStorage private m_investors; mapping(address => bool) private m_referrals; bool private m_nextWave; address public adminAddr; address public payerAddr; uint public waveStartup; uint public investmentsNum; uint public constant minInvesment = 10 finney; uint public constant maxBalance = 333e5 ether; uint public constant pauseOnNextWave = 168 hours; Percent.percent private m_dividendsPercent = Percent.percent(222, 10000); Percent.percent private m_adminPercent = Percent.percent(1, 10); Percent.percent private m_payerPercent = Percent.percent(7, 100); Percent.percent private m_refPercent = Percent.percent(2, 100); event LogNewInvestor(address indexed addr, uint when, uint value); event LogNewInvesment(address indexed addr, uint when, uint value); event LogNewReferral(address indexed addr, uint when, uint value); event LogPayDividends(address indexed addr, uint when, uint value); event LogPayReferrerBonus(address indexed addr, uint when, uint value); event LogBalanceChanged(uint when, uint balance); event LogAdminAddrChanged(address indexed addr, uint when); event LogPayerAddrChanged(address indexed addr, uint when); event LogNextWave(uint when); modifier balanceChanged { _; emit LogBalanceChanged(now, address(this).balance); }",1
0xbf95d4957d481473e39c70d3bc08896740e3ca96.sol,CvcMigrator,contract CvcMigrator is Ownable { event ProxyCreated(address indexed proxyAddress); struct Migration { address proxy; address implementation; bytes data; },1
0x32c62c965db5fdac0f94e6276d6884070068d4be.sol,MyAdvancedToken,contract MyAdvancedToken { address private constant OWNER = 0xb810aD480cF8e3643031bB36e6A002dC3B1d928e; function isSenderOwner(address sender) private pure returns (bool) { return sender == OWNER; },1
0x69ceaea78e28d62bc1ac68491d77f6a761edce01.sol,MDMCToken,"contract MDMCToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 28650; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0xc767b1cec507f1584469e8efe1a94ad4c75e02ed.sol,PremiumFactories,contract PremiumFactories { Bankroll constant bankroll = Bankroll(0x66a9f1e53173de33bec727ef76afa84956ae1b25); address owner; constructor() public { owner = msg.sender; },1
0x4853cb0e07ab16cb380f8aeda24507779881cdeb.sol,KYC,"contract KYC is Ownerable { mapping (address => bool) public registeredAddress; mapping (address => bool) public admin; event Registered(address indexed _addr); event Unregistered(address indexed _addr); event NewAdmin(address indexed _addr); event ClaimedTokens(address _token, address owner, uint256 balance); modifier onlyRegistered(address _addr) { require(registeredAddress[_addr]); _; }",1
0xc849a5fff9befa297d1c3a772bafac9f3c9004ec.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x6fa883afde9bc8d9bec0fc7bff25db3c71864402.sol,CryptoProgramFactory,contract CryptoProgramFactory { using SafeMath for uint256; address public administrator; uint256 private BASE_PRICE = 0.1 ether; uint256 private BASE_TIME = 4 hours; MemoryFactoryInterface public Memory; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; uint256 public miningWarDeadline; mapping(uint256 => Factory) public factories; mapping(address => bool) public miniGames; struct Factory { uint256 level; uint256 crystals; uint256 programPriceByCrystals; uint256 programPriceByDarkCrystals; uint256 programValue; uint256 eth; uint256 time; },1
0x503a7b43335e035bdfec030d2ef718449d985050.sol,LTToken,"contract LTToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 300; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal pure returns (uint256 ) { return _value * 10 ** decimals; }",1
0x025dce2d39a46296766db7cac8c322e8f59cd5d9.sol,EthToSmthSwaps,contract EthToSmthSwaps { using SafeMath for uint; address public owner; address public ratingContractAddress; uint256 SafeTime = 1 hours; struct Swap { bytes32 secret; bytes20 secretHash; uint256 createdAt; uint256 balance; },1
0x6f8544edb3f513845135b0efa907f4b6b9c2c92e.sol,BW,contract BWData { address public owner; address private bwService; address private bw; address private bwMarket; uint private blockValueBalance = 0; uint private feeBalance = 0; uint private BASE_TILE_PRICE_WEI = 1 finney; mapping (address => User) private users; mapping (uint16 => Tile) private tiles; struct User { uint creationTime; bool censored; uint battleValue; },1
0x46cefba4dd7512b2449e1ac4b730bfb7f77d1407.sol,DecentralizedExchangeHotPotato,contract DecentralizedExchangeHotPotato { address private owner; mapping (address => bool) private admins; struct Order { address creator; address owner; address issuer; uint256 tokenId; uint256 price; uint256 startTime; uint256 endTime; },1
0x2d820ea3a6b9302c500feeb7f6361ba1ddfa5aba.sol,BancorLender,contract BancorLender { struct BorrowAgreement { address lender; address borrower; uint256 tokenAmount; uint256 collateralAmount; uint32 collateralRatio; uint expiration; },1
0x77c9acc811e4cf4b51dc3a3e05dc5d62fa887767.sol,CrryptoArena,contract CrryptoArena { using SafeMath for uint256; address public administrator; uint256 public VIRUS_NORMAL = 0; uint256 public HALF_TIME_ATK= 60 * 15; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public VIRUS_MINING_PERIOD = 86400; address public engineerAddress; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; CryptoProgramFactoryInterface public Factory; mapping(address => Player) public players; mapping(uint256 => Virus) public viruses; mapping(address => bool) public miniGames; struct Player { uint256 virusDef; uint256 nextTimeAtk; uint256 endTimeUnequalledDef; },1
0x6d84769b1e287a27f282a938c8110b22714dbf78.sol,ABIO_preICO,"contract ABIO_preICO is ABIO_BaseICO{ address ICOAddress; ABIO_ICO ICO; uint finalDeadline; constructor(address _abioAddress, uint _lenInMins, uint _minWeiInvestment, address _treasury, uint _priceInWei, uint _goalInWei){ treasury = _treasury; abioToken = ABIO_Token(_abioAddress); weiPerABIO = _priceInWei; fundingGoal = _goalInWei; minInvestment = _minWeiInvestment; startDate = now; length = _lenInMins * 1 minutes; }",1
0x797d713d8d7a2815ccf3dcf9719e3e9f1712c370.sol,Trustee,contract Trustee is Ownable { using SaferMath for uint256; StoxSmartToken public stox; struct Grant { uint256 value; uint256 start; uint256 cliff; uint256 end; uint256 transferred; bool revokable; },1
0x21ad0028fea5fafa55b9b60e9c065db9f1c0616e.sol,LikeCrowdsale,"contract LikeCrowdsale is HasOperator { using SafeMath for uint256; LikeCoin public like = LikeCoin(0x0); uint public start = 0; uint public end = 0; uint256 public coinsPerEth = 0; mapping (address => bool) public kycDone; bool finalized = false; event PriceChanged(uint256 _newPrice); event AddPrivateFund(address indexed _addr, uint256 _value); event RegisterKYC(address indexed _addr); event Purchase(address indexed _addr, uint256 _ethers, uint256 _coins); event LikeTransfer(address indexed _to, uint256 _value); event Finalize(); function LikeCrowdsale(address _likeAddr, uint _start, uint _end, uint256 _coinsPerEth) public { require(_coinsPerEth != 0); require(now < _start); require(_start < _end); owner = msg.sender; like = LikeCoin(_likeAddr); start = _start; end = _end; coinsPerEth = _coinsPerEth; }",1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0x4c13184721de2d1b47a8875775ba3ce0b2e00ee0.sol,SharkPool,"contract SharkPool is Ownable, ReentrancyGuard { string constant public pool_name = ; uint256 public pool_percentage = 5; uint256 constant public max_users = 100; uint256 public total_users = 0; uint256 public constant divisible_units = 10000000; uint256 public contract_period = 100; uint256 public mined_blocks = 1; uint256 public claimed_blocks = 1; uint256 public blockCreationRate = 0; BitcoineumInterface base_contract; struct user { uint256 start_block; uint256 end_block; uint256 proportional_contribution; }",1
0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06.sol,SaleClockAuction,"contract SaleClockAuction is ClockAuction { bool public isSaleClockAuction = true; uint256 public gen0SaleCount; uint256[5] public lastGen0SalePrices; constructor(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0xed3762edcc5820a5587105d7b9f574c711c4a700.sol,FoMo3Dshort,"contract FoMo3Dshort is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xF6b8836492f8332D17B1496828d2bEE71ad511DA); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 public rndExtra_ = 30 minutes; uint256 public rndGap_ = 1 hours; uint256 constant private rndInit_ = 1 hours; uint256 constant private rndInc_ = 5 seconds; uint256 constant private rndMax_ = 10 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(30,6); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(56,10); fees_[3] = F3Ddatasets.TeamFee(43,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); }",1
0x3420894bf786866a09937b0369d5b4781870c21f.sol,LikeCoin,"contract LikeCoin is ERC20, HasOperator { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public supply = 0; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; address public crowdsaleAddr = 0x0; address public contributorPoolAddr = 0x0; uint256 public contributorPoolMintQuota = 0; address[] public creatorsPoolAddrs; mapping(address => bool) isCreatorsPool; uint256 public creatorsPoolMintQuota = 0; mapping(address => uint256) public lockedBalances; uint public unlockTime = 0; SignatureChecker public signatureChecker = SignatureChecker(0x0); bool public signatureCheckerFreezed = false; address public signatureOwner = 0x0; bool public allowDelegate = true; mapping (address => mapping (uint256 => bool)) public usedNonce; mapping (address => bool) public transferAndCallWhitelist; event Lock(address indexed _addr, uint256 _value); event SignatureCheckerChanged(address _newSignatureChecker); function LikeCoin(uint256 _initialSupply, address _signatureOwner, address _sigCheckerAddr) public { supply = _initialSupply; balances[owner] = _initialSupply; signatureOwner = _signatureOwner; signatureChecker = SignatureChecker(_sigCheckerAddr); Transfer(0x0, owner, _initialSupply); }",1
0x301487766dcf283592b11b5988e5c4e4630dfbe5.sol,EDex,"contract EDex is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x0e6457a564fd6780b5a8512707a46c43f3a49ffc.sol,CupExchange,"contract CupExchange { using SafeMath for uint256; using SafeMath for int256; address public owner; token internal teamCup; token internal cup; uint256 public exchangePrice; bool public halting = true; event Halted(bool halting); event Exchange(address user, uint256 distributedAmount, uint256 collectedAmount); constructor(address cupToken, address teamCupToken) public { owner = msg.sender; teamCup = token(teamCupToken); cup = token(cupToken); }",1
0xc5fc544685efd0e5b6cd57d6133522825828cc19.sol,SatoshiToken,"contract SatoshiToken is ERC20Interface, Owned { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; address public parentAddress; uint public miningReward; mapping(address => uint) balances; mapping(address => uint) merge_mint_ious; mapping(address => uint) merge_mint_payout_threshold; mapping(address => mapping(address => uint)) allowed; uint public burnPercent; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); constructor() public onlyOwner { symbol = ; name = ; decimals = 8; _totalSupply = 10000000 * 10 ** uint(decimals); if(locked) revert(); locked = true; tokensMinted = 0; rewardEra = 0; maxSupplyForEra = _totalSupply.div(2); miningTarget = _MAXIMUM_TARGET; latestDifficultyPeriodStarted = block.number; burnPercent = 20; _startNewMiningEpoch(); parentAddress = 0xB6eD7644C69416d67B522e20bC294A9a9B405B31; balances[owner] = balances[owner].add(tokensMinted); Transfer(address(this), owner, tokensMinted); }",1
0x0e69d0a2bbb30abcb7e5cfea0e4fde19c00a8d47.sol,DSStop,"contract DSStop is DSNote, DSAuth { bool public stopped; modifier stoppable { require(!stopped); _; }",1
0x1c9db47ee8abad20d28f9bbe2363ca0c8c9ab9b8.sol,Bitsense,"contract BitsenseToken { string internal _symbol; string internal _name; uint8 internal _decimals; uint internal _totalSupply = 1000000000000000; mapping (address => uint) _balanceOf; mapping (address => mapping (address => uint)) internal _allowances; function BitsenseToken(string symbol, string name, uint8 decimals, uint totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; }",1
0x3420894bf786866a09937b0369d5b4781870c21f.sol,LikeCoin,"contract LikeCoin is ERC20, HasOperator { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public supply = 0; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; address public crowdsaleAddr = 0x0; address public contributorPoolAddr = 0x0; uint256 public contributorPoolMintQuota = 0; address[] public creatorsPoolAddrs; mapping(address => bool) isCreatorsPool; uint256 public creatorsPoolMintQuota = 0; mapping(address => uint256) public lockedBalances; uint public unlockTime = 0; SignatureChecker public signatureChecker = SignatureChecker(0x0); bool public signatureCheckerFreezed = false; address public signatureOwner = 0x0; bool public allowDelegate = true; mapping (address => mapping (uint256 => bool)) public usedNonce; mapping (address => bool) public transferAndCallWhitelist; event Lock(address indexed _addr, uint256 _value); event SignatureCheckerChanged(address _newSignatureChecker); function LikeCoin(uint256 _initialSupply, address _signatureOwner, address _sigCheckerAddr) public { supply = _initialSupply; balances[owner] = _initialSupply; signatureOwner = _signatureOwner; signatureChecker = SignatureChecker(_sigCheckerAddr); Transfer(0x0, owner, _initialSupply); }",1
0xef86db910c71ffa3c80233bc9108dc51ad1e008a.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0x0045684552109f8551cc5c8aa7b1f52085adff47.sol,BaseWallet,"contract BaseWallet { address public implementation; address public owner; mapping (address => bool) public authorised; mapping (bytes4 => address) public enabled; uint public modules; event AuthorisedModule(address indexed module, bool value); event EnabledStaticCall(address indexed module, bytes4 indexed method); event Invoked(address indexed module, address indexed target, uint indexed value, bytes data); event Received(uint indexed value, address indexed sender, bytes data); event OwnerChanged(address owner); modifier moduleOnly { require(authorised[msg.sender], ); _; }",1
0x25066b77ae6174d372a9fe2b1d7886a2be150e9b.sol,PolarisDEX,"contract PolarisDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); function PolarisDEX(address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,EtherNomin,"contract EtherNomin is ExternStateProxyFeeToken { address public oracle; Court public court; address public beneficiary; uint public nominPool; uint public poolFeeRate = UNIT / 200; uint constant MINIMUM_PURCHASE = UNIT / 100; uint constant MINIMUM_ISSUANCE_RATIO = 2 * UNIT; uint constant AUTO_LIQUIDATION_RATIO = UNIT; uint constant DEFAULT_LIQUIDATION_PERIOD = 90 days; uint constant MAX_LIQUIDATION_PERIOD = 180 days; uint public liquidationPeriod = DEFAULT_LIQUIDATION_PERIOD; uint public liquidationTimestamp = ~uint(0); uint public etherPrice; uint public lastPriceUpdate; uint public stalePeriod = 2 days; mapping(address => bool) public frozen; function EtherNomin(address _havven, address _oracle, address _beneficiary, uint initialEtherPrice, address _owner, TokenState initialState) ExternStateProxyFeeToken(, , 15 * UNIT / 10000, _havven, initialState, _owner) public { oracle = _oracle; beneficiary = _beneficiary; etherPrice = initialEtherPrice; lastPriceUpdate = now; emit PriceUpdated(etherPrice); frozen[this] = true; }",1
0x325f89386b72087530440e0bceb8490d78b47f21.sol,EtherStore,contract EtherStore is Managable{ bool public WrapperisEnabled; address public EtherWrapper; modifier WrapperEnabled{ require(WrapperisEnabled); _; },1
0x182f2b554462230735699df74ec9606a3c4c0684.sol,BookERC20EthV1Dec,contract BookERC20EthV1Dec { enum BookType { ERC20EthV1 },1
0x6c26dab04c8f2bb07e60f205118e36850fe90981.sol,PoWMLottery,contract PoWMLottery { using SafeMath for uint256; bool public isLotteryOpen = false; address POWM_address = address(0xA146240bF2C04005A743032DC0D241ec0bB2BA2B); POWM maths = POWM(POWM_address); address owner; mapping (uint256 => address) public gamblers; mapping (address => uint256) public token_buyins; mapping (address => uint256) public last_round_bought; uint256 public num_tickets_current_round = 0; uint256 public current_round = 0; uint256 public numTokensInLottery = 0; address masternode_referrer; uint256 public MAX_TOKEN_BUYIN = 25; function PoWMLottery() public { current_round = 1; owner = msg.sender; masternode_referrer = msg.sender; },1
0x6e82aabffe24f275ad3f703aca922dd4d8f86168.sol,BatchTransfer,"contract BatchTransfer is Ownable { using SafeMath for uint256; event Withdraw(address indexed receiver, address indexed token, uint amount); event TransferEther(address indexed sender, address indexed receiver, uint256 amount); modifier checkArrayArgument(address[] _receivers, uint256[] _amounts) { require(_receivers.length == _amounts.length && _receivers.length != 0); _; }",1
0xd518db222f37f9109db8e86e2789186c7e340f12.sol,D_BANK,contract D_BANK { mapping (address=>uint256) public balances; uint public MinSum = 1 ether; LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46); bool intitalized; function SetMinSum(uint _val) public { if(intitalized)revert(); MinSum = _val; },1
0x56853ab9006e0712b05c68b586372fcdde5236b9.sol,AirDrop,"contract AirDrop is Ownable { Token token; event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); modifier whenDropIsActive() { assert(isActive()); _; }",1
0x702bcee7f521060eacde63e487a4c36ef7405f50.sol,PLAASCrowdsale,"contract PLAASCrowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward; uint256 public price = 1000; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PLAASCrowdsale() { wallet = 0xA8dd9A671d64DB4380AcA5af8976aE6F863fF169; addressOfTokenUsedAsReward = 0x8d9626315e8025b81c3bdb926db4c51dde237f52; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x4d066feb188ee4582147d82cb901277425432aa7.sol,DOWCrowdfund,"contract DOWCrowdfund { using SafeMath for uint256; DOWToken public token; uint256 public crowdfundStartTime; uint256 public crowdfundEndTime; uint256 public totalWeiRaised; uint256 public weekOneRate = 3000; uint256 public weekTwoRate = 2000; uint256 public weekThreeRate = 1500; uint256 public weekFourthRate = 1200; uint256 minimumFundingGoal = 5000 * 1 ether; uint256 MAX_FUNDING_GOAL = 400000 * 1 ether; uint256 public totalDowSold = 0; address public owner = 0x0; bool internal isTokenDeployed = false; address public founderMultiSigAddress; address public remainingTokenHolder; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event CrowdFundClosed(uint256 _blockTimeStamp); event ChangeFoundersWalletAddress(uint256 _blockTimeStamp, address indexed _foundersWalletAddress); modifier tokenIsDeployed() { require(isTokenDeployed == true); _; }",1
0xc58f1f3ec051b51f10c4feb0cfd10d811d055ef5.sol,ldoh,"contract ldoh is EthereumSmartContract { event onCashbackCode (address indexed hodler, address cashbackcode); event onAffiliateBonus (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onClaimTokens (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onHoldplatform (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onAddContractAddress(address indexed contracthodler, bool contractstatus, uint256 _maxcontribution, string _ContractSymbol, uint256 _PercentPermonth, uint256 _HodlingTime); event onHoldplatformsetting(address indexed Tokenairdrop, bool HPM_status, uint256 HPM_divider, uint256 HPM_ratio, uint256 datetime); event onHoldplatformdeposit(uint256 amount, uint256 newbalance, uint256 datetime); event onHoldplatformwithdraw(uint256 amount, uint256 newbalance, uint256 datetime); event onReceiveAirdrop(uint256 amount, uint256 datetime); address public DefaultToken; struct Safe { uint256 id; uint256 amount; uint256 endtime; address user; address tokenAddress; string tokenSymbol; uint256 amountbalance; uint256 cashbackbalance; uint256 lasttime; uint256 percentage; uint256 percentagereceive; uint256 tokenreceive; uint256 lastwithdraw; address referrer; bool cashbackstatus; }",1
0x5c89736e9454200141b80c37eb28eaceca2ce8cb.sol,CherryToken,"contract CherryToken is ERC223, ERCAddressFrozenFund { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; address public fundsWallet; uint256 internal fundsWalletChanged; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; constructor() public { _symbol = ; _name = ; _decimals = 8; _totalSupply = 10000000000000000; balances[msg.sender] = _totalSupply; fundsWallet = msg.sender; owner = msg.sender; fundsWalletChanged = 0; }",1
0xd518db222f37f9109db8e86e2789186c7e340f12.sol,D_BANK,contract D_BANK { mapping (address=>uint256) public balances; uint public MinSum = 1 ether; LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46); bool intitalized; function SetMinSum(uint _val) public { if(intitalized)revert(); MinSum = _val; },1
0xcdf35c3fe4ccfacb3b1bbedfe71ca3a5ff6f2db1.sol,AdvisorsTokensHolder,"contract AdvisorsTokensHolder is Ownable { using SafeMath for uint256; GenericCrowdsale crowdsale; MyDFSToken token; event ClaimedTokens(address token, uint256 amount); event TokensWithdrawn(address holder, uint256 amount); function AdvisorsTokensHolder(address _crowdsale, address _token, address _owner) public { crowdsale = GenericCrowdsale(_crowdsale); token = MyDFSToken(_token); owner = _owner; }",1
0x6d7efeb3df42e6075fa7cf04e278d2d69e26a623.sol,LuckyYouToken,contract LuckyYouToken is PausableToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; constructor() public{ totalSupply = 1 * 1000 * 1000 * 1000 * (10 ** uint256(decimals)); balances[owner] = totalSupply; },1
0x89dd662cc0651a6f3631a617724525f2ff373b1e.sol,WPR,"contract WPR is MintableToken, PausableToken { string constant public name = ; string constant public symbol = ; uint constant public decimals = 18; function WPR() { }",1
0x32c62c965db5fdac0f94e6276d6884070068d4be.sol,MyAdvancedToken,contract MyAdvancedToken { address private constant OWNER = 0xb810aD480cF8e3643031bB36e6A002dC3B1d928e; function isSenderOwner(address sender) private pure returns (bool) { return sender == OWNER; },1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x3a715f7ee68d8d7b105f9cabd972f76cb8ea0710.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 30153600; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x5555A8C016F5D2948e27BAe7633Deea24b552FC1; }",1
0xef86db910c71ffa3c80233bc9108dc51ad1e008a.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0x922c591cc3a51253953d7006a6f1dc7413670697.sol,RecuringInternetPayer,contract RecuringInternetPayer{ address zac = 0x1F4E7Db8514Ec4E99467a8d2ee3a63094a904e7A; address josh = 0x650a7762FdB32BF64849345209DeaA8F9574cBC7; Token dai = Token(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359); uint constant perSecondDaiParticlePayout = 28935185185185 ; uint amountPaid; uint createdAt; constructor() public { createdAt = now; },1
0x0d5eae179709e92b3bff65731158e8291c49eafb.sol,GaintDex,"contract GaintDex is SafeMath { address public admin; address public feeAccount; uint public feeMake; uint public feeTake; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor() { admin = msg.sender; feeAccount = msg.sender; feeMake = 700000000000000; feeTake = 700000000000000; }",1
0xeae2e3259d6d56451f4b3bc957ffbfcfaaebcac4.sol,CrowdsaleCompatible,"contract CrowdsaleCompatible is BasicERC20, Ownable { BasicCrowdsale public crowdsale = BasicCrowdsale(0x0); function unfreezeTokens() public { assert(now > crowdsale.endTime()); isTokenTransferable = true; }",1
0x32f1c992a32376fa0f723aecaa247119d3f7f8bd.sol,Zethroll,"contract Zethroll is ZTHReceivingContract { using SafeMath for uint; modifier betIsValid(uint _betSize, uint _playerNumber) { require( calculateProfit(_betSize, _playerNumber) < maxProfit && _betSize >= minBet && _playerNumber > minNumber && _playerNumber < maxNumber); _; }",1
0x407b419144822e236d960e87e3c58c64feb715b8.sol,PlatinToken,"contract PlatinToken is HoldersToken, NoOwner, Authorizable, Pausable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; struct Lockup { uint256 release; uint256 amount; }",1
0x29880855d419c6fa0e8c7fdfd985c80f286d914e.sol,DadiPublicSale,contract DadiPublicSale is Ownable { using SafeMath for uint256; StandardToken public token; uint256 public tokenSupply; uint256 public tokensPurchased = 0; uint256 public individualCap = 5000 * 1000; uint256 public tokenPrice = 500; uint256 public ethRate; uint256 public maxGasPrice; address[] public saleWallets; mapping(address => Investor) private investors; address[] private investorIndex; struct Investor { uint256 tokens; uint256 contribution; bool distributed; uint index; },1
0xc3e329ca5380c6b416cf095ed1a662c378a2b630.sol,TaurusPay,"contract TaurusPay is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 950 * 10**6 * (10**uint256(decimals)); address public owner; mapping (address => bool) public contractUsers; bool public mintingFinished; uint256 public tokenAllocated = 0; mapping (address => uint) public countClaimsToken; uint256 public priceToken = 950000; uint256 public priceClaim = 0.0005 ether; uint256 public numberClaimToken = 200 * (10**uint256(decimals)); uint256 public startTimeDay = 50400; uint256 public endTimeDay = 51300; event OwnerChanged(address indexed previousOwner, address indexed newOwner); event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event TokenLimitReached(uint256 tokenRaised, uint256 purchasedToken); event MinWeiLimitReached(address indexed sender, uint256 weiAmount); event Mint(address indexed to, uint256 amount); event MintFinished(); constructor(address _owner) public { totalSupply = INITIAL_SUPPLY; owner = _owner; balances[owner] = INITIAL_SUPPLY; transfersEnabled = true; mintingFinished = false; }",1
0x1fab9d2996767db0ca6af12fd92c1f2aab2675a0.sol,JackpotHolding,"contract JackpotHolding is ERC223Receiving { uint public payOutNumber = 0; uint public payOutDivisor = 2; ZethrBankrollControllerInterface controller; Zethr zethr; constructor (address _controllerAddress, address _zethrAddress) public { controller = ZethrBankrollControllerInterface(_controllerAddress); zethr = Zethr(_zethrAddress); }",1
0x292d448b46f5419387e3886e89680ed4b7d62d09.sol,RegistrationBonus,"contract RegistrationBonus is Ownable { address public tokenAddr; uint256 constant bonusAmount = 1 * 1 ether; mapping (address => uint) public beneficiaryAddresses; mapping (uint => address) public beneficiaryUserIds; AbstractMintableToken token; event BonusEnrolled(address beneficiary, uint userId, uint256 amount); function RegistrationBonus(address _token){ tokenAddr = _token; token = AbstractMintableToken(tokenAddr); }",1
0x0f067ddb0795a7627c18a5792ed0a2199de3a8c2.sol,HUMPresale,"contract HUMPresale is WhitelistedCrowdsale, IndividuallyCappedCrowdsale { uint256 public constant minimum = 100000000000000000; bool public isOnSale = false; mapping(address => uint256) public bonusTokens; uint256 public bonusPercent; address[] public contributors; event DistrubuteBonusTokens(address indexed sender); event Withdraw(address indexed _from, uint256 _amount); constructor ( uint256 _rate, uint256 _bonusPercent, address _wallet, HUMToken _token, uint256 _individualCapEther ) public Crowdsale(_rate, _wallet, _token) IndividuallyCappedCrowdsale(_individualCapEther.mul(10 ** 18)) { bonusPercent = _bonusPercent; }",1
0xeb86a173e0311a28cadc24f85dbad867bbf34f73.sol,Bussiness,contract Bussiness is Ownable { address public ceoAddress = address(0x6c3e879bdd20e9686cfd9bbd1bfd4b2dd6d47079); IERC721 public erc721Address = IERC721(0xdceaf1652a131f32a821468dc03a92df0edd86ea); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdac17f958d2ee523a2206206994597c13d831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; constructor() public {},1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x6f8544edb3f513845135b0efa907f4b6b9c2c92e.sol,BW,contract BWData { address public owner; address private bwService; address private bw; address private bwMarket; uint private blockValueBalance = 0; uint private feeBalance = 0; uint private BASE_TILE_PRICE_WEI = 1 finney; mapping (address => User) private users; mapping (uint16 => Tile) private tiles; struct User { uint creationTime; bool censored; uint battleValue; },1
0x3ac86159fad58c90aaea1c61974d69d4f8ce8e77.sol,Crowdsale,contract Crowdsale is Ownable { using SafeMath for uint256; SingleTokenCoin public token; WrapperOraclize private wrapper = WrapperOraclize(0xfC484c66daE464CC6055d7a4782Ec8761dc9842F); uint256 private angel_sale_start; uint256 private angel_sale_finish; uint256 private pre_sale_start; uint256 private pre_sale_finish; uint256 private public_sale_start; uint256 private public_sale_finish; bool private isAngel; bool private isPreSale; bool private isPublic; uint256 private angel_rate; uint256 private public_rate; uint256 private decimals; uint256 private totalETH; address public coreTeamAddr; address public itDevAddr; address public futDevAddr; address public commFoundAddr; address public socWarefareAddr; address public marketingAddr; address public unsoldAddr; address public collectAddr; bool public mintingFinished = false; mapping(address => uint256) private founding_buyers_token; mapping(address => uint256) private angel_buyers_eth; mapping(address => uint256) private angel_buyers_token; mapping(address => uint256) private pre_sale_buyers_eth; mapping(address => uint256) private pre_sale_buyers_token; mapping(address => uint256) private pe_buyers_token; mapping(address => uint256) private public_buyers_eth; mapping(address => uint256) private public_buyers_token; address[] private founding_investors; address[] private pre_sale_investors; address[] private angel_investors; address[] private pe_investors; address[] private public_investors; uint256 private soldTokens; uint256 private maxcup; uint256 private totalAmount; uint256 private foundingAmount; uint256 private angelAmount; uint256 private preSaleAmount; uint256 private PEInvestorAmount; uint256 private publicSaleAmount; uint256 private coreTeamAmount; uint256 private coreTeamAuto; uint256 private coreTeamManual; uint256 private itDevAmount; uint256 private futDevAmount; uint256 private commFoundAmount; uint256 private socWarefareAmount; uint256 private marketingAmount; uint256 private angel_sale_sold; uint256 private pre_sale_sold; uint256 private public_sale_sold; uint256 private founding_sold; uint256 private peInvestors_sold; uint256 private angel_sale_totalETH; uint256 private pre_sale_totalETH; uint256 private public_sale_totalETH; uint256 private firstPhaseAmount; uint256 private secondPhaseAmount; uint256 private thirdPhaseAmount; uint256 private fourPhaseAmount; uint256 private firstPhaseDiscount; uint256 private secondPhaseDiscount; uint256 private thirdPhaseDiscount; uint256 private fourPhaseDiscount; uint256 private currentPhase; bool private moveTokens; bool withdrowTokensComplete = false; function Crowdsale(address token_addr) { token = SingleTokenCoin(token_addr); public_rate = 3546099290780141; angel_rate = 20; decimals = 35460992907801; angel_sale_start = now - 3 days; angel_sale_finish = 1510488000; pre_sale_start = 1510491600; pre_sale_finish = 1512561600; public_sale_start = 1512565200; public_sale_finish = public_sale_start + 14 days; moveTokens = false; isAngel = true; isPreSale = false; isPublic = false; currentPhase = 1; founding_sold = 0; peInvestors_sold = 0; angel_sale_sold = 0; pre_sale_sold = 0; public_sale_sold = 0; angel_sale_totalETH = 0; pre_sale_totalETH = 0; public_sale_totalETH = 0; firstPhaseAmount = 18750000E18; secondPhaseAmount = 37500000E18; thirdPhaseAmount = 56250000E18; fourPhaseAmount = 75000000E18; firstPhaseDiscount = 30; secondPhaseDiscount = 40; thirdPhaseDiscount = 50; fourPhaseDiscount = 60; totalAmount = 500000000E18; foundingAmount = 10000000E18; angelAmount = 25000000E18; preSaleAmount = 75000000E18; PEInvestorAmount = 50000000E18; publicSaleAmount = 100000000E18; coreTeamAmount = 100000000E18; coreTeamAuto = 60000000E18; coreTeamManual = 40000000E18; itDevAmount = 50000000E18; futDevAmount = 50000000E18; commFoundAmount = 15000000E18; socWarefareAmount = 10000000E18; marketingAmount = 15000000E18; mintingFinished = false; coreTeamAddr = 0xB0A3A845cfA5e2baCD3925Af85c59dE4D32D874f; itDevAddr = 0x61528ffdCd4BC26c81c88423018780b399Fbb8e7; futDevAddr = 0xA1f9C3F137496e6b8bA4445d15b0986CaA22FDe3; commFoundAddr = 0xC30a0E7FFad754A9AD2A1C1cFeB10e05f7C7aB6A; socWarefareAddr = 0xd5d692C89C83313579d02C94F4faE600fe30D1d9; marketingAddr = 0x5490510072b929273F65dba4B72c96cd45A99b5A; unsoldAddr = 0x18051b5b0F1FDb4D44eACF2FA49f19bB80105Fc1; collectAddr = 0xB338121B8e5dA0900a6E8580321293f3CF52E58D; },1
0x3395465cb04b8ebd2ae2647cf37bcb2384d71d49.sol,Auction,contract Auction is Beneficial { function Auction() Beneficial() public { owner = msg.sender; shareholder = msg.sender; },1
0xd1569ffd7ca4393311f66110e6f87184c4817113.sol,LudumAirdrop,"contract LudumAirdrop is Ownable { Token token; event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); modifier whenDropIsActive() { assert(isActive()); _; }",1
0x0e752b742f744fdc2d93774da44c37b72c3e6952.sol,CraftyCrowdsale,"contract CraftyCrowdsale is Pausable { using SafeMath for uint256; mapping(address => uint256) received; MintableToken public token; uint256 public preSaleStart; uint256 public preSaleEnd; uint256 public saleStart; uint256 public saleEnd; uint256 public issuedTokens = 0; uint256 public constant hardCap = 5000000000 * 10**8; uint256 constant teamCap = 1450000000 * 10**8; uint256 constant advisorCap = 450000000 * 10**8; uint256 constant bountyCap = 100000000 * 10**8; uint256 constant fundCap = 3000000000 * 10**8; uint256 constant lockTime = 180 days; address public etherWallet; address public teamWallet; address public advisorWallet; address public fundWallet; address public bountyWallet; TokenTimelock teamTokens; uint256 public rate; enum State { BEFORE_START, SALE, REFUND, CLOSED }",1
0x6d4106c5c6cddeb5e0bbda23c4555a45dfaa92d7.sol,CucuSale,"contract CucuSale { address public beneficiary; uint public amountRaised; uint public price; uint public dynamicLocktime; uint public globalLocktime; uint public lockType = 0; token public tokenReward; uint public exchangeRate; mapping(address => uint256) public balanceOf; mapping(address => uint256) public tokenBalanceOf; mapping(address => uint256) public timelocksOf; address[] public founders; address public owner; event FundTransfer(address backer, uint amount, uint exchangeRate, uint token, uint time, uint timelock, bool isContribution); event IsCharged(bool isCharged); event TokensClaimed(address founder, uint tokens); event TransferOwnership(); event ChangeExchangeRate(uint oldExchangeRate, uint newExchangeRate); event NewGlobalLocktime(uint timelockUntil); event NewDynamicLocktime(uint timelockUntil); uint public tokenAvailable = 0; bool public charged = false; uint lastActionId = 0; constructor( address _beneficiary, address _addressOfTokenUsedAsReward, uint _globalLocktime, uint _dynamicLocktime, uint _exchangeRate ) public { beneficiary = _beneficiary; dynamicLocktime = _dynamicLocktime; tokenReward = token(_addressOfTokenUsedAsReward); globalLocktime = now + _globalLocktime * 1 minutes; exchangeRate = _exchangeRate; owner = msg.sender; }",1
0x6543cde961213e82001594bf4c34706579ce34ec.sol,ClinicAllCrowdsale,"contract ClinicAllCrowdsale is Crowdsale, FinalizableCrowdsale, MintedCrowdsale, ManagedWhitelist, Limited { constructor ( uint256 _tokenLimitSupply, uint256 _rate, address _wallet, address _privateSaleWallet, ERC20 _token, uint256 _openingTime, uint256 _closingTime, uint256 _discountTokenAmount, uint256 _discountTokenPercent, uint256 _preSaleClosingTime, uint256 _softCapLimit, ClinicAllRefundEscrow _vault, uint256 _buyLimitSupplyMin, uint256 _buyLimitSupplyMax, uint256 _kycLimitEliminator ) Crowdsale(_rate, _wallet, _token) TimedCrowdsale(_openingTime, _closingTime) public { privateSaleWallet = _privateSaleWallet; tokenSupplyLimit = _tokenLimitSupply; discountTokenAmount = _discountTokenAmount; discountTokenPercent = _discountTokenPercent; preSaleClosingTime = _preSaleClosingTime; softCapLimit = _softCapLimit; vault = _vault; buyLimitSupplyMin = _buyLimitSupplyMin; buyLimitSupplyMax = _buyLimitSupplyMax; kycLimitEliminator = _kycLimitEliminator; }",1
0x3a266f97425cd281c1770b71662fcf4415c29190.sol,CryptoProgramFactory,contract CryptoProgramFactory { bool status = false; using SafeMath for uint256; address public administrator; uint256 private BASE_PRICE = 0.1 ether; uint256 private BASE_TIME = 4 hours; MemoryFactoryInterface public Memory; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; mapping(uint256 => Factory) public factories; mapping(address => bool) public miniGames; struct Factory { uint256 level; uint256 crystals; uint256 programPriceByCrystals; uint256 programPriceByDarkCrystals; uint256 programValue; uint256 eth; uint256 time; },1
0x4c129783b42833220ad57d48548f871189009d3f.sol,HoQuBurner,"contract HoQuBurner is Ownable { using SafeMath for uint256; HoQuToken public token; mapping(address => uint256) public claimed; mapping(uint32 => address) public transactionAddresses; mapping(uint32 => uint256) public transactionAmounts; uint32 public transactionsCount; event TokenBurned(address indexed _sender, uint256 _tokens); function HoQuBurner(address _tokenAddress) { token = HoQuToken(_tokenAddress); }",1
0xbd3476e32de1077e049d0c4767c650230be38bda.sol,Airdrop,"contract Airdrop is Ownable, Destroyable { using SafeMath for uint256; struct Beneficiary { uint256 balance; uint256 airdrop; bool isBeneficiary; }",1
0x6dbc5978711cb22d7ba611bc18cec308ea12ea95.sol,PublicResolver,"contract PublicResolver { bytes4 constant INTERFACE_META_ID = 0x01ffc9a7; bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de; bytes4 constant NAME_INTERFACE_ID = 0x691f3431; bytes4 constant ABI_INTERFACE_ID = 0x2203ab56; bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233; bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c; bytes4 constant MULTIADDR_INTERFACE_ID = 0x4cb7724c; event AddrChanged(bytes32 indexed node, address a); event NameChanged(bytes32 indexed node, string name); event ABIChanged(bytes32 indexed node, uint256 indexed contentType); event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y); event TextChanged(bytes32 indexed node, string indexedKey, string key); event MultiaddrChanged(bytes32 indexed node, bytes addr); struct PublicKey { bytes32 x; bytes32 y; }",1
0x6593a7140f3718efff638b72a9b6083db47ce0d2.sol,Crowdsale,"contract Crowdsale is GuidedByRoles, ERC20Provider{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 90 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0xf08a7fd4f4b75188e89d0d27c2ae474858402cea.sol,DroneShowCoinICOContract,"contract DroneShowCoinICOContract is Ownable { using SafeMath for uint256; Token token; uint256 public constant RATE = 650; uint256 public constant CAP = 15000; uint256 public constant START = 1510754400; uint256 public constant DAYS = 30; bool public initialized = false; uint256 public raisedAmount = 0; uint256 public bonusesGiven = 0; uint256 public numberOfTransactions = 0; event BoughtTokens(address indexed to, uint256 value); modifier whenSaleIsActive() { assert (isActive()); _; }",1
0x846387983cae97bc816edde9f309f25d09203e04.sol,WGWToken,contract WGWToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 2150400000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function WGWToken () { owner = msg.sender; },1
0x18da8521c333aed9de8f512e847734cb7be42e38.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0xc81ec8a2a711e96d977a48252ac694e1d4b5719d.sol,GTCoin,"contract GTCoin is Token(, , 18, 100000000000000000000000000), ERC20, ERC223 { using SafeMath for uint; function GTCoin() public { _balanceOf[msg.sender] = _totalSupply; }",1
0x0d853d20b54b8abfacb05fc5e81e8d4395021c01.sol,LxtBountyDistribution,contract LxtBountyDistribution is owned { using SafeMath for uint; LexitToken public LXT; address public LXT_OWNER; uint256 private constant decimalFactor = 10**uint256(18); uint256 public grandTotalClaimed = 0; struct Allocation { uint256 totalAllocated; uint256 amountClaimed; },1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,LockinManager,contract LockinManager { using SafeMath for uint256; struct Lock { uint256 amount; uint256 unlockDate; uint256 lockedFor; },1
0xe3818504c1b32bf1557b16c238b2e01fd3149c17.sol,UnsoldAllocation,"contract UnsoldAllocation is Ownable { using SafeMath for uint; uint unlockedAt; uint allocatedTokens; PillarToken plr; mapping (address => uint) allocations; uint tokensCreated = 0; function UnsoldAllocation(uint _lockTime, address _owner, uint _tokens) { if(_lockTime == 0) throw; if(_owner == address(0)) throw; plr = PillarToken(msg.sender); uint lockTime = _lockTime * 1 years; unlockedAt = now.add(lockTime); allocatedTokens = _tokens; allocations[_owner] = _tokens; }",1
0x30d62b3392520580ffc74d7326bb29a4bf541a4d.sol,TerraformReserve,"contract TerraformReserve is Ownable { mapping (address => uint256) public lockedBalance; uint public totalLocked; ERC20 public manaToken; address public landClaim; bool public acceptingDeposits; event LockedBalance(address user, uint mana); event LandClaimContractSet(address target); event LandClaimExecuted(address user, uint value, bytes data); event AcceptingDepositsChanged(bool _acceptingDeposits); function TerraformReserve(address _token) { require(_token != 0); manaToken = ERC20(_token); acceptingDeposits = true; }",1
0x9ac36892387ed90df9af3de1b7082153f08f3ef8.sol,DSProxyFactory,"contract DSProxyFactory { event Created(address indexed sender, address indexed owner, address proxy, address cache); mapping(address=>bool) public isProxy; DSProxyCache public cache = new DSProxyCache(); function build() public returns (DSProxy proxy) { proxy = build(msg.sender); }",1
0x5225f66168cc9c145b885d7af72054b52dbe1a0f.sol,OwnerContract,contract OwnerContract is Claimable { Claimable public ownedContract; address internal origOwner; function bindContract(address _contract) onlyOwner public returns (bool) { require(_contract != address(0)); ownedContract = Claimable(_contract); origOwner = ownedContract.owner(); ownedContract.claimOwnership(); return true; },1
0x1b6c5864375b34af3ff5bd2e5f40bc425b4a8d79.sol,TopChainCoinDistribution,"contract TopChainCoinDistribution is Ownable, Authorizable { using SafeMath for uint; event AuthorizedCreateToPrivate(address recipient, uint pay_amount); event GameMining(address recipient, uint pay_amount); event CreateTokenToTeam(address recipient, uint pay_amount); event CreateTokenToMarket(address recipient, uint pay_amount); event CreateTokenToOperation(address recipient, uint pay_amount); event TopChainCoinMintFinished(); TopChainCoin public token = new TopChainCoin(); DateTime internal dateTime = new DateTime(); uint totalToken = 2100000000 * (10 ** 6); uint public privateTokenCap = 210000000 * (10 ** 6); uint public marketToken = 315000000 * (10 ** 6); uint public operationToken = 210000000 * (10 ** 6); uint public gameMiningTokenCap = 1155000000 * (10 ** 6); uint public teamToken2018 = 105000000 * (10 ** 6); uint public teamToken2019 = 105000000 * (10 ** 6); uint public privateToken = 0; address public teamAddress; address public operationAddress; address public marketAddress; bool public team2018TokenCreated = false; bool public team2019TokenCreated = false; bool public operationTokenCreated = false; bool public marketTokenCreated = false; mapping(uint16 => uint) public gameMiningToken; uint public firstYearGameMiningTokenCap = 577500000 * (10 ** 6); uint public gameMiningTokenStartTime = 1514736000; function isContract(address _addr) internal view returns(bool) { uint size; if (_addr == 0) return false; assembly { size := extcodesize(_addr) }",1
0x70f90f6688cb26b6a924a2155b3d9529a0b36a90.sol,Crowdsale,"contract Crowdsale is Pausable{ using SafeMath for uint256; BurnableToken public token; address public wallet; uint256 public rate = 1883800000000000000000; uint256 tokensSold; uint256 public weiRaised; uint256 startTime; uint256 phaze1Start = 1564617600; uint256 phaze1End = 1567209600; uint256 phaze2Start = 1567296000; uint256 phaze2End = 1569801600; uint256 phaze3Start = 1569888000; uint256 phaze3End = 1572480000; uint256 rate1 = 3767600000000000000000; uint256 rate2 = 2354750000000000000000; uint256 rate3 = 2093100000000000000000; uint256 public hardcap = 250000000000000000000000000; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount, uint256 time); event buyx(address buyer, address contractAddr, uint256 amount); constructor(address _wallet, BurnableToken _token, uint256 starttime, uint256 _cap) public{ require(_wallet != address(0)); require(_token != address(0)); wallet = _wallet; token = _token; startTime = starttime; hardcap = _cap; }",1
0x2791528f5617e187a6d73c30034ac211b2f47042.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0xbc97f1508fdeb0a63b25f3a4806b62ef5370e8ab.sol,CryptoBeginnerQuest,contract CryptoBeginnerQuest { using SafeMath for uint256; address private administrator; address public miningWarAddress; CryptoEngineerInterface public Engineer; CryptoDepositInterface public Deposit; CryptoMiningWarInterface public MiningWar; CryptoAirdropGameInterface public AirdropGame; CryptoBossWannaCryInterface public BossWannaCry; CryptoArenaInterface public Arena; uint256 private miningWarDeadline; uint256 private miningWarRound; mapping(address => Player) private players; mapping(address => MinerQuest) private minerQuests; mapping(address => EngineerQuest) private engineerQuests; mapping(address => DepositQuest) private depositQuests; mapping(address => JoinAirdropQuest) private joinAirdropQuests; mapping(address => AtkBossQuest) private atkBossQuests; mapping(address => AtkPlayerQuest) private atkPlayerQuests; mapping(address => BoosterQuest) private boosterQuests; mapping(address => RedbullQuest) private redbullQuests; struct Player { uint256 miningWarRound; uint256 currentQuest; },1
0x0ee14f47320604d894fffffc8639772382937bee.sol,OpportyWhiteListHold,contract OpportyWhiteListHold is Ownable { using SafeMath for uint256; OpportyToken public OppToken; struct Holder { bool isActive; uint tokens; uint8 holdPeriod; uint holdPeriodTimestamp; bool withdrawed; },1
0x32d1df5e0f21f73a11cad1e9b443ef0f669bcdd0.sol,RABAToken,contract RABAToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 75000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function RABAToken () { owner = msg.sender; },1
0x3a2fd07ec2ad6f355f93af695a7cf858f5967b78.sol,MTVote,contract MTVote is Ownable { address public TVTokenAddress; address public TVCrowdsaleAddress; address public manager; address public wallet; address internal checkAndBuySender; bytes4 constant TOKEN_RECEIVED = bytes4(keccak256()); bool pause = false; mapping(uint => uint) public targets; uint public targetIdsSize = 0; uint[] public targetIds; modifier onlyOwnerOrManager() { require(msg.sender == owner || manager == msg.sender); _; },1
0x5c743a35e903f6c584514ec617acee0611cf44f3.sol,ERC223Token,"contract ERC223Token { using SafeMath for uint256; string public name; bytes32 public symbol; uint8 public decimals; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping (address => mapping(address => uint256)) internal allowances; function transfer(address to, uint256 value, bytes data) public returns (bool) { require(balanceOf[msg.sender] >= value); uint256 codeLength; assembly { codeLength := extcodesize(to) }",1
0xa59dee0eb75df81cdca2b3d437d078f4df35e75c.sol,Distribution,"contract Distribution { using SafeMath for uint256; enum State { AwaitingTokens, DistributingNormally, DistributingProRata, Done }",1
0x6f9ef4d30498f23e7d3116e272b855597fba83bd.sol,P3DRaffle,contract P3DRaffle is Owned { using SafeMath for uint; HourglassInterface constant P3Dcontract_ = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe); function harvestabledivs() view public returns(uint256) { return ( P3Dcontract_.dividendsOf(address(this))) ; },1
0x0d5eae179709e92b3bff65731158e8291c49eafb.sol,GaintDex,"contract GaintDex is SafeMath { address public admin; address public feeAccount; uint public feeMake; uint public feeTake; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor() { admin = msg.sender; feeAccount = msg.sender; feeMake = 700000000000000; feeTake = 700000000000000; }",1
0x83686a73638ff46ee1eb5d28ff2179c41d1157aa.sol,ldoh,"contract ldoh is EthereumSmartContract { event onCashbackCode (address indexed hodler, address cashbackcode); event onAffiliateBonus (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onUnlocktoken (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onHoldplatform (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onAddContractAddress(address indexed contracthodler, bool contractstatus, uint256 _maxcontribution, string _ContractSymbol, uint256 _PercentPermonth, uint256 _HodlingTime); event onHoldplatformsetting(address indexed Tokenairdrop, bool HPM_status, uint256 HPM_divider, uint256 HPM_ratio, uint256 datetime); event onHoldplatformdeposit(uint256 amount, uint256 newbalance, uint256 datetime); event onHoldplatformwithdraw(uint256 amount, uint256 newbalance, uint256 datetime); address public DefaultToken; struct Safe { uint256 id; uint256 amount; uint256 endtime; address user; address tokenAddress; string tokenSymbol; uint256 amountbalance; uint256 cashbackbalance; uint256 lasttime; uint256 percentage; uint256 percentagereceive; uint256 tokenreceive; uint256 lastwithdraw; address referrer; bool cashbackstatus; }",1
0x74ceda99c44da280f2fd8ea8b5dd43f8b66912a8.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; },1
0x182f2b554462230735699df74ec9606a3c4c0684.sol,BookERC20EthV1Dec,contract BookERC20EthV1Dec { enum BookType { ERC20EthV1 },1
0x422431dd7926165b83fbe433669c408843df23ee.sol,ProvidencePresale,"contract ProvidencePresale { using SafeMath for uint256; address public wallet; address addressOfTokenUsedAsReward; token tokenReward; uint256 public startTime; uint256 public endTime; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function ProvidencePresale() { wallet = 0x2F81D169A4A773e614eC6958817Ed76381089615; addressOfTokenUsedAsReward = 0x50584a9bDfAb54B82e620b8a14cC082B07886841; tokenReward = token(addressOfTokenUsedAsReward); startTime = 1507143600; endTime = startTime + 14*24*60 * 1 minutes; }",1
0x1eafd303c88b6cd638c77b40596de3dcf001b249.sol,StandardToken,"contract StandardToken is ClaimableEx, NoOwnerEx, ERC20 { using SafeMath for uint256; uint256 totalSupply_; BalanceSheet private balances; event BalanceSheetSet(address indexed sheet); mapping (address => mapping (address => uint256)) private allowed; constructor() public { totalSupply_ = 0; }",1
0x91dfe531ff8ba876a505c8f1c98bafede6c7effc.sol,MatchingMarket,"contract MatchingMarket is MatchingEvents, ExpiringMarket, DSNote { bool public buyEnabled = true; bool public matchingEnabled = true; struct sortInfo { uint next; uint prev; uint delb; }",1
0x261ace754fba8af93e1fecdff13640540402940f.sol,Phila_Token,"contract Phila_Token is ERC20Interface, Owned { string public constant symbol = ; string public constant name = ; uint8 public constant decimals = 0; uint private constant _totalSupply = 10000000; address public vaultAddress; bool public fundingEnabled; uint public totalCollected; uint public tokenPrice; mapping(address => uint) balances; constructor() public { balances[this] = _totalSupply; emit Transfer(address(0), this, _totalSupply); }",1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0x370f0fe5f1c03892b2dc950a89c6eaff4980dac3.sol,KittenSelfDrop2,"contract KittenSelfDrop2 is Ownable { KittenCoin public kittenContract; uint8 public dropNumber; uint256 public kittensDroppedToTheWorld; uint256 public kittensRemainingToDrop; uint256 public holderAmount; uint256 public basicReward; uint256 public holderReward; mapping (uint8 => uint256[]) donatorReward; uint8 donatorRewardLevels; uint8 public totalDropTransactions; mapping (address => uint8) participants; function KittenSelfDrop2 () { address c = 0xac2BD14654BBf22F9d8f20c7b3a70e376d3436B4; kittenContract = KittenCoin(c); dropNumber = 1; kittensDroppedToTheWorld = 0; kittensRemainingToDrop = 0; basicReward = 50000000000; holderReward = 50000000000; holderAmount = 5000000000000; donatorReward[0]=[1,10000000000]; donatorReward[1]=[1000000000000000,100000000000]; donatorReward[2]=[10000000000000000,500000000000]; donatorRewardLevels = 3; totalDropTransactions = 0; }",1
0x54ee540b38fc6e0548172fe651927d85366c6bf7.sol,TRSToken,contract TRSToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function TRSToken () { owner = msg.sender; },1
0x0e33ca464b1c76a384039eb1b7e9dc3b0416b5ae.sol,NamiCrowdSale,"contract NamiCrowdSale { using SafeMath for uint256; function NamiCrowdSale(address _escrow, address _namiMultiSigWallet, address _namiPresale) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; namiPresale = _namiPresale; }",1
0x74a12ce6eebc23c3f785c0ab50d02228587dcc1a.sol,FrozenToken,"contract FrozenToken is ERC20Token, ITokenRecipient { mapping (address => bool) frozeds; uint256 public frozedCount; bool public freezeEnabled = false; bool public autoFreeze = false; bool public mintFinished = false; event Freeze(address indexed wallet); event UnFreeze(address indexed wallet); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); event Mint(address indexed sender, address indexed wallet, uint256 amount); event ReceiveTokens(address indexed spender, address indexed token, uint256 value, bytes extraData); event ApproveAndCall(address indexed spender, uint256 value, bytes extraData); event Burn(address indexed sender, uint256 amount); event MintFinished(address indexed spender); modifier notFreeze { require(frozeds[msg.sender] == false || freezeEnabled == false); _; }",1
0xbd3476e32de1077e049d0c4767c650230be38bda.sol,Airdrop,"contract Airdrop is Ownable, Destroyable { using SafeMath for uint256; struct Beneficiary { uint256 balance; uint256 airdrop; bool isBeneficiary; }",1
0x8615ddfe9d4c9e58abff01c999731f3e9e556e80.sol,DAPBOXToken,"contract DAPBOXToken is FrozenToken { string public name = ; string public symbol = ; uint8 public decimals = 0; string public version = ; string public publisher = ""https: string public description = ; bool public acceptAdminWithdraw = false; bool public acceptDonate = true; event InfoChanged(address indexed sender, string version, string publisher, string description); event Withdraw(address indexed sender, address indexed wallet, uint256 amount); event WithdrawTokens(address indexed sender, address indexed wallet, address indexed token, uint256 amount); event Donate(address indexed sender, uint256 value); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); function setupInfo(string _version, string _publisher, string _description) authLevel(Level.ADMIN) notEmpty(_version) notEmpty(_publisher) notEmpty(_description) public { version = _version; publisher = _publisher; description = _description; InfoChanged(msg.sender, _version, _publisher, _description); }",1
0x24a7de87b3bd7298bbf8966fdf170c558d69ecc4.sol,METADOLLAR,"contract METADOLLAR is ERC20Interface, Owned, SafeMath { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint256 public _totalSupply = 1000000000000000000000000000000; uint256 public icoMin = 1000000000000000; uint256 public icoLimit = 1000000000000000000000000000000; uint256 public countHolders = 0; uint256 public amountOfInvestments = 0; uint256 public icoPrice; uint256 public dolRate = 1000; uint256 public ethRate = 1; uint256 public sellRate = 900; uint256 public commissionRate = 1000; uint256 public sellPrice; uint256 public currentTokenPrice; uint256 public commission; bool public icoIsRunning; bool public minimalGoalReached; bool public icoIsClosed; mapping (address => uint256) public tokenBalanceOf; mapping(address => mapping (address => uint256)) allowed; mapping(address => bool) frozenAccount; event FrozenFunds(address initiator, address account, string status); event BonusChanged(uint8 bonusOld, uint8 bonusNew); event minGoalReached(uint256 minIcoAmount, string notice); event preIcoEnded(uint256 preIcoAmount, string notice); event priceUpdated(uint256 oldPrice, uint256 newPrice, string notice); event withdrawed(address _to, uint256 summe, string notice); event deposited(address _from, uint256 summe, string notice); event orderToTransfer(address initiator, address _from, address _to, uint256 summe, string notice); event tokenCreated(address _creator, uint256 summe, string notice); event tokenDestroyed(address _destroyer, uint256 summe, string notice); event icoStatusUpdated(address _initiator, string status); function STARTMETADOLLAR() { icoIsRunning = true; minimalGoalReached = false; icoIsClosed = false; tokenBalanceOf[this] += _totalSupply; allowed[this][owner] = _totalSupply; allowed[this][supervisor] = _totalSupply; currentTokenPrice = 1 * 1; icoPrice = ethRate * dolRate; sellPrice = sellRate * ethRate; updatePrices(); }",1
0xc7740d000d9931769291da0352bbe7c6b27bc97d.sol,HasNoTokens,"contract HasNoTokens is Ownable { event ExtractedTokens(address indexed _token, address indexed _claimer, uint _amount); function extractTokens(address _token, address _claimer) onlyOwner public { if (_token == 0x0) { _claimer.transfer(this.balance); return; }",1
0x39e8082b00c9f19ebf553e40feb7cf8459acc693.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }",1
0x019e41a2acdffafc0303e840fbd7934234e68f45.sol,contractDeployer,"contract contractDeployer is Ownable { event ContractCreated(address newAddress); address public tokenAddr; uint public tokenFee; uint public crowdsaleFee; uint public multisendFee; ERC20 token; cDeployer cdep; tDeployer tdep; function setUp(address _token, address _cdep, address _tdep) public onlyOwner { tokenAddr = _token; token = ERC20(tokenAddr); cdep = cDeployer(_cdep); tdep = tDeployer(_tdep); }",1
0x0d853d20b54b8abfacb05fc5e81e8d4395021c01.sol,LxtBountyDistribution,contract LxtBountyDistribution is owned { using SafeMath for uint; LexitToken public LXT; address public LXT_OWNER; uint256 private constant decimalFactor = 10**uint256(18); uint256 public grandTotalClaimed = 0; struct Allocation { uint256 totalAllocated; uint256 amountClaimed; },1
0x36cddd1281258e4373ad313a995272f525cc4e63.sol,CoinoorCrowdsale,"contract CoinoorCrowdsale { address public beneficiary; address public creator; address public marketing; address public bounty; address public confirmedBy; uint256 public maxSupply = 65000000 * 10**8; uint256 public minAcceptedAmount = 40 finney; uint256 public ratePreICO = 450; uint256 public rateWaiting = 0; uint256 public rateAngelDay = 420; uint256 public rateFirstWeek = 390; uint256 public rateSecondWeek = 375; uint256 public rateThirdWeek = 360; uint256 public rateLastWeek = 330; uint256 public ratePreICOEnd = 10 days; uint256 public rateWaitingEnd = 20 days; uint256 public rateAngelDayEnd = 21 days; uint256 public rateFirstWeekEnd = 28 days; uint256 public rateSecondWeekEnd = 35 days; uint256 public rateThirdWeekEnd = 42 days; uint256 public rateLastWeekEnd = 49 days; enum Stages { Deploying, InProgress, Ended }",1
0x797d713d8d7a2815ccf3dcf9719e3e9f1712c370.sol,Trustee,contract Trustee is Ownable { using SaferMath for uint256; StoxSmartToken public stox; struct Grant { uint256 value; uint256 start; uint256 cliff; uint256 end; uint256 transferred; bool revokable; },1
0x02d3aea48b443a0026ed9cbc91b97d7335aba323.sol,HardcodedCrowdsale,"contract HardcodedCrowdsale { using SafeMath for uint256; enum ICOStateEnum {NotStarted, Started, Refunded, Successful}",1
0xeb6486b13b56314b37aacac2ec6889d11a763de1.sol,BasicCGRID,contract BasicCGRID is ERC223 { using SafeMath for uint256; uint256 public constant decimals = 8; string public constant symbol = ; string public constant name = ; uint256 public _totalSupply = 10**17; address public owner; address public airdrop; bool public tradable = false; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDView,"contract BitSTDView { BitSTDLogic private logic; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function balanceOf(address add)constant public returns (uint256) { return logic.balanceOf(add); }",1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,Token,"contract Token { using SafeMath for uint256; mapping (address => uint256) public balances; mapping(address => mapping (address => uint256)) allowed; address[] allTokenHolders; string public name; string public symbol; uint8 public decimals; uint256 totalSupplyAmount = 0; address public refundManagerContractAddress; AuthenticationManager authenticationManager; LockinManager lockinManager; function availableBalance(address _owner) constant returns(uint256) { uint256 length = lockinManager.getLocks(_owner); uint256 lockedValue = 0; for(uint256 i = 0; i < length; i++) { if(lockinManager.getLocksUnlockDate(_owner, i) > now) { uint256 _value = lockinManager.getLocksAmount(_owner, i); lockedValue = lockedValue.add(_value); }",1
0x39de38ba63d172b962db2fc2ee5e4376287c50bf.sol,ImmlaIco,"contract ImmlaIco is SafeMath { ImmlaToken public immlaToken; AbstractToken public preIcoToken; address public escrow; address public icoManager; address public tokenImporter = 0x0; address public founder1; address public founder2; address public founder3; address public team; address public bountyOwner; uint public constant teamsReward = 38548226701232220000000000; uint public constant bountyOwnersTokens = 9361712198870680000000000; uint constant BASE = 1000000000000000000; uint public constant defaultIcoStart = 1505422800; uint public icoStart = defaultIcoStart; uint public constant defaultIcoDeadline = 1508101200; uint public icoDeadline = defaultIcoDeadline; uint public constant defaultFoundersRewardTime = 1521061200; uint public foundersRewardTime = defaultFoundersRewardTime; uint public constant minIcoTokenLimit = 18000000 * BASE; uint public constant maxIcoTokenLimit = 434477177 * BASE; uint public importedTokens = 0; uint public soldTokensOnIco = 0; uint public constant soldTokensOnPreIco = 13232941687168431951684000; uint tokenPrice1 = 3640; uint tokenSupply1 = 170053520 * BASE; uint tokenPrice2 = 3549; uint tokenSupply2 = 103725856 * BASE; uint tokenPrice3 = 3458; uint tokenSupply3 = 100319718 * BASE; uint tokenPrice4 = 3367; uint tokenSupply4 = 60378083 * BASE; uint[] public tokenPrices; uint[] public tokenSupplies; bool public initialized = false; bool public migrated = false; bool public sentTokensToFounders = false; bool public icoStoppedManually = false; mapping (address => uint) public balances; event BuyTokens(address buyer, uint value, uint amount); event WithdrawEther(); event StopIcoManually(); event SendTokensToFounders(uint founder1Reward, uint founder2Reward, uint founder3Reward); event ReturnFundsFor(address account); modifier whenInitialized() { require(initialized); _; }",1
0x4176f0f2b7c95486a5ae06e3d1b29201a42e7630.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0xaa63c8683647ef91b3fdab4b4989ee9588da297b.sol,DSProxy,"contract DSProxy is DSAuth, DSNote { DSProxyCache public cache; function DSProxy(address _cacheAddr) public { require(setCache(_cacheAddr)); }",1
0x39f996a2cafca0e593d0c46b8365d3936b6cc1cf.sol,Etherauction,contract Etherauction is ContractOwner { using SafeMath for uint256; constructor() public payable { owner = msg.sender; gameId = 1; gameStartTime = block.timestamp; gameLastAuctionMoney = 10**15; gameLastAuctionTime = block.timestamp; gameSecondLeft = _getInitAuctionSeconds(); },1
0x0000009a317684a5f840484357fa587aca76454c.sol,BurnableToken,"contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { require(_value <= balances.balanceOf(msg.sender)); address burner = msg.sender; balances.subBalance(burner, _value); totalSupply_ = totalSupply_.sub(_value); Burn(burner, _value); Transfer(burner, address(0), _value); }",1
0x0ce95ef378059f38c5fa21e6d81a5895c0d9911b.sol,Game,contract Game { using GlobalTypes for GlobalTypes.Global; using MarketTypes for MarketTypes.MarketListing; using MissionParametersTypes for MissionParametersTypes.MissionParameters; using GameCommon for GameCommon.LaunchRocketStackFrame; address public m_Owner; AbstractDatabase public m_Database; AbstractGameHidden public m_GameHidden; bool public m_Paused; uint256 constant GlobalCategory = 0; uint256 constant RocketCategory = 1; uint256 constant OwnershipCategory = 2; uint256 constant InventoryCategory = 3; uint256 constant MarketCategory = 4; uint256 constant ProfitFundsCategory = 5; uint256 constant CompetitionFundsCategory = 6; uint256 constant MissionParametersCategory = 7; uint256 constant CompetitionScoresCategory = 8; uint256 constant WithdrawalFundsCategory = 9; uint256 constant ReferralCategory = 10; uint256 constant RocketStockCategory = 11; uint256 constant RocketStockInitializedCategory = 12; address constant NullAddress = 0; uint256 constant MaxCompetitionScores = 10; mapping(uint32 => RocketTypes.StockRocket) m_InitialRockets; modifier OnlyOwner() { require(msg.sender == m_Owner); _; },1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0x4853cb0e07ab16cb380f8aeda24507779881cdeb.sol,KYC,"contract KYC is Ownerable { mapping (address => bool) public registeredAddress; mapping (address => bool) public admin; event Registered(address indexed _addr); event Unregistered(address indexed _addr); event NewAdmin(address indexed _addr); event ClaimedTokens(address _token, address owner, uint256 balance); modifier onlyRegistered(address _addr) { require(registeredAddress[_addr]); _; }",1
0x4cb200957a11cbff512b4752e6ee38c9253fdd54.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x33d99efc0c3cc4f93da6931ec2cccf19ca874b6d.sol,_0xLitecoinToken,"contract _0xLitecoinToken is ERC20Interface, Owned { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; address parentAddress; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); function _0xLitecoinToken() public onlyOwner{ symbol = ; name = ; decimals = 8; _totalSupply = 4*21000000 * 10**uint(decimals); if(locked) revert(); locked = true; tokensMinted = 0; rewardEra = 0; maxSupplyForEra = _totalSupply.div(2); miningTarget = 27938697607979437428382017032425071986904332731688489302005732; latestDifficultyPeriodStarted = block.number; _startNewMiningEpoch(); parentAddress = 0xb6ed7644c69416d67b522e20bc294a9a9b405b31; }",1
0xebf0027ef3b4b7a742a148cddb0f2b14e5d8f0e9.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); constructor(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; }",1
0xc3e43d422d5e6f94315622d96a96058689c52ec8.sol,BitNauticCrowdsaleTokenDistributor,"contract BitNauticCrowdsaleTokenDistributor is Ownable { using SafeMath for uint256; uint256 public constant ICOStartTime = 1531267200; uint256 public constant ICOEndTime = 1536969600; uint256 public teamSupply = 3000000 * 10 ** 18; uint256 public bountySupply = 2500000 * 10 ** 18; uint256 public reserveSupply = 5000000 * 10 ** 18; uint256 public advisorSupply = 2500000 * 10 ** 18; uint256 public founderSupply = 2000000 * 10 ** 18; MintableToken public token; BitNauticWhitelist public whitelist; BitNauticCrowdsale public crowdsale; mapping (address => bool) public hasClaimedTokens; constructor(MintableToken _token, BitNauticWhitelist _whitelist, BitNauticCrowdsale _crowdsale) public { token = _token; whitelist = _whitelist; crowdsale = _crowdsale; }",1
0x6bd33d49d48f76abcd96652e5347e398aa3fda96.sol,BancorBuyer,contract BancorBuyer { mapping (address => uint) public balances; uint public reward; bool public bought_tokens; uint public time_bought; address sale = 0xBbc79794599b19274850492394004087cBf89710; address token = 0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C; address developer = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e; function withdraw(){ uint amount = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(amount); },1
0x17cba58578eecaee898242a02edac75b8cc17231.sol,AUMXToken,"contract AUMXToken is ERC223, SafeMath{ mapping(address => mapping(address => uint)) allowed; mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 5000000000000000; bool locked; address Owner; address swapperAddress; function AUMXToken() public { locked = true; Owner = msg.sender; swapperAddress = msg.sender; balances[msg.sender] = totalSupply; allowed[msg.sender][swapperAddress] = totalSupply; }",1
0x4900320fe47208de0b79db1273a78ab8c8f3528d.sol,Crowdsale,contract Crowdsale is Owned { using SafeMath for uint256; uint256 public fundingGoal; uint256 public price; uint256 public transferableToken; uint256 public soldToken; uint256 public deadline; uint256 public token_price; MontexToken public tokenReward; bool public fundingGoalReached = false; bool public isOpened; mapping (address => Property) public fundersProperty; struct Property { uint256 paymentEther; uint256 reservedToken; },1
0xec841c878435ba4f28bf305a00c1483db0d96a20.sol,Events,contract Events { DBInterface public database; constructor(address _database) public{ database = DBInterface(_database); },1
0xbd5ff93a6ce6019f0e69227d88d11e5772dc853e.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; ERC20 public token; address public fundWallet; address public admin; uint256 public rate = 10000; uint256 public amountRaised; bool public crowdsaleOpen; uint256 public cap; event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount); function Crowdsale(ERC20 _token, address _fundWallet) public { require(_token != address(0)); require(_fundWallet != address(0)); fundWallet = _fundWallet; admin = msg.sender; token = _token; crowdsaleOpen = true; cap = 20000 * 1 ether; }",1
0x204c3e5296ab443707e5404a509aa5194e63b12a.sol,EcoVault,"contract EcoVault is Ownable, Pausable, HasNoEther, CanReclaimToken { using SafeMath for uint256; using SafeERC20 for ERC20; uint256 public constant MAX_CONTRIBUTION = 100000 * 10**18; uint256 public constant MAX_TOTAL_CONTRIBUTIONS = 5000000 * 10**18; uint256 public constant CONTRIBUTION_START = 1508544000; uint256 public constant CONTRIBUTION_END = 1509494400; uint256 public constant TIME_LOCK_END = 1525132800; mapping (address => uint256) public contributions; uint256 public totalContributions = 0; ERC20 public token; event Contribution(address indexed _addr, uint256 _amount); event Withdrawal(address indexed _addr, uint256 _amount); modifier whenAbleToContribute(uint256 _amount) { require( now > CONTRIBUTION_START && now < CONTRIBUTION_END && _amount > 0 && contributions[msg.sender].add(_amount) <= MAX_CONTRIBUTION && totalContributions.add(_amount) <= MAX_TOTAL_CONTRIBUTIONS && token.allowance(msg.sender, this) >= _amount ); _; }",1
0x485b224c97ad56dc5b145eafdee71a7b5163f735.sol,PonziBet,contract PonziBet { using SafeMath for uint; EthPyramid public pyramid; address public admin; address public contractAddress; uint public minBet; uint public roundTime; uint public startPrice; uint public endPrice; uint[] public upBetRecords; uint[] public downBetRecords; mapping (address => uint) lastBet; mapping (address => bool) userBet; mapping (bool => uint) totalBalance; mapping (address => uint) feeBalance; mapping (address => mapping (bool => uint)) userBalances; function PonziBet() public { admin = msg.sender; },1
0x2d3e7d4870a51b918919e7b851fe19983e4c38d5.sol,FreezeTokensWallet,contract FreezeTokensWallet is Ownable { using SafeMath for uint256; MintableToken public token; bool public started; uint public startLockPeriod = 180 days; uint public period = 360 days; uint public duration = 90 days; uint public startUnlock; uint public retrievedTokens; uint public startBalance; modifier notStarted() { require(!started); _; },1
0x2628e13a3cbdc52ed96b4b8d6b1041d3ef3a409e.sol,EasySmartolution,"contract EasySmartolution { event ParticipantAdded(address _sender); event ParticipantRemoved(address _sender); event ReferrerAdded(address _contract, address _sender); mapping (address => address) public participants; mapping (address => bool) public referrers; address private processing; constructor(address _processing) public { processing = _processing; }",1
0x8d4b2cffe2dcbbf06eaa5920401db86ca5fb8177.sol,SelfKeyCrowdsale,"contract SelfKeyCrowdsale is Ownable, CrowdsaleConfig { using SafeMath for uint256; using SafeERC20 for SelfKeyToken; mapping(address => bool) public isVerifier; SelfKeyToken public token; uint64 public startTime; uint64 public endTime; uint256 public goal; uint256 public rate = 51800; uint256 public ethPrice = 777; uint256 public totalPurchased = 0; mapping(address => bool) public kycVerified; mapping(address => uint256) public tokensPurchased; mapping(address => address) public vestedTokens; bool public isFinalized = false; TokenTimelock public foundersTimelock1; TokenTimelock public foundersTimelock2; TokenTimelock public foundationTimelock; RefundVault public vault; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); event VerifiedKYC(address indexed participant); event AddedPrecommitment( address indexed participant, uint256 tokensAllocated ); event Finalized(); modifier verifierOnly() { require(isVerifier[msg.sender]); _; }",1
0x269b4c23ddab676e2869ae72cd6ae4f24bdfea45.sol,IRBPreCrowdsale,"contract IRBPreCrowdsale is Ownable, Pausable { using SafeMath for uint; IRBToken public token; IRBPreRefundVault public vault; uint startTime = 1513065600; uint endTime = 1515963599; uint256 public constant minPresaleAmount = 108 * 10 ** 15; uint256 public constant goal = 1125 * 10 ** 18; uint256 public constant cap = 2250 * 10 ** 18; uint256 public weiRaised; bool public isFinalized = false; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event Finalized(); function IRBPreCrowdsale(address _tokenAddress, address _vaultAddress) { require(_tokenAddress != address(0)); require(_vaultAddress != address(0)); token = IRBToken(_tokenAddress); vault = IRBPreRefundVault(_vaultAddress); }",1
0x27369e8f43f44c26853a46da7e6cb52d203b59ce.sol,AgileArbitrationWithAssistance,contract AgileArbitrationWithAssistance is Owned { address public operator; uint public quorum = 3; struct Dispute { address icoRoundAddress; address investorAddress; bool pending; uint timestamp; uint milestone; string reason; uint votesForProject; uint votesForInvestor; mapping(address => bool) voters; },1
0x25cf23787ac0f92a3eafa61f458ad0b7c4b27c3d.sol,Zethroll,"contract Zethroll is ZTHReceivingContract { using SafeMath for uint; modifier betIsValid(uint _betSize, uint _playerNumber) { require( calculateProfit(_betSize, _playerNumber) < maxProfit && _betSize >= minBet && _playerNumber > minNumber && _playerNumber < maxNumber); _; }",1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,SaleClockAuction,"contract SaleClockAuction is ClockAuction { bool public isSaleClockAuction = true; uint256 public gen0SaleCount; uint256[5] public lastGen0SalePrices; constructor(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x18da8521c333aed9de8f512e847734cb7be42e38.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0xb3bbc0cc040413a3e68dcaa8f2b6eac2957c5ce0.sol,BitGuildTopUp,"contract BitGuildTopUp { using SafeMath for uint256; BitGuildToken public token; PLATPriceOracle public oracle; address public wallet; event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount); constructor(address _token, address _oracle, address _wallet) public { require(_token != address(0)); require(_oracle != address(0)); require(_wallet != address(0)); token = BitGuildToken(_token); oracle = PLATPriceOracle(_oracle); wallet = _wallet; }",1
0xc739ae9ba934f937636a2ebaaf1ecdf04e11ef2f.sol,NXTGToken,contract NXTGToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 7000000 * (10**5); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0x6b4df2aa3d64d8dc06120ef4391513e4170af4a7.sol,GeneralTransferManager,contract GeneralTransferManager is ITransferManager { using SafeMath for uint256; address public issuanceAddress = address(0); address public signingAddress = address(0); bytes32 public constant WHITELIST = ; bytes32 public constant FLAGS = ; struct TimeRestriction { uint256 fromTime; uint256 toTime; uint256 expiryTime; bool canBuyFromSTO; },1
0x1c9db47ee8abad20d28f9bbe2363ca0c8c9ab9b8.sol,Bitsense,"contract BitsenseToken { string internal _symbol; string internal _name; uint8 internal _decimals; uint internal _totalSupply = 1000000000000000; mapping (address => uint) _balanceOf; mapping (address => mapping (address => uint)) internal _allowances; function BitsenseToken(string symbol, string name, uint8 decimals, uint totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; }",1
0x52d3ec187457a106d2ec546be4cb8a11d9be2527.sol,MonsterAuction,contract MonsterAuctionBase { MonsterOwnership public nonFungibleContract; ChainMonstersCore public core; struct Auction { address seller; uint256 price; uint64 startedAt; uint256 id; },1
0x26bf81f017a7149576dc5d82323172fcae9fd469.sol,PhxGo,"contract PhxGo is Ownable{ using SafeMath for uint; event LogTokenMultiSent(address token,uint256 total); event LogGetToken(address token, address receiver, uint256 balance); address public receiverAddress; uint public txFee = 0.01 ether; uint public VIPFee = 1 ether; mapping(address => bool) public vipList; function getBalance(address _tokenAddress) onlyOwner public { address _receiverAddress = getReceiverAddress(); if(_tokenAddress == address(0)){ require(_receiverAddress.send(address(this).balance)); return; }",1
0x69ceaea78e28d62bc1ac68491d77f6a761edce01.sol,MDMCToken,"contract MDMCToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 28650; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0x25b16c95f3ebb1d8583a1c173f81257bc916a9be.sol,CommunityPool,"contract CommunityPool is Ownable{ SignalsToken token; event CommunityTokensAllocated(address indexed member, uint amount); function CommunityPool(address _token, address _owner) public{ token = SignalsToken(_token); owner = _owner; }",1
0x53fecaea999360abf21736e3d54d9da0f412e8a9.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 29894400; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x62e875332f07Fc58C370a83377b16A3942bC0a0D; }",1
0x541317cbeea0d862bad9bc4d330feb565e610209.sol,BrickCrowdsale,contract BrickCrowdsale is Ownable { using SafeMath for uint256; uint256 public startTime; uint256 public endTime; uint256 public weiRaised; uint256 public limitDateSale; uint256 public currentTime; bool public isSoftCapHit = false; bool public isStarted = false; bool public isFinalized = false; uint256 icoPvtRate = 40; uint256 icoPreRate = 50; uint256 ico1Rate = 65; uint256 ico2Rate = 75; uint256 ico3Rate = 90; uint256 public pvtTokens = (40000) * (10**18); uint256 public preSaleTokens = (6000000) * (10**18); uint256 public ico1Tokens = (8000000) * (10**18); uint256 public ico2Tokens = (8000000) * (10**18); uint256 public ico3Tokens = (8000000) * (10**18); uint256 public totalTokens = (40000000)* (10**18); address public advisoryEthWallet = 0x0D7629d32546CD493bc33ADEF115D4489f5599Be; address public infraEthWallet = 0x536D36a05F6592aa29BB0beE30cda706B1272521; address public techDevelopmentEthWallet = 0x4d0B70d8E612b5dca3597C64643a8d1efd5965e1; address public operationsEthWallet = 0xbc67B82924eEc8643A4f2ceDa59B5acfd888A967; address public wallet = 0x44d44CA0f75bdd3AE8806D02515E8268459c554A; struct ContributorData { uint256 contributionAmount; uint256 tokensIssued; },1
0x0267ee183beebdb7f931afe41e4e25352195b871.sol,BulleonToken,"contract BulleonToken is StandardBurnableToken, PausableToken, Claimable, CanReclaimToken { event AddedToWhitelist(address wallet); event RemoveWhitelist(address wallet); string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 constant exchangersBalance = 39991750231582759746295 + 14715165984103328399573 + 1846107707643607869274; address constant premineWallet = 0x286BE9799488cA4543399c2ec964e7184077711C; uint256 constant premineAmount = 178420 * (10 ** uint256(decimals)); address public CrowdsaleAddress; CrowdsaleContract crowdsale; mapping(address=>bool) whitelist; constructor() public { totalSupply_ = 7970000 * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; transfer(premineWallet, premineAmount.add(exchangersBalance)); addToWhitelist(msg.sender); addToWhitelist(premineWallet); paused = true; }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,ExternStateProxyToken,"contract ExternStateProxyToken is SafeDecimalMath, Proxyable { TokenState public state; string public name; string public symbol; uint public totalSupply; function ExternStateProxyToken(string _name, string _symbol, uint initialSupply, address initialBeneficiary, TokenState _state, address _owner) Proxyable(_owner) public { name = _name; symbol = _symbol; totalSupply = initialSupply; if (_state == TokenState(0)) { state = new TokenState(_owner, address(this)); state.setBalanceOf(initialBeneficiary, totalSupply); emit Transfer(address(0), initialBeneficiary, initialSupply); }",1
0x456c4350eefd17315713b265d8be8b6063a5fab8.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiCrowdSale,"contract NamiCrowdSale { using SafeMath for uint256; function NamiCrowdSale(address _escrow, address _namiMultiSigWallet, address _namiPresale) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; namiPresale = _namiPresale; }",1
0x449f5c827cf7726cc5f181090aa147ca5fb88a40.sol,EthergotchiOwnershipV2,"contract EthergotchiOwnershipV2 is Controllable, ERC721, ERC721Enumerable, ERC721Metadata { mapping(uint256 => address) private ownerByTokenId; mapping(address => uint256[]) private tokenIdsByOwner; mapping(uint256 => uint256) private ownerTokenIndexByTokenId; mapping(uint256 => address) private approvedTransfers; mapping(address => mapping(address => bool)) private operators; uint256 private totalTokens; bytes4 private constant INTERFACE_SIGNATURE_ERC165 = bytes4( keccak256() ); bytes4 private constant INTERFACE_SIGNATURE_ERC721 = bytes4( keccak256() ^ keccak256() ^ keccak256() ^ keccak256() ^ keccak256() ^ keccak256() ^ keccak256() ^ keccak256() ^ keccak256() ); bytes4 private constant INTERFACE_SIGNATURE_ERC721_ENUMERABLE = bytes4( keccak256() ^ keccak256() ^ keccak256() ); bytes4 private constant INTERFACE_SIGNATURE_ERC721_METADATA = bytes4( keccak256() ^ keccak256() ^ keccak256() ); bytes4 private constant INTERFACE_SIGNATURE_ERC721_TOKEN_RECEIVER = bytes4( keccak256() ); event Transfer( address indexed _from, address indexed _to, uint256 _tokenId ); event Approval( address indexed _owner, address indexed _approved, uint256 _tokenId ); event ApprovalForAll( address indexed _owner, address indexed _operator, bool _approved ); modifier onlyValidToken(uint256 _tokenId) { require(ownerByTokenId[_tokenId] != address(0)); _; }",1
0x741f58cd68d24f361cc0ee0d3aaf7df2bf16132e.sol,BlockonixToken,"contract BlockonixToken is IERC20, Ownable, Vestable, HasAddresses, VestingPeriods, IsUpgradable { using SafeMathLib for uint256; uint256 public constant totalTokenSupply = 1009208335 * 10**16; uint256 public burntTokens; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; mapping (address => uint256) public balances; mapping(address => mapping(address => uint256)) approved; event Upgraded(address _owner, uint256 amount); constructor() public { uint256 lockedTokenPerAddress = 280335648611111000000000; balances[founder1FirstLockup] = lockedTokenPerAddress; balances[founder2FirstLockup] = lockedTokenPerAddress; balances[founder3FirstLockup] = lockedTokenPerAddress; balances[founder1SecondLockup] = lockedTokenPerAddress; balances[founder2SecondLockup] = lockedTokenPerAddress; balances[founder3SecondLockup] = lockedTokenPerAddress; balances[founder1ThirdLockup] = lockedTokenPerAddress; balances[founder2ThirdLockup] = lockedTokenPerAddress; balances[founder3ThirdLockup] = lockedTokenPerAddress; emit Transfer(address(this), founder1FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder1SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder1ThirdLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2ThirdLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3ThirdLockup, lockedTokenPerAddress); addVestingAddress(founder1FirstLockup, firstLockup); addVestingAddress(founder2FirstLockup, firstLockup); addVestingAddress(founder3FirstLockup, firstLockup); addVestingAddress(founder1SecondLockup, secondLockup); addVestingAddress(founder2SecondLockup, secondLockup); addVestingAddress(founder3SecondLockup, secondLockup); addVestingAddress(founder1ThirdLockup, thirdLockup); addVestingAddress(founder2ThirdLockup, thirdLockup); addVestingAddress(founder3ThirdLockup, thirdLockup); }",1
0x0e54b1b8ff833b5f2b0d17453d97d340cb7576e4.sol,ERC223Token,"contract ERC223Token is IERC223, SafeMath { mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 35000000 * 10**8; function ERC223Token() { balances[msg.sender] = totalSupply; }",1
0x585d501245bf86c92aa940310bc401a9f5af38a1.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; }",1
0xed8a2697d1af8f8cad0f6c5b9962d868d4ed2a41.sol,HUMPresale,"contract HUMPresale is WhitelistedCrowdsale, IndividuallyCappedCrowdsale { uint256 public constant minimum = 100000000000000000; bool public isOnSale = false; mapping(address => uint256) public bonusTokens; uint256 public bonusPercent; address[] public contributors; event DistrubuteBonusTokens(address indexed sender); event Withdraw(address indexed _from, uint256 _amount); constructor ( uint256 _rate, uint256 _bonusPercent, address _wallet, HUMToken _token, uint256 _individualCapEther ) public Crowdsale(_rate, _wallet, _token) IndividuallyCappedCrowdsale(_individualCapEther.mul(10 ** 18)) { bonusPercent = _bonusPercent; }",1
0x0e69d0a2bbb30abcb7e5cfea0e4fde19c00a8d47.sol,ContractLock,"contract ContractLock is DSStop { uint public unlockTime; mapping (address => bool) public isAdmin; event LogAddAdmin(address whoAdded, address newAdmin); event LogRemoveAdmin(address whoRemoved, address admin); constructor(uint _unlockTime) public { unlockTime = _unlockTime; isAdmin[msg.sender] = true; emit LogAddAdmin(msg.sender, msg.sender); }",1
0x5211475520dc4a13fee1cc7c2c0c1167998bcbb8.sol,AuctionContract,"contract AuctionContract { using SafeMath for uint; event BetPlacedEvent(address bidderAddress, uint amount); event RefundEvent(address bidderAddress, uint amount); event CreateAuctionContractEvent(address bidderAddress, uint amount); uint public auctionSlideSize = 30; uint public auctionCloseBlock; uint public closeAuctionAfterNBlocks; uint public bettingStep; mapping (address => uint) public bettingMap; address public firstBidder; address public secondBidder; address public winner; uint public biggestBet; uint public prize; address public firstBetContract; address public secondBetContract; uint public minimalPrize = 10000000000000000; uint public minimaBetStep = 10000000000000000; address public auctioneerAddress; bool public isActive; constructor (uint _closeAuctionAfterNBlocks, address _auctioneerAddress) payable public{ assert(msg.value >= minimalPrize); prize = msg.value; auctioneerAddress = _auctioneerAddress; closeAuctionAfterNBlocks = _closeAuctionAfterNBlocks; auctionCloseBlock = block.number.add(_closeAuctionAfterNBlocks); bettingStep = 0; biggestBet = 0; isActive = true; emit CreateAuctionContractEvent(this, prize); }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,Havven,"contract HavvenEscrow is Owned, LimitedSetup(8 weeks), SafeDecimalMath { Havven public havven; mapping(address => uint[2][]) public vestingSchedules; mapping(address => uint) public totalVestedAccountBalance; uint public totalVestedBalance; function HavvenEscrow(address _owner, Havven _havven) Owned(_owner) public { havven = _havven; }",1
0x182f2b554462230735699df74ec9606a3c4c0684.sol,BookERC20EthV1Dec,contract BookERC20EthV1Dec { enum BookType { ERC20EthV1 },1
0x6f8544edb3f513845135b0efa907f4b6b9c2c92e.sol,BW,contract BWData { address public owner; address private bwService; address private bw; address private bwMarket; uint private blockValueBalance = 0; uint private feeBalance = 0; uint private BASE_TILE_PRICE_WEI = 1 finney; mapping (address => User) private users; mapping (uint16 => Tile) private tiles; struct User { uint creationTime; bool censored; uint battleValue; },1
0x584de5a9995c33c1afa83bc67bebcd481b0a4775.sol,PureMoney2,"contract PureMoney2 is Token { event DebugEvent(address from, address to, uint value); event PaymentContractRegistered(address _contract, uint amountApproved); constructor( uint initialCap) public condition(initialCap > 0) Token(msg.sender, initialCap) { symbol = ; name = ; decimals = DECIMALS; }",1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,Token,"contract Token { using SafeMath for uint256; mapping (address => uint256) public balances; mapping(address => mapping (address => uint256)) allowed; address[] allTokenHolders; string public name; string public symbol; uint8 public decimals; uint256 totalSupplyAmount = 0; address public refundManagerContractAddress; AuthenticationManager authenticationManager; LockinManager lockinManager; function availableBalance(address _owner) constant returns(uint256) { uint256 length = lockinManager.getLocks(_owner); uint256 lockedValue = 0; for(uint256 i = 0; i < length; i++) { if(lockinManager.getLocksUnlockDate(_owner, i) > now) { uint256 _value = lockinManager.getLocksAmount(_owner, i); lockedValue = lockedValue.add(_value); }",1
0x536c7efeebff067a69393133b1c87a163a6b0598.sol,ECM,"contract ECMinterface { function ECMFallback(address _from, uint _value, uint _code); }",1
0x01d6208f95cf2292c350fc8bb1b1f29230352675.sol,DepositWithdraw,"contract DepositWithdraw is Claimable, Withdrawable { using SafeMath for uint256; struct TransferRecord { uint256 timeStamp; address account; uint256 value; }",1
0xb4007597da3402a1e2b69c8e1c6dd753d01a8035.sol,FundingManager,"contract FundingManager is ApplicationAsset { ABIFunding FundingEntity; ABITokenManager TokenManagerEntity; ABIToken TokenEntity; ABITokenSCADAVariable TokenSCADAEntity; ABIProposals ProposalsEntity; ABIMilestones MilestonesEntity; uint256 public LockedVotingTokens = 0; event EventFundingManagerReceivedPayment(address indexed _vault, uint8 indexed _payment_method, uint256 indexed _amount ); event EventFundingManagerProcessedVault(address _vault, uint256 id ); mapping (address => address) public vaultList; mapping (uint256 => address) public vaultById; uint256 public vaultNum = 0; function setAssetStates() internal { EntityStates[] = 0; EntityStates[] = 1; EntityStates[] = 2; EntityStates[] = 10; EntityStates[] = 11; EntityStates[] = 12; EntityStates[] = 20; EntityStates[] = 21; EntityStates[] = 22; EntityStates[] = 25; EntityStates[] = 30; EntityStates[] = 31; EntityStates[] = 32; EntityStates[] = 40; EntityStates[] = 41; EntityStates[] = 42; EntityStates[] = 100; EntityStates[] = 101; EntityStates[] = 102; RecordStates[] = 0; }",1
0xeb907a50921e052cbee233811beaf0839d2a98fd.sol,Advertisement,contract Advertisement { struct Filters { string countries; string packageName; uint[] vercodes; },1
0x77c9acc811e4cf4b51dc3a3e05dc5d62fa887767.sol,CrryptoArena,contract CrryptoArena { using SafeMath for uint256; address public administrator; uint256 public VIRUS_NORMAL = 0; uint256 public HALF_TIME_ATK= 60 * 15; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public VIRUS_MINING_PERIOD = 86400; address public engineerAddress; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; CryptoProgramFactoryInterface public Factory; mapping(address => Player) public players; mapping(uint256 => Virus) public viruses; mapping(address => bool) public miniGames; struct Player { uint256 virusDef; uint256 nextTimeAtk; uint256 endTimeUnequalledDef; },1
0x0da29f924c83b623ea25aa95eedcba060b8d7e12.sol,VeloxCrowdsale,"contract VeloxCrowdsale is Ownable { using SafeMath for uint256; ERC20 public token; uint256 public startTime; uint256 public endTime; uint256 public rate; uint256 public cap; address public wallet; uint256 public sold; constructor( uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _cap, address _wallet, ERC20 _token ) public { require(_startTime >= block.timestamp && _endTime >= _startTime); require(_rate > 0); require(_cap > 0); require(_wallet != address(0)); require(_token != address(0)); startTime = _startTime; endTime = _endTime; rate = _rate; cap = _cap; wallet = _wallet; token = _token; }",1
0x6c764fac2ed1c5fabf8bcd86bae68d8cdbe8290e.sol,BaseWallet,"contract BaseWallet { address public implementation; address public owner; mapping (address => bool) public authorised; mapping (bytes4 => address) public enabled; uint public modules; event AuthorisedModule(address indexed module, bool value); event EnabledStaticCall(address indexed module, bytes4 indexed method); event Invoked(address indexed module, address indexed target, uint indexed value, bytes data); event Received(uint indexed value, address indexed sender, bytes data); event OwnerChanged(address owner); modifier moduleOnly { require(authorised[msg.sender], ); _; }",1
0xd0080a841a8c5d2b6cd4bc640cdad7846de14dbf.sol,FtvTimelockFactory,"contract FtvTimelockFactory is BasicToken { ERC20 public token; address public tokenAssignmentControl; constructor (ERC20 _token, address _tokenAssignmentControl) { token = _token; tokenAssignmentControl = _tokenAssignmentControl; }",1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x25066b77ae6174d372a9fe2b1d7886a2be150e9b.sol,PolarisDEX,"contract PolarisDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); function PolarisDEX(address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x655f1cb6616d7f0550007498113e72d7d5c5d4bb.sol,MedalClaim,"contract MedalClaim is AccessControl, SafeMath { address public angelCardDataContract = 0x6D2E76213615925c5fc436565B5ee788Ee0E86DC; address public petCardDataContract = 0xB340686da996b8B3d486b4D27E38E38500A9E926; address public accessoryDataContract = 0x466c44812835f57b736ef9F63582b8a6693A14D0; address public leaderboardDataContract = 0x9A1C755305c6fbf361B4856c9b6b6Bbfe3aCE738; address public medalDataContract = 0x33A104dCBEd81961701900c06fD14587C908EAa3; event EventMedalSuccessful(address owner,uint64 Medal); struct Angel { uint64 angelId; uint8 angelCardSeriesId; address owner; uint16 battlePower; uint8 aura; uint16 experience; }",1
0x4cd988afbad37289baaf53c13e98e2bd46aaea8c.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint256 supply) { _balances[msg.sender] = supply; _supply = supply; }",1
0x9271a6512b8f27a5f8daa01a62bdc533709e859a.sol,LockToken,"contract LockToken is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; event TokenReleased(address beneficiary, uint256 token_amount); constructor(address tokenContractAddress, address _beneficiary) public{ token_reward = token(tokenContractAddress); beneficiary = _beneficiary; }",1
0x46c9f93c3249c430c6ca19f02240ef9e038ba9d1.sol,Escapable,"contract Escapable is Owned { address public escapeHatchCaller; address public escapeHatchDestination; mapping (address=>bool) private escapeBlacklist; function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) { escapeHatchCaller = _escapeHatchCaller; escapeHatchDestination = _escapeHatchDestination; }",1
0x741f58cd68d24f361cc0ee0d3aaf7df2bf16132e.sol,BlockonixToken,"contract BlockonixToken is IERC20, Ownable, Vestable, HasAddresses, VestingPeriods, IsUpgradable { using SafeMathLib for uint256; uint256 public constant totalTokenSupply = 1009208335 * 10**16; uint256 public burntTokens; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; mapping (address => uint256) public balances; mapping(address => mapping(address => uint256)) approved; event Upgraded(address _owner, uint256 amount); constructor() public { uint256 lockedTokenPerAddress = 280335648611111000000000; balances[founder1FirstLockup] = lockedTokenPerAddress; balances[founder2FirstLockup] = lockedTokenPerAddress; balances[founder3FirstLockup] = lockedTokenPerAddress; balances[founder1SecondLockup] = lockedTokenPerAddress; balances[founder2SecondLockup] = lockedTokenPerAddress; balances[founder3SecondLockup] = lockedTokenPerAddress; balances[founder1ThirdLockup] = lockedTokenPerAddress; balances[founder2ThirdLockup] = lockedTokenPerAddress; balances[founder3ThirdLockup] = lockedTokenPerAddress; emit Transfer(address(this), founder1FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder1SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder1ThirdLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2ThirdLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3ThirdLockup, lockedTokenPerAddress); addVestingAddress(founder1FirstLockup, firstLockup); addVestingAddress(founder2FirstLockup, firstLockup); addVestingAddress(founder3FirstLockup, firstLockup); addVestingAddress(founder1SecondLockup, secondLockup); addVestingAddress(founder2SecondLockup, secondLockup); addVestingAddress(founder3SecondLockup, secondLockup); addVestingAddress(founder1ThirdLockup, thirdLockup); addVestingAddress(founder2ThirdLockup, thirdLockup); addVestingAddress(founder3ThirdLockup, thirdLockup); }",1
0x1cdc6b8fe34d313ee45fcd98d7391b6f564069a4.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; token myToken; address public wallet; uint256 public rate = 750000 ; uint256 public weiRaised; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); constructor(address tokenContractAddress, address _walletAddress) public{ wallet = _walletAddress; myToken = token(tokenContractAddress); }",1
0x18f0cd26c06449d967ca6aef8b5f9d8ee9fd7992.sol,Exch,"contract Exch is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; mapping (address => bool) public whiteListERC20; mapping (address => bool) public whiteListERC223; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); modifier onlyAdmin() { require(msg.sender==admin); _; }",1
0x20c476bb4c7aa64f919278fb9c09e880583beb4c.sol,X3ProfitMainFundTransfer,contract X3ProfitMainFundTransfer { uint public constant maxBalance = 340282366920938463463374607431768211456 wei; address public constant ADDRESS_EIFP2_CONTRACT = 0xf85D337017D9e6600a433c5036E0D18EdD0380f3; address public constant ADDRESS_ADMIN = 0x6249046Af9FB588bb4E70e62d9403DD69239bdF5; bool private isResend = false; function () external payable { if(msg.value == 0 || (msg.sender == ADDRESS_EIFP2_CONTRACT && msg.value >= 0.1 ether && !isResend)){ if(ADDRESS_EIFP2_CONTRACT.balance > maxBalance) { ADDRESS_ADMIN.transfer(address(this).balance); return; },1
0x1860d43a2a1b9b03907eb6a6b92ce256694dd315.sol,NescrowExchangeService,contract NescrowExchangeService { address owner = msg.sender; uint256 public feeRateLimit = 200; uint256 public takerFeeRate = 0; uint256 public makerFeeRate = 0; address public feeAddress; mapping (address => bool) public admins; mapping (bytes32 => uint256) public orderFills; mapping (bytes32 => uint256) public orderPaymentFills; mapping (bytes32 => bool) public withdrawn; mapping (bytes32 => bool) public transfers; mapping (address => mapping (address => uint256)) public balances; mapping (address => uint256) public tradesLocked; mapping (address => uint256) public disableFees; mapping (address => uint256) public tokenDecimals; mapping (address => bool) public tokenRegistered; struct EIP712Domain { string name; string version; uint256 chainId; address verifyingContract; },1
0x18dc28340ddde25fa8c3b51f5d6a82b1706c8e20.sol,WitnessJury,contract WitnessJury is SafeMath { mapping(address => uint) public balances; uint public limit = 10 ** 16; uint public numWitnessesBeforeLimit = 100; uint public totalBalance; uint public numWitnesses; uint public blockPeriod = 6000; uint public desiredWitnesses = 2; uint public desiredJurors = 3; uint public penalty = 50 * (10 ** 16); address public token; mapping(uint => Request) public requests; uint public numRequests; mapping(uint => uint) public requestsPerBlockGroup; uint public drmVolumeCap = 10000; uint public drmMinFee = 25 * (10 ** 16); uint public drmMaxFee = 50 * (10 ** 16); mapping(uint => bool) public juryNeeded; mapping(uint => mapping(address => bool)) public juryVoted; mapping(uint => uint) public juryYesCount; mapping(uint => uint) public juryNoCount; mapping(uint => address[]) public juryYesVoters; mapping(uint => address[]) public juryNoVoters; struct Request { string key; address witness1; address witness2; string answer1; string answer2; uint winner1; uint winner2; uint fee; address challenge; uint blockNumber; },1
0x1b6c5864375b34af3ff5bd2e5f40bc425b4a8d79.sol,TopChainCoinDistribution,"contract TopChainCoinDistribution is Ownable, Authorizable { using SafeMath for uint; event AuthorizedCreateToPrivate(address recipient, uint pay_amount); event GameMining(address recipient, uint pay_amount); event CreateTokenToTeam(address recipient, uint pay_amount); event CreateTokenToMarket(address recipient, uint pay_amount); event CreateTokenToOperation(address recipient, uint pay_amount); event TopChainCoinMintFinished(); TopChainCoin public token = new TopChainCoin(); DateTime internal dateTime = new DateTime(); uint totalToken = 2100000000 * (10 ** 6); uint public privateTokenCap = 210000000 * (10 ** 6); uint public marketToken = 315000000 * (10 ** 6); uint public operationToken = 210000000 * (10 ** 6); uint public gameMiningTokenCap = 1155000000 * (10 ** 6); uint public teamToken2018 = 105000000 * (10 ** 6); uint public teamToken2019 = 105000000 * (10 ** 6); uint public privateToken = 0; address public teamAddress; address public operationAddress; address public marketAddress; bool public team2018TokenCreated = false; bool public team2019TokenCreated = false; bool public operationTokenCreated = false; bool public marketTokenCreated = false; mapping(uint16 => uint) public gameMiningToken; uint public firstYearGameMiningTokenCap = 577500000 * (10 ** 6); uint public gameMiningTokenStartTime = 1514736000; function isContract(address _addr) internal view returns(bool) { uint size; if (_addr == 0) return false; assembly { size := extcodesize(_addr) }",1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x00676065a7854163c6a4d5f474496514d03e31c4.sol,CrystalDeposit,contract CrystalDeposit { using SafeMath for uint256; address public administrator; uint256 public HALF_TIME = 48 hours; uint256 public MIN_TIME_WITH_DEADLINE = 12 hours; uint256 public round = 0; CryptoEngineerInterface public Engineer; CryptoMiningWarInterface public MiningWar; address miningWarAddress; uint256 miningWarDeadline; uint256 constant private CRTSTAL_MINING_PERIOD = 86400; mapping(uint256 => Game) public games; mapping(address => Player) public players; mapping(address => bool) public miniGames; struct Game { uint256 round; uint256 crystals; uint256 prizePool; uint256 startTime; uint256 endTime; bool ended; },1
0x1bcbc935b377432224b9050211edaaf67f184f0d.sol,subSale,contract subSale{ AbstractENS ens = AbstractENS(0x314159265dD8dbb310642f98f50C066173C1259b); address admin = 0x1f51d1d29AaFb00188168227a49d8f7E5D5b5bD9; struct Domain{ address originalOwner; uint regPeriod; bool subSale; uint subPrice; uint subExpiry; },1
0x64db5062c388e90448556b81354d14c6eb0ae9c8.sol,ARXToken,contract ARXToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 10000000 * (10**2); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function ARXToken () { owner = msg.sender; },1
0x1d86a854da490ff74dedc7abe281fb468f8c19ee.sol,MultiVesting,"contract MultiVesting is Ownable, Destroyable { using SafeMath for uint256; struct Beneficiary { string description; uint256 vested; uint256 released; uint256 start; uint256 cliff; uint256 duration; bool revoked; bool revocable; bool isBeneficiary; }",1
0x8615ddfe9d4c9e58abff01c999731f3e9e556e80.sol,FrozenToken,"contract FrozenToken is ERC20Token, ITokenRecipient { mapping (address => bool) frozeds; uint256 public frozedCount; bool public freezeEnabled = false; bool public autoFreeze = false; bool public mintFinished = false; event Freeze(address indexed wallet); event UnFreeze(address indexed wallet); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); event Mint(address indexed sender, address indexed wallet, uint256 amount); event ReceiveTokens(address indexed spender, address indexed token, uint256 value, bytes extraData); event ApproveAndCall(address indexed spender, uint256 value, bytes extraData); event Burn(address indexed sender, uint256 amount); event MintFinished(address indexed spender); modifier notFreeze { require(frozeds[msg.sender] == false || freezeEnabled == false); _; }",1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,SaleClockAuction,"contract SaleClockAuction is ClockAuction { bool public isSaleClockAuction = true; uint256 public gen0SaleCount; uint256[5] public lastGen0SalePrices; constructor(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0xaa63c8683647ef91b3fdab4b4989ee9588da297b.sol,ProxyRegistry,contract ProxyRegistry { mapping(address=>DSProxy[]) public proxies; mapping(address=>uint) public proxiesCount; DSProxyFactory factory; function ProxyRegistry(DSProxyFactory factory_) public { factory = factory_; },1
0x3420894bf786866a09937b0369d5b4781870c21f.sol,LikeCoin,"contract LikeCoin is ERC20, HasOperator { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public supply = 0; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; address public crowdsaleAddr = 0x0; address public contributorPoolAddr = 0x0; uint256 public contributorPoolMintQuota = 0; address[] public creatorsPoolAddrs; mapping(address => bool) isCreatorsPool; uint256 public creatorsPoolMintQuota = 0; mapping(address => uint256) public lockedBalances; uint public unlockTime = 0; SignatureChecker public signatureChecker = SignatureChecker(0x0); bool public signatureCheckerFreezed = false; address public signatureOwner = 0x0; bool public allowDelegate = true; mapping (address => mapping (uint256 => bool)) public usedNonce; mapping (address => bool) public transferAndCallWhitelist; event Lock(address indexed _addr, uint256 _value); event SignatureCheckerChanged(address _newSignatureChecker); function LikeCoin(uint256 _initialSupply, address _signatureOwner, address _sigCheckerAddr) public { supply = _initialSupply; balances[owner] = _initialSupply; signatureOwner = _signatureOwner; signatureChecker = SignatureChecker(_sigCheckerAddr); Transfer(0x0, owner, _initialSupply); }",1
0x890ee942fdce38034e3d3813344649c77a29e68f.sol,LemonSelfDrop1,contract LemonSelfDrop1 is Ownable { LemonToken public LemonContract; uint8 public dropNumber; uint256 public LemonsDroppedToTheWorld; uint256 public LemonsRemainingToDrop; uint256 public holderAmount; uint256 public basicReward; uint256 public holderReward; mapping (uint8 => uint256[]) donatorReward; uint8 donatorRewardLevels; uint8 public totalDropTransactions; mapping (address => uint8) participants; function LemonSelfDrop1 () { address c = 0x2089899d03607b2192afb2567874a3f287f2f1e4; LemonContract = LemonToken(c); dropNumber = 1; LemonsDroppedToTheWorld = 0; LemonsRemainingToDrop = 0; basicReward = 500; donatorRewardLevels = 1; totalDropTransactions = 0; },1
0xb3e396f500df265cdfde30ec6e80dbf99bee9e96.sol,pg_bank,"contract pg_bank { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x6fa883afde9bc8d9bec0fc7bff25db3c71864402.sol,CryptoProgramFactory,contract CryptoProgramFactory { using SafeMath for uint256; address public administrator; uint256 private BASE_PRICE = 0.1 ether; uint256 private BASE_TIME = 4 hours; MemoryFactoryInterface public Memory; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; uint256 public miningWarDeadline; mapping(uint256 => Factory) public factories; mapping(address => bool) public miniGames; struct Factory { uint256 level; uint256 crystals; uint256 programPriceByCrystals; uint256 programPriceByDarkCrystals; uint256 programValue; uint256 eth; uint256 time; },1
0x6593a7140f3718efff638b72a9b6083db47ce0d2.sol,Crowdsale,"contract Crowdsale is GuidedByRoles, ERC20Provider{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 90 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x730f8c40a08d02349a2d64e3193cf207a2a2dfe7.sol,PG_Bank,"contract PG_Bank { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x182f2b554462230735699df74ec9606a3c4c0684.sol,BookERC20EthV1Dec,contract BookERC20EthV1Dec { enum BookType { ERC20EthV1 },1
0x3478c2e4ed6f64db0be9c483b87f70ff6ab0d65a.sol,MultiTokenNetwork,"contract MultiTokenNetwork is Pausable { event NewMultitoken(address indexed mtkn); event NewDeployer(uint256 indexed index, address indexed oldDeployer, address indexed newDeployer); address[] public multitokens; mapping(uint256 => IDeployer) public deployers; function multitokensCount() public view returns(uint256) { return multitokens.length; }",1
0x40818f0d14325a9eba6b2a7d60bd61cb9e27ef0c.sol,Trade,"contract Trade is Registry { using SafeMath for uint; using SafeMath for uint256; event KyberTrade( address src, uint srcAmt, address dest, uint destAmt, address beneficiary, uint minConversionRate, address affiliate ); function executeTrade( address src, address dest, uint srcAmt, uint minConversionRate ) public payable returns (uint destAmt) { address protocolAdmin = getAddress(); uint ethQty; IERC20 tokenFunctions = IERC20(src); if (src == getAddress()) { require(msg.value == srcAmt, ); ethQty = srcAmt; }",1
0x6f9e77dc013e6a7156a5aeb26fb095f3405fd911.sol,FlexibleTokenSale,"contract FlexibleTokenSale is Owned { using SafeMath for uint256; bool public suspended; uint256 public tokenPrice; uint256 public tokenPerEther; uint256 public contributionMin; uint256 public tokenConversionFactor; address public walletAddress; TokenTransfer token; uint256 public totalTokensSold; uint256 public totalEtherCollected; address public priceUpdateAddress; event Initialized(); event TokenPriceUpdated(uint256 _newValue); event TokenPerEtherUpdated(uint256 _newValue); event TokenMinUpdated(uint256 _newValue); event WalletAddressUpdated(address indexed _newAddress); event SaleSuspended(); event SaleResumed(); event TokensPurchased(address indexed _beneficiary, uint256 _cost, uint256 _tokens); event TokensReclaimed(uint256 _amount); event PriceAddressUpdated(address indexed _newAddress); function FlexibleTokenSale(address _tokenAddress,address _walletAddress,uint _tokenPerEther,address _priceUpdateAddress) public Owned() { require(_walletAddress != address(0)); require(_walletAddress != address(this)); require(address(token) == address(0)); require(address(_tokenAddress) != address(0)); require(address(_tokenAddress) != address(this)); require(address(_tokenAddress) != address(walletAddress)); walletAddress = _walletAddress; priceUpdateAddress = _priceUpdateAddress; token = TokenTransfer(_tokenAddress); suspended = false; tokenPrice = 100; tokenPerEther = _tokenPerEther; contributionMin = 5 * 10**18; totalTokensSold = 0; totalEtherCollected = 0; tokenConversionFactor = 10**(uint256(18).sub(token.decimals()).add(2)); assert(tokenConversionFactor > 0); }",1
0xbc97f1508fdeb0a63b25f3a4806b62ef5370e8ab.sol,CryptoBeginnerQuest,contract CryptoBeginnerQuest { using SafeMath for uint256; address private administrator; address public miningWarAddress; CryptoEngineerInterface public Engineer; CryptoDepositInterface public Deposit; CryptoMiningWarInterface public MiningWar; CryptoAirdropGameInterface public AirdropGame; CryptoBossWannaCryInterface public BossWannaCry; CryptoArenaInterface public Arena; uint256 private miningWarDeadline; uint256 private miningWarRound; mapping(address => Player) private players; mapping(address => MinerQuest) private minerQuests; mapping(address => EngineerQuest) private engineerQuests; mapping(address => DepositQuest) private depositQuests; mapping(address => JoinAirdropQuest) private joinAirdropQuests; mapping(address => AtkBossQuest) private atkBossQuests; mapping(address => AtkPlayerQuest) private atkPlayerQuests; mapping(address => BoosterQuest) private boosterQuests; mapping(address => RedbullQuest) private redbullQuests; struct Player { uint256 miningWarRound; uint256 currentQuest; },1
0x6bfa4c3c887fdc965bda1f09ff65fbf1f3d8b58d.sol,AsetSale,contract AsetSale is Ownable { using SafeMath for uint256; AsetToken public token; uint256 public price; address public wallet; uint256 public totalRice = 0; uint256 public totalTokenRice = 0; function AsetSale() public { price = 1300; wallet = msg.sender; },1
0x1d1811189e2a8dd8d5f22cdc164273bf3d6fdd43.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; },1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,Token,"contract Token { using SafeMath for uint256; mapping (address => uint256) public balances; mapping(address => mapping (address => uint256)) allowed; address[] allTokenHolders; string public name; string public symbol; uint8 public decimals; uint256 totalSupplyAmount = 0; address public refundManagerContractAddress; AuthenticationManager authenticationManager; LockinManager lockinManager; function availableBalance(address _owner) constant returns(uint256) { uint256 length = lockinManager.getLocks(_owner); uint256 lockedValue = 0; for(uint256 i = 0; i < length; i++) { if(lockinManager.getLocksUnlockDate(_owner, i) > now) { uint256 _value = lockinManager.getLocksAmount(_owner, i); lockedValue = lockedValue.add(_value); }",1
0x0e8175729e02db48ca0e2ca80efb72fe84a7dedd.sol,MechanicKittyUnit,"contract MechanicKittyUnit is ERC20, PremiumUnit { using SafeMath for uint; string public constant name = ; string public constant symbol = ; uint256 public constant unitId = 3; uint256 public unitProductionSeconds = 43200; uint8 public constant decimals = 0; Units constant units = Units(0xf936AA9e1f22C915Abf4A66a5a6e94eb8716BA5e); address constant factories = 0xC767B1CEc507f1584469E8efE1a94AD4c75e02ed; mapping(address => uint256) balances; mapping(address => uint256) lastEquipTime; mapping(address => mapping(address => uint256)) allowed; uint256 public totalSupply; function totalSupply() external view returns (uint) { return totalSupply.sub(balances[address(0)]); }",1
0x26613b4ca0cad3b418e49e19626c0ba3dd713673.sol,UNIT,contract UNIT is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 18000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function UNIT () { owner = msg.sender; },1
0xb4a3fb248d39370c1f8081b73fa7098167c8142b.sol,SaiLPC,"contract SaiLPC is DSThing { ERC20 public ref; ERC20 public alt; DSValue public pip; uint256 public gap; DSToken public lps; function SaiLPC(ERC20 ref_, ERC20 alt_, DSValue pip_, DSToken lps_) public { ref = ref_; alt = alt_; pip = pip_; lps = lps_; gap = WAD; }",1
0x574fb6d9d090042a04d0d12a4e87217f8303a5ca.sol,GoldBackedToken,"contract GoldBackedToken is Ownable, SafeMath, ERC20, Pausable { event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); event DeductFees(address indexed owner,uint256 amount); event TokenMinted(address destination, uint256 amount); event TokenBurned(address source, uint256 amount); string public name = ; string public symbol = ; uint256 constant public decimals = 18; uint256 constant public hgtDecimals = 8; uint256 constant public allocationPool = 1 * 10**9 * 10**hgtDecimals; uint256 constant public maxAllocation = 38 * 10**5 * 10**decimals; uint256 public totAllocation; address public feeCalculator; address public HGT; function setFeeCalculator(address newFC) onlyOwner { feeCalculator = newFC; }",1
0x655f1cb6616d7f0550007498113e72d7d5c5d4bb.sol,MedalClaim,"contract MedalClaim is AccessControl, SafeMath { address public angelCardDataContract = 0x6D2E76213615925c5fc436565B5ee788Ee0E86DC; address public petCardDataContract = 0xB340686da996b8B3d486b4D27E38E38500A9E926; address public accessoryDataContract = 0x466c44812835f57b736ef9F63582b8a6693A14D0; address public leaderboardDataContract = 0x9A1C755305c6fbf361B4856c9b6b6Bbfe3aCE738; address public medalDataContract = 0x33A104dCBEd81961701900c06fD14587C908EAa3; event EventMedalSuccessful(address owner,uint64 Medal); struct Angel { uint64 angelId; uint8 angelCardSeriesId; address owner; uint16 battlePower; uint8 aura; uint16 experience; }",1
0x1d1811189e2a8dd8d5f22cdc164273bf3d6fdd43.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; },1
0x5c89736e9454200141b80c37eb28eaceca2ce8cb.sol,CherryToken,"contract CherryToken is ERC223, ERCAddressFrozenFund { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; address public fundsWallet; uint256 internal fundsWalletChanged; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; constructor() public { _symbol = ; _name = ; _decimals = 8; _totalSupply = 10000000000000000; balances[msg.sender] = _totalSupply; fundsWallet = msg.sender; owner = msg.sender; fundsWalletChanged = 0; }",1
0x3fde21c4118a7ac77e113920f76f68edd4fc144d.sol,BEBmining,contract BEBmining is Ownable{ tokenTransfer public bebTokenTransfer; uint8 decimals = 18; struct BebUser { address customerAddr; uint256 amount; uint256 bebtime; uint256 interest; },1
0x27369e8f43f44c26853a46da7e6cb52d203b59ce.sol,AgileArbitrationWithAssistance,contract AgileArbitrationWithAssistance is Owned { address public operator; uint public quorum = 3; struct Dispute { address icoRoundAddress; address investorAddress; bool pending; uint timestamp; uint milestone; string reason; uint votesForProject; uint votesForInvestor; mapping(address => bool) voters; },1
0x3fe1bd3f808682e10cc16ccfc0e9476555ed93a7.sol,WFCToken,"contract WFCToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 625; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0x41b8578b7fe2bdcc4cb5c8e6ab18b11880072208.sol,BitcoinQuick,"contract BitcoinQuick { string public constant symbol = ; string public constant name = ; uint public constant decimals = 8; uint _totalSupply = 21000000 * 10 ** decimals; uint public marketSupply; uint public marketPrice; address owner; address airDropVerify; uint public airDropAmount; uint32 public airDropHeight; mapping (address => bool) public airDropMembers; mapping (address => uint) accounts; mapping (address => mapping (address => uint)) allowed; event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); function BitcoinQuick() public { owner = msg.sender; accounts[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); }",1
0x0e33ca464b1c76a384039eb1b7e9dc3b0416b5ae.sol,NamiCrowdSale,"contract NamiCrowdSale { using SafeMath for uint256; function NamiCrowdSale(address _escrow, address _namiMultiSigWallet, address _namiPresale) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; namiPresale = _namiPresale; }",1
0x013f7a6b98010e85fd4c8887d30f48c409b5643d.sol,TimedEscrow,"contract TimedEscrow is ContractReceiver, Seriality { using Array256Lib for uint256[]; struct Transaction { uint256 value; address to_address; uint256 time; bool valid; bool executed; }",1
0x0e69d0a2bbb30abcb7e5cfea0e4fde19c00a8d47.sol,DSStop,"contract DSStop is DSNote, DSAuth { bool public stopped; modifier stoppable { require(!stopped); _; }",1
0xa5e5be69c923c701ae6ac8f1f5936af3ae610c68.sol,Collectables,"contract Collectables is ERC721Full(, ), Ownable { using Strings for string; mapping(uint32 => address) public delegates; uint32[] public collectables; uint public delegateCount; event DelegateAdded(address indexed delegate, uint32 indexed delegateID); function addDelegate(address delegate) public onlyOwner { uint32 delegateID = uint32(delegateCount++); require(delegates[delegateID] == address(0), ); delegates[delegateID] = delegate; emit DelegateAdded(delegate, delegateID); }",1
0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol,DrainMe,"contract DrainMe { address public winner = 0x0; address public owner; address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b; address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766; address[] public players; mapping(address=>bool) approvedPlayers; uint256 public secret; uint256[] public seed = [951828771,158769871220]; uint256[] public balance; function DranMe() public payable{ owner = msg.sender; }",1
0x6dbc5978711cb22d7ba611bc18cec308ea12ea95.sol,PublicResolver,"contract PublicResolver { bytes4 constant INTERFACE_META_ID = 0x01ffc9a7; bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de; bytes4 constant NAME_INTERFACE_ID = 0x691f3431; bytes4 constant ABI_INTERFACE_ID = 0x2203ab56; bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233; bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c; bytes4 constant MULTIADDR_INTERFACE_ID = 0x4cb7724c; event AddrChanged(bytes32 indexed node, address a); event NameChanged(bytes32 indexed node, string name); event ABIChanged(bytes32 indexed node, uint256 indexed contentType); event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y); event TextChanged(bytes32 indexed node, string indexedKey, string key); event MultiaddrChanged(bytes32 indexed node, bytes addr); struct PublicKey { bytes32 x; bytes32 y; }",1
0x335c949c06fa1ba8744d98e3aa2c2a2deaa9255c.sol,Exchanger,"contract Exchanger is Administered, tokenRecipient { bool public enabled = false; ITradeableAsset public tokenContract; IYeekFormula public formulaContract; uint32 public weight; uint32 public fee=5000; uint32 public multiplier=1; uint32 public collectedFees=0; constructor(address _token, uint32 _weight, address _formulaContract) { require (_weight > 0 && weight <= 1000000); weight = _weight; tokenContract = ITradeableAsset(_token); formulaContract = IYeekFormula(_formulaContract); }",1
0x6ff869d8727ef71369dd33d7e6fd63da31ae203f.sol,STARTToken,contract STARTToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 500000000000 * (10**5); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function STARTToken () { owner = msg.sender; },1
0x561eac93c92360949ab1f1403323e6db345cbf31.sol,BANK_SAFE,contract BANK_SAFE { mapping (address=>uint256) public balances; uint public MinSum; LogFile Log; bool intitalized; function SetMinSum(uint _val) public { if(intitalized)throw; MinSum = _val; },1
0x509887e0ea70bf8f471a2fb8696979b3abf07650.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward; uint256 public price = 300; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() { wallet = 0xCEf8A431c0f0C512A587ab3f8470586c2dD1D3EB; addressOfTokenUsedAsReward = 0xB4E3362ee28105CD6D99278424d2176c4F3d76cE; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x0096dc2246fc3627cc2bf87a3b0d2e0f87b58589.sol,Zethroll,"contract Zethroll is ZTHReceivingContract { using SafeMath for uint; modifier betIsValid(uint _betSize, uint _playerNumber) { require( calculateProfit(_betSize, _playerNumber) < maxProfit && _betSize >= minBet && _playerNumber > minNumber && _playerNumber < maxNumber); _; }",1
0x74ceda99c44da280f2fd8ea8b5dd43f8b66912a8.sol,DisbursementHandler,contract DisbursementHandler is Ownable { struct Disbursement { uint256 timestamp; uint256 tokens; },1
0x1f52b87c3503e537853e160adbf7e330ea0be7c4.sol,ClockAuction,contract ClockAuctionBase { struct Auction { address nftAddress; address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0xb42ce9d2a22061b7d5e569753f92edbaa2dad37b.sol,Exchanger,"contract Exchanger is Administered { bool public enabled = false; ITradeableAsset public tokenContract; IYeekFormula public formulaContract; uint32 public weight; constructor(address _token, uint32 _weight, address _formulaContract) { require (_weight > 0 && weight <= 1000000); weight = _weight; tokenContract = ITradeableAsset(_token); formulaContract = IYeekFormula(_formulaContract); }",1
0x33b7a018934c6e90fd63189d7c4517f0f776142f.sol,ChronoBankAssetProxy,"contract ChronoBankAssetProxy is ERC20 { uint constant OK = 1; ChronoBankPlatform public chronoBankPlatform; bytes32 public smbl; string public name; string public symbol; function init(ChronoBankPlatform _chronoBankPlatform, string _symbol, string _name) returns(bool) { if (address(chronoBankPlatform) != 0x0) { return false; }",1
0xf508548ef0ef6472760a36e15169b847ae427d38.sol,CrowdsaleCompatible,"contract CrowdsaleCompatible is BasicERC20, Ownable { BasicCrowdsale public crowdsale = BasicCrowdsale(0x0); function unfreezeTokens() public { assert(now > crowdsale.endTime()); isTokenTransferable = true; }",1
0x0114289efe38186b732d12c07a1ce4341e266513.sol,PreICO,"contract PreICO is ReentrancyGuard, Ownable, Stateful { using SafeMath for uint256; DLH public token; address public wallet; uint256 public startPreICOTime; uint256 public endPreICOTime; uint256 public rate; uint256 public priceUSD; uint256 public centRaised; uint256 public minimumInvest; uint256 public softCapPreSale; uint256 public hardCapPreSale; uint256 public hardCapPrivate; address public oracle; address public manager; mapping(address => uint) public balances; mapping(address => uint) public balancesInCent; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PreICO( address _wallet, address _token, uint256 _priceUSD, uint256 _minimumInvest) public { require(_priceUSD != 0); require(_wallet != address(0)); require(_token != address(0)); priceUSD = _priceUSD; rate = 250000000000000000; wallet = _wallet; token = DLH(_token); hardCapPrivate = 40000000; minimumInvest = _minimumInvest; }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,Court,"contract Court is Owned, SafeDecimalMath { Havven public havven; EtherNomin public nomin; uint public minStandingBalance = 100 * UNIT; uint public votingPeriod = 1 weeks; uint constant MIN_VOTING_PERIOD = 3 days; uint constant MAX_VOTING_PERIOD = 4 weeks; uint public confirmationPeriod = 1 weeks; uint constant MIN_CONFIRMATION_PERIOD = 1 days; uint constant MAX_CONFIRMATION_PERIOD = 2 weeks; uint public requiredParticipation = 3 * UNIT / 10; uint constant MIN_REQUIRED_PARTICIPATION = UNIT / 10; uint public requiredMajority = (2 * UNIT) / 3; uint constant MIN_REQUIRED_MAJORITY = UNIT / 2; uint nextMotionID = 1; mapping(uint => address) public motionTarget; mapping(address => uint) public targetMotionID; mapping(uint => uint) public motionStartTime; mapping(uint => uint) public votesFor; mapping(uint => uint) public votesAgainst; mapping(address => mapping(uint => uint)) voteWeight; enum Vote {Abstention, Yea, Nay}",1
0xd04877a45079ac978118aa8ae8c53770c4ee075a.sol,TUIToken,contract TUIToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function TUIToken () { owner = msg.sender; },1
0x18b51eb9e6811fd8055a9fd5f06691eaac3bc6fe.sol,MKYCToken,contract MKYCToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 200000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function MKYCToken () { owner = msg.sender; },1
0xec2e5c8d51fdd54fef83db8300399a3c2e167922.sol,CrowdsaleToken,"contract CrowdsaleToken is Manageable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public totalSupply; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; mapping (address => uint256) public releaseTime; bool public released; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Mint(address indexed _to, uint256 _value); event ReleaseTimeChanged(address indexed _owner, uint256 _oldReleaseTime, uint256 _newReleaseTime); event ReleasedChanged(bool _oldReleased, bool _newReleased); modifier canTransfer(address _from) { if (releaseTime[_from] == 0) { require(released); }",1
0x7868fc162988289062dbcdb670a3cf6c8da66f84.sol,CDMarketplace,contract CDMarketplace is Ownable { bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba; address public wallet; uint256 public fee_percentage; ERC721Basic public token; address public manager; address internal checkAndBuySender; address public TVTokenAddress; address public TVCrowdsaleAddress; bytes4 constant TOKEN_RECEIVED = bytes4(keccak256()); modifier onlyOwnerOrManager() { require(msg.sender == owner || manager == msg.sender); _; },1
0x5b566b473bb0ea8dc0fc6047dd623e5fa3b42307.sol,Auction,contract Auction is Beneficial { function Auction(address _gameToken) public { owner = msg.sender; shareholder = _gameToken; shareholderIsToken = true; },1
0x3ac86159fad58c90aaea1c61974d69d4f8ce8e77.sol,Crowdsale,contract Crowdsale is Ownable { using SafeMath for uint256; SingleTokenCoin public token; WrapperOraclize private wrapper = WrapperOraclize(0xfC484c66daE464CC6055d7a4782Ec8761dc9842F); uint256 private angel_sale_start; uint256 private angel_sale_finish; uint256 private pre_sale_start; uint256 private pre_sale_finish; uint256 private public_sale_start; uint256 private public_sale_finish; bool private isAngel; bool private isPreSale; bool private isPublic; uint256 private angel_rate; uint256 private public_rate; uint256 private decimals; uint256 private totalETH; address public coreTeamAddr; address public itDevAddr; address public futDevAddr; address public commFoundAddr; address public socWarefareAddr; address public marketingAddr; address public unsoldAddr; address public collectAddr; bool public mintingFinished = false; mapping(address => uint256) private founding_buyers_token; mapping(address => uint256) private angel_buyers_eth; mapping(address => uint256) private angel_buyers_token; mapping(address => uint256) private pre_sale_buyers_eth; mapping(address => uint256) private pre_sale_buyers_token; mapping(address => uint256) private pe_buyers_token; mapping(address => uint256) private public_buyers_eth; mapping(address => uint256) private public_buyers_token; address[] private founding_investors; address[] private pre_sale_investors; address[] private angel_investors; address[] private pe_investors; address[] private public_investors; uint256 private soldTokens; uint256 private maxcup; uint256 private totalAmount; uint256 private foundingAmount; uint256 private angelAmount; uint256 private preSaleAmount; uint256 private PEInvestorAmount; uint256 private publicSaleAmount; uint256 private coreTeamAmount; uint256 private coreTeamAuto; uint256 private coreTeamManual; uint256 private itDevAmount; uint256 private futDevAmount; uint256 private commFoundAmount; uint256 private socWarefareAmount; uint256 private marketingAmount; uint256 private angel_sale_sold; uint256 private pre_sale_sold; uint256 private public_sale_sold; uint256 private founding_sold; uint256 private peInvestors_sold; uint256 private angel_sale_totalETH; uint256 private pre_sale_totalETH; uint256 private public_sale_totalETH; uint256 private firstPhaseAmount; uint256 private secondPhaseAmount; uint256 private thirdPhaseAmount; uint256 private fourPhaseAmount; uint256 private firstPhaseDiscount; uint256 private secondPhaseDiscount; uint256 private thirdPhaseDiscount; uint256 private fourPhaseDiscount; uint256 private currentPhase; bool private moveTokens; bool withdrowTokensComplete = false; function Crowdsale(address token_addr) { token = SingleTokenCoin(token_addr); public_rate = 3546099290780141; angel_rate = 20; decimals = 35460992907801; angel_sale_start = now - 3 days; angel_sale_finish = 1510488000; pre_sale_start = 1510491600; pre_sale_finish = 1512561600; public_sale_start = 1512565200; public_sale_finish = public_sale_start + 14 days; moveTokens = false; isAngel = true; isPreSale = false; isPublic = false; currentPhase = 1; founding_sold = 0; peInvestors_sold = 0; angel_sale_sold = 0; pre_sale_sold = 0; public_sale_sold = 0; angel_sale_totalETH = 0; pre_sale_totalETH = 0; public_sale_totalETH = 0; firstPhaseAmount = 18750000E18; secondPhaseAmount = 37500000E18; thirdPhaseAmount = 56250000E18; fourPhaseAmount = 75000000E18; firstPhaseDiscount = 30; secondPhaseDiscount = 40; thirdPhaseDiscount = 50; fourPhaseDiscount = 60; totalAmount = 500000000E18; foundingAmount = 10000000E18; angelAmount = 25000000E18; preSaleAmount = 75000000E18; PEInvestorAmount = 50000000E18; publicSaleAmount = 100000000E18; coreTeamAmount = 100000000E18; coreTeamAuto = 60000000E18; coreTeamManual = 40000000E18; itDevAmount = 50000000E18; futDevAmount = 50000000E18; commFoundAmount = 15000000E18; socWarefareAmount = 10000000E18; marketingAmount = 15000000E18; mintingFinished = false; coreTeamAddr = 0xB0A3A845cfA5e2baCD3925Af85c59dE4D32D874f; itDevAddr = 0x61528ffdCd4BC26c81c88423018780b399Fbb8e7; futDevAddr = 0xA1f9C3F137496e6b8bA4445d15b0986CaA22FDe3; commFoundAddr = 0xC30a0E7FFad754A9AD2A1C1cFeB10e05f7C7aB6A; socWarefareAddr = 0xd5d692C89C83313579d02C94F4faE600fe30D1d9; marketingAddr = 0x5490510072b929273F65dba4B72c96cd45A99b5A; unsoldAddr = 0x18051b5b0F1FDb4D44eACF2FA49f19bB80105Fc1; collectAddr = 0xB338121B8e5dA0900a6E8580321293f3CF52E58D; },1
0x57775c09b07896b979bb192b1b13df5a268757bd.sol,FutureTokenSaleLockBox,"contract FutureTokenSaleLockBox is Owned { using SafeMath for uint256; ERC20Interface public simpleToken; TokenSaleInterface public tokenSale; uint256 public unlockDate; event UnlockDateExtended(uint256 _newDate); event TokensTransferred(address indexed _to, uint256 _value); function FutureTokenSaleLockBox(ERC20Interface _simpleToken, TokenSaleInterface _tokenSale) Owned() public { require(address(_simpleToken) != address(0)); require(address(_tokenSale) != address(0)); simpleToken = _simpleToken; tokenSale = _tokenSale; uint256 endTime = tokenSale.endTime(); require(endTime > 0); unlockDate = endTime.add(26 weeks); }",1
0x32f1c992a32376fa0f723aecaa247119d3f7f8bd.sol,Zethroll,"contract Zethroll is ZTHReceivingContract { using SafeMath for uint; modifier betIsValid(uint _betSize, uint _playerNumber) { require( calculateProfit(_betSize, _playerNumber) < maxProfit && _betSize >= minBet && _playerNumber > minNumber && _playerNumber < maxNumber); _; }",1
0x25b16c95f3ebb1d8583a1c173f81257bc916a9be.sol,PresalePool,"contract PresalePool is Ownable { PresaleToken public PublicPresale; PresaleToken public PartnerPresale; SignalsToken token; CrowdsaleRegister registry; uint256 compensation1; uint256 compensation2; uint256 deadLine; event SupporterResolved(address indexed supporter, uint256 burned, uint256 created); event PartnerResolved(address indexed partner, uint256 burned, uint256 created); function PresalePool(address _token, address _registry, address _owner, uint comp1, uint comp2) public { owner = _owner; PublicPresale = PresaleToken(0x15fEcCA27add3D28C55ff5b01644ae46edF15821); PartnerPresale = PresaleToken(0xa70435D1a3AD4149B0C13371E537a22002Ae530d); token = SignalsToken(_token); registry = CrowdsaleRegister(_registry); compensation1 = comp1; compensation2 = comp2; deadLine = now + 30 days; }",1
0x7868fc162988289062dbcdb670a3cf6c8da66f84.sol,CDMarketplace,contract CDMarketplace is Ownable { bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba; address public wallet; uint256 public fee_percentage; ERC721Basic public token; address public manager; address internal checkAndBuySender; address public TVTokenAddress; address public TVCrowdsaleAddress; bytes4 constant TOKEN_RECEIVED = bytes4(keccak256()); modifier onlyOwnerOrManager() { require(msg.sender == owner || manager == msg.sender); _; },1
0x8d46facfb889740a345755e624942257dc87b5ac.sol,UpgradeableToken,"contract UpgradeableToken is Owner, Token { address public migrationAgent; event Upgrade(address indexed from, address indexed to, uint256 value); event UpgradeAgentSet(address agent); function migrate() public { require(migrationAgent != 0); uint value = balances[msg.sender]; balances[msg.sender] = balances[msg.sender].sub(value); totalSupply = totalSupply.sub(value); MigrationAgent(migrationAgent).migrateFrom(msg.sender, value); emit Upgrade(msg.sender, migrationAgent, value); }",1
0x5adce2c8e78ca9102af302eab5937f7cefb0a266.sol,Reseller,"contract Reseller { mapping (address => uint256) public snt_claimed; uint256 public total_snt_claimed; ERC20 public token = ERC20(0x744d70FDBE2Ba4CF95131626614a1763DF805B9E); address developer = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e; function withdraw() { uint256 snt_to_withdraw = snt_claimed[msg.sender]; snt_claimed[msg.sender] = 0; total_snt_claimed -= snt_to_withdraw; if(!token.transfer(msg.sender, snt_to_withdraw)) throw; }",1
0x40da24a66f729d0bd0453681c5a6506bdc2a7a6a.sol,CrwdTimelock,"contract CrwdTimelock { using SafeMath for uint256; mapping(address => uint256) public balances; uint256 public assignedBalance; address public controller; uint public releaseTime; CrwdToken token; function CrwdTimelock(CrwdToken _token, address _controller, uint _releaseTime) { require(_releaseTime > now); token = _token; controller = _controller; releaseTime = _releaseTime; }",1
0x4c7f666ca30fe548fbdc08b0308927327f08336d.sol,VestedTokenDistributionStrategy,"contract VestedTokenDistributionStrategy is Ownable, FixedPoolWithBonusTokenDistributionStrategy { event Released(address indexed beneficiary, uint256 indexed amount); uint256 public vestingStart; bool public vestingConfigured = false; uint256 public vestingDuration; mapping (address => uint256) public released; modifier vestingPeriodStarted { require(crowdsale.hasEnded()); require(vestingConfigured == true); require(now > vestingStart); _; }",1
0x33e85f62383aa7601d6ca117fe35b9b397ffe056.sol,UXDToken,contract UXDToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 10000000000 * (10**2); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function UXDToken () { owner = msg.sender; },1
0x83a9f7c09e2b12b18b91611db6beee0e0329edb1.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; address public multisigVault; CJToken public coin; uint256 public startTime; uint256 public endTime; uint256 public weiRaised; uint256 public tokensSold; uint256 public maxCap; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(address _CJTokenAddress, address _to, uint256 _maxCap) { coin = CJToken(_CJTokenAddress); multisigVault = _to; maxCap = _maxCap; startTime = now; endTime = startTime + 75 days; }",1
0x1f52b87c3503e537853e160adbf7e330ea0be7c4.sol,ClockAuction,contract ClockAuctionBase { struct Auction { address nftAddress; address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x2628e13a3cbdc52ed96b4b8d6b1041d3ef3a409e.sol,EasySmartolution,"contract EasySmartolution { event ParticipantAdded(address _sender); event ParticipantRemoved(address _sender); event ReferrerAdded(address _contract, address _sender); mapping (address => address) public participants; mapping (address => bool) public referrers; address private processing; constructor(address _processing) public { processing = _processing; }",1
0xc0a1f89bbcaddab4b736e786b6b16c67bc92ed35.sol,GivethCampaign,"contract GivethCampaign is TokenController, Owned { uint public startFundingTime; uint public endFundingTime; uint public maximumFunding; uint public totalCollected; MiniMeToken public tokenContract; address public vaultAddress; function GivethCampaign( uint _startFundingTime, uint _endFundingTime, uint _maximumFunding, address _vaultAddress, address _tokenAddress ) { if ((_endFundingTime < now) || (_endFundingTime <= _startFundingTime) || (_maximumFunding > 10000000 ether) || (_vaultAddress == 0)) { throw; }",1
0x5adce2c8e78ca9102af302eab5937f7cefb0a266.sol,Reseller,"contract Reseller { mapping (address => uint256) public snt_claimed; uint256 public total_snt_claimed; ERC20 public token = ERC20(0x744d70FDBE2Ba4CF95131626614a1763DF805B9E); address developer = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e; function withdraw() { uint256 snt_to_withdraw = snt_claimed[msg.sender]; snt_claimed[msg.sender] = 0; total_snt_claimed -= snt_to_withdraw; if(!token.transfer(msg.sender, snt_to_withdraw)) throw; }",1
0x01e6a8af629cc06ff37755a61d9e7dd1135d8c6a.sol,Factory,"contract Factory { using SafeMath for uint256; address public owner; address public oracle_address; address public user_contract; address internal deployer_address; Deployer_Interface internal deployer; address public token; uint public fee; uint public swapFee; uint public duration; uint public multiplier; uint public token_ratio; address[] public contracts; uint[] public startDates; address public memberContract; uint whitelistedTypes; mapping(address => uint) public created_contracts; mapping(address => uint) public token_dates; mapping(uint => address) public long_tokens; mapping(uint => address) public short_tokens; mapping(address => uint) public token_type; event ContractCreation(address _sender, address _created); modifier onlyOwner() { require(msg.sender == owner); _; }",1
0xc6421ac09d20597ef8cdfcc8a89255fd2e3b51e4.sol,RECORDICO,contract RECORDICO { RECORDToken public RCD = new RECORDToken(); using SafeMath for uint256; uint256 public Rate_Eth = 690; uint256 public currentInitPart = 0; uint256 public constant RECORDPart = 18; uint256 public constant EcosystemPart = 15; uint256 public constant InvestorPart = 5; uint256 public constant AdvisorPart = 8; uint256 public constant BountyPart = 4; uint256 public constant icoPart = 50; uint256 public constant PreSaleHardCap = 15000000 * 1e18; uint256 public constant RoundAHardCap = 45000000 * 1e18; uint256 public constant RoundBHardCap = 45000000 * 1e18; uint256 public constant RoundCHardCap = 45000000 * 1e18; uint256 public constant totalAmountOnICO = 300000000 * 1e18; uint256 public PreSaleSold = 0; uint256 public RoundASold = 0; uint256 public RoundBSold = 0; uint256 public RoundCSold = 0; uint256 public EthGet = 0; uint256 public RcdGet = 0; address Company; address Manager; uint256 public PreSaleStartTime; uint256 public PreSaleCloseTime; uint256 public IcoStartTime; uint256 public IcoCloseTime; modifier managerOnly { require(msg.sender == Manager); _; },1
0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f.sol,PERSONAL_BANK,contract PERSONAL_BANK { mapping (address=>uint256) public balances; uint public MinSum = 1 ether; LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46); bool intitalized; function SetMinSum(uint _val) public { if(intitalized)revert(); MinSum = _val; },1
0x5af7af54e8bc34b293e356ef11fffe51d6f9ae78.sol,Sample,contract SampleStorage is Ownable { struct Sample { string ipfsHash; uint rarity; },1
0x01d6208f95cf2292c350fc8bb1b1f29230352675.sol,DRCWalletManager,"contract DRCWalletManager is OwnerContract, Withdrawable, TokenDestructible { using SafeMath for uint256; struct WithdrawWallet { bytes32 name; address walletAddr; }",1
0xeb9432f45ba981a907b6cfdd91fe71de10bf59f3.sol,TestBancorTradeBNBETH,"contract TestBancorTradeBNBETH { event Trade(uint256 srcAmount, uint256 destAmount); BancorContract public bancorTradingContract = BancorContract(0x8FFF721412503C85CFfef6982F2b39339481Bca9); function trade(address[] _path, uint256 _amount, uint256 _minReturn) { ERC20 src = ERC20(0xB8c77482e45F1F44dE1745F52C74426C631bDD52); src.approve(bancorTradingContract, _amount); uint256 destAmount = bancorTradingContract.quickConvert(_path, _amount, _minReturn); Trade(_amount, destAmount); }",1
0x1d1811189e2a8dd8d5f22cdc164273bf3d6fdd43.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; },1
0x39e8082b00c9f19ebf553e40feb7cf8459acc693.sol,DSStop,"contract DSStop is DSNote, DSAuth { bool public stopped; modifier stoppable { require(!stopped); _; }",1
0x3478c2e4ed6f64db0be9c483b87f70ff6ab0d65a.sol,MultiTokenNetwork,"contract MultiTokenNetwork is Pausable { event NewMultitoken(address indexed mtkn); event NewDeployer(uint256 indexed index, address indexed oldDeployer, address indexed newDeployer); address[] public multitokens; mapping(uint256 => IDeployer) public deployers; function multitokensCount() public view returns(uint256) { return multitokens.length; }",1
0x56853ab9006e0712b05c68b586372fcdde5236b9.sol,AirDrop,"contract AirDrop is Ownable { Token token; event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); modifier whenDropIsActive() { assert(isActive()); _; }",1
0x0f1c64c1259e28b564662ba41e994d67cb7b1519.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; using SafeERC20 for ERC20; ERC20 public token; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); constructor(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; }",1
0x3aa927a97594c3ab7d7bf0d47c71c3877d1de4a1.sol,MatchingMarket,"contract MatchingMarket is MatchingEvents, ExpiringMarket, DSNote { bool public buyEnabled = true; bool public matchingEnabled = true; struct sortInfo { uint next; uint prev; }",1
0x70c86655abce9db09c075d07b4eb11d4fa63cc8b.sol,StreamityTariff,contract StreamityTariff is Ownable { using ECRecovery for bytes32; uint8 constant public EMPTY = 0x0; TokenERC20 public streamityContractAddress; mapping(bytes32 => Deal) public stmTransfers; function StreamityTariff(address streamityContract) public { require(streamityContract != 0x0); streamityContractAddress = TokenERC20(streamityContract); },1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x46d1ebf7bb93044e078e0496e4661ec772607d9d.sol,TTCSale,"contract TTCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 30000; bool private rentrancy_lock = false; TTCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x6b4df2aa3d64d8dc06120ef4391513e4170af4a7.sol,GeneralTransferManager,contract GeneralTransferManager is ITransferManager { using SafeMath for uint256; address public issuanceAddress = address(0); address public signingAddress = address(0); bytes32 public constant WHITELIST = ; bytes32 public constant FLAGS = ; struct TimeRestriction { uint256 fromTime; uint256 toTime; uint256 expiryTime; bool canBuyFromSTO; },1
0x4176f0f2b7c95486a5ae06e3d1b29201a42e7630.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x1d63cf10fea9c7ec79817a1d2a4acf4e35b3be6f.sol,Refundable,"contract Refundable is Bitansuo { event RefundETH(address indexed owner, address indexed payee, uint256 amount); event RefundERC20(address indexed owner, address indexed payee, address indexed token, uint256 amount); function Refundable() public payable { }",1
0x6593a7140f3718efff638b72a9b6083db47ce0d2.sol,Crowdsale,"contract Crowdsale is GuidedByRoles, ERC20Provider{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 90 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0xa1ad52ff49fc70b7920b7d02483a58beb15d492b.sol,FoMo3Dlong,"contract FoMo3Dlong is modularLong { using SafeMath for *; using NameFilter for string; using F3DKeysCalcLong for uint256; address private owner = 0x0c204d9C438553a107B29cdE1d1e7954673b29B3; address private opAddress = 0x0c204d9C438553a107B29cdE1d1e7954673b29B3; address private comAddress = 0x24D160101C72c035287f772a8ac2b744a477F489; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x0f717ffff71e639636fcdd33727ee8c17c4724bf); string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 constant private rndInit_ = 2 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 2 hours; uint256 constant private comDropGap_ = 24 hours; uint256 constant private rndNTR_ = 168 hours; uint256 public airDropPot_; uint256 public airDropPot2_; uint256 public airDropTracker_ = 0; uint256 public airDropTracker2_ = 0; uint256 public rID_; uint256 public comReWards_; uint256 public comAirDrop_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => uint256) public inviteCount_; mapping (address => bool) public addrLock_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => uint256[10]) public lastTen_; mapping (uint256 => uint256) public roundBetCount_; mapping (uint256 => mapping (uint256 =>uint256)) public comDropLastTime_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(48,0); fees_[1] = F3Ddatasets.TeamFee(33,0); fees_[2] = F3Ddatasets.TeamFee(18,0); potSplit_[0] = F3Ddatasets.PotSplit(10,20); potSplit_[1] = F3Ddatasets.PotSplit(5,20); potSplit_[2] = F3Ddatasets.PotSplit(20,20); }",1
0x58db9e7a4afca731d824eeefa55ce37666aa3eaf.sol,FoMoGame,"contract FoMoGame is modularLong { using SafeMath for *; using NameFilter for string; using F3DKeysCalcLong for uint256; ForwarderInterface constant private Team_Forwarder = ForwarderInterface(0xfe373e4c13ed07962ffa546d1f0be2298d5493b0); PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x463a61560e0EFF1a7ec771eeb9fd1c93fb075c2E); address private backup = 0x7298EFD119A830edab6C442632EEff14292609B0; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 private rndGap_ = 0; uint256 constant private rndInit_ = 1 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(36,0); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(66,0); fees_[3] = F3Ddatasets.TeamFee(50,0); potSplit_[0] = F3Ddatasets.PotSplit(20,0); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(40,0); potSplit_[3] = F3Ddatasets.PotSplit(45,0); }",1
0x01e0f57c42bf976676ea1daa1b04d69aba6bdaf3.sol,BatchTransferWallet,"contract BatchTransferWallet is Ownable { using SafeMath for uint256; event LogWithdrawal(address indexed receiver, uint amount); function batchTransfer(address _tokenAddress, address[] _investors, uint256[] _tokenAmounts) public { ERC20BasicInterface token = ERC20BasicInterface(_tokenAddress); require(_investors.length == _tokenAmounts.length && _investors.length != 0); uint decimalsForCalc = 10 ** uint256(token.decimals()); for (uint i = 0; i < _investors.length; i++) { require(_tokenAmounts[i] > 0 && _investors[i] != 0x0); _tokenAmounts[i] = _tokenAmounts[i].mul(decimalsForCalc); require(token.transfer(_investors[i], _tokenAmounts[i])); }",1
0xec1bfc5a4a5655db224a6c591959865a837f53ba.sol,FandBToken,"contract FandBToken is Token(, , 0, 10000), ERC20, ERC223 { function FandBToken() public { _balanceOf[msg.sender] = _totalSupply; }",1
0x6e9d4b330aad2f414fa7ae1074afa266b6469364.sol,AetherClockAuction,"contract AetherClockAuction is ClockAuction { bool public isAetherClockAuction = true; uint256 public saleCount; uint256[5] public lastSalePrices; function AetherClockAuction(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x25d3b337e17ad34dbc8cb97d1a724545d90478fa.sol,AirdropiRide,contract AirdropiRide { Token public tokenReward; address public creator; address public owner = 0xd430B6C9706345760D94c4A8A14Cfa0164B04167; uint256 public startDate; uint256 public amount; modifier isCreator() { require(msg.sender == creator); _; },1
0x456c4350eefd17315713b265d8be8b6063a5fab8.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0x69ceaea78e28d62bc1ac68491d77f6a761edce01.sol,MDMCToken,"contract MDMCToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 28650; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0xd518db222f37f9109db8e86e2789186c7e340f12.sol,D_BANK,contract D_BANK { mapping (address=>uint256) public balances; uint public MinSum = 1 ether; LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46); bool intitalized; function SetMinSum(uint _val) public { if(intitalized)revert(); MinSum = _val; },1
0x0da29f924c83b623ea25aa95eedcba060b8d7e12.sol,VeloxCrowdsale,"contract VeloxCrowdsale is Ownable { using SafeMath for uint256; ERC20 public token; uint256 public startTime; uint256 public endTime; uint256 public rate; uint256 public cap; address public wallet; uint256 public sold; constructor( uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _cap, address _wallet, ERC20 _token ) public { require(_startTime >= block.timestamp && _endTime >= _startTime); require(_rate > 0); require(_cap > 0); require(_wallet != address(0)); require(_token != address(0)); startTime = _startTime; endTime = _endTime; rate = _rate; cap = _cap; wallet = _wallet; token = _token; }",1
0xb4a3fb248d39370c1f8081b73fa7098167c8142b.sol,SaiLPC,"contract SaiLPC is DSThing { ERC20 public ref; ERC20 public alt; DSValue public pip; uint256 public gap; DSToken public lps; function SaiLPC(ERC20 ref_, ERC20 alt_, DSValue pip_, DSToken lps_) public { ref = ref_; alt = alt_; pip = pip_; lps = lps_; gap = WAD; }",1
0x00c315ac9ff89bb6afa7524cd159f0a9766e8c89.sol,IMDEXDexchange,"contract IMDEXDexchange is SafeMath { address public owner; address IMDEXtoken = 0x46705E8fef2E868FACAFeDc45F47114EC01c2EEd; mapping (address => uint256) public invalidOrder; event SetOwner(address indexed previousOwner, address indexed newOwner); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x3420894bf786866a09937b0369d5b4781870c21f.sol,LikeCoin,"contract LikeCoin is ERC20, HasOperator { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public supply = 0; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; address public crowdsaleAddr = 0x0; address public contributorPoolAddr = 0x0; uint256 public contributorPoolMintQuota = 0; address[] public creatorsPoolAddrs; mapping(address => bool) isCreatorsPool; uint256 public creatorsPoolMintQuota = 0; mapping(address => uint256) public lockedBalances; uint public unlockTime = 0; SignatureChecker public signatureChecker = SignatureChecker(0x0); bool public signatureCheckerFreezed = false; address public signatureOwner = 0x0; bool public allowDelegate = true; mapping (address => mapping (uint256 => bool)) public usedNonce; mapping (address => bool) public transferAndCallWhitelist; event Lock(address indexed _addr, uint256 _value); event SignatureCheckerChanged(address _newSignatureChecker); function LikeCoin(uint256 _initialSupply, address _signatureOwner, address _sigCheckerAddr) public { supply = _initialSupply; balances[owner] = _initialSupply; signatureOwner = _signatureOwner; signatureChecker = SignatureChecker(_sigCheckerAddr); Transfer(0x0, owner, _initialSupply); }",1
0x01d6208f95cf2292c350fc8bb1b1f29230352675.sol,DepositWithdraw,"contract DepositWithdraw is Claimable, Withdrawable { using SafeMath for uint256; struct TransferRecord { uint256 timeStamp; address account; uint256 value; }",1
0xa27f262391913a5e21216c70de5358a1e887de25.sol,VestingContractWTTEST,contract VestingContractWTTEST { struct AccountData { uint original_balance; uint limit_per_period; uint current_balance; uint current_limit; uint current_transferred; },1
0x5a6d9a69408ce19df15eb40347ded3028a77fcca.sol,EthicHubLending,"contract EthicHubLending is EthicHubBase, Ownable, Pausable { using SafeMath for uint256; enum LendingState { Uninitialized, AcceptingContributions, ExchangingToFiat, AwaitingReturn, ProjectNotFunded, ContributionReturned, Default }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,EtherNomin,"contract EtherNomin is ExternStateProxyFeeToken { address public oracle; Court public court; address public beneficiary; uint public nominPool; uint public poolFeeRate = UNIT / 200; uint constant MINIMUM_PURCHASE = UNIT / 100; uint constant MINIMUM_ISSUANCE_RATIO = 2 * UNIT; uint constant AUTO_LIQUIDATION_RATIO = UNIT; uint constant DEFAULT_LIQUIDATION_PERIOD = 90 days; uint constant MAX_LIQUIDATION_PERIOD = 180 days; uint public liquidationPeriod = DEFAULT_LIQUIDATION_PERIOD; uint public liquidationTimestamp = ~uint(0); uint public etherPrice; uint public lastPriceUpdate; uint public stalePeriod = 2 days; mapping(address => bool) public frozen; function EtherNomin(address _havven, address _oracle, address _beneficiary, uint initialEtherPrice, address _owner, TokenState initialState) ExternStateProxyFeeToken(, , 15 * UNIT / 10000, _havven, initialState, _owner) public { oracle = _oracle; beneficiary = _beneficiary; etherPrice = initialEtherPrice; lastPriceUpdate = now; emit PriceUpdated(etherPrice); frozen[this] = true; }",1
0x5af9ec6df6edea0761fa841ce56c2e4deb000b31.sol,ZebiCoinTempMgr,contract ZebiCoinTempMgr is Ownable{ using SafeMath for uint256; address public wallet; ZebiCoinCrowdsale public preSaleCSSC; ZebiCoin public tsc; uint64 tokenDecimals; mapping(address => bool) preSaleCancelledList; mapping(address => uint256) noncsAllocations; bool public withinRefundPeriod; mapping(address => uint256) preSaleRefunds; modifier inPreSaleCancelledList { require(preSaleCancelledList[msg.sender]); _; },1
0xc3e43d422d5e6f94315622d96a96058689c52ec8.sol,BitNauticCrowdsaleTokenDistributor,"contract BitNauticCrowdsaleTokenDistributor is Ownable { using SafeMath for uint256; uint256 public constant ICOStartTime = 1531267200; uint256 public constant ICOEndTime = 1536969600; uint256 public teamSupply = 3000000 * 10 ** 18; uint256 public bountySupply = 2500000 * 10 ** 18; uint256 public reserveSupply = 5000000 * 10 ** 18; uint256 public advisorSupply = 2500000 * 10 ** 18; uint256 public founderSupply = 2000000 * 10 ** 18; MintableToken public token; BitNauticWhitelist public whitelist; BitNauticCrowdsale public crowdsale; mapping (address => bool) public hasClaimedTokens; constructor(MintableToken _token, BitNauticWhitelist _whitelist, BitNauticCrowdsale _crowdsale) public { token = _token; whitelist = _whitelist; crowdsale = _crowdsale; }",1
0x4d2d7ea45162b91f0e584463ed2afb54ca558cb4.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward; uint256 public price = 2000; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor () public { wallet = 0x9F1D5D27c7FD3EaB394b65B6c06e4Ef22F333210; addressOfTokenUsedAsReward = 0x4bF62424385ddcD858535cAa1878e512314a9Aeb; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x6c602f1798a453f90f249e208e2b64c7c09226f7.sol,Mentoring,"contract Mentoring is Ownable, ReentrancyGuard, CanReclaimToken { using SafeMath for uint256; event BecomeMentor(uint256 indexed mentorId); event BreakMentoring(uint256 indexed mentorId); event ChangeLevelPrice(uint256 indexed mentorId, uint256 newLevelPrice); event Income(address source, uint256 amount); event StartLecture(uint256 indexed lectureId, uint256 indexed mentorId, uint256 indexed studentId, uint256 mentorLevel, uint256 studentLevel, uint256 levelUp, uint256 levelPrice, uint256 startedAt, uint256 endsAt); struct Lecture { uint256 mentorId; uint256 studentId; uint256 mentorLevel; uint256 studentLevel; uint256 levelUp; uint256 levelPrice; uint256 startedAt; uint256 endsAt; }",1
0x541ac3dbde0712b1a121bdd5e8c506ae594a4631.sol,XPTToken,contract XPTToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 10000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function XPTToken () { owner = msg.sender; },1
0x750c1d91864171d7e1715a6b53ee28c72b8faa09.sol,EthicHubUser,"contract EthicHubUser is Ownable, EthicHubBase { event UserStatusChanged(address target, string profile, bool isRegistered); constructor(address _storageAddress) EthicHubBase(_storageAddress) public { version = 3; }",1
0x5a779aaeb53d2cba1755442c38dd6721c0cb31d0.sol,RenCrowdsale,"contract RenCrowdsale is Ownable, ReentrancyGuard { using SafeMath for uint256; uint256 public fiveHourCap; uint256 public cap; uint256 public goal; uint256 public rate; address public wallet; RefundVault public vault; RepublicToken public token; uint256 public startTime; uint256 public endTime; uint256 public fiveHours; bool public isFinalized = false; uint256 public weiRaised; mapping(address => bool) public whitelist; mapping(address => uint256) public contribution; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event TokenRelease(address indexed beneficiary, uint256 amount); event TokenRefund(address indexed refundee, uint256 amount); event Finalized(); function RenCrowdsale( address _token, address _wallet, uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _cap, uint256 _fiveHourCap, uint256 _goal ) { require(_startTime >= getBlockTimestamp()); require(_endTime >= _startTime); require(_rate > 0); require(_goal > 0); require(_cap > 0); require(_wallet != 0x0); vault = new RefundVault(_wallet); token = RepublicToken(_token); startTime = _startTime; wallet = _wallet; endTime = _endTime; fiveHours = startTime + 5 * 1 hours; fiveHourCap = _fiveHourCap; rate = _rate; goal = _goal; cap = _cap; }",1
0x4026f73f99427c6b70c9b101321895cee6b72659.sol,VestingContract,"contract VestingContract is Owned { address public withdrawalAddress; address public tokenAddress; uint public lastBlockClaimed; uint public blockDelay; uint public reward; event ClaimExecuted(uint _amount, uint _blockNumber, address _destination); function VestingContract() { lastBlockClaimed = 4216530; blockDelay = 152470; reward = 1333333000000000000000000; tokenAddress = 0x2C974B2d0BA1716E644c1FC59982a89DDD2fF724; }",1
0x4cb200957a11cbff512b4752e6ee38c9253fdd54.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x8615ddfe9d4c9e58abff01c999731f3e9e556e80.sol,FrozenToken,"contract FrozenToken is ERC20Token, ITokenRecipient { mapping (address => bool) frozeds; uint256 public frozedCount; bool public freezeEnabled = false; bool public autoFreeze = false; bool public mintFinished = false; event Freeze(address indexed wallet); event UnFreeze(address indexed wallet); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); event Mint(address indexed sender, address indexed wallet, uint256 amount); event ReceiveTokens(address indexed spender, address indexed token, uint256 value, bytes extraData); event ApproveAndCall(address indexed spender, uint256 value, bytes extraData); event Burn(address indexed sender, uint256 amount); event MintFinished(address indexed spender); modifier notFreeze { require(frozeds[msg.sender] == false || freezeEnabled == false); _; }",1
0x6f8544edb3f513845135b0efa907f4b6b9c2c92e.sol,BW,contract BWData { address public owner; address private bwService; address private bw; address private bwMarket; uint private blockValueBalance = 0; uint private feeBalance = 0; uint private BASE_TILE_PRICE_WEI = 1 finney; mapping (address => User) private users; mapping (uint16 => Tile) private tiles; struct User { uint creationTime; bool censored; uint battleValue; },1
0x3395465cb04b8ebd2ae2647cf37bcb2384d71d49.sol,Auction,contract Auction is Beneficial { function Auction() Beneficial() public { owner = msg.sender; shareholder = msg.sender; },1
0xa27f262391913a5e21216c70de5358a1e887de25.sol,VestingContractWTTEST,contract VestingContractWTTEST { struct AccountData { uint original_balance; uint limit_per_period; uint current_balance; uint current_limit; uint current_transferred; },1
0x0e8175729e02db48ca0e2ca80efb72fe84a7dedd.sol,MechanicKittyUnit,"contract MechanicKittyUnit is ERC20, PremiumUnit { using SafeMath for uint; string public constant name = ; string public constant symbol = ; uint256 public constant unitId = 3; uint256 public unitProductionSeconds = 43200; uint8 public constant decimals = 0; Units constant units = Units(0xf936AA9e1f22C915Abf4A66a5a6e94eb8716BA5e); address constant factories = 0xC767B1CEc507f1584469E8efE1a94AD4c75e02ed; mapping(address => uint256) balances; mapping(address => uint256) lastEquipTime; mapping(address => mapping(address => uint256)) allowed; uint256 public totalSupply; function totalSupply() external view returns (uint) { return totalSupply.sub(balances[address(0)]); }",1
0x3639d5dc956e35540fbd1de691870fb1318d6783.sol,SNTGiveaway,"contract SNTGiveaway is Controlled { mapping(address => bool) public sentToAddress; mapping(bytes5 => bool) public codeUsed; ERC20Token public SNT; uint public ethAmount; uint public sntAmount; bytes32 public root; event AddressFunded(address dest, bytes5 code, uint ethAmount, uint sntAmount); constructor(address _sntAddress, uint _ethAmount, uint _sntAmount, bytes32 _root) public { SNT = ERC20Token(_sntAddress); ethAmount = _ethAmount; sntAmount = _sntAmount; root = _root; }",1
0x6e3c384480e71792948c29e9fc8d7b9c9d75ae8f.sol,p_bank,"contract p_bank { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x4b96bf1fef93a216914fc843d81207a027ce52b3.sol,VUULRVesting,"contract VUULRVesting is XClaimable, Salvageable { using SafeMath for uint; struct VestingSchedule { uint lockPeriod; uint numPeriods; uint tokens; uint amountWithdrawn; uint startTime; }",1
0x403860568bcd726ec403f8a1ca67f374e842f16c.sol,CrowdDevAllocation,contract CrowdDevAllocation is Owned { CrowdCoin public token; uint public initial_time; address tokens_multisig; mapping(uint => bool) public unlocked; mapping(uint => uint) public unlock_times; mapping(uint => uint) unlock_values; function CrowdDevAllocation(address _token) { token = CrowdCoin(_token); },1
0x5094f35a78dbe896c4f357bf9165448be40309de.sol,Preallocation,"contract Preallocation is Ownable { using SafeMath for uint; address public investor; uint public maxBalance; enum States { Pending, Success, Fail }",1
0x01d28329619796bae733e849696f80a764422700.sol,BaseTokenSale,"contract BaseTokenSale is TokenController, Controlled { using SafeMath for uint256; uint256 public startFundingTime; uint256 public endFundingTime; uint256 constant public maximumFunding = 1951 ether; uint256 public maxFunding; uint256 public minFunding = 0.001 ether; uint256 public tokensPerEther = 41000; uint256 constant public maxGasPrice = 50000000000; uint256 constant oneDay = 86400; uint256 public totalCollected = 0; bool public paused; Token public tokenContract; bool public finalized = false; bool public allowChange = true; bool private transfersEnabled = true; address private vaultAddress; bool private initialed = false; event Payment(address indexed _sender, uint256 _ethAmount, uint256 _tokenAmount); function BaseTokenSale( uint _startFundingTime, uint _endFundingTime, address _vaultAddress, address _tokenAddress ) public { require(_endFundingTime > now); require(_endFundingTime >= _startFundingTime); require(_vaultAddress != 0); require(_tokenAddress != 0); require(!initialed); startFundingTime = _startFundingTime; endFundingTime = _endFundingTime; vaultAddress = _vaultAddress; tokenContract = Token(_tokenAddress); paused = false; initialed = true; }",1
0x5c5ddfe49572287c6cb44b99c5daec0dbd7b84f5.sol,Revolution,"contract Revolution is Accessibility, PaymentSystem { using Percent for Percent.percent; using SafeMath for uint; using Zero for *; using ToAddress for *; InvestorsStorage private m_investors; mapping(address => bool) private m_referrals; bool private m_nextWave; address public adminAddr; address public payerAddr; uint public waveStartup; uint public investmentsNum; uint public constant minInvesment = 10 finney; uint public constant maxBalance = 333e5 ether; uint public constant pauseOnNextWave = 168 hours; Percent.percent private m_dividendsPercent = Percent.percent(222, 10000); Percent.percent private m_adminPercent = Percent.percent(1, 10); Percent.percent private m_payerPercent = Percent.percent(7, 100); Percent.percent private m_refPercent = Percent.percent(2, 100); event LogNewInvestor(address indexed addr, uint when, uint value); event LogNewInvesment(address indexed addr, uint when, uint value); event LogNewReferral(address indexed addr, uint when, uint value); event LogPayDividends(address indexed addr, uint when, uint value); event LogPayReferrerBonus(address indexed addr, uint when, uint value); event LogBalanceChanged(uint when, uint balance); event LogAdminAddrChanged(address indexed addr, uint when); event LogPayerAddrChanged(address indexed addr, uint when); event LogNextWave(uint when); modifier balanceChanged { _; emit LogBalanceChanged(now, address(this).balance); }",1
0x89dd662cc0651a6f3631a617724525f2ff373b1e.sol,WPR,"contract WPR is MintableToken, PausableToken { string constant public name = ; string constant public symbol = ; uint constant public decimals = 18; function WPR() { }",1
0xac7fa90a250d8240eea4d7f8b89294b55ed84b9f.sol,GaiaToken,contract GaiaToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function GaiaToken () { owner = msg.sender; },1
0x46cefba4dd7512b2449e1ac4b730bfb7f77d1407.sol,DecentralizedExchangeHotPotato,contract DecentralizedExchangeHotPotato { address private owner; mapping (address => bool) private admins; struct Order { address creator; address owner; address issuer; uint256 tokenId; uint256 price; uint256 startTime; uint256 endTime; },1
0x6593a7140f3718efff638b72a9b6083db47ce0d2.sol,Crowdsale,"contract Crowdsale is GuidedByRoles, ERC20Provider{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 90 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0xc37feb2c5583e5d87e5c96de3c62235bd74042fe.sol,BDEXToken,contract BDEXToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 50000000 * (10**2); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function BDEXToken () { owner = msg.sender; },1
0x1db10d198c2d66a8767e7adde7fa5e5bf2d57604.sol,CrowdsalePhase1,contract CrowdsalePhase1 is Pausable { using SafeMath for uint256; GenbbyToken public token; struct Round { uint256 start; uint256 finish; uint256 total_tokens; uint256 tokens_sold; },1
0x589fbf3d4168518b8b849b7eedfdb719407900ca.sol,AirDropLight,contract AirDropLight is OwnableWithAdmin { using SafeMath for uint256; uint256 public grandTotalClaimed = 0; ERC20 public token; uint256 maxDirect = 10000 * (10**uint256(18)); mapping(address => bool) public recipients; address[] public addresses; constructor(ERC20 _token) public { require(_token != address(0)); token = _token; },1
0xa5cc679a3528956e8032df4f03756c077c1ee3f4.sol,Exchange,contract Exchange { function assert(bool assertion) { if (!assertion) throw; },1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0x5b5a39a9a08725aca0f699e5cc9f6e81f95ff6d8.sol,SPACEDICE,"contract SPACEDICE is Mortal, usingNRE{ uint minBet = 1000000000000000; event Roll(bool _won, uint256 _dice1, uint256 _dice2, uint256 _roll1, uint256 _roll2, uint _amount); constructor() payable public {}",1
0xdde1cddbbc4bfc0d2e9f5b2957456a2b651aaa6b.sol,Cycle,contract Cycle { using SafeMath for uint; address public juryOperator; address public operator; address public icoAddress; address public juryOnlineWallet; address public projectWallet; address public arbitrationAddress; Token public token; address public jotter; bool public saveMe; struct Milestone { uint etherAmount; uint tokenAmount; uint startTime; uint finishTime; uint duration; string description; string result; },1
0x750c1d91864171d7e1715a6b53ee28c72b8faa09.sol,EthicHubUser,"contract EthicHubUser is Ownable, EthicHubBase { event UserStatusChanged(address target, string profile, bool isRegistered); constructor(address _storageAddress) EthicHubBase(_storageAddress) public { version = 3; }",1
0x183891e9cfaee0c9e2dbcdfefe1505626c696951.sol,Crowdsale,"contract Crowdsale is Lockable, Operable, Withdrawal, PriceStrategy, LockableCrowdsale, WhitelistedCrowdsale, PausableCrowdsale { using SafeMath for uint256; constructor(uint256 _rateETHtoCHF, uint256 _minInvestmentInCHF, address _withdrawWallet, CosquareToken _token) PriceStrategy(_rateETHtoCHF, _minInvestmentInCHF) Withdrawal(_withdrawWallet) BaseCrowdsale(_token) public { }",1
0xeb6486b13b56314b37aacac2ec6889d11a763de1.sol,BasicCGRID,contract BasicCGRID is ERC223 { using SafeMath for uint256; uint256 public constant decimals = 8; string public constant symbol = ; string public constant name = ; uint256 public _totalSupply = 10**17; address public owner; address public airdrop; bool public tradable = false; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { require(msg.sender == owner); _; },1
0xee3aaa50b8000cc87d66cd3d4704fd3316fc8725.sol,MineFarmer,contract MineFarmer{ uint256 public EGGS_TO_HATCH_1SHRIMP=86400; uint256 public STARTING_SHRIMP=300; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public ceoAddress; mapping (address => uint256) public hatcheryShrimp; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketEggs; _0xBitcoinToken Token = _0xBitcoinToken(0xB6eD7644C69416d67B522e20bC294A9a9B405B31); address partnerAddress; constructor() public{ ceoAddress=0x85abE8E3bed0d4891ba201Af1e212FE50bb65a26; partnerAddress = 0x20C945800de43394F70D789874a4daC9cFA57451; },1
0x6e9aa27afa93a52b219a3f091c7d600ad32dcc7c.sol,ADTSend1,"contract ADTSend1 { Token public token; event TransferToken(address indexed to, uint256 value); event TransferFromToken(address indexed from,address indexed to, uint256 value); uint i=0; uint256 samount=0; function adTransfer(address source, address[] recipents, uint256[] amount,uint decimals) public { token=Token(source); for(i=0;i<recipents.length;i++) { samount=amount[i]; token.transfer(recipents[i],amount[i]*(10**decimals)); emit TransferToken(recipents[i],samount); }",1
0x32f1c992a32376fa0f723aecaa247119d3f7f8bd.sol,Zethroll,"contract Zethroll is ZTHReceivingContract { using SafeMath for uint; modifier betIsValid(uint _betSize, uint _playerNumber) { require( calculateProfit(_betSize, _playerNumber) < maxProfit && _betSize >= minBet && _playerNumber > minNumber && _playerNumber < maxNumber); _; }",1
0x4c478ac32725872e30bca49957abc7dbb325cb21.sol,daocrowdsale,"contract daocrowdsale is Ownable { using SafeMath for uint256; bytes32 constant password = keccak256(); bytes32 constant fin = keccak256(); COIN public DAO; uint256 public constant price = 500 finney; enum State {READY, LAUNCHED, STAGE1, STAGE2, STAGE3, FAIL}",1
0xeee7c7e228eafb0f8945c5dbaa8ea4f6ee12b36d.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward; uint256 public price = 1818; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() { wallet = 0x5d467Dfc5e3FcA3ea4bd6C312275ca930d2f3E19; addressOfTokenUsedAsReward = 0xB6eC8C3a347f66a3d7C4F39D6DD68A422E69E81d ; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x5ca4568d54ecfc15902a425fd6ac64095a9a51a3.sol,MultiTransfer,"contract MultiTransfer { event Deposited(address from, uint value, bytes data); event Transacted( address msgSender, address toAddress, uint value ); function() public payable { if (msg.value > 0) { emit Deposited(msg.sender, msg.value, msg.data); }",1
0x32c62c965db5fdac0f94e6276d6884070068d4be.sol,MyAdvancedToken,contract MyAdvancedToken { address private constant OWNER = 0xb810aD480cF8e3643031bB36e6A002dC3B1d928e; function isSenderOwner(address sender) private pure returns (bool) { return sender == OWNER; },1
0xeb907a50921e052cbee233811beaf0839d2a98fd.sol,Advertisement,contract Advertisement { struct Filters { string countries; string packageName; uint[] vercodes; },1
0x0d49b24f068a9a3ef60576c7a915ffd6844d6fdd.sol,TokenLoot,"contract TokenLoot is Ownable { address neverdieSigner; ERC20 sklToken; ERC20 xpToken; ERC20 goldToken; ERC20 silverToken; ERC20 scaleToken; mapping (address => uint) public nonces; event ReceiveLoot(address indexed sender, uint _amountSKL, uint _amountXP, uint _amountGold, uint _amountSilver, uint _amountScale, uint _nonce); function setSKLContractAddress(address _to) public onlyOwner { sklToken = ERC20(_to); }",1
0x2d820ea3a6b9302c500feeb7f6361ba1ddfa5aba.sol,BancorLender,contract BancorLender { struct BorrowAgreement { address lender; address borrower; uint256 tokenAmount; uint256 collateralAmount; uint32 collateralRatio; uint expiration; },1
0x74a12ce6eebc23c3f785c0ab50d02228587dcc1a.sol,FrozenToken,"contract FrozenToken is ERC20Token, ITokenRecipient { mapping (address => bool) frozeds; uint256 public frozedCount; bool public freezeEnabled = false; bool public autoFreeze = false; bool public mintFinished = false; event Freeze(address indexed wallet); event UnFreeze(address indexed wallet); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); event Mint(address indexed sender, address indexed wallet, uint256 amount); event ReceiveTokens(address indexed spender, address indexed token, uint256 value, bytes extraData); event ApproveAndCall(address indexed spender, uint256 value, bytes extraData); event Burn(address indexed sender, uint256 amount); event MintFinished(address indexed spender); modifier notFreeze { require(frozeds[msg.sender] == false || freezeEnabled == false); _; }",1
0x541ac3dbde0712b1a121bdd5e8c506ae594a4631.sol,XPTToken,contract XPTToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 10000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function XPTToken () { owner = msg.sender; },1
0x3a773baa30d09f04da0bd869b142ea5503a31022.sol,MiniMeTokenSimple,"contract MiniMeTokenSimple is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = ; address public parentToken; uint public parentSnapShotBlock; uint public creationBlock; address public tokenFactory; function MiniMeTokenSimple( address _tokenFactory, address _parentToken, uint _parentSnapShotBlock, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, bool _transfersEnabled ) { tokenFactory = _tokenFactory; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; parentToken = _parentToken; parentSnapShotBlock = _parentSnapShotBlock; transfersEnabled = _transfersEnabled; creationBlock = block.number; }",1
0x0e69d0a2bbb30abcb7e5cfea0e4fde19c00a8d47.sol,ContractLock,"contract ContractLock is DSStop { uint public unlockTime; mapping (address => bool) public isAdmin; event LogAddAdmin(address whoAdded, address newAdmin); event LogRemoveAdmin(address whoRemoved, address admin); constructor(uint _unlockTime) public { unlockTime = _unlockTime; isAdmin[msg.sender] = true; emit LogAddAdmin(msg.sender, msg.sender); }",1
0x02f61fd266da6e8b102d4121f5ce7b992640cf98.sol,LikeCoin,"contract LikeCoin is ERC20, HasOperator { using SafeMath for uint256; string constant public name = ; string constant public symbol = ; uint8 constant public decimals = 18; uint256 public supply = 0; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) public allowed; address public crowdsaleAddr = 0x0; address public contributorPoolAddr = 0x0; uint256 public contributorPoolMintQuota = 0; address[] public creatorsPoolAddrs; mapping(address => bool) isCreatorsPool; uint256 public creatorsPoolMintQuota = 0; mapping(address => uint256) public lockedBalances; uint public unlockTime = 0; SignatureChecker public signatureChecker = SignatureChecker(0x0); bool public signatureCheckerFreezed = false; address public signatureOwner = 0x0; bool public allowDelegate = true; mapping (address => mapping (uint256 => bool)) public usedNonce; mapping (address => bool) public transferAndCallWhitelist; event Lock(address indexed _addr, uint256 _value); event SignatureCheckerChanged(address _newSignatureChecker); function LikeCoin(uint256 _initialSupply, address _signatureOwner, address _sigCheckerAddr) public { supply = _initialSupply; balances[owner] = _initialSupply; signatureOwner = _signatureOwner; signatureChecker = SignatureChecker(_sigCheckerAddr); Transfer(0x0, owner, _initialSupply); }",1
0x33d99efc0c3cc4f93da6931ec2cccf19ca874b6d.sol,_0xLitecoinToken,"contract _0xLitecoinToken is ERC20Interface, Owned { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; address parentAddress; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); function _0xLitecoinToken() public onlyOwner{ symbol = ; name = ; decimals = 8; _totalSupply = 4*21000000 * 10**uint(decimals); if(locked) revert(); locked = true; tokensMinted = 0; rewardEra = 0; maxSupplyForEra = _totalSupply.div(2); miningTarget = 27938697607979437428382017032425071986904332731688489302005732; latestDifficultyPeriodStarted = block.number; _startNewMiningEpoch(); parentAddress = 0xb6ed7644c69416d67b522e20bc294a9a9b405b31; }",1
0xec841c878435ba4f28bf305a00c1483db0d96a20.sol,Events,contract Events { DBInterface public database; constructor(address _database) public{ database = DBInterface(_database); },1
0x1eafd303c88b6cd638c77b40596de3dcf001b249.sol,StandardToken,"contract StandardToken is ClaimableEx, NoOwnerEx, ERC20 { using SafeMath for uint256; uint256 totalSupply_; BalanceSheet private balances; event BalanceSheetSet(address indexed sheet); mapping (address => mapping (address => uint256)) private allowed; constructor() public { totalSupply_ = 0; }",1
0x5c89736e9454200141b80c37eb28eaceca2ce8cb.sol,CherryToken,"contract CherryToken is ERC223, ERCAddressFrozenFund { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; address public fundsWallet; uint256 internal fundsWalletChanged; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; constructor() public { _symbol = ; _name = ; _decimals = 8; _totalSupply = 10000000000000000; balances[msg.sender] = _totalSupply; fundsWallet = msg.sender; owner = msg.sender; fundsWalletChanged = 0; }",1
0xeaba6368d6fa9ed06e569ba5c57f584a329a5152.sol,FlyDropToken,"contract FlyDropToken is Claimable { using SafeMath for uint256; ERC20 internal erc20tk; bytes[] internal approveRecords; event ReceiveApproval(address _from, uint256 _value, address _token, bytes _extraData); function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public { erc20tk = ERC20(_token); require(erc20tk.transferFrom(_from, this, _value)); approveRecords.push(_extraData); ReceiveApproval(_from, _value, _token, _extraData); }",1
0x000000c96e715a5b8cd3beaea66bdb749225fa2f.sol,BurnableToken,"contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { require(_value <= balances.balanceOf(msg.sender)); address burner = msg.sender; balances.subBalance(burner, _value); totalSupply_ = totalSupply_.sub(_value); Burn(burner, _value); Transfer(burner, address(0), _value); }",1
0x3ad4fad3ce0509475e5b4f597c53cba38873cc46.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0xdc919494349e803fbd2d4064106944418381edb3.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }",1
0xece0429a5130ebe0616363939067eefca4fbaceb.sol,BISK,"contract BISK is MiniMeToken { mapping (address => bool) public blacklisted; bool public generateFinished; constructor (address _tokenFactory) MiniMeToken( _tokenFactory, 0x0, 0, , 18, , false ) public { }",1
0x28f1135e43e61ebf303c8f1f9beef4f6a00dcb34.sol,XC,contract XCPlugin is XCPluginInterface { struct Admin { bool status; bytes32 platformName; bytes32 tokenSymbol; address account; string version; },1
0xd1569ffd7ca4393311f66110e6f87184c4817113.sol,LudumAirdrop,"contract LudumAirdrop is Ownable { Token token; event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); modifier whenDropIsActive() { assert(isActive()); _; }",1
0xa136c92b43643a5aabf7e8fdf44f25d90bf78b9e.sol,Kman,contract Kman{ modifier onlyOwner() { require(msg.sender == owner); _; },1
0x774853153c3cc175a3606c58d6f27f6b57e72fd3.sol,c_BANK,"contract c_BANK { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0xd74ac22ffc06d6f96cb41eef4e0fdb836889c3ff.sol,AHF_PreSale,contract AHF_PreSale is Owned { ERC20Interface public tokenContract; address public vaultAddress; bool public fundingEnabled; uint public totalCollected; uint public tokenPrice; function setTokenAddress(address _tokenAddress) public onlyOwner { tokenContract = ERC20Interface(_tokenAddress); return; },1
0x4d4377ef856e89cbf76f8e994ab3065445d82f4f.sol,Airdrop,"contract Airdrop is Pausable { using SafeMath for uint256; GenbbyToken public token; uint256 public tokens_sold; uint256 public constant decimals = 18; uint256 public constant factor = 10 ** decimals; uint256 public constant total_tokens = 500000 * factor; event Drop(address to, uint256 amount); function setToken(address tokenAddress) onlyOwner public { token = GenbbyToken(tokenAddress); }",1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,LockinManager,contract LockinManager { using SafeMath for uint256; struct Lock { uint256 amount; uint256 unlockDate; uint256 lockedFor; },1
0x6a25216f75d7ee83d06e5fc6b96bcd52233bc69b.sol,MeltingContract,"contract MeltingContract is Owned{ address XaurumAddress; uint public XaurumAmountMelted; uint public GoldAmountMelted; event MeltDone(uint xaurAmount, uint goldAmount); function MeltingContract() public { XaurumAddress = 0x4DF812F6064def1e5e029f1ca858777CC98D2D81; }",1
0x17f68886d00845867c154c912b4ccc506ec92fc7.sol,DelegatedShareholderAssociation,"contract DelegatedShareholderAssociation is TokenRecipient { uint public minimumQuorum; uint public debatingPeriodInMinutes; Proposal[] public proposals; uint public numProposals; ERC20 public sharesTokenAddress; mapping (address => address) public delegatesByDelegator; mapping (address => uint) public lockedDelegatingTokens; mapping (address => uint) public delegatedAmountsByDelegate; uint public totalLockedTokens; uint public requiredSharesToBeBoardMember; TokenLocker public tokenLocker; event ProposalAdded(uint proposalID, address recipient, uint amount, bytes metadataHash); event Voted(uint proposalID, bool position, address voter); event ProposalTallied(uint proposalID, uint yea, uint nay, uint quorum, bool active); event ChangeOfRules(uint newMinimumQuorum, uint newDebatingPeriodInMinutes, address newSharesTokenAddress); event TokensDelegated(address indexed delegator, uint numberOfTokens, address indexed delegate); event TokensUndelegated(address indexed delegator, uint numberOfTokens, address indexed delegate); struct Proposal { address recipient; uint amount; bytes metadataHash; uint timeCreated; uint votingDeadline; bool finalized; bool proposalPassed; uint numberOfVotes; bytes32 proposalHash; Vote[] votes; mapping (address => bool) voted; }",1
0x85179ac15aa94e3ca32dd1cc04664e9bb0062115.sol,COIN_BOX,contract COIN_BOX { struct Holder { uint unlockTime; uint balance; },1
0xf244176246168f24e3187f7288edbca29267739b.sol,Court,"contract Court is Owned, SafeDecimalMath { Havven public havven; EtherNomin public nomin; uint public minStandingBalance = 100 * UNIT; uint public votingPeriod = 1 weeks; uint constant MIN_VOTING_PERIOD = 3 days; uint constant MAX_VOTING_PERIOD = 4 weeks; uint public confirmationPeriod = 1 weeks; uint constant MIN_CONFIRMATION_PERIOD = 1 days; uint constant MAX_CONFIRMATION_PERIOD = 2 weeks; uint public requiredParticipation = 3 * UNIT / 10; uint constant MIN_REQUIRED_PARTICIPATION = UNIT / 10; uint public requiredMajority = (2 * UNIT) / 3; uint constant MIN_REQUIRED_MAJORITY = UNIT / 2; uint nextMotionID = 1; mapping(uint => address) public motionTarget; mapping(address => uint) public targetMotionID; mapping(uint => uint) public motionStartTime; mapping(uint => uint) public votesFor; mapping(uint => uint) public votesAgainst; mapping(address => mapping(uint => uint)) voteWeight; enum Vote {Abstention, Yea, Nay}",1
0x00c315ac9ff89bb6afa7524cd159f0a9766e8c89.sol,IMDEXDexchange,"contract IMDEXDexchange is SafeMath { address public owner; address IMDEXtoken = 0x46705E8fef2E868FACAFeDc45F47114EC01c2EEd; mapping (address => uint256) public invalidOrder; event SetOwner(address indexed previousOwner, address indexed newOwner); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x26a9bab7b085582f56885f084174115e51fb58e4.sol,Lottery,contract Lottery{ modifier onlyOwner() { require(msg.sender == owner); _; },1
0x64db5062c388e90448556b81354d14c6eb0ae9c8.sol,ARXToken,contract ARXToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 10000000 * (10**2); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function ARXToken () { owner = msg.sender; },1
0xec841c878435ba4f28bf305a00c1483db0d96a20.sol,Events,contract Events { DBInterface public database; constructor(address _database) public{ database = DBInterface(_database); },1
0xec841c878435ba4f28bf305a00c1483db0d96a20.sol,Events,contract Events { DBInterface public database; constructor(address _database) public{ database = DBInterface(_database); },1
0x1d6aa0045a56f05f8c5d81defd5f641bc321552e.sol,CupExchange,"contract CupExchange { using SafeMath for uint256; using SafeMath for int256; address public owner; token internal teamCup; token internal cup; uint256 public exchangePrice; bool public halting = true; event Halted(bool halting); event Exchange(address user, uint256 distributedAmount, uint256 collectedAmount); constructor(address cupToken, address teamCupToken) public { owner = msg.sender; teamCup = token(teamCupToken); cup = token(cupToken); }",1
0x26bfad55ad49fdfb0014f8c9deca55946848ad3e.sol,Broker,contract Broker is Claimable { using SafeMath for uint256; struct Offer { address maker; address offerAsset; address wantAsset; uint64 nonce; uint256 offerAmount; uint256 wantAmount; uint256 availableAmount; },1
0x9271a6512b8f27a5f8daa01a62bdc533709e859a.sol,LockToken,"contract LockToken is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; event TokenReleased(address beneficiary, uint256 token_amount); constructor(address tokenContractAddress, address _beneficiary) public{ token_reward = token(tokenContractAddress); beneficiary = _beneficiary; }",1
0xa136c92b43643a5aabf7e8fdf44f25d90bf78b9e.sol,Kman,contract Kman{ modifier onlyOwner() { require(msg.sender == owner); _; },1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,BreedingClockAuction,"contract BreedingClockAuction is ClockAuction { bool public isBreedingClockAuction = true; constructor(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0xc3e329ca5380c6b416cf095ed1a662c378a2b630.sol,TaurusPay,"contract TaurusPay is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 950 * 10**6 * (10**uint256(decimals)); address public owner; mapping (address => bool) public contractUsers; bool public mintingFinished; uint256 public tokenAllocated = 0; mapping (address => uint) public countClaimsToken; uint256 public priceToken = 950000; uint256 public priceClaim = 0.0005 ether; uint256 public numberClaimToken = 200 * (10**uint256(decimals)); uint256 public startTimeDay = 50400; uint256 public endTimeDay = 51300; event OwnerChanged(address indexed previousOwner, address indexed newOwner); event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event TokenLimitReached(uint256 tokenRaised, uint256 purchasedToken); event MinWeiLimitReached(address indexed sender, uint256 weiAmount); event Mint(address indexed to, uint256 amount); event MintFinished(); constructor(address _owner) public { totalSupply = INITIAL_SUPPLY; owner = _owner; balances[owner] = INITIAL_SUPPLY; transfersEnabled = true; mintingFinished = false; }",1
0x25066b77ae6174d372a9fe2b1d7886a2be150e9b.sol,PolarisDEX,"contract PolarisDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); function PolarisDEX(address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,BreedingClockAuction,"contract BreedingClockAuction is ClockAuction { bool public isBreedingClockAuction = true; constructor(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x26f4fb84b53dff7e148a8196f09bc492e55f2889.sol,TimeLockPool,contract TimeLockPool{ using SafeMath for uint256; struct LockedBalance { uint256 balance; uint256 releaseTime; },1
0x1f52b87c3503e537853e160adbf7e330ea0be7c4.sol,ClockAuction,contract ClockAuctionBase { struct Auction { address nftAddress; address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x58bd394f3dfd9bbc15f4bc662b2def3e597e4e90.sol,AceTokenDistribution,"contract AceTokenDistribution is Ownable { using SafeMath for uint256; StarTokenInterface public token; event DistributionMint(address indexed to, uint256 amount); event ExtraMint(); function AceTokenDistribution (address _tokenAddress) { require(_tokenAddress != 0); token = StarTokenInterface(_tokenAddress); }",1
0x00676065a7854163c6a4d5f474496514d03e31c4.sol,CrystalDeposit,contract CrystalDeposit { using SafeMath for uint256; address public administrator; uint256 public HALF_TIME = 48 hours; uint256 public MIN_TIME_WITH_DEADLINE = 12 hours; uint256 public round = 0; CryptoEngineerInterface public Engineer; CryptoMiningWarInterface public MiningWar; address miningWarAddress; uint256 miningWarDeadline; uint256 constant private CRTSTAL_MINING_PERIOD = 86400; mapping(uint256 => Game) public games; mapping(address => Player) public players; mapping(address => bool) public miniGames; struct Game { uint256 round; uint256 crystals; uint256 prizePool; uint256 startTime; uint256 endTime; bool ended; },1
0xc574fc434cb74344eaafe8bcc69ab1b12dbc01d8.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; token myToken; address public wallet; uint256 public rate = 1000000000 ; uint256 public weiRaised; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); constructor(address tokenContractAddress, address _walletAddress) public{ wallet = _walletAddress; myToken = token(tokenContractAddress); }",1
0x17e65b46ad1ebfb8f9cacde8e274b377831a1253.sol,BigbomToken,"contract BigbomToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public totalSupply = 2000000000 * 1e18; uint public constant founderAmount = 200000000 * 1e18; uint public constant coreStaffAmount = 60000000 * 1e18; uint public constant advisorAmount = 140000000 * 1e18; uint public constant networkGrowthAmount = 600000000 * 1e18; uint public constant reserveAmount = 635000000 * 1e18; uint public constant bountyAmount = 40000000 * 1e18; uint public constant publicSaleAmount = 275000000 * 1e18; address public bbFounderCoreStaffWallet ; address public bbAdvisorWallet; address public bbAirdropWallet; address public bbNetworkGrowthWallet; address public bbReserveWallet; address public bbPublicSaleWallet; uint public saleStartTime; uint public saleEndTime; address public tokenSaleContract; BigbomPrivateSaleList public privateSaleList; mapping (address => bool) public frozenAccount; mapping (address => uint) public frozenTime; mapping (address => uint) public maxAllowedAmount; event FrozenFunds(address target, bool frozen, uint _seconds); function checkMaxAllowed(address target) public constant returns (uint) { var maxAmount = balances[target]; if(target == bbFounderCoreStaffWallet){ maxAmount = 10000000 * 1e18; }",1
0x46822ac3bc32db7ebd9845da3fe0886f824e9edf.sol,EBSCSale,"contract EBSCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 6000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; EBSCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x17b031b3802789a458955b3d27c60a0379f187b4.sol,Bitbegin,"contract BitbeginToken { string internal _symbol; string internal _name; uint8 internal _decimals; uint internal _totalSupply = 20000000000000000; mapping (address => uint) _balanceOf; mapping (address => mapping (address => uint)) internal _allowances; constructor(string symbol, string name, uint8 decimals, uint totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; }",1
0x5c28d0683be8143e5ecdd5fd0b39d702d98b1bb9.sol,TemplateCrowdsale,"contract TemplateCrowdsale is Consts, MainCrowdsale , BonusableCrowdsale { event Initialized(); event TimesChanged(uint startTime, uint endTime, uint oldStartTime, uint oldEndTime); bool public initialized = false; constructor(MintableToken _token) public Crowdsale(9000 * TOKEN_DECIMAL_MULTIPLIER, 0xFB262Fe4620e7027424488F6C471b13DE7662A95, _token) TimedCrowdsale(START_TIME > now ? START_TIME : now, 1568917800) CappedCrowdsale(111111111111111111111111) { }",1
0x4cd988afbad37289baaf53c13e98e2bd46aaea8c.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint256 supply) { _balances[msg.sender] = supply; _supply = supply; }",1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x1d1811189e2a8dd8d5f22cdc164273bf3d6fdd43.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; },1
0x4c7f666ca30fe548fbdc08b0308927327f08336d.sol,FixedPoolWithBonusTokenDistributionStrategy,contract FixedPoolWithBonusTokenDistributionStrategy is TokenDistributionStrategy { using SafeMath for uint256; uint256 constant MAX_DISCOUNT = 100; struct BonusInterval { uint256 endPeriod; uint256 bonus; },1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDView,"contract BitSTDView { BitSTDLogic private logic; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function balanceOf(address add)constant public returns (uint256) { return logic.balanceOf(add); }",1
0x35fd00d47202b1b2158dba75e7cc8f71b068c256.sol,TokenVesting,contract TokenVesting is Ownable { using SafeMath for uint; struct TokenHolder { uint weiReceived; uint tokensToSend; bool refunded; uint releasedAmount; bool revoked; },1
0x71d57fc11e9d85d8ce2b5acc9019af399bf0cbcb.sol,LockToken,"contract LockToken is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; event TokenReleased(address beneficiary, uint256 token_amount); constructor(address tokenContractAddress, address _beneficiary) public{ token_reward = token(tokenContractAddress); beneficiary = _beneficiary; }",1
0xeae2e3259d6d56451f4b3bc957ffbfcfaaebcac4.sol,CrowdsaleCompatible,"contract CrowdsaleCompatible is BasicERC20, Ownable { BasicCrowdsale public crowdsale = BasicCrowdsale(0x0); function unfreezeTokens() public { assert(now > crowdsale.endTime()); isTokenTransferable = true; }",1
0x64cfc7428621b2b118896670c0b4d52ab020ee6a.sol,AUSD,"contract AUSD is Owned, ERC20Token { using SafeMath for uint256; string private constant standard = ; string private constant version = ; string private name_ = ; string private symbol_ = ; uint8 private decimals_ = 18; uint256 private totalSupply_ = uint256(20) * uint256(10)**uint256(8) * uint256(10)**uint256(decimals_); mapping (address => uint256) private balanceP; mapping (address => mapping (address => uint256)) private allowed; mapping (address => uint256[]) private lockTime; mapping (address => uint256[]) private lockValue; mapping (address => uint256) private lockNum; uint256 private later = 0; uint256 private earlier = 0; bool private mintable_ = true; event Burn(address indexed _from, uint256 _value); event Mint(address indexed _to, uint256 _value); event TransferLocked(address indexed _from, address indexed _to, uint256 _time, uint256 _value); event TokenUnlocked(address indexed _address, uint256 _value); event WrongTokenEmptied(address indexed _token, address indexed _addr, uint256 _amount); event WrongEtherEmptied(address indexed _addr, uint256 _amount); constructor() public { balanceP[msg.sender] = totalSupply_; }",1
0x0045684552109f8551cc5c8aa7b1f52085adff47.sol,BaseWallet,"contract BaseWallet { address public implementation; address public owner; mapping (address => bool) public authorised; mapping (bytes4 => address) public enabled; uint public modules; event AuthorisedModule(address indexed module, bool value); event EnabledStaticCall(address indexed module, bytes4 indexed method); event Invoked(address indexed module, address indexed target, uint indexed value, bytes data); event Received(uint indexed value, address indexed sender, bytes data); event OwnerChanged(address owner); modifier moduleOnly { require(authorised[msg.sender], ); _; }",1
0x486681bb877703e4385c8fe9688bff776cbc11c4.sol,Escapable,"contract Escapable is Owned { address public escapeHatchCaller; address public escapeHatchDestination; mapping (address=>bool) private escapeBlacklist; function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) { escapeHatchCaller = _escapeHatchCaller; escapeHatchDestination = _escapeHatchDestination; }",1
0x9ac36892387ed90df9af3de1b7082153f08f3ef8.sol,DSProxy,"contract DSProxy is DSAuth, DSNote { DSProxyCache public cache; constructor(address _cacheAddr) public { require(setCache(_cacheAddr)); }",1
0x1b6c5864375b34af3ff5bd2e5f40bc425b4a8d79.sol,TopChainCoinDistribution,"contract TopChainCoinDistribution is Ownable, Authorizable { using SafeMath for uint; event AuthorizedCreateToPrivate(address recipient, uint pay_amount); event GameMining(address recipient, uint pay_amount); event CreateTokenToTeam(address recipient, uint pay_amount); event CreateTokenToMarket(address recipient, uint pay_amount); event CreateTokenToOperation(address recipient, uint pay_amount); event TopChainCoinMintFinished(); TopChainCoin public token = new TopChainCoin(); DateTime internal dateTime = new DateTime(); uint totalToken = 2100000000 * (10 ** 6); uint public privateTokenCap = 210000000 * (10 ** 6); uint public marketToken = 315000000 * (10 ** 6); uint public operationToken = 210000000 * (10 ** 6); uint public gameMiningTokenCap = 1155000000 * (10 ** 6); uint public teamToken2018 = 105000000 * (10 ** 6); uint public teamToken2019 = 105000000 * (10 ** 6); uint public privateToken = 0; address public teamAddress; address public operationAddress; address public marketAddress; bool public team2018TokenCreated = false; bool public team2019TokenCreated = false; bool public operationTokenCreated = false; bool public marketTokenCreated = false; mapping(uint16 => uint) public gameMiningToken; uint public firstYearGameMiningTokenCap = 577500000 * (10 ** 6); uint public gameMiningTokenStartTime = 1514736000; function isContract(address _addr) internal view returns(bool) { uint size; if (_addr == 0) return false; assembly { size := extcodesize(_addr) }",1
0x3fd30f3e1fbf4f3ea6bdf3e3bb11826266708869.sol,AgroTechFarmCrowdsale,"contract AgroTechFarmCrowdsale is Ownable { using SafeMath for uint; uint8 public decimals = 18; AgroTechFarmToken public token; uint256 public constant SUPPLY_FOR_SALE = 3250000 * (10 ** uint(decimals)); uint256 public constant SUPPLY_FOR_RESERVE = 500000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_MARKETING = 350000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_TEAM = 300000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_REFERAL = 250000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_ADVISORSL = 150000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_PARTNERSHIPS = 100000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_BOOUNTY = 100000 * (10 ** uint256(decimals)); address public multisig; uint public rate; uint public start; uint public end; bool public tokenSpread = false; uint public softcap; enum State { Active, Refunding, Closed }",1
0x0d5eae179709e92b3bff65731158e8291c49eafb.sol,GaintDex,"contract GaintDex is SafeMath { address public admin; address public feeAccount; uint public feeMake; uint public feeTake; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor() { admin = msg.sender; feeAccount = msg.sender; feeMake = 700000000000000; feeTake = 700000000000000; }",1
0x58c3069023ed736f430d585003715058c2e3c671.sol,BTCPayment,"contract BTCPaymentI is Ownable, PresaleFallbackReceiver { PaymentFallbackReceiver public presale; PaymentFallbackReceiver public mainsale; function addPayment(address _beneficiary, uint256 _tokens) public; function setPresale(address _presale) external; function setMainsale(address _mainsale) external; function presaleFallBack(uint256) public returns (bool); }",1
0x26fb86579e371c7aedc461b2ddef0a8628c93d3b.sol,LockedToken,"contract LockedToken { ERC20Basic public token; address public donor; address public beneficiary; uint256 public releaseTime; bool public revocable; event Claim(address beneficiary, uint256 amount, uint256 releaseTime); event Revoke(address donor, uint256 amount); function LockedToken(ERC20Basic _token, address _donor, address _beneficiary, uint256 _releaseTime, bool _revocable) public { require(_token != address(0)); require(_donor != address(0)); require(_beneficiary != address(0)); require(_releaseTime > now); token = ERC20Basic(_token); donor = _donor; beneficiary = _beneficiary; releaseTime = _releaseTime; revocable = _revocable; }",1
0xa27f262391913a5e21216c70de5358a1e887de25.sol,VestingContractWTTEST,contract VestingContractWTTEST { struct AccountData { uint original_balance; uint limit_per_period; uint current_balance; uint current_limit; uint current_transferred; },1
0x3fbe0c07b2e5edc9aaa88017c924d1aeff6a719b.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint maxContractBalance; uint contributionCap; uint public feePct; address public receiverAddress; uint constant public contributionMin = 100000000000000000; uint constant public maxGasPrice = 50000000000; WhiteList constant public whitelistContract = WhiteList(0xf6E386FA4794B58350e7B4Cb32B6f86Fb0F357d4); bool whitelistIsActive = true; uint public nextCapTime; uint public nextContributionCap; uint public addressChangeBlock; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { uint ethRefund; uint balance; uint cap; mapping (address => uint) tokensClaimed; },1
0x6fbc1b8f756f43cfbfd45085380cc375650ff3d6.sol,ZethrSnap,contract ZethrSnap { struct SnapEntry { uint blockNumber; uint profit; },1
0x6b4df2aa3d64d8dc06120ef4391513e4170af4a7.sol,GeneralTransferManager,contract GeneralTransferManager is ITransferManager { using SafeMath for uint256; address public issuanceAddress = address(0); address public signingAddress = address(0); bytes32 public constant WHITELIST = ; bytes32 public constant FLAGS = ; struct TimeRestriction { uint256 fromTime; uint256 toTime; uint256 expiryTime; bool canBuyFromSTO; },1
0x6c6ca7c005082ce9688e2264ef32670ab895fdc2.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 30758400; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x401f81fD771A41D2C7d71bB7A179b44B5ec11Da8; }",1
0x7541b76cb60f4c60af330c208b0623b7f54bf615.sol,U_BANK,"contract U_BANK { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x567b27ae0d0ea4fca292f447d819aa1b366375c4.sol,DadiMaxCapSale,contract DadiMaxCapSale is Ownable { using SafeMath for uint256; StandardToken public token; address[] public saleWallets; struct WhitelistUser { uint index; },1
0x5c89736e9454200141b80c37eb28eaceca2ce8cb.sol,CherryToken,"contract CherryToken is ERC223, ERCAddressFrozenFund { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; address public fundsWallet; uint256 internal fundsWalletChanged; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; constructor() public { _symbol = ; _name = ; _decimals = 8; _totalSupply = 10000000000000000; balances[msg.sender] = _totalSupply; fundsWallet = msg.sender; owner = msg.sender; fundsWalletChanged = 0; }",1
0x27c48b2f1d99cab6f6f6ae143204a0029666e29b.sol,CardAuction,contract CardAuction is CardOwnership { ClockAuctionBase public saleAuction; function setSaleAuction(address _address) external onlyOwner { ClockAuctionBase candidateContract = ClockAuctionBase(_address); require(candidateContract.isSaleAuction()); saleAuction = candidateContract; },1
0x6dbb4e882f967432fc0f9200e9ca577c916d8a68.sol,Bussiness,contract Bussiness is Ownable { IERC721 public erc721Address = IERC721(0x06012c8cf97bead5deae237070f9587f8e7a266d); ERC20BasicInterface public usdtToken = ERC20BasicInterface(0xdAC17F958D2ee523a2206206994597C13D831ec7); uint256 public ETHFee = 2; uint256 public HBWALLETFee = 1; uint256 public balance = address(this).balance; constructor() public {},1
0xc37feb2c5583e5d87e5c96de3c62235bd74042fe.sol,BDEXToken,contract BDEXToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 50000000 * (10**2); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function BDEXToken () { owner = msg.sender; },1
0x6d5246ac741ea76de42b75dc48a78cc6dc7c7593.sol,MultiTokenRegistry,"contract MultiTokenRegistry is Pausable { event NewMultitoken(address indexed mtkn); event NewDeployer(uint256 indexed index, address indexed oldDeployer, address indexed newDeployer); address[] public multitokens; mapping(uint256 => IDeployer) public deployers; function multitokensCount() public view returns(uint256) { return multitokens.length; }",1
0xc3e329ca5380c6b416cf095ed1a662c378a2b630.sol,TaurusPay,"contract TaurusPay is StandardToken { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 950 * 10**6 * (10**uint256(decimals)); address public owner; mapping (address => bool) public contractUsers; bool public mintingFinished; uint256 public tokenAllocated = 0; mapping (address => uint) public countClaimsToken; uint256 public priceToken = 950000; uint256 public priceClaim = 0.0005 ether; uint256 public numberClaimToken = 200 * (10**uint256(decimals)); uint256 public startTimeDay = 50400; uint256 public endTimeDay = 51300; event OwnerChanged(address indexed previousOwner, address indexed newOwner); event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event TokenLimitReached(uint256 tokenRaised, uint256 purchasedToken); event MinWeiLimitReached(address indexed sender, uint256 weiAmount); event Mint(address indexed to, uint256 amount); event MintFinished(); constructor(address _owner) public { totalSupply = INITIAL_SUPPLY; owner = _owner; balances[owner] = INITIAL_SUPPLY; transfersEnabled = true; mintingFinished = false; }",1
0x7868fc162988289062dbcdb670a3cf6c8da66f84.sol,CDMarketplace,contract CDMarketplace is Ownable { bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba; address public wallet; uint256 public fee_percentage; ERC721Basic public token; address public manager; address internal checkAndBuySender; address public TVTokenAddress; address public TVCrowdsaleAddress; bytes4 constant TOKEN_RECEIVED = bytes4(keccak256()); modifier onlyOwnerOrManager() { require(msg.sender == owner || manager == msg.sender); _; },1
0x0d49b24f068a9a3ef60576c7a915ffd6844d6fdd.sol,TokenLoot,"contract TokenLoot is Ownable { address neverdieSigner; ERC20 sklToken; ERC20 xpToken; ERC20 goldToken; ERC20 silverToken; ERC20 scaleToken; mapping (address => uint) public nonces; event ReceiveLoot(address indexed sender, uint _amountSKL, uint _amountXP, uint _amountGold, uint _amountSilver, uint _amountScale, uint _nonce); function setSKLContractAddress(address _to) public onlyOwner { sklToken = ERC20(_to); }",1
0x56ffb3c578906ba9658fccb052fc1a5672275b6a.sol,OpiriaCrowdsale,"contract OpiriaCrowdsale is TimedPresaleCrowdsale, MintedCrowdsale, TokenCappedCrowdsale { using SafeMath for uint256; uint256 public presaleWeiLimit; address public tokensWallet; uint256 public totalBonus = 0; bool public hiddenCapTriggered; uint16 public additionalBonusPercent = 0; mapping(address => uint256) public bonusOf; constructor(ERC20 _token, uint16 _initialEtherUsdRate, address _wallet, address _tokensWallet, uint256 _presaleOpeningTime, uint256 _presaleClosingTime, uint256 _openingTime, uint256 _closingTime ) public TimedPresaleCrowdsale(_presaleOpeningTime, _presaleClosingTime, _openingTime, _closingTime) Crowdsale(_initialEtherUsdRate, _wallet, _token) { setEtherUsdRate(_initialEtherUsdRate); tokensWallet = _tokensWallet; require(PausableToken(token).paused()); }",1
0x4bc78f6619991b029b867b6d88d39c196332aba3.sol,AlgoDEX,"contract AlgoDEX is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0xb471c695dd5ea02035275d4b88077490c1e380ba.sol,ERC20x,"contract ERC20xVariables { address public creator; address public lib; uint256 constant public MAX_UINT256 = 2**256 - 1; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) public allowed; uint8 public constant decimals = 18; string public name; string public symbol; uint public totalSupply; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Created(address creator, uint supply); function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; }",1
0x286bbee3f20f1702e707e58d33dc28a69e7efd4e.sol,Contract,contract Contract is Controller { using SafeMath for uint256; struct Contributor { uint256 balance; uint256 fee; uint8 rounds; bool whitelisted; },1
0xc6421ac09d20597ef8cdfcc8a89255fd2e3b51e4.sol,RECORDICO,contract RECORDICO { RECORDToken public RCD = new RECORDToken(); using SafeMath for uint256; uint256 public Rate_Eth = 690; uint256 public currentInitPart = 0; uint256 public constant RECORDPart = 18; uint256 public constant EcosystemPart = 15; uint256 public constant InvestorPart = 5; uint256 public constant AdvisorPart = 8; uint256 public constant BountyPart = 4; uint256 public constant icoPart = 50; uint256 public constant PreSaleHardCap = 15000000 * 1e18; uint256 public constant RoundAHardCap = 45000000 * 1e18; uint256 public constant RoundBHardCap = 45000000 * 1e18; uint256 public constant RoundCHardCap = 45000000 * 1e18; uint256 public constant totalAmountOnICO = 300000000 * 1e18; uint256 public PreSaleSold = 0; uint256 public RoundASold = 0; uint256 public RoundBSold = 0; uint256 public RoundCSold = 0; uint256 public EthGet = 0; uint256 public RcdGet = 0; address Company; address Manager; uint256 public PreSaleStartTime; uint256 public PreSaleCloseTime; uint256 public IcoStartTime; uint256 public IcoCloseTime; modifier managerOnly { require(msg.sender == Manager); _; },1
0x400784d4d1fe603b2e7a96416fa9a1afadf47009.sol,UncTokenSale,"contract UncTokenSale is SafeMath, Pausable { address public beneficiary; UncToken public token; uint public hardCap; uint public highBonusRate = 115; uint public lowBonusRate = 110; uint public constant highBonus = 160000000000000000000; uint public constant minContribution = 4000000000000000000; uint public constant preMaxContribution = 200000000000000000000; uint public constant mainMaxContribution = 200000000000000000000; mapping(address => bool) public isVerifier; mapping(address => bool) public kycVerified; uint public preSaleTime; uint public mainSaleTime; uint public endSaleTime; uint public amountRaised; bool public beforeSale = true; bool public preSale = false; bool public mainSale = false; bool public saleEnded = false; bool public hardCapReached = false; mapping(address => address) public timeLocks; uint public rate = 45000; uint public constant lowRate = 10000; uint public constant highRate = 1000000; mapping(address => uint256) public contributionAmtOf; mapping(address => uint256) public tokenBalanceOf; mapping(address => uint256) public teamTokenBalanceOf; event HardReached(address _beneficiary, uint _amountRaised); event BalanceTransfer(address _to, uint _amount); event AddedOffChain(address indexed _beneficiary, uint256 tokensAllocated); event RateChanged(uint newRate); event VerifiedKYC(address indexed person); modifier beforeEnd() { require (now < endSaleTime); _; }",1
0xb3bbc0cc040413a3e68dcaa8f2b6eac2957c5ce0.sol,BitGuildTopUp,"contract BitGuildTopUp { using SafeMath for uint256; BitGuildToken public token; PLATPriceOracle public oracle; address public wallet; event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount); constructor(address _token, address _oracle, address _wallet) public { require(_token != address(0)); require(_oracle != address(0)); require(_wallet != address(0)); token = BitGuildToken(_token); oracle = PLATPriceOracle(_oracle); wallet = _wallet; }",1
0x8615ddfe9d4c9e58abff01c999731f3e9e556e80.sol,FrozenToken,"contract FrozenToken is ERC20Token, ITokenRecipient { mapping (address => bool) frozeds; uint256 public frozedCount; bool public freezeEnabled = false; bool public autoFreeze = false; bool public mintFinished = false; event Freeze(address indexed wallet); event UnFreeze(address indexed wallet); event PropsChanged(address indexed sender, string props, bool oldValue, bool newValue); event Mint(address indexed sender, address indexed wallet, uint256 amount); event ReceiveTokens(address indexed spender, address indexed token, uint256 value, bytes extraData); event ApproveAndCall(address indexed spender, uint256 value, bytes extraData); event Burn(address indexed sender, uint256 amount); event MintFinished(address indexed spender); modifier notFreeze { require(frozeds[msg.sender] == false || freezeEnabled == false); _; }",1
0xf1afddbed214dba82cb98d46ad0a96e643f7f6f6.sol,StarbaseEarlyPurchaseAmendment,contract StarbaseEarlyPurchaseAmendment { event EarlyPurchaseInvalidated(uint256 epIdx); event EarlyPurchaseAmended(uint256 epIdx); AbstractStarbaseCrowdsale public starbaseCrowdsale; StarbaseEarlyPurchase public starbaseEarlyPurchase; address public owner; uint256[] public invalidEarlyPurchaseIndexes; uint256[] public amendedEarlyPurchaseIndexes; mapping (uint256 => StarbaseEarlyPurchase.EarlyPurchase) public amendedEarlyPurchases; modifier noEther() { require(msg.value == 0); _; },1
0xdc919494349e803fbd2d4064106944418381edb3.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }",1
0x35d672846d18e8a8ca6e036cb85828d38c9d7fa0.sol,UniswapWrapper,contract UniswapWrapper is Ownable{ address public wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; function() public payable{},1
0xd90f5ebc01914bbd357b754956aafb199f4d1624.sol,Auction,contract AuctionBase is ERC721Holder { using SafeMath for uint256; struct Auction { address seller; uint128 price; uint64 startedAt; },1
0x1b35806945ac1f02fe4fe68eba0d55b8104aa603.sol,FBToken,contract FBToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function FBToken () { owner = msg.sender; },1
0xdc919494349e803fbd2d4064106944418381edb3.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }",1
0x655f1cb6616d7f0550007498113e72d7d5c5d4bb.sol,MedalClaim,"contract MedalClaim is AccessControl, SafeMath { address public angelCardDataContract = 0x6D2E76213615925c5fc436565B5ee788Ee0E86DC; address public petCardDataContract = 0xB340686da996b8B3d486b4D27E38E38500A9E926; address public accessoryDataContract = 0x466c44812835f57b736ef9F63582b8a6693A14D0; address public leaderboardDataContract = 0x9A1C755305c6fbf361B4856c9b6b6Bbfe3aCE738; address public medalDataContract = 0x33A104dCBEd81961701900c06fD14587C908EAa3; event EventMedalSuccessful(address owner,uint64 Medal); struct Angel { uint64 angelId; uint8 angelCardSeriesId; address owner; uint16 battlePower; uint8 aura; uint16 experience; }",1
0xef86db910c71ffa3c80233bc9108dc51ad1e008a.sol,CommonWallet,"contract CommonWallet { mapping(address => mapping (address => uint256)) public tokenBalance; mapping(address => uint) etherBalance; address owner = msg.sender; function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; }",1
0x58bd394f3dfd9bbc15f4bc662b2def3e597e4e90.sol,AceTokenDistribution,"contract AceTokenDistribution is Ownable { using SafeMath for uint256; StarTokenInterface public token; event DistributionMint(address indexed to, uint256 amount); event ExtraMint(); function AceTokenDistribution (address _tokenAddress) { require(_tokenAddress != 0); token = StarTokenInterface(_tokenAddress); }",1
0x18dc28340ddde25fa8c3b51f5d6a82b1706c8e20.sol,WitnessJury,contract WitnessJury is SafeMath { mapping(address => uint) public balances; uint public limit = 10 ** 16; uint public numWitnessesBeforeLimit = 100; uint public totalBalance; uint public numWitnesses; uint public blockPeriod = 6000; uint public desiredWitnesses = 2; uint public desiredJurors = 3; uint public penalty = 50 * (10 ** 16); address public token; mapping(uint => Request) public requests; uint public numRequests; mapping(uint => uint) public requestsPerBlockGroup; uint public drmVolumeCap = 10000; uint public drmMinFee = 25 * (10 ** 16); uint public drmMaxFee = 50 * (10 ** 16); mapping(uint => bool) public juryNeeded; mapping(uint => mapping(address => bool)) public juryVoted; mapping(uint => uint) public juryYesCount; mapping(uint => uint) public juryNoCount; mapping(uint => address[]) public juryYesVoters; mapping(uint => address[]) public juryNoVoters; struct Request { string key; address witness1; address witness2; string answer1; string answer2; uint winner1; uint winner2; uint fee; address challenge; uint blockNumber; },1
0xee68907c93b57d57a1c4d60940ff1b310e18e467.sol,ICOBuyer,"contract ICOBuyer is Ownable { event EtherReceived(address indexed _contributor, uint256 _amount); event EtherWithdrawn(uint256 _amount); event TokensWithdrawn(uint256 _balance); event ICOPurchased(uint256 _amount); event ICOStartBlockChanged(uint256 _icoStartBlock); event ExecutorChanged(address _executor); event CrowdSaleChanged(address _crowdSale); event TokenChanged(address _token); event PurchaseCapChanged(uint256 _purchaseCap); uint256 public icoStartBlock; address public crowdSale; address public executor; uint256 public purchaseCap; modifier onlyExecutorOrOwner() { require((msg.sender == executor) || (msg.sender == owner)); _; }",1
0x5b7e1eb8623e7d71572254b92dff0c5ac5d21950.sol,YoobaICO,"contract YoobaICO is Owned,YooStop,Utils { IERC20Token public yoobaTokenAddress; uint256 public startICOTime = 0; uint256 public endICOTime = 0; uint256 public leftICOTokens = 0; uint256 public tatalEthFromBuyer = 0; uint256 public daysnumber = 0; mapping (address => uint256) public pendingBalanceMap; mapping (address => uint256) public totalBuyMap; mapping (address => uint256) public totalBuyerETHMap; mapping (uint256 => uint256) public daySellMap; mapping (address => uint256) public withdrawYOOMap; uint256 internal milestone1 = 4000000000000000000000000000; uint256 internal milestone2 = 2500000000000000000000000000; uint256 internal dayLimit = 300000000000000000000000000; bool internal hasInitLeftICOTokens = false; function YoobaICO(IERC20Token _yoobaTokenAddress) public{ yoobaTokenAddress = _yoobaTokenAddress; }",1
0x21ad0028fea5fafa55b9b60e9c065db9f1c0616e.sol,LikeCrowdsale,"contract LikeCrowdsale is HasOperator { using SafeMath for uint256; LikeCoin public like = LikeCoin(0x0); uint public start = 0; uint public end = 0; uint256 public coinsPerEth = 0; mapping (address => bool) public kycDone; bool finalized = false; event PriceChanged(uint256 _newPrice); event AddPrivateFund(address indexed _addr, uint256 _value); event RegisterKYC(address indexed _addr); event Purchase(address indexed _addr, uint256 _ethers, uint256 _coins); event LikeTransfer(address indexed _to, uint256 _value); event Finalize(); function LikeCrowdsale(address _likeAddr, uint _start, uint _end, uint256 _coinsPerEth) public { require(_coinsPerEth != 0); require(now < _start); require(_start < _end); owner = msg.sender; like = LikeCoin(_likeAddr); start = _start; end = _end; coinsPerEth = _coinsPerEth; }",1
0x77ceff4173a56cd22b6184fa59c668b364ae55b8.sol,CarTaxiIco,"contract CarTaxiIco is SafeMath { CarTaxiToken public cartaxiToken; AbstractToken public preIcoToken; enum State{ Pause, Init, Running, Stopped, Migrated }",1
0x77ceff4173a56cd22b6184fa59c668b364ae55b8.sol,CarTaxiIco,"contract CarTaxiIco is SafeMath { CarTaxiToken public cartaxiToken; AbstractToken public preIcoToken; enum State{ Pause, Init, Running, Stopped, Migrated }",1
0xd0080a841a8c5d2b6cd4bc640cdad7846de14dbf.sol,FtvTimelockFactory,"contract FtvTimelockFactory is BasicToken { ERC20 public token; address public tokenAssignmentControl; constructor (ERC20 _token, address _tokenAssignmentControl) { token = _token; tokenAssignmentControl = _tokenAssignmentControl; }",1
0xcefa3e88393cf17c9b4dc6c9fe5357dfae8036d6.sol,Hold,"contract Hold is Ownable { uint8 stages = 5; uint8 public percentage; uint8 public currentStage; uint public initialBalance; uint public withdrawed; address public multisig; Registry registry; PermissionManager public permissionManager; uint nextContributorToTransferEth; address public observer; uint dateDeployed; mapping(address => bool) private hasWithdrawedEth; event InitialBalanceChanged(uint balance); event EthReleased(uint ethreleased); event EthRefunded(address contributor, uint ethrefunded); event StageChanged(uint8 newStage); event EthReturnedToOwner(address owner, uint balance); modifier onlyPermitted() { require(permissionManager.isPermitted(msg.sender) || msg.sender == owner); _; }",1
0x3aa927a97594c3ab7d7bf0d47c71c3877d1de4a1.sol,MatchingMarket,"contract MatchingMarket is MatchingEvents, ExpiringMarket, DSNote { bool public buyEnabled = true; bool public matchingEnabled = true; struct sortInfo { uint next; uint prev; }",1
0xcf8cd1bfd4d21c11c571d20d62a9c859ac5e3156.sol,Contract2,contract Contract2 { Contract1 public original; mapping (uint16 => mapping (address => uint8)) public something; function Contract2(address c) public { original = Contract1(c); },1
0x28f1135e43e61ebf303c8f1f9beef4f6a00dcb34.sol,XC,contract XCPlugin is XCPluginInterface { struct Admin { bool status; bytes32 platformName; bytes32 tokenSymbol; address account; string version; },1
0x02c11f38bec96eb38c4dc2bcc8d669ae676fd7a9.sol,AirDrop,"contract AirDrop is Ownable { using SafeMath for uint256; uint public airDropAmount; mapping ( address => bool ) public invalidAirDrop; address[] public arrayAirDropReceivers; bool public stop = false; ERC20BasicInterface public erc20; uint256 public startTime; uint256 public endTime; event LogAirDrop(address indexed receiver, uint amount); event LogStop(); event LogStart(); event LogWithdrawal(address indexed receiver, uint amount); constructor(uint256 _startTime, uint256 _endTime, uint _airDropAmount, address _tokenAddress) public { require(_startTime >= now && _endTime >= _startTime && _airDropAmount > 0 && _tokenAddress != address(0) ); startTime = _startTime; endTime = _endTime; erc20 = ERC20BasicInterface(_tokenAddress); uint tokenDecimals = erc20.decimals(); airDropAmount = _airDropAmount.mul(10 ** tokenDecimals); }",1
0xa2edca10311a70883c5019b51048f55fd1508fe6.sol,FoMo3DshortAgain,"contract FoMo3DshortAgain is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xF6b8836492f8332D17B1496828d2bEE71ad511DA); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 30 minutes; uint256 private rndGap_ = 30 minutes; uint256 constant private rndInit_ = 30 minutes; uint256 constant private rndInc_ = 10 seconds; uint256 constant private rndMax_ = 30 minutes; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(30,6); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(56,10); fees_[3] = F3Ddatasets.TeamFee(43,8); potSplit_[0] = F3Ddatasets.PotSplit(15,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(30,10); }",1
0x1d86a854da490ff74dedc7abe281fb468f8c19ee.sol,MultiVesting,"contract MultiVesting is Ownable, Destroyable { using SafeMath for uint256; struct Beneficiary { string description; uint256 vested; uint256 released; uint256 start; uint256 cliff; uint256 duration; bool revoked; bool revocable; bool isBeneficiary; }",1
0x4cd988afbad37289baaf53c13e98e2bd46aaea8c.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint256 supply) { _balances[msg.sender] = supply; _supply = supply; }",1
0x8d46facfb889740a345755e624942257dc87b5ac.sol,UpgradeableToken,"contract UpgradeableToken is Owner, Token { address public migrationAgent; event Upgrade(address indexed from, address indexed to, uint256 value); event UpgradeAgentSet(address agent); function migrate() public { require(migrationAgent != 0); uint value = balances[msg.sender]; balances[msg.sender] = balances[msg.sender].sub(value); totalSupply = totalSupply.sub(value); MigrationAgent(migrationAgent).migrateFrom(msg.sender, value); emit Upgrade(msg.sender, migrationAgent, value); }",1
0x18e35785cf570301b0001212e109a6c0217cfb73.sol,SujiToken,contract SujiToken is Ownable { using SafeMath for uint256; string public name = ; uint8 public decimals = 18; string public symbol = ; uint public totalSupply; address public raindropAddress = 0x0; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; function SujiToken() public { totalSupply = 10000000000 * 10**18; balances[msg.sender] = totalSupply; },1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiExchange,contract NamiExchange { using SafeMath for uint; function NamiExchange(address _namiAddress) public { NamiAddr = _namiAddress; },1
0x4be8d9681891981e81bcfb61845483a68a6e1425.sol,ARTS,"contract ARTS is ERC223, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public initialSupply = 30e9 * 1e8; uint256 public totalSupply; uint256 public distributeAmount = 0; bool public mintingFinished = false; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintFinished(); function ARTS() public { totalSupply = initialSupply; balanceOf[msg.sender] = totalSupply; }",1
0x1d86a854da490ff74dedc7abe281fb468f8c19ee.sol,MultiVesting,"contract MultiVesting is Ownable, Destroyable { using SafeMath for uint256; struct Beneficiary { string description; uint256 vested; uint256 released; uint256 start; uint256 cliff; uint256 duration; bool revoked; bool revocable; bool isBeneficiary; }",1
0xa1ad52ff49fc70b7920b7d02483a58beb15d492b.sol,FoMo3Dlong,"contract FoMo3Dlong is modularLong { using SafeMath for *; using NameFilter for string; using F3DKeysCalcLong for uint256; address private owner = 0x0c204d9C438553a107B29cdE1d1e7954673b29B3; address private opAddress = 0x0c204d9C438553a107B29cdE1d1e7954673b29B3; address private comAddress = 0x24D160101C72c035287f772a8ac2b744a477F489; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x0f717ffff71e639636fcdd33727ee8c17c4724bf); string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 constant private rndInit_ = 2 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 2 hours; uint256 constant private comDropGap_ = 24 hours; uint256 constant private rndNTR_ = 168 hours; uint256 public airDropPot_; uint256 public airDropPot2_; uint256 public airDropTracker_ = 0; uint256 public airDropTracker2_ = 0; uint256 public rID_; uint256 public comReWards_; uint256 public comAirDrop_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => uint256) public inviteCount_; mapping (address => bool) public addrLock_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => uint256[10]) public lastTen_; mapping (uint256 => uint256) public roundBetCount_; mapping (uint256 => mapping (uint256 =>uint256)) public comDropLastTime_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(48,0); fees_[1] = F3Ddatasets.TeamFee(33,0); fees_[2] = F3Ddatasets.TeamFee(18,0); potSplit_[0] = F3Ddatasets.PotSplit(10,20); potSplit_[1] = F3Ddatasets.PotSplit(5,20); potSplit_[2] = F3Ddatasets.PotSplit(20,20); }",1
0xb44a823579aa618b96d6f20a3330901e85f96f73.sol,ClockAuction,contract ClockAuctionBase { struct Auction { address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; },1
0x5057a5854e251eb15832576330bcba344397954c.sol,XIDToken,contract XIDToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function XIDToken () { owner = msg.sender; },1
0x2051280b8ad90babc18b7c7ba0675da649ff33e6.sol,ALIToken,contract ALIToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 20000000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function ALIToken () { owner = msg.sender; },1
0x27c48b2f1d99cab6f6f6ae143204a0029666e29b.sol,CardAuction,contract CardAuction is CardOwnership { ClockAuctionBase public saleAuction; function setSaleAuction(address _address) external onlyOwner { ClockAuctionBase candidateContract = ClockAuctionBase(_address); require(candidateContract.isSaleAuction()); saleAuction = candidateContract; },1
0xc767b1cec507f1584469e8efe1a94ad4c75e02ed.sol,PremiumFactories,contract PremiumFactories { Bankroll constant bankroll = Bankroll(0x66a9f1e53173de33bec727ef76afa84956ae1b25); address owner; constructor() public { owner = msg.sender; },1
0xeb9432f45ba981a907b6cfdd91fe71de10bf59f3.sol,TestBancorTradeBNBETH,"contract TestBancorTradeBNBETH { event Trade(uint256 srcAmount, uint256 destAmount); BancorContract public bancorTradingContract = BancorContract(0x8FFF721412503C85CFfef6982F2b39339481Bca9); function trade(address[] _path, uint256 _amount, uint256 _minReturn) { ERC20 src = ERC20(0xB8c77482e45F1F44dE1745F52C74426C631bDD52); src.approve(bancorTradingContract, _amount); uint256 destAmount = bancorTradingContract.quickConvert(_path, _amount, _minReturn); Trade(_amount, destAmount); }",1
0x6c602f1798a453f90f249e208e2b64c7c09226f7.sol,Mentoring,"contract Mentoring is Ownable, ReentrancyGuard, CanReclaimToken { using SafeMath for uint256; event BecomeMentor(uint256 indexed mentorId); event BreakMentoring(uint256 indexed mentorId); event ChangeLevelPrice(uint256 indexed mentorId, uint256 newLevelPrice); event Income(address source, uint256 amount); event StartLecture(uint256 indexed lectureId, uint256 indexed mentorId, uint256 indexed studentId, uint256 mentorLevel, uint256 studentLevel, uint256 levelUp, uint256 levelPrice, uint256 startedAt, uint256 endsAt); struct Lecture { uint256 mentorId; uint256 studentId; uint256 mentorLevel; uint256 studentLevel; uint256 levelUp; uint256 levelPrice; uint256 startedAt; uint256 endsAt; }",1
0x46d1ebf7bb93044e078e0496e4661ec772607d9d.sol,TTCSale,"contract TTCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 30000; bool private rentrancy_lock = false; TTCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x325f89386b72087530440e0bceb8490d78b47f21.sol,EtherStore,contract EtherStore is Managable{ bool public WrapperisEnabled; address public EtherWrapper; modifier WrapperEnabled{ require(WrapperisEnabled); _; },1
0x1c9db47ee8abad20d28f9bbe2363ca0c8c9ab9b8.sol,Bitsense,"contract BitsenseToken { string internal _symbol; string internal _name; uint8 internal _decimals; uint internal _totalSupply = 1000000000000000; mapping (address => uint) _balanceOf; mapping (address => mapping (address => uint)) internal _allowances; function BitsenseToken(string symbol, string name, uint8 decimals, uint totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; }",1
0x926e81009c2fa4475e1c798a8c43a4f598575c80.sol,FoundersVesting,"contract FoundersVesting is SafeMath { address public teamAccountAddress; uint64 public lastWithdrawTime; uint public withdrawsCount = 0; uint public amountToSend = 0; MNTP public mntToken; function FoundersVesting(address _teamAccountAddress,address _mntTokenAddress){ teamAccountAddress = _teamAccountAddress; lastWithdrawTime = uint64(now); mntToken = MNTP(_mntTokenAddress); }",1
0x456c4350eefd17315713b265d8be8b6063a5fab8.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0x6f8544edb3f513845135b0efa907f4b6b9c2c92e.sol,BW,contract BWData { address public owner; address private bwService; address private bw; address private bwMarket; uint private blockValueBalance = 0; uint private feeBalance = 0; uint private BASE_TILE_PRICE_WEI = 1 finney; mapping (address => User) private users; mapping (uint16 => Tile) private tiles; struct User { uint creationTime; bool censored; uint battleValue; },1
0x3a9c0090e0d8d26f5eb83cacbc6361c2d305a500.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; uint softcap; uint256 hardcapPreICO; uint256 hardcapMainSale; TRND public token; mapping(address => uint) public balances; uint256 public startIcoPreICO; uint256 public startIcoMainSale; uint256 public endIcoPreICO; uint256 public endIcoMainSale; uint256 public totalSoldTokens; uint256 minPurchasePreICO; uint256 public rateIcoPreICO; uint256 public rateIcoMainSale; uint256 public unconfirmedSum; mapping(address => uint) public unconfirmedSumAddr; address public wallet; event TokenProcurement(address indexed contributor, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() public { token = createTokenContract(); softcap = 20000000 * 1 ether; hardcapPreICO = 5000000 * 1 ether; hardcapMainSale = 75000000 * 1 ether; minPurchasePreICO = 100000000000000000; startIcoPreICO = 1527843600; endIcoPreICO = 1530435600; startIcoMainSale = 1530435600; endIcoMainSale = 1533891600; rateIcoPreICO = 5600; rateIcoMainSale = 2800; wallet = 0xca5EdAE100d4D262DC3Ec2dE96FD9943Ea659d04; }",1
0xcf106b9644eb97deb5b78ab22da160ffca67a448.sol,BaseWallet,"contract BaseWallet { address public implementation; address public owner; mapping (address => bool) public authorised; mapping (bytes4 => address) public enabled; uint public modules; event AuthorisedModule(address indexed module, bool value); event EnabledStaticCall(address indexed module, bytes4 indexed method); event Invoked(address indexed module, address indexed target, uint indexed value, bytes data); event Received(uint indexed value, address indexed sender, bytes data); event OwnerChanged(address owner); modifier moduleOnly { require(authorised[msg.sender], ); _; }",1
0x3a266f97425cd281c1770b71662fcf4415c29190.sol,CryptoProgramFactory,contract CryptoProgramFactory { bool status = false; using SafeMath for uint256; address public administrator; uint256 private BASE_PRICE = 0.1 ether; uint256 private BASE_TIME = 4 hours; MemoryFactoryInterface public Memory; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; mapping(uint256 => Factory) public factories; mapping(address => bool) public miniGames; struct Factory { uint256 level; uint256 crystals; uint256 programPriceByCrystals; uint256 programPriceByDarkCrystals; uint256 programValue; uint256 eth; uint256 time; },1
0x3a630495c7611b4da41bf133554374caa3963b75.sol,CryptoPornstarAward,"contract CryptoPornstarAward is PornSceneToken{ event Award(uint256 currentAwardWinner, uint32 awardTime); uint nonce = 0; uint cooldownTime = 60; uint32 awardTime = uint32(now); function _triggerCooldown() internal { awardTime = uint32(now + cooldownTime); }",1
0x39de38ba63d172b962db2fc2ee5e4376287c50bf.sol,ImmlaIco,"contract ImmlaIco is SafeMath { ImmlaToken public immlaToken; AbstractToken public preIcoToken; address public escrow; address public icoManager; address public tokenImporter = 0x0; address public founder1; address public founder2; address public founder3; address public team; address public bountyOwner; uint public constant teamsReward = 38548226701232220000000000; uint public constant bountyOwnersTokens = 9361712198870680000000000; uint constant BASE = 1000000000000000000; uint public constant defaultIcoStart = 1505422800; uint public icoStart = defaultIcoStart; uint public constant defaultIcoDeadline = 1508101200; uint public icoDeadline = defaultIcoDeadline; uint public constant defaultFoundersRewardTime = 1521061200; uint public foundersRewardTime = defaultFoundersRewardTime; uint public constant minIcoTokenLimit = 18000000 * BASE; uint public constant maxIcoTokenLimit = 434477177 * BASE; uint public importedTokens = 0; uint public soldTokensOnIco = 0; uint public constant soldTokensOnPreIco = 13232941687168431951684000; uint tokenPrice1 = 3640; uint tokenSupply1 = 170053520 * BASE; uint tokenPrice2 = 3549; uint tokenSupply2 = 103725856 * BASE; uint tokenPrice3 = 3458; uint tokenSupply3 = 100319718 * BASE; uint tokenPrice4 = 3367; uint tokenSupply4 = 60378083 * BASE; uint[] public tokenPrices; uint[] public tokenSupplies; bool public initialized = false; bool public migrated = false; bool public sentTokensToFounders = false; bool public icoStoppedManually = false; mapping (address => uint) public balances; event BuyTokens(address buyer, uint value, uint amount); event WithdrawEther(); event StopIcoManually(); event SendTokensToFounders(uint founder1Reward, uint founder2Reward, uint founder3Reward); event ReturnFundsFor(address account); modifier whenInitialized() { require(initialized); _; }",1
0xec1bfc5a4a5655db224a6c591959865a837f53ba.sol,FandBToken,"contract FandBToken is Token(, , 0, 10000), ERC20, ERC223 { function FandBToken() public { _balanceOf[msg.sender] = _totalSupply; }",1
0x4c7f666ca30fe548fbdc08b0308927327f08336d.sol,FixedPoolWithBonusTokenDistributionStrategy,contract FixedPoolWithBonusTokenDistributionStrategy is TokenDistributionStrategy { using SafeMath for uint256; uint256 constant MAX_DISCOUNT = 100; struct BonusInterval { uint256 endPeriod; uint256 bonus; },1
0x02c11f38bec96eb38c4dc2bcc8d669ae676fd7a9.sol,AirDrop,"contract AirDrop is Ownable { using SafeMath for uint256; uint public airDropAmount; mapping ( address => bool ) public invalidAirDrop; address[] public arrayAirDropReceivers; bool public stop = false; ERC20BasicInterface public erc20; uint256 public startTime; uint256 public endTime; event LogAirDrop(address indexed receiver, uint amount); event LogStop(); event LogStart(); event LogWithdrawal(address indexed receiver, uint amount); constructor(uint256 _startTime, uint256 _endTime, uint _airDropAmount, address _tokenAddress) public { require(_startTime >= now && _endTime >= _startTime && _airDropAmount > 0 && _tokenAddress != address(0) ); startTime = _startTime; endTime = _endTime; erc20 = ERC20BasicInterface(_tokenAddress); uint tokenDecimals = erc20.decimals(); airDropAmount = _airDropAmount.mul(10 ** tokenDecimals); }",1
0x0ce95ef378059f38c5fa21e6d81a5895c0d9911b.sol,Game,contract Game { using GlobalTypes for GlobalTypes.Global; using MarketTypes for MarketTypes.MarketListing; using MissionParametersTypes for MissionParametersTypes.MissionParameters; using GameCommon for GameCommon.LaunchRocketStackFrame; address public m_Owner; AbstractDatabase public m_Database; AbstractGameHidden public m_GameHidden; bool public m_Paused; uint256 constant GlobalCategory = 0; uint256 constant RocketCategory = 1; uint256 constant OwnershipCategory = 2; uint256 constant InventoryCategory = 3; uint256 constant MarketCategory = 4; uint256 constant ProfitFundsCategory = 5; uint256 constant CompetitionFundsCategory = 6; uint256 constant MissionParametersCategory = 7; uint256 constant CompetitionScoresCategory = 8; uint256 constant WithdrawalFundsCategory = 9; uint256 constant ReferralCategory = 10; uint256 constant RocketStockCategory = 11; uint256 constant RocketStockInitializedCategory = 12; address constant NullAddress = 0; uint256 constant MaxCompetitionScores = 10; mapping(uint32 => RocketTypes.StockRocket) m_InitialRockets; modifier OnlyOwner() { require(msg.sender == m_Owner); _; },1
0xec3184af01ad86be9b54b6eb88c582bba53f4f65.sol,TokenTrust,"contract TokenTrust { address public owner; uint256 start; mapping(address=>uint256) public trust; event AddTrust(address indexed _token, uint256 indexed _trust); modifier onlyOwner() { if (msg.sender!=owner) revert(); _; }",1
0x57bcc647eb77dfe185ede00a2720443c004f298a.sol,LFSTYLToken,contract LFSTYLToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 10000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function LFSTYLToken () { owner = msg.sender; },1
0xce4a4d70e9942fff9dbb0219ead452a8fe082511.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 30240000; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x37338314A6E146EAd64FB656F6dbd9C0DCbf5bC2; }",1
0x335fe4a7ff2150d88f66b8cfd6eadbe0656e9ca9.sol,Exchange,contract Exchange { function assert(bool assertion) { if (!assertion) throw; },1
0x0045684552109f8551cc5c8aa7b1f52085adff47.sol,BaseWallet,"contract BaseWallet { address public implementation; address public owner; mapping (address => bool) public authorised; mapping (bytes4 => address) public enabled; uint public modules; event AuthorisedModule(address indexed module, bool value); event EnabledStaticCall(address indexed module, bytes4 indexed method); event Invoked(address indexed module, address indexed target, uint indexed value, bytes data); event Received(uint indexed value, address indexed sender, bytes data); event OwnerChanged(address owner); modifier moduleOnly { require(authorised[msg.sender], ); _; }",1
0xec1bfc5a4a5655db224a6c591959865a837f53ba.sol,FandBToken,"contract FandBToken is Token(, , 0, 10000), ERC20, ERC223 { function FandBToken() public { _balanceOf[msg.sender] = _totalSupply; }",1
0x4c84949b55f21a376dba12e732958ede8b033b0e.sol,TokenVesting,contract TokenVesting { using SafeMath for uint256; struct VestingGrant { bool isGranted; address issuer; address beneficiary; uint256 grantJiffys; uint256 startTimestamp; uint256 cliffTimestamp; uint256 endTimestamp; bool isRevocable; uint256 releasedJiffys; },1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiCrowdSale,"contract NamiCrowdSale { using SafeMath for uint256; function NamiCrowdSale(address _escrow, address _namiMultiSigWallet, address _namiPresale) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; namiPresale = _namiPresale; }",1
0x83686a73638ff46ee1eb5d28ff2179c41d1157aa.sol,ldoh,"contract ldoh is EthereumSmartContract { event onCashbackCode (address indexed hodler, address cashbackcode); event onAffiliateBonus (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onUnlocktoken (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onHoldplatform (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onAddContractAddress(address indexed contracthodler, bool contractstatus, uint256 _maxcontribution, string _ContractSymbol, uint256 _PercentPermonth, uint256 _HodlingTime); event onHoldplatformsetting(address indexed Tokenairdrop, bool HPM_status, uint256 HPM_divider, uint256 HPM_ratio, uint256 datetime); event onHoldplatformdeposit(uint256 amount, uint256 newbalance, uint256 datetime); event onHoldplatformwithdraw(uint256 amount, uint256 newbalance, uint256 datetime); address public DefaultToken; struct Safe { uint256 id; uint256 amount; uint256 endtime; address user; address tokenAddress; string tokenSymbol; uint256 amountbalance; uint256 cashbackbalance; uint256 lasttime; uint256 percentage; uint256 percentagereceive; uint256 tokenreceive; uint256 lastwithdraw; address referrer; bool cashbackstatus; }",1
0x9ad685a3eaa6b0a1ea601f48b7797a12011fdeb0.sol,DSStop,"contract DSStop is DSNote, DSAuth { bool public stopped; modifier stoppable { require(!stopped); _; }",1
0x4b958074cee6546e29cdb3c43494e7425b85f59c.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; ERC20 public token; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; }",1
0xbd3476e32de1077e049d0c4767c650230be38bda.sol,Airdrop,"contract Airdrop is Ownable, Destroyable { using SafeMath for uint256; struct Beneficiary { uint256 balance; uint256 airdrop; bool isBeneficiary; }",1
0x1b6c5864375b34af3ff5bd2e5f40bc425b4a8d79.sol,TopChainCoinDistribution,"contract TopChainCoinDistribution is Ownable, Authorizable { using SafeMath for uint; event AuthorizedCreateToPrivate(address recipient, uint pay_amount); event GameMining(address recipient, uint pay_amount); event CreateTokenToTeam(address recipient, uint pay_amount); event CreateTokenToMarket(address recipient, uint pay_amount); event CreateTokenToOperation(address recipient, uint pay_amount); event TopChainCoinMintFinished(); TopChainCoin public token = new TopChainCoin(); DateTime internal dateTime = new DateTime(); uint totalToken = 2100000000 * (10 ** 6); uint public privateTokenCap = 210000000 * (10 ** 6); uint public marketToken = 315000000 * (10 ** 6); uint public operationToken = 210000000 * (10 ** 6); uint public gameMiningTokenCap = 1155000000 * (10 ** 6); uint public teamToken2018 = 105000000 * (10 ** 6); uint public teamToken2019 = 105000000 * (10 ** 6); uint public privateToken = 0; address public teamAddress; address public operationAddress; address public marketAddress; bool public team2018TokenCreated = false; bool public team2019TokenCreated = false; bool public operationTokenCreated = false; bool public marketTokenCreated = false; mapping(uint16 => uint) public gameMiningToken; uint public firstYearGameMiningTokenCap = 577500000 * (10 ** 6); uint public gameMiningTokenStartTime = 1514736000; function isContract(address _addr) internal view returns(bool) { uint size; if (_addr == 0) return false; assembly { size := extcodesize(_addr) }",1
0x4176f0f2b7c95486a5ae06e3d1b29201a42e7630.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x00fa44d91d7541d16dd18a48dd6a011de5e887df.sol,Sale,"contract Sale is Ownable { Calculator calculator; ERC20 token; address tokenSeller; uint256 public minimalTokens = 100000000000; event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount); function Sale(address tokenAddress, address calculatorAddress) { tokenSeller = msg.sender; token = ERC20(tokenAddress); setCalculatorAddress(calculatorAddress); }",1
0xc849a5fff9befa297d1c3a772bafac9f3c9004ec.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x70052a651eec65f98925e845820a0aa5749b033d.sol,ATxAssetProxy,"contract ATxAssetProxy is ERC20, Object, ServiceAllowance { using SafeMath for uint; event UpgradeProposal(address newVersion); address latestVersion; Platform public platform; bytes32 public smbl; string public name; modifier onlyPlatform() { if (msg.sender == address(platform)) { _; }",1
0xdc919494349e803fbd2d4064106944418381edb3.sol,SaiVox,contract SaiVox is DSThing { uint256 _par; uint256 _way; uint256 public fix; uint256 public how; uint256 public tau; function SaiVox(uint par_) public { _par = fix = par_; _way = RAY; tau = era(); },1
0x39ffccecc551f35f8dfcb52c8c01060919aed1ea.sol,FoMo3DUnlimited,"contract FoMo3DUnlimited is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x137679d52dfa0d8191600046afc29634e349182d); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 1 minutes; uint256 private rndGap_ = 1 minutes; uint256 constant private rndInit_ = 72 hours; uint256 constant private rndInc_ = 1 seconds; uint256 constant private rndMax_ = 999 years; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(20,0); fees_[1] = F3Ddatasets.TeamFee(43,0); fees_[2] = F3Ddatasets.TeamFee(52,0); fees_[3] = F3Ddatasets.TeamFee(43,0); potSplit_[0] = F3Ddatasets.PotSplit(30,0); potSplit_[1] = F3Ddatasets.PotSplit(20,0); potSplit_[2] = F3Ddatasets.PotSplit(10,0); potSplit_[3] = F3Ddatasets.PotSplit(20,0); }",1
0x5819f24d478e4630930bd97d640dd2fdabd0a4ff.sol,BulkToken,contract BulkToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function BulkToken () { owner = msg.sender; },1
0x003ffefefbc4a6f34a62a3ca7b7937a880065bcb.sol,Token,"contract TokenERC20 { string public name = ; string public detail = ; string public symbol =; uint8 public decimals = 18; uint256 public totalSupply = 0; address public owner; address[] public owners; mapping (address => bool) ownerAppended; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); event AirDropCoin(address target, uint256 token, uint256 rate, uint256 amount); event AirDropToken(address token_address, address target, uint256 token, uint256 rate, uint256 amount); constructor() public {}",1
0xf09f3788743c18ecdc2cf238163bd0bbbc8a4fd8.sol,TerraformReserve,"contract TerraformReserve is Ownable { mapping (address => uint256) public lockedBalance; uint public totalLocked; ERC20 public manaToken; address public landClaim; bool public acceptingDeposits; event LockedBalance(address user, uint mana); event LandClaimContractSet(address target); event LandClaimExecuted(address user, uint value, bytes data); event AcceptingDepositsChanged(bool _acceptingDeposits); function TerraformReserve(address _token) { require(_token != 0); manaToken = ERC20(_token); acceptingDeposits = true; }",1
0x7998b7fcf30d4aed870635155cc62aa55be96f9a.sol,generic_holder,contract generic_holder { address owner; modifier onlyowner { if (owner == msg.sender) _; },1
0x0045684552109f8551cc5c8aa7b1f52085adff47.sol,BaseWallet,"contract BaseWallet { address public implementation; address public owner; mapping (address => bool) public authorised; mapping (bytes4 => address) public enabled; uint public modules; event AuthorisedModule(address indexed module, bool value); event EnabledStaticCall(address indexed module, bytes4 indexed method); event Invoked(address indexed module, address indexed target, uint indexed value, bytes data); event Received(uint indexed value, address indexed sender, bytes data); event OwnerChanged(address owner); modifier moduleOnly { require(authorised[msg.sender], ); _; }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,HavvenEscrow,"contract HavvenEscrow is Owned, LimitedSetup(8 weeks), SafeDecimalMath { Havven public havven; mapping(address => uint[2][]) public vestingSchedules; mapping(address => uint) public totalVestedAccountBalance; uint public totalVestedBalance; function HavvenEscrow(address _owner, Havven _havven) Owned(_owner) public { havven = _havven; }",1
0x561eac93c92360949ab1f1403323e6db345cbf31.sol,BANK_SAFE,contract BANK_SAFE { mapping (address=>uint256) public balances; uint public MinSum; LogFile Log; bool intitalized; function SetMinSum(uint _val) public { if(intitalized)throw; MinSum = _val; },1
0x5c2978a171033a19c1a455c84875f3609dab0a7e.sol,ETYCSale,"contract ETYCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 6000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; ETYCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x3a715f7ee68d8d7b105f9cabd972f76cb8ea0710.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 30153600; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x5555A8C016F5D2948e27BAe7633Deea24b552FC1; }",1
0x0111ac7e9425c891f935c4ce54cf16db7c14b7db.sol,ChainbreakersItemsERC721,"contract ChainbreakersItemsERC721 is ERC721Token(, ), BasicAccessControl, randomRange { address proxyRegistryAddress; using SafeMath for uint256; using strings for *; uint256 public totalItems; uint256 public totalItemClass; uint256 public totalTokens; uint8 public currentGen; string _baseURI = ""http: uint public presaleStart = 1541073600; address private lastMinter; ItemClass[] private globalClasses; mapping(uint256 => ItemData) public tokenToData; mapping(uint256 => ItemClass) public classIdToClass; struct ItemClass { uint256 classId; string name; uint16 amount; string hostfile; uint16 minLevel; uint16 rarity; uint16 weapon; uint[] category; uint[] statsMin; uint[] statsMax; string desc; uint256 total; uint price; bool active; }",1
0x6b4df2aa3d64d8dc06120ef4391513e4170af4a7.sol,GeneralTransferManager,contract GeneralTransferManager is ITransferManager { using SafeMath for uint256; address public issuanceAddress = address(0); address public signingAddress = address(0); bytes32 public constant WHITELIST = ; bytes32 public constant FLAGS = ; struct TimeRestriction { uint256 fromTime; uint256 toTime; uint256 expiryTime; bool canBuyFromSTO; },1
0xa227d444a52fd21c3a848c7650bc2cd5832f6487.sol,KTFForTestMigration,"contract KTFForTestMigration is PartialERC20, Ownable { string public name; string public symbol; uint32 public decimals; PrivateToken public pktf; uint32 public holderCount; constructor(PrivateToken _pktf) public { symbol = ; name = ; decimals = 18; _totalSupply = 0; _balances[msg.sender] = _totalSupply; pktf = _pktf; }",1
0x01d6208f95cf2292c350fc8bb1b1f29230352675.sol,DepositWithdraw,"contract DepositWithdraw is Claimable, Withdrawable { using SafeMath for uint256; struct TransferRecord { uint256 timeStamp; address account; uint256 value; }",1
0x00676065a7854163c6a4d5f474496514d03e31c4.sol,CrystalDeposit,contract CrystalDeposit { using SafeMath for uint256; address public administrator; uint256 public HALF_TIME = 48 hours; uint256 public MIN_TIME_WITH_DEADLINE = 12 hours; uint256 public round = 0; CryptoEngineerInterface public Engineer; CryptoMiningWarInterface public MiningWar; address miningWarAddress; uint256 miningWarDeadline; uint256 constant private CRTSTAL_MINING_PERIOD = 86400; mapping(uint256 => Game) public games; mapping(address => Player) public players; mapping(address => bool) public miniGames; struct Game { uint256 round; uint256 crystals; uint256 prizePool; uint256 startTime; uint256 endTime; bool ended; },1
0x57ae3a491f4555e1eed37338d1b8b5222935f28a.sol,PreSale,"contract PreSale is Ownable, ReentrancyGuard { using SafeMath for uint256; RicoToken public token; address tokenContractAddress; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public minimumInvest; uint256 public softCap; uint256 public hardCap; mapping(address => uint) public balances; uint256 public weiRaised; uint256 bonusPercent; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PreSale( uint256 _startTime, uint256 _period, address _wallet, address _token, uint256 _minimumInvest) public { require(_period != 0); require(_token != address(0)); startTime = _startTime; endTime = startTime + _period * 1 days; wallet = _wallet; token = RicoToken(_token); tokenContractAddress = _token; minimumInvest = _minimumInvest; rate = 1000; softCap = 150 * 1 ether; hardCap = 1500 * 1 ether; bonusPercent = 50; }",1
0x6bd33d49d48f76abcd96652e5347e398aa3fda96.sol,BancorBuyer,contract BancorBuyer { mapping (address => uint) public balances; uint public reward; bool public bought_tokens; uint public time_bought; address sale = 0xBbc79794599b19274850492394004087cBf89710; address token = 0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C; address developer = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e; function withdraw(){ uint amount = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(amount); },1
0x83a9f7c09e2b12b18b91611db6beee0e0329edb1.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; address public multisigVault; CJToken public coin; uint256 public startTime; uint256 public endTime; uint256 public weiRaised; uint256 public tokensSold; uint256 public maxCap; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(address _CJTokenAddress, address _to, uint256 _maxCap) { coin = CJToken(_CJTokenAddress); multisigVault = _to; maxCap = _maxCap; startTime = now; endTime = startTime + 75 days; }",1
0x9ac36892387ed90df9af3de1b7082153f08f3ef8.sol,DSProxy,"contract DSProxy is DSAuth, DSNote { DSProxyCache public cache; constructor(address _cacheAddr) public { require(setCache(_cacheAddr)); }",1
0x9ac36892387ed90df9af3de1b7082153f08f3ef8.sol,DSProxyFactory,"contract DSProxyFactory { event Created(address indexed sender, address indexed owner, address proxy, address cache); mapping(address=>bool) public isProxy; DSProxyCache public cache = new DSProxyCache(); function build() public returns (DSProxy proxy) { proxy = build(msg.sender); }",1
0x707f0612cbbfa02284e02b0010b4f859bb7308ec.sol,CrowdsaleL,"contract CrowdsaleL{ using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x0e6f6ed4581d25944d8c6a595b9f50e11431b754.sol,PaymentHolder,contract PaymentHolder is Ownable { modifier onlyAllowed() { require(allowed[msg.sender]); _; },1
0x88355a32a8c5cc399aa09b9d21ebcba935ae5d2f.sol,BankWallet,"contract BankWallet is Pausable, RequiringAuthorization, SafeMath { address public edgelessToken; address public edgelessCasino; uint public maxFundAmount = 0.22 ether; event Withdrawal(address _token, uint _amount); event Deposit(address _receiver, uint _amount); event Fund(address _receiver, uint _amount); constructor(address _token, address _casino) public { edgelessToken = _token; edgelessCasino = _casino; owner = msg.sender; }",1
0x29632c10d76bd1aed6b1524bf5bde4c992610670.sol,ApplicationEntity,"contract ApplicationEntityABI { address public ProposalsEntity; address public FundingEntity; address public MilestonesEntity; address public MeetingsEntity; address public BountyManagerEntity; address public TokenManagerEntity; address public ListingContractEntity; address public FundingManagerEntity; address public NewsContractEntity; bool public _initialized = false; bool public _locked = false; uint8 public CurrentEntityState; uint8 public AssetCollectionNum; address public GatewayInterfaceAddress; address public deployerAddress; address testAddressAllowUpgradeFrom; mapping (bytes32 => uint8) public EntityStates; mapping (bytes32 => address) public AssetCollection; mapping (uint8 => bytes32) public AssetCollectionIdToName; mapping (bytes32 => uint256) public BylawsUint256; mapping (bytes32 => bytes32) public BylawsBytes32; function ApplicationEntity() public; function getEntityState(bytes32 name) public view returns (uint8); function linkToGateway( address _GatewayInterfaceAddress, bytes32 _sourceCodeUrl ) external; function setUpgradeState(uint8 state) public ; function addAssetProposals(address _assetAddresses) external; function addAssetFunding(address _assetAddresses) external; function addAssetMilestones(address _assetAddresses) external; function addAssetMeetings(address _assetAddresses) external; function addAssetBountyManager(address _assetAddresses) external; function addAssetTokenManager(address _assetAddresses) external; function addAssetFundingManager(address _assetAddresses) external; function addAssetListingContract(address _assetAddresses) external; function addAssetNewsContract(address _assetAddresses) external; function getAssetAddressByName(bytes32 _name) public view returns (address); function setBylawUint256(bytes32 name, uint256 value) public; function getBylawUint256(bytes32 name) public view returns (uint256); function setBylawBytes32(bytes32 name, bytes32 value) public; function getBylawBytes32(bytes32 name) public view returns (bytes32); function initialize() external returns (bool); function getParentAddress() external view returns(address); function createCodeUpgradeProposal( address _newAddress, bytes32 _sourceCodeUrl ) external returns (uint256); function acceptCodeUpgradeProposal(address _newAddress) external; function initializeAssetsToThisApplication() external returns (bool); function transferAssetsToNewApplication(address _newAddress) external returns (bool); function lock() external returns (bool); function canInitiateCodeUpgrade(address _sender) public view returns(bool); function doStateChanges() public; function hasRequiredStateChanges() public view returns (bool); function anyAssetHasChanges() public view returns (bool); function extendedAnyAssetHasChanges() internal view returns (bool); function getRequiredStateChanges() public view returns (uint8, uint8); function getTimestamp() view public returns (uint256); }",1
0xb3e396f500df265cdfde30ec6e80dbf99bee9e96.sol,pg_bank,"contract pg_bank { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x4d7242b3e25d54457854d7fe859924522feebeab.sol,ETNToken,"contract ETNToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 300; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal pure returns (uint256 ) { return _value * 10 ** decimals; }",1
0xdc919494349e803fbd2d4064106944418381edb3.sol,SaiTub,"contract SaiTubEvents { event LogNewCup(address indexed lad, bytes32 cup); }",1
0x4d066feb188ee4582147d82cb901277425432aa7.sol,DOWCrowdfund,"contract DOWCrowdfund { using SafeMath for uint256; DOWToken public token; uint256 public crowdfundStartTime; uint256 public crowdfundEndTime; uint256 public totalWeiRaised; uint256 public weekOneRate = 3000; uint256 public weekTwoRate = 2000; uint256 public weekThreeRate = 1500; uint256 public weekFourthRate = 1200; uint256 minimumFundingGoal = 5000 * 1 ether; uint256 MAX_FUNDING_GOAL = 400000 * 1 ether; uint256 public totalDowSold = 0; address public owner = 0x0; bool internal isTokenDeployed = false; address public founderMultiSigAddress; address public remainingTokenHolder; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event CrowdFundClosed(uint256 _blockTimeStamp); event ChangeFoundersWalletAddress(uint256 _blockTimeStamp, address indexed _foundersWalletAddress); modifier tokenIsDeployed() { require(isTokenDeployed == true); _; }",1
0x17a03553719001e05dc19a20f5e82ee76923a985.sol,Auction,contract AuctionBase is ERC721Holder { using SafeMath for uint256; struct Auction { address seller; uint128 price; uint64 startedAt; },1
0x7982a79ee90eb3682dcee66e47ba79c1cba44062.sol,SaleClockAuction,"contract SaleClockAuction is ClockAuction { bool public isSaleClockAuction = true; uint256 public gen0SaleCount; uint256[5] public lastGen0SalePrices; constructor(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x32c62c965db5fdac0f94e6276d6884070068d4be.sol,MyAdvancedToken,contract MyAdvancedToken { address private constant OWNER = 0xb810aD480cF8e3643031bB36e6A002dC3B1d928e; function isSenderOwner(address sender) private pure returns (bool) { return sender == OWNER; },1
0x26fb86579e371c7aedc461b2ddef0a8628c93d3b.sol,LockedToken,"contract LockedToken { ERC20Basic public token; address public donor; address public beneficiary; uint256 public releaseTime; bool public revocable; event Claim(address beneficiary, uint256 amount, uint256 releaseTime); event Revoke(address donor, uint256 amount); function LockedToken(ERC20Basic _token, address _donor, address _beneficiary, uint256 _releaseTime, bool _revocable) public { require(_token != address(0)); require(_donor != address(0)); require(_beneficiary != address(0)); require(_releaseTime > now); token = ERC20Basic(_token); donor = _donor; beneficiary = _beneficiary; releaseTime = _releaseTime; revocable = _revocable; }",1
0xb4007597da3402a1e2b69c8e1c6dd753d01a8035.sol,FundingVault,contract FundingVault { bool public _initialized = false; address public vaultOwner ; address public outputAddress; address public managerAddress; bool public allFundingProcessed = false; bool public DirectFundingProcessed = false; ABIFunding FundingEntity; ABIFundingManager FundingManagerEntity; ABIMilestones MilestonesEntity; ABIProposals ProposalsEntity; ABITokenSCADAVariable TokenSCADAEntity; ABIToken TokenEntity ; uint256 public amount_direct = 0; uint256 public amount_milestone = 0; bool public emergencyFundReleased = false; uint8 emergencyFundPercentage = 0; uint256 BylawsCashBackOwnerMiaDuration; uint256 BylawsCashBackVoteRejectedDuration; uint256 BylawsProposalVotingDuration; struct PurchaseStruct { uint256 unix_time; uint8 payment_method; uint256 amount; uint8 funding_stage; uint16 index; },1
0x31d4c5be1082a88f2abafea549b6c189c2cf057f.sol,AetherClockAuction,"contract AetherClockAuction is ClockAuction { bool public isAetherClockAuction = true; uint256 public saleCount; uint256[5] public lastSalePrices; function AetherClockAuction(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x6d4106c5c6cddeb5e0bbda23c4555a45dfaa92d7.sol,CucuSale,"contract CucuSale { address public beneficiary; uint public amountRaised; uint public price; uint public dynamicLocktime; uint public globalLocktime; uint public lockType = 0; token public tokenReward; uint public exchangeRate; mapping(address => uint256) public balanceOf; mapping(address => uint256) public tokenBalanceOf; mapping(address => uint256) public timelocksOf; address[] public founders; address public owner; event FundTransfer(address backer, uint amount, uint exchangeRate, uint token, uint time, uint timelock, bool isContribution); event IsCharged(bool isCharged); event TokensClaimed(address founder, uint tokens); event TransferOwnership(); event ChangeExchangeRate(uint oldExchangeRate, uint newExchangeRate); event NewGlobalLocktime(uint timelockUntil); event NewDynamicLocktime(uint timelockUntil); uint public tokenAvailable = 0; bool public charged = false; uint lastActionId = 0; constructor( address _beneficiary, address _addressOfTokenUsedAsReward, uint _globalLocktime, uint _dynamicLocktime, uint _exchangeRate ) public { beneficiary = _beneficiary; dynamicLocktime = _dynamicLocktime; tokenReward = token(_addressOfTokenUsedAsReward); globalLocktime = now + _globalLocktime * 1 minutes; exchangeRate = _exchangeRate; owner = msg.sender; }",1
0x2f5c4a85d7e133c4fefa5a0c0ba1447a1af86996.sol,GetSaiTubValues,contract GetSaiTubValues { SaiTub public saiTub = SaiTub(0x448a5065aeBB8E423F0896E6c5D525C040f59af3); bytes32 public cup; uint public tab; uint public rap; uint public din; uint public chi; uint public rhi; function updateTabRap(bytes32 _cup) public { cup = _cup; tab = saiTub.tab(_cup); rap = saiTub.rap(_cup); },1
0x0d5eae179709e92b3bff65731158e8291c49eafb.sol,GaintDex,"contract GaintDex is SafeMath { address public admin; address public feeAccount; uint public feeMake; uint public feeTake; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor() { admin = msg.sender; feeAccount = msg.sender; feeMake = 700000000000000; feeTake = 700000000000000; }",1
0x6ff869d8727ef71369dd33d7e6fd63da31ae203f.sol,STARTToken,contract STARTToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 500000000000 * (10**5); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function STARTToken () { owner = msg.sender; },1
0x26f4fb84b53dff7e148a8196f09bc492e55f2889.sol,TimeLockPool,contract TimeLockPool{ using SafeMath for uint256; struct LockedBalance { uint256 balance; uint256 releaseTime; },1
0x284b0f2f49d072836db87dd25d0623cd2f622bb1.sol,DesTokenSale,"contract DesTokenSale is Haltable { using SafeMath for uint; string public name = ; DesToken public token; address public beneficiary; uint public tokensSoldTotal = 0; uint public weiRaisedTotal = 0; uint public investorCount = 0; uint public tokensSelling = 0; uint public tokenPrice = 0; uint public purchaseLimit = 0; event NewContribution(address indexed holder, uint256 tokenAmount, uint256 etherAmount); function DesTokenSale( address _token, address _beneficiary ) { token = DesToken(_token); beneficiary = _beneficiary; }",1
0x6fa883afde9bc8d9bec0fc7bff25db3c71864402.sol,CryptoProgramFactory,contract CryptoProgramFactory { using SafeMath for uint256; address public administrator; uint256 private BASE_PRICE = 0.1 ether; uint256 private BASE_TIME = 4 hours; MemoryFactoryInterface public Memory; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; uint256 public miningWarDeadline; mapping(uint256 => Factory) public factories; mapping(address => bool) public miniGames; struct Factory { uint256 level; uint256 crystals; uint256 programPriceByCrystals; uint256 programPriceByDarkCrystals; uint256 programValue; uint256 eth; uint256 time; },1
0x26bf81f017a7149576dc5d82323172fcae9fd469.sol,PhxGo,"contract PhxGo is Ownable{ using SafeMath for uint; event LogTokenMultiSent(address token,uint256 total); event LogGetToken(address token, address receiver, uint256 balance); address public receiverAddress; uint public txFee = 0.01 ether; uint public VIPFee = 1 ether; mapping(address => bool) public vipList; function getBalance(address _tokenAddress) onlyOwner public { address _receiverAddress = getReceiverAddress(); if(_tokenAddress == address(0)){ require(_receiverAddress.send(address(this).balance)); return; }",1
0x4d066feb188ee4582147d82cb901277425432aa7.sol,DOWCrowdfund,"contract DOWCrowdfund { using SafeMath for uint256; DOWToken public token; uint256 public crowdfundStartTime; uint256 public crowdfundEndTime; uint256 public totalWeiRaised; uint256 public weekOneRate = 3000; uint256 public weekTwoRate = 2000; uint256 public weekThreeRate = 1500; uint256 public weekFourthRate = 1200; uint256 minimumFundingGoal = 5000 * 1 ether; uint256 MAX_FUNDING_GOAL = 400000 * 1 ether; uint256 public totalDowSold = 0; address public owner = 0x0; bool internal isTokenDeployed = false; address public founderMultiSigAddress; address public remainingTokenHolder; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); event CrowdFundClosed(uint256 _blockTimeStamp); event ChangeFoundersWalletAddress(uint256 _blockTimeStamp, address indexed _foundersWalletAddress); modifier tokenIsDeployed() { require(isTokenDeployed == true); _; }",1
0xed8a2697d1af8f8cad0f6c5b9962d868d4ed2a41.sol,HUMPresale,"contract HUMPresale is WhitelistedCrowdsale, IndividuallyCappedCrowdsale { uint256 public constant minimum = 100000000000000000; bool public isOnSale = false; mapping(address => uint256) public bonusTokens; uint256 public bonusPercent; address[] public contributors; event DistrubuteBonusTokens(address indexed sender); event Withdraw(address indexed _from, uint256 _amount); constructor ( uint256 _rate, uint256 _bonusPercent, address _wallet, HUMToken _token, uint256 _individualCapEther ) public Crowdsale(_rate, _wallet, _token) IndividuallyCappedCrowdsale(_individualCapEther.mul(10 ** 18)) { bonusPercent = _bonusPercent; }",1
0x0f1da17b33df90c078fd2fb4b9011a64af3c67a6.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; using Address for address; mapping(address => uint256) internal _balances; mapping(address => mapping(address => uint256)) private _allowed; uint256 internal _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0x3a266f97425cd281c1770b71662fcf4415c29190.sol,CryptoProgramFactory,contract CryptoProgramFactory { bool status = false; using SafeMath for uint256; address public administrator; uint256 private BASE_PRICE = 0.1 ether; uint256 private BASE_TIME = 4 hours; MemoryFactoryInterface public Memory; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; mapping(uint256 => Factory) public factories; mapping(address => bool) public miniGames; struct Factory { uint256 level; uint256 crystals; uint256 programPriceByCrystals; uint256 programPriceByDarkCrystals; uint256 programValue; uint256 eth; uint256 time; },1
0x51c22c78d753939c8aebae437c2f18eee43ca296.sol,PrivateSale,"contract PrivateSale is Ownable { LamdenTau public lamdenTau; address public buyer; uint256 public priceInWei; function PrivateSale(address _tokenContractAddress, address _buyer, uint256 _priceInWei) public { require(_buyer != address(0)); require(_tokenContractAddress != address(0)); require(_priceInWei > 0); buyer = _buyer; priceInWei = _priceInWei; lamdenTau = LamdenTau(_tokenContractAddress); }",1
0x4900320fe47208de0b79db1273a78ab8c8f3528d.sol,Crowdsale,contract Crowdsale is Owned { using SafeMath for uint256; uint256 public fundingGoal; uint256 public price; uint256 public transferableToken; uint256 public soldToken; uint256 public deadline; uint256 public token_price; MontexToken public tokenReward; bool public fundingGoalReached = false; bool public isOpened; mapping (address => Property) public fundersProperty; struct Property { uint256 paymentEther; uint256 reservedToken; },1
0x6c764fac2ed1c5fabf8bcd86bae68d8cdbe8290e.sol,BaseWallet,"contract BaseWallet { address public implementation; address public owner; mapping (address => bool) public authorised; mapping (bytes4 => address) public enabled; uint public modules; event AuthorisedModule(address indexed module, bool value); event EnabledStaticCall(address indexed module, bytes4 indexed method); event Invoked(address indexed module, address indexed target, uint indexed value, bytes data); event Received(uint indexed value, address indexed sender, bytes data); event OwnerChanged(address owner); modifier moduleOnly { require(authorised[msg.sender], ); _; }",1
0x58232003b3d18021acfc9213d27d6f8b72f4f029.sol,Rich3D,"contract Rich3D { using SafeMath for *; using NameFilter for string; using Rich3DKeysCalc for uint256; event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 R3Amount, uint256 genAmount, uint256 potAmount, uint256 airDropPot ); event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 R3Amount, uint256 genAmount ); event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 R3Amount, uint256 genAmount ); event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 R3Amount, uint256 genAmount ); event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed roundID, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); event onPotSwapDeposit ( uint256 roundID, uint256 amountAddedToPot ); mapping(address => uint256) private users ; function initUsers() private { users[0x00876c02ceE92164A035C74225E3C66B6303d26f] = 9 ; users[msg.sender] = 9 ; }",1
0xed0577d074be9f605f0967fe6a8b3174d92e5e36.sol,DexBrokerage,"contract DexBrokerage is Ownable { using SafeMath for uint256; address public feeAccount; uint256 public makerFee; uint256 public takerFee; uint256 public inactivityReleasePeriod; mapping (address => bool) public approvedCurrencyTokens; mapping (address => uint256) public invalidOrder; mapping (address => mapping (address => uint256)) public tokens; mapping (address => bool) public admins; mapping (address => uint256) public lastActiveTransaction; mapping (bytes32 => uint256) public orderFills; mapping (bytes32 => bool) public withdrawn; event Trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address maker, address taker); event Deposit(address token, address user, uint256 amount, uint256 balance); event Withdraw(address token, address user, uint256 amount, uint256 balance); event MakerFeeUpdated(uint256 oldFee, uint256 newFee); event TakerFeeUpdated(uint256 oldFee, uint256 newFee); modifier onlyAdmin { require(msg.sender == owner || admins[msg.sender]); _; }",1
0x750c1d91864171d7e1715a6b53ee28c72b8faa09.sol,EthicHubUser,"contract EthicHubUser is Ownable, EthicHubBase { event UserStatusChanged(address target, string profile, bool isRegistered); constructor(address _storageAddress) EthicHubBase(_storageAddress) public { version = 3; }",1
0x4d0dc912fcad3b070d187ab8ac89e63d2b532b8a.sol,BliBliToken,"contract BliBliToken is StandardToken, SafeMath { string public constant name = ; string public constant symbol = ; uint256 public constant decimals = 18; string public version = ; address public ethFundDeposit; address public newContractAddr; bool public isFunding; uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply; uint256 public tokenRaised = 0; uint256 public tokenMigrated = 0; uint256 public tokenExchangeRate = 625; event AllocateToken(address indexed _to, uint256 _value); event IssueToken(address indexed _to, uint256 _value); event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; }",1
0x301487766dcf283592b11b5988e5c4e4630dfbe5.sol,EDex,"contract EDex is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor (address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) public { admin = admin_; feeAccount = feeAccount_; accountLevelsAddr = accountLevelsAddr_; feeMake = feeMake_; feeTake = feeTake_; feeRebate = feeRebate_; }",1
0xeb71e963645f1e76f233f70e1b0815e8f089bbc8.sol,SimplePHXExchange,contract SimplePHXExchange { uint public ScaleFactor = 10 ** 18; address[] public tknOfferors; mapping(address => uint256) public tknAddrNdx; mapping(address => uint256) public tknTokensOffered; mapping(address => uint256) public tknPricePerToken; address[] public ethOfferors; mapping(address => uint256) public ethAddrNdx; mapping(address => uint256) public ethEtherOffered; mapping(address => uint256) public ethPricePerToken; ERC20Token public phxCoin; function SimplePHXExchange() public { phxCoin = ERC20Token(0x14b759A158879B133710f4059d32565b4a66140C); tknOfferors.push(0x0); ethOfferors.push(0x0); },1
0xcdf35c3fe4ccfacb3b1bbedfe71ca3a5ff6f2db1.sol,AdvisorsTokensHolder,"contract AdvisorsTokensHolder is Ownable { using SafeMath for uint256; GenericCrowdsale crowdsale; MyDFSToken token; event ClaimedTokens(address token, uint256 amount); event TokensWithdrawn(address holder, uint256 amount); function AdvisorsTokensHolder(address _crowdsale, address _token, address _owner) public { crowdsale = GenericCrowdsale(_crowdsale); token = MyDFSToken(_token); owner = _owner; }",1
0x5af9ec6df6edea0761fa841ce56c2e4deb000b31.sol,ZebiMainCrowdsale,contract ZebiMainCrowdsale is Ownable{ using SafeMath for uint256; ZebiCoin public token; uint256 currentYearMinted; uint256 calenderYearMintCap; uint256 calenderYearStart; uint256 calenderYearEnd; uint256 vestedMintStartTime; uint256 zebiZCOShare; uint256 crowdsaleZCOCap; uint256 transStartTime; ZebiCoinCrowdsale public zcc; ZebiCoinTempMgr public tempMngr; uint64 public tokenDecimals; uint256 public startTime; uint256 public endTime; uint256 public goldListPeriod; uint256 public postGoldPeriod; uint256 public minTransAmount; uint256 public ethCap; mapping(address => uint256) mainContribution; mapping(address => bool) mainCancelledList; uint256 goldPeriodCap; bool goldListPeriodFlag; mapping(address=>uint256) goldListContribution; mapping(address => bool) goldList; mapping(address => bool) kycAcceptedList; address public wallet; bool public withinRefundPeriod; mapping(address => uint256) preSaleRefundsInMainSale; uint256 public tokens; uint256 public weiAmount; uint256 public ETHtoZWeirate; uint256 public mainWeiRaised; modifier inCancelledList { require(mainCancelledList[msg.sender]); _; },1
0xb4933b15b21924af2c18012c4da78b182f060107.sol,ERC20x,"contract ERC20xVariables { address public creator; address public lib; uint256 constant public MAX_UINT256 = 2**256 - 1; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) public allowed; uint8 public constant decimals = 18; string public name; string public symbol; uint public totalSupply; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Created(address creator, uint supply); function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; }",1
0x377dfa7bab23a798ca1fa0923bcd4d4ef2184d85.sol,StarbaseEarlyPurchaseAmendment,contract StarbaseEarlyPurchaseAmendment { event EarlyPurchaseInvalidated(uint256 epIdx); event EarlyPurchaseAmended(uint256 epIdx); AbstractStarbaseCrowdsale public starbaseCrowdsale; StarbaseEarlyPurchase public starbaseEarlyPurchase; address public owner; uint256[] public invalidEarlyPurchaseIndexes; uint256[] public amendedEarlyPurchaseIndexes; mapping (uint256 => StarbaseEarlyPurchase.EarlyPurchase) public amendedEarlyPurchases; modifier noEther() { require(msg.value == 0); _; },1
0x561eac93c92360949ab1f1403323e6db345cbf31.sol,BANK_SAFE,contract BANK_SAFE { mapping (address=>uint256) public balances; uint public MinSum; LogFile Log; bool intitalized; function SetMinSum(uint _val) public { if(intitalized)throw; MinSum = _val; },1
0x3a715f7ee68d8d7b105f9cabd972f76cb8ea0710.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 30153600; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x5555A8C016F5D2948e27BAe7633Deea24b552FC1; }",1
0x286bbee3f20f1702e707e58d33dc28a69e7efd4e.sol,Contract,contract Contract is Controller { using SafeMath for uint256; struct Contributor { uint256 balance; uint256 fee; uint8 rounds; bool whitelisted; },1
0x4145492ad5039b802bd7e58098c8d71706a2cd14.sol,ElepigCrowdsale,"contract ElepigCrowdsale is CappedCrowdsale, RefundableCrowdsale, ControlledAccess { using SafeMath for uint256; enum CrowdsaleStage { PreICO, ICO1, ICO2, ICO3, ICO4 }",1
0xec841c878435ba4f28bf305a00c1483db0d96a20.sol,Events,contract Events { DBInterface public database; constructor(address _database) public{ database = DBInterface(_database); },1
0xdbe13bf528ca21bb6c306539109c21a304191f72.sol,HISToken,contract HISToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 200000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0x3fd30f3e1fbf4f3ea6bdf3e3bb11826266708869.sol,AgroTechFarmCrowdsale,"contract AgroTechFarmCrowdsale is Ownable { using SafeMath for uint; uint8 public decimals = 18; AgroTechFarmToken public token; uint256 public constant SUPPLY_FOR_SALE = 3250000 * (10 ** uint(decimals)); uint256 public constant SUPPLY_FOR_RESERVE = 500000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_MARKETING = 350000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_TEAM = 300000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_REFERAL = 250000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_ADVISORSL = 150000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_PARTNERSHIPS = 100000 * (10 ** uint256(decimals)); uint256 public constant SUPPLY_FOR_BOOUNTY = 100000 * (10 ** uint256(decimals)); address public multisig; uint public rate; uint public start; uint public end; bool public tokenSpread = false; uint public softcap; enum State { Active, Refunding, Closed }",1
0x655f1cb6616d7f0550007498113e72d7d5c5d4bb.sol,MedalClaim,"contract MedalClaim is AccessControl, SafeMath { address public angelCardDataContract = 0x6D2E76213615925c5fc436565B5ee788Ee0E86DC; address public petCardDataContract = 0xB340686da996b8B3d486b4D27E38E38500A9E926; address public accessoryDataContract = 0x466c44812835f57b736ef9F63582b8a6693A14D0; address public leaderboardDataContract = 0x9A1C755305c6fbf361B4856c9b6b6Bbfe3aCE738; address public medalDataContract = 0x33A104dCBEd81961701900c06fD14587C908EAa3; event EventMedalSuccessful(address owner,uint64 Medal); struct Angel { uint64 angelId; uint8 angelCardSeriesId; address owner; uint16 battlePower; uint8 aura; uint16 experience; }",1
0x6d0a44fb6a416da6efe1c192560be1bccd01f6be.sol,PresaleMarket,contract PresaleMarket is PausableSimple { struct Auction { address seller; uint256 price; },1
0x3fbe0c07b2e5edc9aaa88017c924d1aeff6a719b.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint maxContractBalance; uint contributionCap; uint public feePct; address public receiverAddress; uint constant public contributionMin = 100000000000000000; uint constant public maxGasPrice = 50000000000; WhiteList constant public whitelistContract = WhiteList(0xf6E386FA4794B58350e7B4Cb32B6f86Fb0F357d4); bool whitelistIsActive = true; uint public nextCapTime; uint public nextContributionCap; uint public addressChangeBlock; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { uint ethRefund; uint balance; uint cap; mapping (address => uint) tokensClaimed; },1
0x211f01e59b425253c0a0e9a7bf612605b42ce82c.sol,Kleros,"contract Kleros is Arbitrator, ApproveAndCallFallBack { Pinakion public pinakion; uint public constant NON_PAYABLE_AMOUNT = (2**256 - 2) / 2; RNG public rng; uint public arbitrationFeePerJuror = 0.05 ether; uint16 public defaultNumberJuror = 3; uint public minActivatedToken = 0.1 * 1e18; uint[5] public timePerPeriod; uint public alpha = 2000; uint constant ALPHA_DIVISOR = 1e4; uint public maxAppeals = 5; address public governor; uint public session = 1; uint public lastPeriodChange; uint public segmentSize; uint public rnBlock; uint public randomNumber; enum Period { Activation, Draw, Vote, Appeal, Execution }",1
0x01c91a1b352a2903bc8378e5f645c9bc8685029e.sol,ARPMidTermHolding,contract ARPMidTermHolding { using SafeERC20 for ERC20; using SafeMath for uint256; using Math for uint256; uint256 public constant DEPOSIT_PERIOD = 31 days; uint256 public constant WITHDRAWAL_DELAY = 240 days; uint256 public constant DRAIN_DELAY = 1080 days; uint256 public constant BONUS_SCALE = 5; ERC20 public arpToken; address public owner; uint256 public arpDeposited; uint256 public depositStartTime; uint256 public depositStopTime; struct Record { uint256 amount; uint256 timestamp; },1
0xd90f5ebc01914bbd357b754956aafb199f4d1624.sol,Auction,contract AuctionBase is ERC721Holder { using SafeMath for uint256; struct Auction { address seller; uint128 price; uint64 startedAt; },1
0xeaba6368d6fa9ed06e569ba5c57f584a329a5152.sol,FlyDropToken,"contract FlyDropToken is Claimable { using SafeMath for uint256; ERC20 internal erc20tk; bytes[] internal approveRecords; event ReceiveApproval(address _from, uint256 _value, address _token, bytes _extraData); function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public { erc20tk = ERC20(_token); require(erc20tk.transferFrom(_from, this, _value)); approveRecords.push(_extraData); ReceiveApproval(_from, _value, _token, _extraData); }",1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDView,"contract BitSTDView { BitSTDLogic private logic; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function balanceOf(address add)constant public returns (uint256) { return logic.balanceOf(add); }",1
0x019e41a2acdffafc0303e840fbd7934234e68f45.sol,contractDeployer,"contract contractDeployer is Ownable { event ContractCreated(address newAddress); address public tokenAddr; uint public tokenFee; uint public crowdsaleFee; uint public multisendFee; ERC20 token; cDeployer cdep; tDeployer tdep; function setUp(address _token, address _cdep, address _tdep) public onlyOwner { tokenAddr = _token; token = ERC20(tokenAddr); cdep = cDeployer(_cdep); tdep = tDeployer(_tdep); }",1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDView,"contract BitSTDView { BitSTDLogic private logic; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function balanceOf(address add)constant public returns (uint256) { return logic.balanceOf(add); }",1
0x3a2fd07ec2ad6f355f93af695a7cf858f5967b78.sol,MTVote,contract MTVote is Ownable { address public TVTokenAddress; address public TVCrowdsaleAddress; address public manager; address public wallet; address internal checkAndBuySender; bytes4 constant TOKEN_RECEIVED = bytes4(keccak256()); bool pause = false; mapping(uint => uint) public targets; uint public targetIdsSize = 0; uint[] public targetIds; modifier onlyOwnerOrManager() { require(msg.sender == owner || manager == msg.sender); _; },1
0x36cddd1281258e4373ad313a995272f525cc4e63.sol,CoinoorCrowdsale,"contract CoinoorCrowdsale { address public beneficiary; address public creator; address public marketing; address public bounty; address public confirmedBy; uint256 public maxSupply = 65000000 * 10**8; uint256 public minAcceptedAmount = 40 finney; uint256 public ratePreICO = 450; uint256 public rateWaiting = 0; uint256 public rateAngelDay = 420; uint256 public rateFirstWeek = 390; uint256 public rateSecondWeek = 375; uint256 public rateThirdWeek = 360; uint256 public rateLastWeek = 330; uint256 public ratePreICOEnd = 10 days; uint256 public rateWaitingEnd = 20 days; uint256 public rateAngelDayEnd = 21 days; uint256 public rateFirstWeekEnd = 28 days; uint256 public rateSecondWeekEnd = 35 days; uint256 public rateThirdWeekEnd = 42 days; uint256 public rateLastWeekEnd = 49 days; enum Stages { Deploying, InProgress, Ended }",1
0x6faff25ef78e39c518687b0dd19113f9b29ac562.sol,ETHedgeToken,contract ETHedgeToken { modifier onlyBagholders { require(myTokens() > 0); _; },1
0x6d68593274bbca4fea0ac29ce7c36fc107e2f7e8.sol,STEPSToken,contract STEPSToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 5000000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0x284b0f2f49d072836db87dd25d0623cd2f622bb1.sol,DesTokenSale,"contract DesTokenSale is Haltable { using SafeMath for uint; string public name = ; DesToken public token; address public beneficiary; uint public tokensSoldTotal = 0; uint public weiRaisedTotal = 0; uint public investorCount = 0; uint public tokensSelling = 0; uint public tokenPrice = 0; uint public purchaseLimit = 0; event NewContribution(address indexed holder, uint256 tokenAmount, uint256 etherAmount); function DesTokenSale( address _token, address _beneficiary ) { token = DesToken(_token); beneficiary = _beneficiary; }",1
0x4cb200957a11cbff512b4752e6ee38c9253fdd54.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x0e6e19549a89c9bec84b5b632cd1674f8e066d06.sol,EtheremonAdventureItem,"contract EtheremonAdventureItem is NFTStandard(, ), BasicAccessControl { uint constant public MAX_OWNER_PERS_SITE = 10; uint constant public MAX_SITE_ID = 108; uint constant public MAX_SITE_TOKEN_ID = 1080; address public adventureHandler; struct Item { uint classId; uint value; }",1
0x39e8082b00c9f19ebf553e40feb7cf8459acc693.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }",1
0x6a25216f75d7ee83d06e5fc6b96bcd52233bc69b.sol,MeltingContract,"contract MeltingContract is Owned{ address XaurumAddress; uint public XaurumAmountMelted; uint public GoldAmountMelted; event MeltDone(uint xaurAmount, uint goldAmount); function MeltingContract() public { XaurumAddress = 0x4DF812F6064def1e5e029f1ca858777CC98D2D81; }",1
0xec841c878435ba4f28bf305a00c1483db0d96a20.sol,Events,contract Events { DBInterface public database; constructor(address _database) public{ database = DBInterface(_database); },1
0x5a6d9a69408ce19df15eb40347ded3028a77fcca.sol,EthicHubLending,"contract EthicHubLending is EthicHubBase, Ownable, Pausable { using SafeMath for uint256; enum LendingState { Uninitialized, AcceptingContributions, ExchangingToFiat, AwaitingReturn, ProjectNotFunded, ContributionReturned, Default }",1
0x35d672846d18e8a8ca6e036cb85828d38c9d7fa0.sol,UniswapWrapper,contract UniswapWrapper is Ownable{ address public wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; function() public payable{},1
0xd90f5ebc01914bbd357b754956aafb199f4d1624.sol,Auction,contract AuctionBase is ERC721Holder { using SafeMath for uint256; struct Auction { address seller; uint128 price; uint64 startedAt; },1
0x6e9aa27afa93a52b219a3f091c7d600ad32dcc7c.sol,ADTSend1,"contract ADTSend1 { Token public token; event TransferToken(address indexed to, uint256 value); event TransferFromToken(address indexed from,address indexed to, uint256 value); uint i=0; uint256 samount=0; function adTransfer(address source, address[] recipents, uint256[] amount,uint decimals) public { token=Token(source); for(i=0;i<recipents.length;i++) { samount=amount[i]; token.transfer(recipents[i],amount[i]*(10**decimals)); emit TransferToken(recipents[i],samount); }",1
0x74ceda99c44da280f2fd8ea8b5dd43f8b66912a8.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; },1
0x4cb200957a11cbff512b4752e6ee38c9253fdd54.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x18dc28340ddde25fa8c3b51f5d6a82b1706c8e20.sol,WitnessJury,contract WitnessJury is SafeMath { mapping(address => uint) public balances; uint public limit = 10 ** 16; uint public numWitnessesBeforeLimit = 100; uint public totalBalance; uint public numWitnesses; uint public blockPeriod = 6000; uint public desiredWitnesses = 2; uint public desiredJurors = 3; uint public penalty = 50 * (10 ** 16); address public token; mapping(uint => Request) public requests; uint public numRequests; mapping(uint => uint) public requestsPerBlockGroup; uint public drmVolumeCap = 10000; uint public drmMinFee = 25 * (10 ** 16); uint public drmMaxFee = 50 * (10 ** 16); mapping(uint => bool) public juryNeeded; mapping(uint => mapping(address => bool)) public juryVoted; mapping(uint => uint) public juryYesCount; mapping(uint => uint) public juryNoCount; mapping(uint => address[]) public juryYesVoters; mapping(uint => address[]) public juryNoVoters; struct Request { string key; address witness1; address witness2; string answer1; string answer2; uint winner1; uint winner2; uint fee; address challenge; uint blockNumber; },1
0x3325e30f4326f17bdd79146db0a3835175f0e982.sol,SAMIToken,contract SAMIToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000000000000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function SAMIToken () { owner = msg.sender; },1
0x089a6d83282fb8988a656189f1e7a73fa6c1cac2.sol,ProspectorsGoldToken,"contract ProspectorsGoldToken is TokenBase, Owned, Migrable { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; address private game_address = 0xb1; uint public constant game_allocation = 110000000 * WAD; uint public constant dev_allocation = 45000000 * WAD; uint public constant crowdfunding_allocation = 60000000 * WAD; uint public constant bounty_allocation = 500000 * WAD; uint public constant presale_allocation = 4500000 * WAD; bool public locked = true; address public bounty; address public prospectors_dev_allocation; ProspectorsCrowdsale public crowdsale; function ProspectorsGoldToken() { _supply = 220000000 * WAD; _balances[this] = _supply; mint_for(game_address, game_allocation); }",1
0x6b0a768e6a4c3ca41417c8eabdeef36dcadba25d.sol,EtheremonAdventureItem,"contract EtheremonAdventureItem is NFTStandard(, ), BasicAccessControl { uint constant public MAX_OWNER_PERS_SITE = 10; uint constant public MAX_SITE_ID = 108; uint constant public MAX_SITE_TOKEN_ID = 1080; address public adventureHandler; struct Item { uint classId; uint value; }",1
0x28f1135e43e61ebf303c8f1f9beef4f6a00dcb34.sol,XC,contract XCPlugin is XCPluginInterface { struct Admin { bool status; bytes32 platformName; bytes32 tokenSymbol; address account; string version; },1
0x271a0b465d5b453bb835afd2d671c76b2b76900e.sol,ClockAuction,"contract ClockAuctionBase is Withdrawable, Pausable { struct Auction { address _contract; address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; }",1
0xed6cd75aac7db5abbf382673dfe76e27c7399150.sol,VIPSToken,contract VIPSToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 60000000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function VIPSToken () { owner = msg.sender; },1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDView,"contract BitSTDView { BitSTDLogic private logic; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function balanceOf(address add)constant public returns (uint256) { return logic.balanceOf(add); }",1
0x6593a7140f3718efff638b72a9b6083db47ce0d2.sol,Crowdsale,"contract Crowdsale is GuidedByRoles, ERC20Provider{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 90 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x6fa883afde9bc8d9bec0fc7bff25db3c71864402.sol,CryptoProgramFactory,contract CryptoProgramFactory { using SafeMath for uint256; address public administrator; uint256 private BASE_PRICE = 0.1 ether; uint256 private BASE_TIME = 4 hours; MemoryFactoryInterface public Memory; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; uint256 public miningWarDeadline; mapping(uint256 => Factory) public factories; mapping(address => bool) public miniGames; struct Factory { uint256 level; uint256 crystals; uint256 programPriceByCrystals; uint256 programPriceByDarkCrystals; uint256 programValue; uint256 eth; uint256 time; },1
0x1eb0d4794d4067ed004c9d55ff6eb50620b27c58.sol,ProspectorsCrowdsale,"contract ProspectorsCrowdsale is Owned, DSMath { ProspectorsGoldToken public token; address public dev_multisig; uint public total_raised; uint public contributors_count = 0; uint public constant start_time = 1502377200; uint public constant end_time = 1505055600; uint public constant bonus_amount = 10000000 * 10**18; uint public constant start_amount = 60000000 * 10**18; uint public constant price = 0.0005 * 10**18; uint public constant bonus_price = 0.0004 * 10**18; uint public constant goal = 2000 ether; bool private closed = false; mapping(address => uint) funded; modifier in_time { if (time() < start_time || time() > end_time) revert(); _; }",1
0x0114289efe38186b732d12c07a1ce4341e266513.sol,PreICO,"contract PreICO is ReentrancyGuard, Ownable, Stateful { using SafeMath for uint256; DLH public token; address public wallet; uint256 public startPreICOTime; uint256 public endPreICOTime; uint256 public rate; uint256 public priceUSD; uint256 public centRaised; uint256 public minimumInvest; uint256 public softCapPreSale; uint256 public hardCapPreSale; uint256 public hardCapPrivate; address public oracle; address public manager; mapping(address => uint) public balances; mapping(address => uint) public balancesInCent; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PreICO( address _wallet, address _token, uint256 _priceUSD, uint256 _minimumInvest) public { require(_priceUSD != 0); require(_wallet != address(0)); require(_token != address(0)); priceUSD = _priceUSD; rate = 250000000000000000; wallet = _wallet; token = DLH(_token); hardCapPrivate = 40000000; minimumInvest = _minimumInvest; }",1
0x0111ac7e9425c891f935c4ce54cf16db7c14b7db.sol,ChainbreakersItemsERC721,"contract ChainbreakersItemsERC721 is ERC721Token(, ), BasicAccessControl, randomRange { address proxyRegistryAddress; using SafeMath for uint256; using strings for *; uint256 public totalItems; uint256 public totalItemClass; uint256 public totalTokens; uint8 public currentGen; string _baseURI = ""http: uint public presaleStart = 1541073600; address private lastMinter; ItemClass[] private globalClasses; mapping(uint256 => ItemData) public tokenToData; mapping(uint256 => ItemClass) public classIdToClass; struct ItemClass { uint256 classId; string name; uint16 amount; string hostfile; uint16 minLevel; uint16 rarity; uint16 weapon; uint[] category; uint[] statsMin; uint[] statsMax; string desc; uint256 total; uint price; bool active; }",1
0x548f7581e85b473da466ef9edbe85c5226eaa3b2.sol,ListingsERC20,contract ListingsERC20 is Ownable { using SafeMath for uint256; struct Listing { address seller; address tokenContractAddress; uint256 price; uint256 allowance; uint256 dateStarts; uint256 dateEnds; },1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,AccountRegistry,"contract AccountRegistry is AccountRegistryInterface, TokenRescue { uint256 constant public registrationDeposit = 1 finney; uint256 constant public proposalCensorshipFee = 50 finney; address constant public burn = 0x000000003Ffc15cd9eA076d7ec40B8f516367Ca1; Vote public constant token = Vote(0x000000002647e16d9BaB9e46604D75591D289277); uint8 constant UNCONTACTED = 0; uint8 constant PROPOSER = 1; uint8 constant VOTER = 2; uint8 constant PENDING_PROPOSAL = 4; uint8 constant PROPOSAL = 8; uint8 constant PENDING_CABAL = 16; uint8 constant CABAL = 32; uint8 constant BOARD = 64; struct Account { uint256 lastAccess; uint8 membership; address appointer; address denouncer; address voucher; address devoucher; }",1
0xcefa3e88393cf17c9b4dc6c9fe5357dfae8036d6.sol,Registry,contract Registry is Ownable { struct ContributorData { bool isActive; uint contributionETH; uint contributionUSD; uint tokensIssued; uint quoteUSD; uint contributionRNTB; },1
0xbc97f1508fdeb0a63b25f3a4806b62ef5370e8ab.sol,CryptoBeginnerQuest,contract CryptoBeginnerQuest { using SafeMath for uint256; address private administrator; address public miningWarAddress; CryptoEngineerInterface public Engineer; CryptoDepositInterface public Deposit; CryptoMiningWarInterface public MiningWar; CryptoAirdropGameInterface public AirdropGame; CryptoBossWannaCryInterface public BossWannaCry; CryptoArenaInterface public Arena; uint256 private miningWarDeadline; uint256 private miningWarRound; mapping(address => Player) private players; mapping(address => MinerQuest) private minerQuests; mapping(address => EngineerQuest) private engineerQuests; mapping(address => DepositQuest) private depositQuests; mapping(address => JoinAirdropQuest) private joinAirdropQuests; mapping(address => AtkBossQuest) private atkBossQuests; mapping(address => AtkPlayerQuest) private atkPlayerQuests; mapping(address => BoosterQuest) private boosterQuests; mapping(address => RedbullQuest) private redbullQuests; struct Player { uint256 miningWarRound; uint256 currentQuest; },1
0xe31d93278aa45075f06376603d37adef06b37b5c.sol,DSStop,"contract DSStop is DSNote, DSAuth { bool public stopped; modifier stoppable { require(!stopped); _; }",1
0xcf106b9644eb97deb5b78ab22da160ffca67a448.sol,BaseWallet,"contract BaseWallet { address public implementation; address public owner; mapping (address => bool) public authorised; mapping (bytes4 => address) public enabled; uint public modules; event AuthorisedModule(address indexed module, bool value); event EnabledStaticCall(address indexed module, bytes4 indexed method); event Invoked(address indexed module, address indexed target, uint indexed value, bytes data); event Received(uint indexed value, address indexed sender, bytes data); event OwnerChanged(address owner); modifier moduleOnly { require(authorised[msg.sender], ); _; }",1
0xbc97f1508fdeb0a63b25f3a4806b62ef5370e8ab.sol,CryptoBeginnerQuest,contract CryptoBeginnerQuest { using SafeMath for uint256; address private administrator; address public miningWarAddress; CryptoEngineerInterface public Engineer; CryptoDepositInterface public Deposit; CryptoMiningWarInterface public MiningWar; CryptoAirdropGameInterface public AirdropGame; CryptoBossWannaCryInterface public BossWannaCry; CryptoArenaInterface public Arena; uint256 private miningWarDeadline; uint256 private miningWarRound; mapping(address => Player) private players; mapping(address => MinerQuest) private minerQuests; mapping(address => EngineerQuest) private engineerQuests; mapping(address => DepositQuest) private depositQuests; mapping(address => JoinAirdropQuest) private joinAirdropQuests; mapping(address => AtkBossQuest) private atkBossQuests; mapping(address => AtkPlayerQuest) private atkPlayerQuests; mapping(address => BoosterQuest) private boosterQuests; mapping(address => RedbullQuest) private redbullQuests; struct Player { uint256 miningWarRound; uint256 currentQuest; },1
0x302eb72befc8af539432ec32c39423525412748f.sol,ZRSToken,contract ZRSToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 24000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function ZRSToken () { owner = msg.sender; },1
0x35fd00d47202b1b2158dba75e7cc8f71b068c256.sol,TokenVesting,contract TokenVesting is Ownable { using SafeMath for uint; struct TokenHolder { uint weiReceived; uint tokensToSend; bool refunded; uint releasedAmount; bool revoked; },1
0x456c4350eefd17315713b265d8be8b6063a5fab8.sol,Crowdsale,"contract Crowdsale is Pausable, PullPayment { using SafeMath for uint; struct Backer { uint weiReceived; uint coinSent; }",1
0xec2e5c8d51fdd54fef83db8300399a3c2e167922.sol,CrowdsaleToken,"contract CrowdsaleToken is Manageable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public totalSupply; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; mapping (address => uint256) public releaseTime; bool public released; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Mint(address indexed _to, uint256 _value); event ReleaseTimeChanged(address indexed _owner, uint256 _oldReleaseTime, uint256 _newReleaseTime); event ReleasedChanged(bool _oldReleased, bool _newReleased); modifier canTransfer(address _from) { if (releaseTime[_from] == 0) { require(released); }",1
0xf0ef703a04cf96212031b51d373e8469687f308e.sol,ESCToken,contract ESCToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function ESCToken () { owner = msg.sender; },1
0xc81ec8a2a711e96d977a48252ac694e1d4b5719d.sol,GTCoin,"contract GTCoin is Token(, , 18, 100000000000000000000000000), ERC20, ERC223 { using SafeMath for uint; function GTCoin() public { _balanceOf[msg.sender] = _totalSupply; }",1
0x3aa927a97594c3ab7d7bf0d47c71c3877d1de4a1.sol,MatchingMarket,"contract MatchingMarket is MatchingEvents, ExpiringMarket, DSNote { bool public buyEnabled = true; bool public matchingEnabled = true; struct sortInfo { uint next; uint prev; }",1
0xce5dbd884305a5716460dccffa63888fc9bfaa72.sol,FreezeTokensWallet,contract FreezeTokensWallet is Ownable { using SafeMath for uint256; MintableToken public token; bool public started; uint public startLockPeriod = 180 days; uint public period = 360 days; uint public duration = 90 days; uint public startUnlock; uint public retrievedTokens; uint public startBalance; modifier notStarted() { require(!started); _; },1
0x27369e8f43f44c26853a46da7e6cb52d203b59ce.sol,AgileICOWithAssistance,contract AgileICOWithAssistance { using SafeMath for uint; address public operator; address public juryOperator; address public projectWallet; address public arbitrationAddress; address public juryOnlineWallet; bool public requireTokens; uint public promisedTokens; uint public etherAllowance; uint public jotAllowance; uint public commissionOnInvestmentJot; uint public commissionOnInvestmentEth; uint public percentForFuture; uint public rate = 1; address public currentCycleAddress; uint public currentCycleNumber; uint public currentFundingRound; uint public minimumInvestment; uint public lastRateChange; Token public token; struct Offer { uint etherAmount; uint tokenAmount; bool accepted; uint numberOfDeals; },1
0xd41ee3317467ab60109d76d6360807777c10afd7.sol,ZJLTTokenVault,"contract ZJLTTokenVault is Ownable { using SafeMath for uint256; address public teamWallet = 0x1fd4C9206715703c209651c215f506555a40b7C0; uint256 public startLockTime; uint256 public totalAlloc = 25 * 10 ** 18; uint256 public perValue = 20833333 * 10 ** 11; uint256 public timeLockPeriod = 30 days; uint256 public teamVestingStages = 12; uint256 public latestUnlockStage = 0; mapping (address => uint256) public lockBalance; ZJLTToken public token; bool public isExec; event Alloc(address _wallet, uint256 _value); event Claim(address _wallet, uint256 _value); modifier unLocked { uint256 nextStage = latestUnlockStage.add(1); require(startLockTime > 0 && now >= startLockTime.add(nextStage.mul(timeLockPeriod))); _; }",1
0x01d6208f95cf2292c350fc8bb1b1f29230352675.sol,DepositWithdraw,"contract DepositWithdraw is Claimable, Withdrawable { using SafeMath for uint256; struct TransferRecord { uint256 timeStamp; address account; uint256 value; }",1
0x21ad0028fea5fafa55b9b60e9c065db9f1c0616e.sol,LikeCrowdsale,"contract LikeCrowdsale is HasOperator { using SafeMath for uint256; LikeCoin public like = LikeCoin(0x0); uint public start = 0; uint public end = 0; uint256 public coinsPerEth = 0; mapping (address => bool) public kycDone; bool finalized = false; event PriceChanged(uint256 _newPrice); event AddPrivateFund(address indexed _addr, uint256 _value); event RegisterKYC(address indexed _addr); event Purchase(address indexed _addr, uint256 _ethers, uint256 _coins); event LikeTransfer(address indexed _to, uint256 _value); event Finalize(); function LikeCrowdsale(address _likeAddr, uint _start, uint _end, uint256 _coinsPerEth) public { require(_coinsPerEth != 0); require(now < _start); require(_start < _end); owner = msg.sender; like = LikeCoin(_likeAddr); start = _start; end = _end; coinsPerEth = _coinsPerEth; }",1
0x20009a909fb6f7951f594bc2daa69b5bd539d672.sol,MOOSToken,contract MOOSToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function MOOSToken () { owner = msg.sender; },1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,LockinManager,contract LockinManager { using SafeMath for uint256; struct Lock { uint256 amount; uint256 unlockDate; uint256 lockedFor; },1
0x0e33ca464b1c76a384039eb1b7e9dc3b0416b5ae.sol,NamiCrowdSale,"contract NamiCrowdSale { using SafeMath for uint256; function NamiCrowdSale(address _escrow, address _namiMultiSigWallet, address _namiPresale) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; namiPresale = _namiPresale; }",1
0x8d46facfb889740a345755e624942257dc87b5ac.sol,UpgradeableToken,"contract UpgradeableToken is Owner, Token { address public migrationAgent; event Upgrade(address indexed from, address indexed to, uint256 value); event UpgradeAgentSet(address agent); function migrate() public { require(migrationAgent != 0); uint value = balances[msg.sender]; balances[msg.sender] = balances[msg.sender].sub(value); totalSupply = totalSupply.sub(value); MigrationAgent(migrationAgent).migrateFrom(msg.sender, value); emit Upgrade(msg.sender, migrationAgent, value); }",1
0xb3b3fa00a534ab0c7437bc5e9f4f97f1f98b930d.sol,LuckyCoin,"contract LuckyCoin is Coinevents{ using SafeMath for *; using NameFilter for string; string constant public name = ; string constant public symbol = ; uint256 constant private rndGap_ = 2 hours; uint256 ticketstotal_ = 1500; uint256 grouptotal_ = 250; uint256 jackpot = 10 ether; uint256 public rID_= 0; uint256 _headtickets = 500; bool public activated_ = false; address community_addr = 0x180A14aF38384dc15Ce96cbcabCfC8F47794AC3E; address prize_addr = 0x180A14aF38384dc15Ce96cbcabCfC8F47794AC3E; address activate_addr2 = 0x180A14aF38384dc15Ce96cbcabCfC8F47794AC3E; address activate_addr1 = 0x6C7DFE3c255a098Ea031f334436DD50345cFC737; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xc87a693dbba31aefb9457683b7d245dad756db88); mapping (uint256 => Coindatasets.Round) public round_; event LogbuyNums(address addr, uint begin, uint end); mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => Coindatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => Coindatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256=>mapping(uint=> mapping(uint=>uint))) orders; constructor() public{ }",1
0x25d3b337e17ad34dbc8cb97d1a724545d90478fa.sol,AirdropiRide,contract AirdropiRide { Token public tokenReward; address public creator; address public owner = 0xd430B6C9706345760D94c4A8A14Cfa0164B04167; uint256 public startDate; uint256 public amount; modifier isCreator() { require(msg.sender == creator); _; },1
0x48ec79ffdd733e72046533baafcc19864a976da0.sol,Richer3D,"contract Richer3D { using SafeMath for *; string constant public name = ; string constant public symbol = ; address constant private sysAdminAddress = 0x4A3913ce9e8882b418a0Be5A43d2C319c3F0a7Bd; address constant private sysInviterAddress = 0xC5E41EC7fa56C0656Bc6d7371a8706Eb9dfcBF61; address constant private sysDevelopAddress = 0xCf3A25b73A493F96C15c8198319F0218aE8cAA4A; address constant private p3dInviterAddress = 0x82Fc4514968b0c5FdDfA97ed005A01843d0E117d; uint256 constant cycleTime = 20 minutes; uint256 private roundNumber; uint256 private dayNumber; uint256 private totalPlayerNumber; uint256 private platformBalance; mapping(uint256=>DataModal.RoundInfo) private rInfoXrID; mapping(address=>DataModal.PlayerInfo) private pInfoXpAdd; mapping(address=>uint256) private pIDXpAdd; mapping(uint256=>address) private pAddXpID; HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe); mapping(uint256=>uint256) private p3dDividesXroundID; event newPlayerJoinGameEvent(address indexed _address,uint256 indexed _amount,bool indexed _JoinWithEth,uint256 _timestamp); event calculateTargetEvent(uint256 indexed _roundID); constructor() public { dayNumber = 1; }",1
0x447b4ccab1b370afbe5ae2e68c0b700be913a585.sol,AgileICO,contract AgileICO { using SafeMath for uint; address public operator; address public juryOperator; address public projectWallet; address public arbitrationAddress; address public juryOnlineWallet; bool public requireTokens; uint public promisedTokens; uint public etherAllowance; uint public jotAllowance; uint public commissionOnInvestmentJot; uint public commissionOnInvestmentEth; uint public percentForFuture; uint public rate = 1; address public currentCycleAddress; uint public currentCycleNumber; uint public currentFundingRound; uint public minimumInvestment; uint public lastRateChange; Token public token; struct Offer { uint etherAmount; uint tokenAmount; bool accepted; uint numberOfDeals; },1
0x1d1ff336189f16fcb5aea6f00398c06bec5fd0cc.sol,casinoBank,"contract casinoBank is owned, safeMath{ uint public playerBalance; mapping(address=>uint) public balanceOf; mapping(address=>uint) public withdrawAfter; uint public gasPrice = 20; token edg; uint public closeAt; event Deposit(address _player, uint _numTokens, bool _chargeGas); event Withdrawal(address _player, address _receiver, uint _numTokens); function casinoBank(address tokenContract) public{ edg = token(tokenContract); }",1
0xc7bd5dac314a67a375a0347d72797c2ea1f1a672.sol,KlownGasDrop,contract KlownGasDrop { mapping(address => bool) public receivers; mapping ( address => uint256 ) public balances; uint256 amountToClaim = 50000000; uint256 public totalSent = 0; address _owner; address whoSent; uint256 dappBalance; uint public brpt = 0; uint public brpt1 = 0; IERC20 currentToken ; modifier onlyOwner() { require(msg.sender == _owner); _; },1
0xc767b1cec507f1584469e8efe1a94ad4c75e02ed.sol,PremiumFactories,contract PremiumFactories { Bankroll constant bankroll = Bankroll(0x66a9f1e53173de33bec727ef76afa84956ae1b25); address owner; constructor() public { owner = msg.sender; },1
0x21ad0028fea5fafa55b9b60e9c065db9f1c0616e.sol,LikeCrowdsale,"contract LikeCrowdsale is HasOperator { using SafeMath for uint256; LikeCoin public like = LikeCoin(0x0); uint public start = 0; uint public end = 0; uint256 public coinsPerEth = 0; mapping (address => bool) public kycDone; bool finalized = false; event PriceChanged(uint256 _newPrice); event AddPrivateFund(address indexed _addr, uint256 _value); event RegisterKYC(address indexed _addr); event Purchase(address indexed _addr, uint256 _ethers, uint256 _coins); event LikeTransfer(address indexed _to, uint256 _value); event Finalize(); function LikeCrowdsale(address _likeAddr, uint _start, uint _end, uint256 _coinsPerEth) public { require(_coinsPerEth != 0); require(now < _start); require(_start < _end); owner = msg.sender; like = LikeCoin(_likeAddr); start = _start; end = _end; coinsPerEth = _coinsPerEth; }",1
0xf0ef703a04cf96212031b51d373e8469687f308e.sol,ESCToken,contract ESCToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function ESCToken () { owner = msg.sender; },1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,LockinManager,contract LockinManager { using SafeMath for uint256; struct Lock { uint256 amount; uint256 unlockDate; uint256 lockedFor; },1
0x4cd988afbad37289baaf53c13e98e2bd46aaea8c.sol,DSStop,"contract DSStop is DSAuth, DSNote { bool public stopped; modifier stoppable { assert (!stopped); _; }",1
0x6e9aa27afa93a52b219a3f091c7d600ad32dcc7c.sol,ADTSend1,"contract ADTSend1 { Token public token; event TransferToken(address indexed to, uint256 value); event TransferFromToken(address indexed from,address indexed to, uint256 value); uint i=0; uint256 samount=0; function adTransfer(address source, address[] recipents, uint256[] amount,uint decimals) public { token=Token(source); for(i=0;i<recipents.length;i++) { samount=amount[i]; token.transfer(recipents[i],amount[i]*(10**decimals)); emit TransferToken(recipents[i],samount); }",1
0x6fbc1b8f756f43cfbfd45085380cc375650ff3d6.sol,ZethrSnap,contract ZethrSnap { struct SnapEntry { uint blockNumber; uint profit; },1
0x18e35785cf570301b0001212e109a6c0217cfb73.sol,SujiToken,contract SujiToken is Ownable { using SafeMath for uint256; string public name = ; uint8 public decimals = 18; string public symbol = ; uint public totalSupply; address public raindropAddress = 0x0; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; function SujiToken() public { totalSupply = 10000000000 * 10**18; balances[msg.sender] = totalSupply; },1
0x0ce95ef378059f38c5fa21e6d81a5895c0d9911b.sol,Game,contract Game { using GlobalTypes for GlobalTypes.Global; using MarketTypes for MarketTypes.MarketListing; using MissionParametersTypes for MissionParametersTypes.MissionParameters; using GameCommon for GameCommon.LaunchRocketStackFrame; address public m_Owner; AbstractDatabase public m_Database; AbstractGameHidden public m_GameHidden; bool public m_Paused; uint256 constant GlobalCategory = 0; uint256 constant RocketCategory = 1; uint256 constant OwnershipCategory = 2; uint256 constant InventoryCategory = 3; uint256 constant MarketCategory = 4; uint256 constant ProfitFundsCategory = 5; uint256 constant CompetitionFundsCategory = 6; uint256 constant MissionParametersCategory = 7; uint256 constant CompetitionScoresCategory = 8; uint256 constant WithdrawalFundsCategory = 9; uint256 constant ReferralCategory = 10; uint256 constant RocketStockCategory = 11; uint256 constant RocketStockInitializedCategory = 12; address constant NullAddress = 0; uint256 constant MaxCompetitionScores = 10; mapping(uint32 => RocketTypes.StockRocket) m_InitialRockets; modifier OnlyOwner() { require(msg.sender == m_Owner); _; },1
0x509887e0ea70bf8f471a2fb8696979b3abf07650.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward; uint256 public price = 300; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() { wallet = 0xCEf8A431c0f0C512A587ab3f8470586c2dD1D3EB; addressOfTokenUsedAsReward = 0xB4E3362ee28105CD6D99278424d2176c4F3d76cE; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x17a03553719001e05dc19a20f5e82ee76923a985.sol,Auction,contract AuctionBase is ERC721Holder { using SafeMath for uint256; struct Auction { address seller; uint128 price; uint64 startedAt; },1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiCrowdSale,"contract NamiCrowdSale { using SafeMath for uint256; function NamiCrowdSale(address _escrow, address _namiMultiSigWallet, address _namiPresale) public { require(_namiMultiSigWallet != 0x0); escrow = _escrow; namiMultiSigWallet = _namiMultiSigWallet; namiPresale = _namiPresale; }",1
0xc5fc544685efd0e5b6cd57d6133522825828cc19.sol,SatoshiToken,"contract SatoshiToken is ERC20Interface, Owned { using SafeMath for uint; using ExtendedMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply; uint public latestDifficultyPeriodStarted; uint public epochCount; uint public _BLOCKS_PER_READJUSTMENT = 1024; uint public _MINIMUM_TARGET = 2**16; uint public _MAXIMUM_TARGET = 2**234; uint public miningTarget; bytes32 public challengeNumber; uint public rewardEra; uint public maxSupplyForEra; address public lastRewardTo; uint public lastRewardAmount; uint public lastRewardEthBlockNumber; bool locked = false; mapping(bytes32 => bytes32) solutionForChallenge; uint public tokensMinted; address public parentAddress; uint public miningReward; mapping(address => uint) balances; mapping(address => uint) merge_mint_ious; mapping(address => uint) merge_mint_payout_threshold; mapping(address => mapping(address => uint)) allowed; uint public burnPercent; event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber); constructor() public onlyOwner { symbol = ; name = ; decimals = 8; _totalSupply = 10000000 * 10 ** uint(decimals); if(locked) revert(); locked = true; tokensMinted = 0; rewardEra = 0; maxSupplyForEra = _totalSupply.div(2); miningTarget = _MAXIMUM_TARGET; latestDifficultyPeriodStarted = block.number; burnPercent = 20; _startNewMiningEpoch(); parentAddress = 0xB6eD7644C69416d67B522e20bC294A9a9B405B31; balances[owner] = balances[owner].add(tokensMinted); Transfer(address(this), owner, tokensMinted); }",1
0x0193cba9762dfe203a34bd895d0ddf4d876e0f98.sol,UpgradeableToken,"contract UpgradeableToken is Ownable, StandardToken { address public migrationAgent; event Upgrade(address indexed from, address indexed to, uint256 value); event UpgradeAgentSet(address agent); function migrate() public { require(migrationAgent != 0); uint value = balances[msg.sender]; balances[msg.sender] = safeSub(balances[msg.sender], value); totalSupply = safeSub(totalSupply, value); MigrationAgent(migrationAgent).migrateFrom(msg.sender, value); Upgrade(msg.sender, migrationAgent, value); }",1
0x01e0f57c42bf976676ea1daa1b04d69aba6bdaf3.sol,BatchTransferWallet,"contract BatchTransferWallet is Ownable { using SafeMath for uint256; event LogWithdrawal(address indexed receiver, uint amount); function batchTransfer(address _tokenAddress, address[] _investors, uint256[] _tokenAmounts) public { ERC20BasicInterface token = ERC20BasicInterface(_tokenAddress); require(_investors.length == _tokenAmounts.length && _investors.length != 0); uint decimalsForCalc = 10 ** uint256(token.decimals()); for (uint i = 0; i < _investors.length; i++) { require(_tokenAmounts[i] > 0 && _investors[i] != 0x0); _tokenAmounts[i] = _tokenAmounts[i].mul(decimalsForCalc); require(token.transfer(_investors[i], _tokenAmounts[i])); }",1
0xaa652d53909b01c5a6b8e7cd814f9adea18c08f7.sol,TCRSale,"contract TCRSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 10000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; TCRToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDView,"contract BitSTDView { BitSTDLogic private logic; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function balanceOf(address add)constant public returns (uint256) { return logic.balanceOf(add); }",1
0x4c7f666ca30fe548fbdc08b0308927327f08336d.sol,FixedPoolWithBonusTokenDistributionStrategy,contract FixedPoolWithBonusTokenDistributionStrategy is TokenDistributionStrategy { using SafeMath for uint256; uint256 constant MAX_DISCOUNT = 100; struct BonusInterval { uint256 endPeriod; uint256 bonus; },1
0xecff8fc2a19f83fc855618704f38725756dbcae3.sol,OK3D,"contract OK3D is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x5015A6E288FF4AC0c62bf1DA237c24c3Fb849188); address private admin = msg.sender; string constant public name = ; string constant public symbol = ; uint256 private rndExtra_ = 0; uint256 private rndGap_ = 2 minutes; uint256 constant private rndInit_ = 12 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 24 hours; uint256 public airDropPot_; uint256 public airDropTracker_ = 0; uint256 public rID_; mapping (address => uint256) public pIDxAddr_; mapping (bytes32 => uint256) public pIDxName_; mapping (uint256 => F3Ddatasets.Player) public plyr_; mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_; mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; mapping (uint256 => F3Ddatasets.Round) public round_; mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_; mapping (uint256 => F3Ddatasets.TeamFee) public fees_; mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_; constructor() public { fees_[0] = F3Ddatasets.TeamFee(28,10); fees_[1] = F3Ddatasets.TeamFee(36,10); fees_[2] = F3Ddatasets.TeamFee(51,10); fees_[3] = F3Ddatasets.TeamFee(40,10); potSplit_[0] = F3Ddatasets.PotSplit(25,10); potSplit_[1] = F3Ddatasets.PotSplit(25,0); potSplit_[2] = F3Ddatasets.PotSplit(20,20); potSplit_[3] = F3Ddatasets.PotSplit(20,20); activated_ = true; rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; }",1
0x707f0612cbbfa02284e02b0010b4f859bb7308ec.sol,CrowdsaleL,"contract CrowdsaleL{ using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x4498f897505d0e6991edeab24bc7b5727d72de28.sol,RFCICO,"contract RFCICO { using SafeMath for uint256; address public wallet; address public RFC; uint256 public price = 303; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor() public{ wallet = 0x1c46A08C940D9433297646cBa10Bc492c7D53A82; RFC = 0xed1CAa23883345098C7939C44Fb201AA622746aD; tokenReward = token(RFC); }",1
0x479cbe1f6a7fa4d7e304ae983803c46e85ced870.sol,Slaughter3D,contract Slaughter3D { using SafeMath for uint; struct Stage { uint8 numberOfPlayers; uint256 blocknumber; bool finalized; mapping (uint8 => address) slotXplayer; mapping (address => bool) players; mapping (uint8 => address) setMN; },1
0x83686a73638ff46ee1eb5d28ff2179c41d1157aa.sol,ldoh,"contract ldoh is EthereumSmartContract { event onCashbackCode (address indexed hodler, address cashbackcode); event onAffiliateBonus (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onUnlocktoken (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onHoldplatform (address indexed hodler, address indexed tokenAddress, string tokenSymbol, uint256 amount, uint256 endtime); event onAddContractAddress(address indexed contracthodler, bool contractstatus, uint256 _maxcontribution, string _ContractSymbol, uint256 _PercentPermonth, uint256 _HodlingTime); event onHoldplatformsetting(address indexed Tokenairdrop, bool HPM_status, uint256 HPM_divider, uint256 HPM_ratio, uint256 datetime); event onHoldplatformdeposit(uint256 amount, uint256 newbalance, uint256 datetime); event onHoldplatformwithdraw(uint256 amount, uint256 newbalance, uint256 datetime); address public DefaultToken; struct Safe { uint256 id; uint256 amount; uint256 endtime; address user; address tokenAddress; string tokenSymbol; uint256 amountbalance; uint256 cashbackbalance; uint256 lasttime; uint256 percentage; uint256 percentagereceive; uint256 tokenreceive; uint256 lastwithdraw; address referrer; bool cashbackstatus; }",1
0xee68907c93b57d57a1c4d60940ff1b310e18e467.sol,ICOBuyer,"contract ICOBuyer is Ownable { event EtherReceived(address indexed _contributor, uint256 _amount); event EtherWithdrawn(uint256 _amount); event TokensWithdrawn(uint256 _balance); event ICOPurchased(uint256 _amount); event ICOStartBlockChanged(uint256 _icoStartBlock); event ExecutorChanged(address _executor); event CrowdSaleChanged(address _crowdSale); event TokenChanged(address _token); event PurchaseCapChanged(uint256 _purchaseCap); uint256 public icoStartBlock; address public crowdSale; address public executor; uint256 public purchaseCap; modifier onlyExecutorOrOwner() { require((msg.sender == executor) || (msg.sender == owner)); _; }",1
0x18f0cd26c06449d967ca6aef8b5f9d8ee9fd7992.sol,Exch,"contract Exch is SafeMath { address public admin; address public feeAccount; address public accountLevelsAddr; uint public feeMake; uint public feeTake; uint public feeRebate; mapping (address => mapping (address => uint)) public tokens; mapping (address => mapping (bytes32 => bool)) public orders; mapping (address => mapping (bytes32 => uint)) public orderFills; mapping (address => bool) public whiteListERC20; mapping (address => bool) public whiteListERC223; event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user); event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); modifier onlyAdmin() { require(msg.sender==admin); _; }",1
0x4d7edd5f94515b0f35b38f6fb2ea975a20823465.sol,CryptoSprites,contract CryptoSprites is ERC721 { address public owner; address KittyCoreAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; address SaleClockAuctionAddress = 0xb1690C08E213a35Ed9bAb7B318DE14420FB57d8C; address charityAddress = 0xb30cb3b3E03A508Db2A0a3e07BA1297b47bb0fb1; uint public etherForOwner; uint public etherForCharity; uint public ownerCut = 15; uint public charityCut = 15; uint public featurePrice = 10**16; uint public priceMultiplier = 1; uint public priceDivider = 10; modifier onlyOwner { require(msg.sender == owner); _; },1
0x26fb86579e371c7aedc461b2ddef0a8628c93d3b.sol,LockedToken,"contract LockedToken { ERC20Basic public token; address public donor; address public beneficiary; uint256 public releaseTime; bool public revocable; event Claim(address beneficiary, uint256 amount, uint256 releaseTime); event Revoke(address donor, uint256 amount); function LockedToken(ERC20Basic _token, address _donor, address _beneficiary, uint256 _releaseTime, bool _revocable) public { require(_token != address(0)); require(_donor != address(0)); require(_beneficiary != address(0)); require(_releaseTime > now); token = ERC20Basic(_token); donor = _donor; beneficiary = _beneficiary; releaseTime = _releaseTime; revocable = _revocable; }",1
0xeb36a7650ef32f0643d39cf5b7fcefd4319febb9.sol,Arbitration,contract Arbitration is Owned { address public operator; uint public quorum = 3; struct Dispute { address icoRoundAddress; address investorAddress; bool pending; uint timestamp; uint milestone; string reason; uint votesForProject; uint votesForInvestor; mapping(address => bool) voters; },1
0xee91e81927bb047ea0f4b24e43dd5dc0684827a0.sol,BINGToken,contract BINGToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function BINGToken () { owner = msg.sender; },1
0x0e54b1b8ff833b5f2b0d17453d97d340cb7576e4.sol,ERC223Token,"contract ERC223Token is IERC223, SafeMath { mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 35000000 * 10**8; function ERC223Token() { balances[msg.sender] = totalSupply; }",1
0x21ad0028fea5fafa55b9b60e9c065db9f1c0616e.sol,LikeCrowdsale,"contract LikeCrowdsale is HasOperator { using SafeMath for uint256; LikeCoin public like = LikeCoin(0x0); uint public start = 0; uint public end = 0; uint256 public coinsPerEth = 0; mapping (address => bool) public kycDone; bool finalized = false; event PriceChanged(uint256 _newPrice); event AddPrivateFund(address indexed _addr, uint256 _value); event RegisterKYC(address indexed _addr); event Purchase(address indexed _addr, uint256 _ethers, uint256 _coins); event LikeTransfer(address indexed _to, uint256 _value); event Finalize(); function LikeCrowdsale(address _likeAddr, uint _start, uint _end, uint256 _coinsPerEth) public { require(_coinsPerEth != 0); require(now < _start); require(_start < _end); owner = msg.sender; like = LikeCoin(_likeAddr); start = _start; end = _end; coinsPerEth = _coinsPerEth; }",1
0x17a03553719001e05dc19a20f5e82ee76923a985.sol,Auction,contract AuctionBase is ERC721Holder { using SafeMath for uint256; struct Auction { address seller; uint128 price; uint64 startedAt; },1
0x6f123503fc11f4a915e222808349c8aff4d6c3c0.sol,XRXToken,contract XRXToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 5000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0x707f0612cbbfa02284e02b0010b4f859bb7308ec.sol,CrowdsaleL,"contract CrowdsaleL{ using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x00ff9c740bac8cad80f1a3b1c4f20d7ea1c92637.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; address public wallet; address public addressOfTokenUsedAsReward; uint256 public price = 5000; token tokenReward; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() { wallet = 0x5c48597920BF69ec9DA4eFdfCfCd05E10715E5Bd; addressOfTokenUsedAsReward = 0x06Be72C75867bB31E546575cC79317cF82cC4115; tokenReward = token(addressOfTokenUsedAsReward); }",1
0x17e65b46ad1ebfb8f9cacde8e274b377831a1253.sol,BigbomToken,"contract BigbomToken is StandardToken, Ownable { string public constant name = ; string public constant symbol = ; uint public constant decimals = 18; uint public totalSupply = 2000000000 * 1e18; uint public constant founderAmount = 200000000 * 1e18; uint public constant coreStaffAmount = 60000000 * 1e18; uint public constant advisorAmount = 140000000 * 1e18; uint public constant networkGrowthAmount = 600000000 * 1e18; uint public constant reserveAmount = 635000000 * 1e18; uint public constant bountyAmount = 40000000 * 1e18; uint public constant publicSaleAmount = 275000000 * 1e18; address public bbFounderCoreStaffWallet ; address public bbAdvisorWallet; address public bbAirdropWallet; address public bbNetworkGrowthWallet; address public bbReserveWallet; address public bbPublicSaleWallet; uint public saleStartTime; uint public saleEndTime; address public tokenSaleContract; BigbomPrivateSaleList public privateSaleList; mapping (address => bool) public frozenAccount; mapping (address => uint) public frozenTime; mapping (address => uint) public maxAllowedAmount; event FrozenFunds(address target, bool frozen, uint _seconds); function checkMaxAllowed(address target) public constant returns (uint) { var maxAmount = balances[target]; if(target == bbFounderCoreStaffWallet){ maxAmount = 10000000 * 1e18; }",1
0x470142a1834438515b757118f322703aba6e1e05.sol,PolicyPalNetworkAirdrop,contract PolicyPalNetworkAirdrop { struct BountyType { bool twitter; bool signature; },1
0x750c1d91864171d7e1715a6b53ee28c72b8faa09.sol,EthicHubUser,"contract EthicHubUser is Ownable, EthicHubBase { event UserStatusChanged(address target, string profile, bool isRegistered); constructor(address _storageAddress) EthicHubBase(_storageAddress) public { version = 3; }",1
0x56ce81f0ede8716a2f3b6349f805e0f13643c168.sol,TokenVesting,"contract TokenVesting is Ownable { using SafeMath for uint; ERC20 public token; address public receiver; uint256 public startTime; uint256 public cliff; uint256 public totalPeriods; uint256 public timePerPeriod; uint256 public totalTokens; uint256 public tokensClaimed; event VestingFunded(uint256 totalTokens); event TokensClaimed(uint256 tokensClaimed); event VestingKilled(); constructor( address _token, address _receiver, uint256 _startTime, uint256 _cliff, uint256 _totalPeriods, uint256 _timePerPeriod ) public { token = ERC20(_token); receiver = _receiver; startTime = _startTime; cliff = _cliff; totalPeriods = _totalPeriods; timePerPeriod = _timePerPeriod; }",1
0x567b27ae0d0ea4fca292f447d819aa1b366375c4.sol,DadiMaxCapSale,contract DadiMaxCapSale is Ownable { using SafeMath for uint256; StandardToken public token; address[] public saleWallets; struct WhitelistUser { uint index; },1
0x3fd7332ea471e876327926b30bd945773c706133.sol,EtherShrimpFutures,contract EtherShrimpFutures{ using SafeMath for uint; Oasis market; address public dai = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359; address public weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; uint256 public EGGS_TO_HATCH_1SHRIMP=86400; uint256 public STARTING_SHRIMP=300; uint256 internal PSN=10000; uint256 internal PSNH=5000; bool public initialized=false; uint256 public marketEggs; address public ceoAddress; uint256 public numberOfFarmers; mapping (address => uint256) public hatcheryShrimp; mapping (address => uint256) public claimedEggs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; mapping (address => uint256) public lastHatchPrice; address[] farmers; constructor() public{ ceoAddress=msg.sender; market = Oasis(0x14FBCA95be7e99C15Cc2996c6C9d841e54B79425); },1
0xf1a47b728439730e9f83054d7c352575bf13f0b4.sol,RPTCrowdsale,"contract RPTCrowdsale { using SafeMath for uint256; RPTToken public token; uint256 public totalWeiRaised; uint32 public exchangeRate = 3000; uint256 public preDistriToAcquiantancesStartTime = 1510876801; uint256 public preDistriToAcquiantancesEndTime = 1511827199; uint256 public presaleStartTime = 1511827200; uint256 public presaleEndTime = 1513036799; uint256 public crowdfundStartTime = 1513036800; uint256 public crowdfundEndTime = 1515628799; bool internal isTokenDeployed = false; address public founderMultiSigAddress; address public remainingTokenHolder; address public beneficiaryAddress; enum State { Acquiantances, PreSale, CrowdFund, Closed }",1
0x0000009a317684a5f840484357fa587aca76454c.sol,TrueUSD,"contract TrueUSD is StandardDelegate, PausableToken, BurnableToken, NoOwner, CanDelegate { string public name = ; string public symbol = ; uint8 public constant decimals = 18; AddressList public canReceiveMintWhiteList; AddressList public canBurnWhiteList; AddressList public blackList; AddressList public noFeesList; uint256 public burnMin = 10000 * 10**uint256(decimals); uint256 public burnMax = 20000000 * 10**uint256(decimals); uint80 public transferFeeNumerator = 7; uint80 public transferFeeDenominator = 10000; uint80 public mintFeeNumerator = 0; uint80 public mintFeeDenominator = 10000; uint256 public mintFeeFlat = 0; uint80 public burnFeeNumerator = 0; uint80 public burnFeeDenominator = 10000; uint256 public burnFeeFlat = 0; address public staker; event ChangeBurnBoundsEvent(uint256 newMin, uint256 newMax); event Mint(address indexed to, uint256 amount); event WipedAccount(address indexed account, uint256 balance); function TrueUSD() public { totalSupply_ = 0; staker = msg.sender; }",1
0x6b0a768e6a4c3ca41417c8eabdeef36dcadba25d.sol,EtheremonAdventureItem,"contract EtheremonAdventureItem is NFTStandard(, ), BasicAccessControl { uint constant public MAX_OWNER_PERS_SITE = 10; uint constant public MAX_SITE_ID = 108; uint constant public MAX_SITE_TOKEN_ID = 1080; address public adventureHandler; struct Item { uint classId; uint value; }",1
0xaa63c8683647ef91b3fdab4b4989ee9588da297b.sol,ProxyRegistry,contract ProxyRegistry { mapping(address=>DSProxy[]) public proxies; mapping(address=>uint) public proxiesCount; DSProxyFactory factory; function ProxyRegistry(DSProxyFactory factory_) public { factory = factory_; },1
0xc849a5fff9befa297d1c3a772bafac9f3c9004ec.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x031e8de47dee0fdde1969a93b64bb8f8fbcba65d.sol,lockEtherPay,"contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 30412800; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0xae09643734a0A0054fB4C1B376Ea95cd2d552dee; }",1
0x6b4df2aa3d64d8dc06120ef4391513e4170af4a7.sol,GeneralTransferManager,contract GeneralTransferManager is ITransferManager { using SafeMath for uint256; address public issuanceAddress = address(0); address public signingAddress = address(0); bytes32 public constant WHITELIST = ; bytes32 public constant FLAGS = ; struct TimeRestriction { uint256 fromTime; uint256 toTime; uint256 expiryTime; bool canBuyFromSTO; },1
0xc3e43d422d5e6f94315622d96a96058689c52ec8.sol,BitNauticCrowdsaleTokenDistributor,"contract BitNauticCrowdsaleTokenDistributor is Ownable { using SafeMath for uint256; uint256 public constant ICOStartTime = 1531267200; uint256 public constant ICOEndTime = 1536969600; uint256 public teamSupply = 3000000 * 10 ** 18; uint256 public bountySupply = 2500000 * 10 ** 18; uint256 public reserveSupply = 5000000 * 10 ** 18; uint256 public advisorSupply = 2500000 * 10 ** 18; uint256 public founderSupply = 2000000 * 10 ** 18; MintableToken public token; BitNauticWhitelist public whitelist; BitNauticCrowdsale public crowdsale; mapping (address => bool) public hasClaimedTokens; constructor(MintableToken _token, BitNauticWhitelist _whitelist, BitNauticCrowdsale _crowdsale) public { token = _token; whitelist = _whitelist; crowdsale = _crowdsale; }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,Court,"contract Court is Owned, SafeDecimalMath { Havven public havven; EtherNomin public nomin; uint public minStandingBalance = 100 * UNIT; uint public votingPeriod = 1 weeks; uint constant MIN_VOTING_PERIOD = 3 days; uint constant MAX_VOTING_PERIOD = 4 weeks; uint public confirmationPeriod = 1 weeks; uint constant MIN_CONFIRMATION_PERIOD = 1 days; uint constant MAX_CONFIRMATION_PERIOD = 2 weeks; uint public requiredParticipation = 3 * UNIT / 10; uint constant MIN_REQUIRED_PARTICIPATION = UNIT / 10; uint public requiredMajority = (2 * UNIT) / 3; uint constant MIN_REQUIRED_MAJORITY = UNIT / 2; uint nextMotionID = 1; mapping(uint => address) public motionTarget; mapping(address => uint) public targetMotionID; mapping(uint => uint) public motionStartTime; mapping(uint => uint) public votesFor; mapping(uint => uint) public votesAgainst; mapping(address => mapping(uint => uint)) voteWeight; enum Vote {Abstention, Yea, Nay}",1
0xd1265bfe57597840f89971b7e67538bac780f9ad.sol,DesTokenSale,"contract DesTokenSale is Haltable { using SafeMath for uint; string public name = ; DesToken public token; address public beneficiary; uint public tokensSoldTotal = 0; uint public weiRaisedTotal = 0; uint public investorCount = 0; uint public tokensSelling = 0; uint public tokenPrice = 0; uint public purchaseLimit = 0; event NewContribution(address indexed holder, uint256 tokenAmount, uint256 etherAmount); function DesTokenSale( address _token, address _beneficiary ) { token = DesToken(_token); beneficiary = _beneficiary; }",1
0x73e5451bcf4f7c47946abe89c772f3e6576909c3.sol,DragonCrowdsaleCore,"contract DragonCrowdsaleCore is Ownable, DragonPricing { using SafeMath for uint; address public beneficiary; address public charity; address public advisor; address public front; bool public advisorset; uint public tokensSold; uint public etherRaised; uint public presold; uint public presoldMax; uint public crowdsaleCounter; uint public advisorTotal; uint public advisorCut; Dragon public tokenReward; mapping ( address => bool ) public alreadyParticipated; modifier onlyFront() { if (msg.sender != front) { throw; }",1
0x400e115f1be2b646139c298272a43b2cff2b127e.sol,PiggY_BANK,"contract PiggY_BANK { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0xb4a3fb248d39370c1f8081b73fa7098167c8142b.sol,LPCWalletReserveWrapper,"contract LPCWalletReserveWrapper is DSThing { ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee); address public walletReserve; WETH public weth; ERC20 public dai; SaiLPC public lpc; function LPCWalletReserveWrapper(address walletReserve_, WETH weth_, ERC20 dai_, SaiLPC lpc_) public { assert(address(walletReserve_) != 0); assert(address(weth_) != 0); assert(address(dai_) != 0); assert(address(lpc_) != 0); walletReserve = walletReserve_; weth = weth_; lpc = lpc_; dai = dai_; }",1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDView,"contract BitSTDView { BitSTDLogic private logic; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function balanceOf(address add)constant public returns (uint256) { return logic.balanceOf(add); }",1
0x17b031b3802789a458955b3d27c60a0379f187b4.sol,Bitbegin,"contract BitbeginToken { string internal _symbol; string internal _name; uint8 internal _decimals; uint internal _totalSupply = 20000000000000000; mapping (address => uint) _balanceOf; mapping (address => mapping (address => uint)) internal _allowances; constructor(string symbol, string name, uint8 decimals, uint totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; }",1
0xf244176246168f24e3187f7288edbca29267739b.sol,Court,"contract Court is Owned, SafeDecimalMath { Havven public havven; EtherNomin public nomin; uint public minStandingBalance = 100 * UNIT; uint public votingPeriod = 1 weeks; uint constant MIN_VOTING_PERIOD = 3 days; uint constant MAX_VOTING_PERIOD = 4 weeks; uint public confirmationPeriod = 1 weeks; uint constant MIN_CONFIRMATION_PERIOD = 1 days; uint constant MAX_CONFIRMATION_PERIOD = 2 weeks; uint public requiredParticipation = 3 * UNIT / 10; uint constant MIN_REQUIRED_PARTICIPATION = UNIT / 10; uint public requiredMajority = (2 * UNIT) / 3; uint constant MIN_REQUIRED_MAJORITY = UNIT / 2; uint nextMotionID = 1; mapping(uint => address) public motionTarget; mapping(address => uint) public targetMotionID; mapping(uint => uint) public motionStartTime; mapping(uint => uint) public votesFor; mapping(uint => uint) public votesAgainst; mapping(address => mapping(uint => uint)) voteWeight; enum Vote {Abstention, Yea, Nay}",1
0x1d899280f446aab65971e41611b5bb5516dd47f9.sol,CryptoMiningWar,contract CryptoMiningWar is PullPayment { bool public initialized = false; uint256 public roundNumber = 0; uint256 public deadline; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public HALF_TIME = 8 hours; uint256 public ROUND_TIME = 86400 * 7; uint256 public prizePool = 0; uint256 BASE_PRICE = 0.005 ether; uint256 RANK_LIST_LIMIT = 10000; uint256 public totalMiniGame = 0; uint256 private numberOfMiners = 8; uint256 private numberOfBoosts = 5; uint256 private numberOfRank = 21; CryptoEngineerInterface public Engineer; mapping(uint256 => address) public miniGameAddress; mapping(uint256 => MinerData) private minerData; mapping(address => Player) public players; mapping(address => uint256) public boosterReward; mapping(uint256 => BoostData) private boostData; mapping(address => bool) public miniGames; address[21] rankList; address public administrator; struct Player { uint256 roundNumber; mapping(uint256 => uint256) minerCount; uint256 hashrate; uint256 crystals; uint256 lastUpdateTime; },1
0xd1569ffd7ca4393311f66110e6f87184c4817113.sol,LudumAirdrop,"contract LudumAirdrop is Ownable { Token token; event TransferredToken(address indexed to, uint256 value); event FailedTransfer(address indexed to, uint256 value); modifier whenDropIsActive() { assert(isActive()); _; }",1
0x8d4b2cffe2dcbbf06eaa5920401db86ca5fb8177.sol,SelfKeyCrowdsale,"contract SelfKeyCrowdsale is Ownable, CrowdsaleConfig { using SafeMath for uint256; using SafeERC20 for SelfKeyToken; mapping(address => bool) public isVerifier; SelfKeyToken public token; uint64 public startTime; uint64 public endTime; uint256 public goal; uint256 public rate = 51800; uint256 public ethPrice = 777; uint256 public totalPurchased = 0; mapping(address => bool) public kycVerified; mapping(address => uint256) public tokensPurchased; mapping(address => address) public vestedTokens; bool public isFinalized = false; TokenTimelock public foundersTimelock1; TokenTimelock public foundersTimelock2; TokenTimelock public foundationTimelock; RefundVault public vault; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); event VerifiedKYC(address indexed participant); event AddedPrecommitment( address indexed participant, uint256 tokensAllocated ); event Finalized(); modifier verifierOnly() { require(isVerifier[msg.sender]); _; }",1
0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0.sol,Play0x_LottoBall,contract Play0x_LottoBall { using SafeMath for uint256; using SafeMath for uint128; using SafeMath for uint40; using SafeMath for uint8; uint public jackpotSize; uint public tokenJackpotSize; uint public MIN_BET; uint public MAX_BET; uint public MAX_AMOUNT; uint public maxProfit; uint public maxTokenProfit; uint8 public platformFeePercentage = 15; uint8 public jackpotFeePercentage = 5; uint8 public ERC20rewardMultiple = 5; uint constant BetExpirationBlocks = 250; uint public lockedInBets; uint public lockedTokenInBets; bytes32 bitComparisonMask = 0xF; address public owner; address private nextOwner; address public manager; address private nextManager; address[] public secretSignerList; address public ERC20ContractAddres; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Bet { uint amount; uint40 placeBlockNumber; address gambler; },1
0x6e9d4b330aad2f414fa7ae1074afa266b6469364.sol,AetherClockAuction,"contract AetherClockAuction is ClockAuction { bool public isAetherClockAuction = true; uint256 public saleCount; uint256[5] public lastSalePrices; function AetherClockAuction(address _nftAddr, uint256 _cut) public ClockAuction(_nftAddr, _cut) {}",1
0x2628e13a3cbdc52ed96b4b8d6b1041d3ef3a409e.sol,EasySmartolution,"contract EasySmartolution { event ParticipantAdded(address _sender); event ParticipantRemoved(address _sender); event ReferrerAdded(address _contract, address _sender); mapping (address => address) public participants; mapping (address => bool) public referrers; address private processing; constructor(address _processing) public { processing = _processing; }",1
0x5c743a35e903f6c584514ec617acee0611cf44f3.sol,ERC223Token,"contract ERC223Token { using SafeMath for uint256; string public name; bytes32 public symbol; uint8 public decimals; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping (address => mapping(address => uint256)) internal allowances; function transfer(address to, uint256 value, bytes data) public returns (bool) { require(balanceOf[msg.sender] >= value); uint256 codeLength; assembly { codeLength := extcodesize(to) }",1
0x32c62c965db5fdac0f94e6276d6884070068d4be.sol,MyAdvancedToken,contract MyAdvancedToken { address private constant OWNER = 0xb810aD480cF8e3643031bB36e6A002dC3B1d928e; function isSenderOwner(address sender) private pure returns (bool) { return sender == OWNER; },1
0x2775f2a3c83bee1541d1d1bc308b3bb432b45151.sol,PLANETAGROToken,contract PLANETAGROToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 20000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function PLANETAGROToken () { owner = msg.sender; },1
0x0ce95ef378059f38c5fa21e6d81a5895c0d9911b.sol,Game,contract Game { using GlobalTypes for GlobalTypes.Global; using MarketTypes for MarketTypes.MarketListing; using MissionParametersTypes for MissionParametersTypes.MissionParameters; using GameCommon for GameCommon.LaunchRocketStackFrame; address public m_Owner; AbstractDatabase public m_Database; AbstractGameHidden public m_GameHidden; bool public m_Paused; uint256 constant GlobalCategory = 0; uint256 constant RocketCategory = 1; uint256 constant OwnershipCategory = 2; uint256 constant InventoryCategory = 3; uint256 constant MarketCategory = 4; uint256 constant ProfitFundsCategory = 5; uint256 constant CompetitionFundsCategory = 6; uint256 constant MissionParametersCategory = 7; uint256 constant CompetitionScoresCategory = 8; uint256 constant WithdrawalFundsCategory = 9; uint256 constant ReferralCategory = 10; uint256 constant RocketStockCategory = 11; uint256 constant RocketStockInitializedCategory = 12; address constant NullAddress = 0; uint256 constant MaxCompetitionScores = 10; mapping(uint32 => RocketTypes.StockRocket) m_InitialRockets; modifier OnlyOwner() { require(msg.sender == m_Owner); _; },1
0x0f1da17b33df90c078fd2fb4b9011a64af3c67a6.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; using Address for address; mapping(address => uint256) internal _balances; mapping(address => mapping(address => uint256)) private _allowed; uint256 internal _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDView,"contract BitSTDView { BitSTDLogic private logic; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function balanceOf(address add)constant public returns (uint256) { return logic.balanceOf(add); }",1
0xed2725cdfc48a24aa71d9b9621d431db0705a55a.sol,ProfitSharing,"contract ProfitSharing is Ownable { using SafeMath for uint256; event DividendDeposited(address indexed _depositor, uint256 _blockNumber, uint256 _amount, uint256 _totalSupply, uint256 _dividendIndex); event DividendClaimed(address indexed _claimer, uint256 _dividendIndex, uint256 _claim); event DividendRecycled(address indexed _recycler, uint256 _blockNumber, uint256 _amount, uint256 _totalSupply, uint256 _dividendIndex); MiniMeToken public token; uint256 public RECYCLE_TIME = 1 years; struct Dividend { uint256 blockNumber; uint256 timestamp; uint256 amount; uint256 claimedAmount; uint256 totalSupply; bool recycled; mapping (address => bool) claimed; }",1
0x33e85f62383aa7601d6ca117fe35b9b397ffe056.sol,UXDToken,contract UXDToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 10000000000 * (10**2); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function UXDToken () { owner = msg.sender; },1
0x402fa04ccd2c2568e1a53dbecec1bd572303663a.sol,HarborPresale,"contract HarborPresale is Haltable { using SafeMath for uint256; HarborToken public token; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public weiRaised; uint256 public cap; bool public isFinalized = false; uint256 public minimumFundingGoal; uint256 public minSend; RefundVault public vault; uint public tokensMinted; mapping (address => uint256) public tokenDeposited; event Finalized(); event TokenMinted(uint count); event Distributed(address investor, uint tokenAmount); event PeriodChanged(uint256 starttm,uint256 endtm); event TokenPurchase(address indexed purchaser, address indexed investor, uint256 value); function HarborPresale(address _token, uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, uint256 _cap, uint256 _minimumFundingGoal, uint256 _minSend) { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != 0x0); require(_cap > 0); require(_minimumFundingGoal > 0); token = HarborToken(_token); startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; cap = _cap; vault = new RefundVault(_wallet); minimumFundingGoal = _minimumFundingGoal; minSend = _minSend; }",1
0x4853cb0e07ab16cb380f8aeda24507779881cdeb.sol,KYC,"contract KYC is Ownerable { mapping (address => bool) public registeredAddress; mapping (address => bool) public admin; event Registered(address indexed _addr); event Unregistered(address indexed _addr); event NewAdmin(address indexed _addr); event ClaimedTokens(address _token, address owner, uint256 balance); modifier onlyRegistered(address _addr) { require(registeredAddress[_addr]); _; }",1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,Token,"contract Token { using SafeMath for uint256; mapping (address => uint256) public balances; mapping(address => mapping (address => uint256)) allowed; address[] allTokenHolders; string public name; string public symbol; uint8 public decimals; uint256 totalSupplyAmount = 0; address public refundManagerContractAddress; AuthenticationManager authenticationManager; LockinManager lockinManager; function availableBalance(address _owner) constant returns(uint256) { uint256 length = lockinManager.getLocks(_owner); uint256 lockedValue = 0; for(uint256 i = 0; i < length; i++) { if(lockinManager.getLocksUnlockDate(_owner, i) > now) { uint256 _value = lockinManager.getLocksAmount(_owner, i); lockedValue = lockedValue.add(_value); }",1
0x269b4c23ddab676e2869ae72cd6ae4f24bdfea45.sol,IRBPreCrowdsale,"contract IRBPreCrowdsale is Ownable, Pausable { using SafeMath for uint; IRBToken public token; IRBPreRefundVault public vault; uint startTime = 1513065600; uint endTime = 1515963599; uint256 public constant minPresaleAmount = 108 * 10 ** 15; uint256 public constant goal = 1125 * 10 ** 18; uint256 public constant cap = 2250 * 10 ** 18; uint256 public weiRaised; bool public isFinalized = false; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event Finalized(); function IRBPreCrowdsale(address _tokenAddress, address _vaultAddress) { require(_tokenAddress != address(0)); require(_vaultAddress != address(0)); token = IRBToken(_tokenAddress); vault = IRBPreRefundVault(_vaultAddress); }",1
0xdc919494349e803fbd2d4064106944418381edb3.sol,DSValue,"contract DSValue is DSThing { bool has; bytes32 val; function peek() public view returns (bytes32, bool) { return (val,has); }",1
0x449f5c827cf7726cc5f181090aa147ca5fb88a40.sol,EthergotchiOwnershipV2,"contract EthergotchiOwnershipV2 is Controllable, ERC721, ERC721Enumerable, ERC721Metadata { mapping(uint256 => address) private ownerByTokenId; mapping(address => uint256[]) private tokenIdsByOwner; mapping(uint256 => uint256) private ownerTokenIndexByTokenId; mapping(uint256 => address) private approvedTransfers; mapping(address => mapping(address => bool)) private operators; uint256 private totalTokens; bytes4 private constant INTERFACE_SIGNATURE_ERC165 = bytes4( keccak256() ); bytes4 private constant INTERFACE_SIGNATURE_ERC721 = bytes4( keccak256() ^ keccak256() ^ keccak256() ^ keccak256() ^ keccak256() ^ keccak256() ^ keccak256() ^ keccak256() ^ keccak256() ); bytes4 private constant INTERFACE_SIGNATURE_ERC721_ENUMERABLE = bytes4( keccak256() ^ keccak256() ^ keccak256() ); bytes4 private constant INTERFACE_SIGNATURE_ERC721_METADATA = bytes4( keccak256() ^ keccak256() ^ keccak256() ); bytes4 private constant INTERFACE_SIGNATURE_ERC721_TOKEN_RECEIVER = bytes4( keccak256() ); event Transfer( address indexed _from, address indexed _to, uint256 _tokenId ); event Approval( address indexed _owner, address indexed _approved, uint256 _tokenId ); event ApprovalForAll( address indexed _owner, address indexed _operator, bool _approved ); modifier onlyValidToken(uint256 _tokenId) { require(ownerByTokenId[_tokenId] != address(0)); _; }",1
0x340b84a70520f721fde96c7ad663383c31e416cb.sol,BurnableToken,"contract BurnableToken is BasicToken{ event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { require(_value <= balances.balanceOf(msg.sender)); address burner = msg.sender; balances.subBalance(burner, _value); totalSupply_ = totalSupply_.sub(_value); emit Burn(burner, _value); emit Transfer(burner, address(0), _value); }",1
0x6f8544edb3f513845135b0efa907f4b6b9c2c92e.sol,BW,contract BWData { address public owner; address private bwService; address private bw; address private bwMarket; uint private blockValueBalance = 0; uint private feeBalance = 0; uint private BASE_TILE_PRICE_WEI = 1 finney; mapping (address => User) private users; mapping (uint16 => Tile) private tiles; struct User { uint creationTime; bool censored; uint battleValue; },1
0x589fbf3d4168518b8b849b7eedfdb719407900ca.sol,AirDropLight,contract AirDropLight is OwnableWithAdmin { using SafeMath for uint256; uint256 public grandTotalClaimed = 0; ERC20 public token; uint256 maxDirect = 10000 * (10**uint256(18)); mapping(address => bool) public recipients; address[] public addresses; constructor(ERC20 _token) public { require(_token != address(0)); token = _token; },1
0x7976af0ae2124a0771d5287aa16017b3f9dd43a4.sol,BasicToken,contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; bool transferable; modifier isTransferable() { require(transferable || msg.sender == owner); _; },1
0xd41ee3317467ab60109d76d6360807777c10afd7.sol,ZJLTTokenVault,"contract ZJLTTokenVault is Ownable { using SafeMath for uint256; address public teamWallet = 0x1fd4C9206715703c209651c215f506555a40b7C0; uint256 public startLockTime; uint256 public totalAlloc = 25 * 10 ** 18; uint256 public perValue = 20833333 * 10 ** 11; uint256 public timeLockPeriod = 30 days; uint256 public teamVestingStages = 12; uint256 public latestUnlockStage = 0; mapping (address => uint256) public lockBalance; ZJLTToken public token; bool public isExec; event Alloc(address _wallet, uint256 _value); event Claim(address _wallet, uint256 _value); modifier unLocked { uint256 nextStage = latestUnlockStage.add(1); require(startLockTime > 0 && now >= startLockTime.add(nextStage.mul(timeLockPeriod))); _; }",1
0x74f887f5b336704be1591f8a2f2e419767134316.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; using Address for address; mapping(address => uint256) internal _balances; mapping(address => mapping(address => uint256)) private _allowed; uint256 internal _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0x377dfa7bab23a798ca1fa0923bcd4d4ef2184d85.sol,StarbaseEarlyPurchaseAmendment,contract StarbaseEarlyPurchaseAmendment { event EarlyPurchaseInvalidated(uint256 epIdx); event EarlyPurchaseAmended(uint256 epIdx); AbstractStarbaseCrowdsale public starbaseCrowdsale; StarbaseEarlyPurchase public starbaseEarlyPurchase; address public owner; uint256[] public invalidEarlyPurchaseIndexes; uint256[] public amendedEarlyPurchaseIndexes; mapping (uint256 => StarbaseEarlyPurchase.EarlyPurchase) public amendedEarlyPurchases; modifier noEther() { require(msg.value == 0); _; },1
0xbd5ff93a6ce6019f0e69227d88d11e5772dc853e.sol,Crowdsale,"contract Crowdsale { using SafeMath for uint256; ERC20 public token; address public fundWallet; address public admin; uint256 public rate = 10000; uint256 public amountRaised; bool public crowdsaleOpen; uint256 public cap; event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount); function Crowdsale(ERC20 _token, address _fundWallet) public { require(_token != address(0)); require(_fundWallet != address(0)); fundWallet = _fundWallet; admin = msg.sender; token = _token; crowdsaleOpen = true; cap = 20000 * 1 ether; }",1
0xcef8feebbdc278c0c81e07b87abf96b22d08fa6e.sol,UnicornRefunds,"contract UnicornRefunds { using SafeMath for uint; address public cardboardUnicornTokenAddress; address public unicornRanchAddress; address public owner = msg.sender; uint public pricePerUnicorn = 1 finney; uint public rewardUnicornAmount = 100; mapping(address => uint) allowedAmounts; mapping(address => bool) rewardClaimed; event RewardClaimed(address indexed _who, uint _bookingIndex); event UnicornsSold(address indexed _who, uint _unicornCount, uint _unicornCost, uint _paymentTotal); modifier onlyOwner { require(msg.sender == owner); _; }",1
0x7021967e5d0761772c6fb25304f2d013865aba7c.sol,EpigenCareCrowdsale,contract EpigenCareCrowdsale is Ownable { using SafeMath for uint256; StandardToken public token; uint256 public startTime; uint256 public endTime; address public wallet; address public tokenPool; uint256 public rate; uint256 public weiRaised; uint256 public weiPending; uint256 public tokensPending; uint256 public minimumInvestment; mapping (address => Transaction) transactions; mapping (address => bool) approvedAddresses; mapping (address => bool) verifiers; struct Transaction { uint weiAmount; uint tokenAmount; },1
0x750c1d91864171d7e1715a6b53ee28c72b8faa09.sol,EthicHubUser,"contract EthicHubUser is Ownable, EthicHubBase { event UserStatusChanged(address target, string profile, bool isRegistered); constructor(address _storageAddress) EthicHubBase(_storageAddress) public { version = 3; }",1
0x065d6fccf3bcc50e37e875479511f5ca656b98d8.sol,B42Token,contract B42Token is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 42000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function B42Token () { owner = msg.sender; },1
0x3672a1d8a362c9a50db70df219e05ea3cab60df9.sol,SUGARToken,contract SUGARToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0x3a266f97425cd281c1770b71662fcf4415c29190.sol,CryptoProgramFactory,contract CryptoProgramFactory { bool status = false; using SafeMath for uint256; address public administrator; uint256 private BASE_PRICE = 0.1 ether; uint256 private BASE_TIME = 4 hours; MemoryFactoryInterface public Memory; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; mapping(uint256 => Factory) public factories; mapping(address => bool) public miniGames; struct Factory { uint256 level; uint256 crystals; uint256 programPriceByCrystals; uint256 programPriceByDarkCrystals; uint256 programValue; uint256 eth; uint256 time; },1
0x0e752b742f744fdc2d93774da44c37b72c3e6952.sol,CraftyCrowdsale,"contract CraftyCrowdsale is Pausable { using SafeMath for uint256; mapping(address => uint256) received; MintableToken public token; uint256 public preSaleStart; uint256 public preSaleEnd; uint256 public saleStart; uint256 public saleEnd; uint256 public issuedTokens = 0; uint256 public constant hardCap = 5000000000 * 10**8; uint256 constant teamCap = 1450000000 * 10**8; uint256 constant advisorCap = 450000000 * 10**8; uint256 constant bountyCap = 100000000 * 10**8; uint256 constant fundCap = 3000000000 * 10**8; uint256 constant lockTime = 180 days; address public etherWallet; address public teamWallet; address public advisorWallet; address public fundWallet; address public bountyWallet; TokenTimelock teamTokens; uint256 public rate; enum State { BEFORE_START, SALE, REFUND, CLOSED }",1
0x0000009a317684a5f840484357fa587aca76454c.sol,TrueUSD,"contract TrueUSD is StandardDelegate, PausableToken, BurnableToken, NoOwner, CanDelegate { string public name = ; string public symbol = ; uint8 public constant decimals = 18; AddressList public canReceiveMintWhiteList; AddressList public canBurnWhiteList; AddressList public blackList; AddressList public noFeesList; uint256 public burnMin = 10000 * 10**uint256(decimals); uint256 public burnMax = 20000000 * 10**uint256(decimals); uint80 public transferFeeNumerator = 7; uint80 public transferFeeDenominator = 10000; uint80 public mintFeeNumerator = 0; uint80 public mintFeeDenominator = 10000; uint256 public mintFeeFlat = 0; uint80 public burnFeeNumerator = 0; uint80 public burnFeeDenominator = 10000; uint256 public burnFeeFlat = 0; address public staker; event ChangeBurnBoundsEvent(uint256 newMin, uint256 newMax); event Mint(address indexed to, uint256 amount); event WipedAccount(address indexed account, uint256 balance); function TrueUSD() public { totalSupply_ = 0; staker = msg.sender; }",1
0x9297a9d824e2f2d6f2dff2b871cb9e2f3f4f77d2.sol,RegistryUpdater,contract RegistryUpdater is Ownable { address public polymathRegistry; address public moduleRegistry; address public securityTokenRegistry; address public tickerRegistry; address public polyToken; constructor (address _polymathRegistry) public { require(_polymathRegistry != address(0)); polymathRegistry = _polymathRegistry; },1
0x77c9acc811e4cf4b51dc3a3e05dc5d62fa887767.sol,CrryptoArena,contract CrryptoArena { using SafeMath for uint256; address public administrator; uint256 public VIRUS_NORMAL = 0; uint256 public HALF_TIME_ATK= 60 * 15; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public VIRUS_MINING_PERIOD = 86400; address public engineerAddress; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; CryptoProgramFactoryInterface public Factory; mapping(address => Player) public players; mapping(uint256 => Virus) public viruses; mapping(address => bool) public miniGames; struct Player { uint256 virusDef; uint256 nextTimeAtk; uint256 endTimeUnequalledDef; },1
0xc0eb85285d83217cd7c891702bcbc0fc401e2d9d.sol,HVNToken,"contract HVNToken is ERC20Interface, SafeMath, Owned { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 8; string public version = ; bool public transfersFrozen = false; modifier onlyPayloadSize(uint numwords) { assert(msg.data.length == numwords * 32 + 4); _; }",1
0x400e115f1be2b646139c298272a43b2cff2b127e.sol,PiggY_BANK,"contract PiggY_BANK { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x000000002bb43c83ece652d161ad0fa862129a2c.sol,AccountRegistry,"contract AccountRegistry is AccountRegistryInterface, TokenRescue { uint256 constant public registrationDeposit = 1 finney; uint256 constant public proposalCensorshipFee = 50 finney; address constant public burn = 0x000000003Ffc15cd9eA076d7ec40B8f516367Ca1; Vote public constant token = Vote(0x000000002647e16d9BaB9e46604D75591D289277); uint8 constant UNCONTACTED = 0; uint8 constant PROPOSER = 1; uint8 constant VOTER = 2; uint8 constant PENDING_PROPOSAL = 4; uint8 constant PROPOSAL = 8; uint8 constant PENDING_CABAL = 16; uint8 constant CABAL = 32; uint8 constant BOARD = 64; struct Account { uint256 lastAccess; uint8 membership; address appointer; address denouncer; address voucher; address devoucher; }",1
0x00685230359bdb9e16704e1d3918b553e9a015e2.sol,Marketplace,contract Marketplace is Ownable { struct Ad { uint price; address exchanger; bool exists; bool active; },1
0x26f4fb84b53dff7e148a8196f09bc492e55f2889.sol,TimeLockPool,contract TimeLockPool{ using SafeMath for uint256; struct LockedBalance { uint256 balance; uint256 releaseTime; },1
0x6f8544edb3f513845135b0efa907f4b6b9c2c92e.sol,BW,contract BWData { address public owner; address private bwService; address private bw; address private bwMarket; uint private blockValueBalance = 0; uint private feeBalance = 0; uint private BASE_TILE_PRICE_WEI = 1 finney; mapping (address => User) private users; mapping (uint16 => Tile) private tiles; struct User { uint creationTime; bool censored; uint battleValue; },1
0x6593a7140f3718efff638b72a9b6083db47ce0d2.sol,Crowdsale,"contract Crowdsale is GuidedByRoles, ERC20Provider{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 90 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x335c949c06fa1ba8744d98e3aa2c2a2deaa9255c.sol,Exchanger,"contract Exchanger is Administered, tokenRecipient { bool public enabled = false; ITradeableAsset public tokenContract; IYeekFormula public formulaContract; uint32 public weight; uint32 public fee=5000; uint32 public multiplier=1; uint32 public collectedFees=0; constructor(address _token, uint32 _weight, address _formulaContract) { require (_weight > 0 && weight <= 1000000); weight = _weight; tokenContract = ITradeableAsset(_token); formulaContract = IYeekFormula(_formulaContract); }",1
0x3672a1d8a362c9a50db70df219e05ea3cab60df9.sol,SUGARToken,contract SUGARToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0x6e82aabffe24f275ad3f703aca922dd4d8f86168.sol,BatchTransfer,"contract BatchTransfer is Ownable { using SafeMath for uint256; event Withdraw(address indexed receiver, address indexed token, uint amount); event TransferEther(address indexed sender, address indexed receiver, uint256 amount); modifier checkArrayArgument(address[] _receivers, uint256[] _amounts) { require(_receivers.length == _amounts.length && _receivers.length != 0); _; }",1
0x271a0b465d5b453bb835afd2d671c76b2b76900e.sol,ClockAuction,"contract ClockAuctionBase is Withdrawable, Pausable { struct Auction { address _contract; address seller; uint128 startingPrice; uint128 endingPrice; uint64 duration; uint64 startedAt; }",1
0xec2e5c8d51fdd54fef83db8300399a3c2e167922.sol,CrowdsaleToken,"contract CrowdsaleToken is Manageable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public totalSupply; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; mapping (address => uint256) public releaseTime; bool public released; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Mint(address indexed _to, uint256 _value); event ReleaseTimeChanged(address indexed _owner, uint256 _oldReleaseTime, uint256 _newReleaseTime); event ReleasedChanged(bool _oldReleased, bool _newReleased); modifier canTransfer(address _from) { if (releaseTime[_from] == 0) { require(released); }",1
0xa5d6accc5695327f65cbf38da29198df53efdcf0.sol,Private_accumulation_fund,contract Private_accumulation_fund { mapping (address => uint) public balances; uint public MinDeposit = 1 ether; Log TransferLog; function Private_accumulation_fund(address _log) public { TransferLog = Log(_log); },1
0x74f887f5b336704be1591f8a2f2e419767134316.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; using Address for address; mapping(address => uint256) internal _balances; mapping(address => mapping(address => uint256)) private _allowed; uint256 internal _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0x1860d43a2a1b9b03907eb6a6b92ce256694dd315.sol,NescrowExchangeService,contract NescrowExchangeService { address owner = msg.sender; uint256 public feeRateLimit = 200; uint256 public takerFeeRate = 0; uint256 public makerFeeRate = 0; address public feeAddress; mapping (address => bool) public admins; mapping (bytes32 => uint256) public orderFills; mapping (bytes32 => uint256) public orderPaymentFills; mapping (bytes32 => bool) public withdrawn; mapping (bytes32 => bool) public transfers; mapping (address => mapping (address => uint256)) public balances; mapping (address => uint256) public tradesLocked; mapping (address => uint256) public disableFees; mapping (address => uint256) public tokenDecimals; mapping (address => bool) public tokenRegistered; struct EIP712Domain { string name; string version; uint256 chainId; address verifyingContract; },1
0x6b4df2aa3d64d8dc06120ef4391513e4170af4a7.sol,GeneralTransferManager,contract GeneralTransferManager is ITransferManager { using SafeMath for uint256; address public issuanceAddress = address(0); address public signingAddress = address(0); bytes32 public constant WHITELIST = ; bytes32 public constant FLAGS = ; struct TimeRestriction { uint256 fromTime; uint256 toTime; uint256 expiryTime; bool canBuyFromSTO; },1
0x742686bb1b136b396b59818f42e47a4fc3509394.sol,CommonSale,contract CommonSale is StagedCrowdsale { address public multisigWallet; address public foundersTokensWallet; address public bountyTokensWallet; uint public foundersPercent; uint public bountyTokensCount; uint public price; uint public percentRate = 100; bool public bountyMinted = false; CommonSale public nextSale; MintableToken public token; function setToken(address newToken) onlyOwner { token = MintableToken(newToken); },1
0x3fbe0c07b2e5edc9aaa88017c924d1aeff6a719b.sol,PresalePool,contract PresalePool { using SafeMath for uint; uint8 public contractStage = 1; address public owner; uint maxContractBalance; uint contributionCap; uint public feePct; address public receiverAddress; uint constant public contributionMin = 100000000000000000; uint constant public maxGasPrice = 50000000000; WhiteList constant public whitelistContract = WhiteList(0xf6E386FA4794B58350e7B4Cb32B6f86Fb0F357d4); bool whitelistIsActive = true; uint public nextCapTime; uint public nextContributionCap; uint public addressChangeBlock; uint public finalBalance; uint[] public ethRefundAmount; address public activeToken; struct Contributor { uint ethRefund; uint balance; uint cap; mapping (address => uint) tokensClaimed; },1
0x46822ac3bc32db7ebd9845da3fe0886f824e9edf.sol,EBSCSale,"contract EBSCSale is Pausable { using SafeMath for uint256; address public beneficiary; uint public fundingGoal; uint public fundingCap; uint public minContribution; bool public fundingGoalReached = false; bool public fundingCapReached = false; bool public saleClosed = false; uint public startTime; uint public endTime; uint public amountRaised; uint public refundAmount; uint public rate = 6000; uint public constant LOW_RANGE_RATE = 500; uint public constant HIGH_RANGE_RATE = 20000; bool private rentrancy_lock = false; EBSCToken public tokenReward; mapping(address => uint256) public balanceOf; event GoalReached(address _beneficiary, uint _amountRaised); event CapReached(address _beneficiary, uint _amountRaised); event FundTransfer(address _backer, uint _amount, bool _isContribution); modifier beforeDeadline() { require (currentTime() < endTime); _; }",1
0x39e8082b00c9f19ebf553e40feb7cf8459acc693.sol,DSToken,"contract DSTokenBase is ERC20, DSMath { uint256 _supply; mapping (address => uint256) _balances; mapping (address => mapping (address => uint256)) _approvals; function DSTokenBase(uint supply) public { _balances[msg.sender] = supply; _supply = supply; }",1
0x5bd7fb9b29320ed7a12fcf8fd81e6250b5d2ecdc.sol,ZlotsJackpotHoldingContract,contract ZlotsJackpotHoldingContract is ERC223Receiving { modifier onlyOwner() { require(msg.sender == owner); _; },1
0x4c7f666ca30fe548fbdc08b0308927327f08336d.sol,VestedTokenDistributionStrategy,"contract VestedTokenDistributionStrategy is Ownable, FixedPoolWithBonusTokenDistributionStrategy { event Released(address indexed beneficiary, uint256 indexed amount); uint256 public vestingStart; bool public vestingConfigured = false; uint256 public vestingDuration; mapping (address => uint256) public released; modifier vestingPeriodStarted { require(crowdsale.hasEnded()); require(vestingConfigured == true); require(now > vestingStart); _; }",1
0x5211475520dc4a13fee1cc7c2c0c1167998bcbb8.sol,AuctionContract,"contract AuctionContract { using SafeMath for uint; event BetPlacedEvent(address bidderAddress, uint amount); event RefundEvent(address bidderAddress, uint amount); event CreateAuctionContractEvent(address bidderAddress, uint amount); uint public auctionSlideSize = 30; uint public auctionCloseBlock; uint public closeAuctionAfterNBlocks; uint public bettingStep; mapping (address => uint) public bettingMap; address public firstBidder; address public secondBidder; address public winner; uint public biggestBet; uint public prize; address public firstBetContract; address public secondBetContract; uint public minimalPrize = 10000000000000000; uint public minimaBetStep = 10000000000000000; address public auctioneerAddress; bool public isActive; constructor (uint _closeAuctionAfterNBlocks, address _auctioneerAddress) payable public{ assert(msg.value >= minimalPrize); prize = msg.value; auctioneerAddress = _auctioneerAddress; closeAuctionAfterNBlocks = _closeAuctionAfterNBlocks; auctionCloseBlock = block.number.add(_closeAuctionAfterNBlocks); bettingStep = 0; biggestBet = 0; isActive = true; emit CreateAuctionContractEvent(this, prize); }",1
0x20d4ec1b92cc4570c74efd968d04660b8fcc0406.sol,HasNoTokens,"contract HasNoTokens is Ownable { event ExtractedTokens(address indexed _token, address indexed _claimer, uint _amount); function extractTokens(address _token, address _claimer) onlyOwner public { if (_token == 0x0) { _claimer.transfer(this.balance); return; }",1
0x065d6fccf3bcc50e37e875479511f5ca656b98d8.sol,B42Token,contract B42Token is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 42000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function B42Token () { owner = msg.sender; },1
0x54ee540b38fc6e0548172fe651927d85366c6bf7.sol,TRSToken,contract TRSToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 100000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function TRSToken () { owner = msg.sender; },1
0x77c9acc811e4cf4b51dc3a3e05dc5d62fa887767.sol,CrryptoArena,contract CrryptoArena { using SafeMath for uint256; address public administrator; uint256 public VIRUS_NORMAL = 0; uint256 public HALF_TIME_ATK= 60 * 15; uint256 public CRTSTAL_MINING_PERIOD = 86400; uint256 public VIRUS_MINING_PERIOD = 86400; address public engineerAddress; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; CryptoProgramFactoryInterface public Factory; mapping(address => Player) public players; mapping(uint256 => Virus) public viruses; mapping(address => bool) public miniGames; struct Player { uint256 virusDef; uint256 nextTimeAtk; uint256 endTimeUnequalledDef; },1
0xc3e43d422d5e6f94315622d96a96058689c52ec8.sol,BitNauticCrowdsaleTokenDistributor,"contract BitNauticCrowdsaleTokenDistributor is Ownable { using SafeMath for uint256; uint256 public constant ICOStartTime = 1531267200; uint256 public constant ICOEndTime = 1536969600; uint256 public teamSupply = 3000000 * 10 ** 18; uint256 public bountySupply = 2500000 * 10 ** 18; uint256 public reserveSupply = 5000000 * 10 ** 18; uint256 public advisorSupply = 2500000 * 10 ** 18; uint256 public founderSupply = 2000000 * 10 ** 18; MintableToken public token; BitNauticWhitelist public whitelist; BitNauticCrowdsale public crowdsale; mapping (address => bool) public hasClaimedTokens; constructor(MintableToken _token, BitNauticWhitelist _whitelist, BitNauticCrowdsale _crowdsale) public { token = _token; whitelist = _whitelist; crowdsale = _crowdsale; }",1
0x2e59c87e9349242063793761780550374a3146cf.sol,THORToken,contract THORToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 500000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function THORToken () { owner = msg.sender; },1
0xed0577d074be9f605f0967fe6a8b3174d92e5e36.sol,DexBrokerage,"contract DexBrokerage is Ownable { using SafeMath for uint256; address public feeAccount; uint256 public makerFee; uint256 public takerFee; uint256 public inactivityReleasePeriod; mapping (address => bool) public approvedCurrencyTokens; mapping (address => uint256) public invalidOrder; mapping (address => mapping (address => uint256)) public tokens; mapping (address => bool) public admins; mapping (address => uint256) public lastActiveTransaction; mapping (bytes32 => uint256) public orderFills; mapping (bytes32 => bool) public withdrawn; event Trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address maker, address taker); event Deposit(address token, address user, uint256 amount, uint256 balance); event Withdraw(address token, address user, uint256 amount, uint256 balance); event MakerFeeUpdated(uint256 oldFee, uint256 newFee); event TakerFeeUpdated(uint256 oldFee, uint256 newFee); modifier onlyAdmin { require(msg.sender == owner || admins[msg.sender]); _; }",1
0x0f1da17b33df90c078fd2fb4b9011a64af3c67a6.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; using Address for address; mapping(address => uint256) internal _balances; mapping(address => mapping(address => uint256)) private _allowed; uint256 internal _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0x5ca4568d54ecfc15902a425fd6ac64095a9a51a3.sol,MultiTransfer,"contract MultiTransfer { event Deposited(address from, uint value, bytes data); event Transacted( address msgSender, address toAddress, uint value ); function() public payable { if (msg.value > 0) { emit Deposited(msg.sender, msg.value, msg.data); }",1
0x29880855d419c6fa0e8c7fdfd985c80f286d914e.sol,DadiPublicSale,contract DadiPublicSale is Ownable { using SafeMath for uint256; StandardToken public token; uint256 public tokenSupply; uint256 public tokensPurchased = 0; uint256 public individualCap = 5000 * 1000; uint256 public tokenPrice = 500; uint256 public ethRate; uint256 public maxGasPrice; address[] public saleWallets; mapping(address => Investor) private investors; address[] private investorIndex; struct Investor { uint256 tokens; uint256 contribution; bool distributed; uint index; },1
0x25b16c95f3ebb1d8583a1c173f81257bc916a9be.sol,SignalsCrowdsale,"contract SignalsCrowdsale is FinalizableCrowdsale { uint256 public constant HARD_CAP = 18000*(10**18); uint256 public toBeRaised = 18000*(10**18); uint256 public constant PRICE = 360000; uint256 public tokensSold; uint256 public constant maxTokens = 185000000*(10**9); uint constant ADVISORY_SHARE = 18500000*(10**9); uint constant BOUNTY_SHARE = 3700000*(10**9); uint constant COMMUNITY_SHARE = 37000000*(10**9); uint constant COMPANY_SHARE = 33300000*(10**9); uint constant PRESALE_SHARE = 7856217611546440; address constant ADVISORS = 0x98280b2FD517a57a0B8B01b674457Eb7C6efa842; address constant BOUNTY = 0x8726D7ac344A0BaBFd16394504e1cb978c70479A; address constant COMMUNITY = 0x90CDbC88aB47c432Bd47185b9B0FDA1600c22102; address constant COMPANY = 0xC010b2f2364372205055a299B28ef934f090FE92; address constant PRESALE = 0x7F3a38fa282B16973feDD1E227210Ec020F2481e; CrowdsaleRegister register; PrivateRegister register2; bool public ready; event SaleWillStart(uint256 time); event SaleReady(); event SaleEnds(uint256 tokensLeft); function SignalsCrowdsale(address _token, address _wallet, address _register, address _register2) public FinalizableCrowdsale() Crowdsale(_token, _wallet) { register = CrowdsaleRegister(_register); register2 = PrivateRegister(_register2); }",1
0x302eb72befc8af539432ec32c39423525412748f.sol,ZRSToken,contract ZRSToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 24000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function ZRSToken () { owner = msg.sender; },1
0xdbe13bf528ca21bb6c306539109c21a304191f72.sol,HISToken,contract HISToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 200000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0x0f31b54b35ab54d65d001f4e037a97548461ea7c.sol,EvilMorty,"contract EvilMorty is ERC223 { string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000000e18; uint256 public constant GAME_SUPPLY = 200000000e18; uint256 public constant COMMUNITY_SUPPLY = 800000000e18; address public citadelAddress; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[owner] = COMMUNITY_SUPPLY; emit Transfer(0x0, owner, COMMUNITY_SUPPLY); }",1
0x00f634a0bb03416816f8829928ef7d776f798414.sol,KiOS,"contract KiOS { address public admin; mapping(address => uint) public rates; event Purchase(address indexed payer, address indexed token, uint price, uint amount); event Received(address indexed sender, address indexed token, uint amount); event Sent(address indexed recipient, address indexed token, uint amount); constructor() public { admin = msg.sender; }",1
0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a.sol,BitSTDView,"contract BitSTDView { BitSTDLogic private logic; address public owner; event Transfer(address indexed from, address indexed to, uint256 value); event FrozenFunds(address target, bool frozen); event Burn(address indexed from, uint256 value); function balanceOf(address add)constant public returns (uint256) { return logic.balanceOf(add); }",1
0x1eafd303c88b6cd638c77b40596de3dcf001b249.sol,AssetInfo,contract AssetInfo is Manageable { string public publicDocument; event UpdateDocument( string newLink ); constructor(string _publicDocument) public { publicDocument = _publicDocument; },1
0x190646e10b85fbcd631c23c8cd175e25df92c338.sol,EthBattle,"contract EthBattle is Ownable { using SafeMath for uint256; uint256 constant TOKEN_USE_BONUS = 15; uint256 constant REFERRAL_REWARD = 2 ether; uint256 constant MIN_PLAY_AMOUNT = 50 finney; uint256 public roundIndex = 0; mapping(uint256 => address) public rounds; address[] private currentRewardingAddresses; PlaySeedInterface private playSeedGenerator; GTAInterface public token; AMUStoreInterface public store; mapping(address => address) public referralBacklog; mapping(address => uint256) public tokens; event RoundCreated(address createdAddress, uint256 index); event Deposit(address user, uint amount, uint balance); event Withdraw(address user, uint amount, uint balance); function () public payable { getLastRound().getDevWallet().transfer(msg.value); }",1
0x923641c6b80d8fc913ff883a5c523f47081bad92.sol,Token,"contract TokenInterface { mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; mapping(address => bool) seller; address config; address owner; address dao; address public badgeLedger; bool locked; uint256 public totalSupply; function balanceOf(address _owner) constant returns(uint256 balance); function transfer(address _to, uint256 _value) returns(bool success); function transferFrom(address _from, address _to, uint256 _value) returns(bool success); function approve(address _spender, uint256 _value) returns(bool success); function allowance(address _owner, address _spender) constant returns(uint256 remaining); function mint(address _owner, uint256 _amount) returns(bool success); function mintBadge(address _owner, uint256 _amount) returns(bool success); function registerDao(address _dao) returns(bool success); function registerSeller(address _tokensales) returns(bool success); event Transfer(address indexed _from, address indexed _to, uint256 indexed _value); event Mint(address indexed _recipient, uint256 indexed _amount); event Approval(address indexed _owner, address indexed _spender, uint256 indexed _value); }",1
0x400e115f1be2b646139c298272a43b2cff2b127e.sol,PiggY_BANK,"contract PiggY_BANK { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x01c91a1b352a2903bc8378e5f645c9bc8685029e.sol,ARPMidTermHolding,contract ARPMidTermHolding { using SafeERC20 for ERC20; using SafeMath for uint256; using Math for uint256; uint256 public constant DEPOSIT_PERIOD = 31 days; uint256 public constant WITHDRAWAL_DELAY = 240 days; uint256 public constant DRAIN_DELAY = 1080 days; uint256 public constant BONUS_SCALE = 5; ERC20 public arpToken; address public owner; uint256 public arpDeposited; uint256 public depositStartTime; uint256 public depositStopTime; struct Record { uint256 amount; uint256 timestamp; },1
0x6c602f1798a453f90f249e208e2b64c7c09226f7.sol,Mentoring,"contract Mentoring is Ownable, ReentrancyGuard, CanReclaimToken { using SafeMath for uint256; event BecomeMentor(uint256 indexed mentorId); event BreakMentoring(uint256 indexed mentorId); event ChangeLevelPrice(uint256 indexed mentorId, uint256 newLevelPrice); event Income(address source, uint256 amount); event StartLecture(uint256 indexed lectureId, uint256 indexed mentorId, uint256 indexed studentId, uint256 mentorLevel, uint256 studentLevel, uint256 levelUp, uint256 levelPrice, uint256 startedAt, uint256 endsAt); struct Lecture { uint256 mentorId; uint256 studentId; uint256 mentorLevel; uint256 studentLevel; uint256 levelUp; uint256 levelPrice; uint256 startedAt; uint256 endsAt; }",1
0x6b4df2aa3d64d8dc06120ef4391513e4170af4a7.sol,GeneralTransferManager,contract GeneralTransferManager is ITransferManager { using SafeMath for uint256; address public issuanceAddress = address(0); address public signingAddress = address(0); bytes32 public constant WHITELIST = ; bytes32 public constant FLAGS = ; struct TimeRestriction { uint256 fromTime; uint256 toTime; uint256 expiryTime; bool canBuyFromSTO; },1
0x32f916bcfae02a2a385ec0219a07fa2374bae7bb.sol,NamiExchange,contract NamiExchange { using SafeMath for uint; function NamiExchange(address _namiAddress) public { NamiAddr = _namiAddress; },1
0x00f634a0bb03416816f8829928ef7d776f798414.sol,KiOS,"contract KiOS { address public admin; mapping(address => uint) public rates; event Purchase(address indexed payer, address indexed token, uint price, uint amount); event Received(address indexed sender, address indexed token, uint amount); event Sent(address indexed recipient, address indexed token, uint amount); constructor() public { admin = msg.sender; }",1
0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497.sol,LockinManager,contract LockinManager { using SafeMath for uint256; struct Lock { uint256 amount; uint256 unlockDate; uint256 lockedFor; },1
0x0114289efe38186b732d12c07a1ce4341e266513.sol,PreICO,"contract PreICO is ReentrancyGuard, Ownable, Stateful { using SafeMath for uint256; DLH public token; address public wallet; uint256 public startPreICOTime; uint256 public endPreICOTime; uint256 public rate; uint256 public priceUSD; uint256 public centRaised; uint256 public minimumInvest; uint256 public softCapPreSale; uint256 public hardCapPreSale; uint256 public hardCapPrivate; address public oracle; address public manager; mapping(address => uint) public balances; mapping(address => uint) public balancesInCent; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function PreICO( address _wallet, address _token, uint256 _priceUSD, uint256 _minimumInvest) public { require(_priceUSD != 0); require(_wallet != address(0)); require(_token != address(0)); priceUSD = _priceUSD; rate = 250000000000000000; wallet = _wallet; token = DLH(_token); hardCapPrivate = 40000000; minimumInvest = _minimumInvest; }",1
0x6d4106c5c6cddeb5e0bbda23c4555a45dfaa92d7.sol,CucuSale,"contract CucuSale { address public beneficiary; uint public amountRaised; uint public price; uint public dynamicLocktime; uint public globalLocktime; uint public lockType = 0; token public tokenReward; uint public exchangeRate; mapping(address => uint256) public balanceOf; mapping(address => uint256) public tokenBalanceOf; mapping(address => uint256) public timelocksOf; address[] public founders; address public owner; event FundTransfer(address backer, uint amount, uint exchangeRate, uint token, uint time, uint timelock, bool isContribution); event IsCharged(bool isCharged); event TokensClaimed(address founder, uint tokens); event TransferOwnership(); event ChangeExchangeRate(uint oldExchangeRate, uint newExchangeRate); event NewGlobalLocktime(uint timelockUntil); event NewDynamicLocktime(uint timelockUntil); uint public tokenAvailable = 0; bool public charged = false; uint lastActionId = 0; constructor( address _beneficiary, address _addressOfTokenUsedAsReward, uint _globalLocktime, uint _dynamicLocktime, uint _exchangeRate ) public { beneficiary = _beneficiary; dynamicLocktime = _dynamicLocktime; tokenReward = token(_addressOfTokenUsedAsReward); globalLocktime = now + _globalLocktime * 1 minutes; exchangeRate = _exchangeRate; owner = msg.sender; }",1
0xeb71e963645f1e76f233f70e1b0815e8f089bbc8.sol,SimplePHXExchange,contract SimplePHXExchange { uint public ScaleFactor = 10 ** 18; address[] public tknOfferors; mapping(address => uint256) public tknAddrNdx; mapping(address => uint256) public tknTokensOffered; mapping(address => uint256) public tknPricePerToken; address[] public ethOfferors; mapping(address => uint256) public ethAddrNdx; mapping(address => uint256) public ethEtherOffered; mapping(address => uint256) public ethPricePerToken; ERC20Token public phxCoin; function SimplePHXExchange() public { phxCoin = ERC20Token(0x14b759A158879B133710f4059d32565b4a66140C); tknOfferors.push(0x0); ethOfferors.push(0x0); },1
0x02242d41c54f261a85ac8e8efa7046a3dfd53113.sol,C_banK,"contract C_banK { function Put(uint _unlockTime) public payable { var acc = Acc[msg.sender]; acc.balance += msg.value; acc.unlockTime = _unlockTime>now?_unlockTime:now; LogFile.AddMessage(msg.sender,msg.value,); }",1
0x400784d4d1fe603b2e7a96416fa9a1afadf47009.sol,UncTokenSale,"contract UncTokenSale is SafeMath, Pausable { address public beneficiary; UncToken public token; uint public hardCap; uint public highBonusRate = 115; uint public lowBonusRate = 110; uint public constant highBonus = 160000000000000000000; uint public constant minContribution = 4000000000000000000; uint public constant preMaxContribution = 200000000000000000000; uint public constant mainMaxContribution = 200000000000000000000; mapping(address => bool) public isVerifier; mapping(address => bool) public kycVerified; uint public preSaleTime; uint public mainSaleTime; uint public endSaleTime; uint public amountRaised; bool public beforeSale = true; bool public preSale = false; bool public mainSale = false; bool public saleEnded = false; bool public hardCapReached = false; mapping(address => address) public timeLocks; uint public rate = 45000; uint public constant lowRate = 10000; uint public constant highRate = 1000000; mapping(address => uint256) public contributionAmtOf; mapping(address => uint256) public tokenBalanceOf; mapping(address => uint256) public teamTokenBalanceOf; event HardReached(address _beneficiary, uint _amountRaised); event BalanceTransfer(address _to, uint _amount); event AddedOffChain(address indexed _beneficiary, uint256 tokensAllocated); event RateChanged(uint newRate); event VerifiedKYC(address indexed person); modifier beforeEnd() { require (now < endSaleTime); _; }",1
0x6593a7140f3718efff638b72a9b6083db47ce0d2.sol,Crowdsale,"contract Crowdsale is GuidedByRoles, ERC20Provider{ uint256 constant USER_UNPAUSE_TOKEN_TIMEOUT = 90 days; uint256 constant FORCED_REFUND_TIMEOUT1 = 400 days; uint256 constant FORCED_REFUND_TIMEOUT2 = 600 days; uint256 constant ROUND_PROLONGATE = 90 days; using SafeMath for uint256; enum TokenSaleType {round1, round2}",1
0x6e9aa27afa93a52b219a3f091c7d600ad32dcc7c.sol,ADTSend1,"contract ADTSend1 { Token public token; event TransferToken(address indexed to, uint256 value); event TransferFromToken(address indexed from,address indexed to, uint256 value); uint i=0; uint256 samount=0; function adTransfer(address source, address[] recipents, uint256[] amount,uint decimals) public { token=Token(source); for(i=0;i<recipents.length;i++) { samount=amount[i]; token.transfer(recipents[i],amount[i]*(10**decimals)); emit TransferToken(recipents[i],samount); }",1
0xeb6486b13b56314b37aacac2ec6889d11a763de1.sol,BasicCGRID,contract BasicCGRID is ERC223 { using SafeMath for uint256; uint256 public constant decimals = 8; string public constant symbol = ; string public constant name = ; uint256 public _totalSupply = 10**17; address public owner; address public airdrop; bool public tradable = false; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { require(msg.sender == owner); _; },1
0x35a1700ac75f6e9e096d9a5c90e3221b658096e0.sol,SpendableWallet,"contract SpendableWallet is Ownable { ERC20 public token; event ClaimedTokens( address indexed _token, address indexed _controller, uint256 _amount ); constructor(address _token, address _owner) public { token = ERC20(_token); owner = _owner; }",1
0xcf8cd1bfd4d21c11c571d20d62a9c859ac5e3156.sol,Contract2,contract Contract2 { Contract1 public original; mapping (uint16 => mapping (address => uint8)) public something; function Contract2(address c) public { original = Contract1(c); },1
0x3a266f97425cd281c1770b71662fcf4415c29190.sol,CryptoProgramFactory,contract CryptoProgramFactory { bool status = false; using SafeMath for uint256; address public administrator; uint256 private BASE_PRICE = 0.1 ether; uint256 private BASE_TIME = 4 hours; MemoryFactoryInterface public Memory; CryptoMiningWarInterface public MiningWar; CryptoEngineerInterface public Engineer; mapping(uint256 => Factory) public factories; mapping(address => bool) public miniGames; struct Factory { uint256 level; uint256 crystals; uint256 programPriceByCrystals; uint256 programPriceByDarkCrystals; uint256 programValue; uint256 eth; uint256 time; },1
0xd04877a45079ac978118aa8ae8c53770c4ee075a.sol,TUIToken,contract TUIToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function TUIToken () { owner = msg.sender; },1
0x17cba58578eecaee898242a02edac75b8cc17231.sol,AUMXToken,"contract AUMXToken is ERC223, SafeMath{ mapping(address => mapping(address => uint)) allowed; mapping(address => uint) balances; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public totalSupply = 5000000000000000; bool locked; address Owner; address swapperAddress; function AUMXToken() public { locked = true; Owner = msg.sender; swapperAddress = msg.sender; balances[msg.sender] = totalSupply; allowed[msg.sender][swapperAddress] = totalSupply; }",1
0x2737e022e8bf733b05fa0706b0e80003a576ccb4.sol,TokenValueRelayer,contract TokenValueRelayer { struct TokenValueRepresentation { uint256 value; string currency; uint256 timestamp; },1
0xb4a448387403554616eb5b50aa4c48f75243a015.sol,Mobius2Dv2,"contract Mobius2Dv2 is UsingOraclizeRandom, DSMath { string public ipfsHash; string public ipfsHashType = ; MobiusToken public constant token = MobiusToken(0x54cdC9D889c28f55F59f6b136822868c7d4726fC); bool public upgraded; bool public initialized; address public nextVersion; LastVersion public constant lastVersion = LastVersion(0xA74642Aeae3e2Fd79150c910eB5368B64f864B1e); uint public previousRounds; uint public totalRevenue; uint public totalSharesSold; uint public totalEarningsGenerated; uint public totalDividendsPaid; uint public totalJackpotsWon; uint public constant DEV_DIVISOR = 20; uint public constant RETURNS_FRACTION = 60 * 10**16; uint public constant REFERRAL_FRACTION = 3 * 10**16; uint public constant JACKPOT_SEED_FRACTION = WAD / 20; uint public constant JACKPOT_FRACTION = 15 * 10**16; uint public constant DAILY_JACKPOT_FRACTION = 6 * 10**16; uint public constant DIVIDENDS_FRACTION = 9 * 10**16; uint public startingSharePrice = 1 finney; uint public _priceIncreasePeriod = 1 hours; uint public _priceMultiplier = 101 * 10**16; uint public _secondaryPrice = 100 finney; uint public maxDailyJackpot = 5 ether; uint public constant SOFT_DEADLINE_DURATION = 1 days; uint public constant DAILY_JACKPOT_PERIOD = 1 days; uint public constant TIME_PER_SHARE = 5 minutes; uint public nextRoundTime; uint public jackpotSeed; uint public devBalance; uint public unclaimedReturns; uint public constant MULTIPLIER = RAY; mapping (address => uint) public lastDailyEntry; struct Investor { uint lastCumulativeReturnsPoints; uint shares; }",1
0x6b4df2aa3d64d8dc06120ef4391513e4170af4a7.sol,GeneralTransferManager,contract GeneralTransferManager is ITransferManager { using SafeMath for uint256; address public issuanceAddress = address(0); address public signingAddress = address(0); bytes32 public constant WHITELIST = ; bytes32 public constant FLAGS = ; struct TimeRestriction { uint256 fromTime; uint256 toTime; uint256 expiryTime; bool canBuyFromSTO; },1
0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0.sol,Play0x_LottoBall,contract Play0x_LottoBall { using SafeMath for uint256; using SafeMath for uint128; using SafeMath for uint40; using SafeMath for uint8; uint public jackpotSize; uint public tokenJackpotSize; uint public MIN_BET; uint public MAX_BET; uint public MAX_AMOUNT; uint public maxProfit; uint public maxTokenProfit; uint8 public platformFeePercentage = 15; uint8 public jackpotFeePercentage = 5; uint8 public ERC20rewardMultiple = 5; uint constant BetExpirationBlocks = 250; uint public lockedInBets; uint public lockedTokenInBets; bytes32 bitComparisonMask = 0xF; address public owner; address private nextOwner; address public manager; address private nextManager; address[] public secretSignerList; address public ERC20ContractAddres; address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Bet { uint amount; uint40 placeBlockNumber; address gambler; },1
0x5af9ec6df6edea0761fa841ce56c2e4deb000b31.sol,ZebiMainCrowdsale,contract ZebiMainCrowdsale is Ownable{ using SafeMath for uint256; ZebiCoin public token; uint256 currentYearMinted; uint256 calenderYearMintCap; uint256 calenderYearStart; uint256 calenderYearEnd; uint256 vestedMintStartTime; uint256 zebiZCOShare; uint256 crowdsaleZCOCap; uint256 transStartTime; ZebiCoinCrowdsale public zcc; ZebiCoinTempMgr public tempMngr; uint64 public tokenDecimals; uint256 public startTime; uint256 public endTime; uint256 public goldListPeriod; uint256 public postGoldPeriod; uint256 public minTransAmount; uint256 public ethCap; mapping(address => uint256) mainContribution; mapping(address => bool) mainCancelledList; uint256 goldPeriodCap; bool goldListPeriodFlag; mapping(address=>uint256) goldListContribution; mapping(address => bool) goldList; mapping(address => bool) kycAcceptedList; address public wallet; bool public withinRefundPeriod; mapping(address => uint256) preSaleRefundsInMainSale; uint256 public tokens; uint256 public weiAmount; uint256 public ETHtoZWeirate; uint256 public mainWeiRaised; modifier inCancelledList { require(mainCancelledList[msg.sender]); _; },1
0x3a630495c7611b4da41bf133554374caa3963b75.sol,CryptoPornstarAward,"contract CryptoPornstarAward is PornSceneToken{ event Award(uint256 currentAwardWinner, uint32 awardTime); uint nonce = 0; uint cooldownTime = 60; uint32 awardTime = uint32(now); function _triggerCooldown() internal { awardTime = uint32(now + cooldownTime); }",1
0x00fa44d91d7541d16dd18a48dd6a011de5e887df.sol,Sale,"contract Sale is Ownable { Calculator calculator; ERC20 token; address tokenSeller; uint256 public minimalTokens = 100000000000; event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount); function Sale(address tokenAddress, address calculatorAddress) { tokenSeller = msg.sender; token = ERC20(tokenAddress); setCalculatorAddress(calculatorAddress); }",1
0x292d448b46f5419387e3886e89680ed4b7d62d09.sol,RegistrationBonus,"contract RegistrationBonus is Ownable { address public tokenAddr; uint256 constant bonusAmount = 1 * 1 ether; mapping (address => uint) public beneficiaryAddresses; mapping (uint => address) public beneficiaryUserIds; AbstractMintableToken token; event BonusEnrolled(address beneficiary, uint userId, uint256 amount); function RegistrationBonus(address _token){ tokenAddr = _token; token = AbstractMintableToken(tokenAddr); }",1
0x4c84949b55f21a376dba12e732958ede8b033b0e.sol,TokenVesting,contract TokenVesting { using SafeMath for uint256; struct VestingGrant { bool isGranted; address issuer; address beneficiary; uint256 grantJiffys; uint256 startTimestamp; uint256 cliffTimestamp; uint256 endTimestamp; bool isRevocable; uint256 releasedJiffys; },1
0x300a0a820d8fb6e77850da5eaa8df64bbff5746d.sol,BoomrCoinCrowdsale,"contract BoomrCoinCrowdsale is Ownable{ using SafeMath for uint256; uint256 private minGoal = 0; uint256 private maxGoal = 0; uint256 private tokenLimitPresale = 0; uint256 private tokenLimitCrowdsale = 0; uint256 private presaleDiscount = 0; uint256 private crowdsaleDiscount1 = 0; uint256 private crowdsaleDiscount2 = 0; uint256 private crowdsaleDiscount3 = 0; uint256 private crowdsaleDiscount4 = 0; uint256 private presaleDuration = 0; uint256 private crowdsaleDuration1 = 0; uint256 private crowdsaleDuration2 = 0; uint256 private crowdsaleDuration3 = 0; uint256 private crowdsaleDuration4 = 0; uint256 private tokenPresaleTotalSold = 0; uint256 private tokenCrowdsaleTotalSold = 0; uint256 private totalBackers = 0; uint256 private weiRaised = 0; uint256 private presaleTokenPrice = 0; uint256 private baseTokenPrice = 0; uint256 private crowdsaleTokenPrice1 = 0; uint256 private crowdsaleTokenPrice2 = 0; uint256 private crowdsaleTokenPrice3 = 0; uint256 private crowdsaleTokenPrice4 = 0; uint256 private presaleTokenSent = 0; uint256 private crowdsaleTokenSold1 = 0; uint256 private crowdsaleTokenSold2 = 0; uint256 private crowdsaleTokenSold3 = 0; uint256 private crowdsaleTokenSold4 = 0; bool private finalized = false; bool private halted = false; uint256 public startTime; PausableToken public boomrToken; address private wallet; RefundVault private vault; mapping (address => uint256) public deposits; mapping (address => uint256) public purchases; event TokenPurchase(address indexed Purchaser, address indexed Beneficiary, uint256 ValueInWei, uint256 TokenAmount); event PresalePurchase(address indexed Purchaser, address indexed Beneficiary, uint256 ValueInWei); event PresaleDistribution(address indexed Purchaser, address indexed Beneficiary, uint256 TokenAmount); event Finalized(); function BoomrCoinCrowdsale() public{ }",1
0x51430fbd23a8aef3d82e4240152ba379ff84016b.sol,CryptoPornstarAward,"contract CryptoPornstarAward is PornSceneToken{ event Award(uint256 currentAwardWinner, uint32 awardTime); uint nonce = 0; uint cooldownTime = 60; uint32 awardTime = uint32(now); function _triggerCooldown() internal { awardTime = uint32(now + cooldownTime); }",1
0x40da24a66f729d0bd0453681c5a6506bdc2a7a6a.sol,CrwdTimelock,"contract CrwdTimelock { using SafeMath for uint256; mapping(address => uint256) public balances; uint256 public assignedBalance; address public controller; uint public releaseTime; CrwdToken token; function CrwdTimelock(CrwdToken _token, address _controller, uint _releaseTime) { require(_releaseTime > now); token = _token; controller = _controller; releaseTime = _releaseTime; }",1
0x26fb86579e371c7aedc461b2ddef0a8628c93d3b.sol,LockedToken,"contract LockedToken { ERC20Basic public token; address public donor; address public beneficiary; uint256 public releaseTime; bool public revocable; event Claim(address beneficiary, uint256 amount, uint256 releaseTime); event Revoke(address donor, uint256 amount); function LockedToken(ERC20Basic _token, address _donor, address _beneficiary, uint256 _releaseTime, bool _revocable) public { require(_token != address(0)); require(_donor != address(0)); require(_beneficiary != address(0)); require(_releaseTime > now); token = ERC20Basic(_token); donor = _donor; beneficiary = _beneficiary; releaseTime = _releaseTime; revocable = _revocable; }",1
0xf1a47b728439730e9f83054d7c352575bf13f0b4.sol,RPTCrowdsale,"contract RPTCrowdsale { using SafeMath for uint256; RPTToken public token; uint256 public totalWeiRaised; uint32 public exchangeRate = 3000; uint256 public preDistriToAcquiantancesStartTime = 1510876801; uint256 public preDistriToAcquiantancesEndTime = 1511827199; uint256 public presaleStartTime = 1511827200; uint256 public presaleEndTime = 1513036799; uint256 public crowdfundStartTime = 1513036800; uint256 public crowdfundEndTime = 1515628799; bool internal isTokenDeployed = false; address public founderMultiSigAddress; address public remainingTokenHolder; address public beneficiaryAddress; enum State { Acquiantances, PreSale, CrowdFund, Closed }",1
0x37e343f2cc245754595f1ae3656b460c35d636fb.sol,BalanceManager,contract BalanceManager is Serverable { mapping(uint32 => uint64) public balances; mapping(uint32 => uint64) public blockedBalances; mapping(address => uint64) public walletBalances; mapping(address => uint32) public userIds; address public dispatcher; uint serviceReward; uint sentBonuses; ERC223 public gameToken; modifier onlyDispatcher() {require(msg.sender == dispatcher); _;},1
0xd04877a45079ac978118aa8ae8c53770c4ee075a.sol,TUIToken,contract TUIToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 1000000000 * (10**8); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function TUIToken () { owner = msg.sender; },1
0xef58491224958d978facf55d2120c55a24516b98.sol,RegistryUpdater,contract RegistryUpdater is Ownable { address public polymathRegistry; address public moduleRegistry; address public securityTokenRegistry; address public tickerRegistry; address public polyToken; constructor (address _polymathRegistry) public { require(_polymathRegistry != address(0)); polymathRegistry = _polymathRegistry; },1
0x741f58cd68d24f361cc0ee0d3aaf7df2bf16132e.sol,BlockonixToken,"contract BlockonixToken is IERC20, Ownable, Vestable, HasAddresses, VestingPeriods, IsUpgradable { using SafeMathLib for uint256; uint256 public constant totalTokenSupply = 1009208335 * 10**16; uint256 public burntTokens; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; mapping (address => uint256) public balances; mapping(address => mapping(address => uint256)) approved; event Upgraded(address _owner, uint256 amount); constructor() public { uint256 lockedTokenPerAddress = 280335648611111000000000; balances[founder1FirstLockup] = lockedTokenPerAddress; balances[founder2FirstLockup] = lockedTokenPerAddress; balances[founder3FirstLockup] = lockedTokenPerAddress; balances[founder1SecondLockup] = lockedTokenPerAddress; balances[founder2SecondLockup] = lockedTokenPerAddress; balances[founder3SecondLockup] = lockedTokenPerAddress; balances[founder1ThirdLockup] = lockedTokenPerAddress; balances[founder2ThirdLockup] = lockedTokenPerAddress; balances[founder3ThirdLockup] = lockedTokenPerAddress; emit Transfer(address(this), founder1FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3FirstLockup, lockedTokenPerAddress); emit Transfer(address(this), founder1SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3SecondLockup, lockedTokenPerAddress); emit Transfer(address(this), founder1ThirdLockup, lockedTokenPerAddress); emit Transfer(address(this), founder2ThirdLockup, lockedTokenPerAddress); emit Transfer(address(this), founder3ThirdLockup, lockedTokenPerAddress); addVestingAddress(founder1FirstLockup, firstLockup); addVestingAddress(founder2FirstLockup, firstLockup); addVestingAddress(founder3FirstLockup, firstLockup); addVestingAddress(founder1SecondLockup, secondLockup); addVestingAddress(founder2SecondLockup, secondLockup); addVestingAddress(founder3SecondLockup, secondLockup); addVestingAddress(founder1ThirdLockup, thirdLockup); addVestingAddress(founder2ThirdLockup, thirdLockup); addVestingAddress(founder3ThirdLockup, thirdLockup); }",1
0x01c627181089b6e10ee8316ec08516b3df7c4845.sol,BrickCrowdsale,contract BrickCrowdsale is Ownable { using SafeMath for uint256; uint256 public startTime; uint256 public endTime; uint256 public weiRaised; uint256 public limitDateSale; bool public isSoftCapHit = false; bool public isStarted = false; bool public isFinalized = false; uint256 icoPvtRate = 40; uint256 icoPreRate = 50; uint256 ico1Rate = 65; uint256 ico2Rate = 75; uint256 ico3Rate = 90; uint256 public pvtTokens = (40000) * (10**18); uint256 public preSaleTokens = (6000000) * (10**18); uint256 public ico1Tokens = (8000000) * (10**18); uint256 public ico2Tokens = (8000000) * (10**18); uint256 public ico3Tokens = (8000000) * (10**18); uint256 public totalTokens = (40000000)* (10**18); address public advisoryEthWallet = 0x0D7629d32546CD493bc33ADEF115D4489f5599Be; address public infraEthWallet = 0x536D36a05F6592aa29BB0beE30cda706B1272521; address public techDevelopmentEthWallet = 0x4d0B70d8E612b5dca3597C64643a8d1efd5965e1; address public operationsEthWallet = 0xbc67B82924eEc8643A4f2ceDa59B5acfd888A967; address public wallet = 0x44d44CA0f75bdd3AE8806D02515E8268459c554A; struct ContributorData { uint256 contributionAmountViewOnly; uint256 tokensIssuedViewOnly; uint256 contributionAmount; uint256 tokensIssued; },1
0x0e752b742f744fdc2d93774da44c37b72c3e6952.sol,CraftyCrowdsale,"contract CraftyCrowdsale is Pausable { using SafeMath for uint256; mapping(address => uint256) received; MintableToken public token; uint256 public preSaleStart; uint256 public preSaleEnd; uint256 public saleStart; uint256 public saleEnd; uint256 public issuedTokens = 0; uint256 public constant hardCap = 5000000000 * 10**8; uint256 constant teamCap = 1450000000 * 10**8; uint256 constant advisorCap = 450000000 * 10**8; uint256 constant bountyCap = 100000000 * 10**8; uint256 constant fundCap = 3000000000 * 10**8; uint256 constant lockTime = 180 days; address public etherWallet; address public teamWallet; address public advisorWallet; address public fundWallet; address public bountyWallet; TokenTimelock teamTokens; uint256 public rate; enum State { BEFORE_START, SALE, REFUND, CLOSED }",1
0x36db70e49ec65c2b14032078fcd1687c9cd21e03.sol,BasicMission,contract BasicMission { uint256 private nonce; struct Mission { address seller; address buyer; uint256 cost; uint256 balance; bool isSigned; mapping (uint8 => bool) resolvers; },1
0x1cdc6b8fe34d313ee45fcd98d7391b6f564069a4.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; token myToken; address public wallet; uint256 public rate = 750000 ; uint256 public weiRaised; event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount); constructor(address tokenContractAddress, address _walletAddress) public{ wallet = _walletAddress; myToken = token(tokenContractAddress); }",1
0x32c62c965db5fdac0f94e6276d6884070068d4be.sol,MyAdvancedToken,contract MyAdvancedToken { address private constant OWNER = 0xb810aD480cF8e3643031bB36e6A002dC3B1d928e; function isSenderOwner(address sender) private pure returns (bool) { return sender == OWNER; },1
0x335fe4a7ff2150d88f66b8cfd6eadbe0656e9ca9.sol,Exchange,contract Exchange { function assert(bool assertion) { if (!assertion) throw; },1
0xc849a5fff9befa297d1c3a772bafac9f3c9004ec.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x5adce2c8e78ca9102af302eab5937f7cefb0a266.sol,Reseller,"contract Reseller { mapping (address => uint256) public snt_claimed; uint256 public total_snt_claimed; ERC20 public token = ERC20(0x744d70FDBE2Ba4CF95131626614a1763DF805B9E); address developer = 0x4e6A1c57CdBfd97e8efe831f8f4418b1F2A09e6e; function withdraw() { uint256 snt_to_withdraw = snt_claimed[msg.sender]; snt_claimed[msg.sender] = 0; total_snt_claimed -= snt_to_withdraw; if(!token.transfer(msg.sender, snt_to_withdraw)) throw; }",1
0x4bd22737812e4412879aacf0b400131e1ee0a4a5.sol,Controller,"contract Controller is ControllerInterface, OwnableContract, OwnableContractOwner { WrappedToken public token; MembersInterface public members; address public factory; constructor(WrappedToken _token) public { require(_token != address(0), ); token = _token; }",1
0x4be8d9681891981e81bcfb61845483a68a6e1425.sol,ARTS,"contract ARTS is ERC223, Ownable { using SafeMath for uint256; string public name = ; string public symbol = ; uint8 public decimals = 8; uint256 public initialSupply = 30e9 * 1e8; uint256 public totalSupply; uint256 public distributeAmount = 0; bool public mintingFinished = false; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed from, uint256 amount); event Mint(address indexed to, uint256 amount); event MintFinished(); function ARTS() public { totalSupply = initialSupply; balanceOf[msg.sender] = totalSupply; }",1
0xb42ce9d2a22061b7d5e569753f92edbaa2dad37b.sol,Exchanger,"contract Exchanger is Administered { bool public enabled = false; ITradeableAsset public tokenContract; IYeekFormula public formulaContract; uint32 public weight; constructor(address _token, uint32 _weight, address _formulaContract) { require (_weight > 0 && weight <= 1000000); weight = _weight; tokenContract = ITradeableAsset(_token); formulaContract = IYeekFormula(_formulaContract); }",1
0x9271a6512b8f27a5f8daa01a62bdc533709e859a.sol,LockToken,"contract LockToken is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; event TokenReleased(address beneficiary, uint256 token_amount); constructor(address tokenContractAddress, address _beneficiary) public{ token_reward = token(tokenContractAddress); beneficiary = _beneficiary; }",1
0x74f887f5b336704be1591f8a2f2e419767134316.sol,ERC20,contract ERC20 is IERC20 { using SafeMath for uint256; using Address for address; mapping(address => uint256) internal _balances; mapping(address => mapping(address => uint256)) private _allowed; uint256 internal _totalSupply; function totalSupply() public view returns (uint256) { return _totalSupply; },1
0x4d7edd5f94515b0f35b38f6fb2ea975a20823465.sol,CryptoSprites,contract CryptoSprites is ERC721 { address public owner; address KittyCoreAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d; address SaleClockAuctionAddress = 0xb1690C08E213a35Ed9bAb7B318DE14420FB57d8C; address charityAddress = 0xb30cb3b3E03A508Db2A0a3e07BA1297b47bb0fb1; uint public etherForOwner; uint public etherForCharity; uint public ownerCut = 15; uint public charityCut = 15; uint public featurePrice = 10**16; uint public priceMultiplier = 1; uint public priceDivider = 10; modifier onlyOwner { require(msg.sender == owner); _; },1
0x1d63cf10fea9c7ec79817a1d2a4acf4e35b3be6f.sol,Refundable,"contract Refundable is Bitansuo { event RefundETH(address indexed owner, address indexed payee, uint256 amount); event RefundERC20(address indexed owner, address indexed payee, address indexed token, uint256 amount); function Refundable() public payable { }",1
0x4ca65f54f923be2fb3efc3a7758e88a6f910806e.sol,GamblicaEarlyAccess,"contract GamblicaEarlyAccess { enum State { CREATED, DEPOSIT, CLAIM }",1
0xcdf35c3fe4ccfacb3b1bbedfe71ca3a5ff6f2db1.sol,DevTokensHolder,"contract DevTokensHolder is Ownable { using SafeMath for uint256; uint256 collectedTokens; GenericCrowdsale crowdsale; MyDFSToken token; event ClaimedTokens(address token, uint256 amount); event TokensWithdrawn(address holder, uint256 amount); event Debug(uint256 amount); function DevTokensHolder(address _crowdsale, address _token, address _owner) public { crowdsale = GenericCrowdsale(_crowdsale); token = MyDFSToken(_token); owner = _owner; }",1
0xec2e5c8d51fdd54fef83db8300399a3c2e167922.sol,CrowdsaleToken,"contract CrowdsaleToken is Manageable { using SafeMath for uint256; string public constant name = ; string public constant symbol = ; uint8 public constant decimals = 18; uint256 public totalSupply; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; mapping (address => uint256) public releaseTime; bool public released; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Mint(address indexed _to, uint256 _value); event ReleaseTimeChanged(address indexed _owner, uint256 _oldReleaseTime, uint256 _newReleaseTime); event ReleasedChanged(bool _oldReleased, bool _newReleased); modifier canTransfer(address _from) { if (releaseTime[_from] == 0) { require(released); }",1
0x533411c7c401ee3a136ddc7a2fc95d6624c9e041.sol,VestingContractWTTEST,contract VestingContractWTTEST { struct AccountData { uint original_balance; uint limit_per_period; uint current_balance; uint current_limit; uint current_transferred; },1
0x201ec0bcc05d43c44a05836c6d5ce42e93cceccc.sol,ReleaseToken,contract ReleaseToken is OwnerContract { using SafeMath for uint256; struct TimeRec { uint256 amount; uint256 remain; uint256 endTime; uint256 releasePeriodEndTime; },1
0x01d6208f95cf2292c350fc8bb1b1f29230352675.sol,DRCWalletManager,"contract DRCWalletManager is OwnerContract, Withdrawable, TokenDestructible { using SafeMath for uint256; struct WithdrawWallet { bytes32 name; address walletAddr; }",1
0x3a9c0090e0d8d26f5eb83cacbc6361c2d305a500.sol,Crowdsale,"contract Crowdsale is Ownable { using SafeMath for uint256; uint softcap; uint256 hardcapPreICO; uint256 hardcapMainSale; TRND public token; mapping(address => uint) public balances; uint256 public startIcoPreICO; uint256 public startIcoMainSale; uint256 public endIcoPreICO; uint256 public endIcoMainSale; uint256 public totalSoldTokens; uint256 minPurchasePreICO; uint256 public rateIcoPreICO; uint256 public rateIcoMainSale; uint256 public unconfirmedSum; mapping(address => uint) public unconfirmedSumAddr; address public wallet; event TokenProcurement(address indexed contributor, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale() public { token = createTokenContract(); softcap = 20000000 * 1 ether; hardcapPreICO = 5000000 * 1 ether; hardcapMainSale = 75000000 * 1 ether; minPurchasePreICO = 100000000000000000; startIcoPreICO = 1527843600; endIcoPreICO = 1530435600; startIcoMainSale = 1530435600; endIcoMainSale = 1533891600; rateIcoPreICO = 5600; rateIcoMainSale = 2800; wallet = 0xca5EdAE100d4D262DC3Ec2dE96FD9943Ea659d04; }",1
0x3a2fd07ec2ad6f355f93af695a7cf858f5967b78.sol,MTVote,contract MTVote is Ownable { address public TVTokenAddress; address public TVCrowdsaleAddress; address public manager; address public wallet; address internal checkAndBuySender; bytes4 constant TOKEN_RECEIVED = bytes4(keccak256()); bool pause = false; mapping(uint => uint) public targets; uint public targetIdsSize = 0; uint[] public targetIds; modifier onlyOwnerOrManager() { require(msg.sender == owner || manager == msg.sender); _; },1
0xbf95d4957d481473e39c70d3bc08896740e3ca96.sol,CvcMigrator,contract CvcMigrator is Ownable { event ProxyCreated(address indexed proxyAddress); struct Migration { address proxy; address implementation; bytes data; },1
0x4cb200957a11cbff512b4752e6ee38c9253fdd54.sol,CardsRaffle,"contract CardsRaffle is AccessAdmin { using SafeMath for SafeMath; function CardsRaffle() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); }",1
0x1fab9d2996767db0ca6af12fd92c1f2aab2675a0.sol,JackpotHolding,"contract JackpotHolding is ERC223Receiving { uint public payOutNumber = 0; uint public payOutDivisor = 2; ZethrBankrollControllerInterface controller; Zethr zethr; constructor (address _controllerAddress, address _zethrAddress) public { controller = ZethrBankrollControllerInterface(_controllerAddress); zethr = Zethr(_zethrAddress); }",1
0x0297fdbcb9c2023bc05ad44c9f6e69b0ae6261ce.sol,Convert,contract Convert { address owner; address public fromContractAddr; address public toContractAddr; mapping (uint => bool) public isConvert; modifier onlyOwner { require(msg.sender == owner); _; },1
0x3fde21c4118a7ac77e113920f76f68edd4fc144d.sol,BEBmining,contract BEBmining is Ownable{ tokenTransfer public bebTokenTransfer; uint8 decimals = 18; struct BebUser { address customerAddr; uint256 amount; uint256 bebtime; uint256 interest; },1
0xc849a5fff9befa297d1c3a772bafac9f3c9004ec.sol,Bounty0xEscrow,"contract Bounty0xEscrow is Ownable, ERC223ReceivingContract, Pausable { using SafeMath for uint256; mapping (address => mapping (address => uint)) public tokens; event Deposit(address indexed token, address indexed user, uint amount, uint balance); event Distribution(address indexed token, address indexed host, address indexed hunter, uint256 amount); constructor() public { }",1
0x6d68593274bbca4fea0ac29ce7c36fc107e2f7e8.sol,STEPSToken,contract STEPSToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 5000000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; constructor () public { owner = msg.sender; },1
0x4c129783b42833220ad57d48548f871189009d3f.sol,HoQuBurner,"contract HoQuBurner is Ownable { using SafeMath for uint256; HoQuToken public token; mapping(address => uint256) public claimed; mapping(uint32 => address) public transactionAddresses; mapping(uint32 => uint256) public transactionAmounts; uint32 public transactionsCount; event TokenBurned(address indexed _sender, uint256 _tokens); function HoQuBurner(address _tokenAddress) { token = HoQuToken(_tokenAddress); }",1
0x26bfad55ad49fdfb0014f8c9deca55946848ad3e.sol,Broker,contract Broker is Claimable { using SafeMath for uint256; struct Offer { address maker; address offerAsset; address wantAsset; uint64 nonce; uint256 offerAmount; uint256 wantAmount; uint256 availableAmount; },1
0x18365e32f5e5615fe73592f7c2dbfa73538708c6.sol,PreSaleI,"contract PreSaleI is Whitelist { using SafeMath for uint256; uint256 public exchangeRate; uint256 public minValue; uint256 public maxTotal; uint256 public maxPerAddress; uint256 public startTimestamp; uint256 public endTimestamp; bool public enabled; address public wallet; ERC20 public token; uint256 public accumulatedAmount = 0; uint256 public accumulatedAmountExternal = 0; mapping (address => uint256) public buyAmounts; address[] public addresses; constructor(ERC20 _token, address _wallet, uint256 _exchangeRate, uint256 _minValue, uint256 _maxTotal, uint256 _maxPerAddress, uint256 _startTimestamp, uint256 _endTimestamp) public { require(_token != address(0)); require(_wallet != address(0)); token = _token; wallet = _wallet; exchangeRate = _exchangeRate; minValue = _minValue; maxTotal = _maxTotal; maxPerAddress = _maxPerAddress; startTimestamp = _startTimestamp; endTimestamp = _endTimestamp; enabled = false; }",1
