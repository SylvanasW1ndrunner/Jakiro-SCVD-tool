file,function,start,end,code,graph,RE,IO,TO,SAFE,expression
./0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a_ext.sol,BitSTDView.migration,451,455,"TMP_152(bool) = HIGH_LEVEL_CALL, dest:logic(BitSTDLogic), function:migration, arguments:['msg.sender', 'addr']  ,TMP_153(bool) = TMP_152 == True,CONDITION TMP_153,TMP_154(uint256) = HIGH_LEVEL_CALL, dest:logic(BitSTDLogic), function:getOldBalanceOf, arguments:['addr']  ,Emit Transfer(msg.sender,addr,TMP_154)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
logic.migration(msg.sender,addr) == true

IRs:
TMP_152(bool) = HIGH_LEVEL_CALL, dest:logic(BitSTDLogic), function:migration, arguments:['msg.sender', 'addr']  
TMP_153(bool) = TMP_152 == True
CONDITION TMP_153""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Transfer(msg.sender,addr,logic.getOldBalanceOf(addr))

IRs:
TMP_154(uint256) = HIGH_LEVEL_CALL, dest:logic(BitSTDLogic), function:getOldBalanceOf, arguments:['addr']  
Emit Transfer(msg.sender,addr,TMP_154)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",1,0,0,0,"logic.migration(msg.sender,addr) == true;Transfer(msg.sender,addr,logic.getOldBalanceOf(addr));"
./0x6dbc5978711cb22d7ba611bc18cec308ea12ea95_ext.sol,PublicResolver.setPubkey,124,127,"REF_7(PublicResolver.Record) -> records[node],REF_8(PublicResolver.PublicKey) -> REF_7.pubkey,TMP_10(PublicResolver.PublicKey) = new PublicKey(x,y),REF_8(PublicResolver.PublicKey) (->records) := TMP_10(PublicResolver.PublicKey),Emit PubkeyChanged(node,x,y),MODIFIER_CALL, PublicResolver.onlyOwner(bytes32)(node)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
records[node].pubkey = PublicKey(x,y)

IRs:
REF_7(PublicResolver.Record) -> records[node]
REF_8(PublicResolver.PublicKey) -> REF_7.pubkey
TMP_10(PublicResolver.PublicKey) = new PublicKey(x,y)
REF_8(PublicResolver.PublicKey) (->records) := TMP_10(PublicResolver.PublicKey)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
PubkeyChanged(node,x,y)

IRs:
Emit PubkeyChanged(node,x,y)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner(node)

IRs:
MODIFIER_CALL, PublicResolver.onlyOwner(bytes32)(node)""];
3->1;
}
",1,0,0,0,"onlyOwner(node);records[node].pubkey = PublicKey(x,y);PubkeyChanged(node,x,y)"
./0x730f8c40a08d02349a2d64e3193cf207a2a2dfe7_ext.sol,PG_Bank.Collect,15,28,"REF_5(PG_Bank.Holder) -> Acc[msg.sender],acc(PG_Bank.Holder) := REF_5(PG_Bank.Holder),REF_6(uint256) -> acc.balance,TMP_2(bool) = REF_6 >= MinSum,REF_7(uint256) -> acc.balance,TMP_3(bool) = REF_7 >= _am,TMP_4(bool) = TMP_2 && TMP_3,REF_8(uint256) -> acc.unlockTime,TMP_5(bool) = now > REF_8,TMP_6(bool) = TMP_4 && TMP_5,CONDITION TMP_6,TMP_8(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:_am ,CONDITION TMP_8,REF_11(uint256) -> acc.balance,REF_11(-> acc) = REF_11 - _am,HIGH_LEVEL_CALL, dest:LogFile(Log), function:AddMessage, arguments:['msg.sender', '_am', 'Collect']  ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
acc = Acc[msg.sender]

IRs:
REF_5(PG_Bank.Holder) -> Acc[msg.sender]
acc(PG_Bank.Holder) := REF_5(PG_Bank.Holder)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
acc.balance >= MinSum && acc.balance >= _am && now > acc.unlockTime

IRs:
REF_6(uint256) -> acc.balance
TMP_2(bool) = REF_6 >= MinSum
REF_7(uint256) -> acc.balance
TMP_3(bool) = REF_7 >= _am
TMP_4(bool) = TMP_2 && TMP_3
REF_8(uint256) -> acc.unlockTime
TMP_5(bool) = now > REF_8
TMP_6(bool) = TMP_4 && TMP_5
CONDITION TMP_6""];
2->3[label=""True""];
2->7[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
msg.sender.call.value(_am)()

IRs:
TMP_8(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:_am 
CONDITION TMP_8""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
acc.balance -= _am

IRs:
REF_11(uint256) -> acc.balance
REF_11(-> acc) = REF_11 - _am""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
LogFile.AddMessage(msg.sender,_am,Collect)

IRs:
HIGH_LEVEL_CALL, dest:LogFile(Log), function:AddMessage, arguments:['msg.sender', '_am', 'Collect']  ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: END_IF 7
""];
}
",1,0,0,0,"acc = Acc[msg.sender];acc.balance >= MinSum && acc.balance >= _am && now > acc.unlockTime;msg.sender.call.value(_am)();;acc.balance -= _am;;LogFile.AddMessage(msg.sender,_am,Collect)"
./0x541ac3dbde0712b1a121bdd5e8c506ae594a4631_ext.sol,XPTToken.refundTokens,355,361,"TMP_111(bool) = msg.sender == owner,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113 = CONVERT this to address,TMP_114(bool) = _token != TMP_113,TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114),TMP_116 = CONVERT _token to AbstractToken,token(AbstractToken) := TMP_116(AbstractToken),TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ,Emit RefundTokens(_token,_refund,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_111(bool) = msg.sender == owner
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_113 = CONVERT this to address
TMP_114(bool) = _token != TMP_113
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
token = AbstractToken(_token)

IRs:
TMP_116 = CONVERT _token to AbstractToken
token(AbstractToken) := TMP_116(AbstractToken)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(_refund,_value)

IRs:
TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RefundTokens(_token,_refund,_value)

IRs:
Emit RefundTokens(_token,_refund,_value)""];
}
",1,0,0,0,"require(bool)(msg.sender == owner);require(bool)(_token != address(this));token = AbstractToken(_token);token.transfer(_refund,_value);RefundTokens(_token,_refund,_value)"
./0xaa63c8683647ef91b3fdab4b4989ee9588da297b_ext.sol,DSProxy.execute,112,131,"TMP_27(address) = HIGH_LEVEL_CALL, dest:cache(DSProxyCache), function:read, arguments:['_code']  ,target(address) := TMP_27(address),TMP_28(bool) = target == 0,CONDITION TMP_28,TMP_29(address) = HIGH_LEVEL_CALL, dest:cache(DSProxyCache), function:write, arguments:['_code']  ,target(address) := TMP_29(address),TMP_30(bytes32) = INTERNAL_CALL, DSProxy.execute(address,bytes)(target,_data),response(bytes32) := TMP_30(bytes32),RETURN target,response","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
target = cache.read(_code)

IRs:
TMP_27(address) = HIGH_LEVEL_CALL, dest:cache(DSProxyCache), function:read, arguments:['_code']  
target(address) := TMP_27(address)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
target == 0x0

IRs:
TMP_28(bool) = target == 0
CONDITION TMP_28""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
target = cache.write(_code)

IRs:
TMP_29(address) = HIGH_LEVEL_CALL, dest:cache(DSProxyCache), function:write, arguments:['_code']  
target(address) := TMP_29(address)""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
response = execute(target,_data)

IRs:
TMP_30(bytes32) = INTERNAL_CALL, DSProxy.execute(address,bytes)(target,_data)
response(bytes32) := TMP_30(bytes32)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
(target,response)

IRs:
RETURN target,response""];
}
",1,0,0,0,"target = cache.read(_code);target == 0x0;target = cache.write(_code);;response = execute(target,_data);(target,response)"
./0x6a3f85f8a86e7b3de0269c20e9ab066dd57b8e21_ext.sol,AccRegCenter.transfer,111,115,"TMP_41 = CONVERT token to ERC20Basic,TMP_42(bool) = HIGH_LEVEL_CALL, dest:TMP_41(ERC20Basic), function:transfer, arguments:['to', 'val']  ,TMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42),Emit TransferTo(to,val),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(ERC20Basic(token).transfer(to,val))

IRs:
TMP_41 = CONVERT token to ERC20Basic
TMP_42(bool) = HIGH_LEVEL_CALL, dest:TMP_41(ERC20Basic), function:transfer, arguments:['to', 'val']  
TMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
TransferTo(to,val)

IRs:
Emit TransferTo(to,val)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
3->1;
}
",1,0,0,0,"onlyOwner();require(bool)(ERC20Basic(token).transfer(to,val));TransferTo(to,val)"
./0x4b96bf1fef93a216914fc843d81207a027ce52b3_ext.sol,VUULRVesting.withdrawVestedTokens,639,652,"REF_184(VUULRVesting.VestingSchedule) -> vestingSchedules[msg.sender],vestingSchedule(VUULRVesting.VestingSchedule) := REF_184(VUULRVesting.VestingSchedule),REF_185(uint256) -> vestingSchedule.tokens,TMP_368(bool) = REF_185 == 0,CONDITION TMP_368,TMP_369(uint256) = INTERNAL_CALL, VUULRVesting.vested(address)(msg.sender),_vested(uint256) := TMP_369(uint256),TMP_370(uint256) = INTERNAL_CALL, VUULRVesting.withdrawable(address)(msg.sender),_withdrawable(uint256) := TMP_370(uint256),REF_186(uint256) -> vestingSchedule.amountWithdrawn,REF_186(uint256) (->vestingSchedule) := _vested(uint256),TMP_371(bool) = _withdrawable > 0,CONDITION TMP_371,TMP_372(bool) = HIGH_LEVEL_CALL, dest:vestingToken(VUULRToken), function:transfer, arguments:['msg.sender', '_withdrawable']  ,TMP_373(None) = SOLIDITY_CALL require(bool)(TMP_372),Emit Withdraw(msg.sender,_withdrawable)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
vestingSchedule = vestingSchedules[msg.sender]

IRs:
REF_184(VUULRVesting.VestingSchedule) -> vestingSchedules[msg.sender]
vestingSchedule(VUULRVesting.VestingSchedule) := REF_184(VUULRVesting.VestingSchedule)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
vestingSchedule.tokens == 0

IRs:
REF_185(uint256) -> vestingSchedule.tokens
TMP_368(bool) = REF_185 == 0
CONDITION TMP_368""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
_vested = vested(msg.sender)

IRs:
TMP_369(uint256) = INTERNAL_CALL, VUULRVesting.vested(address)(msg.sender)
_vested(uint256) := TMP_369(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
_withdrawable = withdrawable(msg.sender)

IRs:
TMP_370(uint256) = INTERNAL_CALL, VUULRVesting.withdrawable(address)(msg.sender)
_withdrawable(uint256) := TMP_370(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
vestingSchedule.amountWithdrawn = _vested

IRs:
REF_186(uint256) -> vestingSchedule.amountWithdrawn
REF_186(uint256) (->vestingSchedule) := _vested(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
_withdrawable > 0

IRs:
TMP_371(bool) = _withdrawable > 0
CONDITION TMP_371""];
8->9[label=""True""];
8->11[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(vestingToken.transfer(msg.sender,_withdrawable))

IRs:
TMP_372(bool) = HIGH_LEVEL_CALL, dest:vestingToken(VUULRToken), function:transfer, arguments:['msg.sender', '_withdrawable']  
TMP_373(None) = SOLIDITY_CALL require(bool)(TMP_372)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Withdraw(msg.sender,_withdrawable)

IRs:
Emit Withdraw(msg.sender,_withdrawable)""];
10->11;
11[label=""Node Type: END_IF 11
""];
}
",1,0,0,0,"vestingSchedule = vestingSchedules[msg.sender];vestingSchedule.tokens == 0;;;_vested = vested(msg.sender);_withdrawable = withdrawable(msg.sender);vestingSchedule.amountWithdrawn = _vested;_withdrawable > 0;require(bool)(vestingToken.transfer(msg.sender,_withdrawable));;Withdraw(msg.sender,_withdrawable)"
./0x47fb9b34d4eca0ca1d25cafcb4924d8fc94e8170_ext.sol,FlexibleTokenSale.reclaimTokens,316,329,"TMP_169 = CONVERT this to address,TMP_170(uint256) = HIGH_LEVEL_CALL, dest:token(TokenTransfer), function:balanceOf, arguments:['TMP_169']  ,tokens(uint256) := TMP_170(uint256),TMP_171(bool) = tokens == 0,CONDITION TMP_171,RETURN False,TMP_172(bool) = HIGH_LEVEL_CALL, dest:token(TokenTransfer), function:transfer, arguments:['owner', 'tokens']  ,TMP_173(None) = SOLIDITY_CALL require(bool)(TMP_172),Emit TokensReclaimed(tokens),RETURN True,MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = token.balanceOf(address(this))

IRs:
TMP_169 = CONVERT this to address
TMP_170(uint256) = HIGH_LEVEL_CALL, dest:token(TokenTransfer), function:balanceOf, arguments:['TMP_169']  
tokens(uint256) := TMP_170(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
tokens == 0

IRs:
TMP_171(bool) = tokens == 0
CONDITION TMP_171""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3

EXPRESSION:
false

IRs:
RETURN False""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(token.transfer(owner,tokens))

IRs:
TMP_172(bool) = HIGH_LEVEL_CALL, dest:token(TokenTransfer), function:transfer, arguments:['owner', 'tokens']  
TMP_173(None) = SOLIDITY_CALL require(bool)(TMP_172)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
TokensReclaimed(tokens)

IRs:
Emit TokensReclaimed(tokens)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
8->1;
}
",1,0,0,0,"onlyOwner();tokens = token.balanceOf(address(this));tokens == 0;false;;require(bool)(token.transfer(owner,tokens));TokensReclaimed(tokens);true"
./0x2791528f5617e187a6d73c30034ac211b2f47042_ext.sol,CardsRaffle.awardRafflePrize,207,245,"TMP_70(bool) = raffleEndTime < block.timestamp,TMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70),TMP_72(bool) = raffleWinner == 0,TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72),TMP_74(address) = HIGH_LEVEL_CALL, dest:rare(RareInterface), function:getRareItemsOwner, arguments:['raffleRareId']  ,TMP_75(address) = INTERNAL_CALL, CardsRaffle.getRareAddress()(),TMP_76(bool) = TMP_74 == TMP_75,TMP_77(None) = SOLIDITY_CALL require(bool)(TMP_76),TMP_78 = UnaryType.BANG raffleWinningTicketSelected ,CONDITION TMP_78,INTERNAL_CALL, CardsRaffle.drawRandomWinner()(),TMP_80(bool) = checkWinner != 0,CONDITION TMP_80,REF_31(CardsRaffle.TicketPurchases) -> ticketsBoughtByPlayer[checkWinner],tickets(CardsRaffle.TicketPurchases) := REF_31(CardsRaffle.TicketPurchases),REF_32(uint256) -> tickets.numPurchases,TMP_81(bool) = REF_32 > 0,REF_33(uint256) -> tickets.numPurchases,TMP_82(bool) = checkIndex < REF_33,TMP_83(bool) = TMP_81 && TMP_82,REF_34(uint256) -> tickets.raffleRareId,TMP_84(bool) = REF_34 == raffleRareId,TMP_85(bool) = TMP_83 && TMP_84,CONDITION TMP_85,REF_35(CardsRaffle.TicketPurchase[]) -> tickets.ticketsBought,REF_36(CardsRaffle.TicketPurchase) -> REF_35[checkIndex],checkTicket(CardsRaffle.TicketPurchase) := REF_36(CardsRaffle.TicketPurchase),REF_37(uint256) -> checkTicket.startId,TMP_86(bool) = raffleTicketThatWon >= REF_37,REF_38(uint256) -> checkTicket.endId,TMP_87(bool) = raffleTicketThatWon <= REF_38,TMP_88(bool) = TMP_86 && TMP_87,CONDITION TMP_88,INTERNAL_CALL, CardsRaffle.assignRafflePrize(address)(checkWinner),i(uint256) := 0(uint256),REF_39(address[]) -> rafflePlayers[raffleRareId],REF_40 -> LENGTH REF_39,TMP_90(bool) = i < REF_40,CONDITION TMP_90,REF_41(address[]) -> rafflePlayers[raffleRareId],REF_42(address) -> REF_41[i],player(address) := REF_42(address),REF_43(CardsRaffle.TicketPurchases) -> ticketsBoughtByPlayer[player],playersTickets(CardsRaffle.TicketPurchases) := REF_43(CardsRaffle.TicketPurchases),REF_44(uint256) -> playersTickets.numPurchases,TMP_91(uint256) = REF_44 - 1,endIndex(uint256) := TMP_91(uint256),REF_45(CardsRaffle.TicketPurchase[]) -> playersTickets.ticketsBought,REF_46(CardsRaffle.TicketPurchase) -> REF_45[0],REF_47(uint256) -> REF_46.startId,TMP_92(bool) = raffleTicketThatWon >= REF_47,REF_48(CardsRaffle.TicketPurchase[]) -> playersTickets.ticketsBought,REF_49(CardsRaffle.TicketPurchase) -> REF_48[endIndex],REF_50(uint256) -> REF_49.endId,TMP_93(bool) = raffleTicketThatWon <= REF_50,TMP_94(bool) = TMP_92 && TMP_93,CONDITION TMP_94,j(uint256) := 0(uint256),REF_51(uint256) -> playersTickets.numPurchases,TMP_95(bool) = j < REF_51,CONDITION TMP_95,REF_52(CardsRaffle.TicketPurchase[]) -> playersTickets.ticketsBought,REF_53(CardsRaffle.TicketPurchase) -> REF_52[j],playerTicket(CardsRaffle.TicketPurchase) := REF_53(CardsRaffle.TicketPurchase),REF_54(uint256) -> playerTicket.startId,TMP_96(bool) = raffleTicketThatWon >= REF_54,REF_55(uint256) -> playerTicket.endId,TMP_97(bool) = raffleTicketThatWon <= REF_55,TMP_98(bool) = TMP_96 && TMP_97,CONDITION TMP_98,INTERNAL_CALL, CardsRaffle.assignRafflePrize(address)(player),TMP_100(uint256) := j(uint256),j(uint256) = j + 1,TMP_101(uint256) := i(uint256),i(uint256) = i + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(raffleEndTime < block.timestamp)

IRs:
TMP_70(bool) = raffleEndTime < block.timestamp
TMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(raffleWinner == 0)

IRs:
TMP_72(bool) = raffleWinner == 0
TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(rare.getRareItemsOwner(raffleRareId) == getRareAddress())

IRs:
TMP_74(address) = HIGH_LEVEL_CALL, dest:rare(RareInterface), function:getRareItemsOwner, arguments:['raffleRareId']  
TMP_75(address) = INTERNAL_CALL, CardsRaffle.getRareAddress()()
TMP_76(bool) = TMP_74 == TMP_75
TMP_77(None) = SOLIDITY_CALL require(bool)(TMP_76)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
! raffleWinningTicketSelected

IRs:
TMP_78 = UnaryType.BANG raffleWinningTicketSelected 
CONDITION TMP_78""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
drawRandomWinner()

IRs:
INTERNAL_CALL, CardsRaffle.drawRandomWinner()()""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
checkWinner != 0

IRs:
TMP_80(bool) = checkWinner != 0
CONDITION TMP_80""];
7->8[label=""True""];
7->16[label=""False""];
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
tickets = ticketsBoughtByPlayer[checkWinner]

IRs:
REF_31(CardsRaffle.TicketPurchases) -> ticketsBoughtByPlayer[checkWinner]
tickets(CardsRaffle.TicketPurchases) := REF_31(CardsRaffle.TicketPurchases)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
tickets.numPurchases > 0 && checkIndex < tickets.numPurchases && tickets.raffleRareId == raffleRareId

IRs:
REF_32(uint256) -> tickets.numPurchases
TMP_81(bool) = REF_32 > 0
REF_33(uint256) -> tickets.numPurchases
TMP_82(bool) = checkIndex < REF_33
TMP_83(bool) = TMP_81 && TMP_82
REF_34(uint256) -> tickets.raffleRareId
TMP_84(bool) = REF_34 == raffleRareId
TMP_85(bool) = TMP_83 && TMP_84
CONDITION TMP_85""];
9->10[label=""True""];
9->15[label=""False""];
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
checkTicket = tickets.ticketsBought[checkIndex]

IRs:
REF_35(CardsRaffle.TicketPurchase[]) -> tickets.ticketsBought
REF_36(CardsRaffle.TicketPurchase) -> REF_35[checkIndex]
checkTicket(CardsRaffle.TicketPurchase) := REF_36(CardsRaffle.TicketPurchase)""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
raffleTicketThatWon >= checkTicket.startId && raffleTicketThatWon <= checkTicket.endId

IRs:
REF_37(uint256) -> checkTicket.startId
TMP_86(bool) = raffleTicketThatWon >= REF_37
REF_38(uint256) -> checkTicket.endId
TMP_87(bool) = raffleTicketThatWon <= REF_38
TMP_88(bool) = TMP_86 && TMP_87
CONDITION TMP_88""];
11->12[label=""True""];
11->14[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
assignRafflePrize(checkWinner)

IRs:
INTERNAL_CALL, CardsRaffle.assignRafflePrize(address)(checkWinner)""];
12->13;
13[label=""Node Type: RETURN 13
""];
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->19;
17[label=""Node Type: BEGIN_LOOP 17
""];
17->20;
18[label=""Node Type: END_LOOP 18
""];
19[label=""Node Type: NEW VARIABLE 19

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
19->17;
20[label=""Node Type: IF_LOOP 20

EXPRESSION:
i < rafflePlayers[raffleRareId].length

IRs:
REF_39(address[]) -> rafflePlayers[raffleRareId]
REF_40 -> LENGTH REF_39
TMP_90(bool) = i < REF_40
CONDITION TMP_90""];
20->21[label=""True""];
20->18[label=""False""];
21[label=""Node Type: NEW VARIABLE 21

EXPRESSION:
player = rafflePlayers[raffleRareId][i]

IRs:
REF_41(address[]) -> rafflePlayers[raffleRareId]
REF_42(address) -> REF_41[i]
player(address) := REF_42(address)""];
21->22;
22[label=""Node Type: NEW VARIABLE 22

EXPRESSION:
playersTickets = ticketsBoughtByPlayer[player]

IRs:
REF_43(CardsRaffle.TicketPurchases) -> ticketsBoughtByPlayer[player]
playersTickets(CardsRaffle.TicketPurchases) := REF_43(CardsRaffle.TicketPurchases)""];
22->23;
23[label=""Node Type: NEW VARIABLE 23

EXPRESSION:
endIndex = playersTickets.numPurchases - 1

IRs:
REF_44(uint256) -> playersTickets.numPurchases
TMP_91(uint256) = REF_44 - 1
endIndex(uint256) := TMP_91(uint256)""];
23->24;
24[label=""Node Type: IF 24

EXPRESSION:
raffleTicketThatWon >= playersTickets.ticketsBought[0].startId && raffleTicketThatWon <= playersTickets.ticketsBought[endIndex].endId

IRs:
REF_45(CardsRaffle.TicketPurchase[]) -> playersTickets.ticketsBought
REF_46(CardsRaffle.TicketPurchase) -> REF_45[0]
REF_47(uint256) -> REF_46.startId
TMP_92(bool) = raffleTicketThatWon >= REF_47
REF_48(CardsRaffle.TicketPurchase[]) -> playersTickets.ticketsBought
REF_49(CardsRaffle.TicketPurchase) -> REF_48[endIndex]
REF_50(uint256) -> REF_49.endId
TMP_93(bool) = raffleTicketThatWon <= REF_50
TMP_94(bool) = TMP_92 && TMP_93
CONDITION TMP_94""];
24->27[label=""True""];
24->35[label=""False""];
25[label=""Node Type: BEGIN_LOOP 25
""];
25->28;
26[label=""Node Type: END_LOOP 26
""];
26->35;
27[label=""Node Type: NEW VARIABLE 27

EXPRESSION:
j = 0

IRs:
j(uint256) := 0(uint256)""];
27->25;
28[label=""Node Type: IF_LOOP 28

EXPRESSION:
j < playersTickets.numPurchases

IRs:
REF_51(uint256) -> playersTickets.numPurchases
TMP_95(bool) = j < REF_51
CONDITION TMP_95""];
28->29[label=""True""];
28->26[label=""False""];
29[label=""Node Type: NEW VARIABLE 29

EXPRESSION:
playerTicket = playersTickets.ticketsBought[j]

IRs:
REF_52(CardsRaffle.TicketPurchase[]) -> playersTickets.ticketsBought
REF_53(CardsRaffle.TicketPurchase) -> REF_52[j]
playerTicket(CardsRaffle.TicketPurchase) := REF_53(CardsRaffle.TicketPurchase)""];
29->30;
30[label=""Node Type: IF 30

EXPRESSION:
raffleTicketThatWon >= playerTicket.startId && raffleTicketThatWon <= playerTicket.endId

IRs:
REF_54(uint256) -> playerTicket.startId
TMP_96(bool) = raffleTicketThatWon >= REF_54
REF_55(uint256) -> playerTicket.endId
TMP_97(bool) = raffleTicketThatWon <= REF_55
TMP_98(bool) = TMP_96 && TMP_97
CONDITION TMP_98""];
30->31[label=""True""];
30->33[label=""False""];
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
assignRafflePrize(player)

IRs:
INTERNAL_CALL, CardsRaffle.assignRafflePrize(address)(player)""];
31->32;
32[label=""Node Type: RETURN 32
""];
33[label=""Node Type: END_IF 33
""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
j ++

IRs:
TMP_100(uint256) := j(uint256)
j(uint256) = j + 1""];
34->28;
35[label=""Node Type: END_IF 35
""];
35->36;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
i ++

IRs:
TMP_101(uint256) := i(uint256)
i(uint256) = i + 1""];
36->20;
}
",1,1,0,0,require(bool)(raffleEndTime < block.timestamp);require(bool)(raffleWinner == 0);require(bool)(rare.getRareItemsOwner(raffleRareId) == getRareAddress());! raffleWinningTicketSelected;drawRandomWinner();;checkWinner != 0;tickets = ticketsBoughtByPlayer[checkWinner];;tickets.numPurchases > 0 && checkIndex < tickets.numPurchases && tickets.raffleRareId == raffleRareId;checkTicket = tickets.ticketsBought[checkIndex];;raffleTicketThatWon >= checkTicket.startId && raffleTicketThatWon <= checkTicket.endId;assignRafflePrize(checkWinner);;;i = 0;;i < rafflePlayers[raffleRareId].length;;player = rafflePlayers[raffleRareId][i];playersTickets = ticketsBoughtByPlayer[player];endIndex = playersTickets.numPurchases - 1;raffleTicketThatWon >= playersTickets.ticketsBought[0].startId && raffleTicketThatWon <= playersTickets.ticketsBought[endIndex].endId;j = 0;;;j < playersTickets.numPurchases;;playerTicket = playersTickets.ticketsBought[j];raffleTicketThatWon >= playerTicket.startId && raffleTicketThatWon <= playerTicket.endId;assignRafflePrize(player);;;j ++;i ++
./0x0000009a317684a5f840484357fa587aca76454c_ext.sol,BurnableToken.burn,873,880,"TMP_322(uint256) = HIGH_LEVEL_CALL, dest:balances(BalanceSheet), function:balanceOf, arguments:['msg.sender']  ,TMP_323(bool) = _value <= TMP_322,TMP_324(None) = SOLIDITY_CALL require(bool)(TMP_323),burner(address) := msg.sender(address),HIGH_LEVEL_CALL, dest:balances(BalanceSheet), function:subBalance, arguments:['burner', '_value']  ,TMP_326(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_value'] ,totalSupply_(uint256) := TMP_326(uint256),Emit Burn(burner,_value),TMP_328 = CONVERT 0 to address,Emit Transfer(burner,TMP_328,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= balances.balanceOf(msg.sender))

IRs:
TMP_322(uint256) = HIGH_LEVEL_CALL, dest:balances(BalanceSheet), function:balanceOf, arguments:['msg.sender']  
TMP_323(bool) = _value <= TMP_322
TMP_324(None) = SOLIDITY_CALL require(bool)(TMP_323)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
burner = msg.sender

IRs:
burner(address) := msg.sender(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances.subBalance(burner,_value)

IRs:
HIGH_LEVEL_CALL, dest:balances(BalanceSheet), function:subBalance, arguments:['burner', '_value']  ""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
totalSupply_ = totalSupply_.sub(_value)

IRs:
TMP_326(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_value'] 
totalSupply_(uint256) := TMP_326(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Burn(burner,_value)

IRs:
Emit Burn(burner,_value)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(burner,address(0),_value)

IRs:
TMP_328 = CONVERT 0 to address
Emit Transfer(burner,TMP_328,_value)""];
}
",1,0,0,0,"require(bool)(_value <= balances.balanceOf(msg.sender));burner = msg.sender;balances.subBalance(burner,_value);totalSupply_ = totalSupply_.sub(_value);Burn(burner,_value);Transfer(burner,address(0),_value)"
./0x0000009a317684a5f840484357fa587aca76454c_ext.sol,BurnableToken.burn,537,547,"TMP_322(uint256) = HIGH_LEVEL_CALL, dest:balances(BalanceSheet), function:balanceOf, arguments:['msg.sender']  ,TMP_323(bool) = _value <= TMP_322,TMP_324(None) = SOLIDITY_CALL require(bool)(TMP_323),burner(address) := msg.sender(address),HIGH_LEVEL_CALL, dest:balances(BalanceSheet), function:subBalance, arguments:['burner', '_value']  ,TMP_326(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_value'] ,totalSupply_(uint256) := TMP_326(uint256),Emit Burn(burner,_value),TMP_328 = CONVERT 0 to address,Emit Transfer(burner,TMP_328,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= balances.balanceOf(msg.sender))

IRs:
TMP_322(uint256) = HIGH_LEVEL_CALL, dest:balances(BalanceSheet), function:balanceOf, arguments:['msg.sender']  
TMP_323(bool) = _value <= TMP_322
TMP_324(None) = SOLIDITY_CALL require(bool)(TMP_323)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
burner = msg.sender

IRs:
burner(address) := msg.sender(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances.subBalance(burner,_value)

IRs:
HIGH_LEVEL_CALL, dest:balances(BalanceSheet), function:subBalance, arguments:['burner', '_value']  ""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
totalSupply_ = totalSupply_.sub(_value)

IRs:
TMP_326(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_value'] 
totalSupply_(uint256) := TMP_326(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Burn(burner,_value)

IRs:
Emit Burn(burner,_value)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(burner,address(0),_value)

IRs:
TMP_328 = CONVERT 0 to address
Emit Transfer(burner,TMP_328,_value)""];
}
",1,0,0,0,"require(bool)(_value <= balances.balanceOf(msg.sender));burner = msg.sender;balances.subBalance(burner,_value);totalSupply_ = totalSupply_.sub(_value);Burn(burner,_value);Transfer(burner,address(0),_value)"
./0x174bb5d84b78e9e2248e7aa2c789aeba82f72f68_ext.sol,LuckyTree.manuallyProcessTransaction,348,357,"TMP_126(bool) = _value == leafPrice,TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126),TMP_128 = CONVERT tokenAddress to IERC20Token,TMP_129 = CONVERT this to address,TMP_130(uint256) = HIGH_LEVEL_CALL, dest:TMP_128(IERC20Token), function:balanceOf, arguments:['TMP_129']  ,TMP_131(uint256) = _value + totalParticipationAmount,TMP_132(bool) = TMP_130 >= TMP_131,TMP_133(None) = SOLIDITY_CALL require(bool)(TMP_132),REF_42(LuckyTree.state) -> state.running,TMP_134(bool) = gameState == REF_42,TMP_135(bool) = block.number < gameDuration,TMP_136(bool) = TMP_134 && TMP_135,CONDITION TMP_136,TMP_137(uint256) = INTERNAL_CALL, LuckyTree.processTransaction(address,uint256)(_from,_value),tokensToTake(uint256) := TMP_137(uint256),TMP_138 = CONVERT tokenAddress to IERC20Token,TMP_139 = CONVERT this to address,TMP_140(bool) = HIGH_LEVEL_CALL, dest:TMP_138(IERC20Token), function:transferFrom, arguments:['_from', 'TMP_139', 'tokensToTake']  ,MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value == leafPrice)

IRs:
TMP_126(bool) = _value == leafPrice
TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(IERC20Token(tokenAddress).balanceOf(address(this)) >= _value + totalParticipationAmount)

IRs:
TMP_128 = CONVERT tokenAddress to IERC20Token
TMP_129 = CONVERT this to address
TMP_130(uint256) = HIGH_LEVEL_CALL, dest:TMP_128(IERC20Token), function:balanceOf, arguments:['TMP_129']  
TMP_131(uint256) = _value + totalParticipationAmount
TMP_132(bool) = TMP_130 >= TMP_131
TMP_133(None) = SOLIDITY_CALL require(bool)(TMP_132)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
gameState == state.running && block.number < gameDuration

IRs:
REF_42(LuckyTree.state) -> state.running
TMP_134(bool) = gameState == REF_42
TMP_135(bool) = block.number < gameDuration
TMP_136(bool) = TMP_134 && TMP_135
CONDITION TMP_136""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
tokensToTake = processTransaction(_from,_value)

IRs:
TMP_137(uint256) = INTERNAL_CALL, LuckyTree.processTransaction(address,uint256)(_from,_value)
tokensToTake(uint256) := TMP_137(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
IERC20Token(tokenAddress).transferFrom(_from,address(this),tokensToTake)

IRs:
TMP_138 = CONVERT tokenAddress to IERC20Token
TMP_139 = CONVERT this to address
TMP_140(bool) = HIGH_LEVEL_CALL, dest:TMP_138(IERC20Token), function:transferFrom, arguments:['_from', 'TMP_139', 'tokensToTake']  ""];
5->6;
6[label=""Node Type: END_IF 6
""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
7->1;
}
",1,0,0,0,"onlyOwner();require(bool)(_value == leafPrice);require(bool)(IERC20Token(tokenAddress).balanceOf(address(this)) >= _value + totalParticipationAmount);gameState == state.running && block.number < gameDuration;tokensToTake = processTransaction(_from,_value);;IERC20Token(tokenAddress).transferFrom(_from,address(this),tokensToTake)"
./0x750c1d91864171d7e1715a6b53ee28c72b8faa09_ext.sol,EthicHubUser.registerCommunity,173,184,"TMP_77 = CONVERT 0 to address,TMP_78(bool) = target != TMP_77,TMP_79(None) = SOLIDITY_CALL require(bool)(TMP_78),TMP_80(bytes32) = SOLIDITY_CALL keccak256()(user,community,target),TMP_81(bool) = HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:getBool, arguments:['TMP_80']  ,isRegistered(bool) := TMP_81(bool),TMP_82 = UnaryType.BANG isRegistered ,CONDITION TMP_82,INTERNAL_CALL, EthicHubUser.changeUserStatus(address,string,bool)(target,community,True),TMP_84(bytes32) = SOLIDITY_CALL keccak256()(contract.name,reputation),TMP_85(address) = HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:getAddress, arguments:['TMP_84']  ,TMP_86 = CONVERT TMP_85 to EthicHubReputationInterface,rep(EthicHubReputationInterface) := TMP_86(EthicHubReputationInterface),HIGH_LEVEL_CALL, dest:rep(EthicHubReputationInterface), function:initCommunityReputation, arguments:['target']  ,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(target != address(0))

IRs:
TMP_77 = CONVERT 0 to address
TMP_78(bool) = target != TMP_77
TMP_79(None) = SOLIDITY_CALL require(bool)(TMP_78)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
isRegistered = ethicHubStorage.getBool(keccak256()(user,community,target))

IRs:
TMP_80(bytes32) = SOLIDITY_CALL keccak256()(user,community,target)
TMP_81(bool) = HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:getBool, arguments:['TMP_80']  
isRegistered(bool) := TMP_81(bool)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
! isRegistered

IRs:
TMP_82 = UnaryType.BANG isRegistered 
CONDITION TMP_82""];
3->4[label=""True""];
3->7[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
changeUserStatus(target,community,true)

IRs:
INTERNAL_CALL, EthicHubUser.changeUserStatus(address,string,bool)(target,community,True)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
rep = EthicHubReputationInterface(ethicHubStorage.getAddress(keccak256()(contract.name,reputation)))

IRs:
TMP_84(bytes32) = SOLIDITY_CALL keccak256()(contract.name,reputation)
TMP_85(address) = HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:getAddress, arguments:['TMP_84']  
TMP_86 = CONVERT TMP_85 to EthicHubReputationInterface
rep(EthicHubReputationInterface) := TMP_86(EthicHubReputationInterface)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
rep.initCommunityReputation(target)

IRs:
HIGH_LEVEL_CALL, dest:rep(EthicHubReputationInterface), function:initCommunityReputation, arguments:['target']  ""];
6->7;
7[label=""Node Type: END_IF 7
""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
8->1;
}
",1,0,0,0,"onlyOwner();require(bool)(target != address(0));isRegistered = ethicHubStorage.getBool(keccak256()(user,community,target));! isRegistered;changeUserStatus(target,community,true);;rep = EthicHubReputationInterface(ethicHubStorage.getAddress(keccak256()(contract.name,reputation)));rep.initCommunityReputation(target)"
./0xc58f1f3ec051b51f10c4feb0cfd10d811d055ef5_ext.sol,ldoh.Holdplatform,155,164,"TMP_9(bool) = tokenAddress != 0,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),TMP_11(bool) = amount > 0,REF_4(mapping(address => mapping(uint256 => uint256))) -> Statistics[msg.sender],REF_5(mapping(uint256 => uint256)) -> REF_4[tokenAddress],REF_6(uint256) -> REF_5[5],TMP_12(uint256) = INTERNAL_CALL, ldoh.add(uint256,uint256)(REF_6,amount),REF_7(uint256) -> maxcontribution[tokenAddress],TMP_13(bool) = TMP_12 <= REF_7,TMP_14(bool) = TMP_11 && TMP_13,TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14),REF_8(bool) -> contractaddress[tokenAddress],TMP_16(bool) = REF_8 == False,CONDITION TMP_16,TMP_17(None) = SOLIDITY_CALL revert()(),TMP_18 = CONVERT tokenAddress to ERC20Interface,token(ERC20Interface) := TMP_18(ERC20Interface),TMP_19 = CONVERT this to address,TMP_20(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Interface), function:transferFrom, arguments:['msg.sender', 'TMP_19', 'amount']  ,TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20),INTERNAL_CALL, ldoh.HodlTokens2(address,uint256)(tokenAddress,amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(tokenAddress != 0x0)

IRs:
TMP_9(bool) = tokenAddress != 0
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(amount > 0 && add(Statistics[msg.sender][tokenAddress][5],amount) <= maxcontribution[tokenAddress])

IRs:
TMP_11(bool) = amount > 0
REF_4(mapping(address => mapping(uint256 => uint256))) -> Statistics[msg.sender]
REF_5(mapping(uint256 => uint256)) -> REF_4[tokenAddress]
REF_6(uint256) -> REF_5[5]
TMP_12(uint256) = INTERNAL_CALL, ldoh.add(uint256,uint256)(REF_6,amount)
REF_7(uint256) -> maxcontribution[tokenAddress]
TMP_13(bool) = TMP_12 <= REF_7
TMP_14(bool) = TMP_11 && TMP_13
TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
contractaddress[tokenAddress] == false

IRs:
REF_8(bool) -> contractaddress[tokenAddress]
TMP_16(bool) = REF_8 == False
CONDITION TMP_16""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
revert()()

IRs:
TMP_17(None) = SOLIDITY_CALL revert()()""];
4->8;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
token = ERC20Interface(tokenAddress)

IRs:
TMP_18 = CONVERT tokenAddress to ERC20Interface
token(ERC20Interface) := TMP_18(ERC20Interface)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(token.transferFrom(msg.sender,address(this),amount))

IRs:
TMP_19 = CONVERT this to address
TMP_20(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Interface), function:transferFrom, arguments:['msg.sender', 'TMP_19', 'amount']  
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
HodlTokens2(tokenAddress,amount)

IRs:
INTERNAL_CALL, ldoh.HodlTokens2(address,uint256)(tokenAddress,amount)""];
7->8;
8[label=""Node Type: END_IF 8
""];
}
",1,0,0,0,"require(bool)(tokenAddress != 0x0);require(bool)(amount > 0 && add(Statistics[msg.sender][tokenAddress][5],amount) <= maxcontribution[tokenAddress]);contractaddress[tokenAddress] == false;revert()();token = ERC20Interface(tokenAddress);;require(bool)(token.transferFrom(msg.sender,address(this),amount));HodlTokens2(tokenAddress,amount)"
./0xf0ef703a04cf96212031b51d373e8469687f308e_ext.sol,ESCToken.refundTokens,355,361,"TMP_111(bool) = msg.sender == owner,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113 = CONVERT this to address,TMP_114(bool) = _token != TMP_113,TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114),TMP_116 = CONVERT _token to AbstractToken,token(AbstractToken) := TMP_116(AbstractToken),TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ,Emit RefundTokens(_token,_refund,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_111(bool) = msg.sender == owner
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_113 = CONVERT this to address
TMP_114(bool) = _token != TMP_113
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
token = AbstractToken(_token)

IRs:
TMP_116 = CONVERT _token to AbstractToken
token(AbstractToken) := TMP_116(AbstractToken)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(_refund,_value)

IRs:
TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RefundTokens(_token,_refund,_value)

IRs:
Emit RefundTokens(_token,_refund,_value)""];
}
",1,0,0,0,"require(bool)(msg.sender == owner);require(bool)(_token != address(this));token = AbstractToken(_token);token.transfer(_refund,_value);RefundTokens(_token,_refund,_value)"
./0x0356e14c2f8de339131c668c1747def594467a9a_ext.sol,Club1VIT.transfer,139,152,"_value(uint256) := 1(uint256),REF_6(uint256) -> balances[msg.sender],TMP_31(bool) = REF_6 == 1,TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31),TMP_33(bool) = _to == owner,TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33),TMP_35(bytes32) = SOLIDITY_CALL keccak256()(resetToken()),TMP_36 = CONVERT TMP_35 to bytes4,TMP_37(bool) = LOW_LEVEL_CALL, dest:owner, function:call, arguments:['TMP_36']  ,TMP_38 = UnaryType.BANG TMP_37 ,CONDITION TMP_38,TMP_39(None) = SOLIDITY_CALL revert()(),REF_8(uint256) -> balances[msg.sender],REF_8(uint256) (->balances) := 0(uint256),REF_9(uint256) -> balances[_to],REF_9(uint256) (->balances) := 1(uint256),Emit Transfer(msg.sender,_to),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_value = 1

IRs:
_value(uint256) := 1(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[msg.sender] == 1)

IRs:
REF_6(uint256) -> balances[msg.sender]
TMP_31(bool) = REF_6 == 1
TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_to == owner)

IRs:
TMP_33(bool) = _to == owner
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
! owner.call(bytes4(keccak256()(resetToken())))

IRs:
TMP_35(bytes32) = SOLIDITY_CALL keccak256()(resetToken())
TMP_36 = CONVERT TMP_35 to bytes4
TMP_37(bool) = LOW_LEVEL_CALL, dest:owner, function:call, arguments:['TMP_36']  
TMP_38 = UnaryType.BANG TMP_37 
CONDITION TMP_38""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
revert()()

IRs:
TMP_39(None) = SOLIDITY_CALL revert()()""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[msg.sender] = 0

IRs:
REF_8(uint256) -> balances[msg.sender]
REF_8(uint256) (->balances) := 0(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[_to] = 1

IRs:
REF_9(uint256) -> balances[_to]
REF_9(uint256) (->balances) := 1(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
Transfer(msg.sender,_to)

IRs:
Emit Transfer(msg.sender,_to)""];
9->10;
10[label=""Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,"_value = 1;require(bool)(balances[msg.sender] == 1);require(bool)(_to == owner);! owner.call(bytes4(keccak256()(resetToken())));revert()();;balances[msg.sender] = 0;balances[_to] = 1;Transfer(msg.sender,_to);true"
./0xed3762edcc5820a5587105d7b9f574c711c4a700_ext.sol,FoMo3Dshort.registerNameXID,593,607,"TMP_91(bytes32) = LIBRARY_CALL, dest:NameFilter, function:NameFilter.nameFilter(string), arguments:['_nameString'] ,_name(bytes32) := TMP_91(bytes32),_addr(address) := msg.sender(address),_paid(uint256) := msg.value(uint256),TUPLE_0(bool,uint256) = HIGH_LEVEL_CALL, dest:PlayerBook(PlayerBookInterface), function:registerNameXIDFromDapp, arguments:['_addr', '_name', '_affCode', '_all'] value:_paid ,_isNewPlayer(bool)= UNPACK TUPLE_0 index: 0 ,_affID(uint256)= UNPACK TUPLE_0 index: 1 ,REF_105(uint256) -> pIDxAddr_[_addr],_pID(uint256) := REF_105(uint256),REF_107(F3Ddatasets.Player) -> plyr_[_affID],REF_108(address) -> REF_107.addr,REF_109(F3Ddatasets.Player) -> plyr_[_affID],REF_110(bytes32) -> REF_109.name,Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_108,REF_110,_paid,now),MODIFIER_CALL, FoMo3Dshort.isHuman()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_name = _nameString.nameFilter()

IRs:
TMP_91(bytes32) = LIBRARY_CALL, dest:NameFilter, function:NameFilter.nameFilter(string), arguments:['_nameString'] 
_name(bytes32) := TMP_91(bytes32)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
_addr = msg.sender

IRs:
_addr(address) := msg.sender(address)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
_paid = msg.value

IRs:
_paid(uint256) := msg.value(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
(_isNewPlayer,_affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr,_name,_affCode,_all)

IRs:
TUPLE_0(bool,uint256) = HIGH_LEVEL_CALL, dest:PlayerBook(PlayerBookInterface), function:registerNameXIDFromDapp, arguments:['_addr', '_name', '_affCode', '_all'] value:_paid 
_isNewPlayer(bool)= UNPACK TUPLE_0 index: 0 
_affID(uint256)= UNPACK TUPLE_0 index: 1 ""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
_pID = pIDxAddr_[_addr]

IRs:
REF_105(uint256) -> pIDxAddr_[_addr]
_pID(uint256) := REF_105(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
F3Devents.onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,_paid,now)

IRs:
REF_107(F3Ddatasets.Player) -> plyr_[_affID]
REF_108(address) -> REF_107.addr
REF_109(F3Ddatasets.Player) -> plyr_[_affID]
REF_110(bytes32) -> REF_109.name
Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_108,REF_110,_paid,now)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
isHuman()

IRs:
MODIFIER_CALL, FoMo3Dshort.isHuman()()""];
9->1;
}
",1,0,0,0,"isHuman();_name = _nameString.nameFilter();_addr = msg.sender;_paid = msg.value;;;(_isNewPlayer,_affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr,_name,_affCode,_all);_pID = pIDxAddr_[_addr];F3Devents.onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,_paid,now)"
./0x292d448b46f5419387e3886e89680ed4b7d62d09_ext.sol,RegistrationBonus.addBonusToken,60,72,"REF_0(uint256) -> beneficiaryAddresses[_beneficiary],TMP_9(bool) = REF_0 == 0,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_1(address) -> beneficiaryUserIds[_userId],TMP_11(bool) = REF_1 == 0,TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11),TMP_13(bool) = HIGH_LEVEL_CALL, dest:token(AbstractMintableToken), function:mintFromTrustedContract, arguments:['_beneficiary', 'bonusAmount']  ,CONDITION TMP_13,REF_3(uint256) -> beneficiaryAddresses[_beneficiary],REF_3(uint256) (->beneficiaryAddresses) := _userId(uint256),REF_4(address) -> beneficiaryUserIds[_userId],REF_4(address) (->beneficiaryUserIds) := _beneficiary(address),Emit BonusEnrolled(_beneficiary,_userId,bonusAmount),RETURN True,RETURN False,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiaryAddresses[_beneficiary] == 0)

IRs:
REF_0(uint256) -> beneficiaryAddresses[_beneficiary]
TMP_9(bool) = REF_0 == 0
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(beneficiaryUserIds[_userId] == 0)

IRs:
REF_1(address) -> beneficiaryUserIds[_userId]
TMP_11(bool) = REF_1 == 0
TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
token.mintFromTrustedContract(_beneficiary,bonusAmount)

IRs:
TMP_13(bool) = HIGH_LEVEL_CALL, dest:token(AbstractMintableToken), function:mintFromTrustedContract, arguments:['_beneficiary', 'bonusAmount']  
CONDITION TMP_13""];
3->4[label=""True""];
3->8[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
beneficiaryAddresses[_beneficiary] = _userId

IRs:
REF_3(uint256) -> beneficiaryAddresses[_beneficiary]
REF_3(uint256) (->beneficiaryAddresses) := _userId(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
beneficiaryUserIds[_userId] = _beneficiary

IRs:
REF_4(address) -> beneficiaryUserIds[_userId]
REF_4(address) (->beneficiaryUserIds) := _beneficiary(address)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
BonusEnrolled(_beneficiary,_userId,bonusAmount)

IRs:
Emit BonusEnrolled(_beneficiary,_userId,bonusAmount)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
10->1;
}
",1,0,0,0,"onlyOwner();require(bool)(beneficiaryAddresses[_beneficiary] == 0);require(bool)(beneficiaryUserIds[_userId] == 0);token.mintFromTrustedContract(_beneficiary,bonusAmount);beneficiaryAddresses[_beneficiary] = _userId;false;beneficiaryUserIds[_userId] = _beneficiary;BonusEnrolled(_beneficiary,_userId,bonusAmount);true"
./0x56ffb3c578906ba9658fccb052fc1a5672275b6a_ext.sol,OpiriaCrowdsale.addBonusBatch,1085,1095,"i(uint256) := 0(uint256),REF_194 -> LENGTH recipients,TMP_610(bool) = i < REF_194,CONDITION TMP_610,TMP_611 = CONVERT token to PausableToken,REF_196(address) -> recipients[i],TMP_612(uint256) = HIGH_LEVEL_CALL, dest:TMP_611(PausableToken), function:balanceOf, arguments:['REF_196']  ,TMP_613(bool) = TMP_612 > 0,TMP_614(None) = SOLIDITY_CALL require(bool)(TMP_613),REF_197(uint256) -> amounts[i],TMP_615(bool) = INTERNAL_CALL, TokenCappedCrowdsale.notExceedingSaleCap(uint256)(REF_197),TMP_616(None) = SOLIDITY_CALL require(bool)(TMP_615),REF_199(uint256) -> amounts[i],TMP_617(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalBonus', 'REF_199'] ,totalBonus(uint256) := TMP_617(uint256),REF_201(uint256) -> amounts[i],TMP_618(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['soldTokens', 'REF_201'] ,soldTokens(uint256) := TMP_618(uint256),REF_202(address) -> recipients[i],REF_203(uint256) -> bonusOf[REF_202],REF_204(address) -> recipients[i],REF_205(uint256) -> bonusOf[REF_204],REF_207(uint256) -> amounts[i],TMP_619(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_205', 'REF_207'] ,REF_203(uint256) (->bonusOf) := TMP_619(uint256),TMP_620(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < recipients.length

IRs:
REF_194 -> LENGTH recipients
TMP_610(bool) = i < REF_194
CONDITION TMP_610""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(PausableToken(token).balanceOf(recipients[i]) > 0)

IRs:
TMP_611 = CONVERT token to PausableToken
REF_196(address) -> recipients[i]
TMP_612(uint256) = HIGH_LEVEL_CALL, dest:TMP_611(PausableToken), function:balanceOf, arguments:['REF_196']  
TMP_613(bool) = TMP_612 > 0
TMP_614(None) = SOLIDITY_CALL require(bool)(TMP_613)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(notExceedingSaleCap(amounts[i]))

IRs:
REF_197(uint256) -> amounts[i]
TMP_615(bool) = INTERNAL_CALL, TokenCappedCrowdsale.notExceedingSaleCap(uint256)(REF_197)
TMP_616(None) = SOLIDITY_CALL require(bool)(TMP_615)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
totalBonus = totalBonus.add(amounts[i])

IRs:
REF_199(uint256) -> amounts[i]
TMP_617(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalBonus', 'REF_199'] 
totalBonus(uint256) := TMP_617(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
soldTokens = soldTokens.add(amounts[i])

IRs:
REF_201(uint256) -> amounts[i]
TMP_618(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['soldTokens', 'REF_201'] 
soldTokens(uint256) := TMP_618(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
bonusOf[recipients[i]] = bonusOf[recipients[i]].add(amounts[i])

IRs:
REF_202(address) -> recipients[i]
REF_203(uint256) -> bonusOf[REF_202]
REF_204(address) -> recipients[i]
REF_205(uint256) -> bonusOf[REF_204]
REF_207(uint256) -> amounts[i]
TMP_619(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_205', 'REF_207'] 
REF_203(uint256) (->bonusOf) := TMP_619(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
i ++

IRs:
TMP_620(uint256) := i(uint256)
i(uint256) = i + 1""];
10->4;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
11->3;
}
",1,0,0,0,onlyOwner();;i < recipients.length;;i = 0;require(bool)(PausableToken(token).balanceOf(recipients[i]) > 0);require(bool)(notExceedingSaleCap(amounts[i]));totalBonus = totalBonus.add(amounts[i]);soldTokens = soldTokens.add(amounts[i]);bonusOf[recipients[i]] = bonusOf[recipients[i]].add(amounts[i]);i ++
./0xef86db910c71ffa3c80233bc9108dc51ad1e008a_ext.sol,CommonWallet.depoToken,37,42,"TMP_6 = CONVERT tokenAddr to ERC20Token,TMP_7(bool) = HIGH_LEVEL_CALL, dest:TMP_6(ERC20Token), function:transferFrom, arguments:['msg.sender', 'this', 'amount']  ,CONDITION TMP_7,REF_2(mapping(address => uint256)) -> tokenBalance[tokenAddr],REF_3(uint256) -> REF_2[msg.sender],REF_4(mapping(address => uint256)) -> tokenBalance[tokenAddr],REF_5(uint256) -> REF_4[msg.sender],TMP_8(uint256) = INTERNAL_CALL, CommonWallet.safeAdd(uint256,uint256)(REF_5,amount),REF_3(uint256) (->tokenBalance) := TMP_8(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
ERC20Token(tokenAddr).transferFrom(msg.sender,this,amount)

IRs:
TMP_6 = CONVERT tokenAddr to ERC20Token
TMP_7(bool) = HIGH_LEVEL_CALL, dest:TMP_6(ERC20Token), function:transferFrom, arguments:['msg.sender', 'this', 'amount']  
CONDITION TMP_7""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
tokenBalance[tokenAddr][msg.sender] = safeAdd(tokenBalance[tokenAddr][msg.sender],amount)

IRs:
REF_2(mapping(address => uint256)) -> tokenBalance[tokenAddr]
REF_3(uint256) -> REF_2[msg.sender]
REF_4(mapping(address => uint256)) -> tokenBalance[tokenAddr]
REF_5(uint256) -> REF_4[msg.sender]
TMP_8(uint256) = INTERNAL_CALL, CommonWallet.safeAdd(uint256,uint256)(REF_5,amount)
REF_3(uint256) (->tokenBalance) := TMP_8(uint256)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",1,0,0,0,"ERC20Token(tokenAddr).transferFrom(msg.sender,this,amount);tokenBalance[tokenAddr][msg.sender] = safeAdd(tokenBalance[tokenAddr][msg.sender],amount);"
./0x6d4106c5c6cddeb5e0bbda23c4555a45dfaa92d7_ext.sol,CucuSale.getLeftOver,170,176,"lastActionId(uint256) := act(uint256),TMP_57(bool) = HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['beneficiary', 'tokenAvailable']  ,CONDITION TMP_57,Emit TokensClaimed(beneficiary,tokenAvailable),tokenAvailable(uint256) := 0(uint256),MODIFIER_CALL, CucuSale.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
lastActionId = act

IRs:
lastActionId(uint256) := act(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
tokenReward.transfer(beneficiary,tokenAvailable)

IRs:
TMP_57(bool) = HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['beneficiary', 'tokenAvailable']  
CONDITION TMP_57""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
TokensClaimed(beneficiary,tokenAvailable)

IRs:
Emit TokensClaimed(beneficiary,tokenAvailable)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
tokenAvailable = 0

IRs:
tokenAvailable(uint256) := 0(uint256)""];
4->5;
5[label=""Node Type: END_IF 5
""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, CucuSale.onlyOwner()()""];
6->1;
}
",1,0,0,0,"onlyOwner();lastActionId = act;tokenReward.transfer(beneficiary,tokenAvailable);TokensClaimed(beneficiary,tokenAvailable);;tokenAvailable = 0"
./0x4c84949b55f21a376dba12e732958ede8b033b0e_ext.sol,TokenVesting.grant,132,178,"TMP_12 = CONVERT 0 to address,TMP_13(bool) = beneficiary != TMP_12,TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13),REF_5(TokenVesting.VestingGrant) -> vestingGrants[beneficiary],REF_6(bool) -> REF_5.isGranted,TMP_15 = UnaryType.BANG REF_6 ,TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15),TMP_17(bool) = vestedJiffys > 0,TMP_18(bool) = unvestedJiffys > 0,TMP_19(bool) = TMP_17 || TMP_18,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),TMP_21(bool) = startTimestamp >= GENESIS_TIMESTAMP,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),TMP_23(bool) = vestingSeconds > 0,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),TMP_25(bool) = cliffSeconds >= 0,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),TMP_27(bool) = cliffSeconds < vestingSeconds,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),HIGH_LEVEL_CALL, dest:whenContract(WHENToken), function:vestingGrant, arguments:['msg.sender', 'beneficiary', 'vestedJiffys', 'unvestedJiffys']  ,REF_8(TokenVesting.VestingGrant) -> vestingGrants[beneficiary],TMP_30(uint256) = startTimestamp + cliffSeconds,TMP_31(uint256) = startTimestamp + vestingSeconds,TMP_32(TokenVesting.VestingGrant) = new VestingGrant(True,msg.sender,beneficiary,unvestedJiffys,startTimestamp,TMP_30,TMP_31,revocable,0),REF_8(TokenVesting.VestingGrant) (->vestingGrants) := TMP_32(TokenVesting.VestingGrant),REF_10 -> LENGTH vestingGrantLookup,TMP_34(uint256) := REF_10(uint256),TMP_35(uint256) = TMP_34 + 1,REF_10(uint256) (->vestingGrantLookup) := TMP_35(uint256),REF_11(address) -> vestingGrantLookup[TMP_34],REF_11(address) (->vestingGrantLookup) := beneficiary(address),Emit Grant(msg.sender,beneficiary,vestedJiffys,unvestedJiffys),REF_12(TokenVesting.VestingGrant) -> vestingGrants[beneficiary],REF_13(uint256) -> REF_12.cliffTimestamp,TMP_37(bool) = REF_13 <= now,CONDITION TMP_37,INTERNAL_CALL, TokenVesting.releaseFor(address)(beneficiary),MODIFIER_CALL, TokenVesting.requireIsOperational()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->15;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != address(0))

IRs:
TMP_12 = CONVERT 0 to address
TMP_13(bool) = beneficiary != TMP_12
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! vestingGrants[beneficiary].isGranted)

IRs:
REF_5(TokenVesting.VestingGrant) -> vestingGrants[beneficiary]
REF_6(bool) -> REF_5.isGranted
TMP_15 = UnaryType.BANG REF_6 
TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)((vestedJiffys > 0) || (unvestedJiffys > 0))

IRs:
TMP_17(bool) = vestedJiffys > 0
TMP_18(bool) = unvestedJiffys > 0
TMP_19(bool) = TMP_17 || TMP_18
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(startTimestamp >= GENESIS_TIMESTAMP)

IRs:
TMP_21(bool) = startTimestamp >= GENESIS_TIMESTAMP
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(vestingSeconds > 0)

IRs:
TMP_23(bool) = vestingSeconds > 0
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(cliffSeconds >= 0)

IRs:
TMP_25(bool) = cliffSeconds >= 0
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(cliffSeconds < vestingSeconds)

IRs:
TMP_27(bool) = cliffSeconds < vestingSeconds
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
whenContract.vestingGrant(msg.sender,beneficiary,vestedJiffys,unvestedJiffys)

IRs:
HIGH_LEVEL_CALL, dest:whenContract(WHENToken), function:vestingGrant, arguments:['msg.sender', 'beneficiary', 'vestedJiffys', 'unvestedJiffys']  ""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
vestingGrants[beneficiary] = VestingGrant({isGranted:true,issuer:msg.sender,beneficiary:beneficiary,grantJiffys:unvestedJiffys,startTimestamp:startTimestamp,cliffTimestamp:startTimestamp + cliffSeconds,endTimestamp:startTimestamp + vestingSeconds,isRevocable:revocable,releasedJiffys:0})

IRs:
REF_8(TokenVesting.VestingGrant) -> vestingGrants[beneficiary]
TMP_30(uint256) = startTimestamp + cliffSeconds
TMP_31(uint256) = startTimestamp + vestingSeconds
TMP_32(TokenVesting.VestingGrant) = new VestingGrant(True,msg.sender,beneficiary,unvestedJiffys,startTimestamp,TMP_30,TMP_31,revocable,0)
REF_8(TokenVesting.VestingGrant) (->vestingGrants) := TMP_32(TokenVesting.VestingGrant)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
vestingGrantLookup.push(beneficiary)

IRs:
REF_10 -> LENGTH vestingGrantLookup
TMP_34(uint256) := REF_10(uint256)
TMP_35(uint256) = TMP_34 + 1
REF_10(uint256) (->vestingGrantLookup) := TMP_35(uint256)
REF_11(address) -> vestingGrantLookup[TMP_34]
REF_11(address) (->vestingGrantLookup) := beneficiary(address)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
Grant(msg.sender,beneficiary,vestedJiffys,unvestedJiffys)

IRs:
Emit Grant(msg.sender,beneficiary,vestedJiffys,unvestedJiffys)""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
vestingGrants[beneficiary].cliffTimestamp <= now

IRs:
REF_12(TokenVesting.VestingGrant) -> vestingGrants[beneficiary]
REF_13(uint256) -> REF_12.cliffTimestamp
TMP_37(bool) = REF_13 <= now
CONDITION TMP_37""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
releaseFor(beneficiary)

IRs:
INTERNAL_CALL, TokenVesting.releaseFor(address)(beneficiary)""];
13->14;
14[label=""Node Type: END_IF 14
""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
requireIsOperational()

IRs:
MODIFIER_CALL, TokenVesting.requireIsOperational()()""];
15->1;
}
",1,1,0,0,"requireIsOperational();require(bool)(beneficiary != address(0));require(bool)(! vestingGrants[beneficiary].isGranted);require(bool)((vestedJiffys > 0) || (unvestedJiffys > 0));require(bool)(startTimestamp >= GENESIS_TIMESTAMP);require(bool)(vestingSeconds > 0);require(bool)(cliffSeconds >= 0);require(bool)(cliffSeconds < vestingSeconds);whenContract.vestingGrant(msg.sender,beneficiary,vestedJiffys,unvestedJiffys);vestingGrants[beneficiary] = VestingGrant({isGranted:true,issuer:msg.sender,beneficiary:beneficiary,grantJiffys:unvestedJiffys,startTimestamp:startTimestamp,cliffTimestamp:startTimestamp + cliffSeconds,endTimestamp:startTimestamp + vestingSeconds,isRevocable:revocable,releasedJiffys:0});vestingGrantLookup.push(beneficiary);Grant(msg.sender,beneficiary,vestedJiffys,unvestedJiffys);vestingGrants[beneficiary].cliffTimestamp <= now;releaseFor(beneficiary);"
./0x174bb5d84b78e9e2248e7aa2c789aeba82f72f68_ext.sol,LuckyTree.receiveApproval,283,292,"TMP_98(bool) = _to == tokenAddress,TMP_99(None) = SOLIDITY_CALL require(bool)(TMP_98),TMP_100(bool) = _value == leafPrice,TMP_101(None) = SOLIDITY_CALL require(bool)(TMP_100),REF_26(LuckyTree.state) -> state.closed,TMP_102(bool) = gameState != REF_26,TMP_103(None) = SOLIDITY_CALL require(bool)(TMP_102),TMP_104 = CONVERT creditGameAddress to CreditGAMEInterface,TMP_105 = CONVERT this to address,TMP_106(bool) = HIGH_LEVEL_CALL, dest:TMP_104(CreditGAMEInterface), function:isGameApproved, arguments:['TMP_105']  ,TMP_107(bool) = TMP_106 == True,TMP_108(None) = SOLIDITY_CALL require(bool)(TMP_107),TMP_109(uint256) = INTERNAL_CALL, LuckyTree.processTransaction(address,uint256)(_from,_value),tokensToTake(uint256) := TMP_109(uint256),TMP_110 = CONVERT tokenAddress to IERC20Token,TMP_111 = CONVERT this to address,TMP_112(bool) = HIGH_LEVEL_CALL, dest:TMP_110(IERC20Token), function:transferFrom, arguments:['_from', 'TMP_111', 'tokensToTake']  ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to == tokenAddress)

IRs:
TMP_98(bool) = _to == tokenAddress
TMP_99(None) = SOLIDITY_CALL require(bool)(TMP_98)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value == leafPrice)

IRs:
TMP_100(bool) = _value == leafPrice
TMP_101(None) = SOLIDITY_CALL require(bool)(TMP_100)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(gameState != state.closed)

IRs:
REF_26(LuckyTree.state) -> state.closed
TMP_102(bool) = gameState != REF_26
TMP_103(None) = SOLIDITY_CALL require(bool)(TMP_102)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(CreditGAMEInterface(creditGameAddress).isGameApproved(address(this)) == true)

IRs:
TMP_104 = CONVERT creditGameAddress to CreditGAMEInterface
TMP_105 = CONVERT this to address
TMP_106(bool) = HIGH_LEVEL_CALL, dest:TMP_104(CreditGAMEInterface), function:isGameApproved, arguments:['TMP_105']  
TMP_107(bool) = TMP_106 == True
TMP_108(None) = SOLIDITY_CALL require(bool)(TMP_107)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
tokensToTake = processTransaction(_from,_value)

IRs:
TMP_109(uint256) = INTERNAL_CALL, LuckyTree.processTransaction(address,uint256)(_from,_value)
tokensToTake(uint256) := TMP_109(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
IERC20Token(tokenAddress).transferFrom(_from,address(this),tokensToTake)

IRs:
TMP_110 = CONVERT tokenAddress to IERC20Token
TMP_111 = CONVERT this to address
TMP_112(bool) = HIGH_LEVEL_CALL, dest:TMP_110(IERC20Token), function:transferFrom, arguments:['_from', 'TMP_111', 'tokensToTake']  ""];
}
",1,0,0,0,"require(bool)(_to == tokenAddress);require(bool)(_value == leafPrice);require(bool)(gameState != state.closed);require(bool)(CreditGAMEInterface(creditGameAddress).isGameApproved(address(this)) == true);tokensToTake = processTransaction(_from,_value);IERC20Token(tokenAddress).transferFrom(_from,address(this),tokensToTake)"
./0x2682e3ad5358932ac5cd8f8616912cec76ad680c_ext.sol,CupExchange.exchange,92,109,"TMP_14 = CONVERT 0 to address,TMP_15(bool) = msg.sender != TMP_14,TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15),TMP_17 = CONVERT this to address,TMP_18(bool) = msg.sender != TMP_17,TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18),TMP_20 = UnaryType.BANG halting ,TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20),TMP_22(uint256) = HIGH_LEVEL_CALL, dest:cup(token), function:allowance, arguments:['msg.sender', 'this']  ,allowance(uint256) := TMP_22(uint256),TMP_23(bool) = allowance > 0,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),TMP_25(bool) = HIGH_LEVEL_CALL, dest:cup(token), function:transferFrom, arguments:['msg.sender', 'this', 'allowance']  ,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),TMP_27 = CONVERT this to address,TMP_28(uint256) = HIGH_LEVEL_CALL, dest:teamCup(token), function:balanceOf, arguments:['TMP_27']  ,teamCupBalance(uint256) := TMP_28(uint256),TMP_29(uint256) = allowance * exchangePrice,teamCupAmount(uint256) := TMP_29(uint256),TMP_30(bool) = teamCupAmount <= teamCupBalance,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),TMP_32(bool) = HIGH_LEVEL_CALL, dest:teamCup(token), function:transfer, arguments:['msg.sender', 'teamCupAmount']  ,TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32),Emit Exchange(msg.sender,teamCupAmount,allowance)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender != address(0x0))

IRs:
TMP_14 = CONVERT 0 to address
TMP_15(bool) = msg.sender != TMP_14
TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender != address(this))

IRs:
TMP_17 = CONVERT this to address
TMP_18(bool) = msg.sender != TMP_17
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(! halting)

IRs:
TMP_20 = UnaryType.BANG halting 
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
allowance = cup.allowance(msg.sender,this)

IRs:
TMP_22(uint256) = HIGH_LEVEL_CALL, dest:cup(token), function:allowance, arguments:['msg.sender', 'this']  
allowance(uint256) := TMP_22(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(allowance > 0)

IRs:
TMP_23(bool) = allowance > 0
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(cup.transferFrom(msg.sender,this,allowance))

IRs:
TMP_25(bool) = HIGH_LEVEL_CALL, dest:cup(token), function:transferFrom, arguments:['msg.sender', 'this', 'allowance']  
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
teamCupBalance = teamCup.balanceOf(address(this))

IRs:
TMP_27 = CONVERT this to address
TMP_28(uint256) = HIGH_LEVEL_CALL, dest:teamCup(token), function:balanceOf, arguments:['TMP_27']  
teamCupBalance(uint256) := TMP_28(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
teamCupAmount = allowance * exchangePrice

IRs:
TMP_29(uint256) = allowance * exchangePrice
teamCupAmount(uint256) := TMP_29(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(teamCupAmount <= teamCupBalance)

IRs:
TMP_30(bool) = teamCupAmount <= teamCupBalance
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(teamCup.transfer(msg.sender,teamCupAmount))

IRs:
TMP_32(bool) = HIGH_LEVEL_CALL, dest:teamCup(token), function:transfer, arguments:['msg.sender', 'teamCupAmount']  
TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
Exchange(msg.sender,teamCupAmount,allowance)

IRs:
Emit Exchange(msg.sender,teamCupAmount,allowance)""];
}
",1,0,0,0,"require(bool)(msg.sender != address(0x0));require(bool)(msg.sender != address(this));require(bool)(! halting);allowance = cup.allowance(msg.sender,this);require(bool)(allowance > 0);require(bool)(cup.transferFrom(msg.sender,this,allowance));teamCupBalance = teamCup.balanceOf(address(this));teamCupAmount = allowance * exchangePrice;require(bool)(teamCupAmount <= teamCupBalance);require(bool)(teamCup.transfer(msg.sender,teamCupAmount));Exchange(msg.sender,teamCupAmount,allowance)"
./0x2e59c87e9349242063793761780550374a3146cf_ext.sol,THORToken.refundTokens,355,361,"TMP_111(bool) = msg.sender == owner,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113 = CONVERT this to address,TMP_114(bool) = _token != TMP_113,TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114),TMP_116 = CONVERT _token to AbstractToken,token(AbstractToken) := TMP_116(AbstractToken),TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ,Emit RefundTokens(_token,_refund,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_111(bool) = msg.sender == owner
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_113 = CONVERT this to address
TMP_114(bool) = _token != TMP_113
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
token = AbstractToken(_token)

IRs:
TMP_116 = CONVERT _token to AbstractToken
token(AbstractToken) := TMP_116(AbstractToken)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(_refund,_value)

IRs:
TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RefundTokens(_token,_refund,_value)

IRs:
Emit RefundTokens(_token,_refund,_value)""];
}
",1,0,0,0,"require(bool)(msg.sender == owner);require(bool)(_token != address(this));token = AbstractToken(_token);token.transfer(_refund,_value);RefundTokens(_token,_refund,_value)"
./0x6f9e77dc013e6a7156a5aeb26fb095f3405fd911_ext.sol,FlexibleTokenSale.reclaimTokens,316,329,"TMP_169 = CONVERT this to address,TMP_170(uint256) = HIGH_LEVEL_CALL, dest:token(TokenTransfer), function:balanceOf, arguments:['TMP_169']  ,tokens(uint256) := TMP_170(uint256),TMP_171(bool) = tokens == 0,CONDITION TMP_171,RETURN False,TMP_172(bool) = HIGH_LEVEL_CALL, dest:token(TokenTransfer), function:transfer, arguments:['owner', 'tokens']  ,TMP_173(None) = SOLIDITY_CALL require(bool)(TMP_172),Emit TokensReclaimed(tokens),RETURN True,MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = token.balanceOf(address(this))

IRs:
TMP_169 = CONVERT this to address
TMP_170(uint256) = HIGH_LEVEL_CALL, dest:token(TokenTransfer), function:balanceOf, arguments:['TMP_169']  
tokens(uint256) := TMP_170(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
tokens == 0

IRs:
TMP_171(bool) = tokens == 0
CONDITION TMP_171""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3

EXPRESSION:
false

IRs:
RETURN False""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(token.transfer(owner,tokens))

IRs:
TMP_172(bool) = HIGH_LEVEL_CALL, dest:token(TokenTransfer), function:transfer, arguments:['owner', 'tokens']  
TMP_173(None) = SOLIDITY_CALL require(bool)(TMP_172)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
TokensReclaimed(tokens)

IRs:
Emit TokensReclaimed(tokens)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
8->1;
}
",1,0,0,0,"onlyOwner();tokens = token.balanceOf(address(this));tokens == 0;false;;require(bool)(token.transfer(owner,tokens));TokensReclaimed(tokens);true"
./0x0e54b1b8ff833b5f2b0d17453d97d340cb7576e4_ext.sol,ERC223Token.transfer,106,114,"TMP_24(bool) = INTERNAL_CALL, ERC223Token.isContract(address)(_to),CONDITION TMP_24,TMP_25(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(msg.sender),TMP_26(bool) = TMP_25 < _value,CONDITION TMP_26,TMP_27(None) = SOLIDITY_CALL revert()(),REF_1(uint256) -> balances[msg.sender],TMP_28(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(msg.sender),TMP_29(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(TMP_28,_value),REF_1(uint256) (->balances) := TMP_29(uint256),REF_2(uint256) -> balances[_to],TMP_30(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(_to),TMP_31(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(TMP_30,_value),REF_2(uint256) (->balances) := TMP_31(uint256),TMP_33(bytes32) = SOLIDITY_CALL keccak256()(_custom_fallback),TMP_34 = CONVERT TMP_33 to bytes4,TMP_35(bool) = LOW_LEVEL_CALL, dest:_to, function:call, arguments:['TMP_34', 'msg.sender', '_value', '_data'] value:0 ,TMP_36(None) = SOLIDITY_CALL assert(bool)(TMP_35),Emit Transfer(msg.sender,_to,_value,_data),RETURN True,TMP_38(bool) = INTERNAL_CALL, ERC223Token.transferToAddress(address,uint256,bytes)(_to,_value,_data),RETURN TMP_38,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
isContract(_to)

IRs:
TMP_24(bool) = INTERNAL_CALL, ERC223Token.isContract(address)(_to)
CONDITION TMP_24""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
balanceOf(msg.sender) < _value

IRs:
TMP_25(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(msg.sender)
TMP_26(bool) = TMP_25 < _value
CONDITION TMP_26""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
revert()()

IRs:
TMP_27(None) = SOLIDITY_CALL revert()()""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[msg.sender] = safeSub(balanceOf(msg.sender),_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_28(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(msg.sender)
TMP_29(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(TMP_28,_value)
REF_1(uint256) (->balances) := TMP_29(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[_to] = safeAdd(balanceOf(_to),_value)

IRs:
REF_2(uint256) -> balances[_to]
TMP_30(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(_to)
TMP_31(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(TMP_30,_value)
REF_2(uint256) (->balances) := TMP_31(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(_to.call.value(0)(bytes4(keccak256()(_custom_fallback)),msg.sender,_value,_data))

IRs:
TMP_33(bytes32) = SOLIDITY_CALL keccak256()(_custom_fallback)
TMP_34 = CONVERT TMP_33 to bytes4
TMP_35(bool) = LOW_LEVEL_CALL, dest:_to, function:call, arguments:['TMP_34', 'msg.sender', '_value', '_data'] value:0 
TMP_36(None) = SOLIDITY_CALL assert(bool)(TMP_35)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(msg.sender,_to,_value,_data)

IRs:
Emit Transfer(msg.sender,_to,_value,_data)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: RETURN 10

EXPRESSION:
transferToAddress(_to,_value,_data)

IRs:
TMP_38(bool) = INTERNAL_CALL, ERC223Token.transferToAddress(address,uint256,bytes)(_to,_value,_data)
RETURN TMP_38""];
12[label=""Node Type: RETURN 12

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,0,0,0,"isContract(_to);balanceOf(msg.sender) < _value;transferToAddress(_to,_value,_data);revert()();;balances[msg.sender] = safeSub(balanceOf(msg.sender),_value);balances[_to] = safeAdd(balanceOf(_to),_value);assert(bool)(_to.call.value(0)(bytes4(keccak256()(_custom_fallback)),msg.sender,_value,_data));Transfer(msg.sender,_to,_value,_data);true;success"
./0x261ace754fba8af93e1fecdff13640540402940f_ext.sol,Phila_Token.claimTokens,207,218,"TMP_46 = CONVERT this to address,TMP_47(bool) = _token != TMP_46,TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47),TMP_49(bool) = _token == 0,CONDITION TMP_49,TMP_50 = CONVERT this to address,TMP_51(uint256) = SOLIDITY_CALL balance(address)(TMP_50),Transfer dest:owner value:TMP_51,TMP_53 = CONVERT _token to ERC20Interface,token(ERC20Interface) := TMP_53(ERC20Interface),TMP_54(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Interface), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_54(uint256),TMP_55(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Interface), function:transfer, arguments:['owner', 'balance']  ,Emit ClaimedTokens(_token,owner,balance),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_46 = CONVERT this to address
TMP_47(bool) = _token != TMP_46
TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
_token == 0x0

IRs:
TMP_49(bool) = _token == 0
CONDITION TMP_49""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_50 = CONVERT this to address
TMP_51(uint256) = SOLIDITY_CALL balance(address)(TMP_50)
Transfer dest:owner value:TMP_51""];
3->4;
4[label=""Node Type: RETURN 4
""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
token = ERC20Interface(_token)

IRs:
TMP_53 = CONVERT _token to ERC20Interface
token(ERC20Interface) := TMP_53(ERC20Interface)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_54(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Interface), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_54(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
token.transfer(owner,balance)

IRs:
TMP_55(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Interface), function:transfer, arguments:['owner', 'balance']  ""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
ClaimedTokens(_token,owner,balance)

IRs:
Emit ClaimedTokens(_token,owner,balance)""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
10->1;
}
",1,0,1,0,"onlyOwner();require(bool)(_token != address(this));_token == 0x0;owner.transfer(address(this).balance);;;token = ERC20Interface(_token);balance = token.balanceOf(this);token.transfer(owner,balance);ClaimedTokens(_token,owner,balance)"
./0x4c129783b42833220ad57d48548f871189009d3f_ext.sol,HoQuBurner.burnFrom,294,304,"TMP_83(bool) = _tokens > 0,TMP_84(None) = SOLIDITY_CALL require(bool)(TMP_83),TMP_85 = CONVERT 0 to address,TMP_86(bool) = HIGH_LEVEL_CALL, dest:token(HoQuToken), function:transfer, arguments:['TMP_85', '_tokens']  ,REF_57(address) -> transactionAddresses[transactionsCount],REF_57(address) (->transactionAddresses) := _sender(address),REF_58(uint256) -> transactionAmounts[transactionsCount],REF_58(uint256) (->transactionAmounts) := _tokens(uint256),TMP_87(uint32) := transactionsCount(uint32),transactionsCount(uint32) = transactionsCount + 1,Emit TokenBurned(_sender,_tokens),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_tokens > 0)

IRs:
TMP_83(bool) = _tokens > 0
TMP_84(None) = SOLIDITY_CALL require(bool)(TMP_83)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
token.transfer(address(0),_tokens)

IRs:
TMP_85 = CONVERT 0 to address
TMP_86(bool) = HIGH_LEVEL_CALL, dest:token(HoQuToken), function:transfer, arguments:['TMP_85', '_tokens']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
transactionAddresses[transactionsCount] = _sender

IRs:
REF_57(address) -> transactionAddresses[transactionsCount]
REF_57(address) (->transactionAddresses) := _sender(address)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
transactionAmounts[transactionsCount] = _tokens

IRs:
REF_58(uint256) -> transactionAmounts[transactionsCount]
REF_58(uint256) (->transactionAmounts) := _tokens(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
transactionsCount ++

IRs:
TMP_87(uint32) := transactionsCount(uint32)
transactionsCount(uint32) = transactionsCount + 1""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
TokenBurned(_sender,_tokens)

IRs:
Emit TokenBurned(_sender,_tokens)""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->1;
}
",1,0,0,0,"onlyOwner();require(bool)(_tokens > 0);token.transfer(address(0),_tokens);transactionAddresses[transactionsCount] = _sender;transactionAmounts[transactionsCount] = _tokens;transactionsCount ++;TokenBurned(_sender,_tokens)"
./0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0_ext.sol,Play0x_LottoBall.sendTokenFundsToManager,864,867,"TMP_461 = CONVERT ERC20ContractAddres to ERC20,HIGH_LEVEL_CALL, dest:TMP_461(ERC20), function:transfer, arguments:['manager', 'amount']  ,Emit TokenPayment(manager,amount),MODIFIER_CALL, Play0x_LottoBall.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ERC20(ERC20ContractAddres).transfer(manager,amount)

IRs:
TMP_461 = CONVERT ERC20ContractAddres to ERC20
HIGH_LEVEL_CALL, dest:TMP_461(ERC20), function:transfer, arguments:['manager', 'amount']  ""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
TokenPayment(manager,amount)

IRs:
Emit TokenPayment(manager,amount)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Play0x_LottoBall.onlyOwner()()""];
3->1;
}
",1,0,0,0,"onlyOwner();ERC20(ERC20ContractAddres).transfer(manager,amount);TokenPayment(manager,amount)"
./0x20c476bb4c7aa64f919278fb9c09e880583beb4c_ext.sol,X3ProfitMainFundTransfer.fallback,21,37,"TMP_0(bool) = msg.value == 0,TMP_1(bool) = msg.sender == ADDRESS_EIFP2_CONTRACT,TMP_2(bool) = msg.value >= 100000000000000000,TMP_3(bool) = TMP_1 && TMP_2,TMP_4 = UnaryType.BANG isResend ,TMP_5(bool) = TMP_3 && TMP_4,TMP_6(bool) = TMP_0 || TMP_5,CONDITION TMP_6,TMP_7(uint256) = SOLIDITY_CALL balance(address)(ADDRESS_EIFP2_CONTRACT),TMP_8(bool) = TMP_7 > maxBalance,CONDITION TMP_8,TMP_9 = CONVERT this to address,TMP_10(uint256) = SOLIDITY_CALL balance(address)(TMP_9),Transfer dest:ADDRESS_ADMIN value:TMP_10,TMP_12(bool) = msg.sender == ADDRESS_EIFP2_CONTRACT,isResend(bool) := TMP_12(bool),TMP_13 = CONVERT this to address,TMP_14(uint256) = SOLIDITY_CALL balance(address)(TMP_13),TMP_16(bool) = LOW_LEVEL_CALL, dest:ADDRESS_EIFP2_CONTRACT, function:call, arguments:[] value:TMP_14 ,TMP_17 = UnaryType.BANG TMP_16 ,CONDITION TMP_17,TMP_18(None) = SOLIDITY_CALL revert()(),isResend(bool) := False(bool)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value == 0 || (msg.sender == ADDRESS_EIFP2_CONTRACT && msg.value >= 100000000000000000 && ! isResend)

IRs:
TMP_0(bool) = msg.value == 0
TMP_1(bool) = msg.sender == ADDRESS_EIFP2_CONTRACT
TMP_2(bool) = msg.value >= 100000000000000000
TMP_3(bool) = TMP_1 && TMP_2
TMP_4 = UnaryType.BANG isResend 
TMP_5(bool) = TMP_3 && TMP_4
TMP_6(bool) = TMP_0 || TMP_5
CONDITION TMP_6""];
1->2[label=""True""];
1->11[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
ADDRESS_EIFP2_CONTRACT.balance > maxBalance

IRs:
TMP_7(uint256) = SOLIDITY_CALL balance(address)(ADDRESS_EIFP2_CONTRACT)
TMP_8(bool) = TMP_7 > maxBalance
CONDITION TMP_8""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ADDRESS_ADMIN.transfer(address(this).balance)

IRs:
TMP_9 = CONVERT this to address
TMP_10(uint256) = SOLIDITY_CALL balance(address)(TMP_9)
Transfer dest:ADDRESS_ADMIN value:TMP_10""];
3->4;
4[label=""Node Type: RETURN 4
""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
isResend = msg.sender == ADDRESS_EIFP2_CONTRACT

IRs:
TMP_12(bool) = msg.sender == ADDRESS_EIFP2_CONTRACT
isResend(bool) := TMP_12(bool)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
! ADDRESS_EIFP2_CONTRACT.call.value(address(this).balance)()

IRs:
TMP_13 = CONVERT this to address
TMP_14(uint256) = SOLIDITY_CALL balance(address)(TMP_13)
TMP_16(bool) = LOW_LEVEL_CALL, dest:ADDRESS_EIFP2_CONTRACT, function:call, arguments:[] value:TMP_14 
TMP_17 = UnaryType.BANG TMP_16 
CONDITION TMP_17""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
revert()()

IRs:
TMP_18(None) = SOLIDITY_CALL revert()()""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
isResend = false

IRs:
isResend(bool) := False(bool)""];
10->11;
11[label=""Node Type: END_IF 11
""];
}
",1,0,1,0,msg.value == 0 || (msg.sender == ADDRESS_EIFP2_CONTRACT && msg.value >= 100000000000000000 && ! isResend);ADDRESS_EIFP2_CONTRACT.balance > maxBalance;;ADDRESS_ADMIN.transfer(address(this).balance);;;isResend = msg.sender == ADDRESS_EIFP2_CONTRACT;! ADDRESS_EIFP2_CONTRACT.call.value(address(this).balance)();revert()();;isResend = false
./0x4bc78f6619991b029b867b6d88d39c196332aba3_ext.sol,AlgoDEX.depositToken,219,225,"TMP_101(bool) = token == 0,CONDITION TMP_101,TMP_102(None) = SOLIDITY_CALL revert()(),TMP_103 = CONVERT token to Token,TMP_104(bool) = HIGH_LEVEL_CALL, dest:TMP_103(Token), function:transferFrom, arguments:['msg.sender', 'this', 'amount']  ,TMP_105 = UnaryType.BANG TMP_104 ,CONDITION TMP_105,TMP_106(None) = SOLIDITY_CALL revert()(),REF_62(mapping(address => uint256)) -> tokens[token],REF_63(uint256) -> REF_62[msg.sender],REF_64(mapping(address => uint256)) -> tokens[token],REF_65(uint256) -> REF_64[msg.sender],TMP_107(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_65,amount),REF_63(uint256) (->tokens) := TMP_107(uint256),REF_66(mapping(address => uint256)) -> tokens[token],REF_67(uint256) -> REF_66[msg.sender],Emit Deposit(token,msg.sender,amount,REF_67)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
token == 0

IRs:
TMP_101(bool) = token == 0
CONDITION TMP_101""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_102(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
! Token(token).transferFrom(msg.sender,this,amount)

IRs:
TMP_103 = CONVERT token to Token
TMP_104(bool) = HIGH_LEVEL_CALL, dest:TMP_103(Token), function:transferFrom, arguments:['msg.sender', 'this', 'amount']  
TMP_105 = UnaryType.BANG TMP_104 
CONDITION TMP_105""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
revert()()

IRs:
TMP_106(None) = SOLIDITY_CALL revert()()""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender],amount)

IRs:
REF_62(mapping(address => uint256)) -> tokens[token]
REF_63(uint256) -> REF_62[msg.sender]
REF_64(mapping(address => uint256)) -> tokens[token]
REF_65(uint256) -> REF_64[msg.sender]
TMP_107(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_65,amount)
REF_63(uint256) (->tokens) := TMP_107(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Deposit(token,msg.sender,amount,tokens[token][msg.sender])

IRs:
REF_66(mapping(address => uint256)) -> tokens[token]
REF_67(uint256) -> REF_66[msg.sender]
Emit Deposit(token,msg.sender,amount,REF_67)""];
}
",1,0,0,0,"token == 0;revert()();;! Token(token).transferFrom(msg.sender,this,amount);revert()();;tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender],amount);Deposit(token,msg.sender,amount,tokens[token][msg.sender])"
./0x514bc174df04a4b04ae2be81ee8c788c3796b06b_ext.sol,Deco.transfer,102,106,"TMP_14(bool) = INTERNAL_CALL, Deco.performTransfer(address,address,uint256,bytes)(msg.sender,_to,_value,),Emit Transfer(msg.sender,_to,_value),RETURN True,TMP_16(uint256) = 2 * 32,MODIFIER_CALL, Deco.onlyPayloadSize(uint256)(TMP_16)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
performTransfer(msg.sender,_to,_value,)

IRs:
TMP_14(bool) = INTERNAL_CALL, Deco.performTransfer(address,address,uint256,bytes)(msg.sender,_to,_value,)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyPayloadSize(2 * 32)

IRs:
TMP_16(uint256) = 2 * 32
MODIFIER_CALL, Deco.onlyPayloadSize(uint256)(TMP_16)""];
4->1;
}
",1,0,0,0,"onlyPayloadSize(2 * 32);performTransfer(msg.sender,_to,_value,);Transfer(msg.sender,_to,_value);true"
./0x89234fab776fb68ec3c33529aa66f09b69a7b5f0_ext.sol,SynergisProxyDeposit.setERC20address,141,146,"TMP_46 = CONVERT currentERC20contract to address,TMP_47(bool) = TMP_46 != 0,TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47),TMP_49 = CONVERT currentERC20contract to AbstractCon,ac(AbstractCon) := TMP_49(AbstractCon),TMP_50 = CONVERT this to address,TMP_51(uint256) = HIGH_LEVEL_CALL, dest:ac(AbstractCon), function:allowance, arguments:['currentERC20contract', 'TMP_50']  ,TMP_52(bool) = TMP_51 > 0,TMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52),ERC20address(address) := currentERC20contract(address),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(address(currentERC20contract) != 0)

IRs:
TMP_46 = CONVERT currentERC20contract to address
TMP_47(bool) = TMP_46 != 0
TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
ac = AbstractCon(currentERC20contract)

IRs:
TMP_49 = CONVERT currentERC20contract to AbstractCon
ac(AbstractCon) := TMP_49(AbstractCon)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(ac.allowance(currentERC20contract,address(this)) > 0)

IRs:
TMP_50 = CONVERT this to address
TMP_51(uint256) = HIGH_LEVEL_CALL, dest:ac(AbstractCon), function:allowance, arguments:['currentERC20contract', 'TMP_50']  
TMP_52(bool) = TMP_51 > 0
TMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ERC20address = currentERC20contract

IRs:
ERC20address(address) := currentERC20contract(address)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",1,0,0,0,"onlyOwner();require(bool)(address(currentERC20contract) != 0);ac = AbstractCon(currentERC20contract);require(bool)(ac.allowance(currentERC20contract,address(this)) > 0);ERC20address = currentERC20contract"
./0x85b794252e7f1b2b24392a5267ff2086c0c3d7d1_ext.sol,CashPokerProPreICO.transfer,216,224,"TMP_75(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['tokensLimit', 'tokensSold'] ,tokenAmountEnable(uint256) := TMP_75(uint256),TMP_76(bool) = amount > tokenAmountEnable,CONDITION TMP_76,amount(uint256) := tokenAmountEnable(uint256),TMP_77(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transferFrom, arguments:['tokenWallet', 'to', 'amount']  ,TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77),TMP_79(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokensSold', 'amount'] ,tokensSold(uint256) := TMP_79(uint256),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokenAmountEnable = tokensLimit.sub(tokensSold)

IRs:
TMP_75(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['tokensLimit', 'tokensSold'] 
tokenAmountEnable(uint256) := TMP_75(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
amount > tokenAmountEnable

IRs:
TMP_76(bool) = amount > tokenAmountEnable
CONDITION TMP_76""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
amount = tokenAmountEnable

IRs:
amount(uint256) := tokenAmountEnable(uint256)""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(token.transferFrom(tokenWallet,to,amount))

IRs:
TMP_77(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transferFrom, arguments:['tokenWallet', 'to', 'amount']  
TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tokensSold = tokensSold.add(amount)

IRs:
TMP_79(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokensSold', 'amount'] 
tokensSold(uint256) := TMP_79(uint256)""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->1;
}
",1,0,0,0,"onlyOwner();tokenAmountEnable = tokensLimit.sub(tokensSold);amount > tokenAmountEnable;amount = tokenAmountEnable;;require(bool)(token.transferFrom(tokenWallet,to,amount));tokensSold = tokensSold.add(amount)"
./0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0_ext.sol,Play0x_LottoBall.withdrawAlltokenFunds,354,358,"TMP_73 = CONVERT ERC20ContractAddres to ERC20,TMP_74 = CONVERT ERC20ContractAddres to ERC20,TMP_75 = CONVERT this to address,TMP_76(uint256) = HIGH_LEVEL_CALL, dest:TMP_74(ERC20), function:balanceOf, arguments:['TMP_75']  ,HIGH_LEVEL_CALL, dest:TMP_73(ERC20), function:transfer, arguments:['beneficiary', 'TMP_76']  ,lockedTokenInBets(uint256) := 0(uint256),TMP_78 = CONVERT ERC20ContractAddres to ERC20,TMP_79 = CONVERT this to address,TMP_80(uint256) = HIGH_LEVEL_CALL, dest:TMP_78(ERC20), function:balanceOf, arguments:['TMP_79']  ,Emit TokenPayment(beneficiary,TMP_80),MODIFIER_CALL, Play0x_LottoBall.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ERC20(ERC20ContractAddres).transfer(beneficiary,ERC20(ERC20ContractAddres).balanceOf(address(this)))

IRs:
TMP_73 = CONVERT ERC20ContractAddres to ERC20
TMP_74 = CONVERT ERC20ContractAddres to ERC20
TMP_75 = CONVERT this to address
TMP_76(uint256) = HIGH_LEVEL_CALL, dest:TMP_74(ERC20), function:balanceOf, arguments:['TMP_75']  
HIGH_LEVEL_CALL, dest:TMP_73(ERC20), function:transfer, arguments:['beneficiary', 'TMP_76']  ""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
lockedTokenInBets = 0

IRs:
lockedTokenInBets(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
TokenPayment(beneficiary,ERC20(ERC20ContractAddres).balanceOf(address(this)))

IRs:
TMP_78 = CONVERT ERC20ContractAddres to ERC20
TMP_79 = CONVERT this to address
TMP_80(uint256) = HIGH_LEVEL_CALL, dest:TMP_78(ERC20), function:balanceOf, arguments:['TMP_79']  
Emit TokenPayment(beneficiary,TMP_80)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Play0x_LottoBall.onlyOwner()()""];
4->1;
}
",1,0,0,0,"onlyOwner();ERC20(ERC20ContractAddres).transfer(beneficiary,ERC20(ERC20ContractAddres).balanceOf(address(this)));lockedTokenInBets = 0;TokenPayment(beneficiary,ERC20(ERC20ContractAddres).balanceOf(address(this)))"
./0x17f68886d00845867c154c912b4ccc506ec92fc7_ext.sol,DelegatedShareholderAssociation.vote,331,348,"REF_34(DelegatedShareholderAssociation.Proposal) -> proposals[proposalNumber],p(DelegatedShareholderAssociation.Proposal) := REF_34(DelegatedShareholderAssociation.Proposal),REF_35(mapping(address => bool)) -> p.voted,REF_36(bool) -> REF_35[msg.sender],TMP_62(bool) = REF_36 != True,TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62),REF_37(DelegatedShareholderAssociation.Vote[]) -> p.votes,REF_38 -> LENGTH REF_37,TMP_64(uint256) := REF_38(uint256),REF_38(-> p) = REF_38 + 1,voteID(uint256) := TMP_64(uint256),REF_39(DelegatedShareholderAssociation.Vote[]) -> p.votes,REF_40(DelegatedShareholderAssociation.Vote) -> REF_39[voteID],TMP_65(DelegatedShareholderAssociation.Vote) = new Vote(supportsProposal,msg.sender),REF_40(DelegatedShareholderAssociation.Vote) (->p) := TMP_65(DelegatedShareholderAssociation.Vote),REF_41(mapping(address => bool)) -> p.voted,REF_42(bool) -> REF_41[msg.sender],REF_42(bool) (->p) := True(bool),REF_43(uint256) -> p.numberOfVotes,TMP_66(uint256) = voteID + 1,REF_43(uint256) (->p) := TMP_66(uint256),Emit Voted(proposalNumber,supportsProposal,msg.sender),RETURN voteID,MODIFIER_CALL, DelegatedShareholderAssociation.onlyShareholders()(),MODIFIER_CALL, DelegatedShareholderAssociation.notSelf()(),RETURN voteID","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
p = proposals[proposalNumber]

IRs:
REF_34(DelegatedShareholderAssociation.Proposal) -> proposals[proposalNumber]
p(DelegatedShareholderAssociation.Proposal) := REF_34(DelegatedShareholderAssociation.Proposal)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(p.voted[msg.sender] != true)

IRs:
REF_35(mapping(address => bool)) -> p.voted
REF_36(bool) -> REF_35[msg.sender]
TMP_62(bool) = REF_36 != True
TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
voteID = p.votes.length ++

IRs:
REF_37(DelegatedShareholderAssociation.Vote[]) -> p.votes
REF_38 -> LENGTH REF_37
TMP_64(uint256) := REF_38(uint256)
REF_38(-> p) = REF_38 + 1
voteID(uint256) := TMP_64(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
p.votes[voteID] = Vote({inSupport:supportsProposal,voter:msg.sender})

IRs:
REF_39(DelegatedShareholderAssociation.Vote[]) -> p.votes
REF_40(DelegatedShareholderAssociation.Vote) -> REF_39[voteID]
TMP_65(DelegatedShareholderAssociation.Vote) = new Vote(supportsProposal,msg.sender)
REF_40(DelegatedShareholderAssociation.Vote) (->p) := TMP_65(DelegatedShareholderAssociation.Vote)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
p.voted[msg.sender] = true

IRs:
REF_41(mapping(address => bool)) -> p.voted
REF_42(bool) -> REF_41[msg.sender]
REF_42(bool) (->p) := True(bool)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
p.numberOfVotes = voteID + 1

IRs:
REF_43(uint256) -> p.numberOfVotes
TMP_66(uint256) = voteID + 1
REF_43(uint256) (->p) := TMP_66(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Voted(proposalNumber,supportsProposal,msg.sender)

IRs:
Emit Voted(proposalNumber,supportsProposal,msg.sender)""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
voteID

IRs:
RETURN voteID""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyShareholders()

IRs:
MODIFIER_CALL, DelegatedShareholderAssociation.onlyShareholders()()""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
notSelf()

IRs:
MODIFIER_CALL, DelegatedShareholderAssociation.notSelf()()""];
10->1;
11[label=""Node Type: RETURN 11

EXPRESSION:
voteID

IRs:
RETURN voteID""];
}
",1,0,0,0,"onlyShareholders();p = proposals[proposalNumber];require(bool)(p.voted[msg.sender] != true);voteID = p.votes.length ++;p.votes[voteID] = Vote({inSupport:supportsProposal,voter:msg.sender});p.voted[msg.sender] = true;p.numberOfVotes = voteID + 1;Voted(proposalNumber,supportsProposal,msg.sender);voteID;notSelf();voteID"
./0x32c62c965db5fdac0f94e6276d6884070068d4be_ext.sol,MyAdvancedToken.transferFrom,61,69,"REF_9(uint256) -> balances_[who],TMP_11(bool) = REF_9 >= val,TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11),REF_10(mapping(address => uint256)) -> allowed_[who],REF_11(uint256) -> REF_10[msg.sender],TMP_13(bool) = REF_11 >= val,TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13),REF_12(mapping(address => uint256)) -> allowed_[who],REF_13(uint256) -> REF_12[msg.sender],REF_13(-> allowed_) = REF_13 - val,REF_14(uint256) -> balances_[who],REF_14(-> balances_) = REF_14 - val,REF_15(uint256) -> balances_[to],REF_15(-> balances_) = REF_15 + val,Emit Transfer(who,to,val),RETURN True,MODIFIER_CALL, MyAdvancedToken.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances_[who] >= val)

IRs:
REF_9(uint256) -> balances_[who]
TMP_11(bool) = REF_9 >= val
TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(allowed_[who][msg.sender] >= val)

IRs:
REF_10(mapping(address => uint256)) -> allowed_[who]
REF_11(uint256) -> REF_10[msg.sender]
TMP_13(bool) = REF_11 >= val
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
allowed_[who][msg.sender] -= val

IRs:
REF_12(mapping(address => uint256)) -> allowed_[who]
REF_13(uint256) -> REF_12[msg.sender]
REF_13(-> allowed_) = REF_13 - val""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances_[who] -= val

IRs:
REF_14(uint256) -> balances_[who]
REF_14(-> balances_) = REF_14 - val""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances_[to] += val

IRs:
REF_15(uint256) -> balances_[to]
REF_15(-> balances_) = REF_15 + val""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(who,to,val)

IRs:
Emit Transfer(who,to,val)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, MyAdvancedToken.whenNotPaused()()""];
8->1;
}
",1,0,0,0,"whenNotPaused();require(bool)(balances_[who] >= val);require(bool)(allowed_[who][msg.sender] >= val);allowed_[who][msg.sender] -= val;balances_[who] -= val;balances_[to] += val;Transfer(who,to,val);true"
./0x3a2fd07ec2ad6f355f93af695a7cf858f5967b78_ext.sol,MTVote.onTokenReceived,122,144,"TMP_32(bool) = msg.sender == TVTokenAddress,TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32),TMP_34 = UnaryType.BANG pause ,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),TMP_36(bytes32) = INTERNAL_CALL, MTVote.convertBytesToBytes32(bytes)(_data),TMP_37 = CONVERT TMP_36 to uint256,targetId(uint256) := TMP_37(uint256),REF_4(uint256) -> targets[targetId],REF_4(-> targets) = REF_4 + _value,TMP_38 = CONVERT TVTokenAddress to TVToken,TMP_39(bool) = HIGH_LEVEL_CALL, dest:TMP_38(TVToken), function:transfer, arguments:['wallet', '_value']  ,TMP_40 = CONVERT 0 to address,checkAndBuySender(address) := TMP_40(address),inList(bool) := False(bool),i(uint256) := 0(uint256),TMP_41(bool) = i < targetIdsSize,CONDITION TMP_41,REF_6(uint256) -> targetIds[i],TMP_42(bool) = REF_6 == targetId,CONDITION TMP_42,inList(bool) := True(bool),TMP_43(uint256) := i(uint256),i(uint256) = i + 1,TMP_44 = UnaryType.BANG inList ,CONDITION TMP_44,REF_8 -> LENGTH targetIds,TMP_46(uint256) := REF_8(uint256),TMP_47(uint256) = TMP_46 + 1,REF_8(uint256) (->targetIds) := TMP_47(uint256),REF_9(uint256) -> targetIds[TMP_46],REF_9(uint256) (->targetIds) := targetId(uint256),TMP_48(uint256) := targetIdsSize(uint256),targetIdsSize(uint256) = targetIdsSize + 1,Emit TokenReceived(_from,_value,targetId),RETURN TOKEN_RECEIVED,TMP_50(bool) = this == _from,CONDITION TMP_50,_from(address) := checkAndBuySender(address),_from(address) := _from(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == TVTokenAddress)

IRs:
TMP_32(bool) = msg.sender == TVTokenAddress
TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! pause)

IRs:
TMP_34 = UnaryType.BANG pause 
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
targetId = uint256(convertBytesToBytes32(_data))

IRs:
TMP_36(bytes32) = INTERNAL_CALL, MTVote.convertBytesToBytes32(bytes)(_data)
TMP_37 = CONVERT TMP_36 to uint256
targetId(uint256) := TMP_37(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
targets[targetId] += _value

IRs:
REF_4(uint256) -> targets[targetId]
REF_4(-> targets) = REF_4 + _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
TVToken(TVTokenAddress).transfer(wallet,_value)

IRs:
TMP_38 = CONVERT TVTokenAddress to TVToken
TMP_39(bool) = HIGH_LEVEL_CALL, dest:TMP_38(TVToken), function:transfer, arguments:['wallet', '_value']  ""];
5->23;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
checkAndBuySender = address(0)

IRs:
TMP_40 = CONVERT 0 to address
checkAndBuySender(address) := TMP_40(address)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
inList = false

IRs:
inList(bool) := False(bool)""];
8->11;
9[label=""Node Type: BEGIN_LOOP 9
""];
9->12;
10[label=""Node Type: END_LOOP 10
""];
10->17;
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
11->9;
12[label=""Node Type: IF_LOOP 12

EXPRESSION:
i < targetIdsSize

IRs:
TMP_41(bool) = i < targetIdsSize
CONDITION TMP_41""];
12->13[label=""True""];
12->10[label=""False""];
13[label=""Node Type: IF 13

EXPRESSION:
targetIds[i] == targetId

IRs:
REF_6(uint256) -> targetIds[i]
TMP_42(bool) = REF_6 == targetId
CONDITION TMP_42""];
13->14[label=""True""];
13->15[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
inList = true

IRs:
inList(bool) := True(bool)""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
i ++

IRs:
TMP_43(uint256) := i(uint256)
i(uint256) = i + 1""];
16->12;
17[label=""Node Type: IF 17

EXPRESSION:
! inList

IRs:
TMP_44 = UnaryType.BANG inList 
CONDITION TMP_44""];
17->18[label=""True""];
17->20[label=""False""];
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
targetIds.push(targetId)

IRs:
REF_8 -> LENGTH targetIds
TMP_46(uint256) := REF_8(uint256)
TMP_47(uint256) = TMP_46 + 1
REF_8(uint256) (->targetIds) := TMP_47(uint256)
REF_9(uint256) -> targetIds[TMP_46]
REF_9(uint256) (->targetIds) := targetId(uint256)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
targetIdsSize ++

IRs:
TMP_48(uint256) := targetIdsSize(uint256)
targetIdsSize(uint256) = targetIdsSize + 1""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
TokenReceived(_from,_value,targetId)

IRs:
Emit TokenReceived(_from,_value,targetId)""];
21->22;
22[label=""Node Type: RETURN 22

EXPRESSION:
TOKEN_RECEIVED

IRs:
RETURN TOKEN_RECEIVED""];
23[label=""Node Type: IF 23

EXPRESSION:
this == _from

IRs:
TMP_50(bool) = this == _from
CONDITION TMP_50""];
23->24[label=""True""];
23->25[label=""False""];
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
_from = checkAndBuySender

IRs:
_from(address) := checkAndBuySender(address)""];
24->26;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
_from = _from

IRs:
_from(address) := _from(address)""];
25->26;
26[label=""Node Type: END_IF 26
""];
26->7;
}
",1,0,0,0,"require(bool)(msg.sender == TVTokenAddress);require(bool)(! pause);targetId = uint256(convertBytesToBytes32(_data));targets[targetId] += _value;TVToken(TVTokenAddress).transfer(wallet,_value);this == _from;checkAndBuySender = address(0);inList = false;i = 0;;i < targetIdsSize;;! inList;targetIds[i] == targetId;inList = true;;i ++;targetIds.push(targetId);;targetIdsSize ++;TokenReceived(_from,_value,targetId);TOKEN_RECEIVED;_from = checkAndBuySender;_from = _from;"
./0x548f7581e85b473da466ef9edbe85c5226eaa3b2_ext.sol,ListingsERC20.buyListing,149,169,"REF_11(ListingsERC20.Listing) -> listings[listingId],listing(ListingsERC20.Listing) := REF_11(ListingsERC20.Listing),REF_12(address) -> listing.seller,seller(address) := REF_12(address),REF_13(address) -> listing.tokenContractAddress,contractAddress(address) := REF_13(address),REF_14(uint256) -> listing.price,price(uint256) := REF_14(uint256),TMP_55(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['price', 'amount'] ,sale(uint256) := TMP_55(uint256),REF_16(uint256) -> listing.allowance,allowance(uint256) := REF_16(uint256),REF_17(uint256) -> listing.dateEnds,TMP_56(bool) = now <= REF_17,TMP_57(None) = SOLIDITY_CALL require(bool)(TMP_56),REF_18(uint256) -> sold[listingId],TMP_58(uint256) = allowance - REF_18,TMP_59(bool) = TMP_58 >= amount,TMP_60(None) = SOLIDITY_CALL require(bool)(TMP_59),TMP_61(uint256) = INTERNAL_CALL, ListingsERC20.getBalance(address,address)(contractAddress,seller),TMP_62(bool) = TMP_61 >= amount,TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62),TMP_64(uint256) = INTERNAL_CALL, ListingsERC20.getAllowance(address,address,address)(contractAddress,seller,this),TMP_65(bool) = TMP_64 >= amount,TMP_66(None) = SOLIDITY_CALL require(bool)(TMP_65),TMP_67(bool) = msg.value == sale,TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67),TMP_69 = CONVERT contractAddress to ERC20,tokenContract(ERC20) := TMP_69(ERC20),TMP_70(bool) = HIGH_LEVEL_CALL, dest:tokenContract(ERC20), function:transferFrom, arguments:['seller', 'msg.sender', 'amount']  ,TMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70),TMP_72(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['sale', 'ownerPercentage'] ,TMP_73(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_72', '10000'] ,TMP_74(uint256) = sale - TMP_73,Transfer dest:seller value:TMP_74,REF_23(uint256) -> sold[listingId],TMP_76(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['allowance', 'amount'] ,REF_23(uint256) (->sold) := TMP_76(uint256),Emit ListingBought(listingId,contractAddress,price,amount,now,msg.sender)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
listing = listings[listingId]

IRs:
REF_11(ListingsERC20.Listing) -> listings[listingId]
listing(ListingsERC20.Listing) := REF_11(ListingsERC20.Listing)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
seller = listing.seller

IRs:
REF_12(address) -> listing.seller
seller(address) := REF_12(address)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
contractAddress = listing.tokenContractAddress

IRs:
REF_13(address) -> listing.tokenContractAddress
contractAddress(address) := REF_13(address)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
price = listing.price

IRs:
REF_14(uint256) -> listing.price
price(uint256) := REF_14(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
sale = price.mul(amount)

IRs:
TMP_55(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['price', 'amount'] 
sale(uint256) := TMP_55(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
allowance = listing.allowance

IRs:
REF_16(uint256) -> listing.allowance
allowance(uint256) := REF_16(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(now <= listing.dateEnds)

IRs:
REF_17(uint256) -> listing.dateEnds
TMP_56(bool) = now <= REF_17
TMP_57(None) = SOLIDITY_CALL require(bool)(TMP_56)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(allowance - sold[listingId] >= amount)

IRs:
REF_18(uint256) -> sold[listingId]
TMP_58(uint256) = allowance - REF_18
TMP_59(bool) = TMP_58 >= amount
TMP_60(None) = SOLIDITY_CALL require(bool)(TMP_59)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(getBalance(contractAddress,seller) >= amount)

IRs:
TMP_61(uint256) = INTERNAL_CALL, ListingsERC20.getBalance(address,address)(contractAddress,seller)
TMP_62(bool) = TMP_61 >= amount
TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(getAllowance(contractAddress,seller,this) >= amount)

IRs:
TMP_64(uint256) = INTERNAL_CALL, ListingsERC20.getAllowance(address,address,address)(contractAddress,seller,this)
TMP_65(bool) = TMP_64 >= amount
TMP_66(None) = SOLIDITY_CALL require(bool)(TMP_65)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
require(bool)(msg.value == sale)

IRs:
TMP_67(bool) = msg.value == sale
TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)""];
11->12;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
tokenContract = ERC20(contractAddress)

IRs:
TMP_69 = CONVERT contractAddress to ERC20
tokenContract(ERC20) := TMP_69(ERC20)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
require(bool)(tokenContract.transferFrom(seller,msg.sender,amount))

IRs:
TMP_70(bool) = HIGH_LEVEL_CALL, dest:tokenContract(ERC20), function:transferFrom, arguments:['seller', 'msg.sender', 'amount']  
TMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
seller.transfer(sale - (sale.mul(ownerPercentage).div(10000)))

IRs:
TMP_72(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['sale', 'ownerPercentage'] 
TMP_73(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_72', '10000'] 
TMP_74(uint256) = sale - TMP_73
Transfer dest:seller value:TMP_74""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
sold[listingId] = allowance.sub(amount)

IRs:
REF_23(uint256) -> sold[listingId]
TMP_76(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['allowance', 'amount'] 
REF_23(uint256) (->sold) := TMP_76(uint256)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
ListingBought(listingId,contractAddress,price,amount,now,msg.sender)

IRs:
Emit ListingBought(listingId,contractAddress,price,amount,now,msg.sender)""];
}
",1,0,0,0,"listing = listings[listingId];seller = listing.seller;contractAddress = listing.tokenContractAddress;price = listing.price;sale = price.mul(amount);allowance = listing.allowance;require(bool)(now <= listing.dateEnds);require(bool)(allowance - sold[listingId] >= amount);require(bool)(getBalance(contractAddress,seller) >= amount);require(bool)(getAllowance(contractAddress,seller,this) >= amount);require(bool)(msg.value == sale);tokenContract = ERC20(contractAddress);require(bool)(tokenContract.transferFrom(seller,msg.sender,amount));seller.transfer(sale - (sale.mul(ownerPercentage).div(10000)));sold[listingId] = allowance.sub(amount);ListingBought(listingId,contractAddress,price,amount,now,msg.sender)"
./0x21ad0028fea5fafa55b9b60e9c065db9f1c0616e_ext.sol,LikeCrowdsale.transferLike,477,481,"TMP_278(bool) = now < start,TMP_279(bool) = now >= end,TMP_280(bool) = TMP_278 || TMP_279,TMP_281(None) = SOLIDITY_CALL require(bool)(TMP_280),TMP_282(bool) = HIGH_LEVEL_CALL, dest:like(LikeCoin), function:transfer, arguments:['_to', '_value']  ,Emit LikeTransfer(_to,_value),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now < start || now >= end)

IRs:
TMP_278(bool) = now < start
TMP_279(bool) = now >= end
TMP_280(bool) = TMP_278 || TMP_279
TMP_281(None) = SOLIDITY_CALL require(bool)(TMP_280)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
like.transfer(_to,_value)

IRs:
TMP_282(bool) = HIGH_LEVEL_CALL, dest:like(LikeCoin), function:transfer, arguments:['_to', '_value']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
LikeTransfer(_to,_value)

IRs:
Emit LikeTransfer(_to,_value)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->1;
}
",1,0,0,0,"onlyOwner();require(bool)(now < start || now >= end);like.transfer(_to,_value);LikeTransfer(_to,_value)"
./0xd0080a841a8c5d2b6cd4bc640cdad7846de14dbf_ext.sol,FtvTimelockFactory.assignBalance,97,107,"TMP_25(bool) = _amount > 0,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),TMP_27(bool) = msg.sender == tokenAssignmentControl,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_14(uint256) -> releaseTimes[_holder],TMP_29(bool) = REF_14 == 0,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),totalSupply(uint256) = totalSupply + _amount,TMP_31(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  ,TMP_32(bool) = totalSupply <= TMP_31,TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32),REF_16(uint256) -> releaseTimes[_holder],REF_16(uint256) (->releaseTimes) := _releaseTime(uint256),REF_17(uint256) -> balances[_holder],REF_18(uint256) -> balances[_holder],TMP_34(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_18', '_amount'] ,REF_17(uint256) (->balances) := TMP_34(uint256),Emit Transfer(0,_holder,_amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_amount > 0)

IRs:
TMP_25(bool) = _amount > 0
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == tokenAssignmentControl)

IRs:
TMP_27(bool) = msg.sender == tokenAssignmentControl
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(releaseTimes[_holder] == 0)

IRs:
REF_14(uint256) -> releaseTimes[_holder]
TMP_29(bool) = REF_14 == 0
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
totalSupply += _amount

IRs:
totalSupply(uint256) = totalSupply + _amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(totalSupply <= token.balanceOf(this))

IRs:
TMP_31(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  
TMP_32(bool) = totalSupply <= TMP_31
TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
releaseTimes[_holder] = _releaseTime

IRs:
REF_16(uint256) -> releaseTimes[_holder]
REF_16(uint256) (->releaseTimes) := _releaseTime(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[_holder] = balances[_holder].add(_amount)

IRs:
REF_17(uint256) -> balances[_holder]
REF_18(uint256) -> balances[_holder]
TMP_34(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_18', '_amount'] 
REF_17(uint256) (->balances) := TMP_34(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(0x0,_holder,_amount)

IRs:
Emit Transfer(0,_holder,_amount)""];
}
",1,0,0,0,"require(bool)(_amount > 0);require(bool)(msg.sender == tokenAssignmentControl);require(bool)(releaseTimes[_holder] == 0);totalSupply += _amount;require(bool)(totalSupply <= token.balanceOf(this));releaseTimes[_holder] = _releaseTime;balances[_holder] = balances[_holder].add(_amount);Transfer(0x0,_holder,_amount)"
./0xf08a7fd4f4b75188e89d0d27c2ae474858402cea_ext.sol,DroneShowCoinICOContract.initialize,108,112,"TMP_24(bool) = initialized == False,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),TMP_26(uint256) = INTERNAL_CALL, DroneShowCoinICOContract.tokensAvailable()(),TMP_27(bool) = TMP_26 == numTokens,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),initialized(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(initialized == false)

IRs:
TMP_24(bool) = initialized == False
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(tokensAvailable() == numTokens)

IRs:
TMP_26(uint256) = INTERNAL_CALL, DroneShowCoinICOContract.tokensAvailable()()
TMP_27(bool) = TMP_26 == numTokens
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
initialized = true

IRs:
initialized(bool) := True(bool)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->1;
}
",1,0,0,0,onlyOwner();require(bool)(initialized == false);require(bool)(tokensAvailable() == numTokens);initialized = true
./0x7982a79ee90eb3682dcee66e47ba79c1cba44062_ext.sol,SaleClockAuction.bidGift,657,669,"REF_165(ClockAuctionBase.Auction) -> tokenIdToAuction[_tokenId],REF_166(address) -> REF_165.seller,seller(address) := REF_166(address),TMP_783(uint256) = INTERNAL_CALL, ClockAuctionBase._bid(uint256,uint256,address)(_tokenId,msg.value,msg.sender),price(uint256) := TMP_783(uint256),INTERNAL_CALL, ClockAuctionBase._transfer(address,uint256)(_to,_tokenId),TMP_785 = CONVERT gen0SellerAddress to address,TMP_786(bool) = seller == TMP_785,CONDITION TMP_786,TMP_787(uint256) = gen0SaleCount % 5,REF_167(uint256) -> lastGen0SalePrices[TMP_787],REF_167(uint256) (->lastGen0SalePrices) := price(uint256),TMP_788(uint256) := gen0SaleCount(uint256),gen0SaleCount(uint256) = gen0SaleCount + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
seller = tokenIdToAuction[_tokenId].seller

IRs:
REF_165(ClockAuctionBase.Auction) -> tokenIdToAuction[_tokenId]
REF_166(address) -> REF_165.seller
seller(address) := REF_166(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
price = _bid(_tokenId,msg.value,msg.sender)

IRs:
TMP_783(uint256) = INTERNAL_CALL, ClockAuctionBase._bid(uint256,uint256,address)(_tokenId,msg.value,msg.sender)
price(uint256) := TMP_783(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_transfer(_to,_tokenId)

IRs:
INTERNAL_CALL, ClockAuctionBase._transfer(address,uint256)(_to,_tokenId)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
seller == address(gen0SellerAddress)

IRs:
TMP_785 = CONVERT gen0SellerAddress to address
TMP_786(bool) = seller == TMP_785
CONDITION TMP_786""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
lastGen0SalePrices[gen0SaleCount % 5] = price

IRs:
TMP_787(uint256) = gen0SaleCount % 5
REF_167(uint256) -> lastGen0SalePrices[TMP_787]
REF_167(uint256) (->lastGen0SalePrices) := price(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
gen0SaleCount ++

IRs:
TMP_788(uint256) := gen0SaleCount(uint256)
gen0SaleCount(uint256) = gen0SaleCount + 1""];
6->7;
7[label=""Node Type: END_IF 7
""];
}
",1,0,0,0,"seller = tokenIdToAuction[_tokenId].seller;price = _bid(_tokenId,msg.value,msg.sender);_transfer(_to,_tokenId);seller == address(gen0SellerAddress);lastGen0SalePrices[gen0SaleCount % 5] = price;;gen0SaleCount ++"
./0x18f0cd26c06449d967ca6aef8b5f9d8ee9fd7992_ext.sol,Exch.withdrawToken,167,173,"REF_34(bool) -> whiteListERC20[token],REF_35(bool) -> whiteListERC223[token],TMP_64(bool) = REF_34 || REF_35,TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64),REF_36(mapping(address => uint256)) -> tokens[token],REF_37(uint256) -> REF_36[msg.sender],TMP_66(bool) = REF_37 < amount,CONDITION TMP_66,TMP_67(None) = SOLIDITY_CALL revert()(),REF_38(mapping(address => uint256)) -> tokens[token],REF_39(uint256) -> REF_38[msg.sender],REF_40(mapping(address => uint256)) -> tokens[token],REF_41(uint256) -> REF_40[msg.sender],TMP_68(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_41,amount),REF_39(uint256) (->tokens) := TMP_68(uint256),TMP_69 = CONVERT token to Token,TMP_70(bool) = HIGH_LEVEL_CALL, dest:TMP_69(Token), function:transfer, arguments:['msg.sender', 'amount']  ,TMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70),REF_43(mapping(address => uint256)) -> tokens[token],REF_44(uint256) -> REF_43[msg.sender],Emit Withdraw(token,msg.sender,amount,REF_44)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(whiteListERC20[token] || whiteListERC223[token])

IRs:
REF_34(bool) -> whiteListERC20[token]
REF_35(bool) -> whiteListERC223[token]
TMP_64(bool) = REF_34 || REF_35
TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
tokens[token][msg.sender] < amount

IRs:
REF_36(mapping(address => uint256)) -> tokens[token]
REF_37(uint256) -> REF_36[msg.sender]
TMP_66(bool) = REF_37 < amount
CONDITION TMP_66""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
revert()()

IRs:
TMP_67(None) = SOLIDITY_CALL revert()()""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
tokens[token][msg.sender] = safeSub(tokens[token][msg.sender],amount)

IRs:
REF_38(mapping(address => uint256)) -> tokens[token]
REF_39(uint256) -> REF_38[msg.sender]
REF_40(mapping(address => uint256)) -> tokens[token]
REF_41(uint256) -> REF_40[msg.sender]
TMP_68(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_41,amount)
REF_39(uint256) (->tokens) := TMP_68(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(Token(token).transfer(msg.sender,amount))

IRs:
TMP_69 = CONVERT token to Token
TMP_70(bool) = HIGH_LEVEL_CALL, dest:TMP_69(Token), function:transfer, arguments:['msg.sender', 'amount']  
TMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Withdraw(token,msg.sender,amount,tokens[token][msg.sender])

IRs:
REF_43(mapping(address => uint256)) -> tokens[token]
REF_44(uint256) -> REF_43[msg.sender]
Emit Withdraw(token,msg.sender,amount,REF_44)""];
}
",1,0,0,0,"require(bool)(whiteListERC20[token] || whiteListERC223[token]);tokens[token][msg.sender] < amount;revert()();;tokens[token][msg.sender] = safeSub(tokens[token][msg.sender],amount);require(bool)(Token(token).transfer(msg.sender,amount));Withdraw(token,msg.sender,amount,tokens[token][msg.sender])"
./0xc767b1cec507f1584469e8efe1a94ad4c75e02ed_ext.sol,PremiumFactories.claimUnits,135,153,"REF_44(PremiumFactories.PremiumFactory) -> premiumFactories[factoryId],factory(PremiumFactories.PremiumFactory) := REF_44(PremiumFactories.PremiumFactory),REF_45(address) -> factory.owner,TMP_67(bool) = REF_45 == msg.sender,TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67),REF_46(uint256) -> factory.unitId,REF_47(PremiumUnit) -> premiumUnits[REF_46],premiumUnit(PremiumUnit) := REF_47(PremiumUnit),TMP_69(uint256) = HIGH_LEVEL_CALL, dest:premiumUnit(PremiumUnit), function:unitProductionSeconds, arguments:[]  ,unitProductionSeconds(uint256) := TMP_69(uint256),REF_49(uint256) -> factory.lastClaimTimestamp,TMP_70(uint256) = now - REF_49,TMP_71(uint256) = TMP_70 / unitProductionSeconds,unitsProduced(uint256) := TMP_71(uint256),TMP_72(bool) = unitsProduced > 0,TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72),REF_50(uint256) -> factory.lastClaimTimestamp,TMP_74(uint256) = unitProductionSeconds * unitsProduced,REF_50(-> factory) = REF_50 + TMP_74,HIGH_LEVEL_CALL, dest:premiumUnit(PremiumUnit), function:mintUnit, arguments:['msg.sender', 'unitsProduced']  ,CONDITION equip,TMP_76 = CONVERT unitsProduced to uint80,HIGH_LEVEL_CALL, dest:premiumUnit(PremiumUnit), function:equipUnit, arguments:['msg.sender', 'TMP_76', '100']  ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
factory = premiumFactories[factoryId]

IRs:
REF_44(PremiumFactories.PremiumFactory) -> premiumFactories[factoryId]
factory(PremiumFactories.PremiumFactory) := REF_44(PremiumFactories.PremiumFactory)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(factory.owner == msg.sender)

IRs:
REF_45(address) -> factory.owner
TMP_67(bool) = REF_45 == msg.sender
TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
premiumUnit = premiumUnits[factory.unitId]

IRs:
REF_46(uint256) -> factory.unitId
REF_47(PremiumUnit) -> premiumUnits[REF_46]
premiumUnit(PremiumUnit) := REF_47(PremiumUnit)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
unitProductionSeconds = premiumUnit.unitProductionSeconds()

IRs:
TMP_69(uint256) = HIGH_LEVEL_CALL, dest:premiumUnit(PremiumUnit), function:unitProductionSeconds, arguments:[]  
unitProductionSeconds(uint256) := TMP_69(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
unitsProduced = (now - factory.lastClaimTimestamp) / unitProductionSeconds

IRs:
REF_49(uint256) -> factory.lastClaimTimestamp
TMP_70(uint256) = now - REF_49
TMP_71(uint256) = TMP_70 / unitProductionSeconds
unitsProduced(uint256) := TMP_71(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(unitsProduced > 0)

IRs:
TMP_72(bool) = unitsProduced > 0
TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
factory.lastClaimTimestamp += (unitProductionSeconds * unitsProduced)

IRs:
REF_50(uint256) -> factory.lastClaimTimestamp
TMP_74(uint256) = unitProductionSeconds * unitsProduced
REF_50(-> factory) = REF_50 + TMP_74""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
premiumUnit.mintUnit(msg.sender,unitsProduced)

IRs:
HIGH_LEVEL_CALL, dest:premiumUnit(PremiumUnit), function:mintUnit, arguments:['msg.sender', 'unitsProduced']  ""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
equip

IRs:
CONDITION equip""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
premiumUnit.equipUnit(msg.sender,uint80(unitsProduced),100)

IRs:
TMP_76 = CONVERT unitsProduced to uint80
HIGH_LEVEL_CALL, dest:premiumUnit(PremiumUnit), function:equipUnit, arguments:['msg.sender', 'TMP_76', '100']  ""];
10->11;
11[label=""Node Type: END_IF 11
""];
}
",1,0,0,0,"factory = premiumFactories[factoryId];require(bool)(factory.owner == msg.sender);premiumUnit = premiumUnits[factory.unitId];unitProductionSeconds = premiumUnit.unitProductionSeconds();unitsProduced = (now - factory.lastClaimTimestamp) / unitProductionSeconds;require(bool)(unitsProduced > 0);factory.lastClaimTimestamp += (unitProductionSeconds * unitsProduced);premiumUnit.mintUnit(msg.sender,unitsProduced);equip;premiumUnit.equipUnit(msg.sender,uint80(unitsProduced),100);"
./0x0dae7caf45d9c473a8f6ae0d4934e5c3b2dbc371_ext.sol,SafeGuardsToken.transfer,426,438,"TMP_188 = CONVERT 0 to address,TMP_189(bool) = _to != TMP_188,TMP_190(None) = SOLIDITY_CALL require(bool)(TMP_189),REF_182(uint256) -> balances[msg.sender],TMP_191(bool) = _value <= REF_182,TMP_192(None) = SOLIDITY_CALL require(bool)(TMP_191),REF_183(uint256) -> balances[msg.sender],REF_184(uint256) -> balances[msg.sender],TMP_193(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_184', '_value'] ,REF_183(uint256) (->balances) := TMP_193(uint256),REF_186(uint256) -> balances[_to],REF_187(uint256) -> balances[_to],TMP_194(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_187', '_value'] ,REF_186(uint256) (->balances) := TMP_194(uint256),Emit Transfer(msg.sender,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_188 = CONVERT 0 to address
TMP_189(bool) = _to != TMP_188
TMP_190(None) = SOLIDITY_CALL require(bool)(TMP_189)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_182(uint256) -> balances[msg.sender]
TMP_191(bool) = _value <= REF_182
TMP_192(None) = SOLIDITY_CALL require(bool)(TMP_191)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_183(uint256) -> balances[msg.sender]
REF_184(uint256) -> balances[msg.sender]
TMP_193(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_184', '_value'] 
REF_183(uint256) (->balances) := TMP_193(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_186(uint256) -> balances[_to]
REF_187(uint256) -> balances[_to]
TMP_194(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_187', '_value'] 
REF_186(uint256) (->balances) := TMP_194(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,"require(bool)(_to != address(0));require(bool)(_value <= balances[msg.sender]);balances[msg.sender] = balances[msg.sender].sub(_value);balances[_to] = balances[_to].add(_value);Transfer(msg.sender,_to,_value);true"
./0x430e87a95a421437ccaa0af644ac57e22914b07a_ext.sol,PoolOwners.distributeTokens,366,384,"TMP_115 = UnaryType.BANG distributionActive ,TMP_116(None) = SOLIDITY_CALL require(bool,string)(TMP_115,Distribution is already active),distributionActive(bool) := True(bool),TMP_117 = CONVERT _token to ERC677,erc677(ERC677) := TMP_117(ERC677),TMP_118(uint256) = HIGH_LEVEL_CALL, dest:erc677(ERC677), function:balanceOf, arguments:['this']  ,REF_94(uint256) -> tokenBalance[_token],TMP_119(uint256) = TMP_118 - REF_94,currentBalance(uint256) := TMP_119(uint256),TMP_120(bool) = currentBalance > distributionMinimum,TMP_121(None) = SOLIDITY_CALL require(bool,string)(TMP_120,Amount in the contract isn't above the minimum distribution limit),TMP_122(uint256) := totalDistributions(uint256),totalDistributions(uint256) = totalDistributions + 1,REF_95(PoolOwners.Distribution) -> distributions[totalDistributions],d(PoolOwners.Distribution) := REF_95(PoolOwners.Distribution),REF_96(uint256) -> d.owners,TMP_123(uint256) = LIBRARY_CALL, dest:itmap, function:itmap.size(itmap.itmap), arguments:['ownerMap'] ,REF_96(uint256) (->d) := TMP_123(uint256),REF_98(uint256) -> d.amount,REF_98(uint256) (->d) := currentBalance(uint256),REF_99(address) -> d.token,REF_99(address) (->d) := _token(address),REF_100(uint256) -> d.claimed,REF_100(uint256) (->d) := 0(uint256),REF_101(uint256) -> totalReturned[_token],REF_101(-> totalReturned) = REF_101 + currentBalance,REF_102(uint256) -> d.owners,Emit TokenDistributionActive(_token,currentBalance,totalDistributions,REF_102),MODIFIER_CALL, PoolOwners.onlyWhitelisted()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(! distributionActive,Distribution is already active)

IRs:
TMP_115 = UnaryType.BANG distributionActive 
TMP_116(None) = SOLIDITY_CALL require(bool,string)(TMP_115,Distribution is already active)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
distributionActive = true

IRs:
distributionActive(bool) := True(bool)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
erc677 = ERC677(_token)

IRs:
TMP_117 = CONVERT _token to ERC677
erc677(ERC677) := TMP_117(ERC677)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
currentBalance = erc677.balanceOf(this) - tokenBalance[_token]

IRs:
TMP_118(uint256) = HIGH_LEVEL_CALL, dest:erc677(ERC677), function:balanceOf, arguments:['this']  
REF_94(uint256) -> tokenBalance[_token]
TMP_119(uint256) = TMP_118 - REF_94
currentBalance(uint256) := TMP_119(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool,string)(currentBalance > distributionMinimum,Amount in the contract isn't above the minimum distribution limit)

IRs:
TMP_120(bool) = currentBalance > distributionMinimum
TMP_121(None) = SOLIDITY_CALL require(bool,string)(TMP_120,Amount in the contract isn't above the minimum distribution limit)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
totalDistributions ++

IRs:
TMP_122(uint256) := totalDistributions(uint256)
totalDistributions(uint256) = totalDistributions + 1""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
d = distributions[totalDistributions]

IRs:
REF_95(PoolOwners.Distribution) -> distributions[totalDistributions]
d(PoolOwners.Distribution) := REF_95(PoolOwners.Distribution)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
d.owners = ownerMap.size()

IRs:
REF_96(uint256) -> d.owners
TMP_123(uint256) = LIBRARY_CALL, dest:itmap, function:itmap.size(itmap.itmap), arguments:['ownerMap'] 
REF_96(uint256) (->d) := TMP_123(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
d.amount = currentBalance

IRs:
REF_98(uint256) -> d.amount
REF_98(uint256) (->d) := currentBalance(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
d.token = _token

IRs:
REF_99(address) -> d.token
REF_99(address) (->d) := _token(address)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
d.claimed = 0

IRs:
REF_100(uint256) -> d.claimed
REF_100(uint256) (->d) := 0(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
totalReturned[_token] += currentBalance

IRs:
REF_101(uint256) -> totalReturned[_token]
REF_101(-> totalReturned) = REF_101 + currentBalance""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
TokenDistributionActive(_token,currentBalance,totalDistributions,d.owners)

IRs:
REF_102(uint256) -> d.owners
Emit TokenDistributionActive(_token,currentBalance,totalDistributions,REF_102)""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
onlyWhitelisted()

IRs:
MODIFIER_CALL, PoolOwners.onlyWhitelisted()()""];
14->1;
}
",1,0,0,0,"onlyWhitelisted();require(bool,string)(! distributionActive,Distribution is already active);distributionActive = true;erc677 = ERC677(_token);currentBalance = erc677.balanceOf(this) - tokenBalance[_token];require(bool,string)(currentBalance > distributionMinimum,Amount in the contract isn't above the minimum distribution limit);totalDistributions ++;d = distributions[totalDistributions];d.owners = ownerMap.size();d.amount = currentBalance;d.token = _token;d.claimed = 0;totalReturned[_token] += currentBalance;TokenDistributionActive(_token,currentBalance,totalDistributions,d.owners)"
./0x5c28d0683be8143e5ecdd5fd0b39d702d98b1bb9_ext.sol,TemplateCrowdsale.init,1163,1188,"TMP_873 = UnaryType.BANG initialized ,TMP_874(None) = SOLIDITY_CALL require(bool)(TMP_873),initialized(bool) := True(bool),CONDITION PAUSED,TMP_875 = CONVERT token to MainToken,HIGH_LEVEL_CALL, dest:TMP_875(MainToken), function:pause, arguments:[]  ,TMP_877 = CONVERT 502308936605942017559532203074488950703634115101 to address,TMP_878 = CONVERT 523132845609615734231652069930600755357394497159 to address,addresses(address[2]) = ['TMP_877(address)', 'TMP_878(address)'],TMP_879 = CONVERT 9000000000000000000000000000 to uint256,TMP_880 = CONVERT 2000000000000000000000000000 to uint256,amounts(uint256[2]) = ['TMP_879(uint256)', 'TMP_880(uint256)'],TMP_881 = CONVERT 0 to uint64,TMP_882 = CONVERT 0 to uint64,freezes(uint64[2]) = ['TMP_881(uint64)', 'TMP_882(uint64)'],i(uint256) := 0(uint256),REF_421 -> LENGTH addresses,TMP_883(bool) = i < REF_421,CONDITION TMP_883,REF_422(uint64) -> freezes[i],TMP_884(bool) = REF_422 == 0,CONDITION TMP_884,TMP_885 = CONVERT token to MainToken,REF_424(address) -> addresses[i],REF_425(uint256) -> amounts[i],TMP_886(bool) = HIGH_LEVEL_CALL, dest:TMP_885(MainToken), function:mint, arguments:['REF_424', 'REF_425']  ,TMP_887 = CONVERT token to MainToken,REF_427(address) -> addresses[i],REF_428(uint256) -> amounts[i],REF_429(uint64) -> freezes[i],TMP_888(bool) = HIGH_LEVEL_CALL, dest:TMP_887(MainToken), function:mintAndFreeze, arguments:['REF_427', 'REF_428', 'REF_429']  ,TMP_889(uint256) := i(uint256),i(uint256) = i + 1,INTERNAL_CALL, Ownable.transferOwnership(address)(TARGET_USER),Emit Initialized(),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->20;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! initialized)

IRs:
TMP_873 = UnaryType.BANG initialized 
TMP_874(None) = SOLIDITY_CALL require(bool)(TMP_873)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
initialized = true

IRs:
initialized(bool) := True(bool)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
PAUSED

IRs:
CONDITION PAUSED""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
MainToken(token).pause()

IRs:
TMP_875 = CONVERT token to MainToken
HIGH_LEVEL_CALL, dest:TMP_875(MainToken), function:pause, arguments:[]  ""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
addresses = (address(0x57fc4fcd5e9d5954da2a8943743ca0e46291ea1d),address(0x5ba2168ddbf65df7c904b822fa1db73088d16e87))

IRs:
TMP_877 = CONVERT 502308936605942017559532203074488950703634115101 to address
TMP_878 = CONVERT 523132845609615734231652069930600755357394497159 to address
addresses(address[2]) = ['TMP_877(address)', 'TMP_878(address)']""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
amounts = (uint256(9000000000000000000000000000),uint256(2000000000000000000000000000))

IRs:
TMP_879 = CONVERT 9000000000000000000000000000 to uint256
TMP_880 = CONVERT 2000000000000000000000000000 to uint256
amounts(uint256[2]) = ['TMP_879(uint256)', 'TMP_880(uint256)']""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
freezes = (uint64(0),uint64(0))

IRs:
TMP_881 = CONVERT 0 to uint64
TMP_882 = CONVERT 0 to uint64
freezes(uint64[2]) = ['TMP_881(uint64)', 'TMP_882(uint64)']""];
8->11;
9[label=""Node Type: BEGIN_LOOP 9
""];
9->12;
10[label=""Node Type: END_LOOP 10
""];
10->18;
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
11->9;
12[label=""Node Type: IF_LOOP 12

EXPRESSION:
i < addresses.length

IRs:
REF_421 -> LENGTH addresses
TMP_883(bool) = i < REF_421
CONDITION TMP_883""];
12->13[label=""True""];
12->10[label=""False""];
13[label=""Node Type: IF 13

EXPRESSION:
freezes[i] == 0

IRs:
REF_422(uint64) -> freezes[i]
TMP_884(bool) = REF_422 == 0
CONDITION TMP_884""];
13->14[label=""True""];
13->15[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
MainToken(token).mint(addresses[i],amounts[i])

IRs:
TMP_885 = CONVERT token to MainToken
REF_424(address) -> addresses[i]
REF_425(uint256) -> amounts[i]
TMP_886(bool) = HIGH_LEVEL_CALL, dest:TMP_885(MainToken), function:mint, arguments:['REF_424', 'REF_425']  ""];
14->16;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
MainToken(token).mintAndFreeze(addresses[i],amounts[i],freezes[i])

IRs:
TMP_887 = CONVERT token to MainToken
REF_427(address) -> addresses[i]
REF_428(uint256) -> amounts[i]
REF_429(uint64) -> freezes[i]
TMP_888(bool) = HIGH_LEVEL_CALL, dest:TMP_887(MainToken), function:mintAndFreeze, arguments:['REF_427', 'REF_428', 'REF_429']  ""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
i ++

IRs:
TMP_889(uint256) := i(uint256)
i(uint256) = i + 1""];
17->12;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
transferOwnership(TARGET_USER)

IRs:
INTERNAL_CALL, Ownable.transferOwnership(address)(TARGET_USER)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
Initialized()

IRs:
Emit Initialized()""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
20->1;
}
",1,0,0,0,"onlyOwner();require(bool)(! initialized);initialized = true;PAUSED;MainToken(token).pause();;addresses = (address(0x57fc4fcd5e9d5954da2a8943743ca0e46291ea1d),address(0x5ba2168ddbf65df7c904b822fa1db73088d16e87));amounts = (uint256(9000000000000000000000000000),uint256(2000000000000000000000000000));freezes = (uint64(0),uint64(0));i = 0;;i < addresses.length;;transferOwnership(TARGET_USER);freezes[i] == 0;MainToken(token).mint(addresses[i],amounts[i]);MainToken(token).mintAndFreeze(addresses[i],amounts[i],freezes[i]);;i ++;Initialized()"
./0x1d899280f446aab65971e41611b5bb5516dd47f9_ext.sol,CryptoMiningWar.setEngineerInterface,290,297,"TMP_88 = CONVERT _addr to CryptoEngineerInterface,engineerInterface(CryptoEngineerInterface) := TMP_88(CryptoEngineerInterface),TMP_89(bool) = HIGH_LEVEL_CALL, dest:engineerInterface(CryptoEngineerInterface), function:isEngineerContract, arguments:[]  ,TMP_90(bool) = TMP_89 == True,TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),Engineer(CryptoEngineerInterface) := engineerInterface(CryptoEngineerInterface),MODIFIER_CALL, CryptoMiningWar.isAdministrator()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
engineerInterface = CryptoEngineerInterface(_addr)

IRs:
TMP_88 = CONVERT _addr to CryptoEngineerInterface
engineerInterface(CryptoEngineerInterface) := TMP_88(CryptoEngineerInterface)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(engineerInterface.isEngineerContract() == true)

IRs:
TMP_89(bool) = HIGH_LEVEL_CALL, dest:engineerInterface(CryptoEngineerInterface), function:isEngineerContract, arguments:[]  
TMP_90(bool) = TMP_89 == True
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Engineer = engineerInterface

IRs:
Engineer(CryptoEngineerInterface) := engineerInterface(CryptoEngineerInterface)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
isAdministrator()

IRs:
MODIFIER_CALL, CryptoMiningWar.isAdministrator()()""];
4->1;
}
",1,0,0,0,isAdministrator();engineerInterface = CryptoEngineerInterface(_addr);require(bool)(engineerInterface.isEngineerContract() == true);Engineer = engineerInterface
./0xeb6486b13b56314b37aacac2ec6889d11a763de1_ext.sol,BasicCGRID.transfer,41,41,"TMP_17(bool) = _to != 0,TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17),REF_2(uint256) -> balances[msg.sender],REF_3(uint256) -> balances[msg.sender],TMP_19(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_3', '_value'] ,REF_2(uint256) (->balances) := TMP_19(uint256),REF_5(uint256) -> balances[_to],REF_6(uint256) -> balances[_to],TMP_20(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_6', '_value'] ,REF_5(uint256) (->balances) := TMP_20(uint256),Emit Transfer(msg.sender,_to,_value),RETURN True,MODIFIER_CALL, BasicCGRID.isTradable()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_17(bool) = _to != 0
TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_2(uint256) -> balances[msg.sender]
REF_3(uint256) -> balances[msg.sender]
TMP_19(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_3', '_value'] 
REF_2(uint256) (->balances) := TMP_19(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_5(uint256) -> balances[_to]
REF_6(uint256) -> balances[_to]
TMP_20(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_6', '_value'] 
REF_5(uint256) (->balances) := TMP_20(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
isTradable()

IRs:
MODIFIER_CALL, BasicCGRID.isTradable()()""];
6->1;
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,0,0,0,"isTradable();require(bool)(_to != 0x0);balances[msg.sender] = balances[msg.sender].sub(_value);balances[_to] = balances[_to].add(_value);Transfer(msg.sender,_to,_value);true;success"
./0x0da76de0916ef2da3c58a97e4d09d501c56a9f15_ext.sol,Piggy_Bank.Collect,15,28,"REF_5(Piggy_Bank.Holder) -> Acc[msg.sender],acc(Piggy_Bank.Holder) := REF_5(Piggy_Bank.Holder),REF_6(uint256) -> acc.balance,TMP_2(bool) = REF_6 >= MinSum,REF_7(uint256) -> acc.balance,TMP_3(bool) = REF_7 >= _am,TMP_4(bool) = TMP_2 && TMP_3,REF_8(uint256) -> acc.unlockTime,TMP_5(bool) = now > REF_8,TMP_6(bool) = TMP_4 && TMP_5,CONDITION TMP_6,TMP_8(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:_am ,CONDITION TMP_8,REF_11(uint256) -> acc.balance,REF_11(-> acc) = REF_11 - _am,HIGH_LEVEL_CALL, dest:LogFile(Log), function:AddMessage, arguments:['msg.sender', '_am', 'Collect']  ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
acc = Acc[msg.sender]

IRs:
REF_5(Piggy_Bank.Holder) -> Acc[msg.sender]
acc(Piggy_Bank.Holder) := REF_5(Piggy_Bank.Holder)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
acc.balance >= MinSum && acc.balance >= _am && now > acc.unlockTime

IRs:
REF_6(uint256) -> acc.balance
TMP_2(bool) = REF_6 >= MinSum
REF_7(uint256) -> acc.balance
TMP_3(bool) = REF_7 >= _am
TMP_4(bool) = TMP_2 && TMP_3
REF_8(uint256) -> acc.unlockTime
TMP_5(bool) = now > REF_8
TMP_6(bool) = TMP_4 && TMP_5
CONDITION TMP_6""];
2->3[label=""True""];
2->7[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
msg.sender.call.value(_am)()

IRs:
TMP_8(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:_am 
CONDITION TMP_8""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
acc.balance -= _am

IRs:
REF_11(uint256) -> acc.balance
REF_11(-> acc) = REF_11 - _am""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
LogFile.AddMessage(msg.sender,_am,Collect)

IRs:
HIGH_LEVEL_CALL, dest:LogFile(Log), function:AddMessage, arguments:['msg.sender', '_am', 'Collect']  ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: END_IF 7
""];
}
",1,0,0,0,"acc = Acc[msg.sender];acc.balance >= MinSum && acc.balance >= _am && now > acc.unlockTime;msg.sender.call.value(_am)();;acc.balance -= _am;;LogFile.AddMessage(msg.sender,_am,Collect)"
./0x5b3c6ac07f3729534b7483d31e48f15e6ce7c6e9_ext.sol,Crowdsale.finalize,211,218,"TMP_72 = UnaryType.BANG isFinalized ,TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72),INTERNAL_CALL, Crowdsale.finalization()(),Emit Finalized(),isFinalized(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isFinalized)

IRs:
TMP_72 = UnaryType.BANG isFinalized 
TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
finalization()

IRs:
INTERNAL_CALL, Crowdsale.finalization()()""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Finalized()

IRs:
Emit Finalized()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
isFinalized = true

IRs:
isFinalized(bool) := True(bool)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",1,0,0,0,onlyOwner();require(bool)(! isFinalized);finalization();Finalized();isFinalized = true
./0x74ceda99c44da280f2fd8ea8b5dd43f8b66912a8_ext.sol,BasicToken.transfer,810,814,"TMP_19 = CONVERT 0 to address,TMP_20(bool) = _to != TMP_19,TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20),REF_0(uint256) -> balances[msg.sender],TMP_22(bool) = _value <= REF_0,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_1(uint256) -> balances[msg.sender],REF_2(uint256) -> balances[msg.sender],TMP_24(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] ,REF_1(uint256) (->balances) := TMP_24(uint256),REF_4(uint256) -> balances[_to],REF_5(uint256) -> balances[_to],TMP_25(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] ,REF_4(uint256) (->balances) := TMP_25(uint256),Emit Transfer(msg.sender,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_19 = CONVERT 0 to address
TMP_20(bool) = _to != TMP_19
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_22(bool) = _value <= REF_0
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_2(uint256) -> balances[msg.sender]
TMP_24(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] 
REF_1(uint256) (->balances) := TMP_24(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_4(uint256) -> balances[_to]
REF_5(uint256) -> balances[_to]
TMP_25(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] 
REF_4(uint256) (->balances) := TMP_25(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,"require(bool)(_to != address(0));require(bool)(_value <= balances[msg.sender]);balances[msg.sender] = balances[msg.sender].sub(_value);balances[_to] = balances[_to].add(_value);Transfer(msg.sender,_to,_value);true"
./0x7982a79ee90eb3682dcee66e47ba79c1cba44062_ext.sol,SaleClockAuction.bidGift,657,669,"REF_165(ClockAuctionBase.Auction) -> tokenIdToAuction[_tokenId],REF_166(address) -> REF_165.seller,seller(address) := REF_166(address),TMP_783(uint256) = INTERNAL_CALL, ClockAuctionBase._bid(uint256,uint256,address)(_tokenId,msg.value,msg.sender),price(uint256) := TMP_783(uint256),INTERNAL_CALL, ClockAuctionBase._transfer(address,uint256)(_to,_tokenId),TMP_785 = CONVERT gen0SellerAddress to address,TMP_786(bool) = seller == TMP_785,CONDITION TMP_786,TMP_787(uint256) = gen0SaleCount % 5,REF_167(uint256) -> lastGen0SalePrices[TMP_787],REF_167(uint256) (->lastGen0SalePrices) := price(uint256),TMP_788(uint256) := gen0SaleCount(uint256),gen0SaleCount(uint256) = gen0SaleCount + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
seller = tokenIdToAuction[_tokenId].seller

IRs:
REF_165(ClockAuctionBase.Auction) -> tokenIdToAuction[_tokenId]
REF_166(address) -> REF_165.seller
seller(address) := REF_166(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
price = _bid(_tokenId,msg.value,msg.sender)

IRs:
TMP_783(uint256) = INTERNAL_CALL, ClockAuctionBase._bid(uint256,uint256,address)(_tokenId,msg.value,msg.sender)
price(uint256) := TMP_783(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_transfer(_to,_tokenId)

IRs:
INTERNAL_CALL, ClockAuctionBase._transfer(address,uint256)(_to,_tokenId)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
seller == address(gen0SellerAddress)

IRs:
TMP_785 = CONVERT gen0SellerAddress to address
TMP_786(bool) = seller == TMP_785
CONDITION TMP_786""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
lastGen0SalePrices[gen0SaleCount % 5] = price

IRs:
TMP_787(uint256) = gen0SaleCount % 5
REF_167(uint256) -> lastGen0SalePrices[TMP_787]
REF_167(uint256) (->lastGen0SalePrices) := price(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
gen0SaleCount ++

IRs:
TMP_788(uint256) := gen0SaleCount(uint256)
gen0SaleCount(uint256) = gen0SaleCount + 1""];
6->7;
7[label=""Node Type: END_IF 7
""];
}
",1,0,0,0,"seller = tokenIdToAuction[_tokenId].seller;price = _bid(_tokenId,msg.value,msg.sender);_transfer(_to,_tokenId);seller == address(gen0SellerAddress);lastGen0SalePrices[gen0SaleCount % 5] = price;;gen0SaleCount ++"
./0x58bd394f3dfd9bbc15f4bc662b2def3e597e4e90_ext.sol,AceTokenDistribution.extraMint,340,343,"TMP_99(bool) = HIGH_LEVEL_CALL, dest:token(StarTokenInterface), function:extraMint, arguments:[]  ,TMP_100(None) = SOLIDITY_CALL assert(bool)(TMP_99),Emit ExtraMint(),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(token.extraMint())

IRs:
TMP_99(bool) = HIGH_LEVEL_CALL, dest:token(StarTokenInterface), function:extraMint, arguments:[]  
TMP_100(None) = SOLIDITY_CALL assert(bool)(TMP_99)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ExtraMint()

IRs:
Emit ExtraMint()""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
3->1;
}
",1,0,0,0,onlyOwner();assert(bool)(token.extraMint());ExtraMint()
./0xd95f7070c4d4abb344f79bb48ee22e751901d8df_ext.sol,SingularDTVLaunch.start,305,320,"TMP_72(bool) = HIGH_LEVEL_CALL, dest:singularDTVToken(AbstractSingularDTVToken), function:transferFrom, arguments:['msg.sender', 'this', 'CAP']  ,TMP_73 = UnaryType.BANG TMP_72 ,CONDITION TMP_73,TMP_74(None) = SOLIDITY_CALL revert()(),startDate(uint256) := now(uint256),REF_30(SingularDTVLaunch.Stages) -> Stages.GoingAndGoalNotReached,stage(SingularDTVLaunch.Stages) := REF_30(SingularDTVLaunch.Stages),INTERNAL_CALL, SingularDTVLaunch.checkInvariants()(),RETURN startDate,MODIFIER_CALL, SingularDTVLaunch.onlyOwner()(),REF_31(SingularDTVLaunch.Stages) -> Stages.Deployed,MODIFIER_CALL, SingularDTVLaunch.atStage(SingularDTVLaunch.Stages)(REF_31)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: IF 1

EXPRESSION:
! singularDTVToken.transferFrom(msg.sender,this,CAP)

IRs:
TMP_72(bool) = HIGH_LEVEL_CALL, dest:singularDTVToken(AbstractSingularDTVToken), function:transferFrom, arguments:['msg.sender', 'this', 'CAP']  
TMP_73 = UnaryType.BANG TMP_72 
CONDITION TMP_73""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_74(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
startDate = now

IRs:
startDate(uint256) := now(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
stage = Stages.GoingAndGoalNotReached

IRs:
REF_30(SingularDTVLaunch.Stages) -> Stages.GoingAndGoalNotReached
stage(SingularDTVLaunch.Stages) := REF_30(SingularDTVLaunch.Stages)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
checkInvariants()

IRs:
INTERNAL_CALL, SingularDTVLaunch.checkInvariants()()""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
startDate

IRs:
RETURN startDate""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, SingularDTVLaunch.onlyOwner()()""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
atStage(Stages.Deployed)

IRs:
REF_31(SingularDTVLaunch.Stages) -> Stages.Deployed
MODIFIER_CALL, SingularDTVLaunch.atStage(SingularDTVLaunch.Stages)(REF_31)""];
9->1;
}
",1,0,0,0,"onlyOwner();! singularDTVToken.transferFrom(msg.sender,this,CAP);revert()();;startDate = now;stage = Stages.GoingAndGoalNotReached;checkInvariants();startDate;atStage(Stages.Deployed)"
./0x4cd988afbad37289baaf53c13e98e2bd46aaea8c_ext.sol,DSToken.setName,439,441,"name(bytes32) := name_(bytes32),MODIFIER_CALL, DSAuth.auth()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
name = name_

IRs:
name(bytes32) := name_(bytes32)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
2->1;
}
",1,0,0,0,auth();name = name_
./0x475a8101fdde7f7246e31be77dd7dcb80f25d735_ext.sol,Exchange.withdrawToken,243,251,"TMP_107(bool) = tokenAddr != 0,TMP_108(None) = SOLIDITY_CALL require(bool)(TMP_107),TMP_109(bool) = amount > 0,TMP_110(None) = SOLIDITY_CALL require(bool)(TMP_109),INTERNAL_CALL, Exchange.balanceSub(address,address,uint256)(tokenAddr,msg.sender,amount),TMP_112 = CONVERT tokenAddr to Token,TMP_113(bool) = HIGH_LEVEL_CALL, dest:TMP_112(Token), function:transfer, arguments:['msg.sender', 'amount']  ,Emit Withdraw(tokenAddr,msg.sender,amount),REF_108(mapping(address => uint256)) -> balanceOf[tokenAddr],REF_109(uint256) -> REF_108[msg.sender],Emit BalanceChanged(tokenAddr,msg.sender,REF_109)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(tokenAddr != 0x0)

IRs:
TMP_107(bool) = tokenAddr != 0
TMP_108(None) = SOLIDITY_CALL require(bool)(TMP_107)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_109(bool) = amount > 0
TMP_110(None) = SOLIDITY_CALL require(bool)(TMP_109)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceSub(tokenAddr,msg.sender,amount)

IRs:
INTERNAL_CALL, Exchange.balanceSub(address,address,uint256)(tokenAddr,msg.sender,amount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Token(tokenAddr).transfer(msg.sender,amount)

IRs:
TMP_112 = CONVERT tokenAddr to Token
TMP_113(bool) = HIGH_LEVEL_CALL, dest:TMP_112(Token), function:transfer, arguments:['msg.sender', 'amount']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Withdraw(tokenAddr,msg.sender,amount)

IRs:
Emit Withdraw(tokenAddr,msg.sender,amount)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
BalanceChanged(tokenAddr,msg.sender,balanceOf[tokenAddr][msg.sender])

IRs:
REF_108(mapping(address => uint256)) -> balanceOf[tokenAddr]
REF_109(uint256) -> REF_108[msg.sender]
Emit BalanceChanged(tokenAddr,msg.sender,REF_109)""];
}
",1,0,0,0,"require(bool)(tokenAddr != 0x0);require(bool)(amount > 0);balanceSub(tokenAddr,msg.sender,amount);Token(tokenAddr).transfer(msg.sender,amount);Withdraw(tokenAddr,msg.sender,amount);BalanceChanged(tokenAddr,msg.sender,balanceOf[tokenAddr][msg.sender])"
./0x00f634a0bb03416816f8829928ef7d776f798414_ext.sol,KiOS.pay,40,46,"TMP_21(bool) = INTERNAL_CALL, KiOS.check(address)(recipient),TMP_22(bool) = amount > 0,TMP_23(bool) = TMP_21 && TMP_22,TMP_24(uint256) = INTERNAL_CALL, KiOS.getBalance(address)(token),TMP_25(bool) = amount <= TMP_24,TMP_26(bool) = TMP_23 && TMP_25,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),TMP_28 = CONVERT 0 to address,TMP_29(bool) = TMP_28 == token,CONDITION TMP_29,Transfer dest:recipient value:amount,TMP_31 = CONVERT token to ERC20,TMP_32(bool) = HIGH_LEVEL_CALL, dest:TMP_31(ERC20), function:transfer, arguments:['recipient', 'amount']  ,TMP_33 = UnaryType.BANG TMP_32 ,CONDITION TMP_33,TMP_34(None) = SOLIDITY_CALL revert()(),Emit Sent(recipient,token,amount),RETURN True,MODIFIER_CALL, KiOS.restrict()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(check(recipient) && amount > 0 && amount <= getBalance(token))

IRs:
TMP_21(bool) = INTERNAL_CALL, KiOS.check(address)(recipient)
TMP_22(bool) = amount > 0
TMP_23(bool) = TMP_21 && TMP_22
TMP_24(uint256) = INTERNAL_CALL, KiOS.getBalance(address)(token)
TMP_25(bool) = amount <= TMP_24
TMP_26(bool) = TMP_23 && TMP_25
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
address(0) == token

IRs:
TMP_28 = CONVERT 0 to address
TMP_29(bool) = TMP_28 == token
CONDITION TMP_29""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
recipient.transfer(amount)

IRs:
Transfer dest:recipient value:amount""];
3->7;
4[label=""Node Type: IF 4

EXPRESSION:
! ERC20(token).transfer(recipient,amount)

IRs:
TMP_31 = CONVERT token to ERC20
TMP_32(bool) = HIGH_LEVEL_CALL, dest:TMP_31(ERC20), function:transfer, arguments:['recipient', 'amount']  
TMP_33 = UnaryType.BANG TMP_32 
CONDITION TMP_33""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
revert()()

IRs:
TMP_34(None) = SOLIDITY_CALL revert()()""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Sent(recipient,token,amount)

IRs:
Emit Sent(recipient,token,amount)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
restrict()

IRs:
MODIFIER_CALL, KiOS.restrict()()""];
10->1;
}
",1,0,0,0,"restrict();require(bool)(check(recipient) && amount > 0 && amount <= getBalance(token));address(0) == token;recipient.transfer(amount);! ERC20(token).transfer(recipient,amount);;revert()();;Sent(recipient,token,amount);true"
./0x1f52b87c3503e537853e160adbf7e330ea0be7c4_ext.sol,SaleClockAuction.createAuction,529,552,"TMP_182(bool) = INTERNAL_CALL, ClockAuctionBase._owns(address,address,uint256)(_nftAddress,msg.sender,_tokenId),TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182),INTERNAL_CALL, ClockAuctionBase._escrow(address,address,uint256)(_nftAddress,msg.sender,_tokenId),TMP_185 = CONVERT _startingPrice to uint128,TMP_186 = CONVERT _endingPrice to uint128,TMP_187 = CONVERT _duration to uint64,TMP_188 = CONVERT now to uint64,TMP_189(ClockAuctionBase.Auction) = new Auction(_nftAddress,_seller,TMP_185,TMP_186,TMP_187,TMP_188),auction(ClockAuctionBase.Auction) := TMP_189(ClockAuctionBase.Auction),INTERNAL_CALL, ClockAuctionBase._addAuction(address,uint256,ClockAuctionBase.Auction)(_nftAddress,_tokenId,auction),MODIFIER_CALL, Pausable.whenNotPaused()(),MODIFIER_CALL, ClockAuctionBase.canBeStoredWith128Bits(uint256)(_startingPrice),MODIFIER_CALL, ClockAuctionBase.canBeStoredWith128Bits(uint256)(_endingPrice),MODIFIER_CALL, ClockAuctionBase.canBeStoredWith64Bits(uint256)(_duration)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_owns(_nftAddress,msg.sender,_tokenId))

IRs:
TMP_182(bool) = INTERNAL_CALL, ClockAuctionBase._owns(address,address,uint256)(_nftAddress,msg.sender,_tokenId)
TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_escrow(_nftAddress,msg.sender,_tokenId)

IRs:
INTERNAL_CALL, ClockAuctionBase._escrow(address,address,uint256)(_nftAddress,msg.sender,_tokenId)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
auction = Auction(_nftAddress,_seller,uint128(_startingPrice),uint128(_endingPrice),uint64(_duration),uint64(now))

IRs:
TMP_185 = CONVERT _startingPrice to uint128
TMP_186 = CONVERT _endingPrice to uint128
TMP_187 = CONVERT _duration to uint64
TMP_188 = CONVERT now to uint64
TMP_189(ClockAuctionBase.Auction) = new Auction(_nftAddress,_seller,TMP_185,TMP_186,TMP_187,TMP_188)
auction(ClockAuctionBase.Auction) := TMP_189(ClockAuctionBase.Auction)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
_addAuction(_nftAddress,_tokenId,auction)

IRs:
INTERNAL_CALL, ClockAuctionBase._addAuction(address,uint256,ClockAuctionBase.Auction)(_nftAddress,_tokenId,auction)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
canBeStoredWith128Bits(_startingPrice)

IRs:
MODIFIER_CALL, ClockAuctionBase.canBeStoredWith128Bits(uint256)(_startingPrice)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
canBeStoredWith128Bits(_endingPrice)

IRs:
MODIFIER_CALL, ClockAuctionBase.canBeStoredWith128Bits(uint256)(_endingPrice)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
canBeStoredWith64Bits(_duration)

IRs:
MODIFIER_CALL, ClockAuctionBase.canBeStoredWith64Bits(uint256)(_duration)""];
8->1;
}
",1,0,0,0,"whenNotPaused();require(bool)(_owns(_nftAddress,msg.sender,_tokenId));_escrow(_nftAddress,msg.sender,_tokenId);auction = Auction(_nftAddress,_seller,uint128(_startingPrice),uint128(_endingPrice),uint64(_duration),uint64(now));_addAuction(_nftAddress,_tokenId,auction);canBeStoredWith128Bits(_startingPrice);canBeStoredWith128Bits(_endingPrice);canBeStoredWith64Bits(_duration)"
./0x25d3b337e17ad34dbc8cb97d1a724545d90478fa_ext.sol,AirdropiRide.dropToken,55,61,"TMP_11(bool) = now > startDate,TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11),i(uint256) := 0(uint256),REF_0 -> LENGTH _to,TMP_13(bool) = i < REF_0,CONDITION TMP_13,REF_2(address) -> _to[i],HIGH_LEVEL_CALL, dest:tokenReward(Token), function:transferFrom, arguments:['owner', 'REF_2', 'amount']  ,Emit FundTransfer(msg.sender,amount,True),TMP_16(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, AirdropiRide.isCreator()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now > startDate)

IRs:
TMP_11(bool) = now > startDate
TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < _to.length

IRs:
REF_0 -> LENGTH _to
TMP_13(bool) = i < REF_0
CONDITION TMP_13""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tokenReward.transferFrom(owner,_to[i],amount)

IRs:
REF_2(address) -> _to[i]
HIGH_LEVEL_CALL, dest:tokenReward(Token), function:transferFrom, arguments:['owner', 'REF_2', 'amount']  ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
FundTransfer(msg.sender,amount,true)

IRs:
Emit FundTransfer(msg.sender,amount,True)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_16(uint256) := i(uint256)
i(uint256) = i + 1""];
8->5;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
isCreator()

IRs:
MODIFIER_CALL, AirdropiRide.isCreator()()""];
9->1;
}
",1,0,0,0,"isCreator();require(bool)(now > startDate);i = 0;;i < _to.length;;tokenReward.transferFrom(owner,_to[i],amount);FundTransfer(msg.sender,amount,true);i ++"
./0x5165db3dffd92454c2d59faa8e2d907e54f174d3_ext.sol,ViewlyBountyRewards.sendTokenReward,338,347,"TMP_273(bool) = tokens > 0,TMP_274(None) = SOLIDITY_CALL require(bool)(TMP_273),TMP_275(uint256) = INTERNAL_CALL, DSMath.add(uint256,uint256)(tokens,totalTokenRewards),TMP_276(bool) = TMP_275 <= MAX_TOKEN_REWARDS,TMP_277(None) = SOLIDITY_CALL require(bool)(TMP_276),REF_56(uint256) -> tokenRewards[recipient],REF_56(-> tokenRewards) = REF_56 + tokens,TMP_278(uint256) = INTERNAL_CALL, DSMath.add(uint256,uint256)(tokens,totalTokenRewards),totalTokenRewards(uint256) := TMP_278(uint256),HIGH_LEVEL_CALL, dest:viewToken(DSToken), function:mint, arguments:['recipient', 'tokens']  ,Emit LogTokenReward(recipient,tokens),MODIFIER_CALL, DSAuth.auth()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(tokens > 0)

IRs:
TMP_273(bool) = tokens > 0
TMP_274(None) = SOLIDITY_CALL require(bool)(TMP_273)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(add(tokens,totalTokenRewards) <= MAX_TOKEN_REWARDS)

IRs:
TMP_275(uint256) = INTERNAL_CALL, DSMath.add(uint256,uint256)(tokens,totalTokenRewards)
TMP_276(bool) = TMP_275 <= MAX_TOKEN_REWARDS
TMP_277(None) = SOLIDITY_CALL require(bool)(TMP_276)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tokenRewards[recipient] += tokens

IRs:
REF_56(uint256) -> tokenRewards[recipient]
REF_56(-> tokenRewards) = REF_56 + tokens""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
totalTokenRewards = add(tokens,totalTokenRewards)

IRs:
TMP_278(uint256) = INTERNAL_CALL, DSMath.add(uint256,uint256)(tokens,totalTokenRewards)
totalTokenRewards(uint256) := TMP_278(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
viewToken.mint(recipient,tokens)

IRs:
HIGH_LEVEL_CALL, dest:viewToken(DSToken), function:mint, arguments:['recipient', 'tokens']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
LogTokenReward(recipient,tokens)

IRs:
Emit LogTokenReward(recipient,tokens)""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
7->1;
}
",1,0,0,0,"auth();require(bool)(tokens > 0);require(bool)(add(tokens,totalTokenRewards) <= MAX_TOKEN_REWARDS);tokenRewards[recipient] += tokens;totalTokenRewards = add(tokens,totalTokenRewards);viewToken.mint(recipient,tokens);LogTokenReward(recipient,tokens)"
./0xaa652d53909b01c5a6b8e7cd814f9adea18c08f7_ext.sol,TCRSale.ownerAllocateTokens,661,672,"TMP_230(address) = HIGH_LEVEL_CALL, dest:tokenReward(TCRToken), function:owner, arguments:[]  ,TMP_231(bool) = HIGH_LEVEL_CALL, dest:tokenReward(TCRToken), function:transferFrom, arguments:['TMP_230', '_to', 'amountMiniTcr']  ,TMP_232 = UnaryType.BANG TMP_231 ,CONDITION TMP_232,TMP_233(None) = SOLIDITY_CALL revert()(),REF_125(uint256) -> balanceOf[_to],REF_126(uint256) -> balanceOf[_to],TMP_234(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_126', 'amountWei'] ,REF_125(uint256) (->balanceOf) := TMP_234(uint256),TMP_235(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['amountRaised', 'amountWei'] ,amountRaised(uint256) := TMP_235(uint256),Emit FundTransfer(_to,amountWei,True),INTERNAL_CALL, TCRSale.checkFundingGoal()(),INTERNAL_CALL, TCRSale.checkFundingCap()(),MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, TCRSale.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
! tokenReward.transferFrom(tokenReward.owner(),_to,amountMiniTcr)

IRs:
TMP_230(address) = HIGH_LEVEL_CALL, dest:tokenReward(TCRToken), function:owner, arguments:[]  
TMP_231(bool) = HIGH_LEVEL_CALL, dest:tokenReward(TCRToken), function:transferFrom, arguments:['TMP_230', '_to', 'amountMiniTcr']  
TMP_232 = UnaryType.BANG TMP_231 
CONDITION TMP_232""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_233(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[_to] = balanceOf[_to].add(amountWei)

IRs:
REF_125(uint256) -> balanceOf[_to]
REF_126(uint256) -> balanceOf[_to]
TMP_234(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_126', 'amountWei'] 
REF_125(uint256) (->balanceOf) := TMP_234(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
amountRaised = amountRaised.add(amountWei)

IRs:
TMP_235(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['amountRaised', 'amountWei'] 
amountRaised(uint256) := TMP_235(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
FundTransfer(_to,amountWei,true)

IRs:
Emit FundTransfer(_to,amountWei,True)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
checkFundingGoal()

IRs:
INTERNAL_CALL, TCRSale.checkFundingGoal()()""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
checkFundingCap()

IRs:
INTERNAL_CALL, TCRSale.checkFundingCap()()""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, TCRSale.nonReentrant()()""];
10->1;
}
",1,0,0,0,"onlyOwner();! tokenReward.transferFrom(tokenReward.owner(),_to,amountMiniTcr);revert()();;balanceOf[_to] = balanceOf[_to].add(amountWei);amountRaised = amountRaised.add(amountWei);FundTransfer(_to,amountWei,true);checkFundingGoal();checkFundingCap();nonReentrant()"
./0x3a266f97425cd281c1770b71662fcf4415c29190_ext.sol,CryptoProgramFactory.setEngineerInterface,174,181,"TMP_35 = CONVERT _addr to CryptoEngineerInterface,engineerInterface(CryptoEngineerInterface) := TMP_35(CryptoEngineerInterface),TMP_36(bool) = HIGH_LEVEL_CALL, dest:engineerInterface(CryptoEngineerInterface), function:isContractMiniGame, arguments:[]  ,TMP_37(bool) = TMP_36 == True,TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37),Engineer(CryptoEngineerInterface) := engineerInterface(CryptoEngineerInterface),MODIFIER_CALL, CryptoProgramFactory.isAdministrator()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
engineerInterface = CryptoEngineerInterface(_addr)

IRs:
TMP_35 = CONVERT _addr to CryptoEngineerInterface
engineerInterface(CryptoEngineerInterface) := TMP_35(CryptoEngineerInterface)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(engineerInterface.isContractMiniGame() == true)

IRs:
TMP_36(bool) = HIGH_LEVEL_CALL, dest:engineerInterface(CryptoEngineerInterface), function:isContractMiniGame, arguments:[]  
TMP_37(bool) = TMP_36 == True
TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Engineer = engineerInterface

IRs:
Engineer(CryptoEngineerInterface) := engineerInterface(CryptoEngineerInterface)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
isAdministrator()

IRs:
MODIFIER_CALL, CryptoProgramFactory.isAdministrator()()""];
4->1;
}
",1,0,0,0,isAdministrator();engineerInterface = CryptoEngineerInterface(_addr);require(bool)(engineerInterface.isContractMiniGame() == true);Engineer = engineerInterface
./0x74a12ce6eebc23c3f785c0ab50d02228587dcc1a_ext.sol,FrozenToken.receiveApproval,281,281,"TMP_386 = CONVERT _token to IERC20,token(IERC20) := TMP_386(IERC20),TMP_387 = CONVERT this to address,TMP_388(bool) = HIGH_LEVEL_CALL, dest:token(IERC20), function:transferFrom, arguments:['_spender', 'TMP_387', '_value']  ,TMP_389(None) = SOLIDITY_CALL require(bool)(TMP_388),Emit ReceiveTokens(_spender,_token,_value,_extraData),MODIFIER_CALL, Utils.validAddress(address)(_spender),MODIFIER_CALL, Utils.validAddress(address)(_token),MODIFIER_CALL, Utils.greaterThanZero(uint256)(_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
token = IERC20(_token)

IRs:
TMP_386 = CONVERT _token to IERC20
token(IERC20) := TMP_386(IERC20)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(token.transferFrom(_spender,address(this),_value))

IRs:
TMP_387 = CONVERT this to address
TMP_388(bool) = HIGH_LEVEL_CALL, dest:token(IERC20), function:transferFrom, arguments:['_spender', 'TMP_387', '_value']  
TMP_389(None) = SOLIDITY_CALL require(bool)(TMP_388)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ReceiveTokens(_spender,_token,_value,_extraData)

IRs:
Emit ReceiveTokens(_spender,_token,_value,_extraData)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
validAddress(_spender)

IRs:
MODIFIER_CALL, Utils.validAddress(address)(_spender)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
validAddress(_token)

IRs:
MODIFIER_CALL, Utils.validAddress(address)(_token)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
greaterThanZero(_value)

IRs:
MODIFIER_CALL, Utils.greaterThanZero(uint256)(_value)""];
6->1;
}
",1,0,0,0,"validAddress(_spender);token = IERC20(_token);require(bool)(token.transferFrom(_spender,address(this),_value));ReceiveTokens(_spender,_token,_value,_extraData);validAddress(_token);greaterThanZero(_value)"
./0x485b224c97ad56dc5b145eafdee71a7b5163f735_ext.sol,PonziBet.enterRound,94,121,"TMP_29(bool) = msg.value >= 10000000000000000,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),TMP_31 = CONVERT 0 to uint256,TMP_32(bool) = roundTime == TMP_31,TMP_33(uint256) = roundTime + 1800,TMP_34(bool) = TMP_33 <= now,TMP_35(bool) = TMP_32 || TMP_34,CONDITION TMP_35,TMP_36 = CONVERT 0 to uint256,endPrice(uint256) := TMP_36(uint256),REF_14 -> LENGTH upBetRecords,TMP_37 = CONVERT 0 to uint256,REF_14(uint256) (->upBetRecords) := TMP_37(uint256),REF_15 -> LENGTH downBetRecords,TMP_38 = CONVERT 0 to uint256,REF_15(uint256) (->downBetRecords) := TMP_38(uint256),TMP_39(uint256) = HIGH_LEVEL_CALL, dest:pyramid(EthPyramid), function:buyPrice, arguments:[]  ,startPrice(uint256) := TMP_39(uint256),roundTime(uint256) := now(uint256),TMP_40(uint256) = roundTime + 900,TMP_41(bool) = TMP_40 > now,CONDITION TMP_41,TMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['msg.value', '20'] ,fee(uint256) := TMP_42(uint256),TMP_43(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.value', 'fee'] ,userAmount(uint256) := TMP_43(uint256),REF_19(uint256) -> feeBalance[admin],REF_20(uint256) -> feeBalance[admin],TMP_44(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_20', 'fee'] ,REF_19(uint256) (->feeBalance) := TMP_44(uint256),TMP_45(bool) = _bet == True,CONDITION TMP_45,INTERNAL_CALL, PonziBet.recordBet(bool,uint256)(True,userAmount),TMP_47(bool) = _bet == False,CONDITION TMP_47,INTERNAL_CALL, PonziBet.recordBet(bool,uint256)(False,userAmount),REF_22(uint256) -> lastBet[msg.sender],REF_22(uint256) (->lastBet) := now(uint256),TMP_49(None) = SOLIDITY_CALL revert()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= 10000000000000000)

IRs:
TMP_29(bool) = msg.value >= 10000000000000000
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
roundTime == uint256(0) || roundTime + 1800 <= now

IRs:
TMP_31 = CONVERT 0 to uint256
TMP_32(bool) = roundTime == TMP_31
TMP_33(uint256) = roundTime + 1800
TMP_34(bool) = TMP_33 <= now
TMP_35(bool) = TMP_32 || TMP_34
CONDITION TMP_35""];
2->3[label=""True""];
2->8[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
endPrice = uint256(0)

IRs:
TMP_36 = CONVERT 0 to uint256
endPrice(uint256) := TMP_36(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
upBetRecords.length = uint256(0)

IRs:
REF_14 -> LENGTH upBetRecords
TMP_37 = CONVERT 0 to uint256
REF_14(uint256) (->upBetRecords) := TMP_37(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
downBetRecords.length = uint256(0)

IRs:
REF_15 -> LENGTH downBetRecords
TMP_38 = CONVERT 0 to uint256
REF_15(uint256) (->downBetRecords) := TMP_38(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
startPrice = pyramid.buyPrice()

IRs:
TMP_39(uint256) = HIGH_LEVEL_CALL, dest:pyramid(EthPyramid), function:buyPrice, arguments:[]  
startPrice(uint256) := TMP_39(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
roundTime = now

IRs:
roundTime(uint256) := now(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
roundTime + 900 > now

IRs:
TMP_40(uint256) = roundTime + 900
TMP_41(bool) = TMP_40 > now
CONDITION TMP_41""];
9->10[label=""True""];
9->20[label=""False""];
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
fee = msg.value.div(20)

IRs:
TMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['msg.value', '20'] 
fee(uint256) := TMP_42(uint256)""];
10->11;
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
userAmount = msg.value.sub(fee)

IRs:
TMP_43(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.value', 'fee'] 
userAmount(uint256) := TMP_43(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
feeBalance[admin] = feeBalance[admin].add(fee)

IRs:
REF_19(uint256) -> feeBalance[admin]
REF_20(uint256) -> feeBalance[admin]
TMP_44(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_20', 'fee'] 
REF_19(uint256) (->feeBalance) := TMP_44(uint256)""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
_bet == true

IRs:
TMP_45(bool) = _bet == True
CONDITION TMP_45""];
13->14[label=""True""];
13->15[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
recordBet(true,userAmount)

IRs:
INTERNAL_CALL, PonziBet.recordBet(bool,uint256)(True,userAmount)""];
14->18;
15[label=""Node Type: IF 15

EXPRESSION:
_bet == false

IRs:
TMP_47(bool) = _bet == False
CONDITION TMP_47""];
15->16[label=""True""];
15->17[label=""False""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
recordBet(false,userAmount)

IRs:
INTERNAL_CALL, PonziBet.recordBet(bool,uint256)(False,userAmount)""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
lastBet[msg.sender] = now

IRs:
REF_22(uint256) -> lastBet[msg.sender]
REF_22(uint256) (->lastBet) := now(uint256)""];
19->21;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
revert()()

IRs:
TMP_49(None) = SOLIDITY_CALL revert()()""];
20->21;
21[label=""Node Type: END_IF 21
""];
}
",1,0,0,0,"require(bool)(msg.value >= 10000000000000000);roundTime == uint256(0) || roundTime + 1800 <= now;endPrice = uint256(0);;upBetRecords.length = uint256(0);downBetRecords.length = uint256(0);startPrice = pyramid.buyPrice();roundTime = now;roundTime + 900 > now;fee = msg.value.div(20);revert()();userAmount = msg.value.sub(fee);feeBalance[admin] = feeBalance[admin].add(fee);_bet == true;recordBet(true,userAmount);_bet == false;;recordBet(false,userAmount);;lastBet[msg.sender] = now;"
./0xb4007597da3402a1e2b69c8e1c6dd753d01a8035_ext.sol,FundingVault.initialize,810,857,"Emit VaultInitialized(_owner),outputAddress(address) := _output(address),vaultOwner(address) := _owner(address),managerAddress(address) := msg.sender(address),TMP_60 = CONVERT _fundingAddress to ABIFunding,FundingEntity(ABIFunding) := TMP_60(ABIFunding),TMP_61 = CONVERT managerAddress to ABIFundingManager,FundingManagerEntity(ABIFundingManager) := TMP_61(ABIFundingManager),TMP_62 = CONVERT _milestoneAddress to ABIMilestones,MilestonesEntity(ABIMilestones) := TMP_62(ABIMilestones),TMP_63 = CONVERT _proposalsAddress to ABIProposals,ProposalsEntity(ABIProposals) := TMP_63(ABIProposals),TMP_64(address) = HIGH_LEVEL_CALL, dest:FundingEntity(ABIFunding), function:getApplicationAssetAddressByName, arguments:['TokenManager']  ,TokenManagerAddress(address) := TMP_64(address),TMP_65 = CONVERT TokenManagerAddress to ABITokenManager,TokenManagerEntity(ABITokenManager) := TMP_65(ABITokenManager),TMP_66(address) = HIGH_LEVEL_CALL, dest:TokenManagerEntity(ABITokenManager), function:TokenEntity, arguments:[]  ,TokenAddress(address) := TMP_66(address),TMP_67 = CONVERT TokenAddress to ABIToken,TokenEntity(ABIToken) := TMP_67(ABIToken),TMP_68(address) = HIGH_LEVEL_CALL, dest:TokenManagerEntity(ABITokenManager), function:TokenSCADAEntity, arguments:[]  ,TokenSCADAAddress(address) := TMP_68(address),TMP_69 = CONVERT TokenSCADAAddress to ABITokenSCADAVariable,TokenSCADAEntity(ABITokenSCADAVariable) := TMP_69(ABITokenSCADAVariable),TMP_70(address) = HIGH_LEVEL_CALL, dest:TokenManagerEntity(ABITokenManager), function:owner, arguments:[]  ,ApplicationEntityAddress(address) := TMP_70(address),TMP_71 = CONVERT ApplicationEntityAddress to ApplicationEntityABI,ApplicationEntity(ApplicationEntityABI) := TMP_71(ApplicationEntityABI),TMP_72(uint256) = HIGH_LEVEL_CALL, dest:ApplicationEntity(ApplicationEntityABI), function:getBylawUint256, arguments:['emergency_fund_percentage']  ,TMP_73 = CONVERT TMP_72 to uint8,emergencyFundPercentage(uint8) := TMP_73(uint8),TMP_74(uint256) = HIGH_LEVEL_CALL, dest:ApplicationEntity(ApplicationEntityABI), function:getBylawUint256, arguments:['cashback_owner_mia_dur']  ,BylawsCashBackOwnerMiaDuration(uint256) := TMP_74(uint256),TMP_75(uint256) = HIGH_LEVEL_CALL, dest:ApplicationEntity(ApplicationEntityABI), function:getBylawUint256, arguments:['cashback_investor_no']  ,BylawsCashBackVoteRejectedDuration(uint256) := TMP_75(uint256),TMP_76(uint256) = HIGH_LEVEL_CALL, dest:ApplicationEntity(ApplicationEntityABI), function:getBylawUint256, arguments:['proposal_voting_duration']  ,BylawsProposalVotingDuration(uint256) := TMP_76(uint256),_initialized(bool) := True(bool),RETURN True,MODIFIER_CALL, FundingVault.requireNotInitialised()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->23;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
VaultInitialized(_owner)

IRs:
Emit VaultInitialized(_owner)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
outputAddress = _output

IRs:
outputAddress(address) := _output(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
vaultOwner = _owner

IRs:
vaultOwner(address) := _owner(address)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
managerAddress = msg.sender

IRs:
managerAddress(address) := msg.sender(address)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
FundingEntity = ABIFunding(_fundingAddress)

IRs:
TMP_60 = CONVERT _fundingAddress to ABIFunding
FundingEntity(ABIFunding) := TMP_60(ABIFunding)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
FundingManagerEntity = ABIFundingManager(managerAddress)

IRs:
TMP_61 = CONVERT managerAddress to ABIFundingManager
FundingManagerEntity(ABIFundingManager) := TMP_61(ABIFundingManager)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
MilestonesEntity = ABIMilestones(_milestoneAddress)

IRs:
TMP_62 = CONVERT _milestoneAddress to ABIMilestones
MilestonesEntity(ABIMilestones) := TMP_62(ABIMilestones)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ProposalsEntity = ABIProposals(_proposalsAddress)

IRs:
TMP_63 = CONVERT _proposalsAddress to ABIProposals
ProposalsEntity(ABIProposals) := TMP_63(ABIProposals)""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
TokenManagerAddress = FundingEntity.getApplicationAssetAddressByName(TokenManager)

IRs:
TMP_64(address) = HIGH_LEVEL_CALL, dest:FundingEntity(ABIFunding), function:getApplicationAssetAddressByName, arguments:['TokenManager']  
TokenManagerAddress(address) := TMP_64(address)""];
9->10;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
TokenManagerEntity = ABITokenManager(TokenManagerAddress)

IRs:
TMP_65 = CONVERT TokenManagerAddress to ABITokenManager
TokenManagerEntity(ABITokenManager) := TMP_65(ABITokenManager)""];
10->11;
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
TokenAddress = TokenManagerEntity.TokenEntity()

IRs:
TMP_66(address) = HIGH_LEVEL_CALL, dest:TokenManagerEntity(ABITokenManager), function:TokenEntity, arguments:[]  
TokenAddress(address) := TMP_66(address)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
TokenEntity = ABIToken(TokenAddress)

IRs:
TMP_67 = CONVERT TokenAddress to ABIToken
TokenEntity(ABIToken) := TMP_67(ABIToken)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
TokenSCADAAddress = TokenManagerEntity.TokenSCADAEntity()

IRs:
TMP_68(address) = HIGH_LEVEL_CALL, dest:TokenManagerEntity(ABITokenManager), function:TokenSCADAEntity, arguments:[]  
TokenSCADAAddress(address) := TMP_68(address)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
TokenSCADAEntity = ABITokenSCADAVariable(TokenSCADAAddress)

IRs:
TMP_69 = CONVERT TokenSCADAAddress to ABITokenSCADAVariable
TokenSCADAEntity(ABITokenSCADAVariable) := TMP_69(ABITokenSCADAVariable)""];
14->15;
15[label=""Node Type: NEW VARIABLE 15

EXPRESSION:
ApplicationEntityAddress = TokenManagerEntity.owner()

IRs:
TMP_70(address) = HIGH_LEVEL_CALL, dest:TokenManagerEntity(ABITokenManager), function:owner, arguments:[]  
ApplicationEntityAddress(address) := TMP_70(address)""];
15->16;
16[label=""Node Type: NEW VARIABLE 16

EXPRESSION:
ApplicationEntity = ApplicationEntityABI(ApplicationEntityAddress)

IRs:
TMP_71 = CONVERT ApplicationEntityAddress to ApplicationEntityABI
ApplicationEntity(ApplicationEntityABI) := TMP_71(ApplicationEntityABI)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
emergencyFundPercentage = uint8(ApplicationEntity.getBylawUint256(emergency_fund_percentage))

IRs:
TMP_72(uint256) = HIGH_LEVEL_CALL, dest:ApplicationEntity(ApplicationEntityABI), function:getBylawUint256, arguments:['emergency_fund_percentage']  
TMP_73 = CONVERT TMP_72 to uint8
emergencyFundPercentage(uint8) := TMP_73(uint8)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
BylawsCashBackOwnerMiaDuration = ApplicationEntity.getBylawUint256(cashback_owner_mia_dur)

IRs:
TMP_74(uint256) = HIGH_LEVEL_CALL, dest:ApplicationEntity(ApplicationEntityABI), function:getBylawUint256, arguments:['cashback_owner_mia_dur']  
BylawsCashBackOwnerMiaDuration(uint256) := TMP_74(uint256)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
BylawsCashBackVoteRejectedDuration = ApplicationEntity.getBylawUint256(cashback_investor_no)

IRs:
TMP_75(uint256) = HIGH_LEVEL_CALL, dest:ApplicationEntity(ApplicationEntityABI), function:getBylawUint256, arguments:['cashback_investor_no']  
BylawsCashBackVoteRejectedDuration(uint256) := TMP_75(uint256)""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
BylawsProposalVotingDuration = ApplicationEntity.getBylawUint256(proposal_voting_duration)

IRs:
TMP_76(uint256) = HIGH_LEVEL_CALL, dest:ApplicationEntity(ApplicationEntityABI), function:getBylawUint256, arguments:['proposal_voting_duration']  
BylawsProposalVotingDuration(uint256) := TMP_76(uint256)""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
_initialized = true

IRs:
_initialized(bool) := True(bool)""];
21->22;
22[label=""Node Type: RETURN 22

EXPRESSION:
true

IRs:
RETURN True""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
requireNotInitialised()

IRs:
MODIFIER_CALL, FundingVault.requireNotInitialised()()""];
23->1;
}
",1,0,0,0,requireNotInitialised();VaultInitialized(_owner);outputAddress = _output;vaultOwner = _owner;managerAddress = msg.sender;FundingEntity = ABIFunding(_fundingAddress);FundingManagerEntity = ABIFundingManager(managerAddress);MilestonesEntity = ABIMilestones(_milestoneAddress);ProposalsEntity = ABIProposals(_proposalsAddress);TokenManagerAddress = FundingEntity.getApplicationAssetAddressByName(TokenManager);TokenManagerEntity = ABITokenManager(TokenManagerAddress);TokenAddress = TokenManagerEntity.TokenEntity();TokenEntity = ABIToken(TokenAddress);TokenSCADAAddress = TokenManagerEntity.TokenSCADAEntity();TokenSCADAEntity = ABITokenSCADAVariable(TokenSCADAAddress);ApplicationEntityAddress = TokenManagerEntity.owner();ApplicationEntity = ApplicationEntityABI(ApplicationEntityAddress);emergencyFundPercentage = uint8(ApplicationEntity.getBylawUint256(emergency_fund_percentage));BylawsCashBackOwnerMiaDuration = ApplicationEntity.getBylawUint256(cashback_owner_mia_dur);BylawsCashBackVoteRejectedDuration = ApplicationEntity.getBylawUint256(cashback_investor_no);BylawsProposalVotingDuration = ApplicationEntity.getBylawUint256(proposal_voting_duration);_initialized = true;true
./0xebf0027ef3b4b7a742a148cddb0f2b14e5d8f0e9_ext.sol,Crowdsale.buyTokens,301,324,"weiAmount(uint256) := msg.value(uint256),INTERNAL_CALL, Crowdsale._preValidatePurchase(address,uint256)(_beneficiary,weiAmount),TMP_79(uint256) = INTERNAL_CALL, Crowdsale._getTokenAmount(uint256)(weiAmount),tokens(uint256) := TMP_79(uint256),TMP_80(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] ,weiRaised(uint256) := TMP_80(uint256),INTERNAL_CALL, Crowdsale._processPurchase(address,uint256)(_beneficiary,tokens),Emit TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens),INTERNAL_CALL, Crowdsale._updatePurchasingState(address,uint256)(_beneficiary,weiAmount),INTERNAL_CALL, Crowdsale._forwardFunds()(),INTERNAL_CALL, Crowdsale._postValidatePurchase(address,uint256)(_beneficiary,weiAmount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_preValidatePurchase(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._preValidatePurchase(address,uint256)(_beneficiary,weiAmount)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
tokens = _getTokenAmount(weiAmount)

IRs:
TMP_79(uint256) = INTERNAL_CALL, Crowdsale._getTokenAmount(uint256)(weiAmount)
tokens(uint256) := TMP_79(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_80(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_80(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_processPurchase(_beneficiary,tokens)

IRs:
INTERNAL_CALL, Crowdsale._processPurchase(address,uint256)(_beneficiary,tokens)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
_updatePurchasingState(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._updatePurchasingState(address,uint256)(_beneficiary,weiAmount)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
_forwardFunds()

IRs:
INTERNAL_CALL, Crowdsale._forwardFunds()()""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
_postValidatePurchase(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._postValidatePurchase(address,uint256)(_beneficiary,weiAmount)""];
}
",1,0,0,0,"weiAmount = msg.value;_preValidatePurchase(_beneficiary,weiAmount);tokens = _getTokenAmount(weiAmount);weiRaised = weiRaised.add(weiAmount);_processPurchase(_beneficiary,tokens);TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens);_updatePurchasingState(_beneficiary,weiAmount);_forwardFunds();_postValidatePurchase(_beneficiary,weiAmount)"
./0x850c430378909ba9ff2494d0a4df17928e99f8f4_ext.sol,BdpOwnership.approve,738,747,"TMP_380(address) = LIBRARY_CALL, dest:BdpContracts, function:BdpContracts.getBdpOwnershipStorage(address[16]), arguments:['_contracts'] ,TMP_381 = CONVERT TMP_380 to BdpOwnershipStorage,ownStorage(BdpOwnershipStorage) := TMP_381(BdpOwnershipStorage),TMP_382(address) = INTERNAL_CALL, BdpOwnership.ownerOf(address[16],uint256)(_contracts,_tokenId),owner(address) := TMP_382(address),TMP_383(bool) = _to != owner,TMP_384(None) = SOLIDITY_CALL require(bool)(TMP_383),TMP_385(address) = HIGH_LEVEL_CALL, dest:ownStorage(BdpOwnershipStorage), function:getTokenApproval, arguments:['_tokenId']  ,TMP_386(bool) = TMP_385 != 0,TMP_387(bool) = _to != 0,TMP_388(bool) = TMP_386 || TMP_387,CONDITION TMP_388,HIGH_LEVEL_CALL, dest:ownStorage(BdpOwnershipStorage), function:setTokenApproval, arguments:['_tokenId', '_to']  ,Emit Approval(owner,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts))

IRs:
TMP_380(address) = LIBRARY_CALL, dest:BdpContracts, function:BdpContracts.getBdpOwnershipStorage(address[16]), arguments:['_contracts'] 
TMP_381 = CONVERT TMP_380 to BdpOwnershipStorage
ownStorage(BdpOwnershipStorage) := TMP_381(BdpOwnershipStorage)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
owner = ownerOf(_contracts,_tokenId)

IRs:
TMP_382(address) = INTERNAL_CALL, BdpOwnership.ownerOf(address[16],uint256)(_contracts,_tokenId)
owner(address) := TMP_382(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_to != owner)

IRs:
TMP_383(bool) = _to != owner
TMP_384(None) = SOLIDITY_CALL require(bool)(TMP_383)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
ownStorage.getTokenApproval(_tokenId) != 0 || _to != 0

IRs:
TMP_385(address) = HIGH_LEVEL_CALL, dest:ownStorage(BdpOwnershipStorage), function:getTokenApproval, arguments:['_tokenId']  
TMP_386(bool) = TMP_385 != 0
TMP_387(bool) = _to != 0
TMP_388(bool) = TMP_386 || TMP_387
CONDITION TMP_388""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
ownStorage.setTokenApproval(_tokenId,_to)

IRs:
HIGH_LEVEL_CALL, dest:ownStorage(BdpOwnershipStorage), function:setTokenApproval, arguments:['_tokenId', '_to']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Approval(owner,_to,_tokenId)

IRs:
Emit Approval(owner,_to,_tokenId)""];
6->7;
7[label=""Node Type: END_IF 7
""];
}
",1,0,0,0,"ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));owner = ownerOf(_contracts,_tokenId);require(bool)(_to != owner);ownStorage.getTokenApproval(_tokenId) != 0 || _to != 0;ownStorage.setTokenApproval(_tokenId,_to);;Approval(owner,_to,_tokenId)"
./0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497_ext.sol,LockinManager.addValidContract,619,629,"REF_129(uint256) -> allowedContracts[_address],TMP_167(bool) = REF_129 != 0,CONDITION TMP_167,REF_130(uint256) -> allowedContracts[_address],REF_130(uint256) (->allowedContracts) := now(uint256),Emit ValidContractAdded(msg.sender,_address,now),MODIFIER_CALL, LockinManager.adminOnly()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: IF 1

EXPRESSION:
allowedContracts[_address] != 0

IRs:
REF_129(uint256) -> allowedContracts[_address]
TMP_167(bool) = REF_129 != 0
CONDITION TMP_167""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowedContracts[_address] = now

IRs:
REF_130(uint256) -> allowedContracts[_address]
REF_130(uint256) (->allowedContracts) := now(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
ValidContractAdded(msg.sender,_address,now)

IRs:
Emit ValidContractAdded(msg.sender,_address,now)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
adminOnly()

IRs:
MODIFIER_CALL, LockinManager.adminOnly()()""];
6->1;
}
",1,0,0,0,"adminOnly();allowedContracts[_address] != 0;;;allowedContracts[_address] = now;ValidContractAdded(msg.sender,_address,now)"
./0xc4ab0f59c4d8bb15e237906a06a736d965a2c390_ext.sol,AirdropLibraToken.airdropTokens,316,343,"TMP_93(bool) = amount > 0,TMP_94(None) = SOLIDITY_CALL require(bool)(TMP_93),TMP_95(uint256) = HIGH_LEVEL_CALL, dest:token(LibraToken), function:balanceOf, arguments:['this']  ,lbaBalance(uint256) := TMP_95(uint256),TMP_96(bool) = lbaBalance >= amount,TMP_97(None) = SOLIDITY_CALL require(bool)(TMP_96),TMP_98(bool) = HIGH_LEVEL_CALL, dest:token(LibraToken), function:transfer, arguments:['_recipient', 'amount']  ,TMP_99(None) = SOLIDITY_CALL require(bool)(TMP_98),REF_98 -> LENGTH airdropDoneList,TMP_101(uint256) := REF_98(uint256),TMP_102(uint256) = TMP_101 + 1,REF_98(uint256) (->airdropDoneList) := TMP_102(uint256),REF_99(address) -> airdropDoneList[TMP_101],REF_99(address) (->airdropDoneList) := _recipient(address),airDropAmountThisAddr(uint256) := 0(uint256),REF_100(uint256) -> airdropDoneAmountMap[_recipient],TMP_103(bool) = REF_100 > 0,CONDITION TMP_103,REF_101(uint256) -> airdropDoneAmountMap[_recipient],TMP_104(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_101', 'amount'] ,airDropAmountThisAddr(uint256) := TMP_104(uint256),airDropAmountThisAddr(uint256) := amount(uint256),REF_103(uint256) -> airdropDoneAmountMap[_recipient],REF_103(uint256) (->airdropDoneAmountMap) := airDropAmountThisAddr(uint256),TMP_105(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['distributedTotal', 'amount'] ,distributedTotal(uint256) := TMP_105(uint256),Emit Airdrop(_recipient,amount),MODIFIER_CALL, AirdropLibraToken.onlyOwnerOrAdmin()(),MODIFIER_CALL, AirdropLibraToken.onlyWhileAirdropPhaseOpen()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_93(bool) = amount > 0
TMP_94(None) = SOLIDITY_CALL require(bool)(TMP_93)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
lbaBalance = token.balanceOf(this)

IRs:
TMP_95(uint256) = HIGH_LEVEL_CALL, dest:token(LibraToken), function:balanceOf, arguments:['this']  
lbaBalance(uint256) := TMP_95(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(lbaBalance >= amount)

IRs:
TMP_96(bool) = lbaBalance >= amount
TMP_97(None) = SOLIDITY_CALL require(bool)(TMP_96)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(token.transfer(_recipient,amount))

IRs:
TMP_98(bool) = HIGH_LEVEL_CALL, dest:token(LibraToken), function:transfer, arguments:['_recipient', 'amount']  
TMP_99(None) = SOLIDITY_CALL require(bool)(TMP_98)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
airdropDoneList.push(_recipient)

IRs:
REF_98 -> LENGTH airdropDoneList
TMP_101(uint256) := REF_98(uint256)
TMP_102(uint256) = TMP_101 + 1
REF_98(uint256) (->airdropDoneList) := TMP_102(uint256)
REF_99(address) -> airdropDoneList[TMP_101]
REF_99(address) (->airdropDoneList) := _recipient(address)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
airDropAmountThisAddr = 0

IRs:
airDropAmountThisAddr(uint256) := 0(uint256)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
airdropDoneAmountMap[_recipient] > 0

IRs:
REF_100(uint256) -> airdropDoneAmountMap[_recipient]
TMP_103(bool) = REF_100 > 0
CONDITION TMP_103""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
airDropAmountThisAddr = airdropDoneAmountMap[_recipient].add(amount)

IRs:
REF_101(uint256) -> airdropDoneAmountMap[_recipient]
TMP_104(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_101', 'amount'] 
airDropAmountThisAddr(uint256) := TMP_104(uint256)""];
8->10;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
airDropAmountThisAddr = amount

IRs:
airDropAmountThisAddr(uint256) := amount(uint256)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
airdropDoneAmountMap[_recipient] = airDropAmountThisAddr

IRs:
REF_103(uint256) -> airdropDoneAmountMap[_recipient]
REF_103(uint256) (->airdropDoneAmountMap) := airDropAmountThisAddr(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
distributedTotal = distributedTotal.add(amount)

IRs:
TMP_105(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['distributedTotal', 'amount'] 
distributedTotal(uint256) := TMP_105(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
Airdrop(_recipient,amount)

IRs:
Emit Airdrop(_recipient,amount)""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
onlyOwnerOrAdmin()

IRs:
MODIFIER_CALL, AirdropLibraToken.onlyOwnerOrAdmin()()""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
onlyWhileAirdropPhaseOpen()

IRs:
MODIFIER_CALL, AirdropLibraToken.onlyWhileAirdropPhaseOpen()()""];
15->1;
}
",1,0,0,0,"onlyOwnerOrAdmin();require(bool)(amount > 0);lbaBalance = token.balanceOf(this);require(bool)(lbaBalance >= amount);require(bool)(token.transfer(_recipient,amount));airdropDoneList.push(_recipient);airDropAmountThisAddr = 0;airdropDoneAmountMap[_recipient] > 0;airDropAmountThisAddr = airdropDoneAmountMap[_recipient].add(amount);airDropAmountThisAddr = amount;;airdropDoneAmountMap[_recipient] = airDropAmountThisAddr;distributedTotal = distributedTotal.add(amount);Airdrop(_recipient,amount);onlyWhileAirdropPhaseOpen()"
./0x000000c96e715a5b8cd3beaea66bdb749225fa2f_ext.sol,BurnableToken.burn,537,547,"TMP_322(uint256) = HIGH_LEVEL_CALL, dest:balances(BalanceSheet), function:balanceOf, arguments:['msg.sender']  ,TMP_323(bool) = _value <= TMP_322,TMP_324(None) = SOLIDITY_CALL require(bool)(TMP_323),burner(address) := msg.sender(address),HIGH_LEVEL_CALL, dest:balances(BalanceSheet), function:subBalance, arguments:['burner', '_value']  ,TMP_326(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_value'] ,totalSupply_(uint256) := TMP_326(uint256),Emit Burn(burner,_value),TMP_328 = CONVERT 0 to address,Emit Transfer(burner,TMP_328,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= balances.balanceOf(msg.sender))

IRs:
TMP_322(uint256) = HIGH_LEVEL_CALL, dest:balances(BalanceSheet), function:balanceOf, arguments:['msg.sender']  
TMP_323(bool) = _value <= TMP_322
TMP_324(None) = SOLIDITY_CALL require(bool)(TMP_323)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
burner = msg.sender

IRs:
burner(address) := msg.sender(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances.subBalance(burner,_value)

IRs:
HIGH_LEVEL_CALL, dest:balances(BalanceSheet), function:subBalance, arguments:['burner', '_value']  ""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
totalSupply_ = totalSupply_.sub(_value)

IRs:
TMP_326(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply_', '_value'] 
totalSupply_(uint256) := TMP_326(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Burn(burner,_value)

IRs:
Emit Burn(burner,_value)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(burner,address(0),_value)

IRs:
TMP_328 = CONVERT 0 to address
Emit Transfer(burner,TMP_328,_value)""];
}
",1,0,0,0,"require(bool)(_value <= balances.balanceOf(msg.sender));burner = msg.sender;balances.subBalance(burner,_value);totalSupply_ = totalSupply_.sub(_value);Burn(burner,_value);Transfer(burner,address(0),_value)"
./0x0e8175729e02db48ca0e2ca80efb72fe84a7dedd_ext.sol,MechanicKittyUnit.unequipUnit,106,116,"TUPLE_0(uint80,uint8) = HIGH_LEVEL_CALL, dest:units(Units), function:unitsOwned, arguments:['msg.sender', 'unitId']  ,unitsOwned(uint80)= UNPACK TUPLE_0 index: 0 ,TMP_26(bool) = unitsOwned >= amount,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),HIGH_LEVEL_CALL, dest:units(Units), function:deleteUnitExternal, arguments:['amount', 'unitId', 'msg.sender']  ,REF_35(uint256) -> balances[msg.sender],REF_35(-> balances) = REF_35 + amount,totalSupply(uint256) = totalSupply + amount,TMP_29 = CONVERT 0 to address,Emit Transfer(TMP_29,msg.sender,amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
(unitsOwned,None) = units.unitsOwned(msg.sender,unitId)

IRs:
TUPLE_0(uint80,uint8) = HIGH_LEVEL_CALL, dest:units(Units), function:unitsOwned, arguments:['msg.sender', 'unitId']  
unitsOwned(uint80)= UNPACK TUPLE_0 index: 0 ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(unitsOwned >= amount)

IRs:
TMP_26(bool) = unitsOwned >= amount
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
units.deleteUnitExternal(amount,unitId,msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:units(Units), function:deleteUnitExternal, arguments:['amount', 'unitId', 'msg.sender']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[msg.sender] += amount

IRs:
REF_35(uint256) -> balances[msg.sender]
REF_35(-> balances) = REF_35 + amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
totalSupply += amount

IRs:
totalSupply(uint256) = totalSupply + amount""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(address(0),msg.sender,amount)

IRs:
TMP_29 = CONVERT 0 to address
Emit Transfer(TMP_29,msg.sender,amount)""];
}
",1,0,0,0,";(unitsOwned,None) = units.unitsOwned(msg.sender,unitId);require(bool)(unitsOwned >= amount);units.deleteUnitExternal(amount,unitId,msg.sender);balances[msg.sender] += amount;totalSupply += amount;Transfer(address(0),msg.sender,amount)"
./0xeda8b016efa8b1161208cf041cd86972eee0f31e_ext.sol,BonusFinalizeAgent.finalizeCrowdsale,1348,1364,"TMP_651 = CONVERT crowdsale to address,TMP_652(bool) = msg.sender == TMP_651,TMP_653(None) = SOLIDITY_CALL require(bool)(TMP_652),TMP_654(uint256) = HIGH_LEVEL_CALL, dest:token(CrowdsaleToken), function:totalSupply, arguments:[]  ,tokenSupply(uint256) := TMP_654(uint256),TMP_655(uint256) = INTERNAL_CALL, SafeMathLib.safeSub(uint256,uint256)(tokenCap,tokenSupply),allocatedTokens(uint256) := TMP_655(uint256),TMP_656(bool) = allocatedTokens > 0,CONDITION TMP_656,TMP_657(bool) = HIGH_LEVEL_CALL, dest:token(CrowdsaleToken), function:mint, arguments:['walletAddress', 'allocatedTokens']  ,HIGH_LEVEL_CALL, dest:token(CrowdsaleToken), function:releaseTokenTransfer, arguments:[]  ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == address(crowdsale))

IRs:
TMP_651 = CONVERT crowdsale to address
TMP_652(bool) = msg.sender == TMP_651
TMP_653(None) = SOLIDITY_CALL require(bool)(TMP_652)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
tokenSupply = token.totalSupply()

IRs:
TMP_654(uint256) = HIGH_LEVEL_CALL, dest:token(CrowdsaleToken), function:totalSupply, arguments:[]  
tokenSupply(uint256) := TMP_654(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
allocatedTokens = safeSub(tokenCap,tokenSupply)

IRs:
TMP_655(uint256) = INTERNAL_CALL, SafeMathLib.safeSub(uint256,uint256)(tokenCap,tokenSupply)
allocatedTokens(uint256) := TMP_655(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
allocatedTokens > 0

IRs:
TMP_656(bool) = allocatedTokens > 0
CONDITION TMP_656""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
token.mint(walletAddress,allocatedTokens)

IRs:
TMP_657(bool) = HIGH_LEVEL_CALL, dest:token(CrowdsaleToken), function:mint, arguments:['walletAddress', 'allocatedTokens']  ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.releaseTokenTransfer()

IRs:
HIGH_LEVEL_CALL, dest:token(CrowdsaleToken), function:releaseTokenTransfer, arguments:[]  ""];
}
",1,0,0,0,"require(bool)(msg.sender == address(crowdsale));tokenSupply = token.totalSupply();allocatedTokens = safeSub(tokenCap,tokenSupply);allocatedTokens > 0;token.mint(walletAddress,allocatedTokens);;token.releaseTokenTransfer()"
./0x57ae3a491f4555e1eed37338d1b8b5222935f28a_ext.sol,PreSale.buyTokens,571,586,"TMP_290 = CONVERT 0 to address,TMP_291(bool) = _beneficiary != TMP_290,TMP_292(None) = SOLIDITY_CALL require(bool)(TMP_291),TMP_293(bool) = msg.value >= minimumInvest,TMP_294(None) = SOLIDITY_CALL require(bool)(TMP_293),weiAmount(uint256) := msg.value(uint256),TMP_295(uint256) = INTERNAL_CALL, PreSale.getTokenAmount(uint256)(weiAmount),tokens(uint256) := TMP_295(uint256),TMP_296(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokens', 'bonusPercent'] ,TMP_297(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_296', '100'] ,TMP_298(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokens', 'TMP_297'] ,tokens(uint256) := TMP_298(uint256),TMP_299(bool) = HIGH_LEVEL_CALL, dest:token(RicoToken), function:mint, arguments:['_beneficiary', 'tokens']  ,TMP_300(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] ,weiRaised(uint256) := TMP_300(uint256),REF_287(uint256) -> balances[_beneficiary],REF_288(uint256) -> balances[_beneficiary],TMP_301(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_288', 'weiAmount'] ,REF_287(uint256) (->balances) := TMP_301(uint256),Emit TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens),MODIFIER_CALL, PreSale.saleIsOn()(),MODIFIER_CALL, PreSale.isUnderHardCap()(),MODIFIER_CALL, ReentrancyGuard.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_beneficiary != address(0))

IRs:
TMP_290 = CONVERT 0 to address
TMP_291(bool) = _beneficiary != TMP_290
TMP_292(None) = SOLIDITY_CALL require(bool)(TMP_291)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.value >= minimumInvest)

IRs:
TMP_293(bool) = msg.value >= minimumInvest
TMP_294(None) = SOLIDITY_CALL require(bool)(TMP_293)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
tokens = getTokenAmount(weiAmount)

IRs:
TMP_295(uint256) = INTERNAL_CALL, PreSale.getTokenAmount(uint256)(weiAmount)
tokens(uint256) := TMP_295(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
tokens = tokens.add(tokens.mul(bonusPercent).div(100))

IRs:
TMP_296(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokens', 'bonusPercent'] 
TMP_297(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_296', '100'] 
TMP_298(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokens', 'TMP_297'] 
tokens(uint256) := TMP_298(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
token.mint(_beneficiary,tokens)

IRs:
TMP_299(bool) = HIGH_LEVEL_CALL, dest:token(RicoToken), function:mint, arguments:['_beneficiary', 'tokens']  ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_300(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_300(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[_beneficiary] = balances[_beneficiary].add(weiAmount)

IRs:
REF_287(uint256) -> balances[_beneficiary]
REF_288(uint256) -> balances[_beneficiary]
TMP_301(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_288', 'weiAmount'] 
REF_287(uint256) (->balances) := TMP_301(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens)""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
saleIsOn()

IRs:
MODIFIER_CALL, PreSale.saleIsOn()()""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
isUnderHardCap()

IRs:
MODIFIER_CALL, PreSale.isUnderHardCap()()""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, ReentrancyGuard.nonReentrant()()""];
12->1;
}
",1,0,0,0,"saleIsOn();require(bool)(_beneficiary != address(0));require(bool)(msg.value >= minimumInvest);weiAmount = msg.value;tokens = getTokenAmount(weiAmount);tokens = tokens.add(tokens.mul(bonusPercent).div(100));token.mint(_beneficiary,tokens);weiRaised = weiRaised.add(weiAmount);balances[_beneficiary] = balances[_beneficiary].add(weiAmount);TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens);isUnderHardCap();nonReentrant()"
./0x470142a1834438515b757118f322703aba6e1e05_ext.sol,PolicyPalNetworkAirdrop.twitterDropSingleAmount,169,189,"i(uint256) := 0(uint256),REF_15 -> LENGTH _recipients,TMP_22(bool) = i < REF_15,CONDITION TMP_22,REF_16(address) -> _recipients[i],recipient(address) := REF_16(address),REF_17(bool) -> twitterdrops[recipient],TMP_23 = UnaryType.BANG REF_17 ,CONDITION TMP_23,TMP_24(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', '_amount']  ,TMP_25(None) = SOLIDITY_CALL assert(bool)(TMP_24),REF_19(bool) -> twitterdrops[recipient],REF_19(bool) (->twitterdrops) := True(bool),TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] ,numDrops(uint256) := TMP_26(uint256),TMP_27(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', '_amount'] ,dropAmount(uint256) := TMP_27(uint256),Emit TokenDrop(recipient,_amount,TWITTER),TMP_29(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()(),MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalance(address[],uint256)(_recipients,_amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _recipients.length

IRs:
REF_15 -> LENGTH _recipients
TMP_22(bool) = i < REF_15
CONDITION TMP_22""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
recipient = _recipients[i]

IRs:
REF_16(address) -> _recipients[i]
recipient(address) := REF_16(address)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
! twitterdrops[recipient]

IRs:
REF_17(bool) -> twitterdrops[recipient]
TMP_23 = UnaryType.BANG REF_17 
CONDITION TMP_23""];
6->7[label=""True""];
6->12[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(token.transfer(recipient,_amount))

IRs:
TMP_24(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', '_amount']  
TMP_25(None) = SOLIDITY_CALL assert(bool)(TMP_24)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
twitterdrops[recipient] = true

IRs:
REF_19(bool) -> twitterdrops[recipient]
REF_19(bool) (->twitterdrops) := True(bool)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
numDrops = numDrops.add(1)

IRs:
TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] 
numDrops(uint256) := TMP_26(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
dropAmount = dropAmount.add(_amount)

IRs:
TMP_27(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', '_amount'] 
dropAmount(uint256) := TMP_27(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
TokenDrop(recipient,_amount,TWITTER)

IRs:
Emit TokenDrop(recipient,_amount,TWITTER)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
i ++

IRs:
TMP_29(uint256) := i(uint256)
i(uint256) = i + 1""];
13->4;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()()""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
validBalance(_recipients,_amount)

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalance(address[],uint256)(_recipients,_amount)""];
15->3;
}
",1,0,0,0,"onlyAdmin();;i < _recipients.length;;i = 0;recipient = _recipients[i];! twitterdrops[recipient];assert(bool)(token.transfer(recipient,_amount));;twitterdrops[recipient] = true;numDrops = numDrops.add(1);dropAmount = dropAmount.add(_amount);TokenDrop(recipient,_amount,TWITTER);i ++;validBalance(_recipients,_amount)"
./0xeee7c7e228eafb0f8945c5dbaa8ea4f6ee12b36d_ext.sol,Crowdsale.buyTokens,120,142,"TMP_21(bool) = beneficiary != 0,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),TMP_23(bool) = INTERNAL_CALL, Crowdsale.validPurchase()(),TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),weiAmount(uint256) := msg.value(uint256),TMP_25(uint256) = weiAmount * price,tokens(uint256) := TMP_25(uint256),TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] ,weiRaised(uint256) := TMP_26(uint256),HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['beneficiary', 'tokens']  ,Emit TokenPurchase(msg.sender,beneficiary,weiAmount,tokens),INTERNAL_CALL, Crowdsale.forwardFunds()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != 0x0)

IRs:
TMP_21(bool) = beneficiary != 0
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(validPurchase())

IRs:
TMP_23(bool) = INTERNAL_CALL, Crowdsale.validPurchase()()
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
tokens = (weiAmount) * price

IRs:
TMP_25(uint256) = weiAmount * price
tokens(uint256) := TMP_25(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_26(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tokenReward.transfer(beneficiary,tokens)

IRs:
HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['beneficiary', 'tokens']  ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
forwardFunds()

IRs:
INTERNAL_CALL, Crowdsale.forwardFunds()()""];
}
",1,0,0,0,"require(bool)(beneficiary != 0x0);require(bool)(validPurchase());weiAmount = msg.value;tokens = (weiAmount) * price;weiRaised = weiRaised.add(weiAmount);tokenReward.transfer(beneficiary,tokens);TokenPurchase(msg.sender,beneficiary,weiAmount,tokens);forwardFunds()"
./0x25cf23787ac0f92a3eafa61f458ad0b7c4b27c3d_ext.sol,Zethroll.ownerSetBankroll,384,390,"TMP_92(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:approve, arguments:['ZethrBankroll', '0']  ,ZethrBankroll(address) := newBankroll(address),TMP_93(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:approve, arguments:['newBankroll', 'MAX_INT']  ,MODIFIER_CALL, Zethroll.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ZTHTKN.approve(ZethrBankroll,0)

IRs:
TMP_92(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:approve, arguments:['ZethrBankroll', '0']  ""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ZethrBankroll = newBankroll

IRs:
ZethrBankroll(address) := newBankroll(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ZTHTKN.approve(newBankroll,MAX_INT)

IRs:
TMP_93(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:approve, arguments:['newBankroll', 'MAX_INT']  ""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Zethroll.onlyOwner()()""];
4->1;
}
",1,0,0,0,"onlyOwner();ZTHTKN.approve(ZethrBankroll,0);ZethrBankroll = newBankroll;ZTHTKN.approve(newBankroll,MAX_INT)"
./0x6b62f10b1d042d3ed601899ca25f80f9dbc92644_ext.sol,TwoCoinsOneMoonGame.betRedCoin,90,98,"TMP_14(uint256) = INTERNAL_CALL, TwoCoinsOneMoonGame.getBetAmount()(),betAmount(uint256) := TMP_14(uint256),marketCapRed(uint256) = marketCapRed + betAmount,TMP_15(TwoCoinsOneMoonGame.Bettor) = new Bettor(msg.sender,betAmount),REF_7 -> LENGTH bettorsRed,TMP_17(uint256) := REF_7(uint256),TMP_18(uint256) = TMP_17 + 1,REF_7(uint256) (->bettorsRed) := TMP_18(uint256),REF_8(TwoCoinsOneMoonGame.Bettor) -> bettorsRed[TMP_17],REF_8(TwoCoinsOneMoonGame.Bettor) (->bettorsRed) := TMP_15(TwoCoinsOneMoonGame.Bettor),REF_9 -> LENGTH bettorsRed,endBetRed(uint256) := REF_9(uint256),INTERNAL_CALL, TwoCoinsOneMoonGame.checkMoon()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
betAmount = getBetAmount()

IRs:
TMP_14(uint256) = INTERNAL_CALL, TwoCoinsOneMoonGame.getBetAmount()()
betAmount(uint256) := TMP_14(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
marketCapRed += betAmount

IRs:
marketCapRed(uint256) = marketCapRed + betAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
bettorsRed.push(Bettor({account:msg.sender,amount:betAmount}))

IRs:
TMP_15(TwoCoinsOneMoonGame.Bettor) = new Bettor(msg.sender,betAmount)
REF_7 -> LENGTH bettorsRed
TMP_17(uint256) := REF_7(uint256)
TMP_18(uint256) = TMP_17 + 1
REF_7(uint256) (->bettorsRed) := TMP_18(uint256)
REF_8(TwoCoinsOneMoonGame.Bettor) -> bettorsRed[TMP_17]
REF_8(TwoCoinsOneMoonGame.Bettor) (->bettorsRed) := TMP_15(TwoCoinsOneMoonGame.Bettor)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
endBetRed = bettorsRed.length

IRs:
REF_9 -> LENGTH bettorsRed
endBetRed(uint256) := REF_9(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
checkMoon()

IRs:
INTERNAL_CALL, TwoCoinsOneMoonGame.checkMoon()()""];
}
",1,0,0,0,"betAmount = getBetAmount();marketCapRed += betAmount;bettorsRed.push(Bettor({account:msg.sender,amount:betAmount}));endBetRed = bettorsRed.length;checkMoon()"
./0x57db9d1890eb580a5ba18926a7c76f7abaa1831d_ext.sol,BdpOwnership.approve,542,551,"TMP_269(address) = LIBRARY_CALL, dest:BdpContracts, function:BdpContracts.getBdpOwnershipStorage(address[16]), arguments:['_contracts'] ,TMP_270 = CONVERT TMP_269 to BdpOwnershipStorage,ownStorage(BdpOwnershipStorage) := TMP_270(BdpOwnershipStorage),TMP_271(address) = INTERNAL_CALL, BdpOwnership.ownerOf(address[16],uint256)(_contracts,_tokenId),owner(address) := TMP_271(address),TMP_272(bool) = _to != owner,TMP_273(None) = SOLIDITY_CALL require(bool)(TMP_272),TMP_274(address) = HIGH_LEVEL_CALL, dest:ownStorage(BdpOwnershipStorage), function:getTokenApproval, arguments:['_tokenId']  ,TMP_275(bool) = TMP_274 != 0,TMP_276(bool) = _to != 0,TMP_277(bool) = TMP_275 || TMP_276,CONDITION TMP_277,HIGH_LEVEL_CALL, dest:ownStorage(BdpOwnershipStorage), function:setTokenApproval, arguments:['_tokenId', '_to']  ,Emit Approval(owner,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts))

IRs:
TMP_269(address) = LIBRARY_CALL, dest:BdpContracts, function:BdpContracts.getBdpOwnershipStorage(address[16]), arguments:['_contracts'] 
TMP_270 = CONVERT TMP_269 to BdpOwnershipStorage
ownStorage(BdpOwnershipStorage) := TMP_270(BdpOwnershipStorage)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
owner = ownerOf(_contracts,_tokenId)

IRs:
TMP_271(address) = INTERNAL_CALL, BdpOwnership.ownerOf(address[16],uint256)(_contracts,_tokenId)
owner(address) := TMP_271(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_to != owner)

IRs:
TMP_272(bool) = _to != owner
TMP_273(None) = SOLIDITY_CALL require(bool)(TMP_272)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
ownStorage.getTokenApproval(_tokenId) != 0 || _to != 0

IRs:
TMP_274(address) = HIGH_LEVEL_CALL, dest:ownStorage(BdpOwnershipStorage), function:getTokenApproval, arguments:['_tokenId']  
TMP_275(bool) = TMP_274 != 0
TMP_276(bool) = _to != 0
TMP_277(bool) = TMP_275 || TMP_276
CONDITION TMP_277""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
ownStorage.setTokenApproval(_tokenId,_to)

IRs:
HIGH_LEVEL_CALL, dest:ownStorage(BdpOwnershipStorage), function:setTokenApproval, arguments:['_tokenId', '_to']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Approval(owner,_to,_tokenId)

IRs:
Emit Approval(owner,_to,_tokenId)""];
6->7;
7[label=""Node Type: END_IF 7
""];
}
",1,0,0,0,"ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));owner = ownerOf(_contracts,_tokenId);require(bool)(_to != owner);ownStorage.getTokenApproval(_tokenId) != 0 || _to != 0;ownStorage.setTokenApproval(_tokenId,_to);;Approval(owner,_to,_tokenId)"
./0xf244176246168f24e3187f7288edbca29267739b_ext.sol,EtherNomin.confiscateBalance,1724,1748,"TMP_668 = CONVERT msg.sender to Court,TMP_669(bool) = TMP_668 == court,TMP_670(None) = SOLIDITY_CALL require(bool)(TMP_669),TMP_671(uint256) = HIGH_LEVEL_CALL, dest:court(Court), function:targetMotionID, arguments:['target']  ,motionID(uint256) := TMP_671(uint256),TMP_672(bool) = motionID != 0,TMP_673(None) = SOLIDITY_CALL require(bool)(TMP_672),TMP_674(bool) = HIGH_LEVEL_CALL, dest:court(Court), function:motionConfirming, arguments:['motionID']  ,TMP_675(None) = SOLIDITY_CALL require(bool)(TMP_674),TMP_676(bool) = HIGH_LEVEL_CALL, dest:court(Court), function:motionPasses, arguments:['motionID']  ,TMP_677(None) = SOLIDITY_CALL require(bool)(TMP_676),REF_123(bool) -> frozen[target],TMP_678 = UnaryType.BANG REF_123 ,TMP_679(None) = SOLIDITY_CALL require(bool)(TMP_678),TMP_680(uint256) = HIGH_LEVEL_CALL, dest:state(TokenState), function:balanceOf, arguments:['target']  ,balance(uint256) := TMP_680(uint256),TMP_681 = CONVERT this to address,TMP_682 = CONVERT this to address,TMP_683(uint256) = HIGH_LEVEL_CALL, dest:state(TokenState), function:balanceOf, arguments:['TMP_682']  ,TMP_684(uint256) = INTERNAL_CALL, SafeDecimalMath.safeAdd(uint256,uint256)(TMP_683,balance),HIGH_LEVEL_CALL, dest:state(TokenState), function:setBalanceOf, arguments:['TMP_681', 'TMP_684']  ,HIGH_LEVEL_CALL, dest:state(TokenState), function:setBalanceOf, arguments:['target', '0']  ,REF_128(bool) -> frozen[target],REF_128(bool) (->frozen) := True(bool),Emit AccountFrozen(target,target,balance),TMP_688 = CONVERT this to address,Emit Transfer(target,TMP_688,balance)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(Court(msg.sender) == court)

IRs:
TMP_668 = CONVERT msg.sender to Court
TMP_669(bool) = TMP_668 == court
TMP_670(None) = SOLIDITY_CALL require(bool)(TMP_669)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
motionID = court.targetMotionID(target)

IRs:
TMP_671(uint256) = HIGH_LEVEL_CALL, dest:court(Court), function:targetMotionID, arguments:['target']  
motionID(uint256) := TMP_671(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(motionID != 0)

IRs:
TMP_672(bool) = motionID != 0
TMP_673(None) = SOLIDITY_CALL require(bool)(TMP_672)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(court.motionConfirming(motionID))

IRs:
TMP_674(bool) = HIGH_LEVEL_CALL, dest:court(Court), function:motionConfirming, arguments:['motionID']  
TMP_675(None) = SOLIDITY_CALL require(bool)(TMP_674)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(court.motionPasses(motionID))

IRs:
TMP_676(bool) = HIGH_LEVEL_CALL, dest:court(Court), function:motionPasses, arguments:['motionID']  
TMP_677(None) = SOLIDITY_CALL require(bool)(TMP_676)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(! frozen[target])

IRs:
REF_123(bool) -> frozen[target]
TMP_678 = UnaryType.BANG REF_123 
TMP_679(None) = SOLIDITY_CALL require(bool)(TMP_678)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
balance = state.balanceOf(target)

IRs:
TMP_680(uint256) = HIGH_LEVEL_CALL, dest:state(TokenState), function:balanceOf, arguments:['target']  
balance(uint256) := TMP_680(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
state.setBalanceOf(address(this),safeAdd(state.balanceOf(address(this)),balance))

IRs:
TMP_681 = CONVERT this to address
TMP_682 = CONVERT this to address
TMP_683(uint256) = HIGH_LEVEL_CALL, dest:state(TokenState), function:balanceOf, arguments:['TMP_682']  
TMP_684(uint256) = INTERNAL_CALL, SafeDecimalMath.safeAdd(uint256,uint256)(TMP_683,balance)
HIGH_LEVEL_CALL, dest:state(TokenState), function:setBalanceOf, arguments:['TMP_681', 'TMP_684']  ""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
state.setBalanceOf(target,0)

IRs:
HIGH_LEVEL_CALL, dest:state(TokenState), function:setBalanceOf, arguments:['target', '0']  ""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
frozen[target] = true

IRs:
REF_128(bool) -> frozen[target]
REF_128(bool) (->frozen) := True(bool)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
AccountFrozen(target,target,balance)

IRs:
Emit AccountFrozen(target,target,balance)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
Transfer(target,address(this),balance)

IRs:
TMP_688 = CONVERT this to address
Emit Transfer(target,TMP_688,balance)""];
}
",1,0,0,0,"require(bool)(Court(msg.sender) == court);motionID = court.targetMotionID(target);require(bool)(motionID != 0);require(bool)(court.motionConfirming(motionID));require(bool)(court.motionPasses(motionID));require(bool)(! frozen[target]);balance = state.balanceOf(target);state.setBalanceOf(address(this),safeAdd(state.balanceOf(address(this)),balance));state.setBalanceOf(target,0);frozen[target] = true;AccountFrozen(target,target,balance);Transfer(target,address(this),balance)"
./0xc767b1cec507f1584469e8efe1a94ad4c75e02ed_ext.sol,PremiumFactories.claimUnits,135,153,"REF_44(PremiumFactories.PremiumFactory) -> premiumFactories[factoryId],factory(PremiumFactories.PremiumFactory) := REF_44(PremiumFactories.PremiumFactory),REF_45(address) -> factory.owner,TMP_67(bool) = REF_45 == msg.sender,TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67),REF_46(uint256) -> factory.unitId,REF_47(PremiumUnit) -> premiumUnits[REF_46],premiumUnit(PremiumUnit) := REF_47(PremiumUnit),TMP_69(uint256) = HIGH_LEVEL_CALL, dest:premiumUnit(PremiumUnit), function:unitProductionSeconds, arguments:[]  ,unitProductionSeconds(uint256) := TMP_69(uint256),REF_49(uint256) -> factory.lastClaimTimestamp,TMP_70(uint256) = now - REF_49,TMP_71(uint256) = TMP_70 / unitProductionSeconds,unitsProduced(uint256) := TMP_71(uint256),TMP_72(bool) = unitsProduced > 0,TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72),REF_50(uint256) -> factory.lastClaimTimestamp,TMP_74(uint256) = unitProductionSeconds * unitsProduced,REF_50(-> factory) = REF_50 + TMP_74,HIGH_LEVEL_CALL, dest:premiumUnit(PremiumUnit), function:mintUnit, arguments:['msg.sender', 'unitsProduced']  ,CONDITION equip,TMP_76 = CONVERT unitsProduced to uint80,HIGH_LEVEL_CALL, dest:premiumUnit(PremiumUnit), function:equipUnit, arguments:['msg.sender', 'TMP_76', '100']  ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
factory = premiumFactories[factoryId]

IRs:
REF_44(PremiumFactories.PremiumFactory) -> premiumFactories[factoryId]
factory(PremiumFactories.PremiumFactory) := REF_44(PremiumFactories.PremiumFactory)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(factory.owner == msg.sender)

IRs:
REF_45(address) -> factory.owner
TMP_67(bool) = REF_45 == msg.sender
TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
premiumUnit = premiumUnits[factory.unitId]

IRs:
REF_46(uint256) -> factory.unitId
REF_47(PremiumUnit) -> premiumUnits[REF_46]
premiumUnit(PremiumUnit) := REF_47(PremiumUnit)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
unitProductionSeconds = premiumUnit.unitProductionSeconds()

IRs:
TMP_69(uint256) = HIGH_LEVEL_CALL, dest:premiumUnit(PremiumUnit), function:unitProductionSeconds, arguments:[]  
unitProductionSeconds(uint256) := TMP_69(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
unitsProduced = (now - factory.lastClaimTimestamp) / unitProductionSeconds

IRs:
REF_49(uint256) -> factory.lastClaimTimestamp
TMP_70(uint256) = now - REF_49
TMP_71(uint256) = TMP_70 / unitProductionSeconds
unitsProduced(uint256) := TMP_71(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(unitsProduced > 0)

IRs:
TMP_72(bool) = unitsProduced > 0
TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
factory.lastClaimTimestamp += (unitProductionSeconds * unitsProduced)

IRs:
REF_50(uint256) -> factory.lastClaimTimestamp
TMP_74(uint256) = unitProductionSeconds * unitsProduced
REF_50(-> factory) = REF_50 + TMP_74""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
premiumUnit.mintUnit(msg.sender,unitsProduced)

IRs:
HIGH_LEVEL_CALL, dest:premiumUnit(PremiumUnit), function:mintUnit, arguments:['msg.sender', 'unitsProduced']  ""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
equip

IRs:
CONDITION equip""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
premiumUnit.equipUnit(msg.sender,uint80(unitsProduced),100)

IRs:
TMP_76 = CONVERT unitsProduced to uint80
HIGH_LEVEL_CALL, dest:premiumUnit(PremiumUnit), function:equipUnit, arguments:['msg.sender', 'TMP_76', '100']  ""];
10->11;
11[label=""Node Type: END_IF 11
""];
}
",1,0,0,0,"factory = premiumFactories[factoryId];require(bool)(factory.owner == msg.sender);premiumUnit = premiumUnits[factory.unitId];unitProductionSeconds = premiumUnit.unitProductionSeconds();unitsProduced = (now - factory.lastClaimTimestamp) / unitProductionSeconds;require(bool)(unitsProduced > 0);factory.lastClaimTimestamp += (unitProductionSeconds * unitsProduced);premiumUnit.mintUnit(msg.sender,unitsProduced);equip;premiumUnit.equipUnit(msg.sender,uint80(unitsProduced),100);"
./0x0002325fcaaac6ebf1254a626589147bde1a2394_ext.sol,HorseyToken.freeForCarrots,775,785,"REF_78(HorseyToken.FeedingData) -> pendingFeedings[msg.sender],REF_79(uint256) -> REF_78.horsey,TMP_241(bool) = REF_79 != tokenId,TMP_242(None) = SOLIDITY_CALL require(bool,string)(TMP_241,),TUPLE_6(address,bytes32,uint8,uint8) = HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:horseys, arguments:['tokenId']  ,feedingCounter(uint8)= UNPACK TUPLE_6 index: 2 ,TMP_243(uint32) = HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:carrot_credits, arguments:['msg.sender']  ,TMP_244(uint8) = feedingCounter * carrotsMultiplier,TMP_245 = CONVERT TMP_244 to uint32,TMP_246(uint32) = TMP_243 + TMP_245,HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:storeCarrotsCredit, arguments:['msg.sender', 'TMP_246']  ,HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:unstoreHorsey, arguments:['tokenId']  ,Emit HorseyFreed(tokenId),MODIFIER_CALL, Pausable.whenNotPaused()(),MODIFIER_CALL, HorseyToken.onlyOwnerOf(uint256)(tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(pendingFeedings[msg.sender].horsey != tokenId,)

IRs:
REF_78(HorseyToken.FeedingData) -> pendingFeedings[msg.sender]
REF_79(uint256) -> REF_78.horsey
TMP_241(bool) = REF_79 != tokenId
TMP_242(None) = SOLIDITY_CALL require(bool,string)(TMP_241,)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
(None,None,feedingCounter,None) = stables.horseys(tokenId)

IRs:
TUPLE_6(address,bytes32,uint8,uint8) = HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:horseys, arguments:['tokenId']  
feedingCounter(uint8)= UNPACK TUPLE_6 index: 2 ""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) + uint32(feedingCounter * carrotsMultiplier))

IRs:
TMP_243(uint32) = HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:carrot_credits, arguments:['msg.sender']  
TMP_244(uint8) = feedingCounter * carrotsMultiplier
TMP_245 = CONVERT TMP_244 to uint32
TMP_246(uint32) = TMP_243 + TMP_245
HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:storeCarrotsCredit, arguments:['msg.sender', 'TMP_246']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
stables.unstoreHorsey(tokenId)

IRs:
HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:unstoreHorsey, arguments:['tokenId']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
HorseyFreed(tokenId)

IRs:
Emit HorseyFreed(tokenId)""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwnerOf(tokenId)

IRs:
MODIFIER_CALL, HorseyToken.onlyOwnerOf(uint256)(tokenId)""];
8->1;
}
",1,0,0,0,"whenNotPaused();require(bool,string)(pendingFeedings[msg.sender].horsey != tokenId,);;(None,None,feedingCounter,None) = stables.horseys(tokenId);stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) + uint32(feedingCounter * carrotsMultiplier));stables.unstoreHorsey(tokenId);HorseyFreed(tokenId);onlyOwnerOf(tokenId)"
./0x574fb6d9d090042a04d0d12a4e87217f8303a5ca_ext.sol,GoldBackedToken.mintTokens,599,606,"TMP_364(bool) = msg.sender == authorisedMinter,TMP_365(None) = SOLIDITY_CALL require(bool)(TMP_364),INTERNAL_CALL, GoldBackedToken.update(address)(destination),REF_139(GoldBackedToken.Balance) -> balances[destination],REF_140(uint256) -> REF_139.amount,REF_141(GoldBackedToken.Balance) -> balances[destination],REF_142(uint256) -> REF_141.amount,TMP_367(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_142,amount),REF_140(uint256) (->balances) := TMP_367(uint256),REF_143(GoldBackedToken.Balance) -> balances[destination],REF_144(uint256) -> REF_143.lastUpdated,REF_144(uint256) (->balances) := now(uint256),REF_145(GoldBackedToken.Balance) -> balances[destination],REF_146(uint256) -> REF_145.nextAllocationIndex,REF_147 -> LENGTH currentAllocations,REF_146(uint256) (->balances) := REF_147(uint256),Emit TokenMinted(destination,amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == authorisedMinter)

IRs:
TMP_364(bool) = msg.sender == authorisedMinter
TMP_365(None) = SOLIDITY_CALL require(bool)(TMP_364)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
update(destination)

IRs:
INTERNAL_CALL, GoldBackedToken.update(address)(destination)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[destination].amount = safeAdd(balances[destination].amount,amount)

IRs:
REF_139(GoldBackedToken.Balance) -> balances[destination]
REF_140(uint256) -> REF_139.amount
REF_141(GoldBackedToken.Balance) -> balances[destination]
REF_142(uint256) -> REF_141.amount
TMP_367(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_142,amount)
REF_140(uint256) (->balances) := TMP_367(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[destination].lastUpdated = now

IRs:
REF_143(GoldBackedToken.Balance) -> balances[destination]
REF_144(uint256) -> REF_143.lastUpdated
REF_144(uint256) (->balances) := now(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[destination].nextAllocationIndex = currentAllocations.length

IRs:
REF_145(GoldBackedToken.Balance) -> balances[destination]
REF_146(uint256) -> REF_145.nextAllocationIndex
REF_147 -> LENGTH currentAllocations
REF_146(uint256) (->balances) := REF_147(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
TokenMinted(destination,amount)

IRs:
Emit TokenMinted(destination,amount)""];
}
",1,0,0,0,"require(bool)(msg.sender == authorisedMinter);update(destination);balances[destination].amount = safeAdd(balances[destination].amount,amount);balances[destination].lastUpdated = now;balances[destination].nextAllocationIndex = currentAllocations.length;TokenMinted(destination,amount)"
./0x4802fe0bf7eb3b3b0dce3ede89c575341f10e3e0_ext.sol,SynergisProxyDeposit.setERC20address,141,146,"TMP_46 = CONVERT currentERC20contract to address,TMP_47(bool) = TMP_46 != 0,TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47),TMP_49 = CONVERT currentERC20contract to AbstractCon,ac(AbstractCon) := TMP_49(AbstractCon),TMP_50 = CONVERT this to address,TMP_51(uint256) = HIGH_LEVEL_CALL, dest:ac(AbstractCon), function:allowance, arguments:['currentERC20contract', 'TMP_50']  ,TMP_52(bool) = TMP_51 > 0,TMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52),ERC20address(address) := currentERC20contract(address),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(address(currentERC20contract) != 0)

IRs:
TMP_46 = CONVERT currentERC20contract to address
TMP_47(bool) = TMP_46 != 0
TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
ac = AbstractCon(currentERC20contract)

IRs:
TMP_49 = CONVERT currentERC20contract to AbstractCon
ac(AbstractCon) := TMP_49(AbstractCon)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(ac.allowance(currentERC20contract,address(this)) > 0)

IRs:
TMP_50 = CONVERT this to address
TMP_51(uint256) = HIGH_LEVEL_CALL, dest:ac(AbstractCon), function:allowance, arguments:['currentERC20contract', 'TMP_50']  
TMP_52(bool) = TMP_51 > 0
TMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ERC20address = currentERC20contract

IRs:
ERC20address(address) := currentERC20contract(address)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",1,0,0,0,"onlyOwner();require(bool)(address(currentERC20contract) != 0);ac = AbstractCon(currentERC20contract);require(bool)(ac.allowance(currentERC20contract,address(this)) > 0);ERC20address = currentERC20contract"
./0x6543cde961213e82001594bf4c34706579ce34ec_ext.sol,ClinicAllCrowdsale.redeemPrivateSaleFunds,2242,2249,"TMP_1154 = CONVERT token to ClinicAllToken,TMP_1155(uint256) = HIGH_LEVEL_CALL, dest:TMP_1154(ClinicAllToken), function:balanceOf, arguments:['msg.sender']  ,_balance(uint256) := TMP_1155(uint256),TMP_1156(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['privateSaleSupplyLimit', '_balance'] ,privateSaleSupplyLimit(uint256) := TMP_1156(uint256),TMP_1157 = CONVERT token to ClinicAllToken,HIGH_LEVEL_CALL, dest:TMP_1157(ClinicAllToken), function:burnPrivateSale, arguments:['msg.sender', '_balance']  ,MODIFIER_CALL, ClinicAllCrowdsale.onlyPrivateSaleWallet()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_balance = ClinicAllToken(token).balanceOf(msg.sender)

IRs:
TMP_1154 = CONVERT token to ClinicAllToken
TMP_1155(uint256) = HIGH_LEVEL_CALL, dest:TMP_1154(ClinicAllToken), function:balanceOf, arguments:['msg.sender']  
_balance(uint256) := TMP_1155(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
privateSaleSupplyLimit = privateSaleSupplyLimit.sub(_balance)

IRs:
TMP_1156(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['privateSaleSupplyLimit', '_balance'] 
privateSaleSupplyLimit(uint256) := TMP_1156(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ClinicAllToken(token).burnPrivateSale(msg.sender,_balance)

IRs:
TMP_1157 = CONVERT token to ClinicAllToken
HIGH_LEVEL_CALL, dest:TMP_1157(ClinicAllToken), function:burnPrivateSale, arguments:['msg.sender', '_balance']  ""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyPrivateSaleWallet()

IRs:
MODIFIER_CALL, ClinicAllCrowdsale.onlyPrivateSaleWallet()()""];
4->1;
}
",1,0,0,0,"onlyPrivateSaleWallet();_balance = ClinicAllToken(token).balanceOf(msg.sender);privateSaleSupplyLimit = privateSaleSupplyLimit.sub(_balance);ClinicAllToken(token).burnPrivateSale(msg.sender,_balance)"
./0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a_ext.sol,BitSTDView.burnFrom,534,539,"TMP_167(bool) = HIGH_LEVEL_CALL, dest:logic(BitSTDLogic), function:burnFrom, arguments:['_from', 'msg.sender', '_value']  ,TMP_168(bool) = TMP_167 == True,CONDITION TMP_168,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
logic.burnFrom(_from,msg.sender,_value) == true

IRs:
TMP_167(bool) = HIGH_LEVEL_CALL, dest:logic(BitSTDLogic), function:burnFrom, arguments:['_from', 'msg.sender', '_value']  
TMP_168(bool) = TMP_167 == True
CONDITION TMP_168""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,0,0,0,"logic.burnFrom(_from,msg.sender,_value) == true;Burn(_from,_value);;true;success"
./0x655f1cb6616d7f0550007498113e72d7d5c5d4bb_ext.sol,MedalClaim.claimStupidFluffyPink,447,460,"REF_95(bool[12]) -> claimedbyAddress[msg.sender],REF_96(bool) -> REF_95[7],TMP_307(bool) = REF_96 == True,CONDITION TMP_307,TMP_308(None) = SOLIDITY_CALL revert()(),TMP_309(uint8) = INTERNAL_CALL, MedalClaim.getPetCardSeries(uint64)(petId),TMP_310(bool) = TMP_309 == 13,TMP_311(uint8) = INTERNAL_CALL, MedalClaim.getPetCardSeries(uint64)(petId),TMP_312(bool) = TMP_311 == 14,TMP_313(bool) = TMP_310 || TMP_312,TMP_314(uint8) = INTERNAL_CALL, MedalClaim.getPetCardSeries(uint64)(petId),TMP_315(bool) = TMP_314 == 15,TMP_316(bool) = TMP_313 || TMP_315,TMP_317(uint8) = INTERNAL_CALL, MedalClaim.getPetCardSeries(uint64)(petId),TMP_318(bool) = TMP_317 == 16,TMP_319(bool) = TMP_316 || TMP_318,CONDITION TMP_319,TMP_320(bool) = INTERNAL_CALL, MedalClaim.checkExistsOwnedPet(uint64)(petId),TMP_321(bool) = TMP_320 == True,CONDITION TMP_321,TMP_322 = CONVERT medalDataContract to IMedalData,medalData(IMedalData) := TMP_322(IMedalData),REF_97(bool[12]) -> claimedbyAddress[msg.sender],REF_98(bool) -> REF_97[7],REF_98(bool) (->claimedbyAddress) := True(bool),HIGH_LEVEL_CALL, dest:medalData(IMedalData), function:_createMedal, arguments:['msg.sender', '7']  ,Emit EventMedalSuccessful(msg.sender,7)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
claimedbyAddress[msg.sender][7] == true

IRs:
REF_95(bool[12]) -> claimedbyAddress[msg.sender]
REF_96(bool) -> REF_95[7]
TMP_307(bool) = REF_96 == True
CONDITION TMP_307""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_308(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
(getPetCardSeries(petId) == 13) || (getPetCardSeries(petId) == 14) || (getPetCardSeries(petId) == 15) || (getPetCardSeries(petId) == 16)

IRs:
TMP_309(uint8) = INTERNAL_CALL, MedalClaim.getPetCardSeries(uint64)(petId)
TMP_310(bool) = TMP_309 == 13
TMP_311(uint8) = INTERNAL_CALL, MedalClaim.getPetCardSeries(uint64)(petId)
TMP_312(bool) = TMP_311 == 14
TMP_313(bool) = TMP_310 || TMP_312
TMP_314(uint8) = INTERNAL_CALL, MedalClaim.getPetCardSeries(uint64)(petId)
TMP_315(bool) = TMP_314 == 15
TMP_316(bool) = TMP_313 || TMP_315
TMP_317(uint8) = INTERNAL_CALL, MedalClaim.getPetCardSeries(uint64)(petId)
TMP_318(bool) = TMP_317 == 16
TMP_319(bool) = TMP_316 || TMP_318
CONDITION TMP_319""];
4->5[label=""True""];
4->11[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
(checkExistsOwnedPet(petId) == true)

IRs:
TMP_320(bool) = INTERNAL_CALL, MedalClaim.checkExistsOwnedPet(uint64)(petId)
TMP_321(bool) = TMP_320 == True
CONDITION TMP_321""];
5->6[label=""True""];
5->10[label=""False""];
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
medalData = IMedalData(medalDataContract)

IRs:
TMP_322 = CONVERT medalDataContract to IMedalData
medalData(IMedalData) := TMP_322(IMedalData)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
claimedbyAddress[msg.sender][7] = true

IRs:
REF_97(bool[12]) -> claimedbyAddress[msg.sender]
REF_98(bool) -> REF_97[7]
REF_98(bool) (->claimedbyAddress) := True(bool)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
medalData._createMedal(msg.sender,7)

IRs:
HIGH_LEVEL_CALL, dest:medalData(IMedalData), function:_createMedal, arguments:['msg.sender', '7']  ""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
EventMedalSuccessful(msg.sender,7)

IRs:
Emit EventMedalSuccessful(msg.sender,7)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: END_IF 11
""];
}
",1,0,0,0,"claimedbyAddress[msg.sender][7] == true;revert()();;(getPetCardSeries(petId) == 13) || (getPetCardSeries(petId) == 14) || (getPetCardSeries(petId) == 15) || (getPetCardSeries(petId) == 16);(checkExistsOwnedPet(petId) == true);;medalData = IMedalData(medalDataContract);;claimedbyAddress[msg.sender][7] = true;medalData._createMedal(msg.sender,7);EventMedalSuccessful(msg.sender,7)"
./0xc710772a16fd040ed9c63de0679a57410981e3fc_ext.sol,TokenVault.withdrawTokenTo,28,35,"TMP_3(uint256) = INTERNAL_CALL, TokenVault.balanceOfToken(address)(token),amount(uint256) := TMP_3(uint256),TMP_4(bool) = amount > 0,CONDITION TMP_4,Emit TokenTransfer(to,token,amount),TMP_6 = CONVERT token to Token,TMP_7(bool) = HIGH_LEVEL_CALL, dest:TMP_6(Token), function:transfer, arguments:['to', 'amount']  ,RETURN TMP_7,RETURN False,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
amount = balanceOfToken(token)

IRs:
TMP_3(uint256) = INTERNAL_CALL, TokenVault.balanceOfToken(address)(token)
amount(uint256) := TMP_3(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
amount > 0

IRs:
TMP_4(bool) = amount > 0
CONDITION TMP_4""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
TokenTransfer(to,token,amount)

IRs:
Emit TokenTransfer(to,token,amount)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
Token(token).transfer(to,amount)

IRs:
TMP_6 = CONVERT token to Token
TMP_7(bool) = HIGH_LEVEL_CALL, dest:TMP_6(Token), function:transfer, arguments:['to', 'amount']  
RETURN TMP_7""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->1;
}
",1,0,0,0,"onlyOwner();amount = balanceOfToken(token);amount > 0;TokenTransfer(to,token,amount);;Token(token).transfer(to,amount);false"
./0xeb36a7650ef32f0643d39cf5b7fcefd4319febb9_ext.sol,Arbitration.openDispute,779,794,"TMP_332 = CONVERT _icoRoundAddress to Cycle,icoRound(Cycle) := TMP_332(Cycle),TMP_333(uint256) = HIGH_LEVEL_CALL, dest:icoRound(Cycle), function:currentMilestone, arguments:[]  ,milestoneDispute(uint256) := TMP_333(uint256),TMP_334(bool) = milestoneDispute > 0,TMP_335(None) = SOLIDITY_CALL require(bool)(TMP_334),TMP_336(bool) = HIGH_LEVEL_CALL, dest:icoRound(Cycle), function:investorExists, arguments:['msg.sender']  ,TMP_337(bool) = TMP_336 == True,TMP_338(None) = SOLIDITY_CALL require(bool)(TMP_337),REF_344(Arbitration.Dispute) -> disputes[disputeLength],REF_345(uint256) -> REF_344.milestone,REF_345(uint256) (->disputes) := milestoneDispute(uint256),REF_346(Arbitration.Dispute) -> disputes[disputeLength],REF_347(address) -> REF_346.icoRoundAddress,REF_347(address) (->disputes) := _icoRoundAddress(address),REF_348(Arbitration.Dispute) -> disputes[disputeLength],REF_349(address) -> REF_348.investorAddress,REF_349(address) (->disputes) := msg.sender(address),REF_350(Arbitration.Dispute) -> disputes[disputeLength],REF_351(uint256) -> REF_350.timestamp,REF_351(uint256) (->disputes) := now(uint256),REF_352(Arbitration.Dispute) -> disputes[disputeLength],REF_353(string) -> REF_352.reason,REF_353(string) (->disputes) := _reason(string),REF_354(Arbitration.Dispute) -> disputes[disputeLength],REF_355(bool) -> REF_354.pending,REF_355(bool) (->disputes) := True(bool),HIGH_LEVEL_CALL, dest:icoRound(Cycle), function:disputeOpened, arguments:['msg.sender']  ,disputeLength(uint256) = disputeLength + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
icoRound = Cycle(_icoRoundAddress)

IRs:
TMP_332 = CONVERT _icoRoundAddress to Cycle
icoRound(Cycle) := TMP_332(Cycle)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
milestoneDispute = icoRound.currentMilestone()

IRs:
TMP_333(uint256) = HIGH_LEVEL_CALL, dest:icoRound(Cycle), function:currentMilestone, arguments:[]  
milestoneDispute(uint256) := TMP_333(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(milestoneDispute > 0)

IRs:
TMP_334(bool) = milestoneDispute > 0
TMP_335(None) = SOLIDITY_CALL require(bool)(TMP_334)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(icoRound.investorExists(msg.sender) == true)

IRs:
TMP_336(bool) = HIGH_LEVEL_CALL, dest:icoRound(Cycle), function:investorExists, arguments:['msg.sender']  
TMP_337(bool) = TMP_336 == True
TMP_338(None) = SOLIDITY_CALL require(bool)(TMP_337)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
disputes[disputeLength].milestone = milestoneDispute

IRs:
REF_344(Arbitration.Dispute) -> disputes[disputeLength]
REF_345(uint256) -> REF_344.milestone
REF_345(uint256) (->disputes) := milestoneDispute(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
disputes[disputeLength].icoRoundAddress = _icoRoundAddress

IRs:
REF_346(Arbitration.Dispute) -> disputes[disputeLength]
REF_347(address) -> REF_346.icoRoundAddress
REF_347(address) (->disputes) := _icoRoundAddress(address)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
disputes[disputeLength].investorAddress = msg.sender

IRs:
REF_348(Arbitration.Dispute) -> disputes[disputeLength]
REF_349(address) -> REF_348.investorAddress
REF_349(address) (->disputes) := msg.sender(address)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
disputes[disputeLength].timestamp = now

IRs:
REF_350(Arbitration.Dispute) -> disputes[disputeLength]
REF_351(uint256) -> REF_350.timestamp
REF_351(uint256) (->disputes) := now(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
disputes[disputeLength].reason = _reason

IRs:
REF_352(Arbitration.Dispute) -> disputes[disputeLength]
REF_353(string) -> REF_352.reason
REF_353(string) (->disputes) := _reason(string)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
disputes[disputeLength].pending = true

IRs:
REF_354(Arbitration.Dispute) -> disputes[disputeLength]
REF_355(bool) -> REF_354.pending
REF_355(bool) (->disputes) := True(bool)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
icoRound.disputeOpened(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:icoRound(Cycle), function:disputeOpened, arguments:['msg.sender']  ""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
disputeLength += 1

IRs:
disputeLength(uint256) = disputeLength + 1""];
}
",1,0,0,0,icoRound = Cycle(_icoRoundAddress);milestoneDispute = icoRound.currentMilestone();require(bool)(milestoneDispute > 0);require(bool)(icoRound.investorExists(msg.sender) == true);disputes[disputeLength].milestone = milestoneDispute;disputes[disputeLength].icoRoundAddress = _icoRoundAddress;disputes[disputeLength].investorAddress = msg.sender;disputes[disputeLength].timestamp = now;disputes[disputeLength].reason = _reason;disputes[disputeLength].pending = true;icoRound.disputeOpened(msg.sender);disputeLength += 1
./0x359a46571d4bc22a6a9310038b51e2d91163412f_ext.sol,TokenSale.allocateServusTokens,794,798,"TMP_227 = UnaryType.BANG servusTokensAllocated ,TMP_228(None) = SOLIDITY_CALL require(bool)(TMP_227),TMP_229(bool) = HIGH_LEVEL_CALL, dest:servusToken(ServusTokenInterface), function:mint, arguments:['servusMultiSig', 'TOKENS_ALLOCATED_TO_SERVUS']  ,servusTokensAllocated(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, TokenSale.whenNotFinalized()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! servusTokensAllocated)

IRs:
TMP_227 = UnaryType.BANG servusTokensAllocated 
TMP_228(None) = SOLIDITY_CALL require(bool)(TMP_227)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
servusToken.mint(servusMultiSig,TOKENS_ALLOCATED_TO_SERVUS)

IRs:
TMP_229(bool) = HIGH_LEVEL_CALL, dest:servusToken(ServusTokenInterface), function:mint, arguments:['servusMultiSig', 'TOKENS_ALLOCATED_TO_SERVUS']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
servusTokensAllocated = true

IRs:
servusTokensAllocated(bool) := True(bool)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
whenNotFinalized()

IRs:
MODIFIER_CALL, TokenSale.whenNotFinalized()()""];
5->1;
}
",1,0,0,0,"onlyOwner();require(bool)(! servusTokensAllocated);servusToken.mint(servusMultiSig,TOKENS_ALLOCATED_TO_SERVUS);servusTokensAllocated = true;whenNotFinalized()"
./0x74f887f5b336704be1591f8a2f2e419767134316_ext.sol,ERC20.transferFrom,184,188,"INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from,to,value),REF_3(mapping(address => uint256)) -> _allowed[from],REF_4(uint256) -> REF_3[msg.sender],TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_4', 'value'] ,INTERNAL_CALL, ERC20._approve(address,address,uint256)(from,msg.sender,TMP_16),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_transfer(from,to,value)

IRs:
INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from,to,value)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_approve(from,msg.sender,_allowed[from][msg.sender].sub(value))

IRs:
REF_3(mapping(address => uint256)) -> _allowed[from]
REF_4(uint256) -> REF_3[msg.sender]
TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_4', 'value'] 
INTERNAL_CALL, ERC20._approve(address,address,uint256)(from,msg.sender,TMP_16)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,"_transfer(from,to,value);_approve(from,msg.sender,_allowed[from][msg.sender].sub(value));true"
./0x33b7a018934c6e90fd63189d7c4517f0f776142f_ext.sol,ChronoBankAssetProxy.purgeUpgrade,447,454,"TMP_44(bool) = pendingVersion == 0,CONDITION TMP_44,RETURN False,pendingVersion = delete pendingVersion ,pendingVersionTimestamp = delete pendingVersionTimestamp ,RETURN True,MODIFIER_CALL, ChronoBankAssetProxy.onlyAssetOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: IF 1

EXPRESSION:
pendingVersion == 0x0

IRs:
TMP_44(bool) = pendingVersion == 0
CONDITION TMP_44""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
delete pendingVersion

IRs:
pendingVersion = delete pendingVersion ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete pendingVersionTimestamp

IRs:
pendingVersionTimestamp = delete pendingVersionTimestamp ""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyAssetOwner()

IRs:
MODIFIER_CALL, ChronoBankAssetProxy.onlyAssetOwner()()""];
7->1;
}
",1,0,0,0,onlyAssetOwner();pendingVersion == 0x0;false;;delete pendingVersion;delete pendingVersionTimestamp;true
./0xb4a3fb248d39370c1f8081b73fa7098167c8142b_ext.sol,DSValue.void,466,468,"has(bool) := False(bool),MODIFIER_CALL, DSNote.note()(),MODIFIER_CALL, DSAuth.auth()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
has = false

IRs:
has(bool) := False(bool)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
note()

IRs:
MODIFIER_CALL, DSNote.note()()""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
3->1;
}
",1,0,0,0,note();has = false;auth()
./0x4c13184721de2d1b47a8875775ba3ce0b2e00ee0_ext.sol,SharkPool.mine,258,295,"TMP_58(uint256) = INTERNAL_CALL, SharkPool.current_external_block()(),TMP_59(uint256) = INTERNAL_CALL, SharkPool.external_to_internal_block_number(uint256)(TMP_58),_blockNum(uint256) := TMP_59(uint256),TMP_60(bool) = HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:checkMiningAttempt, arguments:['_blockNum', 'this']  ,TMP_61 = UnaryType.BANG TMP_60 ,TMP_62(None) = SOLIDITY_CALL require(bool)(TMP_61),total_attempt(uint256) := 0(uint256),total_ejected(uint8) := 0(uint256),i(uint8) := 0(uint256),TMP_63(bool) = i < total_users,CONDITION TMP_63,REF_36(address) -> active_users[i],user_address(address) := REF_36(address),TMP_64(bool) = user_address > 0,CONDITION TMP_64,REF_37(SharkPool.user) -> users[user_address],u(SharkPool.user) := REF_37(SharkPool.user),REF_38(uint256) -> u.end_block,TMP_65(bool) = REF_38 <= mined_blocks,CONDITION TMP_65,TMP_66(bool) = total_ejected < 10,CONDITION TMP_66,REF_39(address) -> active_users[i],active_users = delete REF_39 ,REF_41 -> LENGTH slots,TMP_68(uint256) := REF_41(uint256),TMP_69(uint256) = TMP_68 + 1,REF_41(uint256) (->slots) := TMP_69(uint256),REF_42(uint8) -> slots[TMP_68],REF_42(uint8) (->slots) := i(uint8),REF_43(address) -> active_users[i],REF_44(SharkPool.user) -> users[REF_43],users = delete REF_44 ,TMP_70(uint8) = total_ejected + 1,total_ejected(uint8) := TMP_70(uint8),REF_45(uint256) -> u.proportional_contribution,TMP_71(uint256) = total_attempt + REF_45,total_attempt(uint256) := TMP_71(uint256),TMP_72(uint8) := i(uint8),i(uint8) = i + 1,TMP_73(bool) = total_attempt > 0,CONDITION TMP_73,REF_46(uint256) -> attempts[_blockNum],REF_46(uint256) (->attempts) := total_attempt(uint256),HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:mine, arguments:[] value:total_attempt ,TMP_76(uint256) = mined_blocks + 1,mined_blocks(uint256) := TMP_76(uint256),MODIFIER_CALL, ReentrancyGuard.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->28;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_blockNum = external_to_internal_block_number(current_external_block())

IRs:
TMP_58(uint256) = INTERNAL_CALL, SharkPool.current_external_block()()
TMP_59(uint256) = INTERNAL_CALL, SharkPool.external_to_internal_block_number(uint256)(TMP_58)
_blockNum(uint256) := TMP_59(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! base_contract.checkMiningAttempt(_blockNum,this))

IRs:
TMP_60(bool) = HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:checkMiningAttempt, arguments:['_blockNum', 'this']  
TMP_61 = UnaryType.BANG TMP_60 
TMP_62(None) = SOLIDITY_CALL require(bool)(TMP_61)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
total_attempt = 0

IRs:
total_attempt(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
total_ejected = 0

IRs:
total_ejected(uint8) := 0(uint256)""];
4->7;
5[label=""Node Type: BEGIN_LOOP 5
""];
5->8;
6[label=""Node Type: END_LOOP 6
""];
6->23;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)""];
7->5;
8[label=""Node Type: IF_LOOP 8

EXPRESSION:
i < total_users

IRs:
TMP_63(bool) = i < total_users
CONDITION TMP_63""];
8->9[label=""True""];
8->6[label=""False""];
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
user_address = active_users[i]

IRs:
REF_36(address) -> active_users[i]
user_address(address) := REF_36(address)""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
user_address > 0

IRs:
TMP_64(bool) = user_address > 0
CONDITION TMP_64""];
10->11[label=""True""];
10->21[label=""False""];
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
u = users[user_address]

IRs:
REF_37(SharkPool.user) -> users[user_address]
u(SharkPool.user) := REF_37(SharkPool.user)""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
u.end_block <= mined_blocks

IRs:
REF_38(uint256) -> u.end_block
TMP_65(bool) = REF_38 <= mined_blocks
CONDITION TMP_65""];
12->13[label=""True""];
12->19[label=""False""];
13[label=""Node Type: IF 13

EXPRESSION:
total_ejected < 10

IRs:
TMP_66(bool) = total_ejected < 10
CONDITION TMP_66""];
13->14[label=""True""];
13->18[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
delete active_users[i]

IRs:
REF_39(address) -> active_users[i]
active_users = delete REF_39 ""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
slots.push(i)

IRs:
REF_41 -> LENGTH slots
TMP_68(uint256) := REF_41(uint256)
TMP_69(uint256) = TMP_68 + 1
REF_41(uint256) (->slots) := TMP_69(uint256)
REF_42(uint8) -> slots[TMP_68]
REF_42(uint8) (->slots) := i(uint8)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
delete users[active_users[i]]

IRs:
REF_43(address) -> active_users[i]
REF_44(SharkPool.user) -> users[REF_43]
users = delete REF_44 ""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
total_ejected = total_ejected + 1

IRs:
TMP_70(uint8) = total_ejected + 1
total_ejected(uint8) := TMP_70(uint8)""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->20;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
total_attempt = total_attempt + u.proportional_contribution

IRs:
REF_45(uint256) -> u.proportional_contribution
TMP_71(uint256) = total_attempt + REF_45
total_attempt(uint256) := TMP_71(uint256)""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: END_IF 21
""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
i ++

IRs:
TMP_72(uint8) := i(uint8)
i(uint8) = i + 1""];
22->8;
23[label=""Node Type: IF 23

EXPRESSION:
total_attempt > 0

IRs:
TMP_73(bool) = total_attempt > 0
CONDITION TMP_73""];
23->24[label=""True""];
23->27[label=""False""];
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
attempts[_blockNum] = total_attempt

IRs:
REF_46(uint256) -> attempts[_blockNum]
REF_46(uint256) (->attempts) := total_attempt(uint256)""];
24->25;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
base_contract.mine.value(total_attempt)()

IRs:
HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:mine, arguments:[] value:total_attempt ""];
25->26;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
mined_blocks = mined_blocks + 1

IRs:
TMP_76(uint256) = mined_blocks + 1
mined_blocks(uint256) := TMP_76(uint256)""];
26->27;
27[label=""Node Type: END_IF 27
""];
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, ReentrancyGuard.nonReentrant()()""];
28->1;
}
",1,0,0,0,"nonReentrant();_blockNum = external_to_internal_block_number(current_external_block());require(bool)(! base_contract.checkMiningAttempt(_blockNum,this));total_attempt = 0;total_ejected = 0;i = 0;;i < total_users;;total_attempt > 0;user_address = active_users[i];user_address > 0;u = users[user_address];;u.end_block <= mined_blocks;total_ejected < 10;total_attempt = total_attempt + u.proportional_contribution;delete active_users[i];;slots.push(i);delete users[active_users[i]];total_ejected = total_ejected + 1;;i ++;attempts[_blockNum] = total_attempt;;base_contract.mine.value(total_attempt)();mined_blocks = mined_blocks + 1"
./0x1d1811189e2a8dd8d5f22cdc164273bf3d6fdd43_ext.sol,BasicToken.transferToContract,184,195,"TMP_46(bool) = INTERNAL_CALL, BasicToken.isContract(address)(_to),TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46),REF_19(uint256) -> balances[msg.sender],TMP_48(bool) = _value <= REF_19,TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48),REF_20(uint256) -> balances[msg.sender],TMP_50(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(msg.sender),TMP_51(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_50', '_value'] ,REF_20(uint256) (->balances) := TMP_51(uint256),REF_22(uint256) -> balances[_to],TMP_52(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(_to),TMP_53(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_52', '_value'] ,REF_22(uint256) (->balances) := TMP_53(uint256),TMP_54 = CONVERT _to to NSPReceiver,receiver(NSPReceiver) := TMP_54(NSPReceiver),HIGH_LEVEL_CALL, dest:receiver(NSPReceiver), function:NSPFallback, arguments:['msg.sender', '_value', '_code']  ,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isContract(_to))

IRs:
TMP_46(bool) = INTERNAL_CALL, BasicToken.isContract(address)(_to)
TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_19(uint256) -> balances[msg.sender]
TMP_48(bool) = _value <= REF_19
TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balanceOf(msg.sender).sub(_value)

IRs:
REF_20(uint256) -> balances[msg.sender]
TMP_50(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(msg.sender)
TMP_51(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_50', '_value'] 
REF_20(uint256) (->balances) := TMP_51(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balanceOf(_to).add(_value)

IRs:
REF_22(uint256) -> balances[_to]
TMP_52(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(_to)
TMP_53(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_52', '_value'] 
REF_22(uint256) (->balances) := TMP_53(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
receiver = NSPReceiver(_to)

IRs:
TMP_54 = CONVERT _to to NSPReceiver
receiver(NSPReceiver) := TMP_54(NSPReceiver)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
receiver.NSPFallback(msg.sender,_value,_code)

IRs:
HIGH_LEVEL_CALL, dest:receiver(NSPReceiver), function:NSPFallback, arguments:['msg.sender', '_value', '_code']  ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,0,0,0,"require(bool)(isContract(_to));require(bool)(_value <= balances[msg.sender]);balances[msg.sender] = balanceOf(msg.sender).sub(_value);balances[_to] = balanceOf(_to).add(_value);receiver = NSPReceiver(_to);receiver.NSPFallback(msg.sender,_value,_code);Transfer(msg.sender,_to,_value);true;success"
./0x2791528f5617e187a6d73c30034ac211b2f47042_ext.sol,CardsRaffle.startRareRaffle,187,205,"TMP_58(bool) = rareId > 0,TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58),TMP_60(address) = HIGH_LEVEL_CALL, dest:rare(RareInterface), function:getRareItemsOwner, arguments:['rareId']  ,TMP_61(address) = INTERNAL_CALL, CardsRaffle.getRareAddress()(),TMP_62(bool) = TMP_60 == TMP_61,TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62),TMP_64(bool) = block.timestamp < endTime,TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64),TMP_66(bool) = raffleRareId != 0,CONDITION TMP_66,TMP_67(bool) = raffleWinner != 0,TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67),raffleWinningTicketSelected(bool) := False(bool),raffleTicketThatWon(uint256) := 0(uint256),raffleWinner(address) := 0(uint256),raffleTicketsBought(uint256) := 0(uint256),raffleEndTime(uint256) := endTime(uint256),raffleRareId(uint256) := rareId(uint256),MODIFIER_CALL, AccessAdmin.onlyAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->13;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(rareId > 0)

IRs:
TMP_58(bool) = rareId > 0
TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(rare.getRareItemsOwner(rareId) == getRareAddress())

IRs:
TMP_60(address) = HIGH_LEVEL_CALL, dest:rare(RareInterface), function:getRareItemsOwner, arguments:['rareId']  
TMP_61(address) = INTERNAL_CALL, CardsRaffle.getRareAddress()()
TMP_62(bool) = TMP_60 == TMP_61
TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(block.timestamp < endTime)

IRs:
TMP_64(bool) = block.timestamp < endTime
TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
raffleRareId != 0

IRs:
TMP_66(bool) = raffleRareId != 0
CONDITION TMP_66""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(raffleWinner != 0)

IRs:
TMP_67(bool) = raffleWinner != 0
TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
raffleWinningTicketSelected = false

IRs:
raffleWinningTicketSelected(bool) := False(bool)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
raffleTicketThatWon = 0

IRs:
raffleTicketThatWon(uint256) := 0(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
raffleWinner = 0

IRs:
raffleWinner(address) := 0(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
raffleTicketsBought = 0

IRs:
raffleTicketsBought(uint256) := 0(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
raffleEndTime = endTime

IRs:
raffleEndTime(uint256) := endTime(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
raffleRareId = rareId

IRs:
raffleRareId(uint256) := rareId(uint256)""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, AccessAdmin.onlyAdmin()()""];
13->1;
}
",1,0,0,0,onlyAdmin();require(bool)(rareId > 0);require(bool)(rare.getRareItemsOwner(rareId) == getRareAddress());require(bool)(block.timestamp < endTime);raffleRareId != 0;require(bool)(raffleWinner != 0);;raffleWinningTicketSelected = false;raffleTicketThatWon = 0;raffleWinner = 0;raffleTicketsBought = 0;raffleEndTime = endTime;raffleRareId = rareId
./0x4d7edd5f94515b0f35b38f6fb2ea975a20823465_ext.sol,CryptoSprites.removeSpriteFromSale,272,280,"REF_82(CryptoSprites.BroughtSprites) -> broughtSprites[spriteId],REF_83(address) -> REF_82.owner,TMP_122(bool) = REF_83 != msg.sender,CONDITION TMP_122,REF_84(CryptoSprites.BroughtSprites) -> broughtSprites[spriteId],REF_85(uint256) -> REF_84.timesTraded,TMP_123(bool) = REF_85 == 0,TMP_124(None) = SOLIDITY_CALL require(bool)(TMP_123),TMP_125 = CONVERT KittyCoreAddress to KittyCore,TMP_126(address) = HIGH_LEVEL_CALL, dest:TMP_125(KittyCore), function:ownerOf, arguments:['spriteId']  ,kittyOwner(address) := TMP_126(address),TMP_127(bool) = kittyOwner == msg.sender,TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127),REF_87(CryptoSprites.BroughtSprites) -> broughtSprites[spriteId],REF_88(uint256) -> REF_87.price,REF_88(uint256) (->broughtSprites) := 1(uint256),REF_89(CryptoSprites.BroughtSprites) -> broughtSprites[spriteId],REF_90(bool) -> REF_89.forSale,REF_90(bool) (->broughtSprites) := False(bool)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
broughtSprites[spriteId].owner != msg.sender

IRs:
REF_82(CryptoSprites.BroughtSprites) -> broughtSprites[spriteId]
REF_83(address) -> REF_82.owner
TMP_122(bool) = REF_83 != msg.sender
CONDITION TMP_122""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(broughtSprites[spriteId].timesTraded == 0)

IRs:
REF_84(CryptoSprites.BroughtSprites) -> broughtSprites[spriteId]
REF_85(uint256) -> REF_84.timesTraded
TMP_123(bool) = REF_85 == 0
TMP_124(None) = SOLIDITY_CALL require(bool)(TMP_123)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
kittyOwner = KittyCore(KittyCoreAddress).ownerOf(spriteId)

IRs:
TMP_125 = CONVERT KittyCoreAddress to KittyCore
TMP_126(address) = HIGH_LEVEL_CALL, dest:TMP_125(KittyCore), function:ownerOf, arguments:['spriteId']  
kittyOwner(address) := TMP_126(address)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(kittyOwner == msg.sender)

IRs:
TMP_127(bool) = kittyOwner == msg.sender
TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
broughtSprites[spriteId].price = 1

IRs:
REF_87(CryptoSprites.BroughtSprites) -> broughtSprites[spriteId]
REF_88(uint256) -> REF_87.price
REF_88(uint256) (->broughtSprites) := 1(uint256)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
broughtSprites[spriteId].forSale = false

IRs:
REF_89(CryptoSprites.BroughtSprites) -> broughtSprites[spriteId]
REF_90(bool) -> REF_89.forSale
REF_90(bool) (->broughtSprites) := False(bool)""];
}
",1,0,0,0,broughtSprites[spriteId].owner != msg.sender;require(bool)(broughtSprites[spriteId].timesTraded == 0);;kittyOwner = KittyCore(KittyCoreAddress).ownerOf(spriteId);require(bool)(kittyOwner == msg.sender);broughtSprites[spriteId].price = 1;broughtSprites[spriteId].forSale = false
./0xb4a3fb248d39370c1f8081b73fa7098167c8142b_ext.sol,DSToken.setName,403,405,"name(bytes32) := name_(bytes32),MODIFIER_CALL, DSAuth.auth()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
name = name_

IRs:
name(bytes32) := name_(bytes32)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
2->1;
}
",1,0,0,0,auth();name = name_
./0x1a661224edc279a3844ecd8bd0cd715daafb9cf7_ext.sol,lockEtherPay.lock,87,93,"TMP_27 = UnaryType.BANG isLocked ,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),TMP_29(uint256) = INTERNAL_CALL, lockEtherPay.tokenBalance()(),TMP_30(bool) = TMP_29 > 0,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),start_time(uint256) := now(uint256),TMP_32(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['start_time', 'fifty_two_weeks'] ,end_time(uint256) := TMP_32(uint256),isLocked(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isLocked)

IRs:
TMP_27 = UnaryType.BANG isLocked 
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(tokenBalance() > 0)

IRs:
TMP_29(uint256) = INTERNAL_CALL, lockEtherPay.tokenBalance()()
TMP_30(bool) = TMP_29 > 0
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
start_time = now

IRs:
start_time(uint256) := now(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
end_time = start_time.add(fifty_two_weeks)

IRs:
TMP_32(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['start_time', 'fifty_two_weeks'] 
end_time(uint256) := TMP_32(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
isLocked = true

IRs:
isLocked(bool) := True(bool)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",1,0,0,0,onlyOwner();require(bool)(! isLocked);require(bool)(tokenBalance() > 0);start_time = now;end_time = start_time.add(fifty_two_weeks);isLocked = true
./0xd1569ffd7ca4393311f66110e6f87184c4817113_ext.sol,LudumAirdrop.sendLudumToMany,68,76,"i(uint256) := 0(uint256),REF_0 -> LENGTH dests,TMP_15(bool) = i < REF_0,CONDITION TMP_15,REF_1(uint256) -> values[i],toSend(uint256) := REF_1(uint256),REF_2(address) -> dests[i],REF_3(uint256) -> values[i],INTERNAL_CALL, LudumAirdrop.sendInternally(address,uint256,uint256)(REF_2,toSend,REF_3),TMP_17(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, LudumAirdrop.whenDropIsActive()(),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->3;
3[label=""Node Type: IF_LOOP 3

EXPRESSION:
i < dests.length

IRs:
REF_0 -> LENGTH dests
TMP_15(bool) = i < REF_0
CONDITION TMP_15""];
3->4[label=""True""];
3->7[label=""False""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
toSend = values[i]

IRs:
REF_1(uint256) -> values[i]
toSend(uint256) := REF_1(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
sendInternally(dests[i],toSend,values[i])

IRs:
REF_2(address) -> dests[i]
REF_3(uint256) -> values[i]
INTERNAL_CALL, LudumAirdrop.sendInternally(address,uint256,uint256)(REF_2,toSend,REF_3)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_17(uint256) := i(uint256)
i(uint256) = i + 1""];
6->3;
7[label=""Node Type: END_LOOP 7
""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
whenDropIsActive()

IRs:
MODIFIER_CALL, LudumAirdrop.whenDropIsActive()()""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
9->1;
}
",1,0,0,0,"whenDropIsActive();i = 0;;i < dests.length;toSend = values[i];;sendInternally(dests[i],toSend,values[i]);i ++;onlyOwner()"
./0xb4a3fb248d39370c1f8081b73fa7098167c8142b_ext.sol,DSStop.start,218,220,"stopped(bool) := False(bool),MODIFIER_CALL, DSAuth.auth()(),MODIFIER_CALL, DSNote.note()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
stopped = false

IRs:
stopped(bool) := False(bool)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
note()

IRs:
MODIFIER_CALL, DSNote.note()()""];
3->1;
}
",1,0,0,0,auth();stopped = false;note()
./0x5c89736e9454200141b80c37eb28eaceca2ce8cb_ext.sol,CherryToken.transferdata,274,285,"TMP_131(bool) = _value > 0,TMP_132(None) = SOLIDITY_CALL require(bool)(TMP_131),TMP_133(bool) = INTERNAL_CALL, CherryToken.isContract(address)(_to),CONDITION TMP_133,TMP_134 = CONVERT _to to ERC223ReceivingContract,receiver(ERC223ReceivingContract) := TMP_134(ERC223ReceivingContract),HIGH_LEVEL_CALL, dest:receiver(ERC223ReceivingContract), function:tokenFallback, arguments:['msg.sender', '_value', '_data']  ,REF_110(uint256) -> balances[msg.sender],REF_111(uint256) -> balances[msg.sender],TMP_136(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_111', '_value'] ,REF_110(uint256) (->balances) := TMP_136(uint256),REF_113(uint256) -> balances[_to],REF_114(uint256) -> balances[_to],TMP_137(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_114', '_value'] ,REF_113(uint256) (->balances) := TMP_137(uint256),Emit Transferdata(msg.sender,_to,_value,_data)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_131(bool) = _value > 0
TMP_132(None) = SOLIDITY_CALL require(bool)(TMP_131)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
isContract(_to)

IRs:
TMP_133(bool) = INTERNAL_CALL, CherryToken.isContract(address)(_to)
CONDITION TMP_133""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
receiver = ERC223ReceivingContract(_to)

IRs:
TMP_134 = CONVERT _to to ERC223ReceivingContract
receiver(ERC223ReceivingContract) := TMP_134(ERC223ReceivingContract)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
receiver.tokenFallback(msg.sender,_value,_data)

IRs:
HIGH_LEVEL_CALL, dest:receiver(ERC223ReceivingContract), function:tokenFallback, arguments:['msg.sender', '_value', '_data']  ""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_110(uint256) -> balances[msg.sender]
REF_111(uint256) -> balances[msg.sender]
TMP_136(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_111', '_value'] 
REF_110(uint256) (->balances) := TMP_136(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_113(uint256) -> balances[_to]
REF_114(uint256) -> balances[_to]
TMP_137(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_114', '_value'] 
REF_113(uint256) (->balances) := TMP_137(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transferdata(msg.sender,_to,_value,_data)

IRs:
Emit Transferdata(msg.sender,_to,_value,_data)""];
}
",1,1,0,0,"require(bool)(_value > 0);isContract(_to);receiver = ERC223ReceivingContract(_to);;receiver.tokenFallback(msg.sender,_value,_data);balances[msg.sender] = balances[msg.sender].sub(_value);balances[_to] = balances[_to].add(_value);Transferdata(msg.sender,_to,_value,_data)"
./0xec841c878435ba4f28bf305a00c1483db0d96a20_ext.sol,Events.escrow,285,289,"TMP_64(bytes) = SOLIDITY_CALL abi.encodePacked()(_message),TMP_65(bytes32) = SOLIDITY_CALL keccak256()(TMP_64),Emit LogEscrow(_message,TMP_65,_assetAddress,_escrowID,_manager,_amount,tx.origin),MODIFIER_CALL, Events.onlyApprovedContract()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
LogEscrow(_message,keccak256()(abi.encodePacked(_message)),_assetAddress,_escrowID,_manager,_amount,tx.origin)

IRs:
TMP_64(bytes) = SOLIDITY_CALL abi.encodePacked()(_message)
TMP_65(bytes32) = SOLIDITY_CALL keccak256()(TMP_64)
Emit LogEscrow(_message,TMP_65,_assetAddress,_escrowID,_manager,_amount,tx.origin)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyApprovedContract()

IRs:
MODIFIER_CALL, Events.onlyApprovedContract()()""];
2->1;
}
",1,0,0,0,"onlyApprovedContract();LogEscrow(_message,keccak256()(abi.encodePacked(_message)),_assetAddress,_escrowID,_manager,_amount,tx.origin)"
./0x17a03553719001e05dc19a20f5e82ee76923a985_ext.sol,Auction.bid,573,580,"TMP_132(uint256) = INTERNAL_CALL, AuctionBase._bid(uint256,uint256)(_tokenId,msg.value),INTERNAL_CALL, AuctionBase._transfer(address,uint256)(msg.sender,_tokenId),MODIFIER_CALL, Pausable.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_bid(_tokenId,msg.value)

IRs:
TMP_132(uint256) = INTERNAL_CALL, AuctionBase._bid(uint256,uint256)(_tokenId,msg.value)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_transfer(msg.sender,_tokenId)

IRs:
INTERNAL_CALL, AuctionBase._transfer(address,uint256)(msg.sender,_tokenId)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
3->1;
}
",1,0,0,0,"whenNotPaused();_bid(_tokenId,msg.value);_transfer(msg.sender,_tokenId)"
./0x4b958074cee6546e29cdb3c43494e7425b85f59c_ext.sol,Crowdsale.buyTokens,465,488,"weiAmount(uint256) := msg.value(uint256),INTERNAL_CALL, Crowdsale._preValidatePurchase(address,uint256)(_beneficiary,weiAmount),TMP_236(uint256) = INTERNAL_CALL, Crowdsale._getTokenAmount(uint256)(weiAmount),tokens(uint256) := TMP_236(uint256),TMP_237(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] ,weiRaised(uint256) := TMP_237(uint256),INTERNAL_CALL, Crowdsale._processPurchase(address,uint256)(_beneficiary,tokens),Emit TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens),INTERNAL_CALL, Crowdsale._updatePurchasingState(address,uint256)(_beneficiary,weiAmount),INTERNAL_CALL, Crowdsale._forwardFunds()(),INTERNAL_CALL, Crowdsale._postValidatePurchase(address,uint256)(_beneficiary,weiAmount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_preValidatePurchase(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._preValidatePurchase(address,uint256)(_beneficiary,weiAmount)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
tokens = _getTokenAmount(weiAmount)

IRs:
TMP_236(uint256) = INTERNAL_CALL, Crowdsale._getTokenAmount(uint256)(weiAmount)
tokens(uint256) := TMP_236(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_237(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_237(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_processPurchase(_beneficiary,tokens)

IRs:
INTERNAL_CALL, Crowdsale._processPurchase(address,uint256)(_beneficiary,tokens)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
_updatePurchasingState(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._updatePurchasingState(address,uint256)(_beneficiary,weiAmount)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
_forwardFunds()

IRs:
INTERNAL_CALL, Crowdsale._forwardFunds()()""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
_postValidatePurchase(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._postValidatePurchase(address,uint256)(_beneficiary,weiAmount)""];
}
",1,0,0,0,"weiAmount = msg.value;_preValidatePurchase(_beneficiary,weiAmount);tokens = _getTokenAmount(weiAmount);weiRaised = weiRaised.add(weiAmount);_processPurchase(_beneficiary,tokens);TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens);_updatePurchasingState(_beneficiary,weiAmount);_forwardFunds();_postValidatePurchase(_beneficiary,weiAmount)"
./0xb4a3fb248d39370c1f8081b73fa7098167c8142b_ext.sol,DSToken.mint,379,381,"INTERNAL_CALL, DSToken.mint(address,uint256)(msg.sender,wad)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
mint(msg.sender,wad)

IRs:
INTERNAL_CALL, DSToken.mint(address,uint256)(msg.sender,wad)""];
}
",1,0,0,0,"mint(msg.sender,wad)"
./0x78a06472d78bfef33270654319b6373d51cf0575_ext.sol,EasyMineTokenWallet.withdraw,180,199,"TMP_59(uint256) = INTERNAL_CALL, EasyMineTokenWallet.maxPossibleWithdrawal()(),limit(uint256) := TMP_59(uint256),withdrawalAmount(uint256) := requestedAmount(uint256),TMP_60(bool) = requestedAmount > limit,CONDITION TMP_60,withdrawalAmount(uint256) := limit(uint256),TMP_61(bool) = withdrawalAmount > 0,CONDITION TMP_61,TMP_62(bool) = HIGH_LEVEL_CALL, dest:easyMineToken(Token), function:transfer, arguments:['withdrawalAddress', 'withdrawalAmount']  ,TMP_63 = UnaryType.BANG TMP_62 ,CONDITION TMP_63,TMP_64(None) = SOLIDITY_CALL revert()(),totalWithdrawn(uint256) = totalWithdrawn + withdrawalAmount,RETURN withdrawalAmount,MODIFIER_CALL, EasyMineTokenWallet.isOwner()(),RETURN amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->13;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
limit = maxPossibleWithdrawal()

IRs:
TMP_59(uint256) = INTERNAL_CALL, EasyMineTokenWallet.maxPossibleWithdrawal()()
limit(uint256) := TMP_59(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
withdrawalAmount = requestedAmount

IRs:
withdrawalAmount(uint256) := requestedAmount(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
requestedAmount > limit

IRs:
TMP_60(bool) = requestedAmount > limit
CONDITION TMP_60""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
withdrawalAmount = limit

IRs:
withdrawalAmount(uint256) := limit(uint256)""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
withdrawalAmount > 0

IRs:
TMP_61(bool) = withdrawalAmount > 0
CONDITION TMP_61""];
6->7[label=""True""];
6->11[label=""False""];
7[label=""Node Type: IF 7

EXPRESSION:
! easyMineToken.transfer(withdrawalAddress,withdrawalAmount)

IRs:
TMP_62(bool) = HIGH_LEVEL_CALL, dest:easyMineToken(Token), function:transfer, arguments:['withdrawalAddress', 'withdrawalAmount']  
TMP_63 = UnaryType.BANG TMP_62 
CONDITION TMP_63""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
revert()()

IRs:
TMP_64(None) = SOLIDITY_CALL revert()()""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
totalWithdrawn += withdrawalAmount

IRs:
totalWithdrawn(uint256) = totalWithdrawn + withdrawalAmount""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: RETURN 12

EXPRESSION:
withdrawalAmount

IRs:
RETURN withdrawalAmount""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
isOwner()

IRs:
MODIFIER_CALL, EasyMineTokenWallet.isOwner()()""];
13->1;
14[label=""Node Type: RETURN 14

EXPRESSION:
amount

IRs:
RETURN amount""];
}
",1,0,0,0,"isOwner();limit = maxPossibleWithdrawal();withdrawalAmount = requestedAmount;requestedAmount > limit;withdrawalAmount = limit;;withdrawalAmount > 0;! easyMineToken.transfer(withdrawalAddress,withdrawalAmount);;revert()();;totalWithdrawn += withdrawalAmount;withdrawalAmount;amount"
./0x18f0cd26c06449d967ca6aef8b5f9d8ee9fd7992_ext.sol,Exch.withdraw,160,165,"REF_25(mapping(address => uint256)) -> tokens[0],REF_26(uint256) -> REF_25[msg.sender],TMP_59(bool) = REF_26 < amount,CONDITION TMP_59,TMP_60(None) = SOLIDITY_CALL revert()(),REF_27(mapping(address => uint256)) -> tokens[0],REF_28(uint256) -> REF_27[msg.sender],REF_29(mapping(address => uint256)) -> tokens[0],REF_30(uint256) -> REF_29[msg.sender],TMP_61(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_30,amount),REF_28(uint256) (->tokens) := TMP_61(uint256),Transfer dest:msg.sender value:amount,REF_32(mapping(address => uint256)) -> tokens[0],REF_33(uint256) -> REF_32[msg.sender],Emit Withdraw(0,msg.sender,amount,REF_33)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
tokens[0][msg.sender] < amount

IRs:
REF_25(mapping(address => uint256)) -> tokens[0]
REF_26(uint256) -> REF_25[msg.sender]
TMP_59(bool) = REF_26 < amount
CONDITION TMP_59""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_60(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender],amount)

IRs:
REF_27(mapping(address => uint256)) -> tokens[0]
REF_28(uint256) -> REF_27[msg.sender]
REF_29(mapping(address => uint256)) -> tokens[0]
REF_30(uint256) -> REF_29[msg.sender]
TMP_61(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_30,amount)
REF_28(uint256) (->tokens) := TMP_61(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Withdraw(0,msg.sender,amount,tokens[0][msg.sender])

IRs:
REF_32(mapping(address => uint256)) -> tokens[0]
REF_33(uint256) -> REF_32[msg.sender]
Emit Withdraw(0,msg.sender,amount,REF_33)""];
}
",1,0,0,0,"tokens[0][msg.sender] < amount;revert()();;tokens[0][msg.sender] = safeSub(tokens[0][msg.sender],amount);msg.sender.transfer(amount);Withdraw(0,msg.sender,amount,tokens[0][msg.sender])"
./0x750c1d91864171d7e1715a6b53ee28c72b8faa09_ext.sol,EthicHubUser.unregisterPaymentGateway,266,275,"TMP_125 = CONVERT 0 to address,TMP_126(bool) = target != TMP_125,TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126),TMP_128(bytes32) = SOLIDITY_CALL keccak256()(user,paymentGateway,target),TMP_129(bool) = HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:getBool, arguments:['TMP_128']  ,isRegistered(bool) := TMP_129(bool),CONDITION isRegistered,INTERNAL_CALL, EthicHubUser.deleteUserStatus(address,string)(target,paymentGateway),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(target != address(0))

IRs:
TMP_125 = CONVERT 0 to address
TMP_126(bool) = target != TMP_125
TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
isRegistered = ethicHubStorage.getBool(keccak256()(user,paymentGateway,target))

IRs:
TMP_128(bytes32) = SOLIDITY_CALL keccak256()(user,paymentGateway,target)
TMP_129(bool) = HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:getBool, arguments:['TMP_128']  
isRegistered(bool) := TMP_129(bool)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
isRegistered

IRs:
CONDITION isRegistered""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
deleteUserStatus(target,paymentGateway)

IRs:
INTERNAL_CALL, EthicHubUser.deleteUserStatus(address,string)(target,paymentGateway)""];
4->5;
5[label=""Node Type: END_IF 5
""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",1,0,0,0,"onlyOwner();require(bool)(target != address(0));isRegistered = ethicHubStorage.getBool(keccak256()(user,paymentGateway,target));isRegistered;deleteUserStatus(target,paymentGateway);"
./0xef86db910c71ffa3c80233bc9108dc51ad1e008a_ext.sol,CommonWallet.sendTokenTo,74,80,"REF_24(mapping(address => uint256)) -> tokenBalance[tokenAddr],REF_25(uint256) -> REF_24[msg.sender],TMP_24(bool) = REF_25 >= amount,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),TMP_26 = CONVERT tokenAddr to ERC20Token,TMP_27(bool) = HIGH_LEVEL_CALL, dest:TMP_26(ERC20Token), function:transfer, arguments:['to_', 'amount']  ,CONDITION TMP_27,REF_27(mapping(address => uint256)) -> tokenBalance[tokenAddr],REF_28(uint256) -> REF_27[msg.sender],REF_29(mapping(address => uint256)) -> tokenBalance[tokenAddr],REF_30(uint256) -> REF_29[msg.sender],TMP_28(uint256) = INTERNAL_CALL, CommonWallet.safeSub(uint256,uint256)(REF_30,amount),REF_28(uint256) (->tokenBalance) := TMP_28(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(tokenBalance[tokenAddr][msg.sender] >= amount)

IRs:
REF_24(mapping(address => uint256)) -> tokenBalance[tokenAddr]
REF_25(uint256) -> REF_24[msg.sender]
TMP_24(bool) = REF_25 >= amount
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
ERC20Token(tokenAddr).transfer(to_,amount)

IRs:
TMP_26 = CONVERT tokenAddr to ERC20Token
TMP_27(bool) = HIGH_LEVEL_CALL, dest:TMP_26(ERC20Token), function:transfer, arguments:['to_', 'amount']  
CONDITION TMP_27""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tokenBalance[tokenAddr][msg.sender] = safeSub(tokenBalance[tokenAddr][msg.sender],amount)

IRs:
REF_27(mapping(address => uint256)) -> tokenBalance[tokenAddr]
REF_28(uint256) -> REF_27[msg.sender]
REF_29(mapping(address => uint256)) -> tokenBalance[tokenAddr]
REF_30(uint256) -> REF_29[msg.sender]
TMP_28(uint256) = INTERNAL_CALL, CommonWallet.safeSub(uint256,uint256)(REF_30,amount)
REF_28(uint256) (->tokenBalance) := TMP_28(uint256)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",1,0,0,0,"require(bool)(tokenBalance[tokenAddr][msg.sender] >= amount);ERC20Token(tokenAddr).transfer(to_,amount);tokenBalance[tokenAddr][msg.sender] = safeSub(tokenBalance[tokenAddr][msg.sender],amount);"
./0x70cdbd16575651e3b78fa869a51eb8e991e079bb_ext.sol,PRVTSToken.refundTokens,355,361,"TMP_111(bool) = msg.sender == owner,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113 = CONVERT this to address,TMP_114(bool) = _token != TMP_113,TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114),TMP_116 = CONVERT _token to AbstractToken,token(AbstractToken) := TMP_116(AbstractToken),TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ,Emit RefundTokens(_token,_refund,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_111(bool) = msg.sender == owner
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_113 = CONVERT this to address
TMP_114(bool) = _token != TMP_113
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
token = AbstractToken(_token)

IRs:
TMP_116 = CONVERT _token to AbstractToken
token(AbstractToken) := TMP_116(AbstractToken)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(_refund,_value)

IRs:
TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RefundTokens(_token,_refund,_value)

IRs:
Emit RefundTokens(_token,_refund,_value)""];
}
",1,0,0,0,"require(bool)(msg.sender == owner);require(bool)(_token != address(this));token = AbstractToken(_token);token.transfer(_refund,_value);RefundTokens(_token,_refund,_value)"
./0xc849a5fff9befa297d1c3a772bafac9f3c9004ec_ext.sol,Bounty0xEscrow.distributeTokenToAddressesAndAmountsWithoutHost,234,253,"REF_55 -> LENGTH _hunters,REF_56 -> LENGTH _amounts,TMP_114(bool) = REF_55 == REF_56,TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114),totalAmount(uint256) := 0(uint256),j(uint256) := 0(uint256),REF_57 -> LENGTH _amounts,TMP_116(bool) = j < REF_57,CONDITION TMP_116,REF_59(uint256) -> _amounts[j],TMP_117(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalAmount', 'REF_59'] ,totalAmount(uint256) := TMP_117(uint256),TMP_118(uint256) := j(uint256),j(uint256) = j + 1,TMP_119 = CONVERT 0 to address,TMP_120(bool) = _token == TMP_119,CONDITION TMP_120,TMP_121 = CONVERT this to address,TMP_122(uint256) = SOLIDITY_CALL balance(address)(TMP_121),TMP_123(bool) = TMP_122 >= totalAmount,TMP_124(None) = SOLIDITY_CALL require(bool)(TMP_123),i(uint256) := 0(uint256),REF_60 -> LENGTH _hunters,TMP_125(bool) = i < REF_60,CONDITION TMP_125,REF_61(address) -> _hunters[i],REF_63(uint256) -> _amounts[i],TMP_126 = SEND dest:REF_61 value:REF_63,TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126),REF_64(address) -> _hunters[i],REF_65(uint256) -> _amounts[i],Emit Distribution(_token,this,REF_64,REF_65),TMP_129(uint256) := i(uint256),i(uint256) = i + 1,TMP_130 = CONVERT _token to ERC20,TMP_131(uint256) = HIGH_LEVEL_CALL, dest:TMP_130(ERC20), function:balanceOf, arguments:['this']  ,TMP_132(bool) = TMP_131 >= totalAmount,TMP_133(None) = SOLIDITY_CALL require(bool)(TMP_132),k(uint256) := 0(uint256),REF_67 -> LENGTH _hunters,TMP_134(bool) = k < REF_67,CONDITION TMP_134,TMP_135 = CONVERT _token to ERC20,REF_69(address) -> _hunters[k],REF_70(uint256) -> _amounts[k],HIGH_LEVEL_CALL, dest:TMP_135(ERC20), function:transfer, arguments:['REF_69', 'REF_70']  ,REF_71(address) -> _hunters[k],REF_72(uint256) -> _amounts[k],Emit Distribution(_token,this,REF_71,REF_72),TMP_138(uint256) := k(uint256),k(uint256) = k + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->27;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_hunters.length == _amounts.length)

IRs:
REF_55 -> LENGTH _hunters
REF_56 -> LENGTH _amounts
TMP_114(bool) = REF_55 == REF_56
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
totalAmount = 0

IRs:
totalAmount(uint256) := 0(uint256)""];
2->5;
3[label=""Node Type: BEGIN_LOOP 3
""];
3->6;
4[label=""Node Type: END_LOOP 4
""];
4->9;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
j = 0

IRs:
j(uint256) := 0(uint256)""];
5->3;
6[label=""Node Type: IF_LOOP 6

EXPRESSION:
j < _amounts.length

IRs:
REF_57 -> LENGTH _amounts
TMP_116(bool) = j < REF_57
CONDITION TMP_116""];
6->7[label=""True""];
6->4[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
totalAmount = SafeMath.add(totalAmount,_amounts[j])

IRs:
REF_59(uint256) -> _amounts[j]
TMP_117(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalAmount', 'REF_59'] 
totalAmount(uint256) := TMP_117(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
j ++

IRs:
TMP_118(uint256) := j(uint256)
j(uint256) = j + 1""];
8->6;
9[label=""Node Type: IF 9

EXPRESSION:
_token == address(0)

IRs:
TMP_119 = CONVERT 0 to address
TMP_120(bool) = _token == TMP_119
CONDITION TMP_120""];
9->10[label=""True""];
9->18[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(address(this).balance >= totalAmount)

IRs:
TMP_121 = CONVERT this to address
TMP_122(uint256) = SOLIDITY_CALL balance(address)(TMP_121)
TMP_123(bool) = TMP_122 >= totalAmount
TMP_124(None) = SOLIDITY_CALL require(bool)(TMP_123)""];
10->13;
11[label=""Node Type: BEGIN_LOOP 11
""];
11->14;
12[label=""Node Type: END_LOOP 12
""];
12->26;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
13->11;
14[label=""Node Type: IF_LOOP 14

EXPRESSION:
i < _hunters.length

IRs:
REF_60 -> LENGTH _hunters
TMP_125(bool) = i < REF_60
CONDITION TMP_125""];
14->15[label=""True""];
14->12[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
require(bool)(_hunters[i].send(_amounts[i]))

IRs:
REF_61(address) -> _hunters[i]
REF_63(uint256) -> _amounts[i]
TMP_126 = SEND dest:REF_61 value:REF_63
TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
Distribution(_token,this,_hunters[i],_amounts[i])

IRs:
REF_64(address) -> _hunters[i]
REF_65(uint256) -> _amounts[i]
Emit Distribution(_token,this,REF_64,REF_65)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
i ++

IRs:
TMP_129(uint256) := i(uint256)
i(uint256) = i + 1""];
17->14;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
require(bool)(ERC20(_token).balanceOf(this) >= totalAmount)

IRs:
TMP_130 = CONVERT _token to ERC20
TMP_131(uint256) = HIGH_LEVEL_CALL, dest:TMP_130(ERC20), function:balanceOf, arguments:['this']  
TMP_132(bool) = TMP_131 >= totalAmount
TMP_133(None) = SOLIDITY_CALL require(bool)(TMP_132)""];
18->21;
19[label=""Node Type: BEGIN_LOOP 19
""];
19->22;
20[label=""Node Type: END_LOOP 20
""];
20->26;
21[label=""Node Type: NEW VARIABLE 21

EXPRESSION:
k = 0

IRs:
k(uint256) := 0(uint256)""];
21->19;
22[label=""Node Type: IF_LOOP 22

EXPRESSION:
k < _hunters.length

IRs:
REF_67 -> LENGTH _hunters
TMP_134(bool) = k < REF_67
CONDITION TMP_134""];
22->23[label=""True""];
22->20[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
ERC20(_token).transfer(_hunters[k],_amounts[k])

IRs:
TMP_135 = CONVERT _token to ERC20
REF_69(address) -> _hunters[k]
REF_70(uint256) -> _amounts[k]
HIGH_LEVEL_CALL, dest:TMP_135(ERC20), function:transfer, arguments:['REF_69', 'REF_70']  ""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
Distribution(_token,this,_hunters[k],_amounts[k])

IRs:
REF_71(address) -> _hunters[k]
REF_72(uint256) -> _amounts[k]
Emit Distribution(_token,this,REF_71,REF_72)""];
24->25;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
k ++

IRs:
TMP_138(uint256) := k(uint256)
k(uint256) = k + 1""];
25->22;
26[label=""Node Type: END_IF 26
""];
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
27->1;
}
",1,0,0,0,"onlyOwner();require(bool)(_hunters.length == _amounts.length);totalAmount = 0;j = 0;;j < _amounts.length;;_token == address(0);totalAmount = SafeMath.add(totalAmount,_amounts[j]);j ++;require(bool)(address(this).balance >= totalAmount);require(bool)(ERC20(_token).balanceOf(this) >= totalAmount);i = 0;;i < _hunters.length;;;require(bool)(_hunters[i].send(_amounts[i]));Distribution(_token,this,_hunters[i],_amounts[i]);i ++;k = 0;;k < _hunters.length;;ERC20(_token).transfer(_hunters[k],_amounts[k]);Distribution(_token,this,_hunters[k],_amounts[k]);k ++"
./0x0002325fcaaac6ebf1254a626589147bde1a2394_ext.sol,HorseyPilot.deployChildren,1109,1119,"TMP_345 = UnaryType.BANG deployed ,TMP_346(None) = SOLIDITY_CALL require(bool,string)(TMP_345,already deployed),TMP_348(HorseyExchange) = new HorseyExchange() ,exchangeAddress(address) := TMP_348(HorseyExchange),TMP_350(HorseyToken) = new HorseyToken(stablesAddress) ,tokenAddress(address) := TMP_350(HorseyToken),TMP_351 = CONVERT exchangeAddress to HorseyExchange,HIGH_LEVEL_CALL, dest:TMP_351(HorseyExchange), function:setStables, arguments:['stablesAddress']  ,deployed(bool) := True(bool)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(! deployed,already deployed)

IRs:
TMP_345 = UnaryType.BANG deployed 
TMP_346(None) = SOLIDITY_CALL require(bool,string)(TMP_345,already deployed)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
exchangeAddress = new HorseyExchange()

IRs:
TMP_348(HorseyExchange) = new HorseyExchange() 
exchangeAddress(address) := TMP_348(HorseyExchange)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tokenAddress = new HorseyToken(stablesAddress)

IRs:
TMP_350(HorseyToken) = new HorseyToken(stablesAddress) 
tokenAddress(address) := TMP_350(HorseyToken)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
HorseyExchange(exchangeAddress).setStables(stablesAddress)

IRs:
TMP_351 = CONVERT exchangeAddress to HorseyExchange
HIGH_LEVEL_CALL, dest:TMP_351(HorseyExchange), function:setStables, arguments:['stablesAddress']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
deployed = true

IRs:
deployed(bool) := True(bool)""];
}
",1,0,0,0,"require(bool,string)(! deployed,already deployed);exchangeAddress = new HorseyExchange();tokenAddress = new HorseyToken(stablesAddress);HorseyExchange(exchangeAddress).setStables(stablesAddress);deployed = true"
./0x00676065a7854163c6a4d5f474496514d03e31c4_ext.sol,CrystalDeposit.setEngineerInterface,180,187,"TMP_30 = CONVERT _addr to CryptoEngineerInterface,engineerInterface(CryptoEngineerInterface) := TMP_30(CryptoEngineerInterface),TMP_31(bool) = HIGH_LEVEL_CALL, dest:engineerInterface(CryptoEngineerInterface), function:isEngineerContract, arguments:[]  ,TMP_32(bool) = TMP_31 == True,TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32),Engineer(CryptoEngineerInterface) := engineerInterface(CryptoEngineerInterface),MODIFIER_CALL, CrystalDeposit.isAdministrator()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
engineerInterface = CryptoEngineerInterface(_addr)

IRs:
TMP_30 = CONVERT _addr to CryptoEngineerInterface
engineerInterface(CryptoEngineerInterface) := TMP_30(CryptoEngineerInterface)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(engineerInterface.isEngineerContract() == true)

IRs:
TMP_31(bool) = HIGH_LEVEL_CALL, dest:engineerInterface(CryptoEngineerInterface), function:isEngineerContract, arguments:[]  
TMP_32(bool) = TMP_31 == True
TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Engineer = engineerInterface

IRs:
Engineer(CryptoEngineerInterface) := engineerInterface(CryptoEngineerInterface)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
isAdministrator()

IRs:
MODIFIER_CALL, CrystalDeposit.isAdministrator()()""];
4->1;
}
",1,0,0,0,isAdministrator();engineerInterface = CryptoEngineerInterface(_addr);require(bool)(engineerInterface.isEngineerContract() == true);Engineer = engineerInterface
./0x26f4fb84b53dff7e148a8196f09bc492e55f2889_ext.sol,TimeLockPool.depositERC20,526,542,"TMP_175 = CONVERT 0 to address,TMP_176(bool) = account != TMP_175,TMP_177(None) = SOLIDITY_CALL require(bool)(TMP_176),TMP_178(bool) = tokenAddr != 0,TMP_179(None) = SOLIDITY_CALL require(bool)(TMP_178),TMP_180(bool) = msg.value == 0,TMP_181(None) = SOLIDITY_CALL require(bool)(TMP_180),TMP_182(bool) = amount > 0,TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182),TMP_184 = CONVERT tokenAddr to ERC20Interface,TMP_185(bool) = HIGH_LEVEL_CALL, dest:TMP_184(ERC20Interface), function:transferFrom, arguments:['msg.sender', 'this', 'amount']  ,TMP_186(None) = SOLIDITY_CALL require(bool)(TMP_185),REF_169(mapping(address => TimeLockPool.LockedBalance[])) -> lockedBalances[account],REF_170(TimeLockPool.LockedBalance[]) -> REF_169[tokenAddr],TMP_187(TimeLockPool.LockedBalance) = new LockedBalance(amount,releaseTime),REF_172 -> LENGTH REF_170,TMP_189(uint256) := REF_172(uint256),TMP_190(uint256) = TMP_189 + 1,REF_172(uint256) (->lockedBalances) := TMP_190(uint256),REF_173(TimeLockPool.LockedBalance) -> REF_170[TMP_189],REF_173(TimeLockPool.LockedBalance) (->lockedBalances) := TMP_187(TimeLockPool.LockedBalance),Emit Deposit(account,tokenAddr,amount,releaseTime),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(account != address(0x0))

IRs:
TMP_175 = CONVERT 0 to address
TMP_176(bool) = account != TMP_175
TMP_177(None) = SOLIDITY_CALL require(bool)(TMP_176)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(tokenAddr != 0x0)

IRs:
TMP_178(bool) = tokenAddr != 0
TMP_179(None) = SOLIDITY_CALL require(bool)(TMP_178)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(msg.value == 0)

IRs:
TMP_180(bool) = msg.value == 0
TMP_181(None) = SOLIDITY_CALL require(bool)(TMP_180)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_182(bool) = amount > 0
TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(ERC20Interface(tokenAddr).transferFrom(msg.sender,this,amount))

IRs:
TMP_184 = CONVERT tokenAddr to ERC20Interface
TMP_185(bool) = HIGH_LEVEL_CALL, dest:TMP_184(ERC20Interface), function:transferFrom, arguments:['msg.sender', 'this', 'amount']  
TMP_186(None) = SOLIDITY_CALL require(bool)(TMP_185)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
lockedBalances[account][tokenAddr].push(LockedBalance(amount,releaseTime))

IRs:
REF_169(mapping(address => TimeLockPool.LockedBalance[])) -> lockedBalances[account]
REF_170(TimeLockPool.LockedBalance[]) -> REF_169[tokenAddr]
TMP_187(TimeLockPool.LockedBalance) = new LockedBalance(amount,releaseTime)
REF_172 -> LENGTH REF_170
TMP_189(uint256) := REF_172(uint256)
TMP_190(uint256) = TMP_189 + 1
REF_172(uint256) (->lockedBalances) := TMP_190(uint256)
REF_173(TimeLockPool.LockedBalance) -> REF_170[TMP_189]
REF_173(TimeLockPool.LockedBalance) (->lockedBalances) := TMP_187(TimeLockPool.LockedBalance)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Deposit(account,tokenAddr,amount,releaseTime)

IRs:
Emit Deposit(account,tokenAddr,amount,releaseTime)""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,"require(bool)(account != address(0x0));require(bool)(tokenAddr != 0x0);require(bool)(msg.value == 0);require(bool)(amount > 0);require(bool)(ERC20Interface(tokenAddr).transferFrom(msg.sender,this,amount));lockedBalances[account][tokenAddr].push(LockedBalance(amount,releaseTime));Deposit(account,tokenAddr,amount,releaseTime);true"
./0x74ceda99c44da280f2fd8ea8b5dd43f8b66912a8_ext.sol,DisbursementHandler.withdraw,343,351,"TMP_131(uint256) = INTERNAL_CALL, DisbursementHandler.calcMaxWithdraw()(),maxTokens(uint256) := TMP_131(uint256),REF_108(uint256) -> withdrawnTokens[msg.sender],REF_110(uint256) -> withdrawnTokens[msg.sender],TMP_132(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_110', 'withdrawAmount'] ,REF_108(uint256) (->withdrawnTokens) := TMP_132(uint256),TMP_133(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['to', 'withdrawAmount']  ,Emit LogWithdraw(to,value),TMP_135(bool) = value < maxTokens,CONDITION TMP_135,withdrawAmount(uint256) := value(uint256),withdrawAmount(uint256) := maxTokens(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
maxTokens = calcMaxWithdraw()

IRs:
TMP_131(uint256) = INTERNAL_CALL, DisbursementHandler.calcMaxWithdraw()()
maxTokens(uint256) := TMP_131(uint256)""];
1->6;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
withdrawnTokens[msg.sender] = SafeMath.add(withdrawnTokens[msg.sender],withdrawAmount)

IRs:
REF_108(uint256) -> withdrawnTokens[msg.sender]
REF_110(uint256) -> withdrawnTokens[msg.sender]
TMP_132(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_110', 'withdrawAmount'] 
REF_108(uint256) (->withdrawnTokens) := TMP_132(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(to,withdrawAmount)

IRs:
TMP_133(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['to', 'withdrawAmount']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
LogWithdraw(to,value)

IRs:
Emit LogWithdraw(to,value)""];
6[label=""Node Type: IF 6

EXPRESSION:
value < maxTokens

IRs:
TMP_135(bool) = value < maxTokens
CONDITION TMP_135""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
withdrawAmount = value

IRs:
withdrawAmount(uint256) := value(uint256)""];
7->9;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
withdrawAmount = maxTokens

IRs:
withdrawAmount(uint256) := maxTokens(uint256)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->3;
}
",1,0,0,0,"maxTokens = calcMaxWithdraw();value < maxTokens;withdrawnTokens[msg.sender] = SafeMath.add(withdrawnTokens[msg.sender],withdrawAmount);token.transfer(to,withdrawAmount);LogWithdraw(to,value);withdrawAmount = value;withdrawAmount = maxTokens;"
./0xec841c878435ba4f28bf305a00c1483db0d96a20_ext.sol,Events.message,255,259,"TMP_42(bytes) = SOLIDITY_CALL abi.encodePacked()(_message),TMP_43(bytes32) = SOLIDITY_CALL keccak256()(TMP_42),Emit LogEvent(_message,TMP_43,tx.origin),MODIFIER_CALL, Events.onlyApprovedContract()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
LogEvent(_message,keccak256()(abi.encodePacked(_message)),tx.origin)

IRs:
TMP_42(bytes) = SOLIDITY_CALL abi.encodePacked()(_message)
TMP_43(bytes32) = SOLIDITY_CALL keccak256()(TMP_42)
Emit LogEvent(_message,TMP_43,tx.origin)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyApprovedContract()

IRs:
MODIFIER_CALL, Events.onlyApprovedContract()()""];
2->1;
}
",1,0,0,0,"onlyApprovedContract();LogEvent(_message,keccak256()(abi.encodePacked(_message)),tx.origin)"
./0x27e1d539cb59518bf14e4525b1c3b4721aaa9080_ext.sol,FourCrowdsale.processPresaleOrEarlyContributors,923,934,"TMP_889(bool) = now <= endTime,TMP_890(None) = SOLIDITY_CALL require(bool)(TMP_889),i(uint256) := 0(uint256),REF_573 -> LENGTH _beneficiaries,TMP_891(bool) = i < REF_573,CONDITION TMP_891,REF_575(uint256) -> _tokenAmounts[i],TMP_892(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokensSold', 'REF_575'] ,tokensSold(uint256) := TMP_892(uint256),REF_577(address) -> _beneficiaries[i],REF_578(uint256) -> _tokenAmounts[i],TMP_893(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['REF_577', 'REF_578']  ,REF_579(address) -> _beneficiaries[i],REF_580(uint256) -> _tokenAmounts[i],Emit TokenPurchase(msg.sender,REF_579,0,REF_580),TMP_895(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now <= endTime)

IRs:
TMP_889(bool) = now <= endTime
TMP_890(None) = SOLIDITY_CALL require(bool)(TMP_889)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < _beneficiaries.length

IRs:
REF_573 -> LENGTH _beneficiaries
TMP_891(bool) = i < REF_573
CONDITION TMP_891""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tokensSold = tokensSold.add(_tokenAmounts[i])

IRs:
REF_575(uint256) -> _tokenAmounts[i]
TMP_892(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokensSold', 'REF_575'] 
tokensSold(uint256) := TMP_892(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.mint(_beneficiaries[i],_tokenAmounts[i])

IRs:
REF_577(address) -> _beneficiaries[i]
REF_578(uint256) -> _tokenAmounts[i]
TMP_893(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['REF_577', 'REF_578']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
TokenPurchase(msg.sender,_beneficiaries[i],0,_tokenAmounts[i])

IRs:
REF_579(address) -> _beneficiaries[i]
REF_580(uint256) -> _tokenAmounts[i]
Emit TokenPurchase(msg.sender,REF_579,0,REF_580)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_895(uint256) := i(uint256)
i(uint256) = i + 1""];
9->5;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
10->1;
}
",1,0,0,0,"onlyOwner();require(bool)(now <= endTime);i = 0;;i < _beneficiaries.length;;tokensSold = tokensSold.add(_tokenAmounts[i]);token.mint(_beneficiaries[i],_tokenAmounts[i]);TokenPurchase(msg.sender,_beneficiaries[i],0,_tokenAmounts[i]);i ++"
./0xf244176246168f24e3187f7288edbca29267739b_ext.sol,Havven.setTargetFeePeriodDuration,2472,2481,"TMP_1062(bool) = MIN_FEE_PERIOD_DURATION_SECONDS <= duration,TMP_1063(bool) = duration <= MAX_FEE_PERIOD_DURATION_SECONDS,TMP_1064(bool) = TMP_1062 && TMP_1063,TMP_1065(None) = SOLIDITY_CALL require(bool)(TMP_1064),targetFeePeriodDurationSeconds(uint256) := duration(uint256),Emit FeePeriodDurationUpdated(duration),MODIFIER_CALL, Havven.postCheckFeePeriodRollover()(),MODIFIER_CALL, Proxyable.optionalProxy_onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(MIN_FEE_PERIOD_DURATION_SECONDS <= duration && duration <= MAX_FEE_PERIOD_DURATION_SECONDS)

IRs:
TMP_1062(bool) = MIN_FEE_PERIOD_DURATION_SECONDS <= duration
TMP_1063(bool) = duration <= MAX_FEE_PERIOD_DURATION_SECONDS
TMP_1064(bool) = TMP_1062 && TMP_1063
TMP_1065(None) = SOLIDITY_CALL require(bool)(TMP_1064)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
targetFeePeriodDurationSeconds = duration

IRs:
targetFeePeriodDurationSeconds(uint256) := duration(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
FeePeriodDurationUpdated(duration)

IRs:
Emit FeePeriodDurationUpdated(duration)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
postCheckFeePeriodRollover()

IRs:
MODIFIER_CALL, Havven.postCheckFeePeriodRollover()()""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
optionalProxy_onlyOwner()

IRs:
MODIFIER_CALL, Proxyable.optionalProxy_onlyOwner()()""];
5->1;
}
",1,0,0,0,postCheckFeePeriodRollover();require(bool)(MIN_FEE_PERIOD_DURATION_SECONDS <= duration && duration <= MAX_FEE_PERIOD_DURATION_SECONDS);targetFeePeriodDurationSeconds = duration;FeePeriodDurationUpdated(duration);optionalProxy_onlyOwner()
./0x6bd33d49d48f76abcd96652e5347e398aa3fda96_ext.sol,BancorBuyer.buy,58,70,"bought_tokens(bool) := True(bool),time_bought(uint256) := now(uint256),TMP_1 = CONVERT sale to CrowdsaleController,REF_5(uint256) = SOLIDITY_CALL balance(address)(this),TMP_2([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E3015C40>]) = REF_5 - reward,TMP_4(uint256) = HIGH_LEVEL_CALL, dest:TMP_1(CrowdsaleController), function:contributeETH, arguments:[] value:TMP_2 ,Transfer dest:msg.sender value:reward","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
bought_tokens = true

IRs:
bought_tokens(bool) := True(bool)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
time_bought = now

IRs:
time_bought(uint256) := now(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
CrowdsaleController(sale).contributeETH.value(this.balance - reward)()

IRs:
TMP_1 = CONVERT sale to CrowdsaleController
REF_5(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_2([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E3015C40>]) = REF_5 - reward
TMP_4(uint256) = HIGH_LEVEL_CALL, dest:TMP_1(CrowdsaleController), function:contributeETH, arguments:[] value:TMP_2 ""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(reward)

IRs:
Transfer dest:msg.sender value:reward""];
}
",1,0,1,0,bought_tokens = true;time_bought = now;CrowdsaleController(sale).contributeETH.value(this.balance - reward)();msg.sender.transfer(reward)
./0x0ee14f47320604d894fffffc8639772382937bee_ext.sol,OpportyWhiteListHold.returnTokens,350,355,"TMP_98(uint256) = INTERNAL_CALL, OpportyWhiteListHold.getBalance()(),TMP_99(bool) = nTokens <= TMP_98,TMP_100(None) = SOLIDITY_CALL require(bool)(TMP_99),TMP_101(bool) = HIGH_LEVEL_CALL, dest:OppToken(OpportyToken), function:transfer, arguments:['msg.sender', 'nTokens']  ,Emit TokensTransfered(msg.sender,nTokens),RETURN True,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(nTokens <= getBalance())

IRs:
TMP_98(uint256) = INTERNAL_CALL, OpportyWhiteListHold.getBalance()()
TMP_99(bool) = nTokens <= TMP_98
TMP_100(None) = SOLIDITY_CALL require(bool)(TMP_99)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
OppToken.transfer(msg.sender,nTokens)

IRs:
TMP_101(bool) = HIGH_LEVEL_CALL, dest:OppToken(OpportyToken), function:transfer, arguments:['msg.sender', 'nTokens']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
TokensTransfered(msg.sender,nTokens)

IRs:
Emit TokensTransfered(msg.sender,nTokens)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",1,0,0,0,"onlyOwner();require(bool)(nTokens <= getBalance());OppToken.transfer(msg.sender,nTokens);TokensTransfered(msg.sender,nTokens);true"
./0x6b4df2aa3d64d8dc06120ef4391513e4170af4a7_ext.sol,GeneralTransferManager.modifyWhitelistMulti,860,874,"REF_168 -> LENGTH _investors,REF_169 -> LENGTH _fromTimes,TMP_277(bool) = REF_168 == REF_169,TMP_278(None) = SOLIDITY_CALL require(bool,string)(TMP_277,Mismatched input lengths),REF_170 -> LENGTH _fromTimes,REF_171 -> LENGTH _toTimes,TMP_279(bool) = REF_170 == REF_171,TMP_280(None) = SOLIDITY_CALL require(bool,string)(TMP_279,Mismatched input lengths),REF_172 -> LENGTH _toTimes,REF_173 -> LENGTH _expiryTimes,TMP_281(bool) = REF_172 == REF_173,TMP_282(None) = SOLIDITY_CALL require(bool,string)(TMP_281,Mismatched input lengths),REF_174 -> LENGTH _canBuyFromSTO,REF_175 -> LENGTH _toTimes,TMP_283(bool) = REF_174 == REF_175,TMP_284(None) = SOLIDITY_CALL require(bool,string)(TMP_283,Mismatched input length),i(uint256) := 0(uint256),REF_176 -> LENGTH _investors,TMP_285(bool) = i < REF_176,CONDITION TMP_285,REF_177(address) -> _investors[i],REF_178(uint256) -> _fromTimes[i],REF_179(uint256) -> _toTimes[i],REF_180(uint256) -> _expiryTimes[i],REF_181(bool) -> _canBuyFromSTO[i],INTERNAL_CALL, GeneralTransferManager.modifyWhitelist(address,uint256,uint256,uint256,bool)(REF_177,REF_178,REF_179,REF_180,REF_181),TMP_287(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, IModule.withPerm(bytes32)(WHITELIST)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(_investors.length == _fromTimes.length,Mismatched input lengths)

IRs:
REF_168 -> LENGTH _investors
REF_169 -> LENGTH _fromTimes
TMP_277(bool) = REF_168 == REF_169
TMP_278(None) = SOLIDITY_CALL require(bool,string)(TMP_277,Mismatched input lengths)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(_fromTimes.length == _toTimes.length,Mismatched input lengths)

IRs:
REF_170 -> LENGTH _fromTimes
REF_171 -> LENGTH _toTimes
TMP_279(bool) = REF_170 == REF_171
TMP_280(None) = SOLIDITY_CALL require(bool,string)(TMP_279,Mismatched input lengths)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool,string)(_toTimes.length == _expiryTimes.length,Mismatched input lengths)

IRs:
REF_172 -> LENGTH _toTimes
REF_173 -> LENGTH _expiryTimes
TMP_281(bool) = REF_172 == REF_173
TMP_282(None) = SOLIDITY_CALL require(bool,string)(TMP_281,Mismatched input lengths)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool,string)(_canBuyFromSTO.length == _toTimes.length,Mismatched input length)

IRs:
REF_174 -> LENGTH _canBuyFromSTO
REF_175 -> LENGTH _toTimes
TMP_283(bool) = REF_174 == REF_175
TMP_284(None) = SOLIDITY_CALL require(bool,string)(TMP_283,Mismatched input length)""];
4->7;
5[label=""Node Type: BEGIN_LOOP 5
""];
5->8;
6[label=""Node Type: END_LOOP 6
""];
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
7->5;
8[label=""Node Type: IF_LOOP 8

EXPRESSION:
i < _investors.length

IRs:
REF_176 -> LENGTH _investors
TMP_285(bool) = i < REF_176
CONDITION TMP_285""];
8->9[label=""True""];
8->6[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
modifyWhitelist(_investors[i],_fromTimes[i],_toTimes[i],_expiryTimes[i],_canBuyFromSTO[i])

IRs:
REF_177(address) -> _investors[i]
REF_178(uint256) -> _fromTimes[i]
REF_179(uint256) -> _toTimes[i]
REF_180(uint256) -> _expiryTimes[i]
REF_181(bool) -> _canBuyFromSTO[i]
INTERNAL_CALL, GeneralTransferManager.modifyWhitelist(address,uint256,uint256,uint256,bool)(REF_177,REF_178,REF_179,REF_180,REF_181)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
i ++

IRs:
TMP_287(uint256) := i(uint256)
i(uint256) = i + 1""];
10->8;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
withPerm(WHITELIST)

IRs:
MODIFIER_CALL, IModule.withPerm(bytes32)(WHITELIST)""];
11->1;
}
",1,1,0,0,"withPerm(WHITELIST);require(bool,string)(_investors.length == _fromTimes.length,Mismatched input lengths);require(bool,string)(_fromTimes.length == _toTimes.length,Mismatched input lengths);require(bool,string)(_toTimes.length == _expiryTimes.length,Mismatched input lengths);require(bool,string)(_canBuyFromSTO.length == _toTimes.length,Mismatched input length);i = 0;;i < _investors.length;;modifyWhitelist(_investors[i],_fromTimes[i],_toTimes[i],_expiryTimes[i],_canBuyFromSTO[i]);i ++"
./0x39e8082b00c9f19ebf553e40feb7cf8459acc693_ext.sol,DSToken.setName,257,259,"name(string) := name_(string),MODIFIER_CALL, DSAuth.auth()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
name = name_

IRs:
name(string) := name_(string)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
2->1;
}
",1,0,0,0,auth();name = name_
./0x17a03553719001e05dc19a20f5e82ee76923a985_ext.sol,Auction.createAuction,549,566,"TMP_123(bool) = INTERNAL_CALL, AuctionBase._owns(address,uint256)(msg.sender,_tokenId),TMP_124(None) = SOLIDITY_CALL require(bool)(TMP_123),INTERNAL_CALL, AuctionBase._escrow(address,uint256)(msg.sender,_tokenId),TMP_126 = CONVERT _price to uint128,TMP_127 = CONVERT now to uint64,TMP_128(AuctionBase.Auction) = new Auction(_seller,TMP_126,TMP_127),auction(AuctionBase.Auction) := TMP_128(AuctionBase.Auction),INTERNAL_CALL, AuctionBase._addAuction(uint256,AuctionBase.Auction)(_tokenId,auction),MODIFIER_CALL, Pausable.whenNotPaused()(),MODIFIER_CALL, AuctionBase.canBeStoredWith128Bits(uint256)(_price)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_owns(msg.sender,_tokenId))

IRs:
TMP_123(bool) = INTERNAL_CALL, AuctionBase._owns(address,uint256)(msg.sender,_tokenId)
TMP_124(None) = SOLIDITY_CALL require(bool)(TMP_123)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_escrow(msg.sender,_tokenId)

IRs:
INTERNAL_CALL, AuctionBase._escrow(address,uint256)(msg.sender,_tokenId)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
auction = Auction(_seller,uint128(_price),uint64(now))

IRs:
TMP_126 = CONVERT _price to uint128
TMP_127 = CONVERT now to uint64
TMP_128(AuctionBase.Auction) = new Auction(_seller,TMP_126,TMP_127)
auction(AuctionBase.Auction) := TMP_128(AuctionBase.Auction)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
_addAuction(_tokenId,auction)

IRs:
INTERNAL_CALL, AuctionBase._addAuction(uint256,AuctionBase.Auction)(_tokenId,auction)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
canBeStoredWith128Bits(_price)

IRs:
MODIFIER_CALL, AuctionBase.canBeStoredWith128Bits(uint256)(_price)""];
6->1;
}
",1,0,0,0,"whenNotPaused();require(bool)(_owns(msg.sender,_tokenId));_escrow(msg.sender,_tokenId);auction = Auction(_seller,uint128(_price),uint64(now));_addAuction(_tokenId,auction);canBeStoredWith128Bits(_price)"
./0x797d713d8d7a2815ccf3dcf9719e3e9f1712c370_ext.sol,Trustee.revoke,600,615,"REF_77(Trustee.Grant) -> grants[_holder],grant(Trustee.Grant) := REF_77(Trustee.Grant),REF_78(bool) -> grant.revokable,TMP_310(None) = SOLIDITY_CALL require(bool)(REF_78),REF_79(uint256) -> grant.value,REF_81(uint256) -> grant.transferred,TMP_311(uint256) = LIBRARY_CALL, dest:SaferMath, function:SaferMath.sub(uint256,uint256), arguments:['REF_79', 'REF_81'] ,refund(uint256) := TMP_311(uint256),REF_82(Trustee.Grant) -> grants[_holder],grants = delete REF_82 ,TMP_312(uint256) = LIBRARY_CALL, dest:SaferMath, function:SaferMath.sub(uint256,uint256), arguments:['totalVesting', 'refund'] ,totalVesting(uint256) := TMP_312(uint256),TMP_313(bool) = HIGH_LEVEL_CALL, dest:stox(StoxSmartToken), function:transfer, arguments:['msg.sender', 'refund']  ,Emit RevokeGrant(_holder,refund),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
grant = grants[_holder]

IRs:
REF_77(Trustee.Grant) -> grants[_holder]
grant(Trustee.Grant) := REF_77(Trustee.Grant)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(grant.revokable)

IRs:
REF_78(bool) -> grant.revokable
TMP_310(None) = SOLIDITY_CALL require(bool)(REF_78)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
refund = grant.value.sub(grant.transferred)

IRs:
REF_79(uint256) -> grant.value
REF_81(uint256) -> grant.transferred
TMP_311(uint256) = LIBRARY_CALL, dest:SaferMath, function:SaferMath.sub(uint256,uint256), arguments:['REF_79', 'REF_81'] 
refund(uint256) := TMP_311(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
delete grants[_holder]

IRs:
REF_82(Trustee.Grant) -> grants[_holder]
grants = delete REF_82 ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalVesting = totalVesting.sub(refund)

IRs:
TMP_312(uint256) = LIBRARY_CALL, dest:SaferMath, function:SaferMath.sub(uint256,uint256), arguments:['totalVesting', 'refund'] 
totalVesting(uint256) := TMP_312(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
stox.transfer(msg.sender,refund)

IRs:
TMP_313(bool) = HIGH_LEVEL_CALL, dest:stox(StoxSmartToken), function:transfer, arguments:['msg.sender', 'refund']  ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
RevokeGrant(_holder,refund)

IRs:
Emit RevokeGrant(_holder,refund)""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
8->1;
}
",1,0,0,0,"onlyOwner();grant = grants[_holder];require(bool)(grant.revokable);refund = grant.value.sub(grant.transferred);delete grants[_holder];totalVesting = totalVesting.sub(refund);stox.transfer(msg.sender,refund);RevokeGrant(_holder,refund)"
./0x18f0cd26c06449d967ca6aef8b5f9d8ee9fd7992_ext.sol,Exch.withdraw,160,165,"REF_25(mapping(address => uint256)) -> tokens[0],REF_26(uint256) -> REF_25[msg.sender],TMP_59(bool) = REF_26 < amount,CONDITION TMP_59,TMP_60(None) = SOLIDITY_CALL revert()(),REF_27(mapping(address => uint256)) -> tokens[0],REF_28(uint256) -> REF_27[msg.sender],REF_29(mapping(address => uint256)) -> tokens[0],REF_30(uint256) -> REF_29[msg.sender],TMP_61(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_30,amount),REF_28(uint256) (->tokens) := TMP_61(uint256),Transfer dest:msg.sender value:amount,REF_32(mapping(address => uint256)) -> tokens[0],REF_33(uint256) -> REF_32[msg.sender],Emit Withdraw(0,msg.sender,amount,REF_33)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
tokens[0][msg.sender] < amount

IRs:
REF_25(mapping(address => uint256)) -> tokens[0]
REF_26(uint256) -> REF_25[msg.sender]
TMP_59(bool) = REF_26 < amount
CONDITION TMP_59""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_60(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender],amount)

IRs:
REF_27(mapping(address => uint256)) -> tokens[0]
REF_28(uint256) -> REF_27[msg.sender]
REF_29(mapping(address => uint256)) -> tokens[0]
REF_30(uint256) -> REF_29[msg.sender]
TMP_61(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_30,amount)
REF_28(uint256) (->tokens) := TMP_61(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Withdraw(0,msg.sender,amount,tokens[0][msg.sender])

IRs:
REF_32(mapping(address => uint256)) -> tokens[0]
REF_33(uint256) -> REF_32[msg.sender]
Emit Withdraw(0,msg.sender,amount,REF_33)""];
}
",1,0,0,0,"tokens[0][msg.sender] < amount;revert()();;tokens[0][msg.sender] = safeSub(tokens[0][msg.sender],amount);msg.sender.transfer(amount);Withdraw(0,msg.sender,amount,tokens[0][msg.sender])"
./0x211f01e59b425253c0a0e9a7bf612605b42ce82c_ext.sol,Kleros.executeOrder,1569,1571,"TMP_434(bool) = LOW_LEVEL_CALL, dest:_target, function:call, arguments:['_data'] value:_value ,MODIFIER_CALL, Kleros.onlyGovernor()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_target.call.value(_value)(_data)

IRs:
TMP_434(bool) = LOW_LEVEL_CALL, dest:_target, function:call, arguments:['_data'] value:_value ""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyGovernor()

IRs:
MODIFIER_CALL, Kleros.onlyGovernor()()""];
2->1;
}
",1,0,0,0,onlyGovernor();_target.call.value(_value)(_data)
./0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497_ext.sol,LockinManager.lockForDays,574,581,"TMP_147(bool) = INTERNAL_CALL, LockinManager.ifInAllowedLocks(uint256)(_days),TMP_148 = UnaryType.BANG TMP_147 ,TMP_149(None) = SOLIDITY_CALL require(bool)(TMP_148),TMP_150(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:availableBalance, arguments:['msg.sender']  ,TMP_151(bool) = TMP_150 >= _value,TMP_152(None) = SOLIDITY_CALL require(bool)(TMP_151),INTERNAL_CALL, LockinManager.lockIt(address,uint256,uint256)(msg.sender,_value,_days)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! ifInAllowedLocks(_days))

IRs:
TMP_147(bool) = INTERNAL_CALL, LockinManager.ifInAllowedLocks(uint256)(_days)
TMP_148 = UnaryType.BANG TMP_147 
TMP_149(None) = SOLIDITY_CALL require(bool)(TMP_148)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(token.availableBalance(msg.sender) >= _value)

IRs:
TMP_150(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:availableBalance, arguments:['msg.sender']  
TMP_151(bool) = TMP_150 >= _value
TMP_152(None) = SOLIDITY_CALL require(bool)(TMP_151)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
lockIt(msg.sender,_value,_days)

IRs:
INTERNAL_CALL, LockinManager.lockIt(address,uint256,uint256)(msg.sender,_value,_days)""];
}
",1,0,0,0,"require(bool)(! ifInAllowedLocks(_days));require(bool)(token.availableBalance(msg.sender) >= _value);lockIt(msg.sender,_value,_days)"
./0x4cd988afbad37289baaf53c13e98e2bd46aaea8c_ext.sol,DSStop.start,378,380,"stopped(bool) := False(bool),MODIFIER_CALL, DSAuth.auth()(),MODIFIER_CALL, DSNote.note()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
stopped = false

IRs:
stopped(bool) := False(bool)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
note()

IRs:
MODIFIER_CALL, DSNote.note()()""];
3->1;
}
",1,0,0,0,auth();stopped = false;note()
./0x6f8544edb3f513845135b0efa907f4b6b9c2c92e_ext.sol,BW.claimTilesForNewUser,665,669,"HIGH_LEVEL_CALL, dest:bwData(BWData), function:addUser, arguments:['msg.sender']  ,Emit UserCreated(msg.sender,_name,_imageUrl,_tag,_homeUrl,block.timestamp,_invitedBy),HIGH_LEVEL_CALL, dest:bwService(BWService), function:storeInitialClaim, arguments:['msg.sender', '_claimedTileIds', 'msg.value', 'False']  ,MODIFIER_CALL, BW.isNotPaused()(),MODIFIER_CALL, BW.isNotContractCaller()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
bwData.addUser(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:bwData(BWData), function:addUser, arguments:['msg.sender']  ""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
UserCreated(msg.sender,_name,_imageUrl,_tag,_homeUrl,block.timestamp,_invitedBy)

IRs:
Emit UserCreated(msg.sender,_name,_imageUrl,_tag,_homeUrl,block.timestamp,_invitedBy)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
bwService.storeInitialClaim(msg.sender,_claimedTileIds,msg.value,false)

IRs:
HIGH_LEVEL_CALL, dest:bwService(BWService), function:storeInitialClaim, arguments:['msg.sender', '_claimedTileIds', 'msg.value', 'False']  ""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
isNotPaused()

IRs:
MODIFIER_CALL, BW.isNotPaused()()""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
isNotContractCaller()

IRs:
MODIFIER_CALL, BW.isNotContractCaller()()""];
5->1;
}
",1,0,0,0,"isNotPaused();bwData.addUser(msg.sender);UserCreated(msg.sender,_name,_imageUrl,_tag,_homeUrl,block.timestamp,_invitedBy);bwService.storeInitialClaim(msg.sender,_claimedTileIds,msg.value,false);isNotContractCaller()"
./0x3ac86159fad58c90aaea1c61974d69d4f8ce8e77_ext.sol,Crowdsale.finishMinting,724,733,"CONDITION mintingFinished,TMP_269(None) = SOLIDITY_CALL revert()(),HIGH_LEVEL_CALL, dest:token(SingleTokenCoin), function:finishMinting, arguments:[]  ,mintingFinished(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: IF 1

EXPRESSION:
mintingFinished

IRs:
CONDITION mintingFinished""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_269(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.finishMinting()

IRs:
HIGH_LEVEL_CALL, dest:token(SingleTokenCoin), function:finishMinting, arguments:[]  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
mintingFinished = true

IRs:
mintingFinished(bool) := True(bool)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",1,0,0,0,onlyOwner();mintingFinished;revert()();;token.finishMinting();mintingFinished = true
./0xaf8eabf89f5664a2bc82ca415a4337821cd54d65_ext.sol,Crowdsale.returnBonus,258,263,"TMP_101(bool) = block.timestamp > bonusDeliverTime,TMP_102(None) = SOLIDITY_CALL require(bool)(TMP_101),TMP_103(bool) = bonusUnsold > 0,TMP_104(None) = SOLIDITY_CALL require(bool)(TMP_103),TMP_105(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['wallet', 'bonusUnsold']  ,TMP_106(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['bonusUnsold', 'bonusUnsold'] ,bonusUnsold(uint256) := TMP_106(uint256),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(block.timestamp > bonusDeliverTime)

IRs:
TMP_101(bool) = block.timestamp > bonusDeliverTime
TMP_102(None) = SOLIDITY_CALL require(bool)(TMP_101)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(bonusUnsold > 0)

IRs:
TMP_103(bool) = bonusUnsold > 0
TMP_104(None) = SOLIDITY_CALL require(bool)(TMP_103)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
token.transfer(wallet,bonusUnsold)

IRs:
TMP_105(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['wallet', 'bonusUnsold']  ""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
bonusUnsold = bonusUnsold.sub(bonusUnsold)

IRs:
TMP_106(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['bonusUnsold', 'bonusUnsold'] 
bonusUnsold(uint256) := TMP_106(uint256)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",1,0,0,0,"onlyOwner();require(bool)(block.timestamp > bonusDeliverTime);require(bool)(bonusUnsold > 0);token.transfer(wallet,bonusUnsold);bonusUnsold = bonusUnsold.sub(bonusUnsold)"
./0x3fe1bd3f808682e10cc16ccfc0e9476555ed93a7_ext.sol,WFCToken.migrate,193,207,"CONDITION isFunding,TMP_74 = CONVERT 0 to address,TMP_75(bool) = newContractAddr == TMP_74,CONDITION TMP_75,REF_31(uint256) -> balances[msg.sender],tokens(uint256) := REF_31(uint256),TMP_76(bool) = tokens == 0,CONDITION TMP_76,REF_32(uint256) -> balances[msg.sender],REF_32(uint256) (->balances) := 0(uint256),TMP_77(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(tokenMigrated,tokens),tokenMigrated(uint256) := TMP_77(uint256),TMP_78 = CONVERT newContractAddr to IMigrationContract,newContract(IMigrationContract) := TMP_78(IMigrationContract),TMP_79(bool) = HIGH_LEVEL_CALL, dest:newContract(IMigrationContract), function:migrate, arguments:['msg.sender', 'tokens']  ,TMP_80 = UnaryType.BANG TMP_79 ,CONDITION TMP_80,Emit Migrate(msg.sender,tokens)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
isFunding

IRs:
CONDITION isFunding""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
newContractAddr == address(0x0)

IRs:
TMP_74 = CONVERT 0 to address
TMP_75(bool) = newContractAddr == TMP_74
CONDITION TMP_75""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: THROW 5
""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
tokens = balances[msg.sender]

IRs:
REF_31(uint256) -> balances[msg.sender]
tokens(uint256) := REF_31(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
tokens == 0

IRs:
TMP_76(bool) = tokens == 0
CONDITION TMP_76""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: THROW 9
""];
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
balances[msg.sender] = 0

IRs:
REF_32(uint256) -> balances[msg.sender]
REF_32(uint256) (->balances) := 0(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
tokenMigrated = safeAdd(tokenMigrated,tokens)

IRs:
TMP_77(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(tokenMigrated,tokens)
tokenMigrated(uint256) := TMP_77(uint256)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
newContract = IMigrationContract(newContractAddr)

IRs:
TMP_78 = CONVERT newContractAddr to IMigrationContract
newContract(IMigrationContract) := TMP_78(IMigrationContract)""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
! newContract.migrate(msg.sender,tokens)

IRs:
TMP_79(bool) = HIGH_LEVEL_CALL, dest:newContract(IMigrationContract), function:migrate, arguments:['msg.sender', 'tokens']  
TMP_80 = UnaryType.BANG TMP_79 
CONDITION TMP_80""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: THROW 15
""];
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
Migrate(msg.sender,tokens)

IRs:
Emit Migrate(msg.sender,tokens)""];
}
",1,0,0,0,"isFunding;;;newContractAddr == address(0x0);;;tokens = balances[msg.sender];tokens == 0;;;balances[msg.sender] = 0;tokenMigrated = safeAdd(tokenMigrated,tokens);newContract = IMigrationContract(newContractAddr);! newContract.migrate(msg.sender,tokens);;;Migrate(msg.sender,tokens)"
./0x01d6208f95cf2292c350fc8bb1b1f29230352675_ext.sol,DRCWalletManager.withdrawWithFee,650,653,"REF_124(DRCWalletManager.DepositRepository) -> depositRepos[_deposit],REF_125(DRCWalletManager.WithdrawWallet[]) -> REF_124.withdrawWallets,withdrawWalletList(DRCWalletManager.WithdrawWallet[]) = ['REF_125(DRCWalletManager.WithdrawWallet[])'],REF_126(DRCWalletManager.WithdrawWallet) -> withdrawWalletList[0],REF_127(bytes32) -> REF_126.name,REF_128(DRCWalletManager.WithdrawWallet) -> withdrawWalletList[0],REF_129(address) -> REF_128.walletAddr,TMP_319(bool) = INTERNAL_CALL, DRCWalletManager.withdrawWithFee(address,uint256,bytes32,address,uint256,bool)(_deposit,_time,REF_127,REF_129,_value,_check),RETURN TMP_319,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
withdrawWalletList = depositRepos[_deposit].withdrawWallets

IRs:
REF_124(DRCWalletManager.DepositRepository) -> depositRepos[_deposit]
REF_125(DRCWalletManager.WithdrawWallet[]) -> REF_124.withdrawWallets
withdrawWalletList(DRCWalletManager.WithdrawWallet[]) = ['REF_125(DRCWalletManager.WithdrawWallet[])']""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
withdrawWithFee(_deposit,_time,withdrawWalletList[0].name,withdrawWalletList[0].walletAddr,_value,_check)

IRs:
REF_126(DRCWalletManager.WithdrawWallet) -> withdrawWalletList[0]
REF_127(bytes32) -> REF_126.name
REF_128(DRCWalletManager.WithdrawWallet) -> withdrawWalletList[0]
REF_129(address) -> REF_128.walletAddr
TMP_319(bool) = INTERNAL_CALL, DRCWalletManager.withdrawWithFee(address,uint256,bytes32,address,uint256,bool)(_deposit,_time,REF_127,REF_129,_value,_check)
RETURN TMP_319""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
3->1;
}
",1,0,0,0,"onlyOwner();withdrawWalletList = depositRepos[_deposit].withdrawWallets;withdrawWithFee(_deposit,_time,withdrawWalletList[0].name,withdrawWalletList[0].walletAddr,_value,_check)"
./0x1dd6363c7f7a3150fb7ab13c29fe92f5bab23457_ext.sol,CharityProject.withdrawTokens,393,403,"TMP_98(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['_to', '_value']  ,TMP_99(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['withdrawn', '_value'] ,withdrawn(uint256) := TMP_99(uint256),MODIFIER_CALL, RBACManager.onlyOwnerOrManager()(),MODIFIER_CALL, CharityProject.canWithdraw()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
token.transfer(_to,_value)

IRs:
TMP_98(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['_to', '_value']  ""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
withdrawn = withdrawn.add(_value)

IRs:
TMP_99(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['withdrawn', '_value'] 
withdrawn(uint256) := TMP_99(uint256)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwnerOrManager()

IRs:
MODIFIER_CALL, RBACManager.onlyOwnerOrManager()()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
canWithdraw()

IRs:
MODIFIER_CALL, CharityProject.canWithdraw()()""];
4->1;
}
",1,0,0,0,"onlyOwnerOrManager();token.transfer(_to,_value);withdrawn = withdrawn.add(_value);canWithdraw()"
./0x486681bb877703e4385c8fe9688bff776cbc11c4_ext.sol,Escapable.escapeHatch,793,810,"REF_64(bool) -> escapeBlacklist[_token],TMP_172(bool) = REF_64 == False,TMP_173(None) = SOLIDITY_CALL require(bool)(TMP_172),TMP_174(bool) = _token == 0,CONDITION TMP_174,REF_65(uint256) = SOLIDITY_CALL balance(address)(this),balance(uint256) := REF_65([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B7088130>]),Transfer dest:escapeHatchDestination value:balance,Emit EscapeHatchCalled(_token,balance),TMP_177 = CONVERT _token to ERC20,token(ERC20) := TMP_177(ERC20),TMP_178(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_178(uint256),TMP_179(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['escapeHatchDestination', 'balance']  ,Emit EscapeHatchCalled(_token,balance),MODIFIER_CALL, Escapable.onlyEscapeHatchCallerOrOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->13;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(escapeBlacklist[_token] == false)

IRs:
REF_64(bool) -> escapeBlacklist[_token]
TMP_172(bool) = REF_64 == False
TMP_173(None) = SOLIDITY_CALL require(bool)(TMP_172)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_token == 0x0

IRs:
TMP_174(bool) = _token == 0
CONDITION TMP_174""];
3->4[label=""True""];
3->8[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balance = this.balance

IRs:
REF_65(uint256) = SOLIDITY_CALL balance(address)(this)
balance(uint256) := REF_65([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B7088130>])""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
escapeHatchDestination.transfer(balance)

IRs:
Transfer dest:escapeHatchDestination value:balance""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
EscapeHatchCalled(_token,balance)

IRs:
Emit EscapeHatchCalled(_token,balance)""];
6->7;
7[label=""Node Type: RETURN 7
""];
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
token = ERC20(_token)

IRs:
TMP_177 = CONVERT _token to ERC20
token(ERC20) := TMP_177(ERC20)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_178(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_178(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
token.transfer(escapeHatchDestination,balance)

IRs:
TMP_179(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['escapeHatchDestination', 'balance']  ""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
EscapeHatchCalled(_token,balance)

IRs:
Emit EscapeHatchCalled(_token,balance)""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
onlyEscapeHatchCallerOrOwner()

IRs:
MODIFIER_CALL, Escapable.onlyEscapeHatchCallerOrOwner()()""];
13->1;
}
",1,0,1,0,"onlyEscapeHatchCallerOrOwner();require(bool)(escapeBlacklist[_token] == false);;_token == 0x0;balance = this.balance;;escapeHatchDestination.transfer(balance);EscapeHatchCalled(_token,balance);;token = ERC20(_token);balance = token.balanceOf(this);token.transfer(escapeHatchDestination,balance);EscapeHatchCalled(_token,balance)"
./0x0e54b1b8ff833b5f2b0d17453d97d340cb7576e4_ext.sol,ERC223Token.transfer,89,102,"TMP_24(bool) = INTERNAL_CALL, ERC223Token.isContract(address)(_to),CONDITION TMP_24,TMP_25(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(msg.sender),TMP_26(bool) = TMP_25 < _value,CONDITION TMP_26,TMP_27(None) = SOLIDITY_CALL revert()(),REF_1(uint256) -> balances[msg.sender],TMP_28(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(msg.sender),TMP_29(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(TMP_28,_value),REF_1(uint256) (->balances) := TMP_29(uint256),REF_2(uint256) -> balances[_to],TMP_30(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(_to),TMP_31(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(TMP_30,_value),REF_2(uint256) (->balances) := TMP_31(uint256),TMP_33(bytes32) = SOLIDITY_CALL keccak256()(_custom_fallback),TMP_34 = CONVERT TMP_33 to bytes4,TMP_35(bool) = LOW_LEVEL_CALL, dest:_to, function:call, arguments:['TMP_34', 'msg.sender', '_value', '_data'] value:0 ,TMP_36(None) = SOLIDITY_CALL assert(bool)(TMP_35),Emit Transfer(msg.sender,_to,_value,_data),RETURN True,TMP_38(bool) = INTERNAL_CALL, ERC223Token.transferToAddress(address,uint256,bytes)(_to,_value,_data),RETURN TMP_38,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
isContract(_to)

IRs:
TMP_24(bool) = INTERNAL_CALL, ERC223Token.isContract(address)(_to)
CONDITION TMP_24""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
balanceOf(msg.sender) < _value

IRs:
TMP_25(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(msg.sender)
TMP_26(bool) = TMP_25 < _value
CONDITION TMP_26""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
revert()()

IRs:
TMP_27(None) = SOLIDITY_CALL revert()()""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[msg.sender] = safeSub(balanceOf(msg.sender),_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_28(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(msg.sender)
TMP_29(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(TMP_28,_value)
REF_1(uint256) (->balances) := TMP_29(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[_to] = safeAdd(balanceOf(_to),_value)

IRs:
REF_2(uint256) -> balances[_to]
TMP_30(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(_to)
TMP_31(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(TMP_30,_value)
REF_2(uint256) (->balances) := TMP_31(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(_to.call.value(0)(bytes4(keccak256()(_custom_fallback)),msg.sender,_value,_data))

IRs:
TMP_33(bytes32) = SOLIDITY_CALL keccak256()(_custom_fallback)
TMP_34 = CONVERT TMP_33 to bytes4
TMP_35(bool) = LOW_LEVEL_CALL, dest:_to, function:call, arguments:['TMP_34', 'msg.sender', '_value', '_data'] value:0 
TMP_36(None) = SOLIDITY_CALL assert(bool)(TMP_35)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(msg.sender,_to,_value,_data)

IRs:
Emit Transfer(msg.sender,_to,_value,_data)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: RETURN 10

EXPRESSION:
transferToAddress(_to,_value,_data)

IRs:
TMP_38(bool) = INTERNAL_CALL, ERC223Token.transferToAddress(address,uint256,bytes)(_to,_value,_data)
RETURN TMP_38""];
12[label=""Node Type: RETURN 12

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,1,0,0,"isContract(_to);balanceOf(msg.sender) < _value;transferToAddress(_to,_value,_data);revert()();;balances[msg.sender] = safeSub(balanceOf(msg.sender),_value);balances[_to] = safeAdd(balanceOf(_to),_value);assert(bool)(_to.call.value(0)(bytes4(keccak256()(_custom_fallback)),msg.sender,_value,_data));Transfer(msg.sender,_to,_value,_data);true;success"
./0xaa63c8683647ef91b3fdab4b4989ee9588da297b_ext.sol,DSProxy.setCache,134,143,"TMP_35(bool) = _cacheAddr != 0,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),TMP_37 = CONVERT _cacheAddr to DSProxyCache,cache(DSProxyCache) := TMP_37(DSProxyCache),RETURN True,MODIFIER_CALL, DSAuth.auth()(),MODIFIER_CALL, DSNote.note()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_cacheAddr != 0x0)

IRs:
TMP_35(bool) = _cacheAddr != 0
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
cache = DSProxyCache(_cacheAddr)

IRs:
TMP_37 = CONVERT _cacheAddr to DSProxyCache
cache(DSProxyCache) := TMP_37(DSProxyCache)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
note()

IRs:
MODIFIER_CALL, DSNote.note()()""];
5->1;
}
",1,0,0,0,auth();require(bool)(_cacheAddr != 0x0);cache = DSProxyCache(_cacheAddr);true;note()
./0xef86db910c71ffa3c80233bc9108dc51ad1e008a_ext.sol,CommonWallet.depoToken,37,42,"TMP_6 = CONVERT tokenAddr to ERC20Token,TMP_7(bool) = HIGH_LEVEL_CALL, dest:TMP_6(ERC20Token), function:transferFrom, arguments:['msg.sender', 'this', 'amount']  ,CONDITION TMP_7,REF_2(mapping(address => uint256)) -> tokenBalance[tokenAddr],REF_3(uint256) -> REF_2[msg.sender],REF_4(mapping(address => uint256)) -> tokenBalance[tokenAddr],REF_5(uint256) -> REF_4[msg.sender],TMP_8(uint256) = INTERNAL_CALL, CommonWallet.safeAdd(uint256,uint256)(REF_5,amount),REF_3(uint256) (->tokenBalance) := TMP_8(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
ERC20Token(tokenAddr).transferFrom(msg.sender,this,amount)

IRs:
TMP_6 = CONVERT tokenAddr to ERC20Token
TMP_7(bool) = HIGH_LEVEL_CALL, dest:TMP_6(ERC20Token), function:transferFrom, arguments:['msg.sender', 'this', 'amount']  
CONDITION TMP_7""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
tokenBalance[tokenAddr][msg.sender] = safeAdd(tokenBalance[tokenAddr][msg.sender],amount)

IRs:
REF_2(mapping(address => uint256)) -> tokenBalance[tokenAddr]
REF_3(uint256) -> REF_2[msg.sender]
REF_4(mapping(address => uint256)) -> tokenBalance[tokenAddr]
REF_5(uint256) -> REF_4[msg.sender]
TMP_8(uint256) = INTERNAL_CALL, CommonWallet.safeAdd(uint256,uint256)(REF_5,amount)
REF_3(uint256) (->tokenBalance) := TMP_8(uint256)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",1,0,0,0,"ERC20Token(tokenAddr).transferFrom(msg.sender,this,amount);tokenBalance[tokenAddr][msg.sender] = safeAdd(tokenBalance[tokenAddr][msg.sender],amount);"
./0xcef8feebbdc278c0c81e07b87abf96b22d08fa6e_ext.sol,UnicornRefunds.claimReward,79,91,"TMP_17 = CONVERT unicornRanchAddress to UnicornRanch,ranch(UnicornRanch) := TMP_17(UnicornRanch),TUPLE_0(uint256,UnicornRanch.VisitType,uint256,uint256,UnicornRanch.VisitState,uint256,uint256) = HIGH_LEVEL_CALL, dest:ranch(UnicornRanch), function:getBooking, arguments:['msg.sender', '_bookingIndex']  ,unicornCount(uint256)= UNPACK TUPLE_0 index: 0 ,visitType(UnicornRanch.VisitType)= UNPACK TUPLE_0 index: 1 ,state(UnicornRanch.VisitState)= UNPACK TUPLE_0 index: 4 ,completedCount(uint256)= UNPACK TUPLE_0 index: 6 ,REF_1(UnicornRanch.VisitState) -> VisitState.Completed,TMP_18(bool) = state == REF_1,TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18),REF_2(UnicornRanch.VisitType) -> VisitType.Spa,TMP_20(bool) = visitType != REF_2,TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20),TMP_22(bool) = completedCount > unicornCount,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_3(bool) -> rewardClaimed[msg.sender],TMP_24(bool) = REF_3 == False,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_4(bool) -> rewardClaimed[msg.sender],REF_4(bool) (->rewardClaimed) := True(bool),REF_5(uint256) -> allowedAmounts[msg.sender],REF_6(uint256) -> allowedAmounts[msg.sender],TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_6', 'rewardUnicornAmount'] ,REF_5(uint256) (->allowedAmounts) := TMP_26(uint256),Emit RewardClaimed(msg.sender,_bookingIndex)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
ranch = UnicornRanch(unicornRanchAddress)

IRs:
TMP_17 = CONVERT unicornRanchAddress to UnicornRanch
ranch(UnicornRanch) := TMP_17(UnicornRanch)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: NEW VARIABLE 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
(unicornCount,visitType,None,None,state,None,completedCount) = ranch.getBooking(msg.sender,_bookingIndex)

IRs:
TUPLE_0(uint256,UnicornRanch.VisitType,uint256,uint256,UnicornRanch.VisitState,uint256,uint256) = HIGH_LEVEL_CALL, dest:ranch(UnicornRanch), function:getBooking, arguments:['msg.sender', '_bookingIndex']  
unicornCount(uint256)= UNPACK TUPLE_0 index: 0 
visitType(UnicornRanch.VisitType)= UNPACK TUPLE_0 index: 1 
state(UnicornRanch.VisitState)= UNPACK TUPLE_0 index: 4 
completedCount(uint256)= UNPACK TUPLE_0 index: 6 ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(state == UnicornRanch.VisitState.Completed)

IRs:
REF_1(UnicornRanch.VisitState) -> VisitState.Completed
TMP_18(bool) = state == REF_1
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(visitType != UnicornRanch.VisitType.Spa)

IRs:
REF_2(UnicornRanch.VisitType) -> VisitType.Spa
TMP_20(bool) = visitType != REF_2
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(completedCount > unicornCount)

IRs:
TMP_22(bool) = completedCount > unicornCount
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(rewardClaimed[msg.sender] == false)

IRs:
REF_3(bool) -> rewardClaimed[msg.sender]
TMP_24(bool) = REF_3 == False
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
rewardClaimed[msg.sender] = true

IRs:
REF_4(bool) -> rewardClaimed[msg.sender]
REF_4(bool) (->rewardClaimed) := True(bool)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
allowedAmounts[msg.sender] = allowedAmounts[msg.sender].add(rewardUnicornAmount)

IRs:
REF_5(uint256) -> allowedAmounts[msg.sender]
REF_6(uint256) -> allowedAmounts[msg.sender]
TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_6', 'rewardUnicornAmount'] 
REF_5(uint256) (->allowedAmounts) := TMP_26(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
RewardClaimed(msg.sender,_bookingIndex)

IRs:
Emit RewardClaimed(msg.sender,_bookingIndex)""];
}
",1,0,0,0,"ranch = UnicornRanch(unicornRanchAddress);;;;;(unicornCount,visitType,None,None,state,None,completedCount) = ranch.getBooking(msg.sender,_bookingIndex);require(bool)(state == UnicornRanch.VisitState.Completed);require(bool)(visitType != UnicornRanch.VisitType.Spa);require(bool)(completedCount > unicornCount);require(bool)(rewardClaimed[msg.sender] == false);rewardClaimed[msg.sender] = true;allowedAmounts[msg.sender] = allowedAmounts[msg.sender].add(rewardUnicornAmount);RewardClaimed(msg.sender,_bookingIndex)"
./0x58c3069023ed736f430d585003715058c2e3c671_ext.sol,BTCPayment.addPayment,284,295,"TMP_73 = UnaryType.BANG presaleFallBackCalled ,CONDITION TMP_73,HIGH_LEVEL_CALL, dest:presale(PaymentFallbackReceiver), function:paymentFallBack, arguments:['_beneficiary', '_tokens']  ,HIGH_LEVEL_CALL, dest:mainsale(PaymentFallbackReceiver), function:paymentFallBack, arguments:['_beneficiary', '_tokens']  ,Emit NewPayment(_beneficiary,_tokens),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: IF 1

EXPRESSION:
! presaleFallBackCalled

IRs:
TMP_73 = UnaryType.BANG presaleFallBackCalled 
CONDITION TMP_73""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
presale.paymentFallBack(_beneficiary,_tokens)

IRs:
HIGH_LEVEL_CALL, dest:presale(PaymentFallbackReceiver), function:paymentFallBack, arguments:['_beneficiary', '_tokens']  ""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
mainsale.paymentFallBack(_beneficiary,_tokens)

IRs:
HIGH_LEVEL_CALL, dest:mainsale(PaymentFallbackReceiver), function:paymentFallBack, arguments:['_beneficiary', '_tokens']  ""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
NewPayment(_beneficiary,_tokens)

IRs:
Emit NewPayment(_beneficiary,_tokens)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",1,0,0,0,"onlyOwner();! presaleFallBackCalled;presale.paymentFallBack(_beneficiary,_tokens);mainsale.paymentFallBack(_beneficiary,_tokens);;NewPayment(_beneficiary,_tokens)"
./0x5a6d9a69408ce19df15eb40347ded3028a77fcca_ext.sol,EthicHubLending.saveInitialParametersToStorage,324,339,"TMP_95(bool) = _maxDelayDays != 0,TMP_96(None) = SOLIDITY_CALL require(bool)(TMP_95),REF_3(EthicHubLending.LendingState) -> LendingState.Uninitialized,TMP_97(bool) = state == REF_3,TMP_98(None) = SOLIDITY_CALL require(bool)(TMP_97),TMP_99(bool) = _tier > 0,TMP_100(None) = SOLIDITY_CALL require(bool)(TMP_99),TMP_101(bool) = _communityMembers > 0,TMP_102(None) = SOLIDITY_CALL require(bool)(TMP_101),TMP_103(bytes32) = SOLIDITY_CALL keccak256()(user,community,_community),TMP_104(bool) = HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:getBool, arguments:['TMP_103']  ,TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104),TMP_106(bytes32) = SOLIDITY_CALL keccak256()(lending.maxDelayDays,this),HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:setUint, arguments:['TMP_106', '_maxDelayDays']  ,TMP_108(bytes32) = SOLIDITY_CALL keccak256()(lending.community,this),HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:setAddress, arguments:['TMP_108', '_community']  ,TMP_110(bytes32) = SOLIDITY_CALL keccak256()(lending.localNode,this),HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:setAddress, arguments:['TMP_110', 'localNode']  ,TMP_112(bytes32) = SOLIDITY_CALL keccak256()(lending.tier,this),HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:setUint, arguments:['TMP_112', '_tier']  ,TMP_114(bytes32) = SOLIDITY_CALL keccak256()(lending.communityMembers,this),HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:setUint, arguments:['TMP_114', '_communityMembers']  ,tier(uint256) := _tier(uint256),REF_10(EthicHubLending.LendingState) -> LendingState.AcceptingContributions,state(EthicHubLending.LendingState) := REF_10(EthicHubLending.LendingState),TMP_116 = CONVERT state to uint256,Emit StateChange(TMP_116),MODIFIER_CALL, EthicHubLending.onlyOwnerOrLocalNode()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_maxDelayDays != 0)

IRs:
TMP_95(bool) = _maxDelayDays != 0
TMP_96(None) = SOLIDITY_CALL require(bool)(TMP_95)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(state == LendingState.Uninitialized)

IRs:
REF_3(EthicHubLending.LendingState) -> LendingState.Uninitialized
TMP_97(bool) = state == REF_3
TMP_98(None) = SOLIDITY_CALL require(bool)(TMP_97)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_tier > 0)

IRs:
TMP_99(bool) = _tier > 0
TMP_100(None) = SOLIDITY_CALL require(bool)(TMP_99)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_communityMembers > 0)

IRs:
TMP_101(bool) = _communityMembers > 0
TMP_102(None) = SOLIDITY_CALL require(bool)(TMP_101)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(ethicHubStorage.getBool(keccak256()(user,community,_community)))

IRs:
TMP_103(bytes32) = SOLIDITY_CALL keccak256()(user,community,_community)
TMP_104(bool) = HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:getBool, arguments:['TMP_103']  
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
ethicHubStorage.setUint(keccak256()(lending.maxDelayDays,this),_maxDelayDays)

IRs:
TMP_106(bytes32) = SOLIDITY_CALL keccak256()(lending.maxDelayDays,this)
HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:setUint, arguments:['TMP_106', '_maxDelayDays']  ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
ethicHubStorage.setAddress(keccak256()(lending.community,this),_community)

IRs:
TMP_108(bytes32) = SOLIDITY_CALL keccak256()(lending.community,this)
HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:setAddress, arguments:['TMP_108', '_community']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ethicHubStorage.setAddress(keccak256()(lending.localNode,this),localNode)

IRs:
TMP_110(bytes32) = SOLIDITY_CALL keccak256()(lending.localNode,this)
HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:setAddress, arguments:['TMP_110', 'localNode']  ""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
ethicHubStorage.setUint(keccak256()(lending.tier,this),_tier)

IRs:
TMP_112(bytes32) = SOLIDITY_CALL keccak256()(lending.tier,this)
HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:setUint, arguments:['TMP_112', '_tier']  ""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
ethicHubStorage.setUint(keccak256()(lending.communityMembers,this),_communityMembers)

IRs:
TMP_114(bytes32) = SOLIDITY_CALL keccak256()(lending.communityMembers,this)
HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:setUint, arguments:['TMP_114', '_communityMembers']  ""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
tier = _tier

IRs:
tier(uint256) := _tier(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
state = LendingState.AcceptingContributions

IRs:
REF_10(EthicHubLending.LendingState) -> LendingState.AcceptingContributions
state(EthicHubLending.LendingState) := REF_10(EthicHubLending.LendingState)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
StateChange(uint256(state))

IRs:
TMP_116 = CONVERT state to uint256
Emit StateChange(TMP_116)""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
onlyOwnerOrLocalNode()

IRs:
MODIFIER_CALL, EthicHubLending.onlyOwnerOrLocalNode()()""];
14->1;
}
",1,0,0,0,"onlyOwnerOrLocalNode();require(bool)(_maxDelayDays != 0);require(bool)(state == LendingState.Uninitialized);require(bool)(_tier > 0);require(bool)(_communityMembers > 0);require(bool)(ethicHubStorage.getBool(keccak256()(user,community,_community)));ethicHubStorage.setUint(keccak256()(lending.maxDelayDays,this),_maxDelayDays);ethicHubStorage.setAddress(keccak256()(lending.community,this),_community);ethicHubStorage.setAddress(keccak256()(lending.localNode,this),localNode);ethicHubStorage.setUint(keccak256()(lending.tier,this),_tier);ethicHubStorage.setUint(keccak256()(lending.communityMembers,this),_communityMembers);tier = _tier;state = LendingState.AcceptingContributions;StateChange(uint256(state))"
./0x750c1d91864171d7e1715a6b53ee28c72b8faa09_ext.sol,EthicHubUser.unregisterPaymentGateway,266,275,"TMP_125 = CONVERT 0 to address,TMP_126(bool) = target != TMP_125,TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126),TMP_128(bytes32) = SOLIDITY_CALL keccak256()(user,paymentGateway,target),TMP_129(bool) = HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:getBool, arguments:['TMP_128']  ,isRegistered(bool) := TMP_129(bool),CONDITION isRegistered,INTERNAL_CALL, EthicHubUser.deleteUserStatus(address,string)(target,paymentGateway),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(target != address(0))

IRs:
TMP_125 = CONVERT 0 to address
TMP_126(bool) = target != TMP_125
TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
isRegistered = ethicHubStorage.getBool(keccak256()(user,paymentGateway,target))

IRs:
TMP_128(bytes32) = SOLIDITY_CALL keccak256()(user,paymentGateway,target)
TMP_129(bool) = HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:getBool, arguments:['TMP_128']  
isRegistered(bool) := TMP_129(bool)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
isRegistered

IRs:
CONDITION isRegistered""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
deleteUserStatus(target,paymentGateway)

IRs:
INTERNAL_CALL, EthicHubUser.deleteUserStatus(address,string)(target,paymentGateway)""];
4->5;
5[label=""Node Type: END_IF 5
""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",1,0,0,0,"onlyOwner();require(bool)(target != address(0));isRegistered = ethicHubStorage.getBool(keccak256()(user,paymentGateway,target));isRegistered;deleteUserStatus(target,paymentGateway);"
./0x330bebabc9a2a4136e3d1cb38ca521f5a95aec2e_ext.sol,KoreaShow.claimTokens,664,674,"TMP_184(bool) = _token == 0,CONDITION TMP_184,REF_72(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:controller value:REF_72,TMP_186 = CONVERT _token to ERC20Token,token(ERC20Token) := TMP_186(ERC20Token),TMP_187(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_187(uint256),TMP_188(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:transfer, arguments:['controller', 'balance']  ,Emit ClaimedTokens(_token,controller,balance),MODIFIER_CALL, Controlled.onlyController()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_184(bool) = _token == 0
CONDITION TMP_184""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_72(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_72""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
token = ERC20Token(_token)

IRs:
TMP_186 = CONVERT _token to ERC20Token
token(ERC20Token) := TMP_186(ERC20Token)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_187(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_187(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_188(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:transfer, arguments:['controller', 'balance']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()""];
9->1;
}
",1,0,1,0,"onlyController();_token == 0x0;controller.transfer(this.balance);;;token = ERC20Token(_token);balance = token.balanceOf(this);token.transfer(controller,balance);ClaimedTokens(_token,controller,balance)"
./0x025dce2d39a46296766db7cac8c322e8f59cd5d9_ext.sol,EthToSmthSwaps.close,155,162,"REF_41(mapping(address => EthToSmthSwaps.Swap)) -> swaps[msg.sender],REF_42(EthToSmthSwaps.Swap) -> REF_41[_participantAddress],REF_43(uint256) -> REF_42.balance,TMP_45(bool) = REF_43 == 0,TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45),TMP_47 = CONVERT ratingContractAddress to Reputation,HIGH_LEVEL_CALL, dest:TMP_47(Reputation), function:change, arguments:['msg.sender', '1']  ,INTERNAL_CALL, EthToSmthSwaps.clean(address,address)(msg.sender,_participantAddress),Emit Close()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(swaps[msg.sender][_participantAddress].balance == 0)

IRs:
REF_41(mapping(address => EthToSmthSwaps.Swap)) -> swaps[msg.sender]
REF_42(EthToSmthSwaps.Swap) -> REF_41[_participantAddress]
REF_43(uint256) -> REF_42.balance
TMP_45(bool) = REF_43 == 0
TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Reputation(ratingContractAddress).change(msg.sender,1)

IRs:
TMP_47 = CONVERT ratingContractAddress to Reputation
HIGH_LEVEL_CALL, dest:TMP_47(Reputation), function:change, arguments:['msg.sender', '1']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
clean(msg.sender,_participantAddress)

IRs:
INTERNAL_CALL, EthToSmthSwaps.clean(address,address)(msg.sender,_participantAddress)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Close()

IRs:
Emit Close()""];
}
",1,0,0,0,"require(bool)(swaps[msg.sender][_participantAddress].balance == 0);Reputation(ratingContractAddress).change(msg.sender,1);clean(msg.sender,_participantAddress);Close()"
./0x486cf19a550e2814aef970b14e509e93209a0151_ext.sol,EventChainCrowdsale.mintFounderTokens,426,432,"TMP_191(bool) = HIGH_LEVEL_CALL, dest:evc(EventChain), function:mintAgents, arguments:['this']  ,TMP_192(None) = SOLIDITY_CALL assert(bool)(TMP_191),HIGH_LEVEL_CALL, dest:evc(EventChain), function:mint, arguments:['beneficiary', '29400000000000000000000000']  ,REF_104(EventChainCrowdsale.State) -> State.Prepared,currentState(EventChainCrowdsale.State) := REF_104(EventChainCrowdsale.State),REF_105(EventChainCrowdsale.State) -> State.Preparing,Emit StateChanged(REF_105,currentState),MODIFIER_CALL, Ownable.onlyOwner()(),REF_106(EventChainCrowdsale.State) -> State.Preparing,MODIFIER_CALL, EventChainCrowdsale.inState(EventChainCrowdsale.State)(REF_106)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(evc.mintAgents(this))

IRs:
TMP_191(bool) = HIGH_LEVEL_CALL, dest:evc(EventChain), function:mintAgents, arguments:['this']  
TMP_192(None) = SOLIDITY_CALL assert(bool)(TMP_191)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
evc.mint(beneficiary,29400000000000000000000000)

IRs:
HIGH_LEVEL_CALL, dest:evc(EventChain), function:mint, arguments:['beneficiary', '29400000000000000000000000']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
currentState = State.Prepared

IRs:
REF_104(EventChainCrowdsale.State) -> State.Prepared
currentState(EventChainCrowdsale.State) := REF_104(EventChainCrowdsale.State)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
StateChanged(State.Preparing,currentState)

IRs:
REF_105(EventChainCrowdsale.State) -> State.Preparing
Emit StateChanged(REF_105,currentState)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
inState(State.Preparing)

IRs:
REF_106(EventChainCrowdsale.State) -> State.Preparing
MODIFIER_CALL, EventChainCrowdsale.inState(EventChainCrowdsale.State)(REF_106)""];
6->1;
}
",1,0,0,0,"onlyOwner();assert(bool)(evc.mintAgents(this));evc.mint(beneficiary,29400000000000000000000000);currentState = State.Prepared;StateChanged(State.Preparing,currentState);inState(State.Preparing)"
./0x020ddc98365d0199b4c7a2d769d685480789f67e_ext.sol,EOSclassic.claimEOSclassic,394,397,"TMP_116(bool) = INTERNAL_CALL, EOSclassic.claimEOSclassicFor(address)(msg.sender),RETURN TMP_116","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
claimEOSclassicFor(msg.sender)

IRs:
TMP_116(bool) = INTERNAL_CALL, EOSclassic.claimEOSclassicFor(address)(msg.sender)
RETURN TMP_116""];
}
",1,0,0,0,claimEOSclassicFor(msg.sender)
./0x486681bb877703e4385c8fe9688bff776cbc11c4_ext.sol,Escapable.escapeHatch,793,810,"REF_64(bool) -> escapeBlacklist[_token],TMP_172(bool) = REF_64 == False,TMP_173(None) = SOLIDITY_CALL require(bool)(TMP_172),TMP_174(bool) = _token == 0,CONDITION TMP_174,REF_65(uint256) = SOLIDITY_CALL balance(address)(this),balance(uint256) := REF_65([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E3F9FA60>]),Transfer dest:escapeHatchDestination value:balance,Emit EscapeHatchCalled(_token,balance),TMP_177 = CONVERT _token to ERC20,token(ERC20) := TMP_177(ERC20),TMP_178(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_178(uint256),TMP_179(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['escapeHatchDestination', 'balance']  ,Emit EscapeHatchCalled(_token,balance),MODIFIER_CALL, Escapable.onlyEscapeHatchCallerOrOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->13;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(escapeBlacklist[_token] == false)

IRs:
REF_64(bool) -> escapeBlacklist[_token]
TMP_172(bool) = REF_64 == False
TMP_173(None) = SOLIDITY_CALL require(bool)(TMP_172)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_token == 0x0

IRs:
TMP_174(bool) = _token == 0
CONDITION TMP_174""];
3->4[label=""True""];
3->8[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balance = this.balance

IRs:
REF_65(uint256) = SOLIDITY_CALL balance(address)(this)
balance(uint256) := REF_65([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E3F9FA60>])""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
escapeHatchDestination.transfer(balance)

IRs:
Transfer dest:escapeHatchDestination value:balance""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
EscapeHatchCalled(_token,balance)

IRs:
Emit EscapeHatchCalled(_token,balance)""];
6->7;
7[label=""Node Type: RETURN 7
""];
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
token = ERC20(_token)

IRs:
TMP_177 = CONVERT _token to ERC20
token(ERC20) := TMP_177(ERC20)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_178(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_178(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
token.transfer(escapeHatchDestination,balance)

IRs:
TMP_179(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['escapeHatchDestination', 'balance']  ""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
EscapeHatchCalled(_token,balance)

IRs:
Emit EscapeHatchCalled(_token,balance)""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
onlyEscapeHatchCallerOrOwner()

IRs:
MODIFIER_CALL, Escapable.onlyEscapeHatchCallerOrOwner()()""];
13->1;
}
",1,0,1,0,"onlyEscapeHatchCallerOrOwner();require(bool)(escapeBlacklist[_token] == false);;_token == 0x0;balance = this.balance;;escapeHatchDestination.transfer(balance);EscapeHatchCalled(_token,balance);;token = ERC20(_token);balance = token.balanceOf(this);token.transfer(escapeHatchDestination,balance);EscapeHatchCalled(_token,balance)"
./0x4d2d7ea45162b91f0e584463ed2afb54ca558cb4_ext.sol,Crowdsale.buyTokens,107,124,"TMP_23(bool) = beneficiary != 0,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),TMP_25(bool) = INTERNAL_CALL, Crowdsale.validPurchase()(),TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),weiAmount(uint256) := msg.value(uint256),TMP_27(uint256) = weiAmount * price,tokens(uint256) := TMP_27(uint256),TMP_28(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] ,weiRaised(uint256) := TMP_28(uint256),HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['beneficiary', 'tokens']  ,Emit TokenPurchase(msg.sender,beneficiary,weiAmount,tokens),INTERNAL_CALL, Crowdsale.forwardFunds()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != 0x0)

IRs:
TMP_23(bool) = beneficiary != 0
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(validPurchase())

IRs:
TMP_25(bool) = INTERNAL_CALL, Crowdsale.validPurchase()()
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
tokens = (weiAmount) * price

IRs:
TMP_27(uint256) = weiAmount * price
tokens(uint256) := TMP_27(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_28(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_28(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tokenReward.transfer(beneficiary,tokens)

IRs:
HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['beneficiary', 'tokens']  ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
forwardFunds()

IRs:
INTERNAL_CALL, Crowdsale.forwardFunds()()""];
}
",1,0,0,0,"require(bool)(beneficiary != 0x0);require(bool)(validPurchase());weiAmount = msg.value;tokens = (weiAmount) * price;weiRaised = weiRaised.add(weiAmount);tokenReward.transfer(beneficiary,tokens);TokenPurchase(msg.sender,beneficiary,weiAmount,tokens);forwardFunds()"
./0x26f4fb84b53dff7e148a8196f09bc492e55f2889_ext.sol,TimeLockPool.withdraw,569,597,"TMP_203 = CONVERT 0 to address,TMP_204(bool) = account != TMP_203,TMP_205(None) = SOLIDITY_CALL require(bool)(TMP_204),release_amount(uint256) := 0(uint256),i(uint256) := index_from(uint256),REF_179(mapping(address => TimeLockPool.LockedBalance[])) -> lockedBalances[account],REF_180(TimeLockPool.LockedBalance[]) -> REF_179[tokenAddr],REF_181 -> LENGTH REF_180,TMP_206(bool) = i < REF_181,TMP_207(uint256) = index_to + 1,TMP_208(bool) = i < TMP_207,TMP_209(bool) = TMP_206 && TMP_208,CONDITION TMP_209,REF_182(mapping(address => TimeLockPool.LockedBalance[])) -> lockedBalances[account],REF_183(TimeLockPool.LockedBalance[]) -> REF_182[tokenAddr],REF_184(TimeLockPool.LockedBalance) -> REF_183[i],REF_185(uint256) -> REF_184.balance,TMP_210(bool) = REF_185 > 0,REF_186(mapping(address => TimeLockPool.LockedBalance[])) -> lockedBalances[account],REF_187(TimeLockPool.LockedBalance[]) -> REF_186[tokenAddr],REF_188(TimeLockPool.LockedBalance) -> REF_187[i],REF_189(uint256) -> REF_188.releaseTime,TMP_211(bool) = REF_189 <= block.timestamp,TMP_212(bool) = TMP_210 && TMP_211,CONDITION TMP_212,REF_191(mapping(address => TimeLockPool.LockedBalance[])) -> lockedBalances[account],REF_192(TimeLockPool.LockedBalance[]) -> REF_191[tokenAddr],REF_193(TimeLockPool.LockedBalance) -> REF_192[i],REF_194(uint256) -> REF_193.balance,TMP_213(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['release_amount', 'REF_194'] ,release_amount(uint256) := TMP_213(uint256),REF_195(mapping(address => TimeLockPool.LockedBalance[])) -> lockedBalances[account],REF_196(TimeLockPool.LockedBalance[]) -> REF_195[tokenAddr],REF_197(TimeLockPool.LockedBalance) -> REF_196[i],REF_198(uint256) -> REF_197.balance,REF_198(uint256) (->lockedBalances) := 0(uint256),TMP_214(uint256) := i(uint256),i(uint256) = i + 1,TMP_215(bool) = release_amount > 0,TMP_216(None) = SOLIDITY_CALL require(bool)(TMP_215),TMP_217(bool) = tokenAddr == 0,CONDITION TMP_217,TMP_218 = SEND dest:account value:release_amount,TMP_219 = UnaryType.BANG TMP_218 ,CONDITION TMP_219,TMP_220(None) = SOLIDITY_CALL revert()(),Emit Withdraw(account,tokenAddr,release_amount),RETURN True,TMP_222 = CONVERT tokenAddr to ERC20Interface,TMP_223(bool) = HIGH_LEVEL_CALL, dest:TMP_222(ERC20Interface), function:transfer, arguments:['account', 'release_amount']  ,TMP_224 = UnaryType.BANG TMP_223 ,CONDITION TMP_224,TMP_225(None) = SOLIDITY_CALL revert()(),Emit Withdraw(account,tokenAddr,release_amount),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(account != address(0x0))

IRs:
TMP_203 = CONVERT 0 to address
TMP_204(bool) = account != TMP_203
TMP_205(None) = SOLIDITY_CALL require(bool)(TMP_204)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
release_amount = 0

IRs:
release_amount(uint256) := 0(uint256)""];
2->5;
3[label=""Node Type: BEGIN_LOOP 3
""];
3->6;
4[label=""Node Type: END_LOOP 4
""];
4->12;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
i = index_from

IRs:
i(uint256) := index_from(uint256)""];
5->3;
6[label=""Node Type: IF_LOOP 6

EXPRESSION:
i < lockedBalances[account][tokenAddr].length && i < index_to + 1

IRs:
REF_179(mapping(address => TimeLockPool.LockedBalance[])) -> lockedBalances[account]
REF_180(TimeLockPool.LockedBalance[]) -> REF_179[tokenAddr]
REF_181 -> LENGTH REF_180
TMP_206(bool) = i < REF_181
TMP_207(uint256) = index_to + 1
TMP_208(bool) = i < TMP_207
TMP_209(bool) = TMP_206 && TMP_208
CONDITION TMP_209""];
6->7[label=""True""];
6->4[label=""False""];
7[label=""Node Type: IF 7

EXPRESSION:
lockedBalances[account][tokenAddr][i].balance > 0 && lockedBalances[account][tokenAddr][i].releaseTime <= block.timestamp

IRs:
REF_182(mapping(address => TimeLockPool.LockedBalance[])) -> lockedBalances[account]
REF_183(TimeLockPool.LockedBalance[]) -> REF_182[tokenAddr]
REF_184(TimeLockPool.LockedBalance) -> REF_183[i]
REF_185(uint256) -> REF_184.balance
TMP_210(bool) = REF_185 > 0
REF_186(mapping(address => TimeLockPool.LockedBalance[])) -> lockedBalances[account]
REF_187(TimeLockPool.LockedBalance[]) -> REF_186[tokenAddr]
REF_188(TimeLockPool.LockedBalance) -> REF_187[i]
REF_189(uint256) -> REF_188.releaseTime
TMP_211(bool) = REF_189 <= block.timestamp
TMP_212(bool) = TMP_210 && TMP_211
CONDITION TMP_212""];
7->8[label=""True""];
7->10[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
release_amount = release_amount.add(lockedBalances[account][tokenAddr][i].balance)

IRs:
REF_191(mapping(address => TimeLockPool.LockedBalance[])) -> lockedBalances[account]
REF_192(TimeLockPool.LockedBalance[]) -> REF_191[tokenAddr]
REF_193(TimeLockPool.LockedBalance) -> REF_192[i]
REF_194(uint256) -> REF_193.balance
TMP_213(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['release_amount', 'REF_194'] 
release_amount(uint256) := TMP_213(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
lockedBalances[account][tokenAddr][i].balance = 0

IRs:
REF_195(mapping(address => TimeLockPool.LockedBalance[])) -> lockedBalances[account]
REF_196(TimeLockPool.LockedBalance[]) -> REF_195[tokenAddr]
REF_197(TimeLockPool.LockedBalance) -> REF_196[i]
REF_198(uint256) -> REF_197.balance
REF_198(uint256) (->lockedBalances) := 0(uint256)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_214(uint256) := i(uint256)
i(uint256) = i + 1""];
11->6;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
require(bool)(release_amount > 0)

IRs:
TMP_215(bool) = release_amount > 0
TMP_216(None) = SOLIDITY_CALL require(bool)(TMP_215)""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
tokenAddr == 0x0

IRs:
TMP_217(bool) = tokenAddr == 0
CONDITION TMP_217""];
13->14[label=""True""];
13->19[label=""False""];
14[label=""Node Type: IF 14

EXPRESSION:
! account.send(release_amount)

IRs:
TMP_218 = SEND dest:account value:release_amount
TMP_219 = UnaryType.BANG TMP_218 
CONDITION TMP_219""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
revert()()

IRs:
TMP_220(None) = SOLIDITY_CALL revert()()""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
Withdraw(account,tokenAddr,release_amount)

IRs:
Emit Withdraw(account,tokenAddr,release_amount)""];
17->18;
18[label=""Node Type: RETURN 18

EXPRESSION:
true

IRs:
RETURN True""];
19[label=""Node Type: IF 19

EXPRESSION:
! ERC20Interface(tokenAddr).transfer(account,release_amount)

IRs:
TMP_222 = CONVERT tokenAddr to ERC20Interface
TMP_223(bool) = HIGH_LEVEL_CALL, dest:TMP_222(ERC20Interface), function:transfer, arguments:['account', 'release_amount']  
TMP_224 = UnaryType.BANG TMP_223 
CONDITION TMP_224""];
19->20[label=""True""];
19->21[label=""False""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
revert()()

IRs:
TMP_225(None) = SOLIDITY_CALL revert()()""];
20->21;
21[label=""Node Type: END_IF 21
""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
Withdraw(account,tokenAddr,release_amount)

IRs:
Emit Withdraw(account,tokenAddr,release_amount)""];
22->23;
23[label=""Node Type: RETURN 23

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,"require(bool)(account != address(0x0));release_amount = 0;i = index_from;;i < lockedBalances[account][tokenAddr].length && i < index_to + 1;;require(bool)(release_amount > 0);lockedBalances[account][tokenAddr][i].balance > 0 && lockedBalances[account][tokenAddr][i].releaseTime <= block.timestamp;release_amount = release_amount.add(lockedBalances[account][tokenAddr][i].balance);;lockedBalances[account][tokenAddr][i].balance = 0;i ++;tokenAddr == 0x0;! account.send(release_amount);! ERC20Interface(tokenAddr).transfer(account,release_amount);revert()();;Withdraw(account,tokenAddr,release_amount);true;revert()();;Withdraw(account,tokenAddr,release_amount);true"
./0x574fb6d9d090042a04d0d12a4e87217f8303a5ca_ext.sol,GoldBackedToken.burnTokens,608,615,"TMP_369(bool) = msg.sender == authorisedMinter,TMP_370(None) = SOLIDITY_CALL require(bool)(TMP_369),INTERNAL_CALL, GoldBackedToken.update(address)(source),REF_148(GoldBackedToken.Balance) -> balances[source],REF_149(uint256) -> REF_148.amount,REF_150(GoldBackedToken.Balance) -> balances[source],REF_151(uint256) -> REF_150.amount,TMP_372(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_151,amount),REF_149(uint256) (->balances) := TMP_372(uint256),REF_152(GoldBackedToken.Balance) -> balances[source],REF_153(uint256) -> REF_152.lastUpdated,REF_153(uint256) (->balances) := now(uint256),REF_154(GoldBackedToken.Balance) -> balances[source],REF_155(uint256) -> REF_154.nextAllocationIndex,REF_156 -> LENGTH currentAllocations,REF_155(uint256) (->balances) := REF_156(uint256),Emit TokenBurned(source,amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == authorisedMinter)

IRs:
TMP_369(bool) = msg.sender == authorisedMinter
TMP_370(None) = SOLIDITY_CALL require(bool)(TMP_369)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
update(source)

IRs:
INTERNAL_CALL, GoldBackedToken.update(address)(source)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[source].amount = safeSub(balances[source].amount,amount)

IRs:
REF_148(GoldBackedToken.Balance) -> balances[source]
REF_149(uint256) -> REF_148.amount
REF_150(GoldBackedToken.Balance) -> balances[source]
REF_151(uint256) -> REF_150.amount
TMP_372(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_151,amount)
REF_149(uint256) (->balances) := TMP_372(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[source].lastUpdated = now

IRs:
REF_152(GoldBackedToken.Balance) -> balances[source]
REF_153(uint256) -> REF_152.lastUpdated
REF_153(uint256) (->balances) := now(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[source].nextAllocationIndex = currentAllocations.length

IRs:
REF_154(GoldBackedToken.Balance) -> balances[source]
REF_155(uint256) -> REF_154.nextAllocationIndex
REF_156 -> LENGTH currentAllocations
REF_155(uint256) (->balances) := REF_156(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
TokenBurned(source,amount)

IRs:
Emit TokenBurned(source,amount)""];
}
",1,0,0,0,"require(bool)(msg.sender == authorisedMinter);update(source);balances[source].amount = safeSub(balances[source].amount,amount);balances[source].lastUpdated = now;balances[source].nextAllocationIndex = currentAllocations.length;TokenBurned(source,amount)"
./0x1b6c5864375b34af3ff5bd2e5f40bc425b4a8d79_ext.sol,TopChainCoinDistribution.createTokenToOperation,707,714,"TMP_290 = CONVERT 0 to address,TMP_291(bool) = operationAddress != TMP_290,TMP_292(None) = SOLIDITY_CALL require(bool)(TMP_291),TMP_293(bool) = operationTokenCreated == False,TMP_294(None) = SOLIDITY_CALL require(bool)(TMP_293),operationTokenCreated(bool) := True(bool),TMP_295(bool) = HIGH_LEVEL_CALL, dest:token(TopChainCoin), function:mint, arguments:['operationAddress', 'operationToken']  ,Emit CreateTokenToOperation(operationAddress,operationToken),MODIFIER_CALL, Authorizable.onlyAuthorized()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(operationAddress != address(0))

IRs:
TMP_290 = CONVERT 0 to address
TMP_291(bool) = operationAddress != TMP_290
TMP_292(None) = SOLIDITY_CALL require(bool)(TMP_291)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(operationTokenCreated == false)

IRs:
TMP_293(bool) = operationTokenCreated == False
TMP_294(None) = SOLIDITY_CALL require(bool)(TMP_293)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
operationTokenCreated = true

IRs:
operationTokenCreated(bool) := True(bool)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.mint(operationAddress,operationToken)

IRs:
TMP_295(bool) = HIGH_LEVEL_CALL, dest:token(TopChainCoin), function:mint, arguments:['operationAddress', 'operationToken']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
CreateTokenToOperation(operationAddress,operationToken)

IRs:
Emit CreateTokenToOperation(operationAddress,operationToken)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyAuthorized()

IRs:
MODIFIER_CALL, Authorizable.onlyAuthorized()()""];
6->1;
}
",1,0,0,0,"onlyAuthorized();require(bool)(operationAddress != address(0));require(bool)(operationTokenCreated == false);operationTokenCreated = true;token.mint(operationAddress,operationToken);CreateTokenToOperation(operationAddress,operationToken)"
./0x182f2b554462230735699df74ec9606a3c4c0684_ext.sol,BookERC20EthV1Dec.transferFromRwrd,431,442,"client(address) := msg.sender(address),TMP_82 = CONVERT this to address,book(address) := TMP_82(address),TMP_83(uint256) = HIGH_LEVEL_CALL, dest:rwrdToken(ERC20), function:allowance, arguments:['client', 'book']  ,amountRwrd(uint256) := TMP_83(uint256),TMP_84(bool) = amountRwrd > 0,TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84),TMP_86(bool) = HIGH_LEVEL_CALL, dest:rwrdToken(ERC20), function:transferFrom, arguments:['client', 'book', 'amountRwrd']  ,TMP_87(None) = SOLIDITY_CALL require(bool)(TMP_86),TMP_88(uint256) = HIGH_LEVEL_CALL, dest:rwrdToken(ERC20), function:allowance, arguments:['client', 'book']  ,TMP_89(bool) = TMP_88 == 0,TMP_90(None) = SOLIDITY_CALL assert(bool)(TMP_89),REF_32(uint256) -> balanceRwrdForClient[client],REF_32(-> balanceRwrdForClient) = REF_32 + amountRwrd,REF_33(BookERC20EthV1Dec.ClientPaymentEventType) -> ClientPaymentEventType.TransferFrom,REF_34(BookERC20EthV1Dec.BalanceType) -> BalanceType.Rwrd,TMP_91 = CONVERT amountRwrd to int256,Emit ClientPaymentEvent(client,REF_33,REF_34,TMP_91)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
client = msg.sender

IRs:
client(address) := msg.sender(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
book = address(this)

IRs:
TMP_82 = CONVERT this to address
book(address) := TMP_82(address)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
amountRwrd = rwrdToken.allowance(client,book)

IRs:
TMP_83(uint256) = HIGH_LEVEL_CALL, dest:rwrdToken(ERC20), function:allowance, arguments:['client', 'book']  
amountRwrd(uint256) := TMP_83(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(amountRwrd > 0)

IRs:
TMP_84(bool) = amountRwrd > 0
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(rwrdToken.transferFrom(client,book,amountRwrd))

IRs:
TMP_86(bool) = HIGH_LEVEL_CALL, dest:rwrdToken(ERC20), function:transferFrom, arguments:['client', 'book', 'amountRwrd']  
TMP_87(None) = SOLIDITY_CALL require(bool)(TMP_86)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
assert(bool)(rwrdToken.allowance(client,book) == 0)

IRs:
TMP_88(uint256) = HIGH_LEVEL_CALL, dest:rwrdToken(ERC20), function:allowance, arguments:['client', 'book']  
TMP_89(bool) = TMP_88 == 0
TMP_90(None) = SOLIDITY_CALL assert(bool)(TMP_89)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balanceRwrdForClient[client] += amountRwrd

IRs:
REF_32(uint256) -> balanceRwrdForClient[client]
REF_32(-> balanceRwrdForClient) = REF_32 + amountRwrd""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ClientPaymentEvent(client,ClientPaymentEventType.TransferFrom,BalanceType.Rwrd,int256(amountRwrd))

IRs:
REF_33(BookERC20EthV1Dec.ClientPaymentEventType) -> ClientPaymentEventType.TransferFrom
REF_34(BookERC20EthV1Dec.BalanceType) -> BalanceType.Rwrd
TMP_91 = CONVERT amountRwrd to int256
Emit ClientPaymentEvent(client,REF_33,REF_34,TMP_91)""];
}
",1,0,0,0,"client = msg.sender;book = address(this);amountRwrd = rwrdToken.allowance(client,book);require(bool)(amountRwrd > 0);require(bool)(rwrdToken.transferFrom(client,book,amountRwrd));assert(bool)(rwrdToken.allowance(client,book) == 0);balanceRwrdForClient[client] += amountRwrd;ClientPaymentEvent(client,ClientPaymentEventType.TransferFrom,BalanceType.Rwrd,int256(amountRwrd))"
./0x402fa04ccd2c2568e1a53dbecec1bd572303663a_ext.sol,HarborPresale.mintForEverybody,423,435,"TMP_181(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['weiRaised', 'rate'] ,allTokenAmount(uint256) := TMP_181(uint256),TMP_182(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['allTokenAmount', '2'] ,projectAmount(uint256) := TMP_182(uint256),TMP_183(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['projectAmount', '3'] ,projectAmount(uint256) := TMP_183(uint256),TMP_184 = CONVERT this to address,TMP_185(bool) = HIGH_LEVEL_CALL, dest:token(HarborToken), function:mint, arguments:['TMP_184', 'allTokenAmount']  ,TMP_186(bool) = HIGH_LEVEL_CALL, dest:token(HarborToken), function:mint, arguments:['wallet', 'projectAmount']  ,TMP_187(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['allTokenAmount', 'projectAmount'] ,tokensMinted(uint256) := TMP_187(uint256),Emit TokenMinted(tokensMinted),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
allTokenAmount = weiRaised.mul(rate)

IRs:
TMP_181(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['weiRaised', 'rate'] 
allTokenAmount(uint256) := TMP_181(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
projectAmount = allTokenAmount.mul(2)

IRs:
TMP_182(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['allTokenAmount', '2'] 
projectAmount(uint256) := TMP_182(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
projectAmount = projectAmount.div(3)

IRs:
TMP_183(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['projectAmount', '3'] 
projectAmount(uint256) := TMP_183(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.mint(address(this),allTokenAmount)

IRs:
TMP_184 = CONVERT this to address
TMP_185(bool) = HIGH_LEVEL_CALL, dest:token(HarborToken), function:mint, arguments:['TMP_184', 'allTokenAmount']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
token.mint(wallet,projectAmount)

IRs:
TMP_186(bool) = HIGH_LEVEL_CALL, dest:token(HarborToken), function:mint, arguments:['wallet', 'projectAmount']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tokensMinted = allTokenAmount.add(projectAmount)

IRs:
TMP_187(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['allTokenAmount', 'projectAmount'] 
tokensMinted(uint256) := TMP_187(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
TokenMinted(tokensMinted)

IRs:
Emit TokenMinted(tokensMinted)""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
8->1;
}
",1,0,0,0,"onlyOwner();allTokenAmount = weiRaised.mul(rate);projectAmount = allTokenAmount.mul(2);projectAmount = projectAmount.div(3);token.mint(address(this),allTokenAmount);token.mint(wallet,projectAmount);tokensMinted = allTokenAmount.add(projectAmount);TokenMinted(tokensMinted)"
./0x6faff25ef78e39c518687b0dd19113f9b29ac562_ext.sol,ETHedgeToken.takeCapital,195,202,"TMP_23(bool) = capitalAmount_ > 0,TMP_24(bool) = AdminRewardAmount_ > 0,TMP_25(bool) = TMP_23 && TMP_24,TMP_26(None) = SOLIDITY_CALL require(bool,string)(TMP_25,No fundz, sorry!),Transfer dest:capital_ value:capitalAmount_,TMP_28 = CONVERT devReward_ to DevsInterface,devContract_(DevsInterface) := TMP_28(DevsInterface),HIGH_LEVEL_CALL, dest:devContract_(DevsInterface), function:payDividends, arguments:['ethedge.co source'] value:AdminRewardAmount_ ,capitalAmount_(uint256) := 0(uint256),AdminRewardAmount_(uint256) := 0(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(capitalAmount_ > 0 && AdminRewardAmount_ > 0,No fundz, sorry!)

IRs:
TMP_23(bool) = capitalAmount_ > 0
TMP_24(bool) = AdminRewardAmount_ > 0
TMP_25(bool) = TMP_23 && TMP_24
TMP_26(None) = SOLIDITY_CALL require(bool,string)(TMP_25,No fundz, sorry!)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
capital_.transfer(capitalAmount_)

IRs:
Transfer dest:capital_ value:capitalAmount_""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
devContract_ = DevsInterface(devReward_)

IRs:
TMP_28 = CONVERT devReward_ to DevsInterface
devContract_(DevsInterface) := TMP_28(DevsInterface)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
devContract_.payDividends.value(AdminRewardAmount_)(ethedge.co source)

IRs:
HIGH_LEVEL_CALL, dest:devContract_(DevsInterface), function:payDividends, arguments:['ethedge.co source'] value:AdminRewardAmount_ ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
capitalAmount_ = 0

IRs:
capitalAmount_(uint256) := 0(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
AdminRewardAmount_ = 0

IRs:
AdminRewardAmount_(uint256) := 0(uint256)""];
}
",1,0,0,0,"require(bool,string)(capitalAmount_ > 0 && AdminRewardAmount_ > 0,No fundz, sorry!);capital_.transfer(capitalAmount_);devContract_ = DevsInterface(devReward_);devContract_.payDividends.value(AdminRewardAmount_)(ethedge.co source);capitalAmount_ = 0;AdminRewardAmount_ = 0"
./0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06_ext.sol,BreedingClockAuction.createAuction,1081,1094,"TMP_841 = CONVERT _startingPrice to uint128,TMP_842 = CONVERT TMP_841 to uint256,TMP_843(bool) = _startingPrice == TMP_842,TMP_844(None) = SOLIDITY_CALL require(bool)(TMP_843),TMP_845 = CONVERT _endingPrice to uint128,TMP_846 = CONVERT TMP_845 to uint256,TMP_847(bool) = _endingPrice == TMP_846,TMP_848(None) = SOLIDITY_CALL require(bool)(TMP_847),TMP_849 = CONVERT _duration to uint64,TMP_850 = CONVERT TMP_849 to uint256,TMP_851(bool) = _duration == TMP_850,TMP_852(None) = SOLIDITY_CALL require(bool)(TMP_851),TMP_853(bool) = INTERNAL_CALL, ClockAuctionBase.isOwnerOf(address,uint256)(msg.sender,_tokenId),TMP_854(None) = SOLIDITY_CALL require(bool)(TMP_853),INTERNAL_CALL, ClockAuctionBase._escrow(address,uint256)(msg.sender,_tokenId),startAt(uint64) := _startAt(uint64),TMP_856(bool) = _startAt == 0,CONDITION TMP_856,TMP_857 = CONVERT now to uint64,startAt(uint64) := TMP_857(uint64),TMP_858 = CONVERT _startingPrice to uint128,TMP_859 = CONVERT _endingPrice to uint128,TMP_860 = CONVERT _duration to uint64,TMP_861 = CONVERT startAt to uint64,TMP_862(ClockAuctionBase.Auction) = new Auction(_seller,TMP_858,TMP_859,TMP_860,TMP_861),auction(ClockAuctionBase.Auction) := TMP_862(ClockAuctionBase.Auction),INTERNAL_CALL, ClockAuctionBase._addAuction(uint256,ClockAuctionBase.Auction)(_tokenId,auction),MODIFIER_CALL, Pausable.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_startingPrice == uint256(uint128(_startingPrice)))

IRs:
TMP_841 = CONVERT _startingPrice to uint128
TMP_842 = CONVERT TMP_841 to uint256
TMP_843(bool) = _startingPrice == TMP_842
TMP_844(None) = SOLIDITY_CALL require(bool)(TMP_843)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_endingPrice == uint256(uint128(_endingPrice)))

IRs:
TMP_845 = CONVERT _endingPrice to uint128
TMP_846 = CONVERT TMP_845 to uint256
TMP_847(bool) = _endingPrice == TMP_846
TMP_848(None) = SOLIDITY_CALL require(bool)(TMP_847)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_duration == uint256(uint64(_duration)))

IRs:
TMP_849 = CONVERT _duration to uint64
TMP_850 = CONVERT TMP_849 to uint256
TMP_851(bool) = _duration == TMP_850
TMP_852(None) = SOLIDITY_CALL require(bool)(TMP_851)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(isOwnerOf(msg.sender,_tokenId))

IRs:
TMP_853(bool) = INTERNAL_CALL, ClockAuctionBase.isOwnerOf(address,uint256)(msg.sender,_tokenId)
TMP_854(None) = SOLIDITY_CALL require(bool)(TMP_853)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_escrow(msg.sender,_tokenId)

IRs:
INTERNAL_CALL, ClockAuctionBase._escrow(address,uint256)(msg.sender,_tokenId)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
startAt = _startAt

IRs:
startAt(uint64) := _startAt(uint64)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
_startAt == 0

IRs:
TMP_856(bool) = _startAt == 0
CONDITION TMP_856""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
startAt = uint64(now)

IRs:
TMP_857 = CONVERT now to uint64
startAt(uint64) := TMP_857(uint64)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
auction = Auction(_seller,uint128(_startingPrice),uint128(_endingPrice),uint64(_duration),uint64(startAt))

IRs:
TMP_858 = CONVERT _startingPrice to uint128
TMP_859 = CONVERT _endingPrice to uint128
TMP_860 = CONVERT _duration to uint64
TMP_861 = CONVERT startAt to uint64
TMP_862(ClockAuctionBase.Auction) = new Auction(_seller,TMP_858,TMP_859,TMP_860,TMP_861)
auction(ClockAuctionBase.Auction) := TMP_862(ClockAuctionBase.Auction)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
_addAuction(_tokenId,auction)

IRs:
INTERNAL_CALL, ClockAuctionBase._addAuction(uint256,ClockAuctionBase.Auction)(_tokenId,auction)""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
12->1;
}
",1,0,0,0,"whenNotPaused();require(bool)(_startingPrice == uint256(uint128(_startingPrice)));require(bool)(_endingPrice == uint256(uint128(_endingPrice)));require(bool)(_duration == uint256(uint64(_duration)));require(bool)(isOwnerOf(msg.sender,_tokenId));_escrow(msg.sender,_tokenId);startAt = _startAt;_startAt == 0;startAt = uint64(now);;auction = Auction(_seller,uint128(_startingPrice),uint128(_endingPrice),uint64(_duration),uint64(startAt));_addAuction(_tokenId,auction)"
./0x514bc174df04a4b04ae2be81ee8c788c3796b06b_ext.sol,Deco.transfer,50,50,"TMP_14(bool) = INTERNAL_CALL, Deco.performTransfer(address,address,uint256,bytes)(msg.sender,_to,_value,),Emit Transfer(msg.sender,_to,_value),RETURN True,TMP_16(uint256) = 2 * 32,MODIFIER_CALL, Deco.onlyPayloadSize(uint256)(TMP_16)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
performTransfer(msg.sender,_to,_value,)

IRs:
TMP_14(bool) = INTERNAL_CALL, Deco.performTransfer(address,address,uint256,bytes)(msg.sender,_to,_value,)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyPayloadSize(2 * 32)

IRs:
TMP_16(uint256) = 2 * 32
MODIFIER_CALL, Deco.onlyPayloadSize(uint256)(TMP_16)""];
4->1;
}
",1,0,0,0,"onlyPayloadSize(2 * 32);performTransfer(msg.sender,_to,_value,);Transfer(msg.sender,_to,_value);true"
./0x4ca65f54f923be2fb3efc3a7758e88a6f910806e_ext.sol,GamblicaEarlyAccess.start,41,47,"TMP_4 = CONVERT this to address,TMP_5(uint256) = HIGH_LEVEL_CALL, dest:gmbcToken(GMBCToken), function:balanceOf, arguments:['TMP_4']  ,TMP_6(bool) = TMP_5 >= PRIZE_FUND_GMBC,TMP_7(None) = SOLIDITY_CALL require(bool,string)(TMP_6,Contract can only be activated with a prize fund),REF_2(GamblicaEarlyAccess.State) -> State.CREATED,TMP_8(bool) = state == REF_2,TMP_9(None) = SOLIDITY_CALL require(bool,string)(TMP_8,Invalid contract state),gmbcTotal(uint256) := PRIZE_FUND_GMBC(uint256),REF_3(GamblicaEarlyAccess.State) -> State.DEPOSIT,state(GamblicaEarlyAccess.State) := REF_3(GamblicaEarlyAccess.State),MODIFIER_CALL, GamblicaEarlyAccess.onlyGamblica()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(gmbcToken.balanceOf(address(this)) >= PRIZE_FUND_GMBC,Contract can only be activated with a prize fund)

IRs:
TMP_4 = CONVERT this to address
TMP_5(uint256) = HIGH_LEVEL_CALL, dest:gmbcToken(GMBCToken), function:balanceOf, arguments:['TMP_4']  
TMP_6(bool) = TMP_5 >= PRIZE_FUND_GMBC
TMP_7(None) = SOLIDITY_CALL require(bool,string)(TMP_6,Contract can only be activated with a prize fund)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(state == State.CREATED,Invalid contract state)

IRs:
REF_2(GamblicaEarlyAccess.State) -> State.CREATED
TMP_8(bool) = state == REF_2
TMP_9(None) = SOLIDITY_CALL require(bool,string)(TMP_8,Invalid contract state)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
gmbcTotal = PRIZE_FUND_GMBC

IRs:
gmbcTotal(uint256) := PRIZE_FUND_GMBC(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
state = State.DEPOSIT

IRs:
REF_3(GamblicaEarlyAccess.State) -> State.DEPOSIT
state(GamblicaEarlyAccess.State) := REF_3(GamblicaEarlyAccess.State)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyGamblica()

IRs:
MODIFIER_CALL, GamblicaEarlyAccess.onlyGamblica()()""];
5->1;
}
",1,0,0,0,"onlyGamblica();require(bool,string)(gmbcToken.balanceOf(address(this)) >= PRIZE_FUND_GMBC,Contract can only be activated with a prize fund);require(bool,string)(state == State.CREATED,Invalid contract state);gmbcTotal = PRIZE_FUND_GMBC;state = State.DEPOSIT"
./0xf244176246168f24e3187f7288edbca29267739b_ext.sol,Havven.setTargetFeePeriodDuration,2472,2481,"TMP_1062(bool) = MIN_FEE_PERIOD_DURATION_SECONDS <= duration,TMP_1063(bool) = duration <= MAX_FEE_PERIOD_DURATION_SECONDS,TMP_1064(bool) = TMP_1062 && TMP_1063,TMP_1065(None) = SOLIDITY_CALL require(bool)(TMP_1064),targetFeePeriodDurationSeconds(uint256) := duration(uint256),Emit FeePeriodDurationUpdated(duration),MODIFIER_CALL, Havven.postCheckFeePeriodRollover()(),MODIFIER_CALL, Proxyable.optionalProxy_onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(MIN_FEE_PERIOD_DURATION_SECONDS <= duration && duration <= MAX_FEE_PERIOD_DURATION_SECONDS)

IRs:
TMP_1062(bool) = MIN_FEE_PERIOD_DURATION_SECONDS <= duration
TMP_1063(bool) = duration <= MAX_FEE_PERIOD_DURATION_SECONDS
TMP_1064(bool) = TMP_1062 && TMP_1063
TMP_1065(None) = SOLIDITY_CALL require(bool)(TMP_1064)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
targetFeePeriodDurationSeconds = duration

IRs:
targetFeePeriodDurationSeconds(uint256) := duration(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
FeePeriodDurationUpdated(duration)

IRs:
Emit FeePeriodDurationUpdated(duration)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
postCheckFeePeriodRollover()

IRs:
MODIFIER_CALL, Havven.postCheckFeePeriodRollover()()""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
optionalProxy_onlyOwner()

IRs:
MODIFIER_CALL, Proxyable.optionalProxy_onlyOwner()()""];
5->1;
}
",1,0,0,0,postCheckFeePeriodRollover();require(bool)(MIN_FEE_PERIOD_DURATION_SECONDS <= duration && duration <= MAX_FEE_PERIOD_DURATION_SECONDS);targetFeePeriodDurationSeconds = duration;FeePeriodDurationUpdated(duration);optionalProxy_onlyOwner()
./0x84f7c44b6fed1080f647e354d552595be2cc602f_ext.sol,BigbomToken.transferPrivateSale,453,459,"TMP_155(bool) = INTERNAL_CALL, BigbomToken.transfer(address,uint256)(_to,_value),RETURN TMP_155,MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, BigbomToken.onlyPrivateListEnabled(address)(_to)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: RETURN 1

EXPRESSION:
transfer(_to,_value)

IRs:
TMP_155(bool) = INTERNAL_CALL, BigbomToken.transfer(address,uint256)(_to,_value)
RETURN TMP_155""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyPrivateListEnabled(_to)

IRs:
MODIFIER_CALL, BigbomToken.onlyPrivateListEnabled(address)(_to)""];
3->1;
}
",1,0,0,0,"onlyOwner();transfer(_to,_value);onlyPrivateListEnabled(_to)"
./0xb471c695dd5ea02035275d4b88077490c1e380ba_ext.sol,ERC20x.transferToContract,53,59,"INTERNAL_CALL, ERC20x._transferBalance(address,address,uint256)(msg.sender,_to,_value),TMP_11(bytes32) = SOLIDITY_CALL keccak256()(receiveTokens(address,uint256,bytes)),TMP_12 = CONVERT TMP_11 to bytes4,sig(bytes4) := TMP_12(bytes4),TMP_13(bool) = LOW_LEVEL_CALL, dest:_to, function:call, arguments:['sig', 'msg.sender', '_value', 'data']  ,TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13),Emit Transfer(msg.sender,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_transferBalance(msg.sender,_to,_value)

IRs:
INTERNAL_CALL, ERC20x._transferBalance(address,address,uint256)(msg.sender,_to,_value)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
sig = bytes4(keccak256()(receiveTokens(address,uint256,bytes)))

IRs:
TMP_11(bytes32) = SOLIDITY_CALL keccak256()(receiveTokens(address,uint256,bytes))
TMP_12 = CONVERT TMP_11 to bytes4
sig(bytes4) := TMP_12(bytes4)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_to.call(sig,msg.sender,_value,data))

IRs:
TMP_13(bool) = LOW_LEVEL_CALL, dest:_to, function:call, arguments:['sig', 'msg.sender', '_value', 'data']  
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,"_transferBalance(msg.sender,_to,_value);sig = bytes4(keccak256()(receiveTokens(address,uint256,bytes)));require(bool)(_to.call(sig,msg.sender,_value,data));Transfer(msg.sender,_to,_value);true"
./0x17f68886d00845867c154c912b4ccc506ec92fc7_ext.sol,DelegatedShareholderAssociation.setDelegateAndLockTokens,196,209,"REF_3(uint256) -> lockedDelegatingTokens[msg.sender],REF_3(uint256) (->lockedDelegatingTokens) := tokensToLock(uint256),REF_4(uint256) -> delegatedAmountsByDelegate[delegate],REF_6(uint256) -> delegatedAmountsByDelegate[delegate],TMP_25(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_6', 'tokensToLock'] ,REF_4(uint256) (->delegatedAmountsByDelegate) := TMP_25(uint256),TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalLockedTokens', 'tokensToLock'] ,totalLockedTokens(uint256) := TMP_26(uint256),REF_8(address) -> delegatesByDelegator[msg.sender],REF_8(address) (->delegatesByDelegator) := delegate(address),TMP_27(bool) = HIGH_LEVEL_CALL, dest:sharesTokenAddress(ERC20), function:transferFrom, arguments:['msg.sender', 'tokenLocker', 'tokensToLock']  ,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),TMP_29(uint256) = HIGH_LEVEL_CALL, dest:sharesTokenAddress(ERC20), function:balanceOf, arguments:['tokenLocker']  ,TMP_30(bool) = TMP_29 == totalLockedTokens,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),Emit TokensDelegated(msg.sender,tokensToLock,delegate),MODIFIER_CALL, DelegatedShareholderAssociation.onlyShareholders()(),MODIFIER_CALL, DelegatedShareholderAssociation.onlyUndelegated()(),MODIFIER_CALL, DelegatedShareholderAssociation.notSelf()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
lockedDelegatingTokens[msg.sender] = tokensToLock

IRs:
REF_3(uint256) -> lockedDelegatingTokens[msg.sender]
REF_3(uint256) (->lockedDelegatingTokens) := tokensToLock(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
delegatedAmountsByDelegate[delegate] = SafeMath.add(delegatedAmountsByDelegate[delegate],tokensToLock)

IRs:
REF_4(uint256) -> delegatedAmountsByDelegate[delegate]
REF_6(uint256) -> delegatedAmountsByDelegate[delegate]
TMP_25(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_6', 'tokensToLock'] 
REF_4(uint256) (->delegatedAmountsByDelegate) := TMP_25(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalLockedTokens = SafeMath.add(totalLockedTokens,tokensToLock)

IRs:
TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalLockedTokens', 'tokensToLock'] 
totalLockedTokens(uint256) := TMP_26(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
delegatesByDelegator[msg.sender] = delegate

IRs:
REF_8(address) -> delegatesByDelegator[msg.sender]
REF_8(address) (->delegatesByDelegator) := delegate(address)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(sharesTokenAddress.transferFrom(msg.sender,tokenLocker,tokensToLock))

IRs:
TMP_27(bool) = HIGH_LEVEL_CALL, dest:sharesTokenAddress(ERC20), function:transferFrom, arguments:['msg.sender', 'tokenLocker', 'tokensToLock']  
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(sharesTokenAddress.balanceOf(tokenLocker) == totalLockedTokens)

IRs:
TMP_29(uint256) = HIGH_LEVEL_CALL, dest:sharesTokenAddress(ERC20), function:balanceOf, arguments:['tokenLocker']  
TMP_30(bool) = TMP_29 == totalLockedTokens
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
TokensDelegated(msg.sender,tokensToLock,delegate)

IRs:
Emit TokensDelegated(msg.sender,tokensToLock,delegate)""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyShareholders()

IRs:
MODIFIER_CALL, DelegatedShareholderAssociation.onlyShareholders()()""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyUndelegated()

IRs:
MODIFIER_CALL, DelegatedShareholderAssociation.onlyUndelegated()()""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
notSelf()

IRs:
MODIFIER_CALL, DelegatedShareholderAssociation.notSelf()()""];
10->1;
}
",1,0,0,0,"onlyShareholders();lockedDelegatingTokens[msg.sender] = tokensToLock;delegatedAmountsByDelegate[delegate] = SafeMath.add(delegatedAmountsByDelegate[delegate],tokensToLock);totalLockedTokens = SafeMath.add(totalLockedTokens,tokensToLock);delegatesByDelegator[msg.sender] = delegate;require(bool)(sharesTokenAddress.transferFrom(msg.sender,tokenLocker,tokensToLock));require(bool)(sharesTokenAddress.balanceOf(tokenLocker) == totalLockedTokens);TokensDelegated(msg.sender,tokensToLock,delegate);onlyUndelegated();notSelf()"
./0x85b794252e7f1b2b24392a5267ff2086c0c3d7d1_ext.sol,CashPokerProPreICO.transfer,216,224,"TMP_75(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['tokensLimit', 'tokensSold'] ,tokenAmountEnable(uint256) := TMP_75(uint256),TMP_76(bool) = amount > tokenAmountEnable,CONDITION TMP_76,amount(uint256) := tokenAmountEnable(uint256),TMP_77(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transferFrom, arguments:['tokenWallet', 'to', 'amount']  ,TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77),TMP_79(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokensSold', 'amount'] ,tokensSold(uint256) := TMP_79(uint256),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokenAmountEnable = tokensLimit.sub(tokensSold)

IRs:
TMP_75(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['tokensLimit', 'tokensSold'] 
tokenAmountEnable(uint256) := TMP_75(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
amount > tokenAmountEnable

IRs:
TMP_76(bool) = amount > tokenAmountEnable
CONDITION TMP_76""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
amount = tokenAmountEnable

IRs:
amount(uint256) := tokenAmountEnable(uint256)""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(token.transferFrom(tokenWallet,to,amount))

IRs:
TMP_77(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transferFrom, arguments:['tokenWallet', 'to', 'amount']  
TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tokensSold = tokensSold.add(amount)

IRs:
TMP_79(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokensSold', 'amount'] 
tokensSold(uint256) := TMP_79(uint256)""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->1;
}
",1,0,0,0,"onlyOwner();tokenAmountEnable = tokensLimit.sub(tokensSold);amount > tokenAmountEnable;amount = tokenAmountEnable;;require(bool)(token.transferFrom(tokenWallet,to,amount));tokensSold = tokensSold.add(amount)"
./0x01d6208f95cf2292c350fc8bb1b1f29230352675_ext.sol,DepositWithdraw.withdrawToken,355,374,"TMP_77 = CONVERT 0 to address,TMP_78(bool) = _to != TMP_77,TMP_79(None) = SOLIDITY_CALL require(bool)(TMP_78),TMP_80 = CONVERT 0 to address,TMP_81(bool) = _token != TMP_80,TMP_82(None) = SOLIDITY_CALL require(bool)(TMP_81),TMP_83 = CONVERT _token to ERC20,tk(ERC20) := TMP_83(ERC20),TMP_84(bool) = HIGH_LEVEL_CALL, dest:tk(ERC20), function:transfer, arguments:['_to', '_value']  ,Emit WithdrawToken(_token,_to,_value),RETURN True,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_77 = CONVERT 0 to address
TMP_78(bool) = _to != TMP_77
TMP_79(None) = SOLIDITY_CALL require(bool)(TMP_78)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token != address(0))

IRs:
TMP_80 = CONVERT 0 to address
TMP_81(bool) = _token != TMP_80
TMP_82(None) = SOLIDITY_CALL require(bool)(TMP_81)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
tk = ERC20(_token)

IRs:
TMP_83 = CONVERT _token to ERC20
tk(ERC20) := TMP_83(ERC20)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
tk.transfer(_to,_value)

IRs:
TMP_84(bool) = HIGH_LEVEL_CALL, dest:tk(ERC20), function:transfer, arguments:['_to', '_value']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
WithdrawToken(_token,_to,_value)

IRs:
Emit WithdrawToken(_token,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->1;
}
",1,0,0,0,"onlyOwner();require(bool)(_to != address(0));require(bool)(_token != address(0));tk = ERC20(_token);tk.transfer(_to,_value);WithdrawToken(_token,_to,_value);true"
./0x88355a32a8c5cc399aa09b9d21ebcba935ae5d2f_ext.sol,BankWallet.withdraw,164,184,"_success(bool) := False(bool),TMP_95 = CONVERT 0 to address,TMP_96(bool) = _token == TMP_95,CONDITION TMP_96,weiAmount(uint256) := _amount(uint256),TMP_97 = CONVERT this to address,TMP_98(uint256) = SOLIDITY_CALL balance(address)(TMP_97),TMP_99(bool) = weiAmount > TMP_98,CONDITION TMP_99,RETURN False,TMP_100 = SEND dest:receiver value:weiAmount,_success(bool) := TMP_100(bool),TMP_101 = CONVERT _token to Token,__token(Token) := TMP_101(Token),amount(uint256) := _amount(uint256),TMP_102(uint256) = HIGH_LEVEL_CALL, dest:__token(Token), function:balanceOf, arguments:['this']  ,TMP_103(bool) = amount > TMP_102,CONDITION TMP_103,RETURN False,TMP_104(bool) = HIGH_LEVEL_CALL, dest:__token(Token), function:transfer, arguments:['receiver', 'amount']  ,_success(bool) := TMP_104(bool),CONDITION _success,Emit Withdrawal(_token,_amount),MODIFIER_CALL, Owned.onlyAdmin()(),RETURN _success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->18;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_success = false

IRs:
_success(bool) := False(bool)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
_token == address(0)

IRs:
TMP_95 = CONVERT 0 to address
TMP_96(bool) = _token == TMP_95
CONDITION TMP_96""];
2->3[label=""True""];
2->8[label=""False""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
weiAmount = _amount

IRs:
weiAmount(uint256) := _amount(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
weiAmount > address(this).balance

IRs:
TMP_97 = CONVERT this to address
TMP_98(uint256) = SOLIDITY_CALL balance(address)(TMP_97)
TMP_99(bool) = weiAmount > TMP_98
CONDITION TMP_99""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: RETURN 5

EXPRESSION:
false

IRs:
RETURN False""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
_success = receiver.send(weiAmount)

IRs:
TMP_100 = SEND dest:receiver value:weiAmount
_success(bool) := TMP_100(bool)""];
7->14;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
__token = Token(_token)

IRs:
TMP_101 = CONVERT _token to Token
__token(Token) := TMP_101(Token)""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
amount = _amount

IRs:
amount(uint256) := _amount(uint256)""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
amount > __token.balanceOf(this)

IRs:
TMP_102(uint256) = HIGH_LEVEL_CALL, dest:__token(Token), function:balanceOf, arguments:['this']  
TMP_103(bool) = amount > TMP_102
CONDITION TMP_103""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: RETURN 11

EXPRESSION:
false

IRs:
RETURN False""];
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
_success = __token.transfer(receiver,amount)

IRs:
TMP_104(bool) = HIGH_LEVEL_CALL, dest:__token(Token), function:transfer, arguments:['receiver', 'amount']  
_success(bool) := TMP_104(bool)""];
13->14;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: IF 15

EXPRESSION:
_success

IRs:
CONDITION _success""];
15->16[label=""True""];
15->17[label=""False""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
Withdrawal(_token,_amount)

IRs:
Emit Withdrawal(_token,_amount)""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->19;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Owned.onlyAdmin()()""];
18->1;
19[label=""Node Type: RETURN 19

EXPRESSION:
_success

IRs:
RETURN _success""];
}
",1,0,1,0,"onlyAdmin();_success = false;_token == address(0);weiAmount = _amount;__token = Token(_token);weiAmount > address(this).balance;false;;_success = receiver.send(weiAmount);;amount = _amount;amount > __token.balanceOf(this);false;;_success = __token.transfer(receiver,amount);_success;Withdrawal(_token,_amount);;_success"
./0xaa63c8683647ef91b3fdab4b4989ee9588da297b_ext.sol,DSProxy.execute,98,110,"TMP_27(address) = HIGH_LEVEL_CALL, dest:cache(DSProxyCache), function:read, arguments:['_code']  ,target(address) := TMP_27(address),TMP_28(bool) = target == 0,CONDITION TMP_28,TMP_29(address) = HIGH_LEVEL_CALL, dest:cache(DSProxyCache), function:write, arguments:['_code']  ,target(address) := TMP_29(address),TMP_30(bytes32) = INTERNAL_CALL, DSProxy.execute(address,bytes)(target,_data),response(bytes32) := TMP_30(bytes32),RETURN target,response","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
target = cache.read(_code)

IRs:
TMP_27(address) = HIGH_LEVEL_CALL, dest:cache(DSProxyCache), function:read, arguments:['_code']  
target(address) := TMP_27(address)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
target == 0x0

IRs:
TMP_28(bool) = target == 0
CONDITION TMP_28""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
target = cache.write(_code)

IRs:
TMP_29(address) = HIGH_LEVEL_CALL, dest:cache(DSProxyCache), function:write, arguments:['_code']  
target(address) := TMP_29(address)""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
response = execute(target,_data)

IRs:
TMP_30(bytes32) = INTERNAL_CALL, DSProxy.execute(address,bytes)(target,_data)
response(bytes32) := TMP_30(bytes32)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
(target,response)

IRs:
RETURN target,response""];
}
",1,0,0,0,"target = cache.read(_code);target == 0x0;target = cache.write(_code);;response = execute(target,_data);(target,response)"
./0xa227d444a52fd21c3a848c7650bc2cd5832f6487_ext.sol,KTFForTestMigration.migrateFromPKTF,706,719,"TMP_379(uint32) = HIGH_LEVEL_CALL, dest:pktf(PrivateToken), function:numberOfTokenHolders, arguments:[]  ,numberOfPKTFHolders(uint32) := TMP_379(uint32),holderCount(uint32) := numberOfPKTFHolders(uint32),i(uint256) := 0(uint256),TMP_380(bool) = i < numberOfPKTFHolders,CONDITION TMP_380,TMP_381(address) = HIGH_LEVEL_CALL, dest:pktf(PrivateToken), function:holders, arguments:['i']  ,user(address) := TMP_381(address),TMP_382(uint256) = HIGH_LEVEL_CALL, dest:pktf(PrivateToken), function:balanceOf, arguments:['user']  ,balance(uint256) := TMP_382(uint256),TMP_383(bool) = INTERNAL_CALL, KTFForTestMigration.mint(address,uint256)(user,balance),TMP_384(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
numberOfPKTFHolders = pktf.numberOfTokenHolders()

IRs:
TMP_379(uint32) = HIGH_LEVEL_CALL, dest:pktf(PrivateToken), function:numberOfTokenHolders, arguments:[]  
numberOfPKTFHolders(uint32) := TMP_379(uint32)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
holderCount = numberOfPKTFHolders

IRs:
holderCount(uint32) := numberOfPKTFHolders(uint32)""];
2->5;
3[label=""Node Type: BEGIN_LOOP 3
""];
3->6;
4[label=""Node Type: END_LOOP 4
""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
5->3;
6[label=""Node Type: IF_LOOP 6

EXPRESSION:
i < numberOfPKTFHolders

IRs:
TMP_380(bool) = i < numberOfPKTFHolders
CONDITION TMP_380""];
6->7[label=""True""];
6->4[label=""False""];
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
user = pktf.holders(i)

IRs:
TMP_381(address) = HIGH_LEVEL_CALL, dest:pktf(PrivateToken), function:holders, arguments:['i']  
user(address) := TMP_381(address)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
balance = pktf.balanceOf(user)

IRs:
TMP_382(uint256) = HIGH_LEVEL_CALL, dest:pktf(PrivateToken), function:balanceOf, arguments:['user']  
balance(uint256) := TMP_382(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
mint(user,balance)

IRs:
TMP_383(bool) = INTERNAL_CALL, KTFForTestMigration.mint(address,uint256)(user,balance)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
i ++

IRs:
TMP_384(uint256) := i(uint256)
i(uint256) = i + 1""];
10->6;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
11->1;
}
",1,0,0,0,"onlyOwner();numberOfPKTFHolders = pktf.numberOfTokenHolders();holderCount = numberOfPKTFHolders;i = 0;;i < numberOfPKTFHolders;;user = pktf.holders(i);balance = pktf.balanceOf(user);mint(user,balance);i ++"
./0xbc97f1508fdeb0a63b25f3a4806b62ef5370e8ab_ext.sol,CryptoBeginnerQuest.setDepositInterface,272,279,"TMP_36 = CONVERT _addr to CryptoDepositInterface,depositInterface(CryptoDepositInterface) := TMP_36(CryptoDepositInterface),TMP_37(bool) = HIGH_LEVEL_CALL, dest:depositInterface(CryptoDepositInterface), function:isContractMiniGame, arguments:[]  ,TMP_38(bool) = TMP_37 == True,TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38),Deposit(CryptoDepositInterface) := depositInterface(CryptoDepositInterface),MODIFIER_CALL, CryptoBeginnerQuest.isAdministrator()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
depositInterface = CryptoDepositInterface(_addr)

IRs:
TMP_36 = CONVERT _addr to CryptoDepositInterface
depositInterface(CryptoDepositInterface) := TMP_36(CryptoDepositInterface)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(depositInterface.isContractMiniGame() == true)

IRs:
TMP_37(bool) = HIGH_LEVEL_CALL, dest:depositInterface(CryptoDepositInterface), function:isContractMiniGame, arguments:[]  
TMP_38(bool) = TMP_37 == True
TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Deposit = depositInterface

IRs:
Deposit(CryptoDepositInterface) := depositInterface(CryptoDepositInterface)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
isAdministrator()

IRs:
MODIFIER_CALL, CryptoBeginnerQuest.isAdministrator()()""];
4->1;
}
",1,0,0,0,isAdministrator();depositInterface = CryptoDepositInterface(_addr);require(bool)(depositInterface.isContractMiniGame() == true);Deposit = depositInterface
./0x4720f2468eeb7a795945c5ffbc3b0178e32250e0_ext.sol,ExternalContracts.setMixGenAddress,92,97,"TMP_38 = CONVERT _address to MixGenInterface,candidateContract(MixGenInterface) := TMP_38(MixGenInterface),TMP_39(bool) = HIGH_LEVEL_CALL, dest:candidateContract(MixGenInterface), function:isMixGen, arguments:[]  ,TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39),geneScience(MixGenInterface) := candidateContract(MixGenInterface),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
candidateContract = MixGenInterface(_address)

IRs:
TMP_38 = CONVERT _address to MixGenInterface
candidateContract(MixGenInterface) := TMP_38(MixGenInterface)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(candidateContract.isMixGen())

IRs:
TMP_39(bool) = HIGH_LEVEL_CALL, dest:candidateContract(MixGenInterface), function:isMixGen, arguments:[]  
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
geneScience = candidateContract

IRs:
geneScience(MixGenInterface) := candidateContract(MixGenInterface)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->1;
}
",1,0,0,0,onlyOwner();candidateContract = MixGenInterface(_address);require(bool)(candidateContract.isMixGen());geneScience = candidateContract
./0xeb907a50921e052cbee233811beaf0839d2a98fd_ext.sol,Advertisement.cancelCampaign,186,200,"TMP_49(address) = INTERNAL_CALL, Advertisement.getOwnerOfCampaign(bytes32)(bidId),campaignOwner(address) := TMP_49(address),TMP_50(bool) = owner == msg.sender,TMP_51(bool) = campaignOwner == msg.sender,TMP_52(bool) = TMP_50 || TMP_51,TMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52),TMP_54(uint256) = INTERNAL_CALL, Advertisement.getBudgetOfCampaign(bytes32)(bidId),budget(uint256) := TMP_54(uint256),TMP_55(bool) = HIGH_LEVEL_CALL, dest:appc(AppCoins), function:transfer, arguments:['campaignOwner', 'budget']  ,INTERNAL_CALL, Advertisement.setBudgetOfCampaign(bytes32,uint256)(bidId,0),INTERNAL_CALL, Advertisement.setCampaignValidity(bytes32,bool)(bidId,False)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
campaignOwner = getOwnerOfCampaign(bidId)

IRs:
TMP_49(address) = INTERNAL_CALL, Advertisement.getOwnerOfCampaign(bytes32)(bidId)
campaignOwner(address) := TMP_49(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(owner == msg.sender || campaignOwner == msg.sender)

IRs:
TMP_50(bool) = owner == msg.sender
TMP_51(bool) = campaignOwner == msg.sender
TMP_52(bool) = TMP_50 || TMP_51
TMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
budget = getBudgetOfCampaign(bidId)

IRs:
TMP_54(uint256) = INTERNAL_CALL, Advertisement.getBudgetOfCampaign(bytes32)(bidId)
budget(uint256) := TMP_54(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
appc.transfer(campaignOwner,budget)

IRs:
TMP_55(bool) = HIGH_LEVEL_CALL, dest:appc(AppCoins), function:transfer, arguments:['campaignOwner', 'budget']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
setBudgetOfCampaign(bidId,0)

IRs:
INTERNAL_CALL, Advertisement.setBudgetOfCampaign(bytes32,uint256)(bidId,0)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
setCampaignValidity(bidId,false)

IRs:
INTERNAL_CALL, Advertisement.setCampaignValidity(bytes32,bool)(bidId,False)""];
}
",1,0,0,0,"campaignOwner = getOwnerOfCampaign(bidId);require(bool)(owner == msg.sender || campaignOwner == msg.sender);budget = getBudgetOfCampaign(bidId);appc.transfer(campaignOwner,budget);setBudgetOfCampaign(bidId,0);setCampaignValidity(bidId,false)"
./0xeb6486b13b56314b37aacac2ec6889d11a763de1_ext.sol,BasicCGRID.transfer,60,60,"TMP_17(bool) = _to != 0,TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17),REF_2(uint256) -> balances[msg.sender],REF_3(uint256) -> balances[msg.sender],TMP_19(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_3', '_value'] ,REF_2(uint256) (->balances) := TMP_19(uint256),REF_5(uint256) -> balances[_to],REF_6(uint256) -> balances[_to],TMP_20(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_6', '_value'] ,REF_5(uint256) (->balances) := TMP_20(uint256),Emit Transfer(msg.sender,_to,_value),RETURN True,MODIFIER_CALL, BasicCGRID.isTradable()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_17(bool) = _to != 0
TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_2(uint256) -> balances[msg.sender]
REF_3(uint256) -> balances[msg.sender]
TMP_19(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_3', '_value'] 
REF_2(uint256) (->balances) := TMP_19(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_5(uint256) -> balances[_to]
REF_6(uint256) -> balances[_to]
TMP_20(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_6', '_value'] 
REF_5(uint256) (->balances) := TMP_20(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
isTradable()

IRs:
MODIFIER_CALL, BasicCGRID.isTradable()()""];
6->1;
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,0,0,0,"isTradable();require(bool)(_to != 0x0);balances[msg.sender] = balances[msg.sender].sub(_value);balances[_to] = balances[_to].add(_value);Transfer(msg.sender,_to,_value);true;success"
./0xc0eb85285d83217cd7c891702bcbc0fc401e2d9d_ext.sol,HVNToken.claimTokens,373,384,"TMP_72(bool) = _token == 0,CONDITION TMP_72,REF_23(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:owner value:REF_23,TMP_74 = CONVERT _token to HVNToken,token(HVNToken) := TMP_74(HVNToken),TMP_75(uint256) = HIGH_LEVEL_CALL, dest:token(HVNToken), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_75(uint256),TMP_76(bool) = HIGH_LEVEL_CALL, dest:token(HVNToken), function:transfer, arguments:['owner', 'balance']  ,Emit Transfer(_token,owner,balance),MODIFIER_CALL, Owned.ownerOnly()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_72(bool) = _token == 0
CONDITION TMP_72""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(this.balance)

IRs:
REF_23(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:owner value:REF_23""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
token = HVNToken(_token)

IRs:
TMP_74 = CONVERT _token to HVNToken
token(HVNToken) := TMP_74(HVNToken)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_75(uint256) = HIGH_LEVEL_CALL, dest:token(HVNToken), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_75(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(owner,balance)

IRs:
TMP_76(bool) = HIGH_LEVEL_CALL, dest:token(HVNToken), function:transfer, arguments:['owner', 'balance']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_token,owner,balance)

IRs:
Emit Transfer(_token,owner,balance)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
ownerOnly()

IRs:
MODIFIER_CALL, Owned.ownerOnly()()""];
9->1;
}
",1,0,0,0,"ownerOnly();_token == 0x0;owner.transfer(this.balance);;;token = HVNToken(_token);balance = token.balanceOf(this);token.transfer(owner,balance);Transfer(_token,owner,balance)"
./0x2775f2a3c83bee1541d1d1bc308b3bb432b45151_ext.sol,PLANETAGROToken.refundTokens,355,361,"TMP_111(bool) = msg.sender == owner,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113 = CONVERT this to address,TMP_114(bool) = _token != TMP_113,TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114),TMP_116 = CONVERT _token to AbstractToken,token(AbstractToken) := TMP_116(AbstractToken),TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ,Emit RefundTokens(_token,_refund,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_111(bool) = msg.sender == owner
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_113 = CONVERT this to address
TMP_114(bool) = _token != TMP_113
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
token = AbstractToken(_token)

IRs:
TMP_116 = CONVERT _token to AbstractToken
token(AbstractToken) := TMP_116(AbstractToken)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(_refund,_value)

IRs:
TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RefundTokens(_token,_refund,_value)

IRs:
Emit RefundTokens(_token,_refund,_value)""];
}
",1,0,0,0,"require(bool)(msg.sender == owner);require(bool)(_token != address(this));token = AbstractToken(_token);token.transfer(_refund,_value);RefundTokens(_token,_refund,_value)"
./0x6c764fac2ed1c5fabf8bcd86bae68d8cdbe8290e_ext.sol,BaseWallet.init,570,581,"TMP_131 = CONVERT 0 to address,TMP_132(bool) = owner == TMP_131,TMP_133(bool) = modules == 0,TMP_134(bool) = TMP_132 && TMP_133,TMP_135(None) = SOLIDITY_CALL require(bool,string)(TMP_134,BW: wallet already initialised),REF_51 -> LENGTH _modules,TMP_136(bool) = REF_51 > 0,TMP_137(None) = SOLIDITY_CALL require(bool,string)(TMP_136,BW: construction requires at least 1 module),owner(address) := _owner(address),REF_52 -> LENGTH _modules,modules(uint256) := REF_52(uint256),i(uint256) := 0(uint256),REF_53 -> LENGTH _modules,TMP_138(bool) = i < REF_53,CONDITION TMP_138,REF_54(address) -> _modules[i],REF_55(bool) -> authorised[REF_54],TMP_139(bool) = REF_55 == False,TMP_140(None) = SOLIDITY_CALL require(bool,string)(TMP_139,BW: module is already added),REF_56(address) -> _modules[i],REF_57(bool) -> authorised[REF_56],REF_57(bool) (->authorised) := True(bool),REF_58(address) -> _modules[i],TMP_141 = CONVERT REF_58 to Module,HIGH_LEVEL_CALL, dest:TMP_141(Module), function:init, arguments:['this']  ,REF_60(address) -> _modules[i],Emit AuthorisedModule(REF_60,True),TMP_144(uint256) := i(uint256),i(uint256) = i + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(owner == address(0) && modules == 0,BW: wallet already initialised)

IRs:
TMP_131 = CONVERT 0 to address
TMP_132(bool) = owner == TMP_131
TMP_133(bool) = modules == 0
TMP_134(bool) = TMP_132 && TMP_133
TMP_135(None) = SOLIDITY_CALL require(bool,string)(TMP_134,BW: wallet already initialised)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(_modules.length > 0,BW: construction requires at least 1 module)

IRs:
REF_51 -> LENGTH _modules
TMP_136(bool) = REF_51 > 0
TMP_137(None) = SOLIDITY_CALL require(bool,string)(TMP_136,BW: construction requires at least 1 module)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner = _owner

IRs:
owner(address) := _owner(address)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
modules = _modules.length

IRs:
REF_52 -> LENGTH _modules
modules(uint256) := REF_52(uint256)""];
4->7;
5[label=""Node Type: BEGIN_LOOP 5
""];
5->8;
6[label=""Node Type: END_LOOP 6
""];
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
7->5;
8[label=""Node Type: IF_LOOP 8

EXPRESSION:
i < _modules.length

IRs:
REF_53 -> LENGTH _modules
TMP_138(bool) = i < REF_53
CONDITION TMP_138""];
8->9[label=""True""];
8->6[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool,string)(authorised[_modules[i]] == false,BW: module is already added)

IRs:
REF_54(address) -> _modules[i]
REF_55(bool) -> authorised[REF_54]
TMP_139(bool) = REF_55 == False
TMP_140(None) = SOLIDITY_CALL require(bool,string)(TMP_139,BW: module is already added)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
authorised[_modules[i]] = true

IRs:
REF_56(address) -> _modules[i]
REF_57(bool) -> authorised[REF_56]
REF_57(bool) (->authorised) := True(bool)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
Module(_modules[i]).init(this)

IRs:
REF_58(address) -> _modules[i]
TMP_141 = CONVERT REF_58 to Module
HIGH_LEVEL_CALL, dest:TMP_141(Module), function:init, arguments:['this']  ""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
AuthorisedModule(_modules[i],true)

IRs:
REF_60(address) -> _modules[i]
Emit AuthorisedModule(REF_60,True)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
i ++

IRs:
TMP_144(uint256) := i(uint256)
i(uint256) = i + 1""];
13->8;
}
",1,0,0,0,"require(bool,string)(owner == address(0) && modules == 0,BW: wallet already initialised);require(bool,string)(_modules.length > 0,BW: construction requires at least 1 module);owner = _owner;modules = _modules.length;i = 0;;i < _modules.length;;require(bool,string)(authorised[_modules[i]] == false,BW: module is already added);authorised[_modules[i]] = true;Module(_modules[i]).init(this);AuthorisedModule(_modules[i],true);i ++"
./0x40818f0d14325a9eba6b2a7d60bd61cb9e27ef0c_ext.sol,Trade.executeTrade,156,196,"TMP_24(address) = INTERNAL_CALL, Registry.getAddress(string)(admin),protocolAdmin(address) := TMP_24(address),TMP_25 = CONVERT src to IERC20,tokenFunctions(IERC20) := TMP_25(IERC20),TMP_26(address) = INTERNAL_CALL, Registry.getAddress(string)(eth),TMP_27(bool) = src == TMP_26,CONDITION TMP_27,TMP_28(bool) = msg.value == srcAmt,TMP_29(None) = SOLIDITY_CALL require(bool,string)(TMP_28,Invalid Operation),ethQty(uint256) := srcAmt(uint256),TMP_30 = CONVERT this to address,TMP_31(bool) = HIGH_LEVEL_CALL, dest:tokenFunctions(IERC20), function:transferFrom, arguments:['msg.sender', 'TMP_30', 'srcAmt']  ,TMP_32(address) = INTERNAL_CALL, Registry.getAddress(string)(kyber),TMP_33 = CONVERT TMP_32 to Kyber,kyberFunctions(Kyber) := TMP_33(Kyber),TMP_35(uint256) = 2 ** 256,TMP_36(uint256) = TMP_35 - 1,TMP_37(uint256) = HIGH_LEVEL_CALL, dest:kyberFunctions(Kyber), function:trade, arguments:['src', 'srcAmt', 'dest', 'msg.sender', 'TMP_36', 'minConversionRate', 'protocolAdmin'] value:ethQty ,destAmt(uint256) := TMP_37(uint256),Emit KyberTrade(src,srcAmt,dest,destAmt,msg.sender,minConversionRate,protocolAdmin),RETURN destAmt","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
protocolAdmin = getAddress(admin)

IRs:
TMP_24(address) = INTERNAL_CALL, Registry.getAddress(string)(admin)
protocolAdmin(address) := TMP_24(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
tokenFunctions = IERC20(src)

IRs:
TMP_25 = CONVERT src to IERC20
tokenFunctions(IERC20) := TMP_25(IERC20)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
src == getAddress(eth)

IRs:
TMP_26(address) = INTERNAL_CALL, Registry.getAddress(string)(eth)
TMP_27(bool) = src == TMP_26
CONDITION TMP_27""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool,string)(msg.value == srcAmt,Invalid Operation)

IRs:
TMP_28(bool) = msg.value == srcAmt
TMP_29(None) = SOLIDITY_CALL require(bool,string)(TMP_28,Invalid Operation)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
ethQty = srcAmt

IRs:
ethQty(uint256) := srcAmt(uint256)""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokenFunctions.transferFrom(msg.sender,address(this),srcAmt)

IRs:
TMP_30 = CONVERT this to address
TMP_31(bool) = HIGH_LEVEL_CALL, dest:tokenFunctions(IERC20), function:transferFrom, arguments:['msg.sender', 'TMP_30', 'srcAmt']  ""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
kyberFunctions = Kyber(getAddress(kyber))

IRs:
TMP_32(address) = INTERNAL_CALL, Registry.getAddress(string)(kyber)
TMP_33 = CONVERT TMP_32 to Kyber
kyberFunctions(Kyber) := TMP_33(Kyber)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
destAmt = kyberFunctions.trade.value(ethQty)(src,srcAmt,dest,msg.sender,2 ** 256 - 1,minConversionRate,protocolAdmin)

IRs:
TMP_35(uint256) = 2 ** 256
TMP_36(uint256) = TMP_35 - 1
TMP_37(uint256) = HIGH_LEVEL_CALL, dest:kyberFunctions(Kyber), function:trade, arguments:['src', 'srcAmt', 'dest', 'msg.sender', 'TMP_36', 'minConversionRate', 'protocolAdmin'] value:ethQty 
destAmt(uint256) := TMP_37(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
KyberTrade(src,srcAmt,dest,destAmt,msg.sender,minConversionRate,protocolAdmin)

IRs:
Emit KyberTrade(src,srcAmt,dest,destAmt,msg.sender,minConversionRate,protocolAdmin)""];
11->12;
12[label=""Node Type: RETURN 12

EXPRESSION:
destAmt

IRs:
RETURN destAmt""];
}
",1,0,0,0,"protocolAdmin = getAddress(admin);;tokenFunctions = IERC20(src);src == getAddress(eth);require(bool,string)(msg.value == srcAmt,Invalid Operation);tokenFunctions.transferFrom(msg.sender,address(this),srcAmt);ethQty = srcAmt;;kyberFunctions = Kyber(getAddress(kyber));destAmt = kyberFunctions.trade.value(ethQty)(src,srcAmt,dest,msg.sender,2 ** 256 - 1,minConversionRate,protocolAdmin);KyberTrade(src,srcAmt,dest,destAmt,msg.sender,minConversionRate,protocolAdmin);destAmt"
./0x0f5d6ae470d3b93eb3347212d480bf9b3acfe4f9_ext.sol,LYFToken.refundTokens,355,361,"TMP_111(bool) = msg.sender == owner,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113 = CONVERT this to address,TMP_114(bool) = _token != TMP_113,TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114),TMP_116 = CONVERT _token to AbstractToken,token(AbstractToken) := TMP_116(AbstractToken),TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ,Emit RefundTokens(_token,_refund,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_111(bool) = msg.sender == owner
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_113 = CONVERT this to address
TMP_114(bool) = _token != TMP_113
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
token = AbstractToken(_token)

IRs:
TMP_116 = CONVERT _token to AbstractToken
token(AbstractToken) := TMP_116(AbstractToken)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(_refund,_value)

IRs:
TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RefundTokens(_token,_refund,_value)

IRs:
Emit RefundTokens(_token,_refund,_value)""];
}
",1,0,0,0,"require(bool)(msg.sender == owner);require(bool)(_token != address(this));token = AbstractToken(_token);token.transfer(_refund,_value);RefundTokens(_token,_refund,_value)"
./0x91db07e4401c2559c7eb8290a77a0feef50843fd_ext.sol,Crowdsale.buyTokens,120,142,"TMP_21(bool) = beneficiary != 0,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),TMP_23(bool) = INTERNAL_CALL, Crowdsale.validPurchase()(),TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),weiAmount(uint256) := msg.value(uint256),TMP_25(uint256) = weiAmount * price,tokens(uint256) := TMP_25(uint256),TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] ,weiRaised(uint256) := TMP_26(uint256),HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['beneficiary', 'tokens']  ,Emit TokenPurchase(msg.sender,beneficiary,weiAmount,tokens),INTERNAL_CALL, Crowdsale.forwardFunds()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != 0x0)

IRs:
TMP_21(bool) = beneficiary != 0
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(validPurchase())

IRs:
TMP_23(bool) = INTERNAL_CALL, Crowdsale.validPurchase()()
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
tokens = (weiAmount) * price

IRs:
TMP_25(uint256) = weiAmount * price
tokens(uint256) := TMP_25(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_26(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tokenReward.transfer(beneficiary,tokens)

IRs:
HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['beneficiary', 'tokens']  ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
forwardFunds()

IRs:
INTERNAL_CALL, Crowdsale.forwardFunds()()""];
}
",1,0,0,0,"require(bool)(beneficiary != 0x0);require(bool)(validPurchase());weiAmount = msg.value;tokens = (weiAmount) * price;weiRaised = weiRaised.add(weiAmount);tokenReward.transfer(beneficiary,tokens);TokenPurchase(msg.sender,beneficiary,weiAmount,tokens);forwardFunds()"
./0xecfe4b7afc47260cb590d3043d3f790a61bb7910_ext.sol,EbyteDistribution.distributeEbyteForEBYTE,120,129,"i(uint256) := 0(uint256),REF_18 -> LENGTH addresses,TMP_32(bool) = i < REF_18,CONDITION TMP_32,REF_19(address) -> addresses[i],TMP_33(uint256) = INTERNAL_CALL, EbyteDistribution.getTokenBalance(address)(REF_19),TMP_34(bool) = TMP_33 < ebyteBalance,CONDITION TMP_34,REF_20(address) -> addresses[i],TMP_35(uint256) = INTERNAL_CALL, EbyteDistribution.getTokenBalance(address)(REF_20),TMP_36(uint256) = TMP_35 / 100,TMP_37(uint256) = TMP_36 * percentage,toDistr(uint256) := TMP_37(uint256),REF_21(address) -> addresses[i],Emit sendTokens(REF_21,toDistr),REF_23(address) -> addresses[i],TMP_39(bool) = HIGH_LEVEL_CALL, dest:ebyteToken(Token), function:transfer, arguments:['REF_23', 'toDistr']  ,TMP_40(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, EbyteDistribution.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addresses.length

IRs:
REF_18 -> LENGTH addresses
TMP_32(bool) = i < REF_18
CONDITION TMP_32""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
getTokenBalance(addresses[i]) < ebyteBalance

IRs:
REF_19(address) -> addresses[i]
TMP_33(uint256) = INTERNAL_CALL, EbyteDistribution.getTokenBalance(address)(REF_19)
TMP_34(bool) = TMP_33 < ebyteBalance
CONDITION TMP_34""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: CONTINUE 6
""];
6->11;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
toDistr = (getTokenBalance(addresses[i]) / 100) * percentage

IRs:
REF_20(address) -> addresses[i]
TMP_35(uint256) = INTERNAL_CALL, EbyteDistribution.getTokenBalance(address)(REF_20)
TMP_36(uint256) = TMP_35 / 100
TMP_37(uint256) = TMP_36 * percentage
toDistr(uint256) := TMP_37(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
sendTokens(addresses[i],toDistr)

IRs:
REF_21(address) -> addresses[i]
Emit sendTokens(REF_21,toDistr)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
ebyteToken.transfer(addresses[i],toDistr)

IRs:
REF_23(address) -> addresses[i]
TMP_39(bool) = HIGH_LEVEL_CALL, dest:ebyteToken(Token), function:transfer, arguments:['REF_23', 'toDistr']  ""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_40(uint256) := i(uint256)
i(uint256) = i + 1""];
11->4;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, EbyteDistribution.onlyOwner()()""];
12->3;
}
",1,0,0,0,"onlyOwner();;i < addresses.length;;i = 0;getTokenBalance(addresses[i]) < ebyteBalance;;;i ++;toDistr = (getTokenBalance(addresses[i]) / 100) * percentage;sendTokens(addresses[i],toDistr);ebyteToken.transfer(addresses[i],toDistr)"
./0xec841c878435ba4f28bf305a00c1483db0d96a20_ext.sol,Events.order,291,295,"TMP_68(bytes) = SOLIDITY_CALL abi.encodePacked()(_message),TMP_69(bytes32) = SOLIDITY_CALL keccak256()(TMP_68),Emit LogOrder(_message,TMP_69,_orderID,_amount,_price,tx.origin),MODIFIER_CALL, Events.onlyApprovedContract()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
LogOrder(_message,keccak256()(abi.encodePacked(_message)),_orderID,_amount,_price,tx.origin)

IRs:
TMP_68(bytes) = SOLIDITY_CALL abi.encodePacked()(_message)
TMP_69(bytes32) = SOLIDITY_CALL keccak256()(TMP_68)
Emit LogOrder(_message,TMP_69,_orderID,_amount,_price,tx.origin)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyApprovedContract()

IRs:
MODIFIER_CALL, Events.onlyApprovedContract()()""];
2->1;
}
",1,0,0,0,"onlyApprovedContract();LogOrder(_message,keccak256()(abi.encodePacked(_message)),_orderID,_amount,_price,tx.origin)"
./0x01d6208f95cf2292c350fc8bb1b1f29230352675_ext.sol,DepositWithdraw.receiveApproval,277,286,"TMP_103 = CONVERT 0 to address,TMP_104(bool) = _token != TMP_103,TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104),TMP_106 = CONVERT 0 to address,TMP_107(bool) = _from != TMP_106,TMP_108(None) = SOLIDITY_CALL require(bool)(TMP_107),TMP_109 = CONVERT _token to ERC20,tk(ERC20) := TMP_109(ERC20),TMP_110(bool) = HIGH_LEVEL_CALL, dest:tk(ERC20), function:transferFrom, arguments:['_from', 'this', '_value']  ,TMP_111(None) = SOLIDITY_CALL require(bool)(TMP_110),TMP_112(bytes32) = INTERNAL_CALL, DepositWithdraw.bytesToBytes32(bytes)(_extraData),timestamp(bytes32) := TMP_112(bytes32),TMP_113 = CONVERT timestamp to uint256,TMP_114(DepositWithdraw.TransferRecord) = new TransferRecord(TMP_113,_from,_value),REF_10 -> LENGTH deposRecs,TMP_116(uint256) := REF_10(uint256),TMP_117(uint256) = TMP_116 + 1,REF_10(uint256) (->deposRecs) := TMP_117(uint256),REF_11(DepositWithdraw.TransferRecord) -> deposRecs[TMP_116],REF_11(DepositWithdraw.TransferRecord) (->deposRecs) := TMP_114(DepositWithdraw.TransferRecord),Emit ReceiveDeposit(_from,_value,_token,_extraData),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_token != address(0))

IRs:
TMP_103 = CONVERT 0 to address
TMP_104(bool) = _token != TMP_103
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_from != address(0))

IRs:
TMP_106 = CONVERT 0 to address
TMP_107(bool) = _from != TMP_106
TMP_108(None) = SOLIDITY_CALL require(bool)(TMP_107)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
tk = ERC20(_token)

IRs:
TMP_109 = CONVERT _token to ERC20
tk(ERC20) := TMP_109(ERC20)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(tk.transferFrom(_from,this,_value))

IRs:
TMP_110(bool) = HIGH_LEVEL_CALL, dest:tk(ERC20), function:transferFrom, arguments:['_from', 'this', '_value']  
TMP_111(None) = SOLIDITY_CALL require(bool)(TMP_110)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
timestamp = bytesToBytes32(_extraData)

IRs:
TMP_112(bytes32) = INTERNAL_CALL, DepositWithdraw.bytesToBytes32(bytes)(_extraData)
timestamp(bytes32) := TMP_112(bytes32)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
deposRecs.push(TransferRecord(uint256(timestamp),_from,_value))

IRs:
TMP_113 = CONVERT timestamp to uint256
TMP_114(DepositWithdraw.TransferRecord) = new TransferRecord(TMP_113,_from,_value)
REF_10 -> LENGTH deposRecs
TMP_116(uint256) := REF_10(uint256)
TMP_117(uint256) = TMP_116 + 1
REF_10(uint256) (->deposRecs) := TMP_117(uint256)
REF_11(DepositWithdraw.TransferRecord) -> deposRecs[TMP_116]
REF_11(DepositWithdraw.TransferRecord) (->deposRecs) := TMP_114(DepositWithdraw.TransferRecord)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
ReceiveDeposit(_from,_value,_token,_extraData)

IRs:
Emit ReceiveDeposit(_from,_value,_token,_extraData)""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
8->1;
}
",1,0,0,0,"onlyOwner();require(bool)(_token != address(0));require(bool)(_from != address(0));tk = ERC20(_token);require(bool)(tk.transferFrom(_from,this,_value));timestamp = bytesToBytes32(_extraData);deposRecs.push(TransferRecord(uint256(timestamp),_from,_value));ReceiveDeposit(_from,_value,_token,_extraData)"
./0x44f958d420f0543353a5e4f14e827d73f01b4261_ext.sol,EBBToken.migrate,195,209,"CONDITION isFunding,TMP_80 = CONVERT 0 to address,TMP_81(bool) = newContractAddr == TMP_80,CONDITION TMP_81,REF_31(uint256) -> balances[msg.sender],tokens(uint256) := REF_31(uint256),TMP_82(bool) = tokens == 0,CONDITION TMP_82,REF_32(uint256) -> balances[msg.sender],REF_32(uint256) (->balances) := 0(uint256),TMP_83(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(tokenMigrated,tokens),tokenMigrated(uint256) := TMP_83(uint256),TMP_84 = CONVERT newContractAddr to IMigrationContract,newContract(IMigrationContract) := TMP_84(IMigrationContract),TMP_85(bool) = HIGH_LEVEL_CALL, dest:newContract(IMigrationContract), function:migrate, arguments:['msg.sender', 'tokens']  ,TMP_86 = UnaryType.BANG TMP_85 ,CONDITION TMP_86,Emit Migrate(msg.sender,tokens)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
isFunding

IRs:
CONDITION isFunding""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
newContractAddr == address(0x0)

IRs:
TMP_80 = CONVERT 0 to address
TMP_81(bool) = newContractAddr == TMP_80
CONDITION TMP_81""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: THROW 5
""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
tokens = balances[msg.sender]

IRs:
REF_31(uint256) -> balances[msg.sender]
tokens(uint256) := REF_31(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
tokens == 0

IRs:
TMP_82(bool) = tokens == 0
CONDITION TMP_82""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: THROW 9
""];
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
balances[msg.sender] = 0

IRs:
REF_32(uint256) -> balances[msg.sender]
REF_32(uint256) (->balances) := 0(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
tokenMigrated = safeAdd(tokenMigrated,tokens)

IRs:
TMP_83(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(tokenMigrated,tokens)
tokenMigrated(uint256) := TMP_83(uint256)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
newContract = IMigrationContract(newContractAddr)

IRs:
TMP_84 = CONVERT newContractAddr to IMigrationContract
newContract(IMigrationContract) := TMP_84(IMigrationContract)""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
! newContract.migrate(msg.sender,tokens)

IRs:
TMP_85(bool) = HIGH_LEVEL_CALL, dest:newContract(IMigrationContract), function:migrate, arguments:['msg.sender', 'tokens']  
TMP_86 = UnaryType.BANG TMP_85 
CONDITION TMP_86""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: THROW 15
""];
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
Migrate(msg.sender,tokens)

IRs:
Emit Migrate(msg.sender,tokens)""];
}
",1,0,0,0,"isFunding;;;newContractAddr == address(0x0);;;tokens = balances[msg.sender];tokens == 0;;;balances[msg.sender] = 0;tokenMigrated = safeAdd(tokenMigrated,tokens);newContract = IMigrationContract(newContractAddr);! newContract.migrate(msg.sender,tokens);;;Migrate(msg.sender,tokens)"
./0x183891e9cfaee0c9e2dbcdfefe1505626c696951_ext.sol,Crowdsale.distributeTokensManual,1397,1404,"INTERNAL_CALL, PausableCrowdsale._preValidatePurchase(address,uint256)(_beneficiary,_tokensAmount),INTERNAL_CALL, BaseCrowdsale._deliverTokens(address,uint256)(_beneficiary,_tokensAmount),Emit TokensPurchaseLog(MANUAL,_beneficiary,0,_tokensAmount,0),INTERNAL_CALL, LockableCrowdsale._postPurchaseUpdate(address,uint256)(_beneficiary,_tokensAmount),MODIFIER_CALL, Operable.hasOwnerOrOperatePermission()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_preValidatePurchase(_beneficiary,_tokensAmount)

IRs:
INTERNAL_CALL, PausableCrowdsale._preValidatePurchase(address,uint256)(_beneficiary,_tokensAmount)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_deliverTokens(_beneficiary,_tokensAmount)

IRs:
INTERNAL_CALL, BaseCrowdsale._deliverTokens(address,uint256)(_beneficiary,_tokensAmount)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
TokensPurchaseLog(MANUAL,_beneficiary,0,_tokensAmount,0)

IRs:
Emit TokensPurchaseLog(MANUAL,_beneficiary,0,_tokensAmount,0)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
_postPurchaseUpdate(_beneficiary,_tokensAmount)

IRs:
INTERNAL_CALL, LockableCrowdsale._postPurchaseUpdate(address,uint256)(_beneficiary,_tokensAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
hasOwnerOrOperatePermission()

IRs:
MODIFIER_CALL, Operable.hasOwnerOrOperatePermission()()""];
5->1;
}
",1,0,0,0,"hasOwnerOrOperatePermission();_preValidatePurchase(_beneficiary,_tokensAmount);_deliverTokens(_beneficiary,_tokensAmount);TokensPurchaseLog(MANUAL,_beneficiary,0,_tokensAmount,0);_postPurchaseUpdate(_beneficiary,_tokensAmount)"
./0x3a773baa30d09f04da0bd869b142ea5503a31022_ext.sol,MiniMeTokenSimple.claimTokens,207,217,"TMP_51(bool) = _token == 0,CONDITION TMP_51,REF_33(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:controller value:REF_33,TMP_53 = CONVERT _token to ERC20Token,token(ERC20Token) := TMP_53(ERC20Token),TMP_54(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_54(uint256),TMP_55(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:transfer, arguments:['controller', 'balance']  ,Emit ClaimedTokens(_token,controller,balance),MODIFIER_CALL, Controlled.onlyController()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_51(bool) = _token == 0
CONDITION TMP_51""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_33(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_33""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
token = ERC20Token(_token)

IRs:
TMP_53 = CONVERT _token to ERC20Token
token(ERC20Token) := TMP_53(ERC20Token)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_54(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_54(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_55(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:transfer, arguments:['controller', 'balance']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()""];
9->1;
}
",1,0,0,0,"onlyController();_token == 0x0;controller.transfer(this.balance);;;token = ERC20Token(_token);balance = token.balanceOf(this);token.transfer(controller,balance);ClaimedTokens(_token,controller,balance)"
./0x750c1d91864171d7e1715a6b53ee28c72b8faa09_ext.sol,EthicHubUser.unregisterLocalNode,159,168,"TMP_70 = CONVERT 0 to address,TMP_71(bool) = target != TMP_70,TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71),TMP_73(bytes32) = SOLIDITY_CALL keccak256()(user,localNode,target),TMP_74(bool) = HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:getBool, arguments:['TMP_73']  ,isRegistered(bool) := TMP_74(bool),CONDITION isRegistered,INTERNAL_CALL, EthicHubUser.deleteUserStatus(address,string)(target,localNode),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(target != address(0))

IRs:
TMP_70 = CONVERT 0 to address
TMP_71(bool) = target != TMP_70
TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
isRegistered = ethicHubStorage.getBool(keccak256()(user,localNode,target))

IRs:
TMP_73(bytes32) = SOLIDITY_CALL keccak256()(user,localNode,target)
TMP_74(bool) = HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:getBool, arguments:['TMP_73']  
isRegistered(bool) := TMP_74(bool)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
isRegistered

IRs:
CONDITION isRegistered""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
deleteUserStatus(target,localNode)

IRs:
INTERNAL_CALL, EthicHubUser.deleteUserStatus(address,string)(target,localNode)""];
4->5;
5[label=""Node Type: END_IF 5
""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",1,0,0,0,"onlyOwner();require(bool)(target != address(0));isRegistered = ethicHubStorage.getBool(keccak256()(user,localNode,target));isRegistered;deleteUserStatus(target,localNode);"
./0x1dd6363c7f7a3150fb7ab13c29fe92f5bab23457_ext.sol,CharityProject.withdrawTokens,393,403,"TMP_98(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['_to', '_value']  ,TMP_99(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['withdrawn', '_value'] ,withdrawn(uint256) := TMP_99(uint256),MODIFIER_CALL, RBACManager.onlyOwnerOrManager()(),MODIFIER_CALL, CharityProject.canWithdraw()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
token.transfer(_to,_value)

IRs:
TMP_98(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['_to', '_value']  ""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
withdrawn = withdrawn.add(_value)

IRs:
TMP_99(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['withdrawn', '_value'] 
withdrawn(uint256) := TMP_99(uint256)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwnerOrManager()

IRs:
MODIFIER_CALL, RBACManager.onlyOwnerOrManager()()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
canWithdraw()

IRs:
MODIFIER_CALL, CharityProject.canWithdraw()()""];
4->1;
}
",1,0,0,0,"onlyOwnerOrManager();token.transfer(_to,_value);withdrawn = withdrawn.add(_value);canWithdraw()"
./0x589fbf3d4168518b8b849b7eedfdb719407900ca_ext.sol,AirDropLight.transferDirect,215,233,"TMP_59(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  ,TMP_60(bool) = TMP_59 >= _tokens,TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60),TMP_62(bool) = _tokens < maxDirect,TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62),REF_4(bool) -> recipients[_recipient],TMP_64 = UnaryType.BANG REF_4 ,TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64),REF_5(bool) -> recipients[_recipient],REF_5(bool) (->recipients) := True(bool),TMP_66(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['_recipient', '_tokens']  ,TMP_67(None) = SOLIDITY_CALL require(bool)(TMP_66),TMP_68(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['grandTotalClaimed', '_tokens'] ,grandTotalClaimed(uint256) := TMP_68(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(token.balanceOf(this) >= _tokens)

IRs:
TMP_59(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  
TMP_60(bool) = TMP_59 >= _tokens
TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_tokens < maxDirect)

IRs:
TMP_62(bool) = _tokens < maxDirect
TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(! recipients[_recipient])

IRs:
REF_4(bool) -> recipients[_recipient]
TMP_64 = UnaryType.BANG REF_4 
TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
recipients[_recipient] = true

IRs:
REF_5(bool) -> recipients[_recipient]
REF_5(bool) (->recipients) := True(bool)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(token.transfer(_recipient,_tokens))

IRs:
TMP_66(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['_recipient', '_tokens']  
TMP_67(None) = SOLIDITY_CALL require(bool)(TMP_66)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
grandTotalClaimed = grandTotalClaimed.add(_tokens)

IRs:
TMP_68(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['grandTotalClaimed', '_tokens'] 
grandTotalClaimed(uint256) := TMP_68(uint256)""];
}
",1,0,0,0,"require(bool)(token.balanceOf(this) >= _tokens);require(bool)(_tokens < maxDirect);require(bool)(! recipients[_recipient]);recipients[_recipient] = true;require(bool)(token.transfer(_recipient,_tokens));grandTotalClaimed = grandTotalClaimed.add(_tokens)"
./0x861a174d677946d8c2bea8f9636a53fde1668215_ext.sol,SmartContractBank.increasePercent,350,356,"REF_86(SmartContractBank.Investor) -> investors[msg.sender],investor(SmartContractBank.Investor) := REF_86(SmartContractBank.Investor),TMP_119(uint256) = HIGH_LEVEL_CALL, dest:CBCTokenContract(CBCToken), function:balanceOf, arguments:['msg.sender']  ,TMP_120(bool) = TMP_119 >= 10000000000000000000,CONDITION TMP_120,HIGH_LEVEL_CALL, dest:MainSaleContract(MainSale), function:authorizedBurnTokens, arguments:['msg.sender', '10000000000000000000']  ,REF_89(bool) -> investor.increasedPercent,REF_89(bool) (->investor) := True(bool)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
investor = investors[msg.sender]

IRs:
REF_86(SmartContractBank.Investor) -> investors[msg.sender]
investor(SmartContractBank.Investor) := REF_86(SmartContractBank.Investor)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
CBCTokenContract.balanceOf(msg.sender) >= 10000000000000000000

IRs:
TMP_119(uint256) = HIGH_LEVEL_CALL, dest:CBCTokenContract(CBCToken), function:balanceOf, arguments:['msg.sender']  
TMP_120(bool) = TMP_119 >= 10000000000000000000
CONDITION TMP_120""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
MainSaleContract.authorizedBurnTokens(msg.sender,10000000000000000000)

IRs:
HIGH_LEVEL_CALL, dest:MainSaleContract(MainSale), function:authorizedBurnTokens, arguments:['msg.sender', '10000000000000000000']  ""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
investor.increasedPercent = true

IRs:
REF_89(bool) -> investor.increasedPercent
REF_89(bool) (->investor) := True(bool)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",1,0,0,0,"investor = investors[msg.sender];CBCTokenContract.balanceOf(msg.sender) >= 10000000000000000000;MainSaleContract.authorizedBurnTokens(msg.sender,10000000000000000000);;investor.increasedPercent = true"
./0x4bc78f6619991b029b867b6d88d39c196332aba3_ext.sol,AlgoDEX.withdraw,212,217,"REF_51(mapping(address => uint256)) -> tokens[0],REF_52(uint256) -> REF_51[msg.sender],TMP_93(bool) = REF_52 < amount,CONDITION TMP_93,TMP_94(None) = SOLIDITY_CALL revert()(),REF_53(mapping(address => uint256)) -> tokens[0],REF_54(uint256) -> REF_53[msg.sender],REF_55(mapping(address => uint256)) -> tokens[0],REF_56(uint256) -> REF_55[msg.sender],TMP_95(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_56,amount),REF_54(uint256) (->tokens) := TMP_95(uint256),TMP_97(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:amount ,TMP_98 = UnaryType.BANG TMP_97 ,CONDITION TMP_98,TMP_99(None) = SOLIDITY_CALL revert()(),REF_59(mapping(address => uint256)) -> tokens[0],REF_60(uint256) -> REF_59[msg.sender],Emit Withdraw(0,msg.sender,amount,REF_60)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
tokens[0][msg.sender] < amount

IRs:
REF_51(mapping(address => uint256)) -> tokens[0]
REF_52(uint256) -> REF_51[msg.sender]
TMP_93(bool) = REF_52 < amount
CONDITION TMP_93""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_94(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender],amount)

IRs:
REF_53(mapping(address => uint256)) -> tokens[0]
REF_54(uint256) -> REF_53[msg.sender]
REF_55(mapping(address => uint256)) -> tokens[0]
REF_56(uint256) -> REF_55[msg.sender]
TMP_95(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_56,amount)
REF_54(uint256) (->tokens) := TMP_95(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
! msg.sender.call.value(amount)()

IRs:
TMP_97(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:amount 
TMP_98 = UnaryType.BANG TMP_97 
CONDITION TMP_98""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
revert()()

IRs:
TMP_99(None) = SOLIDITY_CALL revert()()""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Withdraw(0,msg.sender,amount,tokens[0][msg.sender])

IRs:
REF_59(mapping(address => uint256)) -> tokens[0]
REF_60(uint256) -> REF_59[msg.sender]
Emit Withdraw(0,msg.sender,amount,REF_60)""];
}
",1,0,0,0,"tokens[0][msg.sender] < amount;revert()();;tokens[0][msg.sender] = safeSub(tokens[0][msg.sender],amount);! msg.sender.call.value(amount)();revert()();;Withdraw(0,msg.sender,amount,tokens[0][msg.sender])"
./0x02242d41c54f261a85ac8e8efa7046a3dfd53113_ext.sol,C_banK.Collect,15,28,"REF_5(C_banK.Holder) -> Acc[msg.sender],acc(C_banK.Holder) := REF_5(C_banK.Holder),REF_6(uint256) -> acc.balance,TMP_2(bool) = REF_6 >= MinSum,REF_7(uint256) -> acc.balance,TMP_3(bool) = REF_7 >= _am,TMP_4(bool) = TMP_2 && TMP_3,REF_8(uint256) -> acc.unlockTime,TMP_5(bool) = now > REF_8,TMP_6(bool) = TMP_4 && TMP_5,CONDITION TMP_6,TMP_8(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:_am ,CONDITION TMP_8,REF_11(uint256) -> acc.balance,REF_11(-> acc) = REF_11 - _am,HIGH_LEVEL_CALL, dest:LogFile(Log), function:AddMessage, arguments:['msg.sender', '_am', 'Collect']  ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
acc = Acc[msg.sender]

IRs:
REF_5(C_banK.Holder) -> Acc[msg.sender]
acc(C_banK.Holder) := REF_5(C_banK.Holder)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
acc.balance >= MinSum && acc.balance >= _am && now > acc.unlockTime

IRs:
REF_6(uint256) -> acc.balance
TMP_2(bool) = REF_6 >= MinSum
REF_7(uint256) -> acc.balance
TMP_3(bool) = REF_7 >= _am
TMP_4(bool) = TMP_2 && TMP_3
REF_8(uint256) -> acc.unlockTime
TMP_5(bool) = now > REF_8
TMP_6(bool) = TMP_4 && TMP_5
CONDITION TMP_6""];
2->3[label=""True""];
2->7[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
msg.sender.call.value(_am)()

IRs:
TMP_8(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:_am 
CONDITION TMP_8""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
acc.balance -= _am

IRs:
REF_11(uint256) -> acc.balance
REF_11(-> acc) = REF_11 - _am""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
LogFile.AddMessage(msg.sender,_am,Collect)

IRs:
HIGH_LEVEL_CALL, dest:LogFile(Log), function:AddMessage, arguments:['msg.sender', '_am', 'Collect']  ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: END_IF 7
""];
}
",1,0,0,0,"acc = Acc[msg.sender];acc.balance >= MinSum && acc.balance >= _am && now > acc.unlockTime;msg.sender.call.value(_am)();;acc.balance -= _am;;LogFile.AddMessage(msg.sender,_am,Collect)"
./0xa2909e1bcbb24b285741db27a11bfa5706ad4ae5_ext.sol,Crowdsale.finalize,327,345,"TMP_127(bool) = now < endTime,CONDITION TMP_127,TMP_128(bool) = manusSentToEther == MAX_CAP,CONDITION TMP_128,TMP_129(bool) = manusSentToEther < MIN_CAP,TMP_130(uint256) = endTime + 1296000,TMP_131(bool) = now < TMP_130,TMP_132(bool) = TMP_129 && TMP_131,CONDITION TMP_132,REF_94(uint256) = SOLIDITY_CALL balance(address)(this),TMP_133 = SEND dest:multisigEther value:REF_94,TMP_134 = UnaryType.BANG TMP_133 ,CONDITION TMP_134,TMP_135(uint256) = HIGH_LEVEL_CALL, dest:manus(Manus), function:balanceOf, arguments:['this']  ,remains(uint256) := TMP_135(uint256),TMP_136(bool) = remains > 0,CONDITION TMP_136,TMP_137(bool) = HIGH_LEVEL_CALL, dest:manus(Manus), function:burn, arguments:['remains']  ,TMP_138 = UnaryType.BANG TMP_137 ,CONDITION TMP_138,crowdsaleClosed(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->19;
1[label=""Node Type: IF 1

EXPRESSION:
now < endTime

IRs:
TMP_127(bool) = now < endTime
CONDITION TMP_127""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
manusSentToEther == MAX_CAP

IRs:
TMP_128(bool) = manusSentToEther == MAX_CAP
CONDITION TMP_128""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: THROW 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
manusSentToEther < MIN_CAP && now < endTime + 1296000

IRs:
TMP_129(bool) = manusSentToEther < MIN_CAP
TMP_130(uint256) = endTime + 1296000
TMP_131(bool) = now < TMP_130
TMP_132(bool) = TMP_129 && TMP_131
CONDITION TMP_132""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: THROW 7
""];
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
! multisigEther.send(this.balance)

IRs:
REF_94(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_133 = SEND dest:multisigEther value:REF_94
TMP_134 = UnaryType.BANG TMP_133 
CONDITION TMP_134""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: THROW 10
""];
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
remains = manus.balanceOf(this)

IRs:
TMP_135(uint256) = HIGH_LEVEL_CALL, dest:manus(Manus), function:balanceOf, arguments:['this']  
remains(uint256) := TMP_135(uint256)""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
remains > 0

IRs:
TMP_136(bool) = remains > 0
CONDITION TMP_136""];
13->14[label=""True""];
13->17[label=""False""];
14[label=""Node Type: IF 14

EXPRESSION:
! manus.burn(remains)

IRs:
TMP_137(bool) = HIGH_LEVEL_CALL, dest:manus(Manus), function:burn, arguments:['remains']  
TMP_138 = UnaryType.BANG TMP_137 
CONDITION TMP_138""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: THROW 15
""];
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
crowdsaleClosed = true

IRs:
crowdsaleClosed(bool) := True(bool)""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
19->1;
}
",1,0,1,0,onlyOwner();now < endTime;manusSentToEther == MAX_CAP;;;;manusSentToEther < MIN_CAP && now < endTime + 1296000;;;! multisigEther.send(this.balance);;;remains = manus.balanceOf(this);remains > 0;! manus.burn(remains);;;;crowdsaleClosed = true
./0x0f5ee401de162cd163b6ff46318eef2727dbb9fc_ext.sol,MOIRAICO.contribute,108,132,"TMP_13(bool) = msg.value > 1000000000000000,TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13),TMP_15(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalRaised', 'msg.value'] ,totalRaised(uint256) := TMP_15(uint256),currentBalance(uint256) := totalRaised(uint256),REF_3(MOIRAICO.State) -> State.Preico,TMP_16(bool) = state == REF_3,CONDITION TMP_16,REF_5(uint256) -> tablePrices[0],TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', 'REF_5'] ,tokenBought(uint256) := TMP_17(uint256),REF_6(MOIRAICO.State) -> State.Preico,TMP_18(bool) = state == REF_6,TMP_19(uint256) = startTime + 86400,TMP_20(bool) = now < TMP_19,TMP_21(bool) = TMP_18 && TMP_20,CONDITION TMP_21,REF_8(uint256) -> tablePrices[1],TMP_22(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', 'REF_8'] ,tokenBought(uint256) := TMP_22(uint256),REF_10(uint256) -> tablePrices[2],TMP_23(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', 'REF_10'] ,tokenBought(uint256) := TMP_23(uint256),TMP_24(bool) = HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['msg.sender', 'tokenBought']  ,Emit LogFundingReceived(msg.sender,msg.value,totalRaised),Emit LogContributorsPayout(msg.sender,tokenBought),INTERNAL_CALL, MOIRAICO.checkIfFundingCompleteOrExpired()(),MODIFIER_CALL, MOIRAICO.notFinished()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->16;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value > 1000000000000000)

IRs:
TMP_13(bool) = msg.value > 1000000000000000
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalRaised = SafeMath.add(totalRaised,msg.value)

IRs:
TMP_15(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalRaised', 'msg.value'] 
totalRaised(uint256) := TMP_15(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
currentBalance = totalRaised

IRs:
currentBalance(uint256) := totalRaised(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
state == State.Preico

IRs:
REF_3(MOIRAICO.State) -> State.Preico
TMP_16(bool) = state == REF_3
CONDITION TMP_16""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tokenBought = SafeMath.mul(msg.value,tablePrices[0])

IRs:
REF_5(uint256) -> tablePrices[0]
TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', 'REF_5'] 
tokenBought(uint256) := TMP_17(uint256)""];
6->11;
7[label=""Node Type: IF 7

EXPRESSION:
state == State.Preico && now < (startTime + 86400)

IRs:
REF_6(MOIRAICO.State) -> State.Preico
TMP_18(bool) = state == REF_6
TMP_19(uint256) = startTime + 86400
TMP_20(bool) = now < TMP_19
TMP_21(bool) = TMP_18 && TMP_20
CONDITION TMP_21""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
tokenBought = SafeMath.mul(msg.value,tablePrices[1])

IRs:
REF_8(uint256) -> tablePrices[1]
TMP_22(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', 'REF_8'] 
tokenBought(uint256) := TMP_22(uint256)""];
8->10;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
tokenBought = SafeMath.mul(msg.value,tablePrices[2])

IRs:
REF_10(uint256) -> tablePrices[2]
TMP_23(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', 'REF_10'] 
tokenBought(uint256) := TMP_23(uint256)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
tokenReward.transfer(msg.sender,tokenBought)

IRs:
TMP_24(bool) = HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['msg.sender', 'tokenBought']  ""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
LogFundingReceived(msg.sender,msg.value,totalRaised)

IRs:
Emit LogFundingReceived(msg.sender,msg.value,totalRaised)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
LogContributorsPayout(msg.sender,tokenBought)

IRs:
Emit LogContributorsPayout(msg.sender,tokenBought)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
checkIfFundingCompleteOrExpired()

IRs:
INTERNAL_CALL, MOIRAICO.checkIfFundingCompleteOrExpired()()""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
notFinished()

IRs:
MODIFIER_CALL, MOIRAICO.notFinished()()""];
16->1;
}
",1,0,0,0,"notFinished();require(bool)(msg.value > 1000000000000000);;totalRaised = SafeMath.add(totalRaised,msg.value);currentBalance = totalRaised;state == State.Preico;tokenBought = SafeMath.mul(msg.value,tablePrices[0]);state == State.Preico && now < (startTime + 86400);;tokenBought = SafeMath.mul(msg.value,tablePrices[1]);tokenBought = SafeMath.mul(msg.value,tablePrices[2]);;tokenReward.transfer(msg.sender,tokenBought);LogFundingReceived(msg.sender,msg.value,totalRaised);LogContributorsPayout(msg.sender,tokenBought);checkIfFundingCompleteOrExpired()"
./0x4900320fe47208de0b79db1273a78ab8c8f3528d_ext.sol,Crowdsale.withdrawalOwner,201,207,"REF_22(uint256) = SOLIDITY_CALL balance(address)(this),amount(uint256) := REF_22([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E5DB9B80>]),TMP_103(bool) = amount > 0,CONDITION TMP_103,TMP_105(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:amount ,ok(bool) := TMP_105(bool),Emit WithdrawalEther(msg.sender,amount,ok),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
amount = this.balance

IRs:
REF_22(uint256) = SOLIDITY_CALL balance(address)(this)
amount(uint256) := REF_22([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E5DB9B80>])""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
amount > 0

IRs:
TMP_103(bool) = amount > 0
CONDITION TMP_103""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
ok = msg.sender.call.value(amount)()

IRs:
TMP_105(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:amount 
ok(bool) := TMP_105(bool)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
WithdrawalEther(msg.sender,amount,ok)

IRs:
Emit WithdrawalEther(msg.sender,amount,ok)""];
4->5;
5[label=""Node Type: END_IF 5
""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
6->1;
}
",1,0,0,0,"onlyOwner();amount = this.balance;amount > 0;ok = msg.sender.call.value(amount)();;WithdrawalEther(msg.sender,amount,ok)"
./0xa5cc679a3528956e8032df4f03756c077c1ee3f4_ext.sol,Exchange.withdraw,219,229,"REF_32(uint256) -> lastActiveTransaction[msg.sender],TMP_79(uint256) = INTERNAL_CALL, Exchange.safeSub(uint256,uint256)(block.number,REF_32),TMP_80(bool) = TMP_79 < inactivityReleasePeriod,CONDITION TMP_80,REF_33(mapping(address => uint256)) -> tokens[token],REF_34(uint256) -> REF_33[msg.sender],TMP_81(bool) = REF_34 < amount,CONDITION TMP_81,REF_35(mapping(address => uint256)) -> tokens[token],REF_36(uint256) -> REF_35[msg.sender],REF_37(mapping(address => uint256)) -> tokens[token],REF_38(uint256) -> REF_37[msg.sender],TMP_82(uint256) = INTERNAL_CALL, Exchange.safeSub(uint256,uint256)(REF_38,amount),REF_36(uint256) (->tokens) := TMP_82(uint256),TMP_83 = CONVERT 0 to address,TMP_84(bool) = token == TMP_83,CONDITION TMP_84,TMP_85 = SEND dest:msg.sender value:amount,TMP_86 = UnaryType.BANG TMP_85 ,CONDITION TMP_86,TMP_87 = CONVERT token to Token,TMP_88(bool) = HIGH_LEVEL_CALL, dest:TMP_87(Token), function:transfer, arguments:['msg.sender', 'amount']  ,TMP_89 = UnaryType.BANG TMP_88 ,CONDITION TMP_89,REF_41(mapping(address => uint256)) -> tokens[token],REF_42(uint256) -> REF_41[msg.sender],Emit Withdraw(token,msg.sender,amount,REF_42,0),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
safeSub(block.number,lastActiveTransaction[msg.sender]) < inactivityReleasePeriod

IRs:
REF_32(uint256) -> lastActiveTransaction[msg.sender]
TMP_79(uint256) = INTERNAL_CALL, Exchange.safeSub(uint256,uint256)(block.number,REF_32)
TMP_80(bool) = TMP_79 < inactivityReleasePeriod
CONDITION TMP_80""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
tokens[token][msg.sender] < amount

IRs:
REF_33(mapping(address => uint256)) -> tokens[token]
REF_34(uint256) -> REF_33[msg.sender]
TMP_81(bool) = REF_34 < amount
CONDITION TMP_81""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: THROW 5
""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens[token][msg.sender] = safeSub(tokens[token][msg.sender],amount)

IRs:
REF_35(mapping(address => uint256)) -> tokens[token]
REF_36(uint256) -> REF_35[msg.sender]
REF_37(mapping(address => uint256)) -> tokens[token]
REF_38(uint256) -> REF_37[msg.sender]
TMP_82(uint256) = INTERNAL_CALL, Exchange.safeSub(uint256,uint256)(REF_38,amount)
REF_36(uint256) (->tokens) := TMP_82(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
token == address(0)

IRs:
TMP_83 = CONVERT 0 to address
TMP_84(bool) = token == TMP_83
CONDITION TMP_84""];
8->9[label=""True""];
8->12[label=""False""];
9[label=""Node Type: IF 9

EXPRESSION:
! msg.sender.send(amount)

IRs:
TMP_85 = SEND dest:msg.sender value:amount
TMP_86 = UnaryType.BANG TMP_85 
CONDITION TMP_86""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: THROW 10
""];
11[label=""Node Type: END_IF 11
""];
11->15;
12[label=""Node Type: IF 12

EXPRESSION:
! Token(token).transfer(msg.sender,amount)

IRs:
TMP_87 = CONVERT token to Token
TMP_88(bool) = HIGH_LEVEL_CALL, dest:TMP_87(Token), function:transfer, arguments:['msg.sender', 'amount']  
TMP_89 = UnaryType.BANG TMP_88 
CONDITION TMP_89""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: THROW 13
""];
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
Withdraw(token,msg.sender,amount,tokens[token][msg.sender],0)

IRs:
REF_41(mapping(address => uint256)) -> tokens[token]
REF_42(uint256) -> REF_41[msg.sender]
Emit Withdraw(token,msg.sender,amount,REF_42,0)""];
16->17;
17[label=""Node Type: RETURN 17

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,0,0,0,"safeSub(block.number,lastActiveTransaction[msg.sender]) < inactivityReleasePeriod;;;tokens[token][msg.sender] < amount;;;tokens[token][msg.sender] = safeSub(tokens[token][msg.sender],amount);token == address(0);! msg.sender.send(amount);! Token(token).transfer(msg.sender,amount);;;;;;Withdraw(token,msg.sender,amount,tokens[token][msg.sender],0);success"
./0x850c430378909ba9ff2494d0a4df17928e99f8f4_ext.sol,BdpOwnership.approve,738,747,"TMP_380(address) = LIBRARY_CALL, dest:BdpContracts, function:BdpContracts.getBdpOwnershipStorage(address[16]), arguments:['_contracts'] ,TMP_381 = CONVERT TMP_380 to BdpOwnershipStorage,ownStorage(BdpOwnershipStorage) := TMP_381(BdpOwnershipStorage),TMP_382(address) = INTERNAL_CALL, BdpOwnership.ownerOf(address[16],uint256)(_contracts,_tokenId),owner(address) := TMP_382(address),TMP_383(bool) = _to != owner,TMP_384(None) = SOLIDITY_CALL require(bool)(TMP_383),TMP_385(address) = HIGH_LEVEL_CALL, dest:ownStorage(BdpOwnershipStorage), function:getTokenApproval, arguments:['_tokenId']  ,TMP_386(bool) = TMP_385 != 0,TMP_387(bool) = _to != 0,TMP_388(bool) = TMP_386 || TMP_387,CONDITION TMP_388,HIGH_LEVEL_CALL, dest:ownStorage(BdpOwnershipStorage), function:setTokenApproval, arguments:['_tokenId', '_to']  ,Emit Approval(owner,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts))

IRs:
TMP_380(address) = LIBRARY_CALL, dest:BdpContracts, function:BdpContracts.getBdpOwnershipStorage(address[16]), arguments:['_contracts'] 
TMP_381 = CONVERT TMP_380 to BdpOwnershipStorage
ownStorage(BdpOwnershipStorage) := TMP_381(BdpOwnershipStorage)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
owner = ownerOf(_contracts,_tokenId)

IRs:
TMP_382(address) = INTERNAL_CALL, BdpOwnership.ownerOf(address[16],uint256)(_contracts,_tokenId)
owner(address) := TMP_382(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_to != owner)

IRs:
TMP_383(bool) = _to != owner
TMP_384(None) = SOLIDITY_CALL require(bool)(TMP_383)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
ownStorage.getTokenApproval(_tokenId) != 0 || _to != 0

IRs:
TMP_385(address) = HIGH_LEVEL_CALL, dest:ownStorage(BdpOwnershipStorage), function:getTokenApproval, arguments:['_tokenId']  
TMP_386(bool) = TMP_385 != 0
TMP_387(bool) = _to != 0
TMP_388(bool) = TMP_386 || TMP_387
CONDITION TMP_388""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
ownStorage.setTokenApproval(_tokenId,_to)

IRs:
HIGH_LEVEL_CALL, dest:ownStorage(BdpOwnershipStorage), function:setTokenApproval, arguments:['_tokenId', '_to']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Approval(owner,_to,_tokenId)

IRs:
Emit Approval(owner,_to,_tokenId)""];
6->7;
7[label=""Node Type: END_IF 7
""];
}
",1,0,0,0,"ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));owner = ownerOf(_contracts,_tokenId);require(bool)(_to != owner);ownStorage.getTokenApproval(_tokenId) != 0 || _to != 0;ownStorage.setTokenApproval(_tokenId,_to);;Approval(owner,_to,_tokenId)"
./0x40818f0d14325a9eba6b2a7d60bd61cb9e27ef0c_ext.sol,Trade.executeTrade,156,196,"TMP_24(address) = INTERNAL_CALL, Registry.getAddress(string)(admin),protocolAdmin(address) := TMP_24(address),TMP_25 = CONVERT src to IERC20,tokenFunctions(IERC20) := TMP_25(IERC20),TMP_26(address) = INTERNAL_CALL, Registry.getAddress(string)(eth),TMP_27(bool) = src == TMP_26,CONDITION TMP_27,TMP_28(bool) = msg.value == srcAmt,TMP_29(None) = SOLIDITY_CALL require(bool,string)(TMP_28,Invalid Operation),ethQty(uint256) := srcAmt(uint256),TMP_30 = CONVERT this to address,TMP_31(bool) = HIGH_LEVEL_CALL, dest:tokenFunctions(IERC20), function:transferFrom, arguments:['msg.sender', 'TMP_30', 'srcAmt']  ,TMP_32(address) = INTERNAL_CALL, Registry.getAddress(string)(kyber),TMP_33 = CONVERT TMP_32 to Kyber,kyberFunctions(Kyber) := TMP_33(Kyber),TMP_35(uint256) = 2 ** 256,TMP_36(uint256) = TMP_35 - 1,TMP_37(uint256) = HIGH_LEVEL_CALL, dest:kyberFunctions(Kyber), function:trade, arguments:['src', 'srcAmt', 'dest', 'msg.sender', 'TMP_36', 'minConversionRate', 'protocolAdmin'] value:ethQty ,destAmt(uint256) := TMP_37(uint256),Emit KyberTrade(src,srcAmt,dest,destAmt,msg.sender,minConversionRate,protocolAdmin),RETURN destAmt","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
protocolAdmin = getAddress(admin)

IRs:
TMP_24(address) = INTERNAL_CALL, Registry.getAddress(string)(admin)
protocolAdmin(address) := TMP_24(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
tokenFunctions = IERC20(src)

IRs:
TMP_25 = CONVERT src to IERC20
tokenFunctions(IERC20) := TMP_25(IERC20)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
src == getAddress(eth)

IRs:
TMP_26(address) = INTERNAL_CALL, Registry.getAddress(string)(eth)
TMP_27(bool) = src == TMP_26
CONDITION TMP_27""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool,string)(msg.value == srcAmt,Invalid Operation)

IRs:
TMP_28(bool) = msg.value == srcAmt
TMP_29(None) = SOLIDITY_CALL require(bool,string)(TMP_28,Invalid Operation)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
ethQty = srcAmt

IRs:
ethQty(uint256) := srcAmt(uint256)""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokenFunctions.transferFrom(msg.sender,address(this),srcAmt)

IRs:
TMP_30 = CONVERT this to address
TMP_31(bool) = HIGH_LEVEL_CALL, dest:tokenFunctions(IERC20), function:transferFrom, arguments:['msg.sender', 'TMP_30', 'srcAmt']  ""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
kyberFunctions = Kyber(getAddress(kyber))

IRs:
TMP_32(address) = INTERNAL_CALL, Registry.getAddress(string)(kyber)
TMP_33 = CONVERT TMP_32 to Kyber
kyberFunctions(Kyber) := TMP_33(Kyber)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
destAmt = kyberFunctions.trade.value(ethQty)(src,srcAmt,dest,msg.sender,2 ** 256 - 1,minConversionRate,protocolAdmin)

IRs:
TMP_35(uint256) = 2 ** 256
TMP_36(uint256) = TMP_35 - 1
TMP_37(uint256) = HIGH_LEVEL_CALL, dest:kyberFunctions(Kyber), function:trade, arguments:['src', 'srcAmt', 'dest', 'msg.sender', 'TMP_36', 'minConversionRate', 'protocolAdmin'] value:ethQty 
destAmt(uint256) := TMP_37(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
KyberTrade(src,srcAmt,dest,destAmt,msg.sender,minConversionRate,protocolAdmin)

IRs:
Emit KyberTrade(src,srcAmt,dest,destAmt,msg.sender,minConversionRate,protocolAdmin)""];
11->12;
12[label=""Node Type: RETURN 12

EXPRESSION:
destAmt

IRs:
RETURN destAmt""];
}
",1,0,0,0,"protocolAdmin = getAddress(admin);;tokenFunctions = IERC20(src);src == getAddress(eth);require(bool,string)(msg.value == srcAmt,Invalid Operation);tokenFunctions.transferFrom(msg.sender,address(this),srcAmt);ethQty = srcAmt;;kyberFunctions = Kyber(getAddress(kyber));destAmt = kyberFunctions.trade.value(ethQty)(src,srcAmt,dest,msg.sender,2 ** 256 - 1,minConversionRate,protocolAdmin);KyberTrade(src,srcAmt,dest,destAmt,msg.sender,minConversionRate,protocolAdmin);destAmt"
./0x5c89736e9454200141b80c37eb28eaceca2ce8cb_ext.sol,CherryToken.transferdata,274,285,"TMP_131(bool) = _value > 0,TMP_132(None) = SOLIDITY_CALL require(bool)(TMP_131),TMP_133(bool) = INTERNAL_CALL, CherryToken.isContract(address)(_to),CONDITION TMP_133,TMP_134 = CONVERT _to to ERC223ReceivingContract,receiver(ERC223ReceivingContract) := TMP_134(ERC223ReceivingContract),HIGH_LEVEL_CALL, dest:receiver(ERC223ReceivingContract), function:tokenFallback, arguments:['msg.sender', '_value', '_data']  ,REF_110(uint256) -> balances[msg.sender],REF_111(uint256) -> balances[msg.sender],TMP_136(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_111', '_value'] ,REF_110(uint256) (->balances) := TMP_136(uint256),REF_113(uint256) -> balances[_to],REF_114(uint256) -> balances[_to],TMP_137(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_114', '_value'] ,REF_113(uint256) (->balances) := TMP_137(uint256),Emit Transferdata(msg.sender,_to,_value,_data)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_131(bool) = _value > 0
TMP_132(None) = SOLIDITY_CALL require(bool)(TMP_131)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
isContract(_to)

IRs:
TMP_133(bool) = INTERNAL_CALL, CherryToken.isContract(address)(_to)
CONDITION TMP_133""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
receiver = ERC223ReceivingContract(_to)

IRs:
TMP_134 = CONVERT _to to ERC223ReceivingContract
receiver(ERC223ReceivingContract) := TMP_134(ERC223ReceivingContract)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
receiver.tokenFallback(msg.sender,_value,_data)

IRs:
HIGH_LEVEL_CALL, dest:receiver(ERC223ReceivingContract), function:tokenFallback, arguments:['msg.sender', '_value', '_data']  ""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_110(uint256) -> balances[msg.sender]
REF_111(uint256) -> balances[msg.sender]
TMP_136(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_111', '_value'] 
REF_110(uint256) (->balances) := TMP_136(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_113(uint256) -> balances[_to]
REF_114(uint256) -> balances[_to]
TMP_137(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_114', '_value'] 
REF_113(uint256) (->balances) := TMP_137(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transferdata(msg.sender,_to,_value,_data)

IRs:
Emit Transferdata(msg.sender,_to,_value,_data)""];
}
",1,1,0,0,"require(bool)(_value > 0);isContract(_to);receiver = ERC223ReceivingContract(_to);;receiver.tokenFallback(msg.sender,_value,_data);balances[msg.sender] = balances[msg.sender].sub(_value);balances[_to] = balances[_to].add(_value);Transferdata(msg.sender,_to,_value,_data)"
./0x0002325fcaaac6ebf1254a626589147bde1a2394_ext.sol,HorseyToken.feed,815,826,"REF_94(HorseyToken.FeedingData) -> pendingFeedings[msg.sender],TMP_254(HorseyToken.FeedingData) = new FeedingData(block.number,tokenId),REF_94(HorseyToken.FeedingData) (->pendingFeedings) := TMP_254(HorseyToken.FeedingData),TUPLE_8(address,bytes32,uint8,uint8) = HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:horseys, arguments:['tokenId']  ,feedingCounter(uint8)= UNPACK TUPLE_8 index: 2 ,TMP_255(uint32) = HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:carrot_credits, arguments:['msg.sender']  ,TMP_256 = CONVERT feedingCounter to uint32,TMP_257(uint32) = TMP_255 - TMP_256,HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:storeCarrotsCredit, arguments:['msg.sender', 'TMP_257']  ,Emit Feeding(tokenId),MODIFIER_CALL, Pausable.whenNotPaused()(),MODIFIER_CALL, HorseyToken.onlyOwnerOf(uint256)(tokenId),MODIFIER_CALL, HorseyToken.carrotsMeetLevel(uint256)(tokenId),MODIFIER_CALL, HorseyToken.noFeedingInProgress()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
pendingFeedings[msg.sender] = FeedingData(block.number,tokenId)

IRs:
REF_94(HorseyToken.FeedingData) -> pendingFeedings[msg.sender]
TMP_254(HorseyToken.FeedingData) = new FeedingData(block.number,tokenId)
REF_94(HorseyToken.FeedingData) (->pendingFeedings) := TMP_254(HorseyToken.FeedingData)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
(None,None,feedingCounter,None) = stables.horseys(tokenId)

IRs:
TUPLE_8(address,bytes32,uint8,uint8) = HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:horseys, arguments:['tokenId']  
feedingCounter(uint8)= UNPACK TUPLE_8 index: 2 ""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) - uint32(feedingCounter))

IRs:
TMP_255(uint32) = HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:carrot_credits, arguments:['msg.sender']  
TMP_256 = CONVERT feedingCounter to uint32
TMP_257(uint32) = TMP_255 - TMP_256
HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:storeCarrotsCredit, arguments:['msg.sender', 'TMP_257']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Feeding(tokenId)

IRs:
Emit Feeding(tokenId)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwnerOf(tokenId)

IRs:
MODIFIER_CALL, HorseyToken.onlyOwnerOf(uint256)(tokenId)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
carrotsMeetLevel(tokenId)

IRs:
MODIFIER_CALL, HorseyToken.carrotsMeetLevel(uint256)(tokenId)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
noFeedingInProgress()

IRs:
MODIFIER_CALL, HorseyToken.noFeedingInProgress()()""];
9->1;
}
",1,0,0,0,"whenNotPaused();pendingFeedings[msg.sender] = FeedingData(block.number,tokenId);;(None,None,feedingCounter,None) = stables.horseys(tokenId);stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) - uint32(feedingCounter));Feeding(tokenId);onlyOwnerOf(tokenId);carrotsMeetLevel(tokenId);noFeedingInProgress()"
./0x430e87a95a421437ccaa0af644ac57e22914b07a_ext.sol,PoolOwners.distributeTokens,366,384,"TMP_115 = UnaryType.BANG distributionActive ,TMP_116(None) = SOLIDITY_CALL require(bool,string)(TMP_115,Distribution is already active),distributionActive(bool) := True(bool),TMP_117 = CONVERT _token to ERC677,erc677(ERC677) := TMP_117(ERC677),TMP_118(uint256) = HIGH_LEVEL_CALL, dest:erc677(ERC677), function:balanceOf, arguments:['this']  ,REF_94(uint256) -> tokenBalance[_token],TMP_119(uint256) = TMP_118 - REF_94,currentBalance(uint256) := TMP_119(uint256),TMP_120(bool) = currentBalance > distributionMinimum,TMP_121(None) = SOLIDITY_CALL require(bool,string)(TMP_120,Amount in the contract isn't above the minimum distribution limit),TMP_122(uint256) := totalDistributions(uint256),totalDistributions(uint256) = totalDistributions + 1,REF_95(PoolOwners.Distribution) -> distributions[totalDistributions],d(PoolOwners.Distribution) := REF_95(PoolOwners.Distribution),REF_96(uint256) -> d.owners,TMP_123(uint256) = LIBRARY_CALL, dest:itmap, function:itmap.size(itmap.itmap), arguments:['ownerMap'] ,REF_96(uint256) (->d) := TMP_123(uint256),REF_98(uint256) -> d.amount,REF_98(uint256) (->d) := currentBalance(uint256),REF_99(address) -> d.token,REF_99(address) (->d) := _token(address),REF_100(uint256) -> d.claimed,REF_100(uint256) (->d) := 0(uint256),REF_101(uint256) -> totalReturned[_token],REF_101(-> totalReturned) = REF_101 + currentBalance,REF_102(uint256) -> d.owners,Emit TokenDistributionActive(_token,currentBalance,totalDistributions,REF_102),MODIFIER_CALL, PoolOwners.onlyWhitelisted()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(! distributionActive,Distribution is already active)

IRs:
TMP_115 = UnaryType.BANG distributionActive 
TMP_116(None) = SOLIDITY_CALL require(bool,string)(TMP_115,Distribution is already active)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
distributionActive = true

IRs:
distributionActive(bool) := True(bool)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
erc677 = ERC677(_token)

IRs:
TMP_117 = CONVERT _token to ERC677
erc677(ERC677) := TMP_117(ERC677)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
currentBalance = erc677.balanceOf(this) - tokenBalance[_token]

IRs:
TMP_118(uint256) = HIGH_LEVEL_CALL, dest:erc677(ERC677), function:balanceOf, arguments:['this']  
REF_94(uint256) -> tokenBalance[_token]
TMP_119(uint256) = TMP_118 - REF_94
currentBalance(uint256) := TMP_119(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool,string)(currentBalance > distributionMinimum,Amount in the contract isn't above the minimum distribution limit)

IRs:
TMP_120(bool) = currentBalance > distributionMinimum
TMP_121(None) = SOLIDITY_CALL require(bool,string)(TMP_120,Amount in the contract isn't above the minimum distribution limit)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
totalDistributions ++

IRs:
TMP_122(uint256) := totalDistributions(uint256)
totalDistributions(uint256) = totalDistributions + 1""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
d = distributions[totalDistributions]

IRs:
REF_95(PoolOwners.Distribution) -> distributions[totalDistributions]
d(PoolOwners.Distribution) := REF_95(PoolOwners.Distribution)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
d.owners = ownerMap.size()

IRs:
REF_96(uint256) -> d.owners
TMP_123(uint256) = LIBRARY_CALL, dest:itmap, function:itmap.size(itmap.itmap), arguments:['ownerMap'] 
REF_96(uint256) (->d) := TMP_123(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
d.amount = currentBalance

IRs:
REF_98(uint256) -> d.amount
REF_98(uint256) (->d) := currentBalance(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
d.token = _token

IRs:
REF_99(address) -> d.token
REF_99(address) (->d) := _token(address)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
d.claimed = 0

IRs:
REF_100(uint256) -> d.claimed
REF_100(uint256) (->d) := 0(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
totalReturned[_token] += currentBalance

IRs:
REF_101(uint256) -> totalReturned[_token]
REF_101(-> totalReturned) = REF_101 + currentBalance""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
TokenDistributionActive(_token,currentBalance,totalDistributions,d.owners)

IRs:
REF_102(uint256) -> d.owners
Emit TokenDistributionActive(_token,currentBalance,totalDistributions,REF_102)""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
onlyWhitelisted()

IRs:
MODIFIER_CALL, PoolOwners.onlyWhitelisted()()""];
14->1;
}
",1,0,0,0,"onlyWhitelisted();require(bool,string)(! distributionActive,Distribution is already active);distributionActive = true;erc677 = ERC677(_token);currentBalance = erc677.balanceOf(this) - tokenBalance[_token];require(bool,string)(currentBalance > distributionMinimum,Amount in the contract isn't above the minimum distribution limit);totalDistributions ++;d = distributions[totalDistributions];d.owners = ownerMap.size();d.amount = currentBalance;d.token = _token;d.claimed = 0;totalReturned[_token] += currentBalance;TokenDistributionActive(_token,currentBalance,totalDistributions,d.owners)"
./0x17cba58578eecaee898242a02edac75b8cc17231_ext.sol,AUMXToken.transfer,152,159,"TMP_26(bool) = INTERNAL_CALL, AUMXToken.isContract(address)(_to),CONDITION TMP_26,TMP_27(uint256) = INTERNAL_CALL, AUMXToken.balanceOf(address)(msg.sender),TMP_28(bool) = TMP_27 < _value,CONDITION TMP_28,TMP_29(None) = SOLIDITY_CALL revert()(),REF_9(uint256) -> balances[msg.sender],TMP_30(uint256) = INTERNAL_CALL, AUMXToken.balanceOf(address)(msg.sender),TMP_31(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(TMP_30,_value),REF_9(uint256) (->balances) := TMP_31(uint256),REF_10(uint256) -> balances[_to],TMP_32(uint256) = INTERNAL_CALL, AUMXToken.balanceOf(address)(_to),TMP_33(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(TMP_32,_value),REF_10(uint256) (->balances) := TMP_33(uint256),TMP_35(bytes32) = SOLIDITY_CALL keccak256()(_custom_fallback),TMP_36 = CONVERT TMP_35 to bytes4,TMP_37(bool) = LOW_LEVEL_CALL, dest:_to, function:call, arguments:['TMP_36', 'msg.sender', '_value', '_data'] value:0 ,TMP_38(None) = SOLIDITY_CALL assert(bool)(TMP_37),Emit Transfer(msg.sender,_to,_value,_data),RETURN True,TMP_40(bool) = INTERNAL_CALL, AUMXToken.transferToAddress(address,uint256,bytes)(_to,_value,_data),RETURN TMP_40,MODIFIER_CALL, AUMXToken.isUnlocked()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: IF 1

EXPRESSION:
isContract(_to)

IRs:
TMP_26(bool) = INTERNAL_CALL, AUMXToken.isContract(address)(_to)
CONDITION TMP_26""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
balanceOf(msg.sender) < _value

IRs:
TMP_27(uint256) = INTERNAL_CALL, AUMXToken.balanceOf(address)(msg.sender)
TMP_28(bool) = TMP_27 < _value
CONDITION TMP_28""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
revert()()

IRs:
TMP_29(None) = SOLIDITY_CALL revert()()""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[msg.sender] = safeSub(balanceOf(msg.sender),_value)

IRs:
REF_9(uint256) -> balances[msg.sender]
TMP_30(uint256) = INTERNAL_CALL, AUMXToken.balanceOf(address)(msg.sender)
TMP_31(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(TMP_30,_value)
REF_9(uint256) (->balances) := TMP_31(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[_to] = safeAdd(balanceOf(_to),_value)

IRs:
REF_10(uint256) -> balances[_to]
TMP_32(uint256) = INTERNAL_CALL, AUMXToken.balanceOf(address)(_to)
TMP_33(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(TMP_32,_value)
REF_10(uint256) (->balances) := TMP_33(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(_to.call.value(0)(bytes4(keccak256()(_custom_fallback)),msg.sender,_value,_data))

IRs:
TMP_35(bytes32) = SOLIDITY_CALL keccak256()(_custom_fallback)
TMP_36 = CONVERT TMP_35 to bytes4
TMP_37(bool) = LOW_LEVEL_CALL, dest:_to, function:call, arguments:['TMP_36', 'msg.sender', '_value', '_data'] value:0 
TMP_38(None) = SOLIDITY_CALL assert(bool)(TMP_37)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(msg.sender,_to,_value,_data)

IRs:
Emit Transfer(msg.sender,_to,_value,_data)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: RETURN 10

EXPRESSION:
transferToAddress(_to,_value,_data)

IRs:
TMP_40(bool) = INTERNAL_CALL, AUMXToken.transferToAddress(address,uint256,bytes)(_to,_value,_data)
RETURN TMP_40""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
isUnlocked()

IRs:
MODIFIER_CALL, AUMXToken.isUnlocked()()""];
12->1;
13[label=""Node Type: RETURN 13

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,0,0,0,"isUnlocked();isContract(_to);balanceOf(msg.sender) < _value;transferToAddress(_to,_value,_data);revert()();;balances[msg.sender] = safeSub(balanceOf(msg.sender),_value);balances[_to] = safeAdd(balanceOf(_to),_value);assert(bool)(_to.call.value(0)(bytes4(keccak256()(_custom_fallback)),msg.sender,_value,_data));Transfer(msg.sender,_to,_value,_data);true;success"
./0x400784d4d1fe603b2e7a96416fa9a1afadf47009_ext.sol,UncTokenSale.offChainTrans,685,726,"tokens(uint256) := tokensAllocated(uint256),TMP_285 = CONVERT this to address,TMP_286(uint256) = HIGH_LEVEL_CALL, dest:token(UncToken), function:balanceOf, arguments:['TMP_285']  ,TMP_287(bool) = TMP_286 >= tokens,TMP_288(None) = SOLIDITY_CALL require(bool)(TMP_287),REF_60(uint256) -> contributionAmtOf[participant],REF_61(uint256) -> contributionAmtOf[participant],TMP_289(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_61,contributionAmt),REF_60(uint256) (->contributionAmtOf) := TMP_289(uint256),REF_62(uint256) -> tokenBalanceOf[participant],REF_63(uint256) -> tokenBalanceOf[participant],TMP_290(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_63,tokens),REF_62(uint256) (->tokenBalanceOf) := TMP_290(uint256),CONDITION isFounder,startTime(uint256) := 1559347200(uint256),startTime(uint256) := 1540886400(uint256),REF_64(address) -> timeLocks[participant],TMP_291(bool) = REF_64 == 0,CONDITION TMP_291,TMP_293(TimeLock) = new TimeLock(token,participant,startTime) ,lock(TimeLock) := TMP_293(TimeLock),REF_65(address) -> timeLocks[participant],TMP_294 = CONVERT lock to address,REF_65(address) (->timeLocks) := TMP_294(address),REF_66(address) -> timeLocks[participant],TMP_295 = CONVERT REF_66 to TimeLock,lock(TimeLock) := TMP_295(TimeLock),TMP_296(bool) = HIGH_LEVEL_CALL, dest:token(UncToken), function:transfer, arguments:['lock', 'tokens']  ,HIGH_LEVEL_CALL, dest:lock(TimeLock), function:setInitialBalance, arguments:[]  ,Emit AddedOffChain(participant,tokensAllocated),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->19;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
tokens = tokensAllocated

IRs:
tokens(uint256) := tokensAllocated(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(token.balanceOf(address(this)) >= tokens)

IRs:
TMP_285 = CONVERT this to address
TMP_286(uint256) = HIGH_LEVEL_CALL, dest:token(UncToken), function:balanceOf, arguments:['TMP_285']  
TMP_287(bool) = TMP_286 >= tokens
TMP_288(None) = SOLIDITY_CALL require(bool)(TMP_287)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
contributionAmtOf[participant] = safeAdd(contributionAmtOf[participant],contributionAmt)

IRs:
REF_60(uint256) -> contributionAmtOf[participant]
REF_61(uint256) -> contributionAmtOf[participant]
TMP_289(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_61,contributionAmt)
REF_60(uint256) (->contributionAmtOf) := TMP_289(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
tokenBalanceOf[participant] = safeAdd(tokenBalanceOf[participant],tokens)

IRs:
REF_62(uint256) -> tokenBalanceOf[participant]
REF_63(uint256) -> tokenBalanceOf[participant]
TMP_290(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_63,tokens)
REF_62(uint256) (->tokenBalanceOf) := TMP_290(uint256)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
isFounder

IRs:
CONDITION isFounder""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
startTime = 1559347200

IRs:
startTime(uint256) := 1559347200(uint256)""];
7->9;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
startTime = 1540886400

IRs:
startTime(uint256) := 1540886400(uint256)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: NEW VARIABLE 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
timeLocks[participant] == 0x0

IRs:
REF_64(address) -> timeLocks[participant]
TMP_291(bool) = REF_64 == 0
CONDITION TMP_291""];
11->12[label=""True""];
11->14[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
lock = new TimeLock(token,participant,startTime)

IRs:
TMP_293(TimeLock) = new TimeLock(token,participant,startTime) 
lock(TimeLock) := TMP_293(TimeLock)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
timeLocks[participant] = address(lock)

IRs:
REF_65(address) -> timeLocks[participant]
TMP_294 = CONVERT lock to address
REF_65(address) (->timeLocks) := TMP_294(address)""];
13->15;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
lock = TimeLock(timeLocks[participant])

IRs:
REF_66(address) -> timeLocks[participant]
TMP_295 = CONVERT REF_66 to TimeLock
lock(TimeLock) := TMP_295(TimeLock)""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
token.transfer(lock,tokens)

IRs:
TMP_296(bool) = HIGH_LEVEL_CALL, dest:token(UncToken), function:transfer, arguments:['lock', 'tokens']  ""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
lock.setInitialBalance()

IRs:
HIGH_LEVEL_CALL, dest:lock(TimeLock), function:setInitialBalance, arguments:[]  ""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
AddedOffChain(participant,tokensAllocated)

IRs:
Emit AddedOffChain(participant,tokensAllocated)""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
19->1;
}
",1,0,0,0,"onlyOwner();;tokens = tokensAllocated;require(bool)(token.balanceOf(address(this)) >= tokens);contributionAmtOf[participant] = safeAdd(contributionAmtOf[participant],contributionAmt);tokenBalanceOf[participant] = safeAdd(tokenBalanceOf[participant],tokens);isFounder;startTime = 1559347200;startTime = 1540886400;;;timeLocks[participant] == 0x0;lock = new TimeLock(token,participant,startTime);lock = TimeLock(timeLocks[participant]);timeLocks[participant] = address(lock);;token.transfer(lock,tokens);lock.setInitialBalance();AddedOffChain(participant,tokensAllocated)"
./0x301487766dcf283592b11b5988e5c4e4630dfbe5_ext.sol,EDex.withdraw,212,217,"REF_51(mapping(address => uint256)) -> tokens[0],REF_52(uint256) -> REF_51[msg.sender],TMP_93(bool) = REF_52 < amount,CONDITION TMP_93,TMP_94(None) = SOLIDITY_CALL revert()(),REF_53(mapping(address => uint256)) -> tokens[0],REF_54(uint256) -> REF_53[msg.sender],REF_55(mapping(address => uint256)) -> tokens[0],REF_56(uint256) -> REF_55[msg.sender],TMP_95(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_56,amount),REF_54(uint256) (->tokens) := TMP_95(uint256),TMP_97(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:amount ,TMP_98 = UnaryType.BANG TMP_97 ,CONDITION TMP_98,TMP_99(None) = SOLIDITY_CALL revert()(),REF_59(mapping(address => uint256)) -> tokens[0],REF_60(uint256) -> REF_59[msg.sender],Emit Withdraw(0,msg.sender,amount,REF_60)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
tokens[0][msg.sender] < amount

IRs:
REF_51(mapping(address => uint256)) -> tokens[0]
REF_52(uint256) -> REF_51[msg.sender]
TMP_93(bool) = REF_52 < amount
CONDITION TMP_93""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_94(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender],amount)

IRs:
REF_53(mapping(address => uint256)) -> tokens[0]
REF_54(uint256) -> REF_53[msg.sender]
REF_55(mapping(address => uint256)) -> tokens[0]
REF_56(uint256) -> REF_55[msg.sender]
TMP_95(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_56,amount)
REF_54(uint256) (->tokens) := TMP_95(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
! msg.sender.call.value(amount)()

IRs:
TMP_97(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:amount 
TMP_98 = UnaryType.BANG TMP_97 
CONDITION TMP_98""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
revert()()

IRs:
TMP_99(None) = SOLIDITY_CALL revert()()""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Withdraw(0,msg.sender,amount,tokens[0][msg.sender])

IRs:
REF_59(mapping(address => uint256)) -> tokens[0]
REF_60(uint256) -> REF_59[msg.sender]
Emit Withdraw(0,msg.sender,amount,REF_60)""];
}
",1,0,0,0,"tokens[0][msg.sender] < amount;revert()();;tokens[0][msg.sender] = safeSub(tokens[0][msg.sender],amount);! msg.sender.call.value(amount)();revert()();;Withdraw(0,msg.sender,amount,tokens[0][msg.sender])"
./0x02dd48ff449f57a4632c39068e0ca0f4325c3a8d_ext.sol,CB_BANK.Collect,15,28,"REF_5(CB_BANK.Holder) -> Acc[msg.sender],acc(CB_BANK.Holder) := REF_5(CB_BANK.Holder),REF_6(uint256) -> acc.balance,TMP_2(bool) = REF_6 >= MinSum,REF_7(uint256) -> acc.balance,TMP_3(bool) = REF_7 >= _am,TMP_4(bool) = TMP_2 && TMP_3,REF_8(uint256) -> acc.unlockTime,TMP_5(bool) = now > REF_8,TMP_6(bool) = TMP_4 && TMP_5,CONDITION TMP_6,TMP_8(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:_am ,CONDITION TMP_8,REF_11(uint256) -> acc.balance,REF_11(-> acc) = REF_11 - _am,HIGH_LEVEL_CALL, dest:LogFile(Log), function:AddMessage, arguments:['msg.sender', '_am', 'Collect']  ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
acc = Acc[msg.sender]

IRs:
REF_5(CB_BANK.Holder) -> Acc[msg.sender]
acc(CB_BANK.Holder) := REF_5(CB_BANK.Holder)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
acc.balance >= MinSum && acc.balance >= _am && now > acc.unlockTime

IRs:
REF_6(uint256) -> acc.balance
TMP_2(bool) = REF_6 >= MinSum
REF_7(uint256) -> acc.balance
TMP_3(bool) = REF_7 >= _am
TMP_4(bool) = TMP_2 && TMP_3
REF_8(uint256) -> acc.unlockTime
TMP_5(bool) = now > REF_8
TMP_6(bool) = TMP_4 && TMP_5
CONDITION TMP_6""];
2->3[label=""True""];
2->7[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
msg.sender.call.value(_am)()

IRs:
TMP_8(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:_am 
CONDITION TMP_8""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
acc.balance -= _am

IRs:
REF_11(uint256) -> acc.balance
REF_11(-> acc) = REF_11 - _am""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
LogFile.AddMessage(msg.sender,_am,Collect)

IRs:
HIGH_LEVEL_CALL, dest:LogFile(Log), function:AddMessage, arguments:['msg.sender', '_am', 'Collect']  ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: END_IF 7
""];
}
",1,0,0,0,"acc = Acc[msg.sender];acc.balance >= MinSum && acc.balance >= _am && now > acc.unlockTime;msg.sender.call.value(_am)();;acc.balance -= _am;;LogFile.AddMessage(msg.sender,_am,Collect)"
./0x4b96bf1fef93a216914fc843d81207a027ce52b3_ext.sol,VUULRVesting.revokeSchedule,654,666,"TMP_375(bool) = _addressToRefund != 0,TMP_376(None) = SOLIDITY_CALL require(bool)(TMP_375),TMP_377(uint256) = INTERNAL_CALL, VUULRVesting.withdrawable(address)(_addressToRevoke),_withdrawable(uint256) := TMP_377(uint256),REF_188(VUULRVesting.VestingSchedule) -> vestingSchedules[_addressToRevoke],REF_189(uint256) -> REF_188.tokens,TMP_378(uint256) = INTERNAL_CALL, VUULRVesting.vested(address)(_addressToRevoke),TMP_379(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_189', 'TMP_378'] ,_refundable(uint256) := TMP_379(uint256),REF_191(VUULRVesting.VestingSchedule) -> vestingSchedules[_addressToRevoke],vestingSchedules = delete REF_191 ,TMP_380(bool) = _withdrawable > 0,CONDITION TMP_380,TMP_381(bool) = HIGH_LEVEL_CALL, dest:vestingToken(VUULRToken), function:transfer, arguments:['_addressToRevoke', '_withdrawable']  ,TMP_382(None) = SOLIDITY_CALL require(bool)(TMP_381),TMP_383(bool) = _refundable > 0,CONDITION TMP_383,TMP_384(bool) = HIGH_LEVEL_CALL, dest:vestingToken(VUULRToken), function:transfer, arguments:['_addressToRefund', '_refundable']  ,TMP_385(None) = SOLIDITY_CALL require(bool)(TMP_384),Emit VestingRevoked(_addressToRevoke,_withdrawable,_refundable),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_addressToRefund != 0x0)

IRs:
TMP_375(bool) = _addressToRefund != 0
TMP_376(None) = SOLIDITY_CALL require(bool)(TMP_375)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
_withdrawable = withdrawable(_addressToRevoke)

IRs:
TMP_377(uint256) = INTERNAL_CALL, VUULRVesting.withdrawable(address)(_addressToRevoke)
_withdrawable(uint256) := TMP_377(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
_refundable = vestingSchedules[_addressToRevoke].tokens.sub(vested(_addressToRevoke))

IRs:
REF_188(VUULRVesting.VestingSchedule) -> vestingSchedules[_addressToRevoke]
REF_189(uint256) -> REF_188.tokens
TMP_378(uint256) = INTERNAL_CALL, VUULRVesting.vested(address)(_addressToRevoke)
TMP_379(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_189', 'TMP_378'] 
_refundable(uint256) := TMP_379(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
delete vestingSchedules[_addressToRevoke]

IRs:
REF_191(VUULRVesting.VestingSchedule) -> vestingSchedules[_addressToRevoke]
vestingSchedules = delete REF_191 ""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
_withdrawable > 0

IRs:
TMP_380(bool) = _withdrawable > 0
CONDITION TMP_380""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(vestingToken.transfer(_addressToRevoke,_withdrawable))

IRs:
TMP_381(bool) = HIGH_LEVEL_CALL, dest:vestingToken(VUULRToken), function:transfer, arguments:['_addressToRevoke', '_withdrawable']  
TMP_382(None) = SOLIDITY_CALL require(bool)(TMP_381)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
_refundable > 0

IRs:
TMP_383(bool) = _refundable > 0
CONDITION TMP_383""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(vestingToken.transfer(_addressToRefund,_refundable))

IRs:
TMP_384(bool) = HIGH_LEVEL_CALL, dest:vestingToken(VUULRToken), function:transfer, arguments:['_addressToRefund', '_refundable']  
TMP_385(None) = SOLIDITY_CALL require(bool)(TMP_384)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
VestingRevoked(_addressToRevoke,_withdrawable,_refundable)

IRs:
Emit VestingRevoked(_addressToRevoke,_withdrawable,_refundable)""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
12->1;
}
",1,0,0,0,"onlyOwner();require(bool)(_addressToRefund != 0x0);_withdrawable = withdrawable(_addressToRevoke);_refundable = vestingSchedules[_addressToRevoke].tokens.sub(vested(_addressToRevoke));delete vestingSchedules[_addressToRevoke];_withdrawable > 0;require(bool)(vestingToken.transfer(_addressToRevoke,_withdrawable));;_refundable > 0;require(bool)(vestingToken.transfer(_addressToRefund,_refundable));;VestingRevoked(_addressToRevoke,_withdrawable,_refundable)"
./0x8ad0a831b7a17b322e8aebd188a4a8eb3bfdb5e8_ext.sol,CPVToken.refundTokens,355,361,"TMP_111(bool) = msg.sender == owner,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113 = CONVERT this to address,TMP_114(bool) = _token != TMP_113,TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114),TMP_116 = CONVERT _token to AbstractToken,token(AbstractToken) := TMP_116(AbstractToken),TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ,Emit RefundTokens(_token,_refund,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_111(bool) = msg.sender == owner
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_113 = CONVERT this to address
TMP_114(bool) = _token != TMP_113
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
token = AbstractToken(_token)

IRs:
TMP_116 = CONVERT _token to AbstractToken
token(AbstractToken) := TMP_116(AbstractToken)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(_refund,_value)

IRs:
TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RefundTokens(_token,_refund,_value)

IRs:
Emit RefundTokens(_token,_refund,_value)""];
}
",1,0,0,0,"require(bool)(msg.sender == owner);require(bool)(_token != address(this));token = AbstractToken(_token);token.transfer(_refund,_value);RefundTokens(_token,_refund,_value)"
./0x266fe968ce45fa3373726329ce6104b9ca4a9c66_ext.sol,CreditGAME.removeGameManually,326,336,"REF_91(CreditGAME.GameLock) -> gameLocks[_gameAddress],gameLock(CreditGAME.GameLock) := REF_91(CreditGAME.GameLock),TMP_116 = CONVERT tokenAddress to IERC20Token,REF_93(uint256) -> gameLock.amount,TMP_117(bool) = HIGH_LEVEL_CALL, dest:TMP_116(IERC20Token), function:transfer, arguments:['_tokenHolder', 'REF_93']  ,REF_94(uint256) -> gameLock.amount,TMP_118(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(amountLocked,REF_94),amountLocked(uint256) := TMP_118(uint256),REF_95(CreditGAME.GameLock) -> gameLocks[_gameAddress],gameLocks = delete REF_95 ,REF_96(bool) -> isGameLocked[_gameAddress],REF_96(bool) (->isGameLocked) := False(bool),TMP_119(bool) = INTERNAL_CALL, LinkedList.removeItem(address)(_gameAddress),REF_97(bool) -> approvedGames[_gameAddress],REF_97(bool) (->approvedGames) := False(bool),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
gameLock = gameLocks[_gameAddress]

IRs:
REF_91(CreditGAME.GameLock) -> gameLocks[_gameAddress]
gameLock(CreditGAME.GameLock) := REF_91(CreditGAME.GameLock)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
IERC20Token(tokenAddress).transfer(_tokenHolder,gameLock.amount)

IRs:
TMP_116 = CONVERT tokenAddress to IERC20Token
REF_93(uint256) -> gameLock.amount
TMP_117(bool) = HIGH_LEVEL_CALL, dest:TMP_116(IERC20Token), function:transfer, arguments:['_tokenHolder', 'REF_93']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
amountLocked = safeSub(amountLocked,gameLock.amount)

IRs:
REF_94(uint256) -> gameLock.amount
TMP_118(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(amountLocked,REF_94)
amountLocked(uint256) := TMP_118(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
delete (gameLocks[_gameAddress])

IRs:
REF_95(CreditGAME.GameLock) -> gameLocks[_gameAddress]
gameLocks = delete REF_95 ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
isGameLocked[_gameAddress] = false

IRs:
REF_96(bool) -> isGameLocked[_gameAddress]
REF_96(bool) (->isGameLocked) := False(bool)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
removeItem(_gameAddress)

IRs:
TMP_119(bool) = INTERNAL_CALL, LinkedList.removeItem(address)(_gameAddress)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
approvedGames[_gameAddress] = false

IRs:
REF_97(bool) -> approvedGames[_gameAddress]
REF_97(bool) (->approvedGames) := False(bool)""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
8->1;
}
",1,0,0,0,"onlyOwner();gameLock = gameLocks[_gameAddress];IERC20Token(tokenAddress).transfer(_tokenHolder,gameLock.amount);amountLocked = safeSub(amountLocked,gameLock.amount);delete (gameLocks[_gameAddress]);isGameLocked[_gameAddress] = false;removeItem(_gameAddress);approvedGames[_gameAddress] = false"
./0x470142a1834438515b757118f322703aba6e1e05_ext.sol,PolicyPalNetworkAirdrop.twitterDropSingleAmount,169,189,"i(uint256) := 0(uint256),REF_15 -> LENGTH _recipients,TMP_22(bool) = i < REF_15,CONDITION TMP_22,REF_16(address) -> _recipients[i],recipient(address) := REF_16(address),REF_17(bool) -> twitterdrops[recipient],TMP_23 = UnaryType.BANG REF_17 ,CONDITION TMP_23,TMP_24(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', '_amount']  ,TMP_25(None) = SOLIDITY_CALL assert(bool)(TMP_24),REF_19(bool) -> twitterdrops[recipient],REF_19(bool) (->twitterdrops) := True(bool),TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] ,numDrops(uint256) := TMP_26(uint256),TMP_27(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', '_amount'] ,dropAmount(uint256) := TMP_27(uint256),Emit TokenDrop(recipient,_amount,TWITTER),TMP_29(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()(),MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalance(address[],uint256)(_recipients,_amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _recipients.length

IRs:
REF_15 -> LENGTH _recipients
TMP_22(bool) = i < REF_15
CONDITION TMP_22""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
recipient = _recipients[i]

IRs:
REF_16(address) -> _recipients[i]
recipient(address) := REF_16(address)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
! twitterdrops[recipient]

IRs:
REF_17(bool) -> twitterdrops[recipient]
TMP_23 = UnaryType.BANG REF_17 
CONDITION TMP_23""];
6->7[label=""True""];
6->12[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(token.transfer(recipient,_amount))

IRs:
TMP_24(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', '_amount']  
TMP_25(None) = SOLIDITY_CALL assert(bool)(TMP_24)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
twitterdrops[recipient] = true

IRs:
REF_19(bool) -> twitterdrops[recipient]
REF_19(bool) (->twitterdrops) := True(bool)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
numDrops = numDrops.add(1)

IRs:
TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] 
numDrops(uint256) := TMP_26(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
dropAmount = dropAmount.add(_amount)

IRs:
TMP_27(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', '_amount'] 
dropAmount(uint256) := TMP_27(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
TokenDrop(recipient,_amount,TWITTER)

IRs:
Emit TokenDrop(recipient,_amount,TWITTER)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
i ++

IRs:
TMP_29(uint256) := i(uint256)
i(uint256) = i + 1""];
13->4;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()()""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
validBalance(_recipients,_amount)

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalance(address[],uint256)(_recipients,_amount)""];
15->3;
}
",1,0,0,0,"onlyAdmin();;i < _recipients.length;;i = 0;recipient = _recipients[i];! twitterdrops[recipient];assert(bool)(token.transfer(recipient,_amount));;twitterdrops[recipient] = true;numDrops = numDrops.add(1);dropAmount = dropAmount.add(_amount);TokenDrop(recipient,_amount,TWITTER);i ++;validBalance(_recipients,_amount)"
./0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497_ext.sol,LockinManager.setDefaultAllowedLock,645,647,"defaultAllowedLock(uint256) := _days(uint256),MODIFIER_CALL, LockinManager.adminOnly()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
defaultAllowedLock = _days

IRs:
defaultAllowedLock(uint256) := _days(uint256)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
adminOnly()

IRs:
MODIFIER_CALL, LockinManager.adminOnly()()""];
2->1;
}
",1,0,0,0,adminOnly();defaultAllowedLock = _days
./0x91ca47b9ec3187c77f324281a1851f4b991103f1_ext.sol,FundingInputGeneral.buy,38,54,"TMP_5(bool) = msg.value > 0,CONDITION TMP_5,TMP_6(bool) = INTERNAL_CALL, FundingInputGeneral.isContract(address)(FundingAssetAddress),CONDITION TMP_6,TMP_8(bytes32) = SOLIDITY_CALL keccak256()(receivePayment(address,uint8)),TMP_9 = CONVERT TMP_8 to bytes32,TMP_10 = CONVERT TMP_9 to bytes4,TMP_11(bool) = LOW_LEVEL_CALL, dest:FundingAssetAddress, function:call, arguments:['TMP_10', 'msg.sender', 'typeId'] value:msg.value ,CONDITION TMP_11,Emit EventInputPaymentReceived(msg.sender,msg.value,typeId),RETURN True,TMP_13(None) = SOLIDITY_CALL revert()(),TMP_14(None) = SOLIDITY_CALL revert()(),TMP_15(None) = SOLIDITY_CALL revert()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value > 0

IRs:
TMP_5(bool) = msg.value > 0
CONDITION TMP_5""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
isContract(FundingAssetAddress)

IRs:
TMP_6(bool) = INTERNAL_CALL, FundingInputGeneral.isContract(address)(FundingAssetAddress)
CONDITION TMP_6""];
2->3[label=""True""];
2->8[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
FundingAssetAddress.call.value(msg.value)(bytes4(bytes32(keccak256()(receivePayment(address,uint8)))),msg.sender,typeId)

IRs:
TMP_8(bytes32) = SOLIDITY_CALL keccak256()(receivePayment(address,uint8))
TMP_9 = CONVERT TMP_8 to bytes32
TMP_10 = CONVERT TMP_9 to bytes4
TMP_11(bool) = LOW_LEVEL_CALL, dest:FundingAssetAddress, function:call, arguments:['TMP_10', 'msg.sender', 'typeId'] value:msg.value 
CONDITION TMP_11""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
EventInputPaymentReceived(msg.sender,msg.value,typeId)

IRs:
Emit EventInputPaymentReceived(msg.sender,msg.value,typeId)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
revert()()

IRs:
TMP_13(None) = SOLIDITY_CALL revert()()""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->9;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
revert()()

IRs:
TMP_14(None) = SOLIDITY_CALL revert()()""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->11;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
revert()()

IRs:
TMP_15(None) = SOLIDITY_CALL revert()()""];
10->11;
11[label=""Node Type: END_IF 11
""];
}
",1,0,0,0,"msg.value > 0;isContract(FundingAssetAddress);revert()();FundingAssetAddress.call.value(msg.value)(bytes4(bytes32(keccak256()(receivePayment(address,uint8)))),msg.sender,typeId);revert()();EventInputPaymentReceived(msg.sender,msg.value,typeId);revert()();true;;;"
./0x300a0a820d8fb6e77850da5eaa8df64bbff5746d_ext.sol,BoomrCoinCrowdsale.finalize,868,880,"TMP_380 = UnaryType.BANG finalized ,TMP_381(None) = SOLIDITY_CALL require(bool)(TMP_380),TMP_382(bool) = INTERNAL_CALL, BoomrCoinCrowdsale.isCompleted()(),TMP_383(None) = SOLIDITY_CALL require(bool)(TMP_382),TMP_384(bool) = INTERNAL_CALL, BoomrCoinCrowdsale.minGoalReached()(),CONDITION TMP_384,HIGH_LEVEL_CALL, dest:vault(RefundVault), function:close, arguments:[]  ,HIGH_LEVEL_CALL, dest:vault(RefundVault), function:enableRefunds, arguments:[]  ,finalized(bool) := True(bool),Emit Finalized(),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! finalized)

IRs:
TMP_380 = UnaryType.BANG finalized 
TMP_381(None) = SOLIDITY_CALL require(bool)(TMP_380)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(isCompleted())

IRs:
TMP_382(bool) = INTERNAL_CALL, BoomrCoinCrowdsale.isCompleted()()
TMP_383(None) = SOLIDITY_CALL require(bool)(TMP_382)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
minGoalReached()

IRs:
TMP_384(bool) = INTERNAL_CALL, BoomrCoinCrowdsale.minGoalReached()()
CONDITION TMP_384""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
vault.close()

IRs:
HIGH_LEVEL_CALL, dest:vault(RefundVault), function:close, arguments:[]  ""];
4->6;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
vault.enableRefunds()

IRs:
HIGH_LEVEL_CALL, dest:vault(RefundVault), function:enableRefunds, arguments:[]  ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
finalized = true

IRs:
finalized(bool) := True(bool)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Finalized()

IRs:
Emit Finalized()""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
9->1;
}
",1,0,0,0,onlyOwner();require(bool)(! finalized);require(bool)(isCompleted());minGoalReached();vault.close();vault.enableRefunds();;finalized = true;Finalized()
./0x1b6c5864375b34af3ff5bd2e5f40bc425b4a8d79_ext.sol,TopChainCoinDistribution.createTokenToMarket,698,705,"TMP_282 = CONVERT 0 to address,TMP_283(bool) = marketAddress != TMP_282,TMP_284(None) = SOLIDITY_CALL require(bool)(TMP_283),TMP_285(bool) = marketTokenCreated == False,TMP_286(None) = SOLIDITY_CALL require(bool)(TMP_285),marketTokenCreated(bool) := True(bool),TMP_287(bool) = HIGH_LEVEL_CALL, dest:token(TopChainCoin), function:mint, arguments:['marketAddress', 'marketToken']  ,Emit CreateTokenToMarket(marketAddress,marketToken),MODIFIER_CALL, Authorizable.onlyAuthorized()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(marketAddress != address(0))

IRs:
TMP_282 = CONVERT 0 to address
TMP_283(bool) = marketAddress != TMP_282
TMP_284(None) = SOLIDITY_CALL require(bool)(TMP_283)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(marketTokenCreated == false)

IRs:
TMP_285(bool) = marketTokenCreated == False
TMP_286(None) = SOLIDITY_CALL require(bool)(TMP_285)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
marketTokenCreated = true

IRs:
marketTokenCreated(bool) := True(bool)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.mint(marketAddress,marketToken)

IRs:
TMP_287(bool) = HIGH_LEVEL_CALL, dest:token(TopChainCoin), function:mint, arguments:['marketAddress', 'marketToken']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
CreateTokenToMarket(marketAddress,marketToken)

IRs:
Emit CreateTokenToMarket(marketAddress,marketToken)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyAuthorized()

IRs:
MODIFIER_CALL, Authorizable.onlyAuthorized()()""];
6->1;
}
",1,0,0,0,"onlyAuthorized();require(bool)(marketAddress != address(0));require(bool)(marketTokenCreated == false);marketTokenCreated = true;token.mint(marketAddress,marketToken);CreateTokenToMarket(marketAddress,marketToken)"
./0xc849a5fff9befa297d1c3a772bafac9f3c9004ec_ext.sol,Bounty0xEscrow.depositToken,190,196,"TMP_61 = CONVERT 0 to address,TMP_62(bool) = _token != TMP_61,TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62),TMP_64 = CONVERT _token to ERC20,HIGH_LEVEL_CALL, dest:TMP_64(ERC20), function:transferFrom, arguments:['msg.sender', 'this', '_amount']  ,REF_8(mapping(address => uint256)) -> tokens[_token],REF_9(uint256) -> REF_8[msg.sender],REF_11(mapping(address => uint256)) -> tokens[_token],REF_12(uint256) -> REF_11[msg.sender],TMP_66(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_12', '_amount'] ,REF_9(uint256) (->tokens) := TMP_66(uint256),REF_13(mapping(address => uint256)) -> tokens[_token],REF_14(uint256) -> REF_13[msg.sender],Emit Deposit(_token,msg.sender,_amount,REF_14),MODIFIER_CALL, Pausable.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_token != address(0))

IRs:
TMP_61 = CONVERT 0 to address
TMP_62(bool) = _token != TMP_61
TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ERC20(_token).transferFrom(msg.sender,this,_amount)

IRs:
TMP_64 = CONVERT _token to ERC20
HIGH_LEVEL_CALL, dest:TMP_64(ERC20), function:transferFrom, arguments:['msg.sender', 'this', '_amount']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tokens[_token][msg.sender] = SafeMath.add(tokens[_token][msg.sender],_amount)

IRs:
REF_8(mapping(address => uint256)) -> tokens[_token]
REF_9(uint256) -> REF_8[msg.sender]
REF_11(mapping(address => uint256)) -> tokens[_token]
REF_12(uint256) -> REF_11[msg.sender]
TMP_66(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_12', '_amount'] 
REF_9(uint256) (->tokens) := TMP_66(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Deposit(_token,msg.sender,_amount,tokens[_token][msg.sender])

IRs:
REF_13(mapping(address => uint256)) -> tokens[_token]
REF_14(uint256) -> REF_13[msg.sender]
Emit Deposit(_token,msg.sender,_amount,REF_14)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
5->1;
}
",1,0,0,0,"whenNotPaused();require(bool)(_token != address(0));ERC20(_token).transferFrom(msg.sender,this,_amount);tokens[_token][msg.sender] = SafeMath.add(tokens[_token][msg.sender],_amount);Deposit(_token,msg.sender,_amount,tokens[_token][msg.sender])"
./0x00c315ac9ff89bb6afa7524cd159f0a9766e8c89_ext.sol,IMDEXDexchange.IMDEXdepositToken,109,114,"REF_3(mapping(address => uint256)) -> tokens[token],REF_4(uint256) -> REF_3[msg.sender],REF_5(mapping(address => uint256)) -> tokens[token],REF_6(uint256) -> REF_5[msg.sender],TMP_34(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_6,amount),REF_4(uint256) (->tokens) := TMP_34(uint256),REF_7(uint256) -> lastActiveTransaction[msg.sender],REF_7(uint256) (->lastActiveTransaction) := block.number(uint256),TMP_35 = CONVERT token to IMDEX,TMP_36(bool) = HIGH_LEVEL_CALL, dest:TMP_35(IMDEX), function:transferFrom, arguments:['msg.sender', 'this', 'amount']  ,TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36),REF_9(mapping(address => uint256)) -> tokens[token],REF_10(uint256) -> REF_9[msg.sender],Emit Deposit(token,msg.sender,amount,REF_10)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender],amount)

IRs:
REF_3(mapping(address => uint256)) -> tokens[token]
REF_4(uint256) -> REF_3[msg.sender]
REF_5(mapping(address => uint256)) -> tokens[token]
REF_6(uint256) -> REF_5[msg.sender]
TMP_34(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_6,amount)
REF_4(uint256) (->tokens) := TMP_34(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
lastActiveTransaction[msg.sender] = block.number

IRs:
REF_7(uint256) -> lastActiveTransaction[msg.sender]
REF_7(uint256) (->lastActiveTransaction) := block.number(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(IMDEX(token).transferFrom(msg.sender,this,amount))

IRs:
TMP_35 = CONVERT token to IMDEX
TMP_36(bool) = HIGH_LEVEL_CALL, dest:TMP_35(IMDEX), function:transferFrom, arguments:['msg.sender', 'this', 'amount']  
TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Deposit(token,msg.sender,amount,tokens[token][msg.sender])

IRs:
REF_9(mapping(address => uint256)) -> tokens[token]
REF_10(uint256) -> REF_9[msg.sender]
Emit Deposit(token,msg.sender,amount,REF_10)""];
}
",1,0,0,0,"tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender],amount);lastActiveTransaction[msg.sender] = block.number;require(bool)(IMDEX(token).transferFrom(msg.sender,this,amount));Deposit(token,msg.sender,amount,tokens[token][msg.sender])"
./0x8615ddfe9d4c9e58abff01c999731f3e9e556e80_ext.sol,FrozenToken.receiveApproval,588,597,"TMP_386 = CONVERT _token to IERC20,token(IERC20) := TMP_386(IERC20),TMP_387 = CONVERT this to address,TMP_388(bool) = HIGH_LEVEL_CALL, dest:token(IERC20), function:transferFrom, arguments:['_spender', 'TMP_387', '_value']  ,TMP_389(None) = SOLIDITY_CALL require(bool)(TMP_388),Emit ReceiveTokens(_spender,_token,_value,_extraData),MODIFIER_CALL, Utils.validAddress(address)(_spender),MODIFIER_CALL, Utils.validAddress(address)(_token),MODIFIER_CALL, Utils.greaterThanZero(uint256)(_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
token = IERC20(_token)

IRs:
TMP_386 = CONVERT _token to IERC20
token(IERC20) := TMP_386(IERC20)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(token.transferFrom(_spender,address(this),_value))

IRs:
TMP_387 = CONVERT this to address
TMP_388(bool) = HIGH_LEVEL_CALL, dest:token(IERC20), function:transferFrom, arguments:['_spender', 'TMP_387', '_value']  
TMP_389(None) = SOLIDITY_CALL require(bool)(TMP_388)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ReceiveTokens(_spender,_token,_value,_extraData)

IRs:
Emit ReceiveTokens(_spender,_token,_value,_extraData)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
validAddress(_spender)

IRs:
MODIFIER_CALL, Utils.validAddress(address)(_spender)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
validAddress(_token)

IRs:
MODIFIER_CALL, Utils.validAddress(address)(_token)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
greaterThanZero(_value)

IRs:
MODIFIER_CALL, Utils.greaterThanZero(uint256)(_value)""];
6->1;
}
",1,0,0,0,"validAddress(_spender);token = IERC20(_token);require(bool)(token.transferFrom(_spender,address(this),_value));ReceiveTokens(_spender,_token,_value,_extraData);validAddress(_token);greaterThanZero(_value)"
./0x449f5c827cf7726cc5f181090aa147ca5fb88a40_ext.sol,EthergotchiOwnershipV2.migrate,1294,1348,"TMP_157(bool) = 1521849600 <= now,TMP_158(bool) = now <= 1522022399,TMP_159(bool) = TMP_157 && TMP_158,TMP_160(None) = SOLIDITY_CALL require(bool)(TMP_159),TMP_161(uint256) = HIGH_LEVEL_CALL, dest:formerContract(PartialOwnership), function:totalSupply, arguments:[]  ,formerTokenCount(uint256) := TMP_161(uint256),TMP_162(uint256) = migrationIndex + _count,endIndex(uint256) := TMP_162(uint256),TMP_163(bool) = endIndex >= formerTokenCount,CONDITION TMP_163,endIndex(uint256) := formerTokenCount(uint256),i(uint256) := migrationIndex(uint256),TMP_164(bool) = i < endIndex,CONDITION TMP_164,TMP_165(bool) = INTERNAL_CALL, EthergotchiOwnershipV2._isExcluded(uint256)(i),CONDITION TMP_165,TMP_166 = CONVERT 0 to address,tokenOwner(address) := TMP_166(address),TMP_167(address) = HIGH_LEVEL_CALL, dest:formerContract(PartialOwnership), function:ownerOf, arguments:['i']  ,tokenOwner(address) := TMP_167(address),INTERNAL_CALL, EthergotchiOwnershipV2._add(uint256,address)(i,tokenOwner),TMP_169 = CONVERT formerContract to address,Emit Transfer(TMP_169,tokenOwner,i),TMP_171(uint256) := i(uint256),i(uint256) = i + 1,migrationIndex(uint256) := endIndex(uint256),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->20;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(1521849600 <= now && now <= 1522022399)

IRs:
TMP_157(bool) = 1521849600 <= now
TMP_158(bool) = now <= 1522022399
TMP_159(bool) = TMP_157 && TMP_158
TMP_160(None) = SOLIDITY_CALL require(bool)(TMP_159)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
formerTokenCount = formerContract.totalSupply()

IRs:
TMP_161(uint256) = HIGH_LEVEL_CALL, dest:formerContract(PartialOwnership), function:totalSupply, arguments:[]  
formerTokenCount(uint256) := TMP_161(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
endIndex = migrationIndex + _count

IRs:
TMP_162(uint256) = migrationIndex + _count
endIndex(uint256) := TMP_162(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
endIndex >= formerTokenCount

IRs:
TMP_163(bool) = endIndex >= formerTokenCount
CONDITION TMP_163""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
endIndex = formerTokenCount

IRs:
endIndex(uint256) := formerTokenCount(uint256)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->9;
7[label=""Node Type: BEGIN_LOOP 7
""];
7->10;
8[label=""Node Type: END_LOOP 8
""];
8->19;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
i = migrationIndex

IRs:
i(uint256) := migrationIndex(uint256)""];
9->7;
10[label=""Node Type: IF_LOOP 10

EXPRESSION:
i < endIndex

IRs:
TMP_164(bool) = i < endIndex
CONDITION TMP_164""];
10->11[label=""True""];
10->8[label=""False""];
11[label=""Node Type: NEW VARIABLE 11
""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
_isExcluded(i)

IRs:
TMP_165(bool) = INTERNAL_CALL, EthergotchiOwnershipV2._isExcluded(uint256)(i)
CONDITION TMP_165""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
tokenOwner = address(0)

IRs:
TMP_166 = CONVERT 0 to address
tokenOwner(address) := TMP_166(address)""];
13->15;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
tokenOwner = formerContract.ownerOf(i)

IRs:
TMP_167(address) = HIGH_LEVEL_CALL, dest:formerContract(PartialOwnership), function:ownerOf, arguments:['i']  
tokenOwner(address) := TMP_167(address)""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
_add(i,tokenOwner)

IRs:
INTERNAL_CALL, EthergotchiOwnershipV2._add(uint256,address)(i,tokenOwner)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
Transfer(address(formerContract),tokenOwner,i)

IRs:
TMP_169 = CONVERT formerContract to address
Emit Transfer(TMP_169,tokenOwner,i)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
i ++

IRs:
TMP_171(uint256) := i(uint256)
i(uint256) = i + 1""];
18->10;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
migrationIndex = endIndex

IRs:
migrationIndex(uint256) := endIndex(uint256)""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
20->1;
}
",1,0,0,0,"onlyOwner();require(bool)(1521849600 <= now && now <= 1522022399);formerTokenCount = formerContract.totalSupply();endIndex = migrationIndex + _count;endIndex >= formerTokenCount;endIndex = formerTokenCount;;i = migrationIndex;;i < endIndex;;migrationIndex = endIndex;;_isExcluded(i);tokenOwner = address(0);tokenOwner = formerContract.ownerOf(i);;_add(i,tokenOwner);Transfer(address(formerContract),tokenOwner,i);i ++"
./0x6c764fac2ed1c5fabf8bcd86bae68d8cdbe8290e_ext.sol,BaseWallet.invoke,632,636,"TMP_162(bool) = LOW_LEVEL_CALL, dest:_target, function:call, arguments:['_data'] value:_value ,TMP_163(None) = SOLIDITY_CALL require(bool,string)(TMP_162,BW: call to target failed),Emit Invoked(msg.sender,_target,_value,_data),MODIFIER_CALL, BaseWallet.moduleOnly()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(_target.call.value(_value)(_data),BW: call to target failed)

IRs:
TMP_162(bool) = LOW_LEVEL_CALL, dest:_target, function:call, arguments:['_data'] value:_value 
TMP_163(None) = SOLIDITY_CALL require(bool,string)(TMP_162,BW: call to target failed)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Invoked(msg.sender,_target,_value,_data)

IRs:
Emit Invoked(msg.sender,_target,_value,_data)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
moduleOnly()

IRs:
MODIFIER_CALL, BaseWallet.moduleOnly()()""];
3->1;
}
",1,0,0,0,"moduleOnly();require(bool,string)(_target.call.value(_value)(_data),BW: call to target failed);Invoked(msg.sender,_target,_value,_data)"
./0x8615ddfe9d4c9e58abff01c999731f3e9e556e80_ext.sol,DAPBOXToken.withdraw,690,695,"TMP_654 = CONVERT this to address,TMP_655(uint256) = SOLIDITY_CALL balance(address)(TMP_654),TMP_656(bool) = INTERNAL_CALL, DAPBOXToken.withdrawAmount(uint256)(TMP_655),RETURN TMP_656,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
withdrawAmount(address(this).balance)

IRs:
TMP_654 = CONVERT this to address
TMP_655(uint256) = SOLIDITY_CALL balance(address)(TMP_654)
TMP_656(bool) = INTERNAL_CALL, DAPBOXToken.withdrawAmount(uint256)(TMP_655)
RETURN TMP_656""];
2[label=""Node Type: RETURN 2

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,0,0,0,withdrawAmount(address(this).balance);success
./0x0096dc2246fc3627cc2bf87a3b0d2e0f87b58589_ext.sol,Zethroll.ownerSetBankroll,359,365,"TMP_83(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:approve, arguments:['ZethrBankroll', '0']  ,ZethrBankroll(address) := newBankroll(address),TMP_84(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:approve, arguments:['newBankroll', 'MAX_INT']  ,MODIFIER_CALL, Zethroll.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ZTHTKN.approve(ZethrBankroll,0)

IRs:
TMP_83(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:approve, arguments:['ZethrBankroll', '0']  ""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ZethrBankroll = newBankroll

IRs:
ZethrBankroll(address) := newBankroll(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ZTHTKN.approve(newBankroll,MAX_INT)

IRs:
TMP_84(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:approve, arguments:['newBankroll', 'MAX_INT']  ""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Zethroll.onlyOwner()()""];
4->1;
}
",1,0,0,0,"onlyOwner();ZTHTKN.approve(ZethrBankroll,0);ZethrBankroll = newBankroll;ZTHTKN.approve(newBankroll,MAX_INT)"
./0x025dce2d39a46296766db7cac8c322e8f59cd5d9_ext.sol,EthToSmthSwaps.close,155,162,"REF_41(mapping(address => EthToSmthSwaps.Swap)) -> swaps[msg.sender],REF_42(EthToSmthSwaps.Swap) -> REF_41[_participantAddress],REF_43(uint256) -> REF_42.balance,TMP_45(bool) = REF_43 == 0,TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45),TMP_47 = CONVERT ratingContractAddress to Reputation,HIGH_LEVEL_CALL, dest:TMP_47(Reputation), function:change, arguments:['msg.sender', '1']  ,INTERNAL_CALL, EthToSmthSwaps.clean(address,address)(msg.sender,_participantAddress),Emit Close()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(swaps[msg.sender][_participantAddress].balance == 0)

IRs:
REF_41(mapping(address => EthToSmthSwaps.Swap)) -> swaps[msg.sender]
REF_42(EthToSmthSwaps.Swap) -> REF_41[_participantAddress]
REF_43(uint256) -> REF_42.balance
TMP_45(bool) = REF_43 == 0
TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Reputation(ratingContractAddress).change(msg.sender,1)

IRs:
TMP_47 = CONVERT ratingContractAddress to Reputation
HIGH_LEVEL_CALL, dest:TMP_47(Reputation), function:change, arguments:['msg.sender', '1']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
clean(msg.sender,_participantAddress)

IRs:
INTERNAL_CALL, EthToSmthSwaps.clean(address,address)(msg.sender,_participantAddress)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Close()

IRs:
Emit Close()""];
}
",1,0,0,0,"require(bool)(swaps[msg.sender][_participantAddress].balance == 0);Reputation(ratingContractAddress).change(msg.sender,1);clean(msg.sender,_participantAddress);Close()"
./0x26bfad55ad49fdfb0014f8c9deca55946848ad3e_ext.sol,Broker.depositERC20,481,503,"TMP_71(bool) = _amount > 0,TMP_72(None) = SOLIDITY_CALL require(bool,string)(TMP_71,Invalid value),REF_8(mapping(address => uint256)) -> balances[_user],REF_9(uint256) -> REF_8[_token],REF_10(mapping(address => uint256)) -> balances[_user],REF_11(uint256) -> REF_10[_token],TMP_73(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_11', '_amount'] ,REF_9(uint256) (->balances) := TMP_73(uint256),TMP_74 = CONVERT _token to ERC20,TMP_75 = CONVERT this to address,TMP_76(bool) = HIGH_LEVEL_CALL, dest:TMP_74(ERC20), function:transferFrom, arguments:['_user', 'TMP_75', '_amount']  ,TMP_77(bool) = INTERNAL_CALL, Broker._getSanitizedReturnValue()(),TMP_78(None) = SOLIDITY_CALL require(bool,string)(TMP_77,transferFrom failed.),Emit BalanceIncrease(_user,_token,_amount,ReasonDeposit),MODIFIER_CALL, Broker.onlyCoordinator()(),MODIFIER_CALL, Broker.onlyActiveState()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(_amount > 0,Invalid value)

IRs:
TMP_71(bool) = _amount > 0
TMP_72(None) = SOLIDITY_CALL require(bool,string)(TMP_71,Invalid value)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_user][_token] = balances[_user][_token].add(_amount)

IRs:
REF_8(mapping(address => uint256)) -> balances[_user]
REF_9(uint256) -> REF_8[_token]
REF_10(mapping(address => uint256)) -> balances[_user]
REF_11(uint256) -> REF_10[_token]
TMP_73(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_11', '_amount'] 
REF_9(uint256) (->balances) := TMP_73(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ERC20(_token).transferFrom(_user,address(this),_amount)

IRs:
TMP_74 = CONVERT _token to ERC20
TMP_75 = CONVERT this to address
TMP_76(bool) = HIGH_LEVEL_CALL, dest:TMP_74(ERC20), function:transferFrom, arguments:['_user', 'TMP_75', '_amount']  ""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool,string)(_getSanitizedReturnValue(),transferFrom failed.)

IRs:
TMP_77(bool) = INTERNAL_CALL, Broker._getSanitizedReturnValue()()
TMP_78(None) = SOLIDITY_CALL require(bool,string)(TMP_77,transferFrom failed.)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
BalanceIncrease(_user,_token,_amount,ReasonDeposit)

IRs:
Emit BalanceIncrease(_user,_token,_amount,ReasonDeposit)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyCoordinator()

IRs:
MODIFIER_CALL, Broker.onlyCoordinator()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyActiveState()

IRs:
MODIFIER_CALL, Broker.onlyActiveState()()""];
7->1;
}
",1,0,0,0,"onlyCoordinator();require(bool,string)(_amount > 0,Invalid value);balances[_user][_token] = balances[_user][_token].add(_amount);ERC20(_token).transferFrom(_user,address(this),_amount);require(bool,string)(_getSanitizedReturnValue(),transferFrom failed.);BalanceIncrease(_user,_token,_amount,ReasonDeposit);onlyActiveState()"
./0x7976af0ae2124a0771d5287aa16017b3f9dd43a4_ext.sol,BasicToken.transfer,212,228,"REF_0(uint256) -> balances[msg.sender],REF_1(uint256) -> balances[msg.sender],TMP_54(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_1', '_value'] ,REF_0(uint256) (->balances) := TMP_54(uint256),REF_3(uint256) -> balances[_to],REF_4(uint256) -> balances[_to],TMP_55(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_4', '_value'] ,REF_3(uint256) (->balances) := TMP_55(uint256),TMP_56(bool) = codeLength > 0,CONDITION TMP_56,TMP_57 = CONVERT _to to ERC223ReceivingContract,receiver(ERC223ReceivingContract) := TMP_57(ERC223ReceivingContract),HIGH_LEVEL_CALL, dest:receiver(ERC223ReceivingContract), function:tokenFallback, arguments:['msg.sender', '_value', '_data']  ,Emit Transfer(msg.sender,_to,_value),MODIFIER_CALL, BasicToken.isTransferable()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: INLINE ASM 2
""];
2->3;
3[label=""Node Type: END INLINE ASM 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_0(uint256) -> balances[msg.sender]
REF_1(uint256) -> balances[msg.sender]
TMP_54(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_1', '_value'] 
REF_0(uint256) (->balances) := TMP_54(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_3(uint256) -> balances[_to]
REF_4(uint256) -> balances[_to]
TMP_55(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_4', '_value'] 
REF_3(uint256) (->balances) := TMP_55(uint256)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
codeLength > 0

IRs:
TMP_56(bool) = codeLength > 0
CONDITION TMP_56""];
6->7[label=""True""];
6->9[label=""False""];
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
receiver = ERC223ReceivingContract(_to)

IRs:
TMP_57 = CONVERT _to to ERC223ReceivingContract
receiver(ERC223ReceivingContract) := TMP_57(ERC223ReceivingContract)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
receiver.tokenFallback(msg.sender,_value,_data)

IRs:
HIGH_LEVEL_CALL, dest:receiver(ERC223ReceivingContract), function:tokenFallback, arguments:['msg.sender', '_value', '_data']  ""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
isTransferable()

IRs:
MODIFIER_CALL, BasicToken.isTransferable()()""];
11->1;
}
",1,0,0,0,"isTransferable();;;;balances[msg.sender] = balances[msg.sender].sub(_value);balances[_to] = balances[_to].add(_value);codeLength > 0;receiver = ERC223ReceivingContract(_to);;receiver.tokenFallback(msg.sender,_value,_data);Transfer(msg.sender,_to,_value)"
./0x5211475520dc4a13fee1cc7c2c0c1167998bcbb8_ext.sol,AuctionContract.closeAuction,139,163,"TMP_45(None) = SOLIDITY_CALL assert(bool)(isActive),TMP_46(bool) = auctionCloseBlock < block.number,TMP_47(None) = SOLIDITY_CALL assert(bool)(TMP_46),TMP_48(bool) = msg.sender == winner,TMP_49(None) = SOLIDITY_CALL assert(bool)(TMP_48),Transfer dest:msg.sender value:prize,TMP_51 = CONVERT auctioneerAddress to Auctioneer,auctioneer(Auctioneer) := TMP_51(Auctioneer),TMP_52 = CONVERT 0 to address,TMP_53(bool) = firstBidder != TMP_52,CONDITION TMP_53,REF_11(uint256) -> bettingMap[firstBidder],firstValue(uint256) := REF_11(uint256),TMP_54(bool) = firstValue >= minimalPrize,CONDITION TMP_54,TMP_56(address) = HIGH_LEVEL_CALL, dest:auctioneer(Auctioneer), function:createAuctionContract, arguments:[] value:firstValue ,firstContract(address) := TMP_56(address),firstBetContract(address) := firstContract(address),TMP_57 = CONVERT 0 to address,TMP_58(bool) = secondBidder != TMP_57,CONDITION TMP_58,REF_14(uint256) -> bettingMap[secondBidder],secondValue(uint256) := REF_14(uint256),TMP_59(bool) = secondValue >= minimalPrize,CONDITION TMP_59,TMP_61(address) = HIGH_LEVEL_CALL, dest:auctioneer(Auctioneer), function:createAuctionContract, arguments:[] value:secondValue ,secondContract(address) := TMP_61(address),secondBetContract(address) := secondContract(address),isActive(bool) := False(bool)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(isActive)

IRs:
TMP_45(None) = SOLIDITY_CALL assert(bool)(isActive)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(auctionCloseBlock < block.number)

IRs:
TMP_46(bool) = auctionCloseBlock < block.number
TMP_47(None) = SOLIDITY_CALL assert(bool)(TMP_46)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
assert(bool)(msg.sender == winner)

IRs:
TMP_48(bool) = msg.sender == winner
TMP_49(None) = SOLIDITY_CALL assert(bool)(TMP_48)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(prize)

IRs:
Transfer dest:msg.sender value:prize""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
auctioneer = Auctioneer(auctioneerAddress)

IRs:
TMP_51 = CONVERT auctioneerAddress to Auctioneer
auctioneer(Auctioneer) := TMP_51(Auctioneer)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
firstBidder != address(0)

IRs:
TMP_52 = CONVERT 0 to address
TMP_53(bool) = firstBidder != TMP_52
CONDITION TMP_53""];
6->7[label=""True""];
6->12[label=""False""];
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
firstValue = bettingMap[firstBidder]

IRs:
REF_11(uint256) -> bettingMap[firstBidder]
firstValue(uint256) := REF_11(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
firstValue >= minimalPrize

IRs:
TMP_54(bool) = firstValue >= minimalPrize
CONDITION TMP_54""];
8->9[label=""True""];
8->11[label=""False""];
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
firstContract = auctioneer.createAuctionContract.value(firstValue)()

IRs:
TMP_56(address) = HIGH_LEVEL_CALL, dest:auctioneer(Auctioneer), function:createAuctionContract, arguments:[] value:firstValue 
firstContract(address) := TMP_56(address)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
firstBetContract = firstContract

IRs:
firstBetContract(address) := firstContract(address)""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
secondBidder != address(0)

IRs:
TMP_57 = CONVERT 0 to address
TMP_58(bool) = secondBidder != TMP_57
CONDITION TMP_58""];
13->14[label=""True""];
13->19[label=""False""];
14[label=""Node Type: NEW VARIABLE 14

EXPRESSION:
secondValue = bettingMap[secondBidder]

IRs:
REF_14(uint256) -> bettingMap[secondBidder]
secondValue(uint256) := REF_14(uint256)""];
14->15;
15[label=""Node Type: IF 15

EXPRESSION:
secondValue >= minimalPrize

IRs:
TMP_59(bool) = secondValue >= minimalPrize
CONDITION TMP_59""];
15->16[label=""True""];
15->18[label=""False""];
16[label=""Node Type: NEW VARIABLE 16

EXPRESSION:
secondContract = auctioneer.createAuctionContract.value(secondValue)()

IRs:
TMP_61(address) = HIGH_LEVEL_CALL, dest:auctioneer(Auctioneer), function:createAuctionContract, arguments:[] value:secondValue 
secondContract(address) := TMP_61(address)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
secondBetContract = secondContract

IRs:
secondBetContract(address) := secondContract(address)""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
isActive = false

IRs:
isActive(bool) := False(bool)""];
}
",1,0,1,0,assert(bool)(isActive);assert(bool)(auctionCloseBlock < block.number);assert(bool)(msg.sender == winner);msg.sender.transfer(prize);auctioneer = Auctioneer(auctioneerAddress);firstBidder != address(0);firstValue = bettingMap[firstBidder];;firstValue >= minimalPrize;firstContract = auctioneer.createAuctionContract.value(firstValue)();;firstBetContract = firstContract;secondBidder != address(0);secondValue = bettingMap[secondBidder];;secondValue >= minimalPrize;secondContract = auctioneer.createAuctionContract.value(secondValue)();;secondBetContract = secondContract;isActive = false
./0x54923b4f2e4433294c70559cc94d1812793f0451_ext.sol,Future1Exchange.tokenWithdraw,59,69,"TMP_8(bool) = archon == msg.sender,CONDITION TMP_8,TMP_9 = CONVERT token to Token,TMP_10 = CONVERT this to address,TMP_11(uint256) = HIGH_LEVEL_CALL, dest:TMP_9(Token), function:balanceOf, arguments:['TMP_10']  ,TMP_12(bool) = TMP_11 >= tokens,CONDITION TMP_12,REF_7(mapping(address => uint256)) -> _token[msg.sender],REF_8(uint256) -> REF_7[token],REF_9(mapping(address => uint256)) -> _token[msg.sender],REF_10(uint256) -> REF_9[token],TMP_13(uint256) = INTERNAL_CALL, Future1Exchange.safeSub(uint256,uint256)(REF_10,tokens),REF_8(uint256) (->_token) := TMP_13(uint256),TMP_14 = CONVERT token to Token,TMP_15(bool) = HIGH_LEVEL_CALL, dest:TMP_14(Token), function:transfer, arguments:['to', 'tokens']  ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
archon == msg.sender

IRs:
TMP_8(bool) = archon == msg.sender
CONDITION TMP_8""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
Token(token).balanceOf(address(this)) >= tokens

IRs:
TMP_9 = CONVERT token to Token
TMP_10 = CONVERT this to address
TMP_11(uint256) = HIGH_LEVEL_CALL, dest:TMP_9(Token), function:balanceOf, arguments:['TMP_10']  
TMP_12(bool) = TMP_11 >= tokens
CONDITION TMP_12""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_token[msg.sender][token] = safeSub(_token[msg.sender][token],tokens)

IRs:
REF_7(mapping(address => uint256)) -> _token[msg.sender]
REF_8(uint256) -> REF_7[token]
REF_9(mapping(address => uint256)) -> _token[msg.sender]
REF_10(uint256) -> REF_9[token]
TMP_13(uint256) = INTERNAL_CALL, Future1Exchange.safeSub(uint256,uint256)(REF_10,tokens)
REF_8(uint256) (->_token) := TMP_13(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Token(token).transfer(to,tokens)

IRs:
TMP_14 = CONVERT token to Token
TMP_15(bool) = HIGH_LEVEL_CALL, dest:TMP_14(Token), function:transfer, arguments:['to', 'tokens']  ""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",1,0,0,0,"archon == msg.sender;Token(token).balanceOf(address(this)) >= tokens;;_token[msg.sender][token] = safeSub(_token[msg.sender][token],tokens);;Token(token).transfer(to,tokens)"
./0x4145492ad5039b802bd7e58098c8d71706a2cd14_ext.sol,ElepigCrowdsale.finish,641,653,"TMP_336 = UnaryType.BANG isFinalized ,TMP_337(None) = SOLIDITY_CALL require(bool)(TMP_336),TMP_338(bool) = tokensMinted < totalTokensForSale,CONDITION TMP_338,TMP_339(uint256) = totalTokensForSale - tokensMinted,unsoldTokens(uint256) := TMP_339(uint256),TMP_340(bool) = HIGH_LEVEL_CALL, dest:tokenReward(token), function:mint, arguments:['community', 'unsoldTokens']  ,INTERNAL_CALL, FinalizableCrowdsale.finalize()(),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isFinalized)

IRs:
TMP_336 = UnaryType.BANG isFinalized 
TMP_337(None) = SOLIDITY_CALL require(bool)(TMP_336)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
tokensMinted < totalTokensForSale

IRs:
TMP_338(bool) = tokensMinted < totalTokensForSale
CONDITION TMP_338""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
unsoldTokens = totalTokensForSale - tokensMinted

IRs:
TMP_339(uint256) = totalTokensForSale - tokensMinted
unsoldTokens(uint256) := TMP_339(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
tokenReward.mint(community,unsoldTokens)

IRs:
TMP_340(bool) = HIGH_LEVEL_CALL, dest:tokenReward(token), function:mint, arguments:['community', 'unsoldTokens']  ""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
finalize()

IRs:
INTERNAL_CALL, FinalizableCrowdsale.finalize()()""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->1;
}
",1,0,0,0,"onlyOwner();require(bool)(! isFinalized);tokensMinted < totalTokensForSale;unsoldTokens = totalTokensForSale - tokensMinted;;tokenReward.mint(community,unsoldTokens);finalize()"
./0xc7bd5dac314a67a375a0347d72797c2ea1f1a672_ext.sol,KlownGasDrop.claimGasDrop,138,166,"REF_3(bool) -> receivers[msg.sender],TMP_5(bool) = REF_3 != True,CONDITION TMP_5,REF_4(uint256) -> balances[whoSent],TMP_6(bool) = amountToClaim <= REF_4,CONDITION TMP_6,REF_5(uint256) -> balances[whoSent],REF_5(-> balances) = REF_5 - amountToClaim,TMP_7 = CONVERT currentTokenAddress to IERC20,TMP_8(bool) = HIGH_LEVEL_CALL, dest:TMP_7(IERC20), function:transfer, arguments:['msg.sender', 'amountToClaim']  ,REF_7(bool) -> receivers[msg.sender],REF_7(bool) (->receivers) := True(bool),totalSent(uint256) = totalSent + amountToClaim","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
receivers[msg.sender] != true

IRs:
REF_3(bool) -> receivers[msg.sender]
TMP_5(bool) = REF_3 != True
CONDITION TMP_5""];
1->2[label=""True""];
1->8[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
amountToClaim <= balances[whoSent]

IRs:
REF_4(uint256) -> balances[whoSent]
TMP_6(bool) = amountToClaim <= REF_4
CONDITION TMP_6""];
2->3[label=""True""];
2->7[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[whoSent] -= amountToClaim

IRs:
REF_5(uint256) -> balances[whoSent]
REF_5(-> balances) = REF_5 - amountToClaim""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
IERC20(currentTokenAddress).transfer(msg.sender,amountToClaim)

IRs:
TMP_7 = CONVERT currentTokenAddress to IERC20
TMP_8(bool) = HIGH_LEVEL_CALL, dest:TMP_7(IERC20), function:transfer, arguments:['msg.sender', 'amountToClaim']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
receivers[msg.sender] = true

IRs:
REF_7(bool) -> receivers[msg.sender]
REF_7(bool) (->receivers) := True(bool)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
totalSent += amountToClaim

IRs:
totalSent(uint256) = totalSent + amountToClaim""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: END_IF 8
""];
}
",1,0,0,0,"receivers[msg.sender] != true;amountToClaim <= balances[whoSent];;balances[whoSent] -= amountToClaim;;IERC20(currentTokenAddress).transfer(msg.sender,amountToClaim);receivers[msg.sender] = true;totalSent += amountToClaim"
./0x6dbb4e882f967432fc0f9200e9ca577c916d8a68_ext.sol,Bussiness.setPrice,94,98,"TMP_13(address) = HIGH_LEVEL_CALL, dest:erc721Address(IERC721), function:ownerOf, arguments:['_tokenId']  ,TMP_14(bool) = TMP_13 == msg.sender,TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14),REF_2(Bussiness.Price) -> prices[_tokenId],TMP_16(Bussiness.Price) = new Price(msg.sender,_ethPrice,0),REF_2(Bussiness.Price) (->prices) := TMP_16(Bussiness.Price),REF_3(Bussiness.Price) -> usdtPrices[_tokenId],TMP_17(Bussiness.Price) = new Price(msg.sender,_usdtPrice,0),REF_3(Bussiness.Price) (->usdtPrices) := TMP_17(Bussiness.Price)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(erc721Address.ownerOf(_tokenId) == msg.sender)

IRs:
TMP_13(address) = HIGH_LEVEL_CALL, dest:erc721Address(IERC721), function:ownerOf, arguments:['_tokenId']  
TMP_14(bool) = TMP_13 == msg.sender
TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
prices[_tokenId] = Price(msg.sender,_ethPrice,0)

IRs:
REF_2(Bussiness.Price) -> prices[_tokenId]
TMP_16(Bussiness.Price) = new Price(msg.sender,_ethPrice,0)
REF_2(Bussiness.Price) (->prices) := TMP_16(Bussiness.Price)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
usdtPrices[_tokenId] = Price(msg.sender,_usdtPrice,0)

IRs:
REF_3(Bussiness.Price) -> usdtPrices[_tokenId]
TMP_17(Bussiness.Price) = new Price(msg.sender,_usdtPrice,0)
REF_3(Bussiness.Price) (->usdtPrices) := TMP_17(Bussiness.Price)""];
}
",1,0,0,0,"require(bool)(erc721Address.ownerOf(_tokenId) == msg.sender);prices[_tokenId] = Price(msg.sender,_ethPrice,0);usdtPrices[_tokenId] = Price(msg.sender,_usdtPrice,0)"
./0x6b4df2aa3d64d8dc06120ef4391513e4170af4a7_ext.sol,GeneralTransferManager.changeAllowAllTransfers,766,769,"allowAllTransfers(bool) := _allowAllTransfers(bool),Emit LogAllowAllTransfers(_allowAllTransfers),MODIFIER_CALL, IModule.withPerm(bytes32)(FLAGS)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowAllTransfers = _allowAllTransfers

IRs:
allowAllTransfers(bool) := _allowAllTransfers(bool)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
LogAllowAllTransfers(_allowAllTransfers)

IRs:
Emit LogAllowAllTransfers(_allowAllTransfers)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
withPerm(FLAGS)

IRs:
MODIFIER_CALL, IModule.withPerm(bytes32)(FLAGS)""];
3->1;
}
",1,0,0,0,withPerm(FLAGS);allowAllTransfers = _allowAllTransfers;LogAllowAllTransfers(_allowAllTransfers)
./0x301487766dcf283592b11b5988e5c4e4630dfbe5_ext.sol,EDex.withdraw,212,217,"REF_51(mapping(address => uint256)) -> tokens[0],REF_52(uint256) -> REF_51[msg.sender],TMP_93(bool) = REF_52 < amount,CONDITION TMP_93,TMP_94(None) = SOLIDITY_CALL revert()(),REF_53(mapping(address => uint256)) -> tokens[0],REF_54(uint256) -> REF_53[msg.sender],REF_55(mapping(address => uint256)) -> tokens[0],REF_56(uint256) -> REF_55[msg.sender],TMP_95(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_56,amount),REF_54(uint256) (->tokens) := TMP_95(uint256),TMP_97(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:amount ,TMP_98 = UnaryType.BANG TMP_97 ,CONDITION TMP_98,TMP_99(None) = SOLIDITY_CALL revert()(),REF_59(mapping(address => uint256)) -> tokens[0],REF_60(uint256) -> REF_59[msg.sender],Emit Withdraw(0,msg.sender,amount,REF_60)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
tokens[0][msg.sender] < amount

IRs:
REF_51(mapping(address => uint256)) -> tokens[0]
REF_52(uint256) -> REF_51[msg.sender]
TMP_93(bool) = REF_52 < amount
CONDITION TMP_93""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_94(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender],amount)

IRs:
REF_53(mapping(address => uint256)) -> tokens[0]
REF_54(uint256) -> REF_53[msg.sender]
REF_55(mapping(address => uint256)) -> tokens[0]
REF_56(uint256) -> REF_55[msg.sender]
TMP_95(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_56,amount)
REF_54(uint256) (->tokens) := TMP_95(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
! msg.sender.call.value(amount)()

IRs:
TMP_97(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:amount 
TMP_98 = UnaryType.BANG TMP_97 
CONDITION TMP_98""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
revert()()

IRs:
TMP_99(None) = SOLIDITY_CALL revert()()""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Withdraw(0,msg.sender,amount,tokens[0][msg.sender])

IRs:
REF_59(mapping(address => uint256)) -> tokens[0]
REF_60(uint256) -> REF_59[msg.sender]
Emit Withdraw(0,msg.sender,amount,REF_60)""];
}
",1,0,0,0,"tokens[0][msg.sender] < amount;revert()();;tokens[0][msg.sender] = safeSub(tokens[0][msg.sender],amount);! msg.sender.call.value(amount)();revert()();;Withdraw(0,msg.sender,amount,tokens[0][msg.sender])"
./0x020ddc98365d0199b4c7a2d769d685480789f67e_ext.sol,EOSclassic.claimEOSclassicFor,400,432,"TMP_117 = CONVERT 0 to address,TMP_118(bool) = _toAddress != TMP_117,TMP_119(None) = SOLIDITY_CALL require(bool)(TMP_118),TMP_120(bool) = INTERNAL_CALL, EOSclassic.isClaimed(address)(_toAddress),TMP_121(bool) = TMP_120 == False,TMP_122(None) = SOLIDITY_CALL require(bool)(TMP_121),TMP_123(uint256) = INTERNAL_CALL, EOSclassic.queryEOSTokenBalance(address)(_toAddress),_eosContractBalance(uint256) := TMP_123(uint256),TMP_124(bool) = _eosContractBalance > 0,TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124),TMP_126 = CONVERT this to address,REF_103(uint256) -> balances[TMP_126],TMP_127(bool) = _eosContractBalance <= REF_103,TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127),REF_104(bool) -> eosClassicClaimed[_toAddress],REF_104(bool) (->eosClassicClaimed) := True(bool),TMP_129 = CONVERT this to address,REF_105(uint256) -> balances[TMP_129],TMP_130 = CONVERT this to address,REF_106(uint256) -> balances[TMP_130],TMP_131(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_106', '_eosContractBalance'] ,REF_105(uint256) (->balances) := TMP_131(uint256),REF_108(uint256) -> balances[_toAddress],REF_109(uint256) -> balances[_toAddress],TMP_132(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_109', '_eosContractBalance'] ,REF_108(uint256) (->balances) := TMP_132(uint256),TMP_133 = CONVERT this to address,Emit Transfer(TMP_133,_toAddress,_eosContractBalance),Emit LogClaim(_toAddress,_eosContractBalance),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_toAddress != address(0))

IRs:
TMP_117 = CONVERT 0 to address
TMP_118(bool) = _toAddress != TMP_117
TMP_119(None) = SOLIDITY_CALL require(bool)(TMP_118)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(isClaimed(_toAddress) == false)

IRs:
TMP_120(bool) = INTERNAL_CALL, EOSclassic.isClaimed(address)(_toAddress)
TMP_121(bool) = TMP_120 == False
TMP_122(None) = SOLIDITY_CALL require(bool)(TMP_121)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
_eosContractBalance = queryEOSTokenBalance(_toAddress)

IRs:
TMP_123(uint256) = INTERNAL_CALL, EOSclassic.queryEOSTokenBalance(address)(_toAddress)
_eosContractBalance(uint256) := TMP_123(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_eosContractBalance > 0)

IRs:
TMP_124(bool) = _eosContractBalance > 0
TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(_eosContractBalance <= balances[address(this)])

IRs:
TMP_126 = CONVERT this to address
REF_103(uint256) -> balances[TMP_126]
TMP_127(bool) = _eosContractBalance <= REF_103
TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
eosClassicClaimed[_toAddress] = true

IRs:
REF_104(bool) -> eosClassicClaimed[_toAddress]
REF_104(bool) (->eosClassicClaimed) := True(bool)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[address(this)] = balances[address(this)].sub(_eosContractBalance)

IRs:
TMP_129 = CONVERT this to address
REF_105(uint256) -> balances[TMP_129]
TMP_130 = CONVERT this to address
REF_106(uint256) -> balances[TMP_130]
TMP_131(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_106', '_eosContractBalance'] 
REF_105(uint256) (->balances) := TMP_131(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[_toAddress] = balances[_toAddress].add(_eosContractBalance)

IRs:
REF_108(uint256) -> balances[_toAddress]
REF_109(uint256) -> balances[_toAddress]
TMP_132(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_109', '_eosContractBalance'] 
REF_108(uint256) (->balances) := TMP_132(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
Transfer(address(this),_toAddress,_eosContractBalance)

IRs:
TMP_133 = CONVERT this to address
Emit Transfer(TMP_133,_toAddress,_eosContractBalance)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
LogClaim(_toAddress,_eosContractBalance)

IRs:
Emit LogClaim(_toAddress,_eosContractBalance)""];
10->11;
11[label=""Node Type: RETURN 11

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,"require(bool)(_toAddress != address(0));require(bool)(isClaimed(_toAddress) == false);_eosContractBalance = queryEOSTokenBalance(_toAddress);require(bool)(_eosContractBalance > 0);require(bool)(_eosContractBalance <= balances[address(this)]);eosClassicClaimed[_toAddress] = true;balances[address(this)] = balances[address(this)].sub(_eosContractBalance);balances[_toAddress] = balances[_toAddress].add(_eosContractBalance);Transfer(address(this),_toAddress,_eosContractBalance);LogClaim(_toAddress,_eosContractBalance);true"
./0xeee7c7e228eafb0f8945c5dbaa8ea4f6ee12b36d_ext.sol,Crowdsale.buyTokens,120,142,"TMP_21(bool) = beneficiary != 0,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),TMP_23(bool) = INTERNAL_CALL, Crowdsale.validPurchase()(),TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),weiAmount(uint256) := msg.value(uint256),TMP_25(uint256) = weiAmount * price,tokens(uint256) := TMP_25(uint256),TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] ,weiRaised(uint256) := TMP_26(uint256),HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['beneficiary', 'tokens']  ,Emit TokenPurchase(msg.sender,beneficiary,weiAmount,tokens),INTERNAL_CALL, Crowdsale.forwardFunds()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != 0x0)

IRs:
TMP_21(bool) = beneficiary != 0
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(validPurchase())

IRs:
TMP_23(bool) = INTERNAL_CALL, Crowdsale.validPurchase()()
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
tokens = (weiAmount) * price

IRs:
TMP_25(uint256) = weiAmount * price
tokens(uint256) := TMP_25(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_26(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tokenReward.transfer(beneficiary,tokens)

IRs:
HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['beneficiary', 'tokens']  ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
forwardFunds()

IRs:
INTERNAL_CALL, Crowdsale.forwardFunds()()""];
}
",1,0,0,0,"require(bool)(beneficiary != 0x0);require(bool)(validPurchase());weiAmount = msg.value;tokens = (weiAmount) * price;weiRaised = weiRaised.add(weiAmount);tokenReward.transfer(beneficiary,tokens);TokenPurchase(msg.sender,beneficiary,weiAmount,tokens);forwardFunds()"
./0xc0952584ddd2735a237f844dab59bde737e7fe14_ext.sol,lockEtherPay.lock,87,93,"TMP_27 = UnaryType.BANG isLocked ,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),TMP_29(uint256) = INTERNAL_CALL, lockEtherPay.tokenBalance()(),TMP_30(bool) = TMP_29 > 0,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),start_time(uint256) := now(uint256),TMP_32(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['start_time', 'fifty_two_weeks'] ,end_time(uint256) := TMP_32(uint256),isLocked(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isLocked)

IRs:
TMP_27 = UnaryType.BANG isLocked 
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(tokenBalance() > 0)

IRs:
TMP_29(uint256) = INTERNAL_CALL, lockEtherPay.tokenBalance()()
TMP_30(bool) = TMP_29 > 0
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
start_time = now

IRs:
start_time(uint256) := now(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
end_time = start_time.add(fifty_two_weeks)

IRs:
TMP_32(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['start_time', 'fifty_two_weeks'] 
end_time(uint256) := TMP_32(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
isLocked = true

IRs:
isLocked(bool) := True(bool)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",1,0,0,0,onlyOwner();require(bool)(! isLocked);require(bool)(tokenBalance() > 0);start_time = now;end_time = start_time.add(fifty_two_weeks);isLocked = true
./0x3639d5dc956e35540fbd1de691870fb1318d6783_ext.sol,SNTGiveaway.manualSend,192,202,"REF_21(bool) -> sentToAddress[_dest],TMP_35 = UnaryType.BANG REF_21 ,REF_22(bool) -> codeUsed[_code],TMP_36 = UnaryType.BANG REF_22 ,TMP_37(bool) = TMP_35 && TMP_36,TMP_38(None) = SOLIDITY_CALL require(bool,string)(TMP_37,Funds already sent / Code already used),REF_23(bool) -> sentToAddress[_dest],REF_23(bool) (->sentToAddress) := True(bool),REF_24(bool) -> codeUsed[_code],REF_24(bool) (->codeUsed) := True(bool),TMP_39(bool) = HIGH_LEVEL_CALL, dest:SNT(ERC20Token), function:transfer, arguments:['_dest', 'sntAmount']  ,TMP_40(None) = SOLIDITY_CALL require(bool,string)(TMP_39,Transfer did not work),Transfer dest:_dest value:ethAmount,Emit AddressFunded(_dest,_code,ethAmount,sntAmount),MODIFIER_CALL, Controlled.onlyController()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(! sentToAddress[_dest] && ! codeUsed[_code],Funds already sent / Code already used)

IRs:
REF_21(bool) -> sentToAddress[_dest]
TMP_35 = UnaryType.BANG REF_21 
REF_22(bool) -> codeUsed[_code]
TMP_36 = UnaryType.BANG REF_22 
TMP_37(bool) = TMP_35 && TMP_36
TMP_38(None) = SOLIDITY_CALL require(bool,string)(TMP_37,Funds already sent / Code already used)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
sentToAddress[_dest] = true

IRs:
REF_23(bool) -> sentToAddress[_dest]
REF_23(bool) (->sentToAddress) := True(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
codeUsed[_code] = true

IRs:
REF_24(bool) -> codeUsed[_code]
REF_24(bool) (->codeUsed) := True(bool)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool,string)(SNT.transfer(_dest,sntAmount),Transfer did not work)

IRs:
TMP_39(bool) = HIGH_LEVEL_CALL, dest:SNT(ERC20Token), function:transfer, arguments:['_dest', 'sntAmount']  
TMP_40(None) = SOLIDITY_CALL require(bool,string)(TMP_39,Transfer did not work)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_dest.transfer(ethAmount)

IRs:
Transfer dest:_dest value:ethAmount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
AddressFunded(_dest,_code,ethAmount,sntAmount)

IRs:
Emit AddressFunded(_dest,_code,ethAmount,sntAmount)""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()""];
7->1;
}
",1,0,1,0,"onlyController();require(bool,string)(! sentToAddress[_dest] && ! codeUsed[_code],Funds already sent / Code already used);sentToAddress[_dest] = true;codeUsed[_code] = true;require(bool,string)(SNT.transfer(_dest,sntAmount),Transfer did not work);_dest.transfer(ethAmount);AddressFunded(_dest,_code,ethAmount,sntAmount)"
./0xcef8feebbdc278c0c81e07b87abf96b22d08fa6e_ext.sol,UnicornRefunds.claimReward,79,91,"TMP_17 = CONVERT unicornRanchAddress to UnicornRanch,ranch(UnicornRanch) := TMP_17(UnicornRanch),TUPLE_0(uint256,UnicornRanch.VisitType,uint256,uint256,UnicornRanch.VisitState,uint256,uint256) = HIGH_LEVEL_CALL, dest:ranch(UnicornRanch), function:getBooking, arguments:['msg.sender', '_bookingIndex']  ,unicornCount(uint256)= UNPACK TUPLE_0 index: 0 ,visitType(UnicornRanch.VisitType)= UNPACK TUPLE_0 index: 1 ,state(UnicornRanch.VisitState)= UNPACK TUPLE_0 index: 4 ,completedCount(uint256)= UNPACK TUPLE_0 index: 6 ,REF_1(UnicornRanch.VisitState) -> VisitState.Completed,TMP_18(bool) = state == REF_1,TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18),REF_2(UnicornRanch.VisitType) -> VisitType.Spa,TMP_20(bool) = visitType != REF_2,TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20),TMP_22(bool) = completedCount > unicornCount,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_3(bool) -> rewardClaimed[msg.sender],TMP_24(bool) = REF_3 == False,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_4(bool) -> rewardClaimed[msg.sender],REF_4(bool) (->rewardClaimed) := True(bool),REF_5(uint256) -> allowedAmounts[msg.sender],REF_6(uint256) -> allowedAmounts[msg.sender],TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_6', 'rewardUnicornAmount'] ,REF_5(uint256) (->allowedAmounts) := TMP_26(uint256),Emit RewardClaimed(msg.sender,_bookingIndex)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
ranch = UnicornRanch(unicornRanchAddress)

IRs:
TMP_17 = CONVERT unicornRanchAddress to UnicornRanch
ranch(UnicornRanch) := TMP_17(UnicornRanch)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: NEW VARIABLE 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
(unicornCount,visitType,None,None,state,None,completedCount) = ranch.getBooking(msg.sender,_bookingIndex)

IRs:
TUPLE_0(uint256,UnicornRanch.VisitType,uint256,uint256,UnicornRanch.VisitState,uint256,uint256) = HIGH_LEVEL_CALL, dest:ranch(UnicornRanch), function:getBooking, arguments:['msg.sender', '_bookingIndex']  
unicornCount(uint256)= UNPACK TUPLE_0 index: 0 
visitType(UnicornRanch.VisitType)= UNPACK TUPLE_0 index: 1 
state(UnicornRanch.VisitState)= UNPACK TUPLE_0 index: 4 
completedCount(uint256)= UNPACK TUPLE_0 index: 6 ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(state == UnicornRanch.VisitState.Completed)

IRs:
REF_1(UnicornRanch.VisitState) -> VisitState.Completed
TMP_18(bool) = state == REF_1
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(visitType != UnicornRanch.VisitType.Spa)

IRs:
REF_2(UnicornRanch.VisitType) -> VisitType.Spa
TMP_20(bool) = visitType != REF_2
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(completedCount > unicornCount)

IRs:
TMP_22(bool) = completedCount > unicornCount
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(rewardClaimed[msg.sender] == false)

IRs:
REF_3(bool) -> rewardClaimed[msg.sender]
TMP_24(bool) = REF_3 == False
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
rewardClaimed[msg.sender] = true

IRs:
REF_4(bool) -> rewardClaimed[msg.sender]
REF_4(bool) (->rewardClaimed) := True(bool)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
allowedAmounts[msg.sender] = allowedAmounts[msg.sender].add(rewardUnicornAmount)

IRs:
REF_5(uint256) -> allowedAmounts[msg.sender]
REF_6(uint256) -> allowedAmounts[msg.sender]
TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_6', 'rewardUnicornAmount'] 
REF_5(uint256) (->allowedAmounts) := TMP_26(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
RewardClaimed(msg.sender,_bookingIndex)

IRs:
Emit RewardClaimed(msg.sender,_bookingIndex)""];
}
",1,0,0,0,"ranch = UnicornRanch(unicornRanchAddress);;;;;(unicornCount,visitType,None,None,state,None,completedCount) = ranch.getBooking(msg.sender,_bookingIndex);require(bool)(state == UnicornRanch.VisitState.Completed);require(bool)(visitType != UnicornRanch.VisitType.Spa);require(bool)(completedCount > unicornCount);require(bool)(rewardClaimed[msg.sender] == false);rewardClaimed[msg.sender] = true;allowedAmounts[msg.sender] = allowedAmounts[msg.sender].add(rewardUnicornAmount);RewardClaimed(msg.sender,_bookingIndex)"
./0x56853ab9006e0712b05c68b586372fcdde5236b9_ext.sol,AirDrop.sendTokens,51,58,"i(uint256) := 0(uint256),REF_0 -> LENGTH dests,TMP_13(bool) = i < REF_0,CONDITION TMP_13,REF_1(uint256) -> values[i],TMP_14(uint256) = 10 ** 18,TMP_15(uint256) = REF_1 * TMP_14,toSend(uint256) := TMP_15(uint256),REF_2(address) -> dests[i],REF_3(uint256) -> values[i],INTERNAL_CALL, AirDrop.sendInternally(address,uint256,uint256)(REF_2,toSend,REF_3),TMP_17(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, AirDrop.whenDropIsActive()(),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->3;
3[label=""Node Type: IF_LOOP 3

EXPRESSION:
i < dests.length

IRs:
REF_0 -> LENGTH dests
TMP_13(bool) = i < REF_0
CONDITION TMP_13""];
3->4[label=""True""];
3->7[label=""False""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
toSend = values[i] * 10 ** 18

IRs:
REF_1(uint256) -> values[i]
TMP_14(uint256) = 10 ** 18
TMP_15(uint256) = REF_1 * TMP_14
toSend(uint256) := TMP_15(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
sendInternally(dests[i],toSend,values[i])

IRs:
REF_2(address) -> dests[i]
REF_3(uint256) -> values[i]
INTERNAL_CALL, AirDrop.sendInternally(address,uint256,uint256)(REF_2,toSend,REF_3)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_17(uint256) := i(uint256)
i(uint256) = i + 1""];
6->3;
7[label=""Node Type: END_LOOP 7
""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
whenDropIsActive()

IRs:
MODIFIER_CALL, AirDrop.whenDropIsActive()()""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
9->1;
}
",1,0,0,0,"whenDropIsActive();i = 0;;i < dests.length;toSend = values[i] * 10 ** 18;;sendInternally(dests[i],toSend,values[i]);i ++;onlyOwner()"
./0xa27f262391913a5e21216c70de5358a1e887de25_ext.sol,VestingContractWTTEST.ownerTransfer,106,116,"current_balance_all(uint256) := 0(uint256),i(uint256) := 0(uint256),REF_27 -> LENGTH accounts,TMP_21(bool) = i < REF_27,CONDITION TMP_21,REF_28(address) -> accounts[i],REF_29(VestingContractWTTEST.AccountData) -> account_data[REF_28],REF_30(uint256) -> REF_29.current_balance,current_balance_all(uint256) = current_balance_all + REF_30,TMP_22(uint256) := i(uint256),i(uint256) = i + 1,TMP_23(uint256) = INTERNAL_CALL, VestingContractWTTEST.getBalance()(),TMP_24(bool) = TMP_23 > current_balance_all,TMP_25(uint256) = INTERNAL_CALL, VestingContractWTTEST.getBalance()(),TMP_26(uint256) = TMP_25 - current_balance_all,TMP_27(bool) = value <= TMP_26,TMP_28(bool) = TMP_24 && TMP_27,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),TMP_30(bool) = HIGH_LEVEL_CALL, dest:we_test_token(WeTestToken), function:transfer, arguments:['to', 'value']  ,CONDITION TMP_30,Emit OwnerTransfer(to,value),MODIFIER_CALL, VestingContractWTTEST.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
current_balance_all = 0

IRs:
current_balance_all(uint256) := 0(uint256)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
3->8;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < accounts.length

IRs:
REF_27 -> LENGTH accounts
TMP_21(bool) = i < REF_27
CONDITION TMP_21""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
current_balance_all += account_data[accounts[i]].current_balance

IRs:
REF_28(address) -> accounts[i]
REF_29(VestingContractWTTEST.AccountData) -> account_data[REF_28]
REF_30(uint256) -> REF_29.current_balance
current_balance_all(uint256) = current_balance_all + REF_30""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_22(uint256) := i(uint256)
i(uint256) = i + 1""];
7->5;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(getBalance() > current_balance_all && value <= getBalance() - current_balance_all)

IRs:
TMP_23(uint256) = INTERNAL_CALL, VestingContractWTTEST.getBalance()()
TMP_24(bool) = TMP_23 > current_balance_all
TMP_25(uint256) = INTERNAL_CALL, VestingContractWTTEST.getBalance()()
TMP_26(uint256) = TMP_25 - current_balance_all
TMP_27(bool) = value <= TMP_26
TMP_28(bool) = TMP_24 && TMP_27
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
we_test_token.transfer(to,value)

IRs:
TMP_30(bool) = HIGH_LEVEL_CALL, dest:we_test_token(WeTestToken), function:transfer, arguments:['to', 'value']  
CONDITION TMP_30""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
OwnerTransfer(to,value)

IRs:
Emit OwnerTransfer(to,value)""];
10->11;
11[label=""Node Type: END_IF 11
""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, VestingContractWTTEST.onlyOwner()()""];
12->1;
}
",1,0,0,0,"onlyOwner();current_balance_all = 0;i = 0;;i < accounts.length;;require(bool)(getBalance() > current_balance_all && value <= getBalance() - current_balance_all);current_balance_all += account_data[accounts[i]].current_balance;i ++;we_test_token.transfer(to,value);OwnerTransfer(to,value);"
./0x301487766dcf283592b11b5988e5c4e4630dfbe5_ext.sol,EDex.depositToken,219,225,"TMP_101(bool) = token == 0,CONDITION TMP_101,TMP_102(None) = SOLIDITY_CALL revert()(),TMP_103 = CONVERT token to Token,TMP_104(bool) = HIGH_LEVEL_CALL, dest:TMP_103(Token), function:transferFrom, arguments:['msg.sender', 'this', 'amount']  ,TMP_105 = UnaryType.BANG TMP_104 ,CONDITION TMP_105,TMP_106(None) = SOLIDITY_CALL revert()(),REF_62(mapping(address => uint256)) -> tokens[token],REF_63(uint256) -> REF_62[msg.sender],REF_64(mapping(address => uint256)) -> tokens[token],REF_65(uint256) -> REF_64[msg.sender],TMP_107(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_65,amount),REF_63(uint256) (->tokens) := TMP_107(uint256),REF_66(mapping(address => uint256)) -> tokens[token],REF_67(uint256) -> REF_66[msg.sender],Emit Deposit(token,msg.sender,amount,REF_67)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
token == 0

IRs:
TMP_101(bool) = token == 0
CONDITION TMP_101""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_102(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
! Token(token).transferFrom(msg.sender,this,amount)

IRs:
TMP_103 = CONVERT token to Token
TMP_104(bool) = HIGH_LEVEL_CALL, dest:TMP_103(Token), function:transferFrom, arguments:['msg.sender', 'this', 'amount']  
TMP_105 = UnaryType.BANG TMP_104 
CONDITION TMP_105""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
revert()()

IRs:
TMP_106(None) = SOLIDITY_CALL revert()()""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender],amount)

IRs:
REF_62(mapping(address => uint256)) -> tokens[token]
REF_63(uint256) -> REF_62[msg.sender]
REF_64(mapping(address => uint256)) -> tokens[token]
REF_65(uint256) -> REF_64[msg.sender]
TMP_107(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_65,amount)
REF_63(uint256) (->tokens) := TMP_107(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Deposit(token,msg.sender,amount,tokens[token][msg.sender])

IRs:
REF_66(mapping(address => uint256)) -> tokens[token]
REF_67(uint256) -> REF_66[msg.sender]
Emit Deposit(token,msg.sender,amount,REF_67)""];
}
",1,0,0,0,"token == 0;revert()();;! Token(token).transferFrom(msg.sender,this,amount);revert()();;tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender],amount);Deposit(token,msg.sender,amount,tokens[token][msg.sender])"
./0x0317ada015cf35244b9f9c7d1f8f05c3651833ff_ext.sol,TokenAbout.claimTokens,64,83,"REF_0 -> LENGTH tokens,TMP_19(bool) = REF_0 <= 100,TMP_20(None) = SOLIDITY_CALL require(bool,string)(TMP_19,tokens.length too long),REF_1 -> LENGTH tokens,TMP_21(bool) = i < REF_1,CONDITION TMP_21,REF_2(address) -> tokens[i],_token(address) := REF_2(address),TMP_22(bool) = _token == 0,CONDITION TMP_22,TMP_23 = CONVERT this to address,TMP_24(uint256) = SOLIDITY_CALL balance(address)(TMP_23),balance(uint256) := TMP_24(uint256),TMP_25(bool) = balance > 0,CONDITION TMP_25,Transfer dest:msg.sender value:balance,TMP_27 = CONVERT _token to ERC20Token,token(ERC20Token) := TMP_27(ERC20Token),TMP_28 = CONVERT this to address,TMP_29(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:balanceOf, arguments:['TMP_28']  ,balance(uint256) := TMP_29(uint256),TMP_30(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:transfer, arguments:['msg.sender', 'balance']  ,Emit ClaimedTokens(_token,msg.sender,balance),TMP_32(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Controlled.onlyController()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->21;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(tokens.length <= 100,tokens.length too long)

IRs:
REF_0 -> LENGTH tokens
TMP_19(bool) = REF_0 <= 100
TMP_20(None) = SOLIDITY_CALL require(bool,string)(TMP_19,tokens.length too long)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: NEW VARIABLE 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4
""];
4->7;
5[label=""Node Type: BEGIN_LOOP 5
""];
5->8;
6[label=""Node Type: END_LOOP 6
""];
7[label=""Node Type: NEW VARIABLE 7
""];
7->5;
8[label=""Node Type: IF_LOOP 8

EXPRESSION:
i < tokens.length

IRs:
REF_1 -> LENGTH tokens
TMP_21(bool) = i < REF_1
CONDITION TMP_21""];
8->9[label=""True""];
8->6[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
_token = tokens[i]

IRs:
REF_2(address) -> tokens[i]
_token(address) := REF_2(address)""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
_token == 0x0

IRs:
TMP_22(bool) = _token == 0
CONDITION TMP_22""];
10->11[label=""True""];
10->15[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
balance = address(this).balance

IRs:
TMP_23 = CONVERT this to address
TMP_24(uint256) = SOLIDITY_CALL balance(address)(TMP_23)
balance(uint256) := TMP_24(uint256)""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
balance > 0

IRs:
TMP_25(bool) = balance > 0
CONDITION TMP_25""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
msg.sender.transfer(balance)

IRs:
Transfer dest:msg.sender value:balance""];
13->14;
14[label=""Node Type: END_IF 14
""];
14->19;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
token = ERC20Token(_token)

IRs:
TMP_27 = CONVERT _token to ERC20Token
token(ERC20Token) := TMP_27(ERC20Token)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
balance = token.balanceOf(address(this))

IRs:
TMP_28 = CONVERT this to address
TMP_29(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:balanceOf, arguments:['TMP_28']  
balance(uint256) := TMP_29(uint256)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
token.transfer(msg.sender,balance)

IRs:
TMP_30(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:transfer, arguments:['msg.sender', 'balance']  ""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
ClaimedTokens(_token,msg.sender,balance)

IRs:
Emit ClaimedTokens(_token,msg.sender,balance)""];
18->19;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
i ++

IRs:
TMP_32(uint256) := i(uint256)
i(uint256) = i + 1""];
20->8;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()""];
21->1;
}
",1,0,0,0,"onlyController();require(bool,string)(tokens.length <= 100,tokens.length too long);;;;;;i < tokens.length;;_token = tokens[i];_token == 0x0;balance = address(this).balance;token = ERC20Token(_token);balance > 0;msg.sender.transfer(balance);;;balance = token.balanceOf(address(this));token.transfer(msg.sender,balance);ClaimedTokens(_token,msg.sender,balance);i ++"
./0x4c129783b42833220ad57d48548f871189009d3f_ext.sol,HoQuBurner.burn,312,315,"TMP_90(bool) = HIGH_LEVEL_CALL, dest:token(HoQuToken), function:transferFrom, arguments:['msg.sender', 'this', '_tokens']  ,INTERNAL_CALL, HoQuBurner.burnFrom(address,uint256)(msg.sender,_tokens)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
token.transferFrom(msg.sender,this,_tokens)

IRs:
TMP_90(bool) = HIGH_LEVEL_CALL, dest:token(HoQuToken), function:transferFrom, arguments:['msg.sender', 'this', '_tokens']  ""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
burnFrom(msg.sender,_tokens)

IRs:
INTERNAL_CALL, HoQuBurner.burnFrom(address,uint256)(msg.sender,_tokens)""];
}
",1,0,0,0,"token.transferFrom(msg.sender,this,_tokens);burnFrom(msg.sender,_tokens)"
./0x46c9f93c3249c430c6ca19f02240ef9e038ba9d1_ext.sol,Escapable.escapeHatch,161,177,"REF_2(bool) -> escapeBlacklist[_token],TMP_30(bool) = REF_2 == False,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),TMP_32(bool) = _token == 0,CONDITION TMP_32,REF_3(uint256) = SOLIDITY_CALL balance(address)(this),balance(uint256) := REF_3([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B94689A0>]),Transfer dest:escapeHatchDestination value:balance,Emit EscapeHatchCalled(_token,balance),TMP_35 = CONVERT _token to ERC20,token(ERC20) := TMP_35(ERC20),TMP_36(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_36(uint256),TMP_37(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['escapeHatchDestination', 'balance']  ,Emit EscapeHatchCalled(_token,balance),MODIFIER_CALL, Escapable.onlyEscapeHatchCallerOrOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->13;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(escapeBlacklist[_token] == false)

IRs:
REF_2(bool) -> escapeBlacklist[_token]
TMP_30(bool) = REF_2 == False
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_token == 0x0

IRs:
TMP_32(bool) = _token == 0
CONDITION TMP_32""];
3->4[label=""True""];
3->8[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balance = this.balance

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
balance(uint256) := REF_3([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B94689A0>])""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
escapeHatchDestination.transfer(balance)

IRs:
Transfer dest:escapeHatchDestination value:balance""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
EscapeHatchCalled(_token,balance)

IRs:
Emit EscapeHatchCalled(_token,balance)""];
6->7;
7[label=""Node Type: RETURN 7
""];
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
token = ERC20(_token)

IRs:
TMP_35 = CONVERT _token to ERC20
token(ERC20) := TMP_35(ERC20)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_36(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_36(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
token.transfer(escapeHatchDestination,balance)

IRs:
TMP_37(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['escapeHatchDestination', 'balance']  ""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
EscapeHatchCalled(_token,balance)

IRs:
Emit EscapeHatchCalled(_token,balance)""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
onlyEscapeHatchCallerOrOwner()

IRs:
MODIFIER_CALL, Escapable.onlyEscapeHatchCallerOrOwner()()""];
13->1;
}
",1,0,1,0,"onlyEscapeHatchCallerOrOwner();require(bool)(escapeBlacklist[_token] == false);;_token == 0x0;balance = this.balance;;escapeHatchDestination.transfer(balance);EscapeHatchCalled(_token,balance);;token = ERC20(_token);balance = token.balanceOf(this);token.transfer(escapeHatchDestination,balance);EscapeHatchCalled(_token,balance)"
./0x6d0a44fb6a416da6efe1c192560be1bccd01f6be_ext.sol,PresaleMarket.createAuction,338,350,"TMP_124 = CONVERT artworkContract to address,TMP_125(bool) = msg.sender == TMP_124,TMP_126(None) = SOLIDITY_CALL require(bool)(TMP_125),INTERNAL_CALL, PresaleMarket._takeOwnership(address,uint256)(_originalOwner,_artworkId),REF_31(address) -> auction.seller,REF_31(address) (->auction) := _originalOwner(address),REF_32(uint256) -> auction.price,REF_32(uint256) (->auction) := _price(uint256),INTERNAL_CALL, PresaleMarket._createAuction(uint256,PresaleMarket.Auction)(_artworkId,auction),MODIFIER_CALL, PausableSimple.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == address(artworkContract))

IRs:
TMP_124 = CONVERT artworkContract to address
TMP_125(bool) = msg.sender == TMP_124
TMP_126(None) = SOLIDITY_CALL require(bool)(TMP_125)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_takeOwnership(_originalOwner,_artworkId)

IRs:
INTERNAL_CALL, PresaleMarket._takeOwnership(address,uint256)(_originalOwner,_artworkId)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
auction.seller = _originalOwner

IRs:
REF_31(address) -> auction.seller
REF_31(address) (->auction) := _originalOwner(address)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
auction.price = _price

IRs:
REF_32(uint256) -> auction.price
REF_32(uint256) (->auction) := _price(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
_createAuction(_artworkId,auction)

IRs:
INTERNAL_CALL, PresaleMarket._createAuction(uint256,PresaleMarket.Auction)(_artworkId,auction)""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, PausableSimple.whenNotPaused()()""];
7->1;
}
",1,0,0,0,"whenNotPaused();require(bool)(msg.sender == address(artworkContract));_takeOwnership(_originalOwner,_artworkId);;auction.seller = _originalOwner;auction.price = _price;_createAuction(_artworkId,auction)"
./0xc739ae9ba934f937636a2ebaaf1ecdf04e11ef2f_ext.sol,NXTGToken.refundTokens,355,361,"TMP_111(bool) = msg.sender == owner,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113 = CONVERT this to address,TMP_114(bool) = _token != TMP_113,TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114),TMP_116 = CONVERT _token to AbstractToken,token(AbstractToken) := TMP_116(AbstractToken),TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ,Emit RefundTokens(_token,_refund,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_111(bool) = msg.sender == owner
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_113 = CONVERT this to address
TMP_114(bool) = _token != TMP_113
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
token = AbstractToken(_token)

IRs:
TMP_116 = CONVERT _token to AbstractToken
token(AbstractToken) := TMP_116(AbstractToken)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(_refund,_value)

IRs:
TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RefundTokens(_token,_refund,_value)

IRs:
Emit RefundTokens(_token,_refund,_value)""];
}
",1,0,0,0,"require(bool)(msg.sender == owner);require(bool)(_token != address(this));token = AbstractToken(_token);token.transfer(_refund,_value);RefundTokens(_token,_refund,_value)"
./0xc4ab0f59c4d8bb15e237906a06a736d965a2c390_ext.sol,AirdropLibraToken.airdropTokens,316,343,"TMP_93(bool) = amount > 0,TMP_94(None) = SOLIDITY_CALL require(bool)(TMP_93),TMP_95(uint256) = HIGH_LEVEL_CALL, dest:token(LibraToken), function:balanceOf, arguments:['this']  ,lbaBalance(uint256) := TMP_95(uint256),TMP_96(bool) = lbaBalance >= amount,TMP_97(None) = SOLIDITY_CALL require(bool)(TMP_96),TMP_98(bool) = HIGH_LEVEL_CALL, dest:token(LibraToken), function:transfer, arguments:['_recipient', 'amount']  ,TMP_99(None) = SOLIDITY_CALL require(bool)(TMP_98),REF_98 -> LENGTH airdropDoneList,TMP_101(uint256) := REF_98(uint256),TMP_102(uint256) = TMP_101 + 1,REF_98(uint256) (->airdropDoneList) := TMP_102(uint256),REF_99(address) -> airdropDoneList[TMP_101],REF_99(address) (->airdropDoneList) := _recipient(address),airDropAmountThisAddr(uint256) := 0(uint256),REF_100(uint256) -> airdropDoneAmountMap[_recipient],TMP_103(bool) = REF_100 > 0,CONDITION TMP_103,REF_101(uint256) -> airdropDoneAmountMap[_recipient],TMP_104(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_101', 'amount'] ,airDropAmountThisAddr(uint256) := TMP_104(uint256),airDropAmountThisAddr(uint256) := amount(uint256),REF_103(uint256) -> airdropDoneAmountMap[_recipient],REF_103(uint256) (->airdropDoneAmountMap) := airDropAmountThisAddr(uint256),TMP_105(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['distributedTotal', 'amount'] ,distributedTotal(uint256) := TMP_105(uint256),Emit Airdrop(_recipient,amount),MODIFIER_CALL, AirdropLibraToken.onlyOwnerOrAdmin()(),MODIFIER_CALL, AirdropLibraToken.onlyWhileAirdropPhaseOpen()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_93(bool) = amount > 0
TMP_94(None) = SOLIDITY_CALL require(bool)(TMP_93)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
lbaBalance = token.balanceOf(this)

IRs:
TMP_95(uint256) = HIGH_LEVEL_CALL, dest:token(LibraToken), function:balanceOf, arguments:['this']  
lbaBalance(uint256) := TMP_95(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(lbaBalance >= amount)

IRs:
TMP_96(bool) = lbaBalance >= amount
TMP_97(None) = SOLIDITY_CALL require(bool)(TMP_96)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(token.transfer(_recipient,amount))

IRs:
TMP_98(bool) = HIGH_LEVEL_CALL, dest:token(LibraToken), function:transfer, arguments:['_recipient', 'amount']  
TMP_99(None) = SOLIDITY_CALL require(bool)(TMP_98)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
airdropDoneList.push(_recipient)

IRs:
REF_98 -> LENGTH airdropDoneList
TMP_101(uint256) := REF_98(uint256)
TMP_102(uint256) = TMP_101 + 1
REF_98(uint256) (->airdropDoneList) := TMP_102(uint256)
REF_99(address) -> airdropDoneList[TMP_101]
REF_99(address) (->airdropDoneList) := _recipient(address)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
airDropAmountThisAddr = 0

IRs:
airDropAmountThisAddr(uint256) := 0(uint256)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
airdropDoneAmountMap[_recipient] > 0

IRs:
REF_100(uint256) -> airdropDoneAmountMap[_recipient]
TMP_103(bool) = REF_100 > 0
CONDITION TMP_103""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
airDropAmountThisAddr = airdropDoneAmountMap[_recipient].add(amount)

IRs:
REF_101(uint256) -> airdropDoneAmountMap[_recipient]
TMP_104(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_101', 'amount'] 
airDropAmountThisAddr(uint256) := TMP_104(uint256)""];
8->10;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
airDropAmountThisAddr = amount

IRs:
airDropAmountThisAddr(uint256) := amount(uint256)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
airdropDoneAmountMap[_recipient] = airDropAmountThisAddr

IRs:
REF_103(uint256) -> airdropDoneAmountMap[_recipient]
REF_103(uint256) (->airdropDoneAmountMap) := airDropAmountThisAddr(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
distributedTotal = distributedTotal.add(amount)

IRs:
TMP_105(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['distributedTotal', 'amount'] 
distributedTotal(uint256) := TMP_105(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
Airdrop(_recipient,amount)

IRs:
Emit Airdrop(_recipient,amount)""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
onlyOwnerOrAdmin()

IRs:
MODIFIER_CALL, AirdropLibraToken.onlyOwnerOrAdmin()()""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
onlyWhileAirdropPhaseOpen()

IRs:
MODIFIER_CALL, AirdropLibraToken.onlyWhileAirdropPhaseOpen()()""];
15->1;
}
",1,0,0,0,"onlyOwnerOrAdmin();require(bool)(amount > 0);lbaBalance = token.balanceOf(this);require(bool)(lbaBalance >= amount);require(bool)(token.transfer(_recipient,amount));airdropDoneList.push(_recipient);airDropAmountThisAddr = 0;airdropDoneAmountMap[_recipient] > 0;airDropAmountThisAddr = airdropDoneAmountMap[_recipient].add(amount);airDropAmountThisAddr = amount;;airdropDoneAmountMap[_recipient] = airDropAmountThisAddr;distributedTotal = distributedTotal.add(amount);Airdrop(_recipient,amount);onlyWhileAirdropPhaseOpen()"
./0x17f68886d00845867c154c912b4ccc506ec92fc7_ext.sol,DelegatedShareholderAssociation.newProposal,271,298,"TMP_49 = CONVERT tokenLocker to address,TMP_50(bool) = beneficiary != TMP_49,TMP_51(None) = SOLIDITY_CALL require(bool)(TMP_50),REF_21 -> LENGTH proposals,TMP_52(uint256) := REF_21(uint256),REF_21(-> proposals) = REF_21 + 1,proposalID(uint256) := TMP_52(uint256),REF_22(DelegatedShareholderAssociation.Proposal) -> proposals[proposalID],p(DelegatedShareholderAssociation.Proposal) := REF_22(DelegatedShareholderAssociation.Proposal),REF_23(address) -> p.recipient,REF_23(address) (->p) := beneficiary(address),REF_24(uint256) -> p.amount,REF_24(uint256) (->p) := weiAmount(uint256),REF_25(bytes) -> p.metadataHash,REF_25(bytes) (->p) := jobMetadataHash(bytes),REF_26(bytes32) -> p.proposalHash,TMP_53(bytes32) = SOLIDITY_CALL keccak256()(beneficiary,weiAmount,transactionBytecode),REF_26(bytes32) (->p) := TMP_53(bytes32),REF_27(uint256) -> p.timeCreated,REF_27(uint256) (->p) := now(uint256),REF_28(uint256) -> p.votingDeadline,TMP_54(uint256) = debatingPeriodInMinutes * 60,TMP_55(uint256) = now + TMP_54,REF_28(uint256) (->p) := TMP_55(uint256),REF_29(bool) -> p.finalized,REF_29(bool) (->p) := False(bool),REF_30(bool) -> p.proposalPassed,REF_30(bool) (->p) := False(bool),REF_31(uint256) -> p.numberOfVotes,REF_31(uint256) (->p) := 0(uint256),Emit ProposalAdded(proposalID,beneficiary,weiAmount,jobMetadataHash),TMP_57(uint256) = proposalID + 1,numProposals(uint256) := TMP_57(uint256),RETURN proposalID,MODIFIER_CALL, DelegatedShareholderAssociation.onlyBoardMembers()(),MODIFIER_CALL, DelegatedShareholderAssociation.notSelf()(),RETURN proposalID","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->16;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != address(tokenLocker))

IRs:
TMP_49 = CONVERT tokenLocker to address
TMP_50(bool) = beneficiary != TMP_49
TMP_51(None) = SOLIDITY_CALL require(bool)(TMP_50)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
proposalID = proposals.length ++

IRs:
REF_21 -> LENGTH proposals
TMP_52(uint256) := REF_21(uint256)
REF_21(-> proposals) = REF_21 + 1
proposalID(uint256) := TMP_52(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
p = proposals[proposalID]

IRs:
REF_22(DelegatedShareholderAssociation.Proposal) -> proposals[proposalID]
p(DelegatedShareholderAssociation.Proposal) := REF_22(DelegatedShareholderAssociation.Proposal)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
p.recipient = beneficiary

IRs:
REF_23(address) -> p.recipient
REF_23(address) (->p) := beneficiary(address)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
p.amount = weiAmount

IRs:
REF_24(uint256) -> p.amount
REF_24(uint256) (->p) := weiAmount(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
p.metadataHash = jobMetadataHash

IRs:
REF_25(bytes) -> p.metadataHash
REF_25(bytes) (->p) := jobMetadataHash(bytes)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
p.proposalHash = keccak256()(beneficiary,weiAmount,transactionBytecode)

IRs:
REF_26(bytes32) -> p.proposalHash
TMP_53(bytes32) = SOLIDITY_CALL keccak256()(beneficiary,weiAmount,transactionBytecode)
REF_26(bytes32) (->p) := TMP_53(bytes32)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
p.timeCreated = now

IRs:
REF_27(uint256) -> p.timeCreated
REF_27(uint256) (->p) := now(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
p.votingDeadline = now + debatingPeriodInMinutes * 60

IRs:
REF_28(uint256) -> p.votingDeadline
TMP_54(uint256) = debatingPeriodInMinutes * 60
TMP_55(uint256) = now + TMP_54
REF_28(uint256) (->p) := TMP_55(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
p.finalized = false

IRs:
REF_29(bool) -> p.finalized
REF_29(bool) (->p) := False(bool)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
p.proposalPassed = false

IRs:
REF_30(bool) -> p.proposalPassed
REF_30(bool) (->p) := False(bool)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
p.numberOfVotes = 0

IRs:
REF_31(uint256) -> p.numberOfVotes
REF_31(uint256) (->p) := 0(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
ProposalAdded(proposalID,beneficiary,weiAmount,jobMetadataHash)

IRs:
Emit ProposalAdded(proposalID,beneficiary,weiAmount,jobMetadataHash)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
numProposals = proposalID + 1

IRs:
TMP_57(uint256) = proposalID + 1
numProposals(uint256) := TMP_57(uint256)""];
14->15;
15[label=""Node Type: RETURN 15

EXPRESSION:
proposalID

IRs:
RETURN proposalID""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
onlyBoardMembers()

IRs:
MODIFIER_CALL, DelegatedShareholderAssociation.onlyBoardMembers()()""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
notSelf()

IRs:
MODIFIER_CALL, DelegatedShareholderAssociation.notSelf()()""];
17->1;
18[label=""Node Type: RETURN 18

EXPRESSION:
proposalID

IRs:
RETURN proposalID""];
}
",1,0,0,0,"onlyBoardMembers();require(bool)(beneficiary != address(tokenLocker));proposalID = proposals.length ++;p = proposals[proposalID];p.recipient = beneficiary;p.amount = weiAmount;p.metadataHash = jobMetadataHash;p.proposalHash = keccak256()(beneficiary,weiAmount,transactionBytecode);p.timeCreated = now;p.votingDeadline = now + debatingPeriodInMinutes * 60;p.finalized = false;p.proposalPassed = false;p.numberOfVotes = 0;ProposalAdded(proposalID,beneficiary,weiAmount,jobMetadataHash);numProposals = proposalID + 1;proposalID;notSelf();proposalID"
./0x0f1da17b33df90c078fd2fb4b9011a64af3c67a6_ext.sol,ERC20.transfer,85,85,"INTERNAL_CALL, ERC20._transfer(address,address,uint256)(msg.sender,to,value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_transfer(msg.sender,to,value)

IRs:
INTERNAL_CALL, ERC20._transfer(address,address,uint256)(msg.sender,to,value)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,"_transfer(msg.sender,to,value);true"
./0x53c347888c54519820249ee629b30316f3b79974_ext.sol,UCToken.refundTokens,355,361,"TMP_111(bool) = msg.sender == owner,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113 = CONVERT this to address,TMP_114(bool) = _token != TMP_113,TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114),TMP_116 = CONVERT _token to AbstractToken,token(AbstractToken) := TMP_116(AbstractToken),TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ,Emit RefundTokens(_token,_refund,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_111(bool) = msg.sender == owner
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_113 = CONVERT this to address
TMP_114(bool) = _token != TMP_113
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
token = AbstractToken(_token)

IRs:
TMP_116 = CONVERT _token to AbstractToken
token(AbstractToken) := TMP_116(AbstractToken)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(_refund,_value)

IRs:
TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RefundTokens(_token,_refund,_value)

IRs:
Emit RefundTokens(_token,_refund,_value)""];
}
",1,0,0,0,"require(bool)(msg.sender == owner);require(bool)(_token != address(this));token = AbstractToken(_token);token.transfer(_refund,_value);RefundTokens(_token,_refund,_value)"
./0x6e82aabffe24f275ad3f703aca922dd4d8f86168_ext.sol,BatchTransfer.withdraw,151,157,"TMP_53 = CONVERT _token to ERC20,token(ERC20) := TMP_53(ERC20),TMP_54(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  ,tokenBalanceOfContract(uint256) := TMP_54(uint256),TMP_55 = CONVERT 0 to address,TMP_56(bool) = _receiver != TMP_55,TMP_57(bool) = tokenBalanceOfContract > 0,TMP_58(bool) = TMP_56 && TMP_57,TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58),TMP_60(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['_receiver', 'tokenBalanceOfContract']  ,TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60),Emit Withdraw(_receiver,_token,tokenBalanceOfContract),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
token = ERC20(_token)

IRs:
TMP_53 = CONVERT _token to ERC20
token(ERC20) := TMP_53(ERC20)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
tokenBalanceOfContract = token.balanceOf(this)

IRs:
TMP_54(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  
tokenBalanceOfContract(uint256) := TMP_54(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_receiver != address(0) && tokenBalanceOfContract > 0)

IRs:
TMP_55 = CONVERT 0 to address
TMP_56(bool) = _receiver != TMP_55
TMP_57(bool) = tokenBalanceOfContract > 0
TMP_58(bool) = TMP_56 && TMP_57
TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(token.transfer(_receiver,tokenBalanceOfContract))

IRs:
TMP_60(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['_receiver', 'tokenBalanceOfContract']  
TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Withdraw(_receiver,_token,tokenBalanceOfContract)

IRs:
Emit Withdraw(_receiver,_token,tokenBalanceOfContract)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",1,0,0,0,"onlyOwner();token = ERC20(_token);tokenBalanceOfContract = token.balanceOf(this);require(bool)(_receiver != address(0) && tokenBalanceOfContract > 0);require(bool)(token.transfer(_receiver,tokenBalanceOfContract));Withdraw(_receiver,_token,tokenBalanceOfContract)"
./0x1fab9d2996767db0ca6af12fd92c1f2aab2675a0_ext.sol,JackpotHolding.ownerSetControllerAddress,2417,2422,"TMP_645 = CONVERT _controllerAddress to ZethrBankrollControllerInterface,controller(ZethrBankrollControllerInterface) := TMP_645(ZethrBankrollControllerInterface),MODIFIER_CALL, JackpotHolding.ownerOnly()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
controller = ZethrBankrollControllerInterface(_controllerAddress)

IRs:
TMP_645 = CONVERT _controllerAddress to ZethrBankrollControllerInterface
controller(ZethrBankrollControllerInterface) := TMP_645(ZethrBankrollControllerInterface)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ownerOnly()

IRs:
MODIFIER_CALL, JackpotHolding.ownerOnly()()""];
2->1;
}
",1,0,0,0,ownerOnly();controller = ZethrBankrollControllerInterface(_controllerAddress)
./0xb4a3fb248d39370c1f8081b73fa7098167c8142b_ext.sol,DSValue.void,466,468,"has(bool) := False(bool),MODIFIER_CALL, DSNote.note()(),MODIFIER_CALL, DSAuth.auth()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
has = false

IRs:
has(bool) := False(bool)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
note()

IRs:
MODIFIER_CALL, DSNote.note()()""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
3->1;
}
",1,0,0,0,note();has = false;auth()
./0x01c627181089b6e10ee8316ec08516b3df7c4845_ext.sol,BrickCrowdsale.finalize,676,684,"TMP_411 = UnaryType.BANG isFinalized ,TMP_412(None) = SOLIDITY_CALL require(bool)(TMP_411),INTERNAL_CALL, BrickCrowdsale.finalization()(),Emit BrickFinalized(),isFinalized(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isFinalized)

IRs:
TMP_411 = UnaryType.BANG isFinalized 
TMP_412(None) = SOLIDITY_CALL require(bool)(TMP_411)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
finalization()

IRs:
INTERNAL_CALL, BrickCrowdsale.finalization()()""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
BrickFinalized()

IRs:
Emit BrickFinalized()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
isFinalized = true

IRs:
isFinalized(bool) := True(bool)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",1,0,0,0,onlyOwner();require(bool)(! isFinalized);finalization();BrickFinalized();isFinalized = true
./0xf244176246168f24e3187f7288edbca29267739b_ext.sol,HavvenEscrow.appendVestingEntry,2155,2176,"TMP_887(bool) = now < time,TMP_888(None) = SOLIDITY_CALL require(bool)(TMP_887),TMP_889(bool) = quantity != 0,TMP_890(None) = SOLIDITY_CALL require(bool)(TMP_889),TMP_891(uint256) = INTERNAL_CALL, SafeDecimalMath.safeAdd(uint256,uint256)(totalVestedBalance,quantity),totalVestedBalance(uint256) := TMP_891(uint256),TMP_892(uint256) = HIGH_LEVEL_CALL, dest:havven(Havven), function:balanceOf, arguments:['this']  ,TMP_893(bool) = totalVestedBalance <= TMP_892,TMP_894(None) = SOLIDITY_CALL require(bool)(TMP_893),REF_161(uint256[2][]) -> vestingSchedules[account],REF_162 -> LENGTH REF_161,TMP_895(bool) = REF_162 == 0,CONDITION TMP_895,REF_163(uint256) -> totalVestedAccountBalance[account],REF_163(uint256) (->totalVestedAccountBalance) := quantity(uint256),TMP_896(uint256) = INTERNAL_CALL, HavvenEscrow.numVestingEntries(address)(account),TMP_897(uint256) = TMP_896 - 1,TMP_898(uint256) = INTERNAL_CALL, HavvenEscrow.getVestingTime(address,uint256)(account,TMP_897),TMP_899(bool) = TMP_898 < time,TMP_900(None) = SOLIDITY_CALL require(bool)(TMP_899),REF_164(uint256) -> totalVestedAccountBalance[account],REF_165(uint256) -> totalVestedAccountBalance[account],TMP_901(uint256) = INTERNAL_CALL, SafeDecimalMath.safeAdd(uint256,uint256)(REF_165,quantity),REF_164(uint256) (->totalVestedAccountBalance) := TMP_901(uint256),REF_166(uint256[2][]) -> vestingSchedules[account],REF_168 -> LENGTH REF_166,TMP_903(uint256) := REF_168(uint256),TMP_904(uint256) = TMP_903 + 1,REF_168(uint256) (->vestingSchedules) := TMP_904(uint256),REF_169(uint256[2]) -> REF_166[TMP_903],TMP_905(uint256[2]) = ['time(uint256)', 'quantity(uint256)'],REF_169(uint256[2]) (->vestingSchedules) := TMP_905(uint256[2]),MODIFIER_CALL, Owned.onlyOwner()(),MODIFIER_CALL, LimitedSetup.setupFunction()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now < time)

IRs:
TMP_887(bool) = now < time
TMP_888(None) = SOLIDITY_CALL require(bool)(TMP_887)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(quantity != 0)

IRs:
TMP_889(bool) = quantity != 0
TMP_890(None) = SOLIDITY_CALL require(bool)(TMP_889)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalVestedBalance = safeAdd(totalVestedBalance,quantity)

IRs:
TMP_891(uint256) = INTERNAL_CALL, SafeDecimalMath.safeAdd(uint256,uint256)(totalVestedBalance,quantity)
totalVestedBalance(uint256) := TMP_891(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(totalVestedBalance <= havven.balanceOf(this))

IRs:
TMP_892(uint256) = HIGH_LEVEL_CALL, dest:havven(Havven), function:balanceOf, arguments:['this']  
TMP_893(bool) = totalVestedBalance <= TMP_892
TMP_894(None) = SOLIDITY_CALL require(bool)(TMP_893)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
vestingSchedules[account].length == 0

IRs:
REF_161(uint256[2][]) -> vestingSchedules[account]
REF_162 -> LENGTH REF_161
TMP_895(bool) = REF_162 == 0
CONDITION TMP_895""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
totalVestedAccountBalance[account] = quantity

IRs:
REF_163(uint256) -> totalVestedAccountBalance[account]
REF_163(uint256) (->totalVestedAccountBalance) := quantity(uint256)""];
6->9;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(getVestingTime(account,numVestingEntries(account) - 1) < time)

IRs:
TMP_896(uint256) = INTERNAL_CALL, HavvenEscrow.numVestingEntries(address)(account)
TMP_897(uint256) = TMP_896 - 1
TMP_898(uint256) = INTERNAL_CALL, HavvenEscrow.getVestingTime(address,uint256)(account,TMP_897)
TMP_899(bool) = TMP_898 < time
TMP_900(None) = SOLIDITY_CALL require(bool)(TMP_899)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
totalVestedAccountBalance[account] = safeAdd(totalVestedAccountBalance[account],quantity)

IRs:
REF_164(uint256) -> totalVestedAccountBalance[account]
REF_165(uint256) -> totalVestedAccountBalance[account]
TMP_901(uint256) = INTERNAL_CALL, SafeDecimalMath.safeAdd(uint256,uint256)(REF_165,quantity)
REF_164(uint256) (->totalVestedAccountBalance) := TMP_901(uint256)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
vestingSchedules[account].push((time,quantity))

IRs:
REF_166(uint256[2][]) -> vestingSchedules[account]
REF_168 -> LENGTH REF_166
TMP_903(uint256) := REF_168(uint256)
TMP_904(uint256) = TMP_903 + 1
REF_168(uint256) (->vestingSchedules) := TMP_904(uint256)
REF_169(uint256[2]) -> REF_166[TMP_903]
TMP_905(uint256[2]) = ['time(uint256)', 'quantity(uint256)']
REF_169(uint256[2]) (->vestingSchedules) := TMP_905(uint256[2])""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
setupFunction()

IRs:
MODIFIER_CALL, LimitedSetup.setupFunction()()""];
12->1;
}
",1,0,0,0,"onlyOwner();require(bool)(now < time);require(bool)(quantity != 0);totalVestedBalance = safeAdd(totalVestedBalance,quantity);require(bool)(totalVestedBalance <= havven.balanceOf(this));vestingSchedules[account].length == 0;totalVestedAccountBalance[account] = quantity;require(bool)(getVestingTime(account,numVestingEntries(account) - 1) < time);;totalVestedAccountBalance[account] = safeAdd(totalVestedAccountBalance[account],quantity);vestingSchedules[account].push((time,quantity));setupFunction()"
./0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0_ext.sol,Play0x_LottoBall.placeTokenBet,438,458,"REF_31(Play0x_LottoBall.PlaceParam) -> PlaceParam.RotateTime,TMP_118 = CONVERT REF_31 to uint8,REF_32(uint256) -> placParameter[TMP_118],TMP_119(bool) = REF_32 != 0,TMP_120(None) = SOLIDITY_CALL require(bool)(TMP_119),TMP_121(bool) = block.number <= _commitLastBlock,TMP_122(None) = SOLIDITY_CALL require(bool)(TMP_121),REF_33(Play0x_LottoBall.PlaceParam) -> PlaceParam.secretSignerIndex,TMP_123 = CONVERT REF_33 to uint8,REF_34(uint256) -> placParameter[TMP_123],REF_35(address) -> secretSignerList[REF_34],TMP_124(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(_signatureHash,v,r,s),TMP_125(bool) = REF_35 == TMP_124,TMP_126(None) = SOLIDITY_CALL require(bool)(TMP_125),REF_36(Play0x_LottoBall.Bet) -> bets[_commit],bet(Play0x_LottoBall.Bet) := REF_36(Play0x_LottoBall.Bet),REF_37(address) -> bet.gambler,TMP_127 = CONVERT 0 to address,TMP_128(bool) = REF_37 == TMP_127,TMP_129(None) = SOLIDITY_CALL require(bool)(TMP_128),REF_39(Play0x_LottoBall.PlaceParam) -> PlaceParam.possibleWinAmount,TMP_130 = CONVERT REF_39 to uint8,REF_40(uint256) -> placParameter[TMP_130],TMP_131 = CONVERT REF_40 to uint256,TMP_132(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['lockedTokenInBets', 'TMP_131'] ,lockedTokenInBets(uint256) := TMP_132(uint256),REF_41(Play0x_LottoBall.PlaceParam) -> PlaceParam.possibleWinAmount,TMP_133 = CONVERT REF_41 to uint8,REF_42(uint256) -> placParameter[TMP_133],TMP_134 = CONVERT REF_42 to uint256,TMP_135(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_amount', 'maxTokenProfit'] ,TMP_136(bool) = TMP_134 <= TMP_135,TMP_137(None) = SOLIDITY_CALL require(bool)(TMP_136),TMP_138 = CONVERT ERC20ContractAddres to ERC20,TMP_139 = CONVERT this to address,TMP_140(uint256) = HIGH_LEVEL_CALL, dest:TMP_138(ERC20), function:balanceOf, arguments:['TMP_139']  ,TMP_141(bool) = lockedTokenInBets <= TMP_140,TMP_142(None) = SOLIDITY_CALL require(bool)(TMP_141),REF_45(uint256) -> bet.amount,REF_45(uint256) (->bet) := _amount(uint256),REF_46(uint40) -> bet.placeBlockNumber,TMP_143 = CONVERT block.number to uint40,REF_46(uint40) (->bet) := TMP_143(uint40),REF_47(address) -> bet.gambler,REF_47(address) (->bet) := _playerAddress(address),REF_48(Play0x_LottoBall.PlaceParam) -> PlaceParam.RotateTime,TMP_144 = CONVERT REF_48 to uint8,REF_49(uint256) -> placParameter[TMP_144],TMP_145 = CONVERT REF_49 to uint8,Emit PlaceBetLog(_playerAddress,_amount,TMP_145)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(placParameter[uint8(PlaceParam.RotateTime)] != 0)

IRs:
REF_31(Play0x_LottoBall.PlaceParam) -> PlaceParam.RotateTime
TMP_118 = CONVERT REF_31 to uint8
REF_32(uint256) -> placParameter[TMP_118]
TMP_119(bool) = REF_32 != 0
TMP_120(None) = SOLIDITY_CALL require(bool)(TMP_119)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(block.number <= _commitLastBlock)

IRs:
TMP_121(bool) = block.number <= _commitLastBlock
TMP_122(None) = SOLIDITY_CALL require(bool)(TMP_121)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(secretSignerList[placParameter[uint8(PlaceParam.secretSignerIndex)]] == ecrecover(bytes32,uint8,bytes32,bytes32)(_signatureHash,v,r,s))

IRs:
REF_33(Play0x_LottoBall.PlaceParam) -> PlaceParam.secretSignerIndex
TMP_123 = CONVERT REF_33 to uint8
REF_34(uint256) -> placParameter[TMP_123]
REF_35(address) -> secretSignerList[REF_34]
TMP_124(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(_signatureHash,v,r,s)
TMP_125(bool) = REF_35 == TMP_124
TMP_126(None) = SOLIDITY_CALL require(bool)(TMP_125)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bet = bets[_commit]

IRs:
REF_36(Play0x_LottoBall.Bet) -> bets[_commit]
bet(Play0x_LottoBall.Bet) := REF_36(Play0x_LottoBall.Bet)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(bet.gambler == address(0))

IRs:
REF_37(address) -> bet.gambler
TMP_127 = CONVERT 0 to address
TMP_128(bool) = REF_37 == TMP_127
TMP_129(None) = SOLIDITY_CALL require(bool)(TMP_128)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
lockedTokenInBets = lockedTokenInBets.add(uint256(placParameter[uint8(PlaceParam.possibleWinAmount)]))

IRs:
REF_39(Play0x_LottoBall.PlaceParam) -> PlaceParam.possibleWinAmount
TMP_130 = CONVERT REF_39 to uint8
REF_40(uint256) -> placParameter[TMP_130]
TMP_131 = CONVERT REF_40 to uint256
TMP_132(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['lockedTokenInBets', 'TMP_131'] 
lockedTokenInBets(uint256) := TMP_132(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(uint256(placParameter[uint8(PlaceParam.possibleWinAmount)]) <= _amount.add(maxTokenProfit))

IRs:
REF_41(Play0x_LottoBall.PlaceParam) -> PlaceParam.possibleWinAmount
TMP_133 = CONVERT REF_41 to uint8
REF_42(uint256) -> placParameter[TMP_133]
TMP_134 = CONVERT REF_42 to uint256
TMP_135(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_amount', 'maxTokenProfit'] 
TMP_136(bool) = TMP_134 <= TMP_135
TMP_137(None) = SOLIDITY_CALL require(bool)(TMP_136)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(lockedTokenInBets <= ERC20(ERC20ContractAddres).balanceOf(address(this)))

IRs:
TMP_138 = CONVERT ERC20ContractAddres to ERC20
TMP_139 = CONVERT this to address
TMP_140(uint256) = HIGH_LEVEL_CALL, dest:TMP_138(ERC20), function:balanceOf, arguments:['TMP_139']  
TMP_141(bool) = lockedTokenInBets <= TMP_140
TMP_142(None) = SOLIDITY_CALL require(bool)(TMP_141)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
bet.amount = _amount

IRs:
REF_45(uint256) -> bet.amount
REF_45(uint256) (->bet) := _amount(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
bet.placeBlockNumber = uint40(block.number)

IRs:
REF_46(uint40) -> bet.placeBlockNumber
TMP_143 = CONVERT block.number to uint40
REF_46(uint40) (->bet) := TMP_143(uint40)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
bet.gambler = _playerAddress

IRs:
REF_47(address) -> bet.gambler
REF_47(address) (->bet) := _playerAddress(address)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
PlaceBetLog(_playerAddress,_amount,uint8(placParameter[uint8(PlaceParam.RotateTime)]))

IRs:
REF_48(Play0x_LottoBall.PlaceParam) -> PlaceParam.RotateTime
TMP_144 = CONVERT REF_48 to uint8
REF_49(uint256) -> placParameter[TMP_144]
TMP_145 = CONVERT REF_49 to uint8
Emit PlaceBetLog(_playerAddress,_amount,TMP_145)""];
}
",1,0,0,0,"require(bool)(placParameter[uint8(PlaceParam.RotateTime)] != 0);require(bool)(block.number <= _commitLastBlock);require(bool)(secretSignerList[placParameter[uint8(PlaceParam.secretSignerIndex)]] == ecrecover(bytes32,uint8,bytes32,bytes32)(_signatureHash,v,r,s));bet = bets[_commit];require(bool)(bet.gambler == address(0));lockedTokenInBets = lockedTokenInBets.add(uint256(placParameter[uint8(PlaceParam.possibleWinAmount)]));require(bool)(uint256(placParameter[uint8(PlaceParam.possibleWinAmount)]) <= _amount.add(maxTokenProfit));require(bool)(lockedTokenInBets <= ERC20(ERC20ContractAddres).balanceOf(address(this)));bet.amount = _amount;bet.placeBlockNumber = uint40(block.number);bet.gambler = _playerAddress;PlaceBetLog(_playerAddress,_amount,uint8(placParameter[uint8(PlaceParam.RotateTime)]))"
./0xb4a448387403554616eb5b50aa4c48f75243a015_ext.sol,Mobius2Dv2.init,1329,1353,"TMP_1078 = UnaryType.BANG initialized ,TMP_1079(None) = SOLIDITY_CALL require(bool,string)(TMP_1078,Already initialized!),TMP_1080(uint256) = HIGH_LEVEL_CALL, dest:lastVersion(LastVersion), function:latestRoundID, arguments:[]  ,_rID(uint256) := TMP_1080(uint256),TMP_1081(uint256) = 1 + _rID,previousRounds(uint256) := TMP_1081(uint256),TUPLE_10(address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool) = HIGH_LEVEL_CALL, dest:lastVersion(LastVersion), function:roundInfo, arguments:['_rID']  ,_invested(uint256)= UNPACK TUPLE_10 index: 5 ,finalized(bool)= UNPACK TUPLE_10 index: 9 ,TMP_1082(None) = SOLIDITY_CALL require(bool,string)(finalized,Last round is still not finalized!),TUPLE_11(uint256,uint256,uint256,uint256) = HIGH_LEVEL_CALL, dest:lastVersion(LastVersion), function:totalsInfo, arguments:[]  ,_returns(uint256)= UNPACK TUPLE_11 index: 0 ,_shares(uint256)= UNPACK TUPLE_11 index: 1 ,_dividends(uint256)= UNPACK TUPLE_11 index: 2 ,_jackpots(uint256)= UNPACK TUPLE_11 index: 3 ,totalSharesSold(uint256) := _shares(uint256),totalRevenue(uint256) := _invested(uint256),totalEarningsGenerated(uint256) := _returns(uint256),totalDividendsPaid(uint256) := _dividends(uint256),totalJackpotsWon(uint256) := _jackpots(uint256),initialized(bool) := True(bool),MODIFIER_CALL, DSAuth.auth()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->19;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(! initialized,Already initialized!)

IRs:
TMP_1078 = UnaryType.BANG initialized 
TMP_1079(None) = SOLIDITY_CALL require(bool,string)(TMP_1078,Already initialized!)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
_rID = lastVersion.latestRoundID()

IRs:
TMP_1080(uint256) = HIGH_LEVEL_CALL, dest:lastVersion(LastVersion), function:latestRoundID, arguments:[]  
_rID(uint256) := TMP_1080(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
previousRounds = 1 + _rID

IRs:
TMP_1081(uint256) = 1 + _rID
previousRounds(uint256) := TMP_1081(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5
""];
5->6;
6[label=""Node Type: NEW VARIABLE 6
""];
6->7;
7[label=""Node Type: NEW VARIABLE 7
""];
7->8;
8[label=""Node Type: NEW VARIABLE 8
""];
8->9;
9[label=""Node Type: NEW VARIABLE 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
(None,None,None,None,None,_invested,None,None,None,finalized) = lastVersion.roundInfo(_rID)

IRs:
TUPLE_10(address,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,bool) = HIGH_LEVEL_CALL, dest:lastVersion(LastVersion), function:roundInfo, arguments:['_rID']  
_invested(uint256)= UNPACK TUPLE_10 index: 5 
finalized(bool)= UNPACK TUPLE_10 index: 9 ""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
require(bool,string)(finalized,Last round is still not finalized!)

IRs:
TMP_1082(None) = SOLIDITY_CALL require(bool,string)(finalized,Last round is still not finalized!)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
(_returns,_shares,_dividends,_jackpots) = lastVersion.totalsInfo()

IRs:
TUPLE_11(uint256,uint256,uint256,uint256) = HIGH_LEVEL_CALL, dest:lastVersion(LastVersion), function:totalsInfo, arguments:[]  
_returns(uint256)= UNPACK TUPLE_11 index: 0 
_shares(uint256)= UNPACK TUPLE_11 index: 1 
_dividends(uint256)= UNPACK TUPLE_11 index: 2 
_jackpots(uint256)= UNPACK TUPLE_11 index: 3 ""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
totalSharesSold = _shares

IRs:
totalSharesSold(uint256) := _shares(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
totalRevenue = _invested

IRs:
totalRevenue(uint256) := _invested(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
totalEarningsGenerated = _returns

IRs:
totalEarningsGenerated(uint256) := _returns(uint256)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
totalDividendsPaid = _dividends

IRs:
totalDividendsPaid(uint256) := _dividends(uint256)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
totalJackpotsWon = _jackpots

IRs:
totalJackpotsWon(uint256) := _jackpots(uint256)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
initialized = true

IRs:
initialized(bool) := True(bool)""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
19->1;
}
",1,0,0,0,"auth();require(bool,string)(! initialized,Already initialized!);_rID = lastVersion.latestRoundID();previousRounds = 1 + _rID;;;;;;;(None,None,None,None,None,_invested,None,None,None,finalized) = lastVersion.roundInfo(_rID);require(bool,string)(finalized,Last round is still not finalized!);(_returns,_shares,_dividends,_jackpots) = lastVersion.totalsInfo();totalSharesSold = _shares;totalRevenue = _invested;totalEarningsGenerated = _returns;totalDividendsPaid = _dividends;totalJackpotsWon = _jackpots;initialized = true"
./0x402fa04ccd2c2568e1a53dbecec1bd572303663a_ext.sol,HarborPresale.finalize,468,475,"TMP_209 = UnaryType.BANG isFinalized ,TMP_210(None) = SOLIDITY_CALL require(bool)(TMP_209),TMP_211(bool) = INTERNAL_CALL, HarborPresale.hasEnded()(),TMP_212(None) = SOLIDITY_CALL require(bool)(TMP_211),INTERNAL_CALL, HarborPresale.finalization()(),Emit Finalized(),isFinalized(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, Haltable.stopInEmergency()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isFinalized)

IRs:
TMP_209 = UnaryType.BANG isFinalized 
TMP_210(None) = SOLIDITY_CALL require(bool)(TMP_209)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(hasEnded())

IRs:
TMP_211(bool) = INTERNAL_CALL, HarborPresale.hasEnded()()
TMP_212(None) = SOLIDITY_CALL require(bool)(TMP_211)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
finalization()

IRs:
INTERNAL_CALL, HarborPresale.finalization()()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Finalized()

IRs:
Emit Finalized()""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
isFinalized = true

IRs:
isFinalized(bool) := True(bool)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
stopInEmergency()

IRs:
MODIFIER_CALL, Haltable.stopInEmergency()()""];
7->1;
}
",1,0,0,0,onlyOwner();require(bool)(! isFinalized);require(bool)(hasEnded());finalization();Finalized();isFinalized = true;stopInEmergency()
./0xc3e43d422d5e6f94315622d96a96058689c52ec8_ext.sol,BitNauticCrowdsaleTokenDistributor.grantContributorTokens,136,146,"REF_1(bool) -> hasClaimedTokens[contributor],TMP_30 = UnaryType.BANG REF_1 ,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),TMP_32(uint256) = HIGH_LEVEL_CALL, dest:crowdsale(BitNauticCrowdsale), function:creditOf, arguments:['contributor']  ,TMP_33(bool) = TMP_32 > 0,TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33),TMP_35(bool) = HIGH_LEVEL_CALL, dest:whitelist(BitNauticWhitelist), function:AMLWhitelisted, arguments:['contributor']  ,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),TMP_37(bool) = now > ICOEndTime,TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37),TMP_39(uint256) = HIGH_LEVEL_CALL, dest:crowdsale(BitNauticCrowdsale), function:creditOf, arguments:['contributor']  ,TMP_40(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['contributor', 'TMP_39']  ,TMP_41(None) = SOLIDITY_CALL assert(bool)(TMP_40),REF_6(bool) -> hasClaimedTokens[contributor],REF_6(bool) (->hasClaimedTokens) := True(bool),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! hasClaimedTokens[contributor])

IRs:
REF_1(bool) -> hasClaimedTokens[contributor]
TMP_30 = UnaryType.BANG REF_1 
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(crowdsale.creditOf(contributor) > 0)

IRs:
TMP_32(uint256) = HIGH_LEVEL_CALL, dest:crowdsale(BitNauticCrowdsale), function:creditOf, arguments:['contributor']  
TMP_33(bool) = TMP_32 > 0
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(whitelist.AMLWhitelisted(contributor))

IRs:
TMP_35(bool) = HIGH_LEVEL_CALL, dest:whitelist(BitNauticWhitelist), function:AMLWhitelisted, arguments:['contributor']  
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(now > ICOEndTime)

IRs:
TMP_37(bool) = now > ICOEndTime
TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(token.mint(contributor,crowdsale.creditOf(contributor)))

IRs:
TMP_39(uint256) = HIGH_LEVEL_CALL, dest:crowdsale(BitNauticCrowdsale), function:creditOf, arguments:['contributor']  
TMP_40(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['contributor', 'TMP_39']  
TMP_41(None) = SOLIDITY_CALL assert(bool)(TMP_40)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
hasClaimedTokens[contributor] = true

IRs:
REF_6(bool) -> hasClaimedTokens[contributor]
REF_6(bool) (->hasClaimedTokens) := True(bool)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,"require(bool)(! hasClaimedTokens[contributor]);require(bool)(crowdsale.creditOf(contributor) > 0);require(bool)(whitelist.AMLWhitelisted(contributor));require(bool)(now > ICOEndTime);assert(bool)(token.mint(contributor,crowdsale.creditOf(contributor)));hasClaimedTokens[contributor] = true;true"
./0xc3e43d422d5e6f94315622d96a96058689c52ec8_ext.sol,BitNauticCrowdsaleTokenDistributor.grantAdvisorsTokens,166,171,"TMP_52(bool) = advisorSupply > 0,TMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52),TMP_54(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['beneficiary', 'advisorSupply']  ,advisorSupply(uint256) := 0(uint256),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(advisorSupply > 0)

IRs:
TMP_52(bool) = advisorSupply > 0
TMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
token.mint(beneficiary,advisorSupply)

IRs:
TMP_54(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['beneficiary', 'advisorSupply']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
advisorSupply = 0

IRs:
advisorSupply(uint256) := 0(uint256)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->1;
}
",1,0,0,0,"onlyOwner();require(bool)(advisorSupply > 0);token.mint(beneficiary,advisorSupply);advisorSupply = 0"
./0xc4aad17558fa95c8937d0856b2dad74c1a7a095f_ext.sol,AgiCrowdsale.finalize,482,501,"TMP_245 = UnaryType.BANG isFinalized ,TMP_246(None) = SOLIDITY_CALL require(bool)(TMP_245),TMP_247(bool) = INTERNAL_CALL, AgiCrowdsale.hasEnded()(),TMP_248(None) = SOLIDITY_CALL require(bool)(TMP_247),TMP_249(bool) = INTERNAL_CALL, AgiCrowdsale.goalReached()(),CONDITION TMP_249,HIGH_LEVEL_CALL, dest:vault(RefundVault), function:close, arguments:[]  ,HIGH_LEVEL_CALL, dest:token(SingularityNetToken), function:unpause, arguments:[]  ,HIGH_LEVEL_CALL, dest:token(SingularityNetToken), function:transferOwnership, arguments:['owner']  ,HIGH_LEVEL_CALL, dest:vault(RefundVault), function:enableRefunds, arguments:[]  ,isFinalized(bool) := True(bool),Emit Finalized(),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isFinalized)

IRs:
TMP_245 = UnaryType.BANG isFinalized 
TMP_246(None) = SOLIDITY_CALL require(bool)(TMP_245)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(hasEnded())

IRs:
TMP_247(bool) = INTERNAL_CALL, AgiCrowdsale.hasEnded()()
TMP_248(None) = SOLIDITY_CALL require(bool)(TMP_247)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
goalReached()

IRs:
TMP_249(bool) = INTERNAL_CALL, AgiCrowdsale.goalReached()()
CONDITION TMP_249""];
3->4[label=""True""];
3->7[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
vault.close()

IRs:
HIGH_LEVEL_CALL, dest:vault(RefundVault), function:close, arguments:[]  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
token.unpause()

IRs:
HIGH_LEVEL_CALL, dest:token(SingularityNetToken), function:unpause, arguments:[]  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
token.transferOwnership(owner)

IRs:
HIGH_LEVEL_CALL, dest:token(SingularityNetToken), function:transferOwnership, arguments:['owner']  ""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
vault.enableRefunds()

IRs:
HIGH_LEVEL_CALL, dest:vault(RefundVault), function:enableRefunds, arguments:[]  ""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
isFinalized = true

IRs:
isFinalized(bool) := True(bool)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Finalized()

IRs:
Emit Finalized()""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
11->1;
}
",1,0,0,0,onlyOwner();require(bool)(! isFinalized);require(bool)(hasEnded());goalReached();vault.close();vault.enableRefunds();token.unpause();token.transferOwnership(owner);;isFinalized = true;Finalized()
./0x6dbb4e882f967432fc0f9200e9ca577c916d8a68_ext.sol,Bussiness.removePrice,109,114,"TMP_32(address) = HIGH_LEVEL_CALL, dest:erc721Address(IERC721), function:ownerOf, arguments:['tokenId']  ,TMP_33(bool) = TMP_32 == msg.sender,TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33),REF_15(Bussiness.Price) -> prices[tokenId],REF_16(uint256) -> REF_15.fee,TMP_35(bool) = REF_16 > 0,CONDITION TMP_35,REF_18(Bussiness.Price) -> prices[tokenId],REF_19(uint256) -> REF_18.fee,Transfer dest:msg.sender value:REF_19,INTERNAL_CALL, Bussiness.resetPrice(uint256)(tokenId),REF_20(Bussiness.Price) -> prices[tokenId],REF_21(uint256) -> REF_20.price,RETURN REF_21","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(erc721Address.ownerOf(tokenId) == msg.sender)

IRs:
TMP_32(address) = HIGH_LEVEL_CALL, dest:erc721Address(IERC721), function:ownerOf, arguments:['tokenId']  
TMP_33(bool) = TMP_32 == msg.sender
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
prices[tokenId].fee > 0

IRs:
REF_15(Bussiness.Price) -> prices[tokenId]
REF_16(uint256) -> REF_15.fee
TMP_35(bool) = REF_16 > 0
CONDITION TMP_35""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(prices[tokenId].fee)

IRs:
REF_18(Bussiness.Price) -> prices[tokenId]
REF_19(uint256) -> REF_18.fee
Transfer dest:msg.sender value:REF_19""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
resetPrice(tokenId)

IRs:
INTERNAL_CALL, Bussiness.resetPrice(uint256)(tokenId)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
prices[tokenId].price

IRs:
REF_20(Bussiness.Price) -> prices[tokenId]
REF_21(uint256) -> REF_20.price
RETURN REF_21""];
}
",1,0,1,0,require(bool)(erc721Address.ownerOf(tokenId) == msg.sender);prices[tokenId].fee > 0;msg.sender.transfer(prices[tokenId].fee);;resetPrice(tokenId);prices[tokenId].price
./0x74a12ce6eebc23c3f785c0ab50d02228587dcc1a_ext.sol,FrozenToken.approveAndCall,575,587,"TMP_380 = CONVERT _spender to ITokenRecipient,spender(ITokenRecipient) := TMP_380(ITokenRecipient),TMP_381(bool) = INTERNAL_CALL, FrozenToken.approve(address,uint256)(_spender,_value),CONDITION TMP_381,HIGH_LEVEL_CALL, dest:spender(ITokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,Emit ApproveAndCall(_spender,_value,_extraData),RETURN True,MODIFIER_CALL, Utils.validAddress(address)(_spender),MODIFIER_CALL, Utils.greaterThanZero(uint256)(_value),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = ITokenRecipient(_spender)

IRs:
TMP_380 = CONVERT _spender to ITokenRecipient
spender(ITokenRecipient) := TMP_380(ITokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_381(bool) = INTERNAL_CALL, FrozenToken.approve(address,uint256)(_spender,_value)
CONDITION TMP_381""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(ITokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ApproveAndCall(_spender,_value,_extraData)

IRs:
Emit ApproveAndCall(_spender,_value,_extraData)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: END_IF 6
""];
6->9;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
validAddress(_spender)

IRs:
MODIFIER_CALL, Utils.validAddress(address)(_spender)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
greaterThanZero(_value)

IRs:
MODIFIER_CALL, Utils.greaterThanZero(uint256)(_value)""];
8->1;
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,0,0,0,"validAddress(_spender);spender = ITokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;ApproveAndCall(_spender,_value,_extraData);true;success;greaterThanZero(_value)"
./0x3fd2371b53f2db38765220c90f2ffd4ddbe8afd1_ext.sol,MonethaUsersClaimHandler.changeOwnerOfMonethaUsersClaimStorage,202,206,"HIGH_LEVEL_CALL, dest:storageContract(MonethaUsersClaimStorage), function:transferOwnership, arguments:['_newOwner']  ,Emit StorageContractOwnerChanged(_newOwner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
storageContract.transferOwnership(_newOwner)

IRs:
HIGH_LEVEL_CALL, dest:storageContract(MonethaUsersClaimStorage), function:transferOwnership, arguments:['_newOwner']  ""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
StorageContractOwnerChanged(_newOwner)

IRs:
Emit StorageContractOwnerChanged(_newOwner)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
3->1;
}
",1,0,0,0,onlyOwner();storageContract.transferOwnership(_newOwner);StorageContractOwnerChanged(_newOwner)
./0x4bc78f6619991b029b867b6d88d39c196332aba3_ext.sol,AlgoDEX.withdraw,212,217,"REF_51(mapping(address => uint256)) -> tokens[0],REF_52(uint256) -> REF_51[msg.sender],TMP_93(bool) = REF_52 < amount,CONDITION TMP_93,TMP_94(None) = SOLIDITY_CALL revert()(),REF_53(mapping(address => uint256)) -> tokens[0],REF_54(uint256) -> REF_53[msg.sender],REF_55(mapping(address => uint256)) -> tokens[0],REF_56(uint256) -> REF_55[msg.sender],TMP_95(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_56,amount),REF_54(uint256) (->tokens) := TMP_95(uint256),TMP_97(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:amount ,TMP_98 = UnaryType.BANG TMP_97 ,CONDITION TMP_98,TMP_99(None) = SOLIDITY_CALL revert()(),REF_59(mapping(address => uint256)) -> tokens[0],REF_60(uint256) -> REF_59[msg.sender],Emit Withdraw(0,msg.sender,amount,REF_60)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
tokens[0][msg.sender] < amount

IRs:
REF_51(mapping(address => uint256)) -> tokens[0]
REF_52(uint256) -> REF_51[msg.sender]
TMP_93(bool) = REF_52 < amount
CONDITION TMP_93""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_94(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
tokens[0][msg.sender] = safeSub(tokens[0][msg.sender],amount)

IRs:
REF_53(mapping(address => uint256)) -> tokens[0]
REF_54(uint256) -> REF_53[msg.sender]
REF_55(mapping(address => uint256)) -> tokens[0]
REF_56(uint256) -> REF_55[msg.sender]
TMP_95(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_56,amount)
REF_54(uint256) (->tokens) := TMP_95(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
! msg.sender.call.value(amount)()

IRs:
TMP_97(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:amount 
TMP_98 = UnaryType.BANG TMP_97 
CONDITION TMP_98""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
revert()()

IRs:
TMP_99(None) = SOLIDITY_CALL revert()()""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Withdraw(0,msg.sender,amount,tokens[0][msg.sender])

IRs:
REF_59(mapping(address => uint256)) -> tokens[0]
REF_60(uint256) -> REF_59[msg.sender]
Emit Withdraw(0,msg.sender,amount,REF_60)""];
}
",1,0,0,0,"tokens[0][msg.sender] < amount;revert()();;tokens[0][msg.sender] = safeSub(tokens[0][msg.sender],amount);! msg.sender.call.value(amount)();revert()();;Withdraw(0,msg.sender,amount,tokens[0][msg.sender])"
./0x2716d9189adc5ee2fb35f193b79b5578c3d7bcda_ext.sol,EthereumLegitAirDrop.airDrop,120,131,"TMP_26(bool) = amount > 0,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),i(uint256) := 0(uint256),REF_18 -> LENGTH recipients,TMP_28(bool) = i < REF_18,CONDITION TMP_28,REF_20(address) -> recipients[i],HIGH_LEVEL_CALL, dest:myToken(token), function:transfer, arguments:['REF_20', 'amount']  ,REF_21(address) -> recipients[i],Emit TokenDrop(REF_21,amount),TMP_31(uint256) := i(uint256),i(uint256) = i + 1,REF_22 -> LENGTH recipients,numDrops(uint256) = numDrops + REF_22,REF_23 -> LENGTH recipients,TMP_32(uint256) = REF_23 * amount,dropAmount(uint256) = dropAmount + TMP_32,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_26(bool) = amount > 0
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
3->9;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < recipients.length

IRs:
REF_18 -> LENGTH recipients
TMP_28(bool) = i < REF_18
CONDITION TMP_28""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
myToken.transfer(recipients[i],amount)

IRs:
REF_20(address) -> recipients[i]
HIGH_LEVEL_CALL, dest:myToken(token), function:transfer, arguments:['REF_20', 'amount']  ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
TokenDrop(recipients[i],amount)

IRs:
REF_21(address) -> recipients[i]
Emit TokenDrop(REF_21,amount)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_31(uint256) := i(uint256)
i(uint256) = i + 1""];
8->5;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
numDrops += recipients.length

IRs:
REF_22 -> LENGTH recipients
numDrops(uint256) = numDrops + REF_22""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
dropAmount += recipients.length * amount

IRs:
REF_23 -> LENGTH recipients
TMP_32(uint256) = REF_23 * amount
dropAmount(uint256) = dropAmount + TMP_32""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
11->1;
}
",1,0,0,0,"onlyOwner();require(bool)(amount > 0);i = 0;;i < recipients.length;;numDrops += recipients.length;myToken.transfer(recipients[i],amount);TokenDrop(recipients[i],amount);i ++;dropAmount += recipients.length * amount"
./0x4c13184721de2d1b47a8875775ba3ce0b2e00ee0_ext.sol,SharkPool.claim,297,314,"TMP_78(bool) = HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:checkWinning, arguments:['_blockNumber']  ,TMP_79(None) = SOLIDITY_CALL require(bool)(TMP_78),TMP_80(uint256) = HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:balanceOf, arguments:['this']  ,initial_balance(uint256) := TMP_80(uint256),HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:claim, arguments:['_blockNumber', 'this']  ,TMP_82(uint256) = HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_82(uint256),REF_53(uint256) -> attempts[_blockNumber],total_attempt(uint256) := REF_53(uint256),TMP_83(uint256) = balance - initial_balance,INTERNAL_CALL, SharkPool.distribute_reward(uint256,uint256)(total_attempt,TMP_83),TMP_85(uint256) = claimed_blocks + 1,claimed_blocks(uint256) := TMP_85(uint256),MODIFIER_CALL, ReentrancyGuard.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(base_contract.checkWinning(_blockNumber))

IRs:
TMP_78(bool) = HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:checkWinning, arguments:['_blockNumber']  
TMP_79(None) = SOLIDITY_CALL require(bool)(TMP_78)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
initial_balance = base_contract.balanceOf(this)

IRs:
TMP_80(uint256) = HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:balanceOf, arguments:['this']  
initial_balance(uint256) := TMP_80(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
base_contract.claim(_blockNumber,this)

IRs:
HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:claim, arguments:['_blockNumber', 'this']  ""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
balance = base_contract.balanceOf(this)

IRs:
TMP_82(uint256) = HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_82(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
total_attempt = attempts[_blockNumber]

IRs:
REF_53(uint256) -> attempts[_blockNumber]
total_attempt(uint256) := REF_53(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
distribute_reward(total_attempt,balance - initial_balance)

IRs:
TMP_83(uint256) = balance - initial_balance
INTERNAL_CALL, SharkPool.distribute_reward(uint256,uint256)(total_attempt,TMP_83)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
claimed_blocks = claimed_blocks + 1

IRs:
TMP_85(uint256) = claimed_blocks + 1
claimed_blocks(uint256) := TMP_85(uint256)""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, ReentrancyGuard.nonReentrant()()""];
8->1;
}
",1,0,0,0,"nonReentrant();require(bool)(base_contract.checkWinning(_blockNumber));initial_balance = base_contract.balanceOf(this);base_contract.claim(_blockNumber,this);balance = base_contract.balanceOf(this);total_attempt = attempts[_blockNumber];distribute_reward(total_attempt,balance - initial_balance);claimed_blocks = claimed_blocks + 1"
./0xeda8b016efa8b1161208cf041cd86972eee0f31e_ext.sol,BonusFinalizeAgent.finalizeCrowdsale,1348,1364,"TMP_651 = CONVERT crowdsale to address,TMP_652(bool) = msg.sender == TMP_651,TMP_653(None) = SOLIDITY_CALL require(bool)(TMP_652),TMP_654(uint256) = HIGH_LEVEL_CALL, dest:token(CrowdsaleToken), function:totalSupply, arguments:[]  ,tokenSupply(uint256) := TMP_654(uint256),TMP_655(uint256) = INTERNAL_CALL, SafeMathLib.safeSub(uint256,uint256)(tokenCap,tokenSupply),allocatedTokens(uint256) := TMP_655(uint256),TMP_656(bool) = allocatedTokens > 0,CONDITION TMP_656,TMP_657(bool) = HIGH_LEVEL_CALL, dest:token(CrowdsaleToken), function:mint, arguments:['walletAddress', 'allocatedTokens']  ,HIGH_LEVEL_CALL, dest:token(CrowdsaleToken), function:releaseTokenTransfer, arguments:[]  ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == address(crowdsale))

IRs:
TMP_651 = CONVERT crowdsale to address
TMP_652(bool) = msg.sender == TMP_651
TMP_653(None) = SOLIDITY_CALL require(bool)(TMP_652)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
tokenSupply = token.totalSupply()

IRs:
TMP_654(uint256) = HIGH_LEVEL_CALL, dest:token(CrowdsaleToken), function:totalSupply, arguments:[]  
tokenSupply(uint256) := TMP_654(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
allocatedTokens = safeSub(tokenCap,tokenSupply)

IRs:
TMP_655(uint256) = INTERNAL_CALL, SafeMathLib.safeSub(uint256,uint256)(tokenCap,tokenSupply)
allocatedTokens(uint256) := TMP_655(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
allocatedTokens > 0

IRs:
TMP_656(bool) = allocatedTokens > 0
CONDITION TMP_656""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
token.mint(walletAddress,allocatedTokens)

IRs:
TMP_657(bool) = HIGH_LEVEL_CALL, dest:token(CrowdsaleToken), function:mint, arguments:['walletAddress', 'allocatedTokens']  ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.releaseTokenTransfer()

IRs:
HIGH_LEVEL_CALL, dest:token(CrowdsaleToken), function:releaseTokenTransfer, arguments:[]  ""];
}
",1,0,0,0,"require(bool)(msg.sender == address(crowdsale));tokenSupply = token.totalSupply();allocatedTokens = safeSub(tokenCap,tokenSupply);allocatedTokens > 0;token.mint(walletAddress,allocatedTokens);;token.releaseTokenTransfer()"
./0x269b4c23ddab676e2869ae72cd6ae4f24bdfea45_ext.sol,IRBPreCrowdsale.buyTokens,611,632,"TMP_197 = CONVERT 0 to address,TMP_198(bool) = beneficiary != TMP_197,TMP_199(None) = SOLIDITY_CALL require(bool)(TMP_198),TMP_200(bool) = INTERNAL_CALL, IRBPreCrowdsale.validPurchase(uint256)(msg.value),TMP_201(None) = SOLIDITY_CALL require(bool)(TMP_200),weiAmount(uint256) := msg.value(uint256),buyer(address) := msg.sender(address),TMP_202(uint256) = INTERNAL_CALL, IRBPreCrowdsale.convertAmountToTokens(uint256)(weiAmount),tokens(uint256) := TMP_202(uint256),TMP_203(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] ,weiRaised(uint256) := TMP_203(uint256),TMP_204(address) = HIGH_LEVEL_CALL, dest:token(IRBToken), function:preCrowdsaleTokensWallet, arguments:[]  ,TMP_205(bool) = HIGH_LEVEL_CALL, dest:token(IRBToken), function:transferFrom, arguments:['TMP_204', 'beneficiary', 'tokens']  ,TMP_206 = UnaryType.BANG TMP_205 ,CONDITION TMP_206,TMP_207(None) = SOLIDITY_CALL revert()(),Emit TokenPurchase(buyer,beneficiary,weiAmount,tokens),HIGH_LEVEL_CALL, dest:vault(IRBPreRefundVault), function:deposit, arguments:['buyer'] value:weiAmount ,MODIFIER_CALL, Pausable.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != address(0))

IRs:
TMP_197 = CONVERT 0 to address
TMP_198(bool) = beneficiary != TMP_197
TMP_199(None) = SOLIDITY_CALL require(bool)(TMP_198)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(validPurchase(msg.value))

IRs:
TMP_200(bool) = INTERNAL_CALL, IRBPreCrowdsale.validPurchase(uint256)(msg.value)
TMP_201(None) = SOLIDITY_CALL require(bool)(TMP_200)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
buyer = msg.sender

IRs:
buyer(address) := msg.sender(address)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
tokens = convertAmountToTokens(weiAmount)

IRs:
TMP_202(uint256) = INTERNAL_CALL, IRBPreCrowdsale.convertAmountToTokens(uint256)(weiAmount)
tokens(uint256) := TMP_202(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_203(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_203(uint256)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
! token.transferFrom(token.preCrowdsaleTokensWallet(),beneficiary,tokens)

IRs:
TMP_204(address) = HIGH_LEVEL_CALL, dest:token(IRBToken), function:preCrowdsaleTokensWallet, arguments:[]  
TMP_205(bool) = HIGH_LEVEL_CALL, dest:token(IRBToken), function:transferFrom, arguments:['TMP_204', 'beneficiary', 'tokens']  
TMP_206 = UnaryType.BANG TMP_205 
CONDITION TMP_206""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
revert()()

IRs:
TMP_207(None) = SOLIDITY_CALL revert()()""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
TokenPurchase(buyer,beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(buyer,beneficiary,weiAmount,tokens)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
vault.deposit.value(weiAmount)(buyer)

IRs:
HIGH_LEVEL_CALL, dest:vault(IRBPreRefundVault), function:deposit, arguments:['buyer'] value:weiAmount ""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
12->1;
}
",1,0,0,0,"whenNotPaused();require(bool)(beneficiary != address(0));require(bool)(validPurchase(msg.value));weiAmount = msg.value;buyer = msg.sender;tokens = convertAmountToTokens(weiAmount);weiRaised = weiRaised.add(weiAmount);! token.transferFrom(token.preCrowdsaleTokensWallet(),beneficiary,tokens);revert()();;TokenPurchase(buyer,beneficiary,weiAmount,tokens);vault.deposit.value(weiAmount)(buyer)"
./0x32f1c992a32376fa0f723aecaa247119d3f7f8bd_ext.sol,Zethroll.ownerSetBankroll,351,357,"TMP_79(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:approve, arguments:['ZethrBankroll', '0']  ,ZethrBankroll(address) := newBankroll(address),TMP_80(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:approve, arguments:['newBankroll', 'MAX_INT']  ,MODIFIER_CALL, Zethroll.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ZTHTKN.approve(ZethrBankroll,0)

IRs:
TMP_79(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:approve, arguments:['ZethrBankroll', '0']  ""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ZethrBankroll = newBankroll

IRs:
ZethrBankroll(address) := newBankroll(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ZTHTKN.approve(newBankroll,MAX_INT)

IRs:
TMP_80(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:approve, arguments:['newBankroll', 'MAX_INT']  ""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Zethroll.onlyOwner()()""];
4->1;
}
",1,0,0,0,"onlyOwner();ZTHTKN.approve(ZethrBankroll,0);ZethrBankroll = newBankroll;ZTHTKN.approve(newBankroll,MAX_INT)"
./0x70f90f6688cb26b6a924a2155b3d9529a0b36a90_ext.sol,Crowdsale.buyTokens,442,470,"TMP_233(bool) = block.timestamp >= phaze1Start,TMP_234(bool) = block.timestamp <= phaze1End,TMP_235(bool) = TMP_233 && TMP_234,TMP_236(bool) = tokensSold <= 40000000000000000000000000,TMP_237(bool) = TMP_235 && TMP_236,TMP_238(bool) = weiRaised <= hardcap,TMP_239(bool) = TMP_237 && TMP_238,CONDITION TMP_239,rate(uint256) := rate1(uint256),TMP_240(bool) = block.timestamp >= phaze2Start,TMP_241(bool) = block.timestamp <= phaze2End,TMP_242(bool) = TMP_240 && TMP_241,TMP_243(bool) = tokensSold <= hardcap,TMP_244(bool) = TMP_242 && TMP_243,CONDITION TMP_244,rate(uint256) := rate2(uint256),TMP_245(bool) = block.timestamp >= phaze3Start,TMP_246(bool) = block.timestamp <= phaze3End,TMP_247(bool) = TMP_245 && TMP_246,TMP_248(bool) = tokensSold <= hardcap,TMP_249(bool) = TMP_247 && TMP_248,CONDITION TMP_249,rate(uint256) := rate3(uint256),rate(uint256) := 10000000000000000000(uint256),weiAmount(uint256) := msg.value(uint256),TMP_250(uint256) = INTERNAL_CALL, Crowdsale._getTokenAmount(uint256)(weiAmount),tokens(uint256) := TMP_250(uint256),TMP_251(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokensSold', 'tokens'] ,tokensSold(uint256) := TMP_251(uint256),TMP_252(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] ,weiRaised(uint256) := TMP_252(uint256),INTERNAL_CALL, Crowdsale._processPurchase(address,uint256)(_beneficiary,tokens),Emit TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens,block.number),INTERNAL_CALL, Crowdsale._updatePurchasingState(address,uint256)(_beneficiary,weiAmount),INTERNAL_CALL, Crowdsale._forwardFunds()(),INTERNAL_CALL, Crowdsale._postValidatePurchase(address,uint256)(_beneficiary,weiAmount),MODIFIER_CALL, Pausable.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->20;
1[label=""Node Type: IF 1

EXPRESSION:
(block.timestamp >= phaze1Start) && (block.timestamp <= phaze1End) && (tokensSold <= 40000000000000000000000000) && (weiRaised <= hardcap)

IRs:
TMP_233(bool) = block.timestamp >= phaze1Start
TMP_234(bool) = block.timestamp <= phaze1End
TMP_235(bool) = TMP_233 && TMP_234
TMP_236(bool) = tokensSold <= 40000000000000000000000000
TMP_237(bool) = TMP_235 && TMP_236
TMP_238(bool) = weiRaised <= hardcap
TMP_239(bool) = TMP_237 && TMP_238
CONDITION TMP_239""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
rate = rate1

IRs:
rate(uint256) := rate1(uint256)""];
2->10;
3[label=""Node Type: IF 3

EXPRESSION:
(block.timestamp >= phaze2Start) && (block.timestamp <= phaze2End) && (tokensSold <= hardcap)

IRs:
TMP_240(bool) = block.timestamp >= phaze2Start
TMP_241(bool) = block.timestamp <= phaze2End
TMP_242(bool) = TMP_240 && TMP_241
TMP_243(bool) = tokensSold <= hardcap
TMP_244(bool) = TMP_242 && TMP_243
CONDITION TMP_244""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
rate = rate2

IRs:
rate(uint256) := rate2(uint256)""];
4->9;
5[label=""Node Type: IF 5

EXPRESSION:
(block.timestamp >= phaze3Start) && (block.timestamp <= phaze3End) && (tokensSold <= hardcap)

IRs:
TMP_245(bool) = block.timestamp >= phaze3Start
TMP_246(bool) = block.timestamp <= phaze3End
TMP_247(bool) = TMP_245 && TMP_246
TMP_248(bool) = tokensSold <= hardcap
TMP_249(bool) = TMP_247 && TMP_248
CONDITION TMP_249""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
rate = rate3

IRs:
rate(uint256) := rate3(uint256)""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
rate = 10000000000000000000

IRs:
rate(uint256) := 10000000000000000000(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)""];
11->12;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
tokens = _getTokenAmount(weiAmount)

IRs:
TMP_250(uint256) = INTERNAL_CALL, Crowdsale._getTokenAmount(uint256)(weiAmount)
tokens(uint256) := TMP_250(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
tokensSold = tokensSold.add(tokens)

IRs:
TMP_251(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokensSold', 'tokens'] 
tokensSold(uint256) := TMP_251(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_252(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_252(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
_processPurchase(_beneficiary,tokens)

IRs:
INTERNAL_CALL, Crowdsale._processPurchase(address,uint256)(_beneficiary,tokens)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens,block.number)

IRs:
Emit TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens,block.number)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
_updatePurchasingState(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._updatePurchasingState(address,uint256)(_beneficiary,weiAmount)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
_forwardFunds()

IRs:
INTERNAL_CALL, Crowdsale._forwardFunds()()""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
_postValidatePurchase(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._postValidatePurchase(address,uint256)(_beneficiary,weiAmount)""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
20->1;
}
",1,0,0,0,"whenNotPaused();(block.timestamp >= phaze1Start) && (block.timestamp <= phaze1End) && (tokensSold <= 40000000000000000000000000) && (weiRaised <= hardcap);rate = rate1;(block.timestamp >= phaze2Start) && (block.timestamp <= phaze2End) && (tokensSold <= hardcap);;rate = rate2;(block.timestamp >= phaze3Start) && (block.timestamp <= phaze3End) && (tokensSold <= hardcap);;rate = rate3;rate = 10000000000000000000;;weiAmount = msg.value;tokens = _getTokenAmount(weiAmount);tokensSold = tokensSold.add(tokens);weiRaised = weiRaised.add(weiAmount);_processPurchase(_beneficiary,tokens);TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens,block.number);_updatePurchasingState(_beneficiary,weiAmount);_forwardFunds();_postValidatePurchase(_beneficiary,weiAmount)"
./0x28f1135e43e61ebf303c8f1f9beef4f6a00dcb34_ext.sol,XC.unlock,767,781,"REF_163(uint8) -> admin.status,TMP_186(bool) = REF_163 == 1,REF_164(uint8) -> admin.status,TMP_187(bool) = REF_164 == 3,TMP_188(bool) = TMP_186 || TMP_187,TMP_189(None) = SOLIDITY_CALL require(bool)(TMP_188),TMP_190(bool) = HIGH_LEVEL_CALL, dest:xcPlugin(XCPlugin), function:getStatus, arguments:[]  ,TMP_191(None) = SOLIDITY_CALL require(bool)(TMP_190),TMP_192(bool) = value > 0,TMP_193(None) = SOLIDITY_CALL require(bool)(TMP_192),TUPLE_0(bool,bool) = HIGH_LEVEL_CALL, dest:xcPlugin(XCPlugin), function:verifyProposal, arguments:['fromAccount', 'toAccount', 'value', 'txid']  ,complete(bool)= UNPACK TUPLE_0 index: 0 ,verify(bool)= UNPACK TUPLE_0 index: 1 ,TMP_194 = UnaryType.BANG complete ,TMP_195(bool) = verify && TMP_194,TMP_196(None) = SOLIDITY_CALL require(bool)(TMP_195),TMP_197(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_197(uint256),TMP_198(bool) = balance >= value,TMP_199(None) = SOLIDITY_CALL require(bool)(TMP_198),TMP_200(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transfer, arguments:['toAccount', 'value']  ,TMP_201(None) = SOLIDITY_CALL require(bool)(TMP_200),TMP_202(bool) = HIGH_LEVEL_CALL, dest:xcPlugin(XCPlugin), function:commitProposal, arguments:['txid']  ,TMP_203(None) = SOLIDITY_CALL require(bool)(TMP_202),TMP_204(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['lockBalance', 'value'] ,lockBalance(uint256) := TMP_204(uint256),TMP_205(bytes32) = HIGH_LEVEL_CALL, dest:xcPlugin(XCPlugin), function:getTrustPlatform, arguments:[]  ,TMP_206 = CONVERT value to bytes32,TMP_207(bytes32) = HIGH_LEVEL_CALL, dest:xcPlugin(XCPlugin), function:getTokenSymbol, arguments:[]  ,Emit Unlock(txid,TMP_205,fromAccount,TMP_206,TMP_207),MODIFIER_CALL, XC.nonzeroAddress(address)(toAccount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(admin.status == 1 || admin.status == 3)

IRs:
REF_163(uint8) -> admin.status
TMP_186(bool) = REF_163 == 1
REF_164(uint8) -> admin.status
TMP_187(bool) = REF_164 == 3
TMP_188(bool) = TMP_186 || TMP_187
TMP_189(None) = SOLIDITY_CALL require(bool)(TMP_188)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(xcPlugin.getStatus())

IRs:
TMP_190(bool) = HIGH_LEVEL_CALL, dest:xcPlugin(XCPlugin), function:getStatus, arguments:[]  
TMP_191(None) = SOLIDITY_CALL require(bool)(TMP_190)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(value > 0)

IRs:
TMP_192(bool) = value > 0
TMP_193(None) = SOLIDITY_CALL require(bool)(TMP_192)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
(complete,verify) = xcPlugin.verifyProposal(fromAccount,toAccount,value,txid)

IRs:
TUPLE_0(bool,bool) = HIGH_LEVEL_CALL, dest:xcPlugin(XCPlugin), function:verifyProposal, arguments:['fromAccount', 'toAccount', 'value', 'txid']  
complete(bool)= UNPACK TUPLE_0 index: 0 
verify(bool)= UNPACK TUPLE_0 index: 1 ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(verify && ! complete)

IRs:
TMP_194 = UnaryType.BANG complete 
TMP_195(bool) = verify && TMP_194
TMP_196(None) = SOLIDITY_CALL require(bool)(TMP_195)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_197(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_197(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(balance >= value)

IRs:
TMP_198(bool) = balance >= value
TMP_199(None) = SOLIDITY_CALL require(bool)(TMP_198)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(token.transfer(toAccount,value))

IRs:
TMP_200(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transfer, arguments:['toAccount', 'value']  
TMP_201(None) = SOLIDITY_CALL require(bool)(TMP_200)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
require(bool)(xcPlugin.commitProposal(txid))

IRs:
TMP_202(bool) = HIGH_LEVEL_CALL, dest:xcPlugin(XCPlugin), function:commitProposal, arguments:['txid']  
TMP_203(None) = SOLIDITY_CALL require(bool)(TMP_202)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
lockBalance = SafeMath.sub(lockBalance,value)

IRs:
TMP_204(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['lockBalance', 'value'] 
lockBalance(uint256) := TMP_204(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
Unlock(txid,xcPlugin.getTrustPlatform(),fromAccount,bytes32(value),xcPlugin.getTokenSymbol())

IRs:
TMP_205(bytes32) = HIGH_LEVEL_CALL, dest:xcPlugin(XCPlugin), function:getTrustPlatform, arguments:[]  
TMP_206 = CONVERT value to bytes32
TMP_207(bytes32) = HIGH_LEVEL_CALL, dest:xcPlugin(XCPlugin), function:getTokenSymbol, arguments:[]  
Emit Unlock(txid,TMP_205,fromAccount,TMP_206,TMP_207)""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
nonzeroAddress(toAccount)

IRs:
MODIFIER_CALL, XC.nonzeroAddress(address)(toAccount)""];
14->1;
}
",1,0,0,0,"nonzeroAddress(toAccount);require(bool)(admin.status == 1 || admin.status == 3);require(bool)(xcPlugin.getStatus());require(bool)(value > 0);;;(complete,verify) = xcPlugin.verifyProposal(fromAccount,toAccount,value,txid);require(bool)(verify && ! complete);balance = token.balanceOf(this);require(bool)(balance >= value);require(bool)(token.transfer(toAccount,value));require(bool)(xcPlugin.commitProposal(txid));lockBalance = SafeMath.sub(lockBalance,value);Unlock(txid,xcPlugin.getTrustPlatform(),fromAccount,bytes32(value),xcPlugin.getTokenSymbol())"
./0x3420894bf786866a09937b0369d5b4781870c21f_ext.sol,LikeCoin.transferMultiple,266,268,"TMP_138(bool) = INTERNAL_CALL, LikeCoin._transferMultiple(address,address[],uint256[])(msg.sender,_addrs,_values),RETURN TMP_138,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_transferMultiple(msg.sender,_addrs,_values)

IRs:
TMP_138(bool) = INTERNAL_CALL, LikeCoin._transferMultiple(address,address[],uint256[])(msg.sender,_addrs,_values)
RETURN TMP_138""];
2[label=""Node Type: RETURN 2

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,0,0,0,"_transferMultiple(msg.sender,_addrs,_values);success"
./0xc739ae9ba934f937636a2ebaaf1ecdf04e11ef2f_ext.sol,NXTGToken.refundTokens,355,361,"TMP_111(bool) = msg.sender == owner,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113 = CONVERT this to address,TMP_114(bool) = _token != TMP_113,TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114),TMP_116 = CONVERT _token to AbstractToken,token(AbstractToken) := TMP_116(AbstractToken),TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ,Emit RefundTokens(_token,_refund,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_111(bool) = msg.sender == owner
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_113 = CONVERT this to address
TMP_114(bool) = _token != TMP_113
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
token = AbstractToken(_token)

IRs:
TMP_116 = CONVERT _token to AbstractToken
token(AbstractToken) := TMP_116(AbstractToken)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(_refund,_value)

IRs:
TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RefundTokens(_token,_refund,_value)

IRs:
Emit RefundTokens(_token,_refund,_value)""];
}
",1,0,0,0,"require(bool)(msg.sender == owner);require(bool)(_token != address(this));token = AbstractToken(_token);token.transfer(_refund,_value);RefundTokens(_token,_refund,_value)"
./0x4cd988afbad37289baaf53c13e98e2bd46aaea8c_ext.sol,DSToken.mint,421,424,"REF_49(uint256) -> _balances[msg.sender],REF_50(uint256) -> _balances[msg.sender],TMP_325(uint256) = INTERNAL_CALL, DSMath.add(uint256,uint256)(REF_50,wad),REF_49(uint256) (->_balances) := TMP_325(uint256),TMP_326(uint256) = INTERNAL_CALL, DSMath.add(uint256,uint256)(_supply,wad),_supply(uint256) := TMP_326(uint256),MODIFIER_CALL, DSAuth.auth()(),MODIFIER_CALL, DSStop.stoppable()(),MODIFIER_CALL, DSNote.note()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_balances[msg.sender] = add(_balances[msg.sender],wad)

IRs:
REF_49(uint256) -> _balances[msg.sender]
REF_50(uint256) -> _balances[msg.sender]
TMP_325(uint256) = INTERNAL_CALL, DSMath.add(uint256,uint256)(REF_50,wad)
REF_49(uint256) (->_balances) := TMP_325(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_supply = add(_supply,wad)

IRs:
TMP_326(uint256) = INTERNAL_CALL, DSMath.add(uint256,uint256)(_supply,wad)
_supply(uint256) := TMP_326(uint256)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
stoppable()

IRs:
MODIFIER_CALL, DSStop.stoppable()()""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
note()

IRs:
MODIFIER_CALL, DSNote.note()()""];
5->1;
}
",1,0,0,0,"auth();_balances[msg.sender] = add(_balances[msg.sender],wad);_supply = add(_supply,wad);stoppable();note()"
./0xd73c51ce805c86046577b7b4e5cb2dde14d72a36_ext.sol,EPTCrowdfund.endCrowdFund,397,408,"TMP_119(bool) = now > crowdfundEndTime,TMP_120(None) = SOLIDITY_CALL require(bool)(TMP_119),TMP_121(uint256) = HIGH_LEVEL_CALL, dest:token(EPTToken), function:balanceOf, arguments:['this']  ,remainingtoken(uint256) := TMP_121(uint256),TMP_122(bool) = remainingtoken != 0,CONDITION TMP_122,TMP_123(bool) = HIGH_LEVEL_CALL, dest:token(EPTToken), function:transfer, arguments:['founderAddress', 'remainingtoken']  ,Emit CrowdFundClosed(now),RETURN True,Emit CrowdFundClosed(now),RETURN False,MODIFIER_CALL, EPTCrowdfund.onlyfounder()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now > crowdfundEndTime)

IRs:
TMP_119(bool) = now > crowdfundEndTime
TMP_120(None) = SOLIDITY_CALL require(bool)(TMP_119)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
remainingtoken = token.balanceOf(this)

IRs:
TMP_121(uint256) = HIGH_LEVEL_CALL, dest:token(EPTToken), function:balanceOf, arguments:['this']  
remainingtoken(uint256) := TMP_121(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
remainingtoken != 0

IRs:
TMP_122(bool) = remainingtoken != 0
CONDITION TMP_122""];
3->4[label=""True""];
3->7[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(founderAddress,remainingtoken)

IRs:
TMP_123(bool) = HIGH_LEVEL_CALL, dest:token(EPTToken), function:transfer, arguments:['founderAddress', 'remainingtoken']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
CrowdFundClosed(now)

IRs:
Emit CrowdFundClosed(now)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
CrowdFundClosed(now)

IRs:
Emit CrowdFundClosed(now)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
false

IRs:
RETURN False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyfounder()

IRs:
MODIFIER_CALL, EPTCrowdfund.onlyfounder()()""];
10->1;
}
",1,0,0,0,"onlyfounder();require(bool)(now > crowdfundEndTime);remainingtoken = token.balanceOf(this);remainingtoken != 0;token.transfer(founderAddress,remainingtoken);;CrowdFundClosed(now);true;CrowdFundClosed(now);false"
./0x4bc78f6619991b029b867b6d88d39c196332aba3_ext.sol,AlgoDEX.withdrawToken,227,233,"TMP_109(bool) = token == 0,CONDITION TMP_109,TMP_110(None) = SOLIDITY_CALL revert()(),REF_68(mapping(address => uint256)) -> tokens[token],REF_69(uint256) -> REF_68[msg.sender],TMP_111(bool) = REF_69 < amount,CONDITION TMP_111,TMP_112(None) = SOLIDITY_CALL revert()(),REF_70(mapping(address => uint256)) -> tokens[token],REF_71(uint256) -> REF_70[msg.sender],REF_72(mapping(address => uint256)) -> tokens[token],REF_73(uint256) -> REF_72[msg.sender],TMP_113(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_73,amount),REF_71(uint256) (->tokens) := TMP_113(uint256),TMP_114 = CONVERT token to Token,TMP_115(bool) = HIGH_LEVEL_CALL, dest:TMP_114(Token), function:transfer, arguments:['msg.sender', 'amount']  ,TMP_116 = UnaryType.BANG TMP_115 ,CONDITION TMP_116,TMP_117(None) = SOLIDITY_CALL revert()(),REF_75(mapping(address => uint256)) -> tokens[token],REF_76(uint256) -> REF_75[msg.sender],Emit Withdraw(token,msg.sender,amount,REF_76)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
token == 0

IRs:
TMP_109(bool) = token == 0
CONDITION TMP_109""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_110(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
tokens[token][msg.sender] < amount

IRs:
REF_68(mapping(address => uint256)) -> tokens[token]
REF_69(uint256) -> REF_68[msg.sender]
TMP_111(bool) = REF_69 < amount
CONDITION TMP_111""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
revert()()

IRs:
TMP_112(None) = SOLIDITY_CALL revert()()""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens[token][msg.sender] = safeSub(tokens[token][msg.sender],amount)

IRs:
REF_70(mapping(address => uint256)) -> tokens[token]
REF_71(uint256) -> REF_70[msg.sender]
REF_72(mapping(address => uint256)) -> tokens[token]
REF_73(uint256) -> REF_72[msg.sender]
TMP_113(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_73,amount)
REF_71(uint256) (->tokens) := TMP_113(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
! Token(token).transfer(msg.sender,amount)

IRs:
TMP_114 = CONVERT token to Token
TMP_115(bool) = HIGH_LEVEL_CALL, dest:TMP_114(Token), function:transfer, arguments:['msg.sender', 'amount']  
TMP_116 = UnaryType.BANG TMP_115 
CONDITION TMP_116""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
revert()()

IRs:
TMP_117(None) = SOLIDITY_CALL revert()()""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
Withdraw(token,msg.sender,amount,tokens[token][msg.sender])

IRs:
REF_75(mapping(address => uint256)) -> tokens[token]
REF_76(uint256) -> REF_75[msg.sender]
Emit Withdraw(token,msg.sender,amount,REF_76)""];
}
",1,0,0,0,"token == 0;revert()();;tokens[token][msg.sender] < amount;revert()();;tokens[token][msg.sender] = safeSub(tokens[token][msg.sender],amount);! Token(token).transfer(msg.sender,amount);revert()();;Withdraw(token,msg.sender,amount,tokens[token][msg.sender])"
./0x723aaf922709819c25344b81901dd8a9c84c0b89_ext.sol,FinalizableCrowdsale.finalize,360,368,"TMP_178 = UnaryType.BANG isFinalized ,TMP_179(None) = SOLIDITY_CALL require(bool)(TMP_178),TMP_180(bool) = INTERNAL_CALL, Crowdsale.hasEnded()(),TMP_181(None) = SOLIDITY_CALL require(bool)(TMP_180),isFinalized(bool) := True(bool),INTERNAL_CALL, FinalizableCrowdsale.finalization()(),Emit Finalized(),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isFinalized)

IRs:
TMP_178 = UnaryType.BANG isFinalized 
TMP_179(None) = SOLIDITY_CALL require(bool)(TMP_178)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(hasEnded())

IRs:
TMP_180(bool) = INTERNAL_CALL, Crowdsale.hasEnded()()
TMP_181(None) = SOLIDITY_CALL require(bool)(TMP_180)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
isFinalized = true

IRs:
isFinalized(bool) := True(bool)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
finalization()

IRs:
INTERNAL_CALL, FinalizableCrowdsale.finalization()()""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Finalized()

IRs:
Emit Finalized()""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",1,0,0,0,onlyOwner();require(bool)(! isFinalized);require(bool)(hasEnded());isFinalized = true;finalization();Finalized()
./0xed8a2697d1af8f8cad0f6c5b9962d868d4ed2a41_ext.sol,HUMPresale.withdrawToken,756,760,"TMP_374(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  ,balanceOfThis(uint256) := TMP_374(uint256),TMP_375(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['wallet', 'balanceOfThis']  ,Emit Withdraw(wallet,balanceOfThis),MODIFIER_CALL, MultiOwnable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
balanceOfThis = token.balanceOf(this)

IRs:
TMP_374(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  
balanceOfThis(uint256) := TMP_374(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
token.transfer(wallet,balanceOfThis)

IRs:
TMP_375(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['wallet', 'balanceOfThis']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Withdraw(wallet,balanceOfThis)

IRs:
Emit Withdraw(wallet,balanceOfThis)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwnable.onlyOwner()()""];
4->1;
}
",1,0,0,0,"onlyOwner();balanceOfThis = token.balanceOf(this);token.transfer(wallet,balanceOfThis);Withdraw(wallet,balanceOfThis)"
./0x74263f99e21db7c38a319e8ed40bfeca2da791f5_ext.sol,CORENET.refundTokens,355,361,"TMP_111(bool) = msg.sender == owner,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113 = CONVERT this to address,TMP_114(bool) = _token != TMP_113,TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114),TMP_116 = CONVERT _token to AbstractToken,token(AbstractToken) := TMP_116(AbstractToken),TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ,Emit RefundTokens(_token,_refund,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_111(bool) = msg.sender == owner
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_113 = CONVERT this to address
TMP_114(bool) = _token != TMP_113
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
token = AbstractToken(_token)

IRs:
TMP_116 = CONVERT _token to AbstractToken
token(AbstractToken) := TMP_116(AbstractToken)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(_refund,_value)

IRs:
TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RefundTokens(_token,_refund,_value)

IRs:
Emit RefundTokens(_token,_refund,_value)""];
}
",1,0,0,0,"require(bool)(msg.sender == owner);require(bool)(_token != address(this));token = AbstractToken(_token);token.transfer(_refund,_value);RefundTokens(_token,_refund,_value)"
./0x18dc28340ddde25fa8c3b51f5d6a82b1706c8e20_ext.sol,WitnessJury.deposit,390,400,"TMP_293(bool) = amount > 0,TMP_294(None) = SOLIDITY_CALL require(bool)(TMP_293),REF_73(uint256) -> balances[msg.sender],TMP_295(bool) = REF_73 == 0,CONDITION TMP_295,TMP_296(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(numWitnesses,1),numWitnesses(uint256) := TMP_296(uint256),REF_74(uint256) -> balances[msg.sender],REF_75(uint256) -> balances[msg.sender],TMP_297(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_75,amount),REF_74(uint256) (->balances) := TMP_297(uint256),TMP_298(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(totalBalance,amount),totalBalance(uint256) := TMP_298(uint256),TMP_299 = CONVERT token to Token,TMP_300(bool) = HIGH_LEVEL_CALL, dest:TMP_299(Token), function:transferFrom, arguments:['msg.sender', 'this', 'amount']  ,TMP_301(None) = SOLIDITY_CALL require(bool)(TMP_300),Emit Deposit(amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_293(bool) = amount > 0
TMP_294(None) = SOLIDITY_CALL require(bool)(TMP_293)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
balances[msg.sender] == 0

IRs:
REF_73(uint256) -> balances[msg.sender]
TMP_295(bool) = REF_73 == 0
CONDITION TMP_295""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
numWitnesses = safeAdd(numWitnesses,1)

IRs:
TMP_296(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(numWitnesses,1)
numWitnesses(uint256) := TMP_296(uint256)""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[msg.sender] = safeAdd(balances[msg.sender],amount)

IRs:
REF_74(uint256) -> balances[msg.sender]
REF_75(uint256) -> balances[msg.sender]
TMP_297(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_75,amount)
REF_74(uint256) (->balances) := TMP_297(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
totalBalance = safeAdd(totalBalance,amount)

IRs:
TMP_298(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(totalBalance,amount)
totalBalance(uint256) := TMP_298(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(Token(token).transferFrom(msg.sender,this,amount))

IRs:
TMP_299 = CONVERT token to Token
TMP_300(bool) = HIGH_LEVEL_CALL, dest:TMP_299(Token), function:transferFrom, arguments:['msg.sender', 'this', 'amount']  
TMP_301(None) = SOLIDITY_CALL require(bool)(TMP_300)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Deposit(amount)

IRs:
Emit Deposit(amount)""];
}
",1,0,0,0,"require(bool)(amount > 0);balances[msg.sender] == 0;numWitnesses = safeAdd(numWitnesses,1);;balances[msg.sender] = safeAdd(balances[msg.sender],amount);totalBalance = safeAdd(totalBalance,amount);require(bool)(Token(token).transferFrom(msg.sender,this,amount));Deposit(amount)"
./0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06_ext.sol,SaleClockAuction.bid,1131,1143,"TMP_1019(uint256) = INTERNAL_CALL, ClockAuctionBase._bid(uint256,uint256,address)(_tokenId,msg.value,_sender),INTERNAL_CALL, ClockAuctionBase._transfer(address,uint256)(_sender,_tokenId),MODIFIER_CALL, Pausable.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_bid(_tokenId,msg.value,_sender)

IRs:
TMP_1019(uint256) = INTERNAL_CALL, ClockAuctionBase._bid(uint256,uint256,address)(_tokenId,msg.value,_sender)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_transfer(_sender,_tokenId)

IRs:
INTERNAL_CALL, ClockAuctionBase._transfer(address,uint256)(_sender,_tokenId)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
3->1;
}
",1,0,0,0,"whenNotPaused();_bid(_tokenId,msg.value,_sender);_transfer(_sender,_tokenId)"
./0x567b27ae0d0ea4fca292f447d819aa1b366375c4_ext.sol,DadiMaxCapSale.closeSale,373,385,"REF_62(DadiMaxCapSale.SaleState) -> SaleState.Closed,state(DadiMaxCapSale.SaleState) := REF_62(DadiMaxCapSale.SaleState),Emit LogStateChange(state),TMP_95(uint256) = INTERNAL_CALL, DadiMaxCapSale.getTokensAvailable()(),remaining(uint256) := TMP_95(uint256),INTERNAL_CALL, DadiMaxCapSale.updateSaleParameters(uint256)(remaining),TMP_97(bool) = remaining > 0,CONDITION TMP_97,TMP_98(bool) = HIGH_LEVEL_CALL, dest:token(StandardToken), function:transfer, arguments:['recipient', 'remaining']  ,Emit LogRedistributeTokens(recipient,state,remaining),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
state = SaleState.Closed

IRs:
REF_62(DadiMaxCapSale.SaleState) -> SaleState.Closed
state(DadiMaxCapSale.SaleState) := REF_62(DadiMaxCapSale.SaleState)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
LogStateChange(state)

IRs:
Emit LogStateChange(state)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
remaining = getTokensAvailable()

IRs:
TMP_95(uint256) = INTERNAL_CALL, DadiMaxCapSale.getTokensAvailable()()
remaining(uint256) := TMP_95(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
updateSaleParameters(remaining)

IRs:
INTERNAL_CALL, DadiMaxCapSale.updateSaleParameters(uint256)(remaining)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
remaining > 0

IRs:
TMP_97(bool) = remaining > 0
CONDITION TMP_97""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
token.transfer(recipient,remaining)

IRs:
TMP_98(bool) = HIGH_LEVEL_CALL, dest:token(StandardToken), function:transfer, arguments:['recipient', 'remaining']  ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
LogRedistributeTokens(recipient,state,remaining)

IRs:
Emit LogRedistributeTokens(recipient,state,remaining)""];
7->8;
8[label=""Node Type: END_IF 8
""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
9->1;
}
",1,0,0,0,"onlyOwner();state = SaleState.Closed;LogStateChange(state);remaining = getTokensAvailable();updateSaleParameters(remaining);remaining > 0;token.transfer(recipient,remaining);;LogRedistributeTokens(recipient,state,remaining)"
./0x470142a1834438515b757118f322703aba6e1e05_ext.sol,PolicyPalNetworkAirdrop.signatureDropSingleAmount,224,244,"i(uint256) := 0(uint256),REF_30 -> LENGTH _recipients,TMP_42(bool) = i < REF_30,CONDITION TMP_42,REF_31(address) -> _recipients[i],recipient(address) := REF_31(address),REF_32(bool) -> signaturedrops[recipient],TMP_43 = UnaryType.BANG REF_32 ,CONDITION TMP_43,TMP_44(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', '_amount']  ,TMP_45(None) = SOLIDITY_CALL assert(bool)(TMP_44),REF_34(bool) -> signaturedrops[recipient],REF_34(bool) (->signaturedrops) := True(bool),TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] ,numDrops(uint256) := TMP_46(uint256),TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', '_amount'] ,dropAmount(uint256) := TMP_47(uint256),Emit TokenDrop(recipient,_amount,SIGNATURE),TMP_49(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()(),MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalance(address[],uint256)(_recipients,_amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _recipients.length

IRs:
REF_30 -> LENGTH _recipients
TMP_42(bool) = i < REF_30
CONDITION TMP_42""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
recipient = _recipients[i]

IRs:
REF_31(address) -> _recipients[i]
recipient(address) := REF_31(address)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
! signaturedrops[recipient]

IRs:
REF_32(bool) -> signaturedrops[recipient]
TMP_43 = UnaryType.BANG REF_32 
CONDITION TMP_43""];
6->7[label=""True""];
6->12[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(token.transfer(recipient,_amount))

IRs:
TMP_44(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', '_amount']  
TMP_45(None) = SOLIDITY_CALL assert(bool)(TMP_44)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
signaturedrops[recipient] = true

IRs:
REF_34(bool) -> signaturedrops[recipient]
REF_34(bool) (->signaturedrops) := True(bool)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
numDrops = numDrops.add(1)

IRs:
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] 
numDrops(uint256) := TMP_46(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
dropAmount = dropAmount.add(_amount)

IRs:
TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', '_amount'] 
dropAmount(uint256) := TMP_47(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
TokenDrop(recipient,_amount,SIGNATURE)

IRs:
Emit TokenDrop(recipient,_amount,SIGNATURE)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
i ++

IRs:
TMP_49(uint256) := i(uint256)
i(uint256) = i + 1""];
13->4;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()()""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
validBalance(_recipients,_amount)

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalance(address[],uint256)(_recipients,_amount)""];
15->3;
}
",1,0,0,0,"onlyAdmin();;i < _recipients.length;;i = 0;recipient = _recipients[i];! signaturedrops[recipient];assert(bool)(token.transfer(recipient,_amount));;signaturedrops[recipient] = true;numDrops = numDrops.add(1);dropAmount = dropAmount.add(_amount);TokenDrop(recipient,_amount,SIGNATURE);i ++;validBalance(_recipients,_amount)"
./0xd41ee3317467ab60109d76d6360807777c10afd7_ext.sol,ZJLTTokenVault.alloc,374,380,"TMP_197 = CONVERT this to address,TMP_198(uint256) = HIGH_LEVEL_CALL, dest:token(ZJLTToken), function:balanceOf, arguments:['TMP_197']  ,TMP_199(bool) = TMP_198 >= totalAlloc,TMP_200(None) = SOLIDITY_CALL require(bool)(TMP_199),REF_186(uint256) -> lockBalance[teamWallet],REF_186(uint256) (->lockBalance) := totalAlloc(uint256),startLockTime(uint256) := 1494432000(uint256),isExec(bool) := True(bool),Emit Alloc(teamWallet,totalAlloc),MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, ZJLTTokenVault.unExecd()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(token.balanceOf(address(this)) >= totalAlloc)

IRs:
TMP_197 = CONVERT this to address
TMP_198(uint256) = HIGH_LEVEL_CALL, dest:token(ZJLTToken), function:balanceOf, arguments:['TMP_197']  
TMP_199(bool) = TMP_198 >= totalAlloc
TMP_200(None) = SOLIDITY_CALL require(bool)(TMP_199)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
lockBalance[teamWallet] = totalAlloc

IRs:
REF_186(uint256) -> lockBalance[teamWallet]
REF_186(uint256) (->lockBalance) := totalAlloc(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
startLockTime = 1494432000

IRs:
startLockTime(uint256) := 1494432000(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
isExec = true

IRs:
isExec(bool) := True(bool)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Alloc(teamWallet,totalAlloc)

IRs:
Emit Alloc(teamWallet,totalAlloc)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
unExecd()

IRs:
MODIFIER_CALL, ZJLTTokenVault.unExecd()()""];
7->1;
}
",1,0,0,0,"onlyOwner();require(bool)(token.balanceOf(address(this)) >= totalAlloc);lockBalance[teamWallet] = totalAlloc;startLockTime = 1494432000;isExec = true;Alloc(teamWallet,totalAlloc);unExecd()"
./0x742686bb1b136b396b59818f42e47a4fc3509394_ext.sol,CommonSale.mintBounty,480,484,"TMP_293 = UnaryType.BANG bountyMinted ,TMP_294(None) = SOLIDITY_CALL require(bool)(TMP_293),TMP_295(uint256) = bountyTokensCount * 1000000000000000000,TMP_296(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['bountyTokensWallet', 'TMP_295']  ,bountyMinted(bool) := True(bool),MODIFIER_CALL, Pausable.whenNotPaused()(),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! bountyMinted)

IRs:
TMP_293 = UnaryType.BANG bountyMinted 
TMP_294(None) = SOLIDITY_CALL require(bool)(TMP_293)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
token.mint(bountyTokensWallet,bountyTokensCount * 1000000000000000000)

IRs:
TMP_295(uint256) = bountyTokensCount * 1000000000000000000
TMP_296(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['bountyTokensWallet', 'TMP_295']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
bountyMinted = true

IRs:
bountyMinted(bool) := True(bool)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",1,0,0,0,"whenNotPaused();require(bool)(! bountyMinted);token.mint(bountyTokensWallet,bountyTokensCount * 1000000000000000000);bountyMinted = true;onlyOwner()"
./0x2d3e7d4870a51b918919e7b851fe19983e4c38d5_ext.sol,FreezeTokensWallet.start,339,344,"TMP_130(uint256) = now + startLockPeriod,startUnlock(uint256) := TMP_130(uint256),retrievedTokens(uint256) := 0(uint256),TMP_131(uint256) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:balanceOf, arguments:['this']  ,startBalance(uint256) := TMP_131(uint256),started(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, FreezeTokensWallet.notStarted()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
startUnlock = now + startLockPeriod

IRs:
TMP_130(uint256) = now + startLockPeriod
startUnlock(uint256) := TMP_130(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
retrievedTokens = 0

IRs:
retrievedTokens(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
startBalance = token.balanceOf(this)

IRs:
TMP_131(uint256) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:balanceOf, arguments:['this']  
startBalance(uint256) := TMP_131(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
started = true

IRs:
started(bool) := True(bool)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
notStarted()

IRs:
MODIFIER_CALL, FreezeTokensWallet.notStarted()()""];
6->1;
}
",1,0,0,0,onlyOwner();startUnlock = now + startLockPeriod;retrievedTokens = 0;startBalance = token.balanceOf(this);started = true;notStarted()
./0x4c478ac32725872e30bca49957abc7dbb325cb21_ext.sol,daocrowdsale.buy,283,289,"TMP_95(uint256) = price * _amount,TMP_96(bool) = msg.value == TMP_95,REF_67(uint256) -> Values.hardcap,TMP_97(uint256) = HIGH_LEVEL_CALL, dest:DAO(COIN), function:totalSupply, arguments:[]  ,TMP_98(uint256) = REF_67 - TMP_97,TMP_99(bool) = _amount <= TMP_98,TMP_100(bool) = TMP_96 && TMP_99,TMP_101(None) = SOLIDITY_CALL require(bool)(TMP_100),Transfer dest:owner value:msg.value,TMP_103(bool) = HIGH_LEVEL_CALL, dest:DAO(COIN), function:passwordMint, arguments:['msg.sender', '_amount', 'password']  ,Emit Deal(msg.sender,_amount),RETURN True,MODIFIER_CALL, daocrowdsale.IsOutdated()(),TMP_106(uint256) = HIGH_LEVEL_CALL, dest:DAO(COIN), function:totalSupply, arguments:[]  ,REF_72(uint256) -> Values.hardcap,MODIFIER_CALL, daocrowdsale.IsBought(uint256,uint256)(TMP_106,REF_72)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((msg.value == price * _amount) && (_amount <= (Values.hardcap - DAO.totalSupply())))

IRs:
TMP_95(uint256) = price * _amount
TMP_96(bool) = msg.value == TMP_95
REF_67(uint256) -> Values.hardcap
TMP_97(uint256) = HIGH_LEVEL_CALL, dest:DAO(COIN), function:totalSupply, arguments:[]  
TMP_98(uint256) = REF_67 - TMP_97
TMP_99(bool) = _amount <= TMP_98
TMP_100(bool) = TMP_96 && TMP_99
TMP_101(None) = SOLIDITY_CALL require(bool)(TMP_100)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(msg.value)

IRs:
Transfer dest:owner value:msg.value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
DAO.passwordMint(msg.sender,_amount,password)

IRs:
TMP_103(bool) = HIGH_LEVEL_CALL, dest:DAO(COIN), function:passwordMint, arguments:['msg.sender', '_amount', 'password']  ""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Deal(msg.sender,_amount)

IRs:
Emit Deal(msg.sender,_amount)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
IsOutdated()

IRs:
MODIFIER_CALL, daocrowdsale.IsOutdated()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
IsBought(DAO.totalSupply(),Values.hardcap)

IRs:
TMP_106(uint256) = HIGH_LEVEL_CALL, dest:DAO(COIN), function:totalSupply, arguments:[]  
REF_72(uint256) -> Values.hardcap
MODIFIER_CALL, daocrowdsale.IsBought(uint256,uint256)(TMP_106,REF_72)""];
7->1;
}
",1,0,0,0,"IsOutdated();require(bool)((msg.value == price * _amount) && (_amount <= (Values.hardcap - DAO.totalSupply())));owner.transfer(msg.value);DAO.passwordMint(msg.sender,_amount,password);Deal(msg.sender,_amount);true;IsBought(DAO.totalSupply(),Values.hardcap)"
./0xdc919494349e803fbd2d4064106944418381edb3_ext.sol,DSToken.setName,471,473,"name(bytes32) := name_(bytes32),MODIFIER_CALL, DSAuth.auth()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
name = name_

IRs:
name(bytes32) := name_(bytes32)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
2->1;
}
",1,0,0,0,auth();name = name_
./0x0e6f6ed4581d25944d8c6a595b9f50e11431b754_ext.sol,PaymentHolder.migrate,474,484,"TMP_171 = CONVERT newHolder to PaymentHolder,TMP_172 = CONVERT this to address,TMP_173(uint256) = SOLIDITY_CALL balance(address)(TMP_172),TMP_175(bool) = HIGH_LEVEL_CALL, dest:TMP_171(PaymentHolder), function:update, arguments:['_allowed'] value:TMP_173 ,TMP_176(None) = SOLIDITY_CALL require(bool)(TMP_175),i(uint256) := 0(uint256),REF_80 -> LENGTH tokens,TMP_177(bool) = i < REF_80,CONDITION TMP_177,REF_81(address) -> tokens[i],token(address) := REF_81(address),TMP_178 = CONVERT token to Token,TMP_179(uint256) = HIGH_LEVEL_CALL, dest:TMP_178(Token), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_179(uint256),TMP_180(bool) = balance > 0,CONDITION TMP_180,TMP_181 = CONVERT token to Token,TMP_182(bool) = HIGH_LEVEL_CALL, dest:TMP_181(Token), function:transfer, arguments:['newHolder', 'balance']  ,TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182),TMP_184(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(PaymentHolder(newHolder).update.value(address(this).balance)(_allowed))

IRs:
TMP_171 = CONVERT newHolder to PaymentHolder
TMP_172 = CONVERT this to address
TMP_173(uint256) = SOLIDITY_CALL balance(address)(TMP_172)
TMP_175(bool) = HIGH_LEVEL_CALL, dest:TMP_171(PaymentHolder), function:update, arguments:['_allowed'] value:TMP_173 
TMP_176(None) = SOLIDITY_CALL require(bool)(TMP_175)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < tokens.length

IRs:
REF_80 -> LENGTH tokens
TMP_177(bool) = i < REF_80
CONDITION TMP_177""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
token = tokens[i]

IRs:
REF_81(address) -> tokens[i]
token(address) := REF_81(address)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
balance = Token(token).balanceOf(this)

IRs:
TMP_178 = CONVERT token to Token
TMP_179(uint256) = HIGH_LEVEL_CALL, dest:TMP_178(Token), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_179(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
balance > 0

IRs:
TMP_180(bool) = balance > 0
CONDITION TMP_180""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(Token(token).transfer(newHolder,balance))

IRs:
TMP_181 = CONVERT token to Token
TMP_182(bool) = HIGH_LEVEL_CALL, dest:TMP_181(Token), function:transfer, arguments:['newHolder', 'balance']  
TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_184(uint256) := i(uint256)
i(uint256) = i + 1""];
11->5;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
12->1;
}
",1,0,1,0,"onlyOwner();require(bool)(PaymentHolder(newHolder).update.value(address(this).balance)(_allowed));i = 0;;i < tokens.length;;token = tokens[i];balance = Token(token).balanceOf(this);balance > 0;require(bool)(Token(token).transfer(newHolder,balance));;i ++"
./0x8615ddfe9d4c9e58abff01c999731f3e9e556e80_ext.sol,DAPBOXToken.withdraw,690,695,"TMP_654 = CONVERT this to address,TMP_655(uint256) = SOLIDITY_CALL balance(address)(TMP_654),TMP_656(bool) = INTERNAL_CALL, DAPBOXToken.withdrawAmount(uint256)(TMP_655),RETURN TMP_656,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
withdrawAmount(address(this).balance)

IRs:
TMP_654 = CONVERT this to address
TMP_655(uint256) = SOLIDITY_CALL balance(address)(TMP_654)
TMP_656(bool) = INTERNAL_CALL, DAPBOXToken.withdrawAmount(uint256)(TMP_655)
RETURN TMP_656""];
2[label=""Node Type: RETURN 2

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,0,0,0,withdrawAmount(address(this).balance);success
./0x0e33ca464b1c76a384039eb1b7e9dc3b0416b5ae_ext.sol,NamiCrowdSale.transferToBuyer,894,909,"REF_306(uint256) -> balanceOf[msg.sender],REF_307(uint256) -> balanceOf[msg.sender],TMP_338(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_307', '_value'] ,REF_306(uint256) (->balanceOf) := TMP_338(uint256),REF_309(uint256) -> balanceOf[_to],REF_310(uint256) -> balanceOf[_to],TMP_339(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_310', '_value'] ,REF_309(uint256) (->balanceOf) := TMP_339(uint256),Emit Transfer(msg.sender,_to,_value),TMP_341(bool) = codeLength > 0,CONDITION TMP_341,TMP_342 = CONVERT _to to ERC223ReceivingContract,receiver(ERC223ReceivingContract) := TMP_342(ERC223ReceivingContract),TMP_343(bool) = HIGH_LEVEL_CALL, dest:receiver(ERC223ReceivingContract), function:tokenFallbackBuyer, arguments:['msg.sender', '_value', '_buyer']  ,Emit TransferToBuyer(msg.sender,_to,_value,_buyer)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: INLINE ASM 2
""];
2->3;
3[label=""Node Type: END INLINE ASM 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value)

IRs:
REF_306(uint256) -> balanceOf[msg.sender]
REF_307(uint256) -> balanceOf[msg.sender]
TMP_338(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_307', '_value'] 
REF_306(uint256) (->balanceOf) := TMP_338(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_to] = balanceOf[_to].add(_value)

IRs:
REF_309(uint256) -> balanceOf[_to]
REF_310(uint256) -> balanceOf[_to]
TMP_339(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_310', '_value'] 
REF_309(uint256) (->balanceOf) := TMP_339(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
codeLength > 0

IRs:
TMP_341(bool) = codeLength > 0
CONDITION TMP_341""];
7->8[label=""True""];
7->11[label=""False""];
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
receiver = ERC223ReceivingContract(_to)

IRs:
TMP_342 = CONVERT _to to ERC223ReceivingContract
receiver(ERC223ReceivingContract) := TMP_342(ERC223ReceivingContract)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
receiver.tokenFallbackBuyer(msg.sender,_value,_buyer)

IRs:
TMP_343(bool) = HIGH_LEVEL_CALL, dest:receiver(ERC223ReceivingContract), function:tokenFallbackBuyer, arguments:['msg.sender', '_value', '_buyer']  ""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
TransferToBuyer(msg.sender,_to,_value,_buyer)

IRs:
Emit TransferToBuyer(msg.sender,_to,_value,_buyer)""];
10->11;
11[label=""Node Type: END_IF 11
""];
}
",1,0,0,0,";;;balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);balanceOf[_to] = balanceOf[_to].add(_value);Transfer(msg.sender,_to,_value);codeLength > 0;receiver = ERC223ReceivingContract(_to);;receiver.tokenFallbackBuyer(msg.sender,_value,_buyer);TransferToBuyer(msg.sender,_to,_value,_buyer)"
./0x57775c09b07896b979bb192b1b13df5a268757bd_ext.sol,FutureTokenSaleLockBox.transfer,218,224,"TMP_48(bool) = HIGH_LEVEL_CALL, dest:simpleToken(ERC20Interface), function:transfer, arguments:['_to', '_value']  ,TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48),Emit TokensTransferred(_to,_value),RETURN True,MODIFIER_CALL, Owned.onlyOwner()(),MODIFIER_CALL, FutureTokenSaleLockBox.onlyAfterUnlockDate()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(simpleToken.transfer(_to,_value))

IRs:
TMP_48(bool) = HIGH_LEVEL_CALL, dest:simpleToken(ERC20Interface), function:transfer, arguments:['_to', '_value']  
TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
TokensTransferred(_to,_value)

IRs:
Emit TokensTransferred(_to,_value)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyAfterUnlockDate()

IRs:
MODIFIER_CALL, FutureTokenSaleLockBox.onlyAfterUnlockDate()()""];
5->1;
}
",1,0,0,0,"onlyOwner();require(bool)(simpleToken.transfer(_to,_value));TokensTransferred(_to,_value);true;onlyAfterUnlockDate()"
./0xd1569ffd7ca4393311f66110e6f87184c4817113_ext.sol,LudumAirdrop.sendLudumToMany,68,76,"i(uint256) := 0(uint256),REF_0 -> LENGTH dests,TMP_15(bool) = i < REF_0,CONDITION TMP_15,REF_1(uint256) -> values[i],toSend(uint256) := REF_1(uint256),REF_2(address) -> dests[i],REF_3(uint256) -> values[i],INTERNAL_CALL, LudumAirdrop.sendInternally(address,uint256,uint256)(REF_2,toSend,REF_3),TMP_17(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, LudumAirdrop.whenDropIsActive()(),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->3;
3[label=""Node Type: IF_LOOP 3

EXPRESSION:
i < dests.length

IRs:
REF_0 -> LENGTH dests
TMP_15(bool) = i < REF_0
CONDITION TMP_15""];
3->4[label=""True""];
3->7[label=""False""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
toSend = values[i]

IRs:
REF_1(uint256) -> values[i]
toSend(uint256) := REF_1(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
sendInternally(dests[i],toSend,values[i])

IRs:
REF_2(address) -> dests[i]
REF_3(uint256) -> values[i]
INTERNAL_CALL, LudumAirdrop.sendInternally(address,uint256,uint256)(REF_2,toSend,REF_3)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_17(uint256) := i(uint256)
i(uint256) = i + 1""];
6->3;
7[label=""Node Type: END_LOOP 7
""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
whenDropIsActive()

IRs:
MODIFIER_CALL, LudumAirdrop.whenDropIsActive()()""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
9->1;
}
",1,0,0,0,"whenDropIsActive();i = 0;;i < dests.length;toSend = values[i];;sendInternally(dests[i],toSend,values[i]);i ++;onlyOwner()"
./0x0e752b742f744fdc2d93774da44c37b72c3e6952_ext.sol,CraftyCrowdsale.finishCrowdsale,553,562,"TMP_202(bool) = now > saleEnd,TMP_203(None) = SOLIDITY_CALL require(bool)(TMP_202),TMP_204(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['hardCap', 'issuedTokens'] ,unspentTokens(uint256) := TMP_204(uint256),TMP_205(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['fundWallet', 'unspentTokens']  ,REF_86(CraftyCrowdsale.State) -> State.CLOSED,currentState(CraftyCrowdsale.State) := REF_86(CraftyCrowdsale.State),TMP_206(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:finishMinting, arguments:[]  ,MODIFIER_CALL, Ownable.onlyOwner()(),REF_88(CraftyCrowdsale.State) -> State.SALE,MODIFIER_CALL, CraftyCrowdsale.inState(CraftyCrowdsale.State)(REF_88)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now > saleEnd)

IRs:
TMP_202(bool) = now > saleEnd
TMP_203(None) = SOLIDITY_CALL require(bool)(TMP_202)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
unspentTokens = hardCap.sub(issuedTokens)

IRs:
TMP_204(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['hardCap', 'issuedTokens'] 
unspentTokens(uint256) := TMP_204(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
token.mint(fundWallet,unspentTokens)

IRs:
TMP_205(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['fundWallet', 'unspentTokens']  ""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
currentState = State.CLOSED

IRs:
REF_86(CraftyCrowdsale.State) -> State.CLOSED
currentState(CraftyCrowdsale.State) := REF_86(CraftyCrowdsale.State)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
token.finishMinting()

IRs:
TMP_206(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:finishMinting, arguments:[]  ""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
inState(State.SALE)

IRs:
REF_88(CraftyCrowdsale.State) -> State.SALE
MODIFIER_CALL, CraftyCrowdsale.inState(CraftyCrowdsale.State)(REF_88)""];
7->1;
}
",1,0,0,0,"onlyOwner();require(bool)(now > saleEnd);unspentTokens = hardCap.sub(issuedTokens);token.mint(fundWallet,unspentTokens);currentState = State.CLOSED;token.finishMinting();inState(State.SALE)"
./0x1fd2a7194c6bdc3c8f2c3b59b73f008a8f7a4818_ext.sol,TokenTimelock.addTokens,163,169,"TMP_38 = CONVERT 0 to address,TMP_39(bool) = _owner != TMP_38,TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39),LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(ERC20,address,address,uint256), arguments:['token', 'msg.sender', 'this', '_value'] ,REF_4(uint256) -> balances[_owner],REF_5(uint256) -> balances[_owner],TMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] ,REF_4(uint256) (->balances) := TMP_42(uint256),REF_7(uint256) -> releaseTime[_owner],TMP_43(uint256) = _releaseTime * 86400,TMP_44(uint256) = now + TMP_43,REF_7(uint256) (->releaseTime) := TMP_44(uint256),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_owner != address(0))

IRs:
TMP_38 = CONVERT 0 to address
TMP_39(bool) = _owner != TMP_38
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
token.safeTransferFrom(msg.sender,this,_value)

IRs:
LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(ERC20,address,address,uint256), arguments:['token', 'msg.sender', 'this', '_value'] ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_owner] = balances[_owner].add(_value)

IRs:
REF_4(uint256) -> balances[_owner]
REF_5(uint256) -> balances[_owner]
TMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] 
REF_4(uint256) (->balances) := TMP_42(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
releaseTime[_owner] = now + _releaseTime * 86400

IRs:
REF_7(uint256) -> releaseTime[_owner]
TMP_43(uint256) = _releaseTime * 86400
TMP_44(uint256) = now + TMP_43
REF_7(uint256) (->releaseTime) := TMP_44(uint256)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",1,0,0,0,"onlyOwner();require(bool)(_owner != address(0));token.safeTransferFrom(msg.sender,this,_value);balances[_owner] = balances[_owner].add(_value);releaseTime[_owner] = now + _releaseTime * 86400"
./0x486cf19a550e2814aef970b14e509e93209a0151_ext.sol,EventChainCrowdsale.mintFounderTokens,426,432,"TMP_191(bool) = HIGH_LEVEL_CALL, dest:evc(EventChain), function:mintAgents, arguments:['this']  ,TMP_192(None) = SOLIDITY_CALL assert(bool)(TMP_191),HIGH_LEVEL_CALL, dest:evc(EventChain), function:mint, arguments:['beneficiary', '29400000000000000000000000']  ,REF_104(EventChainCrowdsale.State) -> State.Prepared,currentState(EventChainCrowdsale.State) := REF_104(EventChainCrowdsale.State),REF_105(EventChainCrowdsale.State) -> State.Preparing,Emit StateChanged(REF_105,currentState),MODIFIER_CALL, Ownable.onlyOwner()(),REF_106(EventChainCrowdsale.State) -> State.Preparing,MODIFIER_CALL, EventChainCrowdsale.inState(EventChainCrowdsale.State)(REF_106)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(evc.mintAgents(this))

IRs:
TMP_191(bool) = HIGH_LEVEL_CALL, dest:evc(EventChain), function:mintAgents, arguments:['this']  
TMP_192(None) = SOLIDITY_CALL assert(bool)(TMP_191)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
evc.mint(beneficiary,29400000000000000000000000)

IRs:
HIGH_LEVEL_CALL, dest:evc(EventChain), function:mint, arguments:['beneficiary', '29400000000000000000000000']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
currentState = State.Prepared

IRs:
REF_104(EventChainCrowdsale.State) -> State.Prepared
currentState(EventChainCrowdsale.State) := REF_104(EventChainCrowdsale.State)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
StateChanged(State.Preparing,currentState)

IRs:
REF_105(EventChainCrowdsale.State) -> State.Preparing
Emit StateChanged(REF_105,currentState)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
inState(State.Preparing)

IRs:
REF_106(EventChainCrowdsale.State) -> State.Preparing
MODIFIER_CALL, EventChainCrowdsale.inState(EventChainCrowdsale.State)(REF_106)""];
6->1;
}
",1,0,0,0,"onlyOwner();assert(bool)(evc.mintAgents(this));evc.mint(beneficiary,29400000000000000000000000);currentState = State.Prepared;StateChanged(State.Preparing,currentState);inState(State.Preparing)"
./0x35a1700ac75f6e9e096d9a5c90e3221b658096e0_ext.sol,SpendableWallet.claimTokens,124,137,"TMP_21(bool) = _token == 0,CONDITION TMP_21,TMP_22 = CONVERT this to address,TMP_23(uint256) = SOLIDITY_CALL balance(address)(TMP_22),Transfer dest:owner value:TMP_23,TMP_25 = CONVERT _token to ERC20,erc20token(ERC20) := TMP_25(ERC20),TMP_26 = CONVERT this to address,TMP_27(uint256) = HIGH_LEVEL_CALL, dest:erc20token(ERC20), function:balanceOf, arguments:['TMP_26']  ,balance(uint256) := TMP_27(uint256),TMP_28(bool) = HIGH_LEVEL_CALL, dest:erc20token(ERC20), function:transfer, arguments:['owner', 'balance']  ,TMP_29(None) = SOLIDITY_CALL require(bool,string)(TMP_28,Token transfer could not be executed.),Emit ClaimedTokens(_token,owner,balance),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_21(bool) = _token == 0
CONDITION TMP_21""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_22 = CONVERT this to address
TMP_23(uint256) = SOLIDITY_CALL balance(address)(TMP_22)
Transfer dest:owner value:TMP_23""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
erc20token = ERC20(_token)

IRs:
TMP_25 = CONVERT _token to ERC20
erc20token(ERC20) := TMP_25(ERC20)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = erc20token.balanceOf(address(this))

IRs:
TMP_26 = CONVERT this to address
TMP_27(uint256) = HIGH_LEVEL_CALL, dest:erc20token(ERC20), function:balanceOf, arguments:['TMP_26']  
balance(uint256) := TMP_27(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool,string)(erc20token.transfer(owner,balance),Token transfer could not be executed.)

IRs:
TMP_28(bool) = HIGH_LEVEL_CALL, dest:erc20token(ERC20), function:transfer, arguments:['owner', 'balance']  
TMP_29(None) = SOLIDITY_CALL require(bool,string)(TMP_28,Token transfer could not be executed.)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,owner,balance)

IRs:
Emit ClaimedTokens(_token,owner,balance)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
9->1;
}
",1,0,0,0,"onlyOwner();_token == 0x0;owner.transfer(address(this).balance);;;erc20token = ERC20(_token);balance = erc20token.balanceOf(address(this));require(bool,string)(erc20token.transfer(owner,balance),Token transfer could not be executed.);ClaimedTokens(_token,owner,balance)"
./0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06_ext.sol,SaleClockAuction.bid,1131,1143,"TMP_1019(uint256) = INTERNAL_CALL, ClockAuctionBase._bid(uint256,uint256,address)(_tokenId,msg.value,_sender),INTERNAL_CALL, ClockAuctionBase._transfer(address,uint256)(_sender,_tokenId),MODIFIER_CALL, Pausable.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_bid(_tokenId,msg.value,_sender)

IRs:
TMP_1019(uint256) = INTERNAL_CALL, ClockAuctionBase._bid(uint256,uint256,address)(_tokenId,msg.value,_sender)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_transfer(_sender,_tokenId)

IRs:
INTERNAL_CALL, ClockAuctionBase._transfer(address,uint256)(_sender,_tokenId)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
3->1;
}
",1,0,0,0,"whenNotPaused();_bid(_tokenId,msg.value,_sender);_transfer(_sender,_tokenId)"
./0x56c945f90c9cd1aafbcac78936f569e5fd2438bf_ext.sol,HeroUp.upgrade,180,198,"TMP_83(address) = HIGH_LEVEL_CALL, dest:heroesOld(HEROES_OLD), function:ownerOf, arguments:['_tokenId']  ,TMP_84(bool) = msg.sender == TMP_83,TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84),TUPLE_0(uint256,uint256,uint256,uint256,uint32,uint32,uint32,uint256,uint16) = HIGH_LEVEL_CALL, dest:heroesOld(HEROES_OLD), function:getCharacter, arguments:['_tokenId']  ,genes(uint256)= UNPACK TUPLE_0 index: 0 ,level(uint32)= UNPACK TUPLE_0 index: 6 ,lockedTo(uint256)= UNPACK TUPLE_0 index: 7 ,lockId(uint16)= UNPACK TUPLE_0 index: 8 ,TMP_86(bool) = HIGH_LEVEL_CALL, dest:heroesOld(HEROES_OLD), function:unlock, arguments:['_tokenId', 'lockId']  ,TMP_87(bool) = HIGH_LEVEL_CALL, dest:heroesOld(HEROES_OLD), function:lock, arguments:['_tokenId', '0', '999']  ,TMP_88 = CONVERT this to address,HIGH_LEVEL_CALL, dest:heroesOld(HEROES_OLD), function:transferFrom, arguments:['msg.sender', 'TMP_88', '_tokenId']  ,TMP_90(uint256) = HIGH_LEVEL_CALL, dest:heroesNew(HEROES_NEW), function:mint, arguments:['_tokenId', 'msg.sender', 'genes', 'level']  ,Emit HeroUpgraded(_tokenId,msg.sender)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == heroesOld.ownerOf(_tokenId))

IRs:
TMP_83(address) = HIGH_LEVEL_CALL, dest:heroesOld(HEROES_OLD), function:ownerOf, arguments:['_tokenId']  
TMP_84(bool) = msg.sender == TMP_83
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: NEW VARIABLE 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
(genes,None,None,None,None,None,level,lockedTo,lockId) = heroesOld.getCharacter(_tokenId)

IRs:
TUPLE_0(uint256,uint256,uint256,uint256,uint32,uint32,uint32,uint256,uint16) = HIGH_LEVEL_CALL, dest:heroesOld(HEROES_OLD), function:getCharacter, arguments:['_tokenId']  
genes(uint256)= UNPACK TUPLE_0 index: 0 
level(uint32)= UNPACK TUPLE_0 index: 6 
lockedTo(uint256)= UNPACK TUPLE_0 index: 7 
lockId(uint16)= UNPACK TUPLE_0 index: 8 ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
heroesOld.unlock(_tokenId,lockId)

IRs:
TMP_86(bool) = HIGH_LEVEL_CALL, dest:heroesOld(HEROES_OLD), function:unlock, arguments:['_tokenId', 'lockId']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
heroesOld.lock(_tokenId,0,999)

IRs:
TMP_87(bool) = HIGH_LEVEL_CALL, dest:heroesOld(HEROES_OLD), function:lock, arguments:['_tokenId', '0', '999']  ""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
heroesOld.transferFrom(msg.sender,address(this),_tokenId)

IRs:
TMP_88 = CONVERT this to address
HIGH_LEVEL_CALL, dest:heroesOld(HEROES_OLD), function:transferFrom, arguments:['msg.sender', 'TMP_88', '_tokenId']  ""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
heroesNew.mint(_tokenId,msg.sender,genes,level)

IRs:
TMP_90(uint256) = HIGH_LEVEL_CALL, dest:heroesNew(HEROES_NEW), function:mint, arguments:['_tokenId', 'msg.sender', 'genes', 'level']  ""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
HeroUpgraded(_tokenId,msg.sender)

IRs:
Emit HeroUpgraded(_tokenId,msg.sender)""];
}
",1,0,0,0,"require(bool)(msg.sender == heroesOld.ownerOf(_tokenId));;;;;(genes,None,None,None,None,None,level,lockedTo,lockId) = heroesOld.getCharacter(_tokenId);heroesOld.unlock(_tokenId,lockId);heroesOld.lock(_tokenId,0,999);heroesOld.transferFrom(msg.sender,address(this),_tokenId);heroesNew.mint(_tokenId,msg.sender,genes,level);HeroUpgraded(_tokenId,msg.sender)"
./0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a_ext.sol,BitSTDView.transferFrom,480,485,"TMP_159(bool) = HIGH_LEVEL_CALL, dest:logic(BitSTDLogic), function:transferFrom, arguments:['_from', 'msg.sender', '_to', '_value']  ,TMP_160(bool) = TMP_159 == True,CONDITION TMP_160,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
logic.transferFrom(_from,msg.sender,_to,_value) == true

IRs:
TMP_159(bool) = HIGH_LEVEL_CALL, dest:logic(BitSTDLogic), function:transferFrom, arguments:['_from', 'msg.sender', '_to', '_value']  
TMP_160(bool) = TMP_159 == True
CONDITION TMP_160""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,0,0,0,"logic.transferFrom(_from,msg.sender,_to,_value) == true;Transfer(_from,_to,_value);;true;success"
./0x32f916bcfae02a2a385ec0219a07fa2374bae7bb_ext.sol,NamiExchange.tokenFallbackBuyer,941,968,"TMP_306 = CONVERT NamiAddr to ERC23,asset(ERC23) := TMP_306(ERC23),REF_185(NamiExchange.OrderBid) -> bid[_buyer],REF_186(uint256) -> REF_185.eth,currentEth(uint256) := REF_186(uint256),REF_188(NamiExchange.OrderBid) -> bid[_buyer],REF_189(uint256) -> REF_188.price,TMP_307(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_value', 'REF_189'] ,TMP_308(bool) = TMP_307 > currentEth,CONDITION TMP_308,TMP_309 = SEND dest:_from value:currentEth,REF_193(NamiExchange.OrderBid) -> bid[_buyer],REF_194(uint256) -> REF_193.price,TMP_310(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['currentEth', 'REF_194'] ,TMP_311(bool) = HIGH_LEVEL_CALL, dest:asset(ERC23), function:transfer, arguments:['_buyer', 'TMP_310']  ,TMP_312(bool) = TMP_309 && TMP_311,REF_197(NamiExchange.OrderBid) -> bid[_buyer],REF_198(uint256) -> REF_197.price,TMP_313(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['currentEth', 'REF_198'] ,TMP_314(uint256) = _value - TMP_313,TMP_315(bool) = HIGH_LEVEL_CALL, dest:asset(ERC23), function:transfer, arguments:['_from', 'TMP_314']  ,TMP_316(bool) = TMP_312 && TMP_315,CONDITION TMP_316,REF_199(NamiExchange.OrderBid) -> bid[_buyer],REF_200(uint256) -> REF_199.eth,REF_200(uint256) (->bid) := 0(uint256),TMP_317(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['etherBalance', 'currentEth'] ,etherBalance(uint256) := TMP_317(uint256),REF_202(NamiExchange.OrderBid) -> bid[_buyer],REF_203(uint256) -> REF_202.price,REF_204(NamiExchange.OrderBid) -> bid[_buyer],REF_205(uint256) -> REF_204.eth,Emit UpdateBid(_buyer,REF_203,REF_205),RETURN True,TMP_319(bool) = HIGH_LEVEL_CALL, dest:asset(ERC23), function:transfer, arguments:['_from', '_value']  ,RETURN False,REF_208(NamiExchange.OrderBid) -> bid[_buyer],REF_209(uint256) -> REF_208.price,TMP_320(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_value', 'REF_209'] ,eth(uint256) := TMP_320(uint256),TMP_321 = SEND dest:_from value:eth,TMP_322(bool) = HIGH_LEVEL_CALL, dest:asset(ERC23), function:transfer, arguments:['_buyer', '_value']  ,TMP_323(bool) = TMP_321 && TMP_322,CONDITION TMP_323,REF_212(NamiExchange.OrderBid) -> bid[_buyer],REF_213(uint256) -> REF_212.eth,REF_214(NamiExchange.OrderBid) -> bid[_buyer],REF_215(uint256) -> REF_214.eth,TMP_324(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_215', 'eth'] ,REF_213(uint256) (->bid) := TMP_324(uint256),TMP_325(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['etherBalance', 'eth'] ,etherBalance(uint256) := TMP_325(uint256),REF_218(NamiExchange.OrderBid) -> bid[_buyer],REF_219(uint256) -> REF_218.price,REF_220(NamiExchange.OrderBid) -> bid[_buyer],REF_221(uint256) -> REF_220.eth,Emit UpdateBid(_buyer,REF_219,REF_221),RETURN True,TMP_327(bool) = HIGH_LEVEL_CALL, dest:asset(ERC23), function:transfer, arguments:['_from', '_value']  ,RETURN False,MODIFIER_CALL, NamiExchange.onlyNami()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->22;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
asset = ERC23(NamiAddr)

IRs:
TMP_306 = CONVERT NamiAddr to ERC23
asset(ERC23) := TMP_306(ERC23)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
currentEth = bid[_buyer].eth

IRs:
REF_185(NamiExchange.OrderBid) -> bid[_buyer]
REF_186(uint256) -> REF_185.eth
currentEth(uint256) := REF_186(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
(_value.div(bid[_buyer].price)) > currentEth

IRs:
REF_188(NamiExchange.OrderBid) -> bid[_buyer]
REF_189(uint256) -> REF_188.price
TMP_307(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_value', 'REF_189'] 
TMP_308(bool) = TMP_307 > currentEth
CONDITION TMP_308""];
3->4[label=""True""];
3->12[label=""False""];
4[label=""Node Type: IF 4

EXPRESSION:
_from.send(currentEth) && asset.transfer(_buyer,currentEth.mul(bid[_buyer].price)) && asset.transfer(_from,_value - (currentEth.mul(bid[_buyer].price)))

IRs:
TMP_309 = SEND dest:_from value:currentEth
REF_193(NamiExchange.OrderBid) -> bid[_buyer]
REF_194(uint256) -> REF_193.price
TMP_310(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['currentEth', 'REF_194'] 
TMP_311(bool) = HIGH_LEVEL_CALL, dest:asset(ERC23), function:transfer, arguments:['_buyer', 'TMP_310']  
TMP_312(bool) = TMP_309 && TMP_311
REF_197(NamiExchange.OrderBid) -> bid[_buyer]
REF_198(uint256) -> REF_197.price
TMP_313(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['currentEth', 'REF_198'] 
TMP_314(uint256) = _value - TMP_313
TMP_315(bool) = HIGH_LEVEL_CALL, dest:asset(ERC23), function:transfer, arguments:['_from', 'TMP_314']  
TMP_316(bool) = TMP_312 && TMP_315
CONDITION TMP_316""];
4->5[label=""True""];
4->9[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
bid[_buyer].eth = 0

IRs:
REF_199(NamiExchange.OrderBid) -> bid[_buyer]
REF_200(uint256) -> REF_199.eth
REF_200(uint256) (->bid) := 0(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
etherBalance = etherBalance.sub(currentEth)

IRs:
TMP_317(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['etherBalance', 'currentEth'] 
etherBalance(uint256) := TMP_317(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
UpdateBid(_buyer,bid[_buyer].price,bid[_buyer].eth)

IRs:
REF_202(NamiExchange.OrderBid) -> bid[_buyer]
REF_203(uint256) -> REF_202.price
REF_204(NamiExchange.OrderBid) -> bid[_buyer]
REF_205(uint256) -> REF_204.eth
Emit UpdateBid(_buyer,REF_203,REF_205)""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
asset.transfer(_from,_value)

IRs:
TMP_319(bool) = HIGH_LEVEL_CALL, dest:asset(ERC23), function:transfer, arguments:['_from', '_value']  ""];
9->10;
10[label=""Node Type: RETURN 10

EXPRESSION:
false

IRs:
RETURN False""];
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
eth = _value.div(bid[_buyer].price)

IRs:
REF_208(NamiExchange.OrderBid) -> bid[_buyer]
REF_209(uint256) -> REF_208.price
TMP_320(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_value', 'REF_209'] 
eth(uint256) := TMP_320(uint256)""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
_from.send(eth) && asset.transfer(_buyer,_value)

IRs:
TMP_321 = SEND dest:_from value:eth
TMP_322(bool) = HIGH_LEVEL_CALL, dest:asset(ERC23), function:transfer, arguments:['_buyer', '_value']  
TMP_323(bool) = TMP_321 && TMP_322
CONDITION TMP_323""];
13->14[label=""True""];
13->18[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
bid[_buyer].eth = (bid[_buyer].eth).sub(eth)

IRs:
REF_212(NamiExchange.OrderBid) -> bid[_buyer]
REF_213(uint256) -> REF_212.eth
REF_214(NamiExchange.OrderBid) -> bid[_buyer]
REF_215(uint256) -> REF_214.eth
TMP_324(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_215', 'eth'] 
REF_213(uint256) (->bid) := TMP_324(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
etherBalance = etherBalance.sub(eth)

IRs:
TMP_325(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['etherBalance', 'eth'] 
etherBalance(uint256) := TMP_325(uint256)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
UpdateBid(_buyer,bid[_buyer].price,bid[_buyer].eth)

IRs:
REF_218(NamiExchange.OrderBid) -> bid[_buyer]
REF_219(uint256) -> REF_218.price
REF_220(NamiExchange.OrderBid) -> bid[_buyer]
REF_221(uint256) -> REF_220.eth
Emit UpdateBid(_buyer,REF_219,REF_221)""];
16->17;
17[label=""Node Type: RETURN 17

EXPRESSION:
true

IRs:
RETURN True""];
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
asset.transfer(_from,_value)

IRs:
TMP_327(bool) = HIGH_LEVEL_CALL, dest:asset(ERC23), function:transfer, arguments:['_from', '_value']  ""];
18->19;
19[label=""Node Type: RETURN 19

EXPRESSION:
false

IRs:
RETURN False""];
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
onlyNami()

IRs:
MODIFIER_CALL, NamiExchange.onlyNami()()""];
22->1;
23[label=""Node Type: RETURN 23

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,0,0,0,"onlyNami();asset = ERC23(NamiAddr);currentEth = bid[_buyer].eth;(_value.div(bid[_buyer].price)) > currentEth;_from.send(currentEth) && asset.transfer(_buyer,currentEth.mul(bid[_buyer].price)) && asset.transfer(_from,_value - (currentEth.mul(bid[_buyer].price)));eth = _value.div(bid[_buyer].price);bid[_buyer].eth = 0;asset.transfer(_from,_value);etherBalance = etherBalance.sub(currentEth);UpdateBid(_buyer,bid[_buyer].price,bid[_buyer].eth);true;false;_from.send(eth) && asset.transfer(_buyer,_value);bid[_buyer].eth = (bid[_buyer].eth).sub(eth);asset.transfer(_from,_value);etherBalance = etherBalance.sub(eth);UpdateBid(_buyer,bid[_buyer].price,bid[_buyer].eth);true;false;success"
./0x5af9ec6df6edea0761fa841ce56c2e4deb000b31_ext.sol,ZebiMainCrowdsale.buyTokens,981,1020,"transStartTime(uint256) := now(uint256),REF_268(bool) -> goldList[beneficiary],REF_269(bool) -> kycAcceptedList[beneficiary],TMP_450(bool) = REF_268 || REF_269,TMP_451(None) = SOLIDITY_CALL require(bool)(TMP_450),goldListPeriodFlag(bool) := False(bool),TMP_452 = CONVERT 0 to address,TMP_453(bool) = beneficiary != TMP_452,TMP_454(None) = SOLIDITY_CALL require(bool)(TMP_453),TMP_455(bool) = INTERNAL_CALL, ZebiMainCrowdsale.validPurchase()(),TMP_456(None) = SOLIDITY_CALL require(bool)(TMP_455),extraEth(uint256) := 0(uint256),weiAmount(uint256) := msg.value(uint256),TMP_457(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['ethCap', 'mainWeiRaised'] ,TMP_458(bool) = msg.value > TMP_457,TMP_459 = UnaryType.BANG goldListPeriodFlag ,TMP_460(bool) = TMP_458 && TMP_459,CONDITION TMP_460,TMP_461(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['ethCap', 'mainWeiRaised'] ,weiAmount(uint256) := TMP_461(uint256),TMP_462(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.value', 'weiAmount'] ,extraEth(uint256) := TMP_462(uint256),TMP_463(uint256) = INTERNAL_CALL, ZebiMainCrowdsale.getTokenAmount(uint256)(weiAmount),tokens(uint256) := TMP_463(uint256),TMP_464(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['mainWeiRaised', 'weiAmount'] ,mainWeiRaised(uint256) := TMP_464(uint256),TMP_465(bool) = HIGH_LEVEL_CALL, dest:token(ZebiCoin), function:mint, arguments:['beneficiary', 'tokens']  ,REF_275(uint256) -> mainContribution[beneficiary],REF_276(uint256) -> mainContribution[beneficiary],TMP_466(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_276', 'weiAmount'] ,REF_275(uint256) (->mainContribution) := TMP_466(uint256),CONDITION goldListPeriodFlag,REF_278(uint256) -> goldListContribution[beneficiary],REF_279(uint256) -> goldListContribution[beneficiary],TMP_467(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_279', 'weiAmount'] ,REF_278(uint256) (->goldListContribution) := TMP_467(uint256),Emit TokenPurchase(beneficiary,weiAmount,tokens),INTERNAL_CALL, ZebiMainCrowdsale.forwardFunds()(),TMP_470(bool) = extraEth > 0,CONDITION TMP_470,Transfer dest:beneficiary value:extraEth","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
transStartTime = now

IRs:
transStartTime(uint256) := now(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(goldList[beneficiary] || kycAcceptedList[beneficiary])

IRs:
REF_268(bool) -> goldList[beneficiary]
REF_269(bool) -> kycAcceptedList[beneficiary]
TMP_450(bool) = REF_268 || REF_269
TMP_451(None) = SOLIDITY_CALL require(bool)(TMP_450)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
goldListPeriodFlag = false

IRs:
goldListPeriodFlag(bool) := False(bool)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(beneficiary != address(0))

IRs:
TMP_452 = CONVERT 0 to address
TMP_453(bool) = beneficiary != TMP_452
TMP_454(None) = SOLIDITY_CALL require(bool)(TMP_453)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(validPurchase())

IRs:
TMP_455(bool) = INTERNAL_CALL, ZebiMainCrowdsale.validPurchase()()
TMP_456(None) = SOLIDITY_CALL require(bool)(TMP_455)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
extraEth = 0

IRs:
extraEth(uint256) := 0(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
(msg.value > ethCap.sub(mainWeiRaised)) && ! goldListPeriodFlag

IRs:
TMP_457(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['ethCap', 'mainWeiRaised'] 
TMP_458(bool) = msg.value > TMP_457
TMP_459 = UnaryType.BANG goldListPeriodFlag 
TMP_460(bool) = TMP_458 && TMP_459
CONDITION TMP_460""];
8->9[label=""True""];
8->11[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
weiAmount = ethCap.sub(mainWeiRaised)

IRs:
TMP_461(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['ethCap', 'mainWeiRaised'] 
weiAmount(uint256) := TMP_461(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
extraEth = (msg.value).sub(weiAmount)

IRs:
TMP_462(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.value', 'weiAmount'] 
extraEth(uint256) := TMP_462(uint256)""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
tokens = getTokenAmount(weiAmount)

IRs:
TMP_463(uint256) = INTERNAL_CALL, ZebiMainCrowdsale.getTokenAmount(uint256)(weiAmount)
tokens(uint256) := TMP_463(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
mainWeiRaised = mainWeiRaised.add(weiAmount)

IRs:
TMP_464(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['mainWeiRaised', 'weiAmount'] 
mainWeiRaised(uint256) := TMP_464(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
token.mint(beneficiary,tokens)

IRs:
TMP_465(bool) = HIGH_LEVEL_CALL, dest:token(ZebiCoin), function:mint, arguments:['beneficiary', 'tokens']  ""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
mainContribution[beneficiary] = mainContribution[beneficiary].add(weiAmount)

IRs:
REF_275(uint256) -> mainContribution[beneficiary]
REF_276(uint256) -> mainContribution[beneficiary]
TMP_466(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_276', 'weiAmount'] 
REF_275(uint256) (->mainContribution) := TMP_466(uint256)""];
15->16;
16[label=""Node Type: IF 16

EXPRESSION:
goldListPeriodFlag

IRs:
CONDITION goldListPeriodFlag""];
16->17[label=""True""];
16->18[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
goldListContribution[beneficiary] = goldListContribution[beneficiary].add(weiAmount)

IRs:
REF_278(uint256) -> goldListContribution[beneficiary]
REF_279(uint256) -> goldListContribution[beneficiary]
TMP_467(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_279', 'weiAmount'] 
REF_278(uint256) (->goldListContribution) := TMP_467(uint256)""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
TokenPurchase(beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(beneficiary,weiAmount,tokens)""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
forwardFunds()

IRs:
INTERNAL_CALL, ZebiMainCrowdsale.forwardFunds()()""];
20->21;
21[label=""Node Type: IF 21

EXPRESSION:
extraEth > 0

IRs:
TMP_470(bool) = extraEth > 0
CONDITION TMP_470""];
21->22[label=""True""];
21->23[label=""False""];
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
beneficiary.transfer(extraEth)

IRs:
Transfer dest:beneficiary value:extraEth""];
22->23;
23[label=""Node Type: END_IF 23
""];
}
",1,0,0,0,"transStartTime = now;require(bool)(goldList[beneficiary] || kycAcceptedList[beneficiary]);goldListPeriodFlag = false;require(bool)(beneficiary != address(0));require(bool)(validPurchase());extraEth = 0;weiAmount = msg.value;(msg.value > ethCap.sub(mainWeiRaised)) && ! goldListPeriodFlag;weiAmount = ethCap.sub(mainWeiRaised);;extraEth = (msg.value).sub(weiAmount);tokens = getTokenAmount(weiAmount);mainWeiRaised = mainWeiRaised.add(weiAmount);token.mint(beneficiary,tokens);mainContribution[beneficiary] = mainContribution[beneficiary].add(weiAmount);goldListPeriodFlag;goldListContribution[beneficiary] = goldListContribution[beneficiary].add(weiAmount);;TokenPurchase(beneficiary,weiAmount,tokens);forwardFunds();extraEth > 0;beneficiary.transfer(extraEth);"
./0xed4fd2e53153b8bfd866e11fb015a1bc4a0e9655_ext.sol,Lottery.emergencyStop,152,163,"HIGH_LEVEL_CALL, dest:poohContract(POOH), function:exit, arguments:[]  ,TMP_22 = CONVERT this to address,TMP_23(uint256) = SOLIDITY_CALL balance(address)(TMP_22),balance(uint256) := TMP_23(uint256),Transfer dest:owner value:balance,openToPublic(bool) := False(bool),MODIFIER_CALL, Lottery.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
poohContract.exit()

IRs:
HIGH_LEVEL_CALL, dest:poohContract(POOH), function:exit, arguments:[]  ""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
balance = address(this).balance

IRs:
TMP_22 = CONVERT this to address
TMP_23(uint256) = SOLIDITY_CALL balance(address)(TMP_22)
balance(uint256) := TMP_23(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(balance)

IRs:
Transfer dest:owner value:balance""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
openToPublic = false

IRs:
openToPublic(bool) := False(bool)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Lottery.onlyOwner()()""];
5->1;
}
",1,0,0,0,onlyOwner();poohContract.exit();balance = address(this).balance;owner.transfer(balance);openToPublic = false
./0x26fb86579e371c7aedc461b2ddef0a8628c93d3b_ext.sol,LockedToken.claim,255,262,"TMP_211(bool) = now >= releaseTime,TMP_212(None) = SOLIDITY_CALL require(bool)(TMP_211),TMP_213(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Basic), function:balanceOf, arguments:['this']  ,amount(uint256) := TMP_213(uint256),TMP_214(bool) = amount > 0,TMP_215(None) = SOLIDITY_CALL require(bool)(TMP_214),TMP_216(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Basic), function:transfer, arguments:['beneficiary', 'amount']  ,Emit Claim(beneficiary,amount,releaseTime)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now >= releaseTime)

IRs:
TMP_211(bool) = now >= releaseTime
TMP_212(None) = SOLIDITY_CALL require(bool)(TMP_211)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = token.balanceOf(this)

IRs:
TMP_213(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Basic), function:balanceOf, arguments:['this']  
amount(uint256) := TMP_213(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_214(bool) = amount > 0
TMP_215(None) = SOLIDITY_CALL require(bool)(TMP_214)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(beneficiary,amount)

IRs:
TMP_216(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Basic), function:transfer, arguments:['beneficiary', 'amount']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Claim(beneficiary,amount,releaseTime)

IRs:
Emit Claim(beneficiary,amount,releaseTime)""];
}
",1,0,0,0,"require(bool)(now >= releaseTime);amount = token.balanceOf(this);require(bool)(amount > 0);token.transfer(beneficiary,amount);Claim(beneficiary,amount,releaseTime)"
./0x890ee942fdce38034e3d3813344649c77a29e68f_ext.sol,LemonSelfDrop1.withdrawKittenCoins,120,123,"TMP_30(uint256) = HIGH_LEVEL_CALL, dest:LemonContract(LemonToken), function:balanceOf, arguments:['this']  ,TMP_31(bool) = HIGH_LEVEL_CALL, dest:LemonContract(LemonToken), function:transfer, arguments:['owner', 'TMP_30']  ,LemonsRemainingToDrop(uint256) := 0(uint256),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
LemonContract.transfer(owner,LemonContract.balanceOf(this))

IRs:
TMP_30(uint256) = HIGH_LEVEL_CALL, dest:LemonContract(LemonToken), function:balanceOf, arguments:['this']  
TMP_31(bool) = HIGH_LEVEL_CALL, dest:LemonContract(LemonToken), function:transfer, arguments:['owner', 'TMP_30']  ""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
LemonsRemainingToDrop = 0

IRs:
LemonsRemainingToDrop(uint256) := 0(uint256)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
3->1;
}
",1,0,0,0,"onlyOwner();LemonContract.transfer(owner,LemonContract.balanceOf(this));LemonsRemainingToDrop = 0"
./0x286bbee3f20f1702e707e58d33dc28a69e7efd4e_ext.sol,Contract.buy_the_tokens,114,122,"TMP_21 = UnaryType.BANG bought_tokens ,TMP_22(bool) = sale != 0,TMP_23(bool) = TMP_21 && TMP_22,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),bought_tokens(bool) := True(bool),REF_2(uint256) = SOLIDITY_CALL balance(address)(this),const_contract_eth_value(uint256) := REF_2([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E330FCA0>]),INTERNAL_CALL, Contract.take_fees_eth_dev()(),INTERNAL_CALL, Contract.take_fees_eth_owner()(),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),const_contract_eth_value(uint256) := REF_3([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E330FE80>]),REF_7(uint256) = SOLIDITY_CALL balance(address)(this),TMP_29(bool) = LOW_LEVEL_CALL, dest:sale, function:call, arguments:['_data'] value:REF_7 gas:msg.gas,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),MODIFIER_CALL, Controller.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! bought_tokens && sale != 0x0)

IRs:
TMP_21 = UnaryType.BANG bought_tokens 
TMP_22(bool) = sale != 0
TMP_23(bool) = TMP_21 && TMP_22
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
bought_tokens = true

IRs:
bought_tokens(bool) := True(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
const_contract_eth_value = this.balance

IRs:
REF_2(uint256) = SOLIDITY_CALL balance(address)(this)
const_contract_eth_value(uint256) := REF_2([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E330FCA0>])""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
take_fees_eth_dev()

IRs:
INTERNAL_CALL, Contract.take_fees_eth_dev()()""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
take_fees_eth_owner()

IRs:
INTERNAL_CALL, Contract.take_fees_eth_owner()()""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
const_contract_eth_value = this.balance

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
const_contract_eth_value(uint256) := REF_3([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E330FE80>])""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(sale.call.gas(msg.gas).value(this.balance)(_data))

IRs:
REF_7(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_29(bool) = LOW_LEVEL_CALL, dest:sale, function:call, arguments:['_data'] value:REF_7 gas:msg.gas
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Controller.onlyOwner()()""];
8->1;
}
",1,0,0,0,onlyOwner();require(bool)(! bought_tokens && sale != 0x0);bought_tokens = true;const_contract_eth_value = this.balance;take_fees_eth_dev();take_fees_eth_owner();const_contract_eth_value = this.balance;require(bool)(sale.call.gas(msg.gas).value(this.balance)(_data))
./0x65061cfa23aa566316b0215c9eecabeafd4d9e81_ext.sol,Crowdsale.buyTokens,140,166,"TMP_23(bool) = beneficiary != 0,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),TMP_25(bool) = INTERNAL_CALL, Crowdsale.validPurchase()(),TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),weiAmount(uint256) := msg.value(uint256),TMP_27(uint256) = 10 ** 10,TMP_28(uint256) = weiAmount / TMP_27,TMP_29(uint256) = TMP_28 * price,tokens(uint256) := TMP_29(uint256),TMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] ,weiRaised(uint256) := TMP_30(uint256),HIGH_LEVEL_CALL, dest:tokenReward1(token), function:transfer, arguments:['beneficiary', 'tokens']  ,HIGH_LEVEL_CALL, dest:tokenReward2(token), function:transfer, arguments:['beneficiary', 'tokens']  ,HIGH_LEVEL_CALL, dest:tokenReward3(token), function:transfer, arguments:['beneficiary', 'tokens']  ,HIGH_LEVEL_CALL, dest:tokenReward4(token), function:transfer, arguments:['beneficiary', 'tokens']  ,HIGH_LEVEL_CALL, dest:tokenReward5(token), function:transfer, arguments:['beneficiary', 'tokens']  ,Emit TokenPurchase(msg.sender,beneficiary,weiAmount,tokens),INTERNAL_CALL, Crowdsale.forwardFunds()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != 0x0)

IRs:
TMP_23(bool) = beneficiary != 0
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(validPurchase())

IRs:
TMP_25(bool) = INTERNAL_CALL, Crowdsale.validPurchase()()
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
tokens = (weiAmount / 10 ** 10) * price

IRs:
TMP_27(uint256) = 10 ** 10
TMP_28(uint256) = weiAmount / TMP_27
TMP_29(uint256) = TMP_28 * price
tokens(uint256) := TMP_29(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_30(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tokenReward1.transfer(beneficiary,tokens)

IRs:
HIGH_LEVEL_CALL, dest:tokenReward1(token), function:transfer, arguments:['beneficiary', 'tokens']  ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokenReward2.transfer(beneficiary,tokens)

IRs:
HIGH_LEVEL_CALL, dest:tokenReward2(token), function:transfer, arguments:['beneficiary', 'tokens']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
tokenReward3.transfer(beneficiary,tokens)

IRs:
HIGH_LEVEL_CALL, dest:tokenReward3(token), function:transfer, arguments:['beneficiary', 'tokens']  ""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
tokenReward4.transfer(beneficiary,tokens)

IRs:
HIGH_LEVEL_CALL, dest:tokenReward4(token), function:transfer, arguments:['beneficiary', 'tokens']  ""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
tokenReward5.transfer(beneficiary,tokens)

IRs:
HIGH_LEVEL_CALL, dest:tokenReward5(token), function:transfer, arguments:['beneficiary', 'tokens']  ""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
forwardFunds()

IRs:
INTERNAL_CALL, Crowdsale.forwardFunds()()""];
}
",1,0,0,0,"require(bool)(beneficiary != 0x0);require(bool)(validPurchase());weiAmount = msg.value;tokens = (weiAmount / 10 ** 10) * price;weiRaised = weiRaised.add(weiAmount);tokenReward1.transfer(beneficiary,tokens);tokenReward2.transfer(beneficiary,tokens);tokenReward3.transfer(beneficiary,tokens);tokenReward4.transfer(beneficiary,tokens);tokenReward5.transfer(beneficiary,tokens);TokenPurchase(msg.sender,beneficiary,weiAmount,tokens);forwardFunds()"
./0x18da8521c333aed9de8f512e847734cb7be42e38_ext.sol,Crowdsale.finalize,310,325,"TMP_128(bool) = now < endTime,CONDITION TMP_128,TMP_129(bool) = coinSentToEther == MAX_CAP,CONDITION TMP_129,TMP_130(bool) = coinSentToEther < MIN_CAP,TMP_131(uint256) = endTime + 259200,TMP_132(bool) = now < TMP_131,TMP_133(bool) = TMP_130 && TMP_132,CONDITION TMP_133,REF_94(uint256) = SOLIDITY_CALL balance(address)(this),TMP_134 = SEND dest:multisigEther value:REF_94,TMP_135 = UnaryType.BANG TMP_134 ,CONDITION TMP_135,TMP_136(uint256) = HIGH_LEVEL_CALL, dest:coin(ProjectX), function:balanceOf, arguments:['this']  ,remains(uint256) := TMP_136(uint256),TMP_137(bool) = remains > 0,CONDITION TMP_137,TMP_138(bool) = HIGH_LEVEL_CALL, dest:coin(ProjectX), function:burn, arguments:['remains']  ,TMP_139 = UnaryType.BANG TMP_138 ,CONDITION TMP_139,crowdsaleClosed(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->19;
1[label=""Node Type: IF 1

EXPRESSION:
now < endTime

IRs:
TMP_128(bool) = now < endTime
CONDITION TMP_128""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
coinSentToEther == MAX_CAP

IRs:
TMP_129(bool) = coinSentToEther == MAX_CAP
CONDITION TMP_129""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: THROW 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
coinSentToEther < MIN_CAP && now < endTime + 259200

IRs:
TMP_130(bool) = coinSentToEther < MIN_CAP
TMP_131(uint256) = endTime + 259200
TMP_132(bool) = now < TMP_131
TMP_133(bool) = TMP_130 && TMP_132
CONDITION TMP_133""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: THROW 7
""];
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
! multisigEther.send(this.balance)

IRs:
REF_94(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_134 = SEND dest:multisigEther value:REF_94
TMP_135 = UnaryType.BANG TMP_134 
CONDITION TMP_135""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: THROW 10
""];
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
remains = coin.balanceOf(this)

IRs:
TMP_136(uint256) = HIGH_LEVEL_CALL, dest:coin(ProjectX), function:balanceOf, arguments:['this']  
remains(uint256) := TMP_136(uint256)""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
remains > 0

IRs:
TMP_137(bool) = remains > 0
CONDITION TMP_137""];
13->14[label=""True""];
13->17[label=""False""];
14[label=""Node Type: IF 14

EXPRESSION:
! coin.burn(remains)

IRs:
TMP_138(bool) = HIGH_LEVEL_CALL, dest:coin(ProjectX), function:burn, arguments:['remains']  
TMP_139 = UnaryType.BANG TMP_138 
CONDITION TMP_139""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: THROW 15
""];
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
crowdsaleClosed = true

IRs:
crowdsaleClosed(bool) := True(bool)""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
19->1;
}
",1,0,1,0,onlyOwner();now < endTime;coinSentToEther == MAX_CAP;;;;coinSentToEther < MIN_CAP && now < endTime + 259200;;;! multisigEther.send(this.balance);;;remains = coin.balanceOf(this);remains > 0;! coin.burn(remains);;;;crowdsaleClosed = true
./0x29880855d419c6fa0e8c7fdfd985c80f286d914e_ext.sol,DadiPublicSale.closeSale,398,410,"REF_53(DadiPublicSale.SaleState) -> SaleState.Closed,state(DadiPublicSale.SaleState) := REF_53(DadiPublicSale.SaleState),Emit LogStateChange(state),TMP_103(uint256) = INTERNAL_CALL, DadiPublicSale.getTokensAvailable()(),remaining(uint256) := TMP_103(uint256),INTERNAL_CALL, DadiPublicSale.updateSaleParameters(uint256)(remaining),TMP_105(bool) = remaining > 0,CONDITION TMP_105,TMP_106(bool) = HIGH_LEVEL_CALL, dest:token(StandardToken), function:transfer, arguments:['recipient', 'remaining']  ,Emit LogRedistributeTokens(recipient,state,remaining),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
state = SaleState.Closed

IRs:
REF_53(DadiPublicSale.SaleState) -> SaleState.Closed
state(DadiPublicSale.SaleState) := REF_53(DadiPublicSale.SaleState)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
LogStateChange(state)

IRs:
Emit LogStateChange(state)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
remaining = getTokensAvailable()

IRs:
TMP_103(uint256) = INTERNAL_CALL, DadiPublicSale.getTokensAvailable()()
remaining(uint256) := TMP_103(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
updateSaleParameters(remaining)

IRs:
INTERNAL_CALL, DadiPublicSale.updateSaleParameters(uint256)(remaining)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
remaining > 0

IRs:
TMP_105(bool) = remaining > 0
CONDITION TMP_105""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
token.transfer(recipient,remaining)

IRs:
TMP_106(bool) = HIGH_LEVEL_CALL, dest:token(StandardToken), function:transfer, arguments:['recipient', 'remaining']  ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
LogRedistributeTokens(recipient,state,remaining)

IRs:
Emit LogRedistributeTokens(recipient,state,remaining)""];
7->8;
8[label=""Node Type: END_IF 8
""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
9->1;
}
",1,0,0,0,"onlyOwner();state = SaleState.Closed;LogStateChange(state);remaining = getTokensAvailable();updateSaleParameters(remaining);remaining > 0;token.transfer(recipient,remaining);;LogRedistributeTokens(recipient,state,remaining)"
./0x302eb72befc8af539432ec32c39423525412748f_ext.sol,ZRSToken.refundTokens,355,361,"TMP_111(bool) = msg.sender == owner,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113 = CONVERT this to address,TMP_114(bool) = _token != TMP_113,TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114),TMP_116 = CONVERT _token to AbstractToken,token(AbstractToken) := TMP_116(AbstractToken),TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ,Emit RefundTokens(_token,_refund,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_111(bool) = msg.sender == owner
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_113 = CONVERT this to address
TMP_114(bool) = _token != TMP_113
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
token = AbstractToken(_token)

IRs:
TMP_116 = CONVERT _token to AbstractToken
token(AbstractToken) := TMP_116(AbstractToken)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(_refund,_value)

IRs:
TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RefundTokens(_token,_refund,_value)

IRs:
Emit RefundTokens(_token,_refund,_value)""];
}
",1,0,0,0,"require(bool)(msg.sender == owner);require(bool)(_token != address(this));token = AbstractToken(_token);token.transfer(_refund,_value);RefundTokens(_token,_refund,_value)"
./0x6593a7140f3718efff638b72a9b6083db47ce0d2_ext.sol,Crowdsale.finalize,372,378,"TMP_109(bool) = INTERNAL_CALL, Crowdsale.hasEnded()(),TMP_110(None) = SOLIDITY_CALL require(bool)(TMP_109),isFinalized(bool) := True(bool),INTERNAL_CALL, Crowdsale.finalization()(),Emit Finalized()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(hasEnded())

IRs:
TMP_109(bool) = INTERNAL_CALL, Crowdsale.hasEnded()()
TMP_110(None) = SOLIDITY_CALL require(bool)(TMP_109)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isFinalized = true

IRs:
isFinalized(bool) := True(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
finalization()

IRs:
INTERNAL_CALL, Crowdsale.finalization()()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Finalized()

IRs:
Emit Finalized()""];
}
",1,0,0,0,require(bool)(hasEnded());isFinalized = true;finalization();Finalized()
./0xcefa3e88393cf17c9b4dc6c9fe5357dfae8036d6_ext.sol,Registry.setCompleted,111,113,"completed(bool) := compl(bool),MODIFIER_CALL, Registry.onlyPermitted()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
completed = compl

IRs:
completed(bool) := compl(bool)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyPermitted()

IRs:
MODIFIER_CALL, Registry.onlyPermitted()()""];
2->1;
}
",1,0,0,0,onlyPermitted();completed = compl
./0x850c430378909ba9ff2494d0a4df17928e99f8f4_ext.sol,BdpOwnership.approve,738,747,"TMP_380(address) = LIBRARY_CALL, dest:BdpContracts, function:BdpContracts.getBdpOwnershipStorage(address[16]), arguments:['_contracts'] ,TMP_381 = CONVERT TMP_380 to BdpOwnershipStorage,ownStorage(BdpOwnershipStorage) := TMP_381(BdpOwnershipStorage),TMP_382(address) = INTERNAL_CALL, BdpOwnership.ownerOf(address[16],uint256)(_contracts,_tokenId),owner(address) := TMP_382(address),TMP_383(bool) = _to != owner,TMP_384(None) = SOLIDITY_CALL require(bool)(TMP_383),TMP_385(address) = HIGH_LEVEL_CALL, dest:ownStorage(BdpOwnershipStorage), function:getTokenApproval, arguments:['_tokenId']  ,TMP_386(bool) = TMP_385 != 0,TMP_387(bool) = _to != 0,TMP_388(bool) = TMP_386 || TMP_387,CONDITION TMP_388,HIGH_LEVEL_CALL, dest:ownStorage(BdpOwnershipStorage), function:setTokenApproval, arguments:['_tokenId', '_to']  ,Emit Approval(owner,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts))

IRs:
TMP_380(address) = LIBRARY_CALL, dest:BdpContracts, function:BdpContracts.getBdpOwnershipStorage(address[16]), arguments:['_contracts'] 
TMP_381 = CONVERT TMP_380 to BdpOwnershipStorage
ownStorage(BdpOwnershipStorage) := TMP_381(BdpOwnershipStorage)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
owner = ownerOf(_contracts,_tokenId)

IRs:
TMP_382(address) = INTERNAL_CALL, BdpOwnership.ownerOf(address[16],uint256)(_contracts,_tokenId)
owner(address) := TMP_382(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_to != owner)

IRs:
TMP_383(bool) = _to != owner
TMP_384(None) = SOLIDITY_CALL require(bool)(TMP_383)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
ownStorage.getTokenApproval(_tokenId) != 0 || _to != 0

IRs:
TMP_385(address) = HIGH_LEVEL_CALL, dest:ownStorage(BdpOwnershipStorage), function:getTokenApproval, arguments:['_tokenId']  
TMP_386(bool) = TMP_385 != 0
TMP_387(bool) = _to != 0
TMP_388(bool) = TMP_386 || TMP_387
CONDITION TMP_388""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
ownStorage.setTokenApproval(_tokenId,_to)

IRs:
HIGH_LEVEL_CALL, dest:ownStorage(BdpOwnershipStorage), function:setTokenApproval, arguments:['_tokenId', '_to']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Approval(owner,_to,_tokenId)

IRs:
Emit Approval(owner,_to,_tokenId)""];
6->7;
7[label=""Node Type: END_IF 7
""];
}
",1,0,0,0,"ownStorage = BdpOwnershipStorage(BdpContracts.getBdpOwnershipStorage(_contracts));owner = ownerOf(_contracts,_tokenId);require(bool)(_to != owner);ownStorage.getTokenApproval(_tokenId) != 0 || _to != 0;ownStorage.setTokenApproval(_tokenId,_to);;Approval(owner,_to,_tokenId)"
./0x0ce95ef378059f38c5fa21e6d81a5895c0d9911b_ext.sol,Game.RemoveRocketForSale,387,401,"TMP_166(bytes32) = HIGH_LEVEL_CALL, dest:m_Database(AbstractDatabase), function:Load, arguments:['NullAddress', 'RocketCategory', 'rocket_id']  ,TMP_167(RocketTypes.Rocket) = LIBRARY_CALL, dest:RocketTypes, function:RocketTypes.DeserializeRocket(bytes32), arguments:['TMP_166'] ,rocket(RocketTypes.Rocket) := TMP_167(RocketTypes.Rocket),REF_114(uint8) -> rocket.m_Version,TMP_168(bool) = REF_114 > 0,TMP_169(None) = SOLIDITY_CALL require(bool)(TMP_168),REF_115(uint8) -> rocket.m_IsForSale,TMP_170(bool) = REF_115 == 1,TMP_171(None) = SOLIDITY_CALL require(bool)(TMP_170),TMP_172(bytes32) = HIGH_LEVEL_CALL, dest:m_Database(AbstractDatabase), function:Load, arguments:['NullAddress', 'OwnershipCategory', 'rocket_id']  ,TMP_173(OwnershipTypes.Ownership) = LIBRARY_CALL, dest:OwnershipTypes, function:OwnershipTypes.DeserializeOwnership(bytes32), arguments:['TMP_172'] ,ownership(OwnershipTypes.Ownership) := TMP_173(OwnershipTypes.Ownership),REF_118(address) -> ownership.m_Owner,TMP_174(bool) = REF_118 == msg.sender,TMP_175(None) = SOLIDITY_CALL require(bool)(TMP_174),REF_119(uint8) -> rocket.m_IsForSale,REF_119(uint8) (->rocket) := 0(uint256),TMP_176(bytes32) = LIBRARY_CALL, dest:RocketTypes, function:RocketTypes.SerializeRocket(RocketTypes.Rocket), arguments:['rocket'] ,HIGH_LEVEL_CALL, dest:m_Database(AbstractDatabase), function:Store, arguments:['NullAddress', 'RocketCategory', 'rocket_id', 'TMP_176']  ,Emit RemoveRocketForSaleEvent(msg.sender,rocket_id),MODIFIER_CALL, Game.NotWhilePaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
rocket = RocketTypes.DeserializeRocket(m_Database.Load(NullAddress,RocketCategory,rocket_id))

IRs:
TMP_166(bytes32) = HIGH_LEVEL_CALL, dest:m_Database(AbstractDatabase), function:Load, arguments:['NullAddress', 'RocketCategory', 'rocket_id']  
TMP_167(RocketTypes.Rocket) = LIBRARY_CALL, dest:RocketTypes, function:RocketTypes.DeserializeRocket(bytes32), arguments:['TMP_166'] 
rocket(RocketTypes.Rocket) := TMP_167(RocketTypes.Rocket)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(rocket.m_Version > 0)

IRs:
REF_114(uint8) -> rocket.m_Version
TMP_168(bool) = REF_114 > 0
TMP_169(None) = SOLIDITY_CALL require(bool)(TMP_168)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(rocket.m_IsForSale == 1)

IRs:
REF_115(uint8) -> rocket.m_IsForSale
TMP_170(bool) = REF_115 == 1
TMP_171(None) = SOLIDITY_CALL require(bool)(TMP_170)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
ownership = OwnershipTypes.DeserializeOwnership(m_Database.Load(NullAddress,OwnershipCategory,rocket_id))

IRs:
TMP_172(bytes32) = HIGH_LEVEL_CALL, dest:m_Database(AbstractDatabase), function:Load, arguments:['NullAddress', 'OwnershipCategory', 'rocket_id']  
TMP_173(OwnershipTypes.Ownership) = LIBRARY_CALL, dest:OwnershipTypes, function:OwnershipTypes.DeserializeOwnership(bytes32), arguments:['TMP_172'] 
ownership(OwnershipTypes.Ownership) := TMP_173(OwnershipTypes.Ownership)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(ownership.m_Owner == msg.sender)

IRs:
REF_118(address) -> ownership.m_Owner
TMP_174(bool) = REF_118 == msg.sender
TMP_175(None) = SOLIDITY_CALL require(bool)(TMP_174)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
rocket.m_IsForSale = 0

IRs:
REF_119(uint8) -> rocket.m_IsForSale
REF_119(uint8) (->rocket) := 0(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
m_Database.Store(NullAddress,RocketCategory,rocket_id,RocketTypes.SerializeRocket(rocket))

IRs:
TMP_176(bytes32) = LIBRARY_CALL, dest:RocketTypes, function:RocketTypes.SerializeRocket(RocketTypes.Rocket), arguments:['rocket'] 
HIGH_LEVEL_CALL, dest:m_Database(AbstractDatabase), function:Store, arguments:['NullAddress', 'RocketCategory', 'rocket_id', 'TMP_176']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
RemoveRocketForSaleEvent(msg.sender,rocket_id)

IRs:
Emit RemoveRocketForSaleEvent(msg.sender,rocket_id)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
NotWhilePaused()

IRs:
MODIFIER_CALL, Game.NotWhilePaused()()""];
9->1;
}
",1,0,0,0,"NotWhilePaused();rocket = RocketTypes.DeserializeRocket(m_Database.Load(NullAddress,RocketCategory,rocket_id));require(bool)(rocket.m_Version > 0);require(bool)(rocket.m_IsForSale == 1);ownership = OwnershipTypes.DeserializeOwnership(m_Database.Load(NullAddress,OwnershipCategory,rocket_id));require(bool)(ownership.m_Owner == msg.sender);rocket.m_IsForSale = 0;m_Database.Store(NullAddress,RocketCategory,rocket_id,RocketTypes.SerializeRocket(rocket));RemoveRocketForSaleEvent(msg.sender,rocket_id)"
./0xf244176246168f24e3187f7288edbca29267739b_ext.sol,HavvenEscrow.appendVestingEntry,2155,2176,"TMP_887(bool) = now < time,TMP_888(None) = SOLIDITY_CALL require(bool)(TMP_887),TMP_889(bool) = quantity != 0,TMP_890(None) = SOLIDITY_CALL require(bool)(TMP_889),TMP_891(uint256) = INTERNAL_CALL, SafeDecimalMath.safeAdd(uint256,uint256)(totalVestedBalance,quantity),totalVestedBalance(uint256) := TMP_891(uint256),TMP_892(uint256) = HIGH_LEVEL_CALL, dest:havven(Havven), function:balanceOf, arguments:['this']  ,TMP_893(bool) = totalVestedBalance <= TMP_892,TMP_894(None) = SOLIDITY_CALL require(bool)(TMP_893),REF_161(uint256[2][]) -> vestingSchedules[account],REF_162 -> LENGTH REF_161,TMP_895(bool) = REF_162 == 0,CONDITION TMP_895,REF_163(uint256) -> totalVestedAccountBalance[account],REF_163(uint256) (->totalVestedAccountBalance) := quantity(uint256),TMP_896(uint256) = INTERNAL_CALL, HavvenEscrow.numVestingEntries(address)(account),TMP_897(uint256) = TMP_896 - 1,TMP_898(uint256) = INTERNAL_CALL, HavvenEscrow.getVestingTime(address,uint256)(account,TMP_897),TMP_899(bool) = TMP_898 < time,TMP_900(None) = SOLIDITY_CALL require(bool)(TMP_899),REF_164(uint256) -> totalVestedAccountBalance[account],REF_165(uint256) -> totalVestedAccountBalance[account],TMP_901(uint256) = INTERNAL_CALL, SafeDecimalMath.safeAdd(uint256,uint256)(REF_165,quantity),REF_164(uint256) (->totalVestedAccountBalance) := TMP_901(uint256),REF_166(uint256[2][]) -> vestingSchedules[account],REF_168 -> LENGTH REF_166,TMP_903(uint256) := REF_168(uint256),TMP_904(uint256) = TMP_903 + 1,REF_168(uint256) (->vestingSchedules) := TMP_904(uint256),REF_169(uint256[2]) -> REF_166[TMP_903],TMP_905(uint256[2]) = ['time(uint256)', 'quantity(uint256)'],REF_169(uint256[2]) (->vestingSchedules) := TMP_905(uint256[2]),MODIFIER_CALL, Owned.onlyOwner()(),MODIFIER_CALL, LimitedSetup.setupFunction()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now < time)

IRs:
TMP_887(bool) = now < time
TMP_888(None) = SOLIDITY_CALL require(bool)(TMP_887)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(quantity != 0)

IRs:
TMP_889(bool) = quantity != 0
TMP_890(None) = SOLIDITY_CALL require(bool)(TMP_889)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalVestedBalance = safeAdd(totalVestedBalance,quantity)

IRs:
TMP_891(uint256) = INTERNAL_CALL, SafeDecimalMath.safeAdd(uint256,uint256)(totalVestedBalance,quantity)
totalVestedBalance(uint256) := TMP_891(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(totalVestedBalance <= havven.balanceOf(this))

IRs:
TMP_892(uint256) = HIGH_LEVEL_CALL, dest:havven(Havven), function:balanceOf, arguments:['this']  
TMP_893(bool) = totalVestedBalance <= TMP_892
TMP_894(None) = SOLIDITY_CALL require(bool)(TMP_893)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
vestingSchedules[account].length == 0

IRs:
REF_161(uint256[2][]) -> vestingSchedules[account]
REF_162 -> LENGTH REF_161
TMP_895(bool) = REF_162 == 0
CONDITION TMP_895""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
totalVestedAccountBalance[account] = quantity

IRs:
REF_163(uint256) -> totalVestedAccountBalance[account]
REF_163(uint256) (->totalVestedAccountBalance) := quantity(uint256)""];
6->9;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(getVestingTime(account,numVestingEntries(account) - 1) < time)

IRs:
TMP_896(uint256) = INTERNAL_CALL, HavvenEscrow.numVestingEntries(address)(account)
TMP_897(uint256) = TMP_896 - 1
TMP_898(uint256) = INTERNAL_CALL, HavvenEscrow.getVestingTime(address,uint256)(account,TMP_897)
TMP_899(bool) = TMP_898 < time
TMP_900(None) = SOLIDITY_CALL require(bool)(TMP_899)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
totalVestedAccountBalance[account] = safeAdd(totalVestedAccountBalance[account],quantity)

IRs:
REF_164(uint256) -> totalVestedAccountBalance[account]
REF_165(uint256) -> totalVestedAccountBalance[account]
TMP_901(uint256) = INTERNAL_CALL, SafeDecimalMath.safeAdd(uint256,uint256)(REF_165,quantity)
REF_164(uint256) (->totalVestedAccountBalance) := TMP_901(uint256)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
vestingSchedules[account].push((time,quantity))

IRs:
REF_166(uint256[2][]) -> vestingSchedules[account]
REF_168 -> LENGTH REF_166
TMP_903(uint256) := REF_168(uint256)
TMP_904(uint256) = TMP_903 + 1
REF_168(uint256) (->vestingSchedules) := TMP_904(uint256)
REF_169(uint256[2]) -> REF_166[TMP_903]
TMP_905(uint256[2]) = ['time(uint256)', 'quantity(uint256)']
REF_169(uint256[2]) (->vestingSchedules) := TMP_905(uint256[2])""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
setupFunction()

IRs:
MODIFIER_CALL, LimitedSetup.setupFunction()()""];
12->1;
}
",1,0,0,0,"onlyOwner();require(bool)(now < time);require(bool)(quantity != 0);totalVestedBalance = safeAdd(totalVestedBalance,quantity);require(bool)(totalVestedBalance <= havven.balanceOf(this));vestingSchedules[account].length == 0;totalVestedAccountBalance[account] = quantity;require(bool)(getVestingTime(account,numVestingEntries(account) - 1) < time);;totalVestedAccountBalance[account] = safeAdd(totalVestedAccountBalance[account],quantity);vestingSchedules[account].push((time,quantity));setupFunction()"
./0x1c8654c680c3f18a3b3a0ee943d40848a9fffd0d_ext.sol,Crowdsale.buyTokens,215,238,"weiAmount(uint256) := msg.value(uint256),INTERNAL_CALL, Crowdsale._preValidatePurchase(address,uint256)(_beneficiary,weiAmount),TMP_34(uint256) = INTERNAL_CALL, Crowdsale._getTokenAmount(uint256)(weiAmount),tokens(uint256) := TMP_34(uint256),TMP_35(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] ,weiRaised(uint256) := TMP_35(uint256),INTERNAL_CALL, Crowdsale._processPurchase(address,uint256)(_beneficiary,tokens),Emit TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens),INTERNAL_CALL, Crowdsale._updatePurchasingState(address,uint256)(_beneficiary,weiAmount),INTERNAL_CALL, Crowdsale._forwardFunds()(),INTERNAL_CALL, Crowdsale._postValidatePurchase(address,uint256)(_beneficiary,weiAmount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_preValidatePurchase(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._preValidatePurchase(address,uint256)(_beneficiary,weiAmount)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
tokens = _getTokenAmount(weiAmount)

IRs:
TMP_34(uint256) = INTERNAL_CALL, Crowdsale._getTokenAmount(uint256)(weiAmount)
tokens(uint256) := TMP_34(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_35(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_35(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_processPurchase(_beneficiary,tokens)

IRs:
INTERNAL_CALL, Crowdsale._processPurchase(address,uint256)(_beneficiary,tokens)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
_updatePurchasingState(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._updatePurchasingState(address,uint256)(_beneficiary,weiAmount)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
_forwardFunds()

IRs:
INTERNAL_CALL, Crowdsale._forwardFunds()()""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
_postValidatePurchase(_beneficiary,weiAmount)

IRs:
INTERNAL_CALL, Crowdsale._postValidatePurchase(address,uint256)(_beneficiary,weiAmount)""];
}
",1,0,0,0,"weiAmount = msg.value;_preValidatePurchase(_beneficiary,weiAmount);tokens = _getTokenAmount(weiAmount);weiRaised = weiRaised.add(weiAmount);_processPurchase(_beneficiary,tokens);TokenPurchase(msg.sender,_beneficiary,weiAmount,tokens);_updatePurchasingState(_beneficiary,weiAmount);_forwardFunds();_postValidatePurchase(_beneficiary,weiAmount)"
./0x0d853d20b54b8abfacb05fc5e81e8d4395021c01_ext.sol,LxtBountyDistribution.transferToken,358,366,"REF_129(LxtBountyDistribution.Allocation) -> allocations[_recipient],allocation(LxtBountyDistribution.Allocation) := REF_129(LxtBountyDistribution.Allocation),REF_130(uint256) -> allocation.totalAllocated,TMP_172(bool) = REF_130 > 0,CONDITION TMP_172,REF_131(uint256) -> allocation.totalAllocated,REF_133(uint256) -> allocation.amountClaimed,TMP_173(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_131', 'REF_133'] ,amount(uint256) := TMP_173(uint256),TMP_174(bool) = HIGH_LEVEL_CALL, dest:LXT(LexitToken), function:transferFrom, arguments:['LXT_OWNER', '_recipient', 'amount']  ,TMP_175(None) = SOLIDITY_CALL require(bool)(TMP_174),REF_135(uint256) -> allocation.amountClaimed,REF_136(uint256) -> allocation.amountClaimed,TMP_176(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_136', 'amount'] ,REF_135(uint256) (->allocation) := TMP_176(uint256),TMP_177(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['grandTotalClaimed', 'amount'] ,grandTotalClaimed(uint256) := TMP_177(uint256),MODIFIER_CALL, LxtBountyDistribution.onlyOwnerOrAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
allocation = allocations[_recipient]

IRs:
REF_129(LxtBountyDistribution.Allocation) -> allocations[_recipient]
allocation(LxtBountyDistribution.Allocation) := REF_129(LxtBountyDistribution.Allocation)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
allocation.totalAllocated > 0

IRs:
REF_130(uint256) -> allocation.totalAllocated
TMP_172(bool) = REF_130 > 0
CONDITION TMP_172""];
2->3[label=""True""];
2->7[label=""False""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
amount = allocation.totalAllocated.sub(allocation.amountClaimed)

IRs:
REF_131(uint256) -> allocation.totalAllocated
REF_133(uint256) -> allocation.amountClaimed
TMP_173(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_131', 'REF_133'] 
amount(uint256) := TMP_173(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(LXT.transferFrom(LXT_OWNER,_recipient,amount))

IRs:
TMP_174(bool) = HIGH_LEVEL_CALL, dest:LXT(LexitToken), function:transferFrom, arguments:['LXT_OWNER', '_recipient', 'amount']  
TMP_175(None) = SOLIDITY_CALL require(bool)(TMP_174)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allocation.amountClaimed = allocation.amountClaimed.add(amount)

IRs:
REF_135(uint256) -> allocation.amountClaimed
REF_136(uint256) -> allocation.amountClaimed
TMP_176(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_136', 'amount'] 
REF_135(uint256) (->allocation) := TMP_176(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
grandTotalClaimed = grandTotalClaimed.add(amount)

IRs:
TMP_177(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['grandTotalClaimed', 'amount'] 
grandTotalClaimed(uint256) := TMP_177(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwnerOrAdmin()

IRs:
MODIFIER_CALL, LxtBountyDistribution.onlyOwnerOrAdmin()()""];
8->1;
}
",1,0,0,0,"onlyOwnerOrAdmin();allocation = allocations[_recipient];allocation.totalAllocated > 0;amount = allocation.totalAllocated.sub(allocation.amountClaimed);;require(bool)(LXT.transferFrom(LXT_OWNER,_recipient,amount));allocation.amountClaimed = allocation.amountClaimed.add(amount);grandTotalClaimed = grandTotalClaimed.add(amount)"
./0xa1ad52ff49fc70b7920b7d02483a58beb15d492b_ext.sol,FoMo3Dlong.registerNameXID,631,645,"TMP_89(bytes32) = LIBRARY_CALL, dest:NameFilter, function:NameFilter.nameFilter(string), arguments:['_nameString'] ,_name(bytes32) := TMP_89(bytes32),_addr(address) := msg.sender(address),_paid(uint256) := msg.value(uint256),TUPLE_0(bool,uint256) = HIGH_LEVEL_CALL, dest:PlayerBook(PlayerBookInterface), function:registerNameXIDFromDapp, arguments:['_addr', '_name', '_affCode', '_all'] value:_paid ,_isNewPlayer(bool)= UNPACK TUPLE_0 index: 0 ,_affID(uint256)= UNPACK TUPLE_0 index: 1 ,REF_101(uint256) -> pIDxAddr_[_addr],_pID(uint256) := REF_101(uint256),REF_103(F3Ddatasets.Player) -> plyr_[_affID],REF_104(address) -> REF_103.addr,REF_105(F3Ddatasets.Player) -> plyr_[_affID],REF_106(bytes32) -> REF_105.name,Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_104,REF_106,_paid,now),MODIFIER_CALL, FoMo3Dlong.isHuman()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_name = _nameString.nameFilter()

IRs:
TMP_89(bytes32) = LIBRARY_CALL, dest:NameFilter, function:NameFilter.nameFilter(string), arguments:['_nameString'] 
_name(bytes32) := TMP_89(bytes32)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
_addr = msg.sender

IRs:
_addr(address) := msg.sender(address)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
_paid = msg.value

IRs:
_paid(uint256) := msg.value(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
(_isNewPlayer,_affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr,_name,_affCode,_all)

IRs:
TUPLE_0(bool,uint256) = HIGH_LEVEL_CALL, dest:PlayerBook(PlayerBookInterface), function:registerNameXIDFromDapp, arguments:['_addr', '_name', '_affCode', '_all'] value:_paid 
_isNewPlayer(bool)= UNPACK TUPLE_0 index: 0 
_affID(uint256)= UNPACK TUPLE_0 index: 1 ""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
_pID = pIDxAddr_[_addr]

IRs:
REF_101(uint256) -> pIDxAddr_[_addr]
_pID(uint256) := REF_101(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
F3Devents.onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,_paid,now)

IRs:
REF_103(F3Ddatasets.Player) -> plyr_[_affID]
REF_104(address) -> REF_103.addr
REF_105(F3Ddatasets.Player) -> plyr_[_affID]
REF_106(bytes32) -> REF_105.name
Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_104,REF_106,_paid,now)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
isHuman()

IRs:
MODIFIER_CALL, FoMo3Dlong.isHuman()()""];
9->1;
}
",1,0,0,0,"isHuman();_name = _nameString.nameFilter();_addr = msg.sender;_paid = msg.value;;;(_isNewPlayer,_affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr,_name,_affCode,_all);_pID = pIDxAddr_[_addr];F3Devents.onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,_paid,now)"
./0xb602f224523c89c80dd8e970573291c63beeb778_ext.sol,Crowdsale.endIco,212,218,"TMP_90 = UnaryType.BANG isIcoEnded ,TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),TMP_92(bool) = msg.sender == owner,TMP_93(bool) = msg.sender == techSupport,TMP_94(bool) = TMP_92 || TMP_93,TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94),TMP_96(uint256) = icoFinish + 432000,TMP_97(bool) = now > TMP_96,TMP_98(None) = SOLIDITY_CALL require(bool)(TMP_97),HIGH_LEVEL_CALL, dest:token(BineuroToken), function:burnTokens, arguments:['etherDistribution1', 'etherDistribution2', 'bountyAddress', 'tokensSold']  ,isIcoEnded(bool) := True(bool)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isIcoEnded)

IRs:
TMP_90 = UnaryType.BANG isIcoEnded 
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == owner || msg.sender == techSupport)

IRs:
TMP_92(bool) = msg.sender == owner
TMP_93(bool) = msg.sender == techSupport
TMP_94(bool) = TMP_92 || TMP_93
TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(now > icoFinish + 432000)

IRs:
TMP_96(uint256) = icoFinish + 432000
TMP_97(bool) = now > TMP_96
TMP_98(None) = SOLIDITY_CALL require(bool)(TMP_97)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.burnTokens(etherDistribution1,etherDistribution2,bountyAddress,tokensSold)

IRs:
HIGH_LEVEL_CALL, dest:token(BineuroToken), function:burnTokens, arguments:['etherDistribution1', 'etherDistribution2', 'bountyAddress', 'tokensSold']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
isIcoEnded = true

IRs:
isIcoEnded(bool) := True(bool)""];
}
",1,0,0,0,"require(bool)(! isIcoEnded);require(bool)(msg.sender == owner || msg.sender == techSupport);require(bool)(now > icoFinish + 432000);token.burnTokens(etherDistribution1,etherDistribution2,bountyAddress,tokensSold);isIcoEnded = true"
./0xa2909e1bcbb24b285741db27a11bfa5706ad4ae5_ext.sol,Crowdsale.finalize,327,345,"TMP_127(bool) = now < endTime,CONDITION TMP_127,TMP_128(bool) = manusSentToEther == MAX_CAP,CONDITION TMP_128,TMP_129(bool) = manusSentToEther < MIN_CAP,TMP_130(uint256) = endTime + 1296000,TMP_131(bool) = now < TMP_130,TMP_132(bool) = TMP_129 && TMP_131,CONDITION TMP_132,REF_94(uint256) = SOLIDITY_CALL balance(address)(this),TMP_133 = SEND dest:multisigEther value:REF_94,TMP_134 = UnaryType.BANG TMP_133 ,CONDITION TMP_134,TMP_135(uint256) = HIGH_LEVEL_CALL, dest:manus(Manus), function:balanceOf, arguments:['this']  ,remains(uint256) := TMP_135(uint256),TMP_136(bool) = remains > 0,CONDITION TMP_136,TMP_137(bool) = HIGH_LEVEL_CALL, dest:manus(Manus), function:burn, arguments:['remains']  ,TMP_138 = UnaryType.BANG TMP_137 ,CONDITION TMP_138,crowdsaleClosed(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->19;
1[label=""Node Type: IF 1

EXPRESSION:
now < endTime

IRs:
TMP_127(bool) = now < endTime
CONDITION TMP_127""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
manusSentToEther == MAX_CAP

IRs:
TMP_128(bool) = manusSentToEther == MAX_CAP
CONDITION TMP_128""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: THROW 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
manusSentToEther < MIN_CAP && now < endTime + 1296000

IRs:
TMP_129(bool) = manusSentToEther < MIN_CAP
TMP_130(uint256) = endTime + 1296000
TMP_131(bool) = now < TMP_130
TMP_132(bool) = TMP_129 && TMP_131
CONDITION TMP_132""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: THROW 7
""];
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
! multisigEther.send(this.balance)

IRs:
REF_94(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_133 = SEND dest:multisigEther value:REF_94
TMP_134 = UnaryType.BANG TMP_133 
CONDITION TMP_134""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: THROW 10
""];
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
remains = manus.balanceOf(this)

IRs:
TMP_135(uint256) = HIGH_LEVEL_CALL, dest:manus(Manus), function:balanceOf, arguments:['this']  
remains(uint256) := TMP_135(uint256)""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
remains > 0

IRs:
TMP_136(bool) = remains > 0
CONDITION TMP_136""];
13->14[label=""True""];
13->17[label=""False""];
14[label=""Node Type: IF 14

EXPRESSION:
! manus.burn(remains)

IRs:
TMP_137(bool) = HIGH_LEVEL_CALL, dest:manus(Manus), function:burn, arguments:['remains']  
TMP_138 = UnaryType.BANG TMP_137 
CONDITION TMP_138""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: THROW 15
""];
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
crowdsaleClosed = true

IRs:
crowdsaleClosed(bool) := True(bool)""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
19->1;
}
",1,0,1,0,onlyOwner();now < endTime;manusSentToEther == MAX_CAP;;;;manusSentToEther < MIN_CAP && now < endTime + 1296000;;;! multisigEther.send(this.balance);;;remains = manus.balanceOf(this);remains > 0;! manus.burn(remains);;;;crowdsaleClosed = true
./0xc4aad17558fa95c8937d0856b2dad74c1a7a095f_ext.sol,AgiCrowdsale.finalize,482,501,"TMP_245 = UnaryType.BANG isFinalized ,TMP_246(None) = SOLIDITY_CALL require(bool)(TMP_245),TMP_247(bool) = INTERNAL_CALL, AgiCrowdsale.hasEnded()(),TMP_248(None) = SOLIDITY_CALL require(bool)(TMP_247),TMP_249(bool) = INTERNAL_CALL, AgiCrowdsale.goalReached()(),CONDITION TMP_249,HIGH_LEVEL_CALL, dest:vault(RefundVault), function:close, arguments:[]  ,HIGH_LEVEL_CALL, dest:token(SingularityNetToken), function:unpause, arguments:[]  ,HIGH_LEVEL_CALL, dest:token(SingularityNetToken), function:transferOwnership, arguments:['owner']  ,HIGH_LEVEL_CALL, dest:vault(RefundVault), function:enableRefunds, arguments:[]  ,isFinalized(bool) := True(bool),Emit Finalized(),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isFinalized)

IRs:
TMP_245 = UnaryType.BANG isFinalized 
TMP_246(None) = SOLIDITY_CALL require(bool)(TMP_245)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(hasEnded())

IRs:
TMP_247(bool) = INTERNAL_CALL, AgiCrowdsale.hasEnded()()
TMP_248(None) = SOLIDITY_CALL require(bool)(TMP_247)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
goalReached()

IRs:
TMP_249(bool) = INTERNAL_CALL, AgiCrowdsale.goalReached()()
CONDITION TMP_249""];
3->4[label=""True""];
3->7[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
vault.close()

IRs:
HIGH_LEVEL_CALL, dest:vault(RefundVault), function:close, arguments:[]  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
token.unpause()

IRs:
HIGH_LEVEL_CALL, dest:token(SingularityNetToken), function:unpause, arguments:[]  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
token.transferOwnership(owner)

IRs:
HIGH_LEVEL_CALL, dest:token(SingularityNetToken), function:transferOwnership, arguments:['owner']  ""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
vault.enableRefunds()

IRs:
HIGH_LEVEL_CALL, dest:vault(RefundVault), function:enableRefunds, arguments:[]  ""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
isFinalized = true

IRs:
isFinalized(bool) := True(bool)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Finalized()

IRs:
Emit Finalized()""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
11->1;
}
",1,0,0,0,onlyOwner();require(bool)(! isFinalized);require(bool)(hasEnded());goalReached();vault.close();vault.enableRefunds();token.unpause();token.transferOwnership(owner);;isFinalized = true;Finalized()
./0x4160836bd96bf4f2ed931bfefb3e00b3e68ad8f6_ext.sol,PRHXToken.refundTokens,355,361,"TMP_111(bool) = msg.sender == owner,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113 = CONVERT this to address,TMP_114(bool) = _token != TMP_113,TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114),TMP_116 = CONVERT _token to AbstractToken,token(AbstractToken) := TMP_116(AbstractToken),TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ,Emit RefundTokens(_token,_refund,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_111(bool) = msg.sender == owner
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_113 = CONVERT this to address
TMP_114(bool) = _token != TMP_113
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
token = AbstractToken(_token)

IRs:
TMP_116 = CONVERT _token to AbstractToken
token(AbstractToken) := TMP_116(AbstractToken)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(_refund,_value)

IRs:
TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RefundTokens(_token,_refund,_value)

IRs:
Emit RefundTokens(_token,_refund,_value)""];
}
",1,0,0,0,"require(bool)(msg.sender == owner);require(bool)(_token != address(this));token = AbstractToken(_token);token.transfer(_refund,_value);RefundTokens(_token,_refund,_value)"
./0xb602f224523c89c80dd8e970573291c63beeb778_ext.sol,Crowdsale.manualSendTokens,198,201,"HIGH_LEVEL_CALL, dest:token(BineuroToken), function:sendCrowdsaleTokens, arguments:['_address', '_tokens']  ,TMP_78(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokensSold', '_tokens'] ,tokensSold(uint256) := TMP_78(uint256),MODIFIER_CALL, Ownable.onlyTechSupport()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
token.sendCrowdsaleTokens(_address,_tokens)

IRs:
HIGH_LEVEL_CALL, dest:token(BineuroToken), function:sendCrowdsaleTokens, arguments:['_address', '_tokens']  ""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
tokensSold = tokensSold.add(_tokens)

IRs:
TMP_78(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokensSold', '_tokens'] 
tokensSold(uint256) := TMP_78(uint256)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyTechSupport()

IRs:
MODIFIER_CALL, Ownable.onlyTechSupport()()""];
3->1;
}
",1,0,0,0,"onlyTechSupport();token.sendCrowdsaleTokens(_address,_tokens);tokensSold = tokensSold.add(_tokens)"
./0x000000002bb43c83ece652d161ad0fa862129a2c_ext.sol,AccountRegistry.proposeProper,496,505,"TMP_167(ProperProposal) = new ProperProposal() ,proposal(ProperProposal) := TMP_167(ProperProposal),HIGH_LEVEL_CALL, dest:proposal(ProperProposal), function:init, arguments:['msg.sender', '_resolution']  ,REF_162(AccountRegistry.Account) -> accounts[proposal],REF_163(uint8) -> REF_162.membership,REF_163(-> accounts) = REF_163 | PROPOSAL,Emit Proposal(proposal),RETURN proposal","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
proposal = new ProperProposal()

IRs:
TMP_167(ProperProposal) = new ProperProposal() 
proposal(ProperProposal) := TMP_167(ProperProposal)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
proposal.init(msg.sender,_resolution)

IRs:
HIGH_LEVEL_CALL, dest:proposal(ProperProposal), function:init, arguments:['msg.sender', '_resolution']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
accounts[proposal].membership |= PROPOSAL

IRs:
REF_162(AccountRegistry.Account) -> accounts[proposal]
REF_163(uint8) -> REF_162.membership
REF_163(-> accounts) = REF_163 | PROPOSAL""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Proposal(proposal)

IRs:
Emit Proposal(proposal)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
proposal

IRs:
RETURN proposal""];
}
",1,0,0,0,"proposal = new ProperProposal();proposal.init(msg.sender,_resolution);accounts[proposal].membership |= PROPOSAL;Proposal(proposal);proposal"
./0x4498f897505d0e6991edeab24bc7b5727d72de28_ext.sol,RFCICO.buyTokens,109,127,"TMP_26(bool) = beneficiary != 0,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),TMP_28(bool) = INTERNAL_CALL, RFCICO.validPurchase()(),TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),weiAmount(uint256) := msg.value(uint256),TMP_30(uint256) = weiAmount * price,tokens(uint256) := TMP_30(uint256),TMP_31(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] ,weiRaised(uint256) := TMP_31(uint256),HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['beneficiary', 'tokens']  ,Emit TokenPurchase(msg.sender,beneficiary,weiAmount,tokens),INTERNAL_CALL, RFCICO.forwardFunds()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != 0x0)

IRs:
TMP_26(bool) = beneficiary != 0
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(validPurchase())

IRs:
TMP_28(bool) = INTERNAL_CALL, RFCICO.validPurchase()()
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
tokens = ((weiAmount) * price)

IRs:
TMP_30(uint256) = weiAmount * price
tokens(uint256) := TMP_30(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
weiRaised = weiRaised.add(weiAmount)

IRs:
TMP_31(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['weiRaised', 'weiAmount'] 
weiRaised(uint256) := TMP_31(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tokenReward.transfer(beneficiary,tokens)

IRs:
HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['beneficiary', 'tokens']  ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,beneficiary,weiAmount,tokens)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
forwardFunds()

IRs:
INTERNAL_CALL, RFCICO.forwardFunds()()""];
}
",1,0,0,0,"require(bool)(beneficiary != 0x0);require(bool)(validPurchase());weiAmount = msg.value;tokens = ((weiAmount) * price);weiRaised = weiRaised.add(weiAmount);tokenReward.transfer(beneficiary,tokens);TokenPurchase(msg.sender,beneficiary,weiAmount,tokens);forwardFunds()"
./0x73e5451bcf4f7c47946abe89c772f3e6576909c3_ext.sol,DragonCrowdsaleCore.manualSend,363,384,"TMP_119(bool) = packagenumber != 1,TMP_120(bool) = packagenumber != 2,TMP_121(bool) = TMP_119 && TMP_120,TMP_122(bool) = packagenumber != 3,TMP_123(bool) = TMP_121 && TMP_122,CONDITION TMP_123,TMP_124(None) = SOLIDITY_CALL revert()(),TMP_125(bool) = packagenumber == 1,CONDITION TMP_125,award(uint256) := 10800000000(uint256),donation(uint256) := 800000000(uint256),TMP_126(bool) = packagenumber == 2,CONDITION TMP_126,award(uint256) := 108800000000(uint256),donation(uint256) := 8800000000(uint256),TMP_127(bool) = packagenumber == 3,CONDITION TMP_127,award(uint256) := 1088800000000(uint256),donation(uint256) := 88800000000(uint256),TMP_128(bool) = HIGH_LEVEL_CALL, dest:tokenReward(Dragon), function:transfer, arguments:['tokenholder', 'award']  ,TMP_129(bool) = HIGH_LEVEL_CALL, dest:tokenReward(Dragon), function:transfer, arguments:['charity', 'donation']  ,TMP_130(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['presold', 'award'] ,presold(uint256) := TMP_130(uint256),TMP_131(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['presold', 'donation'] ,presold(uint256) := TMP_131(uint256),TMP_132(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokensSold', 'award'] ,tokensSold(uint256) := TMP_132(uint256),TMP_133(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokensSold', 'donation'] ,tokensSold(uint256) := TMP_133(uint256),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->24;
1[label=""Node Type: IF 1

EXPRESSION:
packagenumber != 1 && packagenumber != 2 && packagenumber != 3

IRs:
TMP_119(bool) = packagenumber != 1
TMP_120(bool) = packagenumber != 2
TMP_121(bool) = TMP_119 && TMP_120
TMP_122(bool) = packagenumber != 3
TMP_123(bool) = TMP_121 && TMP_122
CONDITION TMP_123""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_124(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5
""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
packagenumber == 1

IRs:
TMP_125(bool) = packagenumber == 1
CONDITION TMP_125""];
6->7[label=""True""];
6->9[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
award = 10800000000

IRs:
award(uint256) := 10800000000(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
donation = 800000000

IRs:
donation(uint256) := 800000000(uint256)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
packagenumber == 2

IRs:
TMP_126(bool) = packagenumber == 2
CONDITION TMP_126""];
10->11[label=""True""];
10->13[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
award = 108800000000

IRs:
award(uint256) := 108800000000(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
donation = 8800000000

IRs:
donation(uint256) := 8800000000(uint256)""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
packagenumber == 3

IRs:
TMP_127(bool) = packagenumber == 3
CONDITION TMP_127""];
14->15[label=""True""];
14->17[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
award = 1088800000000

IRs:
award(uint256) := 1088800000000(uint256)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
donation = 88800000000

IRs:
donation(uint256) := 88800000000(uint256)""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
tokenReward.transfer(tokenholder,award)

IRs:
TMP_128(bool) = HIGH_LEVEL_CALL, dest:tokenReward(Dragon), function:transfer, arguments:['tokenholder', 'award']  ""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
tokenReward.transfer(charity,donation)

IRs:
TMP_129(bool) = HIGH_LEVEL_CALL, dest:tokenReward(Dragon), function:transfer, arguments:['charity', 'donation']  ""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
presold = presold.add(award)

IRs:
TMP_130(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['presold', 'award'] 
presold(uint256) := TMP_130(uint256)""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
presold = presold.add(donation)

IRs:
TMP_131(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['presold', 'donation'] 
presold(uint256) := TMP_131(uint256)""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
tokensSold = tokensSold.add(award)

IRs:
TMP_132(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokensSold', 'award'] 
tokensSold(uint256) := TMP_132(uint256)""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
tokensSold = tokensSold.add(donation)

IRs:
TMP_133(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokensSold', 'donation'] 
tokensSold(uint256) := TMP_133(uint256)""];
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
24->1;
}
",1,0,0,0,"onlyOwner();packagenumber != 1 && packagenumber != 2 && packagenumber != 3;revert()();;;;packagenumber == 1;award = 10800000000;;donation = 800000000;packagenumber == 2;award = 108800000000;;donation = 8800000000;packagenumber == 3;award = 1088800000000;;donation = 88800000000;tokenReward.transfer(tokenholder,award);tokenReward.transfer(charity,donation);presold = presold.add(award);presold = presold.add(donation);tokensSold = tokensSold.add(award);tokensSold = tokensSold.add(donation)"
./0x01c627181089b6e10ee8316ec08516b3df7c4845_ext.sol,BrickCrowdsale.finalize,676,684,"TMP_411 = UnaryType.BANG isFinalized ,TMP_412(None) = SOLIDITY_CALL require(bool)(TMP_411),INTERNAL_CALL, BrickCrowdsale.finalization()(),Emit BrickFinalized(),isFinalized(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isFinalized)

IRs:
TMP_411 = UnaryType.BANG isFinalized 
TMP_412(None) = SOLIDITY_CALL require(bool)(TMP_411)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
finalization()

IRs:
INTERNAL_CALL, BrickCrowdsale.finalization()()""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
BrickFinalized()

IRs:
Emit BrickFinalized()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
isFinalized = true

IRs:
isFinalized(bool) := True(bool)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",1,0,0,0,onlyOwner();require(bool)(! isFinalized);finalization();BrickFinalized();isFinalized = true
./0x91dfe531ff8ba876a505c8f1c98bafede6c7effc_ext.sol,MatchingMarket.setMatchingEnabled,765,769,"matchingEnabled(bool) := matchingEnabled_(bool),Emit LogMatchingEnabled(matchingEnabled),RETURN True,MODIFIER_CALL, DSAuth.auth()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
matchingEnabled = matchingEnabled_

IRs:
matchingEnabled(bool) := matchingEnabled_(bool)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
LogMatchingEnabled(matchingEnabled)

IRs:
Emit LogMatchingEnabled(matchingEnabled)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
4->1;
}
",1,0,0,0,auth();matchingEnabled = matchingEnabled_;LogMatchingEnabled(matchingEnabled);true
./0x6ddb328c94350b53a155e8cad141e3b972decc01_ext.sol,BTCCMToken.refundTokens,355,361,"TMP_111(bool) = msg.sender == owner,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113 = CONVERT this to address,TMP_114(bool) = _token != TMP_113,TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114),TMP_116 = CONVERT _token to AbstractToken,token(AbstractToken) := TMP_116(AbstractToken),TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ,Emit RefundTokens(_token,_refund,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_111(bool) = msg.sender == owner
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_113 = CONVERT this to address
TMP_114(bool) = _token != TMP_113
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
token = AbstractToken(_token)

IRs:
TMP_116 = CONVERT _token to AbstractToken
token(AbstractToken) := TMP_116(AbstractToken)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(_refund,_value)

IRs:
TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RefundTokens(_token,_refund,_value)

IRs:
Emit RefundTokens(_token,_refund,_value)""];
}
",1,0,0,0,"require(bool)(msg.sender == owner);require(bool)(_token != address(this));token = AbstractToken(_token);token.transfer(_refund,_value);RefundTokens(_token,_refund,_value)"
./0x4900320fe47208de0b79db1273a78ab8c8f3528d_ext.sol,Crowdsale.finishCrowdSale,185,199,"REF_19(uint256) = SOLIDITY_CALL balance(address)(this),TMP_94(bool) = REF_19 >= fundingGoal,CONDITION TMP_94,fundingGoalReached(bool) := True(bool),TMP_95(bool) = isOpened == True,CONDITION TMP_95,isOpened(bool) := False(bool),TMP_96(uint256) = transferableToken - soldToken,val(uint256) := TMP_96(uint256),TMP_97(bool) = val > 0,CONDITION TMP_97,TMP_98(uint256) = transferableToken - soldToken,HIGH_LEVEL_CALL, dest:tokenReward(MontexToken), function:transfer, arguments:['msg.sender', 'TMP_98']  ,Emit WithdrawalToken(msg.sender,val,True),REF_21(uint256) = SOLIDITY_CALL balance(address)(this),Emit FinishCrowdSale(owner,fundingGoal,REF_21,fundingGoalReached,soldToken),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->13;
1[label=""Node Type: IF 1

EXPRESSION:
this.balance >= fundingGoal

IRs:
REF_19(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_94(bool) = REF_19 >= fundingGoal
CONDITION TMP_94""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
fundingGoalReached = true

IRs:
fundingGoalReached(bool) := True(bool)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
isOpened == true

IRs:
TMP_95(bool) = isOpened == True
CONDITION TMP_95""];
4->5[label=""True""];
4->11[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
isOpened = false

IRs:
isOpened(bool) := False(bool)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
val = transferableToken - soldToken

IRs:
TMP_96(uint256) = transferableToken - soldToken
val(uint256) := TMP_96(uint256)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
val > 0

IRs:
TMP_97(bool) = val > 0
CONDITION TMP_97""];
7->8[label=""True""];
7->10[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
tokenReward.transfer(msg.sender,transferableToken - soldToken)

IRs:
TMP_98(uint256) = transferableToken - soldToken
HIGH_LEVEL_CALL, dest:tokenReward(MontexToken), function:transfer, arguments:['msg.sender', 'TMP_98']  ""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
WithdrawalToken(msg.sender,val,true)

IRs:
Emit WithdrawalToken(msg.sender,val,True)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
FinishCrowdSale(owner,fundingGoal,this.balance,fundingGoalReached,soldToken)

IRs:
REF_21(uint256) = SOLIDITY_CALL balance(address)(this)
Emit FinishCrowdSale(owner,fundingGoal,REF_21,fundingGoalReached,soldToken)""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
13->1;
}
",1,0,0,0,"onlyOwner();this.balance >= fundingGoal;fundingGoalReached = true;;isOpened == true;isOpened = false;;val = transferableToken - soldToken;val > 0;tokenReward.transfer(msg.sender,transferableToken - soldToken);;WithdrawalToken(msg.sender,val,true);FinishCrowdSale(owner,fundingGoal,this.balance,fundingGoalReached,soldToken)"
./0x75a17c63c2121447655955b55aaa1a413e750232_ext.sol,CryderCrowdsale.requestTokens,523,528,"TMP_219(uint256) = HIGH_LEVEL_CALL, dest:presaleToken(CryderToken), function:balanceOf, arguments:['msg.sender']  ,TMP_220(bool) = TMP_219 > 0,REF_138(bool) -> tokenRequests[msg.sender],TMP_221(bool) = REF_138 == False,TMP_222(bool) = TMP_220 && TMP_221,TMP_223(None) = SOLIDITY_CALL require(bool)(TMP_222),TMP_224(uint256) = HIGH_LEVEL_CALL, dest:presaleToken(CryderToken), function:balanceOf, arguments:['msg.sender']  ,TMP_225(bool) = HIGH_LEVEL_CALL, dest:token(CryderToken), function:mint, arguments:['msg.sender', 'TMP_224']  ,REF_141(bool) -> tokenRequests[msg.sender],REF_141(bool) (->tokenRequests) := True(bool),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(presaleToken.balanceOf(msg.sender) > 0 && tokenRequests[msg.sender] == false)

IRs:
TMP_219(uint256) = HIGH_LEVEL_CALL, dest:presaleToken(CryderToken), function:balanceOf, arguments:['msg.sender']  
TMP_220(bool) = TMP_219 > 0
REF_138(bool) -> tokenRequests[msg.sender]
TMP_221(bool) = REF_138 == False
TMP_222(bool) = TMP_220 && TMP_221
TMP_223(None) = SOLIDITY_CALL require(bool)(TMP_222)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
token.mint(msg.sender,presaleToken.balanceOf(msg.sender))

IRs:
TMP_224(uint256) = HIGH_LEVEL_CALL, dest:presaleToken(CryderToken), function:balanceOf, arguments:['msg.sender']  
TMP_225(bool) = HIGH_LEVEL_CALL, dest:token(CryderToken), function:mint, arguments:['msg.sender', 'TMP_224']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tokenRequests[msg.sender] = true

IRs:
REF_141(bool) -> tokenRequests[msg.sender]
REF_141(bool) (->tokenRequests) := True(bool)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,"require(bool)(presaleToken.balanceOf(msg.sender) > 0 && tokenRequests[msg.sender] == false);token.mint(msg.sender,presaleToken.balanceOf(msg.sender));tokenRequests[msg.sender] = true;true"
./0x0d61178ce25bf05c5b19dc56f30e0f10cbbe9f2b_ext.sol,Lottery.buyTickets,90,118,"TMP_19(bool) = msg.value >= ticketPrice,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),customerAddress(address) := msg.sender(address),TMP_22(uint256) = HIGH_LEVEL_CALL, dest:contractCall(_Contract), function:buy, arguments:['customerAddress'] value:msg.value ,REF_2 -> LENGTH entries,TMP_23(bool) = entryCounter == REF_2,CONDITION TMP_23,REF_4 -> LENGTH entries,TMP_25(uint256) := REF_4(uint256),TMP_26(uint256) = TMP_25 + 1,REF_4(uint256) (->entries) := TMP_26(uint256),REF_5(address) -> entries[TMP_25],REF_5(address) (->entries) := customerAddress(address),REF_6(address) -> entries[entryCounter],REF_6(address) (->entries) := customerAddress(address),TMP_27(uint256) := entryCounter(uint256),entryCounter(uint256) = entryCounter + 1,Emit BoughtTicket(msg.value,msg.sender,entryCounter),TMP_29(bool) = entryCounter >= automaticThreshold,CONDITION TMP_29,HIGH_LEVEL_CALL, dest:contractCall(_Contract), function:exit, arguments:[]  ,INTERNAL_CALL, Lottery.giveawayFee()(),TMP_32(address) = INTERNAL_CALL, Lottery.payWinner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= ticketPrice)

IRs:
TMP_19(bool) = msg.value >= ticketPrice
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
customerAddress = msg.sender

IRs:
customerAddress(address) := msg.sender(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
contractCall.buy.value(msg.value)(customerAddress)

IRs:
TMP_22(uint256) = HIGH_LEVEL_CALL, dest:contractCall(_Contract), function:buy, arguments:['customerAddress'] value:msg.value ""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
entryCounter == (entries.length)

IRs:
REF_2 -> LENGTH entries
TMP_23(bool) = entryCounter == REF_2
CONDITION TMP_23""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
entries.push(customerAddress)

IRs:
REF_4 -> LENGTH entries
TMP_25(uint256) := REF_4(uint256)
TMP_26(uint256) = TMP_25 + 1
REF_4(uint256) (->entries) := TMP_26(uint256)
REF_5(address) -> entries[TMP_25]
REF_5(address) (->entries) := customerAddress(address)""];
5->7;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
entries[entryCounter] = customerAddress

IRs:
REF_6(address) -> entries[entryCounter]
REF_6(address) (->entries) := customerAddress(address)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
entryCounter ++

IRs:
TMP_27(uint256) := entryCounter(uint256)
entryCounter(uint256) = entryCounter + 1""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
BoughtTicket(msg.value,msg.sender,entryCounter)

IRs:
Emit BoughtTicket(msg.value,msg.sender,entryCounter)""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
entryCounter >= automaticThreshold

IRs:
TMP_29(bool) = entryCounter >= automaticThreshold
CONDITION TMP_29""];
10->11[label=""True""];
10->14[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
contractCall.exit()

IRs:
HIGH_LEVEL_CALL, dest:contractCall(_Contract), function:exit, arguments:[]  ""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
giveawayFee()

IRs:
INTERNAL_CALL, Lottery.giveawayFee()()""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
payWinner()

IRs:
TMP_32(address) = INTERNAL_CALL, Lottery.payWinner()()""];
13->14;
14[label=""Node Type: END_IF 14
""];
}
",1,0,1,0,"require(bool)(msg.value >= ticketPrice);customerAddress = msg.sender;contractCall.buy.value(msg.value)(customerAddress);entryCounter == (entries.length);entries.push(customerAddress);entries[entryCounter] = customerAddress;;entryCounter ++;BoughtTicket(msg.value,msg.sender,entryCounter);entryCounter >= automaticThreshold;contractCall.exit();;giveawayFee();payWinner()"
./0x5af9ec6df6edea0761fa841ce56c2e4deb000b31_ext.sol,ZebiMainCrowdsale.mintvestedTokens,1127,1146,"TMP_523(bool) = zweitokens <= zebiZCOShare,TMP_524(bool) = zweitokens > 0,TMP_525(bool) = TMP_523 && TMP_524,TMP_526(None) = SOLIDITY_CALL require(bool)(TMP_525),TMP_527 = CONVERT 0 to address,TMP_528(bool) = partnerAddress != TMP_527,TMP_529(None) = SOLIDITY_CALL require(bool)(TMP_528),TMP_530(bool) = now >= vestedMintStartTime,TMP_531(None) = SOLIDITY_CALL require(bool)(TMP_530),TMP_532(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['now', 'calenderYearStart'] ,TMP_533(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_532', '220752000'] ,currentYearCounter(uint256) := TMP_533(uint256),TMP_534(bool) = now > calenderYearEnd,TMP_535(bool) = currentYearCounter >= 1,TMP_536(bool) = TMP_534 && TMP_535,CONDITION TMP_536,currentYearMinted(uint256) := 0(uint256),TMP_537(uint256) = currentYearCounter - 1,TMP_538(uint256) = TMP_537 * 220752000,TMP_539(uint256) = calenderYearEnd + TMP_538,TMP_540(uint256) = TMP_539 + 1,calenderYearStart(uint256) := TMP_540(uint256),TMP_541(uint256) = calenderYearStart + 220752000,TMP_542(uint256) = TMP_541 - 1,calenderYearEnd(uint256) := TMP_542(uint256),TMP_543(uint256) = currentYearMinted + zweitokens,TMP_544(bool) = TMP_543 <= calenderYearMintCap,TMP_545(None) = SOLIDITY_CALL require(bool)(TMP_544),TMP_546(uint256) = currentYearMinted + zweitokens,currentYearMinted(uint256) := TMP_546(uint256),TMP_547(bool) = HIGH_LEVEL_CALL, dest:token(ZebiCoin), function:mint, arguments:['partnerAddress', 'zweitokens']  ,TMP_548(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['zebiZCOShare', 'zweitokens'] ,zebiZCOShare(uint256) := TMP_548(uint256),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(zweitokens <= zebiZCOShare && zweitokens > 0)

IRs:
TMP_523(bool) = zweitokens <= zebiZCOShare
TMP_524(bool) = zweitokens > 0
TMP_525(bool) = TMP_523 && TMP_524
TMP_526(None) = SOLIDITY_CALL require(bool)(TMP_525)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(partnerAddress != address(0))

IRs:
TMP_527 = CONVERT 0 to address
TMP_528(bool) = partnerAddress != TMP_527
TMP_529(None) = SOLIDITY_CALL require(bool)(TMP_528)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(now >= vestedMintStartTime)

IRs:
TMP_530(bool) = now >= vestedMintStartTime
TMP_531(None) = SOLIDITY_CALL require(bool)(TMP_530)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
currentYearCounter = SafeMath.div((SafeMath.sub(now,calenderYearStart)),220752000)

IRs:
TMP_532(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['now', 'calenderYearStart'] 
TMP_533(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_532', '220752000'] 
currentYearCounter(uint256) := TMP_533(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
now > calenderYearEnd && currentYearCounter >= 1

IRs:
TMP_534(bool) = now > calenderYearEnd
TMP_535(bool) = currentYearCounter >= 1
TMP_536(bool) = TMP_534 && TMP_535
CONDITION TMP_536""];
5->6[label=""True""];
5->9[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
currentYearMinted = 0

IRs:
currentYearMinted(uint256) := 0(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
calenderYearStart = calenderYearEnd + ((currentYearCounter - 1) * 220752000) + 1

IRs:
TMP_537(uint256) = currentYearCounter - 1
TMP_538(uint256) = TMP_537 * 220752000
TMP_539(uint256) = calenderYearEnd + TMP_538
TMP_540(uint256) = TMP_539 + 1
calenderYearStart(uint256) := TMP_540(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
calenderYearEnd = (calenderYearStart + 220752000) - 1

IRs:
TMP_541(uint256) = calenderYearStart + 220752000
TMP_542(uint256) = TMP_541 - 1
calenderYearEnd(uint256) := TMP_542(uint256)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(currentYearMinted + zweitokens <= calenderYearMintCap)

IRs:
TMP_543(uint256) = currentYearMinted + zweitokens
TMP_544(bool) = TMP_543 <= calenderYearMintCap
TMP_545(None) = SOLIDITY_CALL require(bool)(TMP_544)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
currentYearMinted = currentYearMinted + zweitokens

IRs:
TMP_546(uint256) = currentYearMinted + zweitokens
currentYearMinted(uint256) := TMP_546(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
token.mint(partnerAddress,zweitokens)

IRs:
TMP_547(bool) = HIGH_LEVEL_CALL, dest:token(ZebiCoin), function:mint, arguments:['partnerAddress', 'zweitokens']  ""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
zebiZCOShare = zebiZCOShare.sub(zweitokens)

IRs:
TMP_548(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['zebiZCOShare', 'zweitokens'] 
zebiZCOShare(uint256) := TMP_548(uint256)""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
14->1;
}
",1,0,0,0,"onlyOwner();require(bool)(zweitokens <= zebiZCOShare && zweitokens > 0);require(bool)(partnerAddress != address(0));require(bool)(now >= vestedMintStartTime);currentYearCounter = SafeMath.div((SafeMath.sub(now,calenderYearStart)),220752000);now > calenderYearEnd && currentYearCounter >= 1;currentYearMinted = 0;;calenderYearStart = calenderYearEnd + ((currentYearCounter - 1) * 220752000) + 1;calenderYearEnd = (calenderYearStart + 220752000) - 1;require(bool)(currentYearMinted + zweitokens <= calenderYearMintCap);currentYearMinted = currentYearMinted + zweitokens;token.mint(partnerAddress,zweitokens);zebiZCOShare = zebiZCOShare.sub(zweitokens)"
./0x5c89736e9454200141b80c37eb28eaceca2ce8cb_ext.sol,CherryToken.transferFrom,223,244,"TMP_102 = CONVERT 0 to address,TMP_103(bool) = _to != TMP_102,TMP_104(None) = SOLIDITY_CALL require(bool)(TMP_103),REF_71(uint256) -> balances[_from],TMP_105(bool) = _value <= REF_71,TMP_106(None) = SOLIDITY_CALL require(bool)(TMP_105),REF_72(mapping(address => uint256)) -> allowed[_from],REF_73(uint256) -> REF_72[msg.sender],TMP_107(bool) = _value <= REF_73,TMP_108(None) = SOLIDITY_CALL require(bool)(TMP_107),TMP_109(bool) = _from == fundsWallet,CONDITION TMP_109,REF_74(uint256) -> balances[_from],TMP_110(bool) = _value <= REF_74,TMP_111(None) = SOLIDITY_CALL require(bool)(TMP_110),TMP_112(bool) = INTERNAL_CALL, CherryToken.isContract(address)(_to),CONDITION TMP_112,TMP_113 = CONVERT _to to ERC223ReceivingContract,receiver(ERC223ReceivingContract) := TMP_113(ERC223ReceivingContract),TMP_115 = new bytes(1),_data(bytes) := TMP_115(bytes),HIGH_LEVEL_CALL, dest:receiver(ERC223ReceivingContract), function:tokenFallback, arguments:['msg.sender', '_value', '_data']  ,REF_76(uint256) -> balances[_from],REF_78(uint256) -> balances[_from],TMP_117(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_78', '_value'] ,REF_76(uint256) (->balances) := TMP_117(uint256),REF_79(uint256) -> balances[_to],REF_81(uint256) -> balances[_to],TMP_118(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_81', '_value'] ,REF_79(uint256) (->balances) := TMP_118(uint256),REF_82(mapping(address => uint256)) -> allowed[_from],REF_83(uint256) -> REF_82[msg.sender],REF_85(mapping(address => uint256)) -> allowed[_from],REF_86(uint256) -> REF_85[msg.sender],TMP_119(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_86', '_value'] ,REF_83(uint256) (->allowed) := TMP_119(uint256),Emit Transfer(_from,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_102 = CONVERT 0 to address
TMP_103(bool) = _to != TMP_102
TMP_104(None) = SOLIDITY_CALL require(bool)(TMP_103)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_71(uint256) -> balances[_from]
TMP_105(bool) = _value <= REF_71
TMP_106(None) = SOLIDITY_CALL require(bool)(TMP_105)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_72(mapping(address => uint256)) -> allowed[_from]
REF_73(uint256) -> REF_72[msg.sender]
TMP_107(bool) = _value <= REF_73
TMP_108(None) = SOLIDITY_CALL require(bool)(TMP_107)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
_from == fundsWallet

IRs:
TMP_109(bool) = _from == fundsWallet
CONDITION TMP_109""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_74(uint256) -> balances[_from]
TMP_110(bool) = _value <= REF_74
TMP_111(None) = SOLIDITY_CALL require(bool)(TMP_110)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
isContract(_to)

IRs:
TMP_112(bool) = INTERNAL_CALL, CherryToken.isContract(address)(_to)
CONDITION TMP_112""];
7->8[label=""True""];
7->11[label=""False""];
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
receiver = ERC223ReceivingContract(_to)

IRs:
TMP_113 = CONVERT _to to ERC223ReceivingContract
receiver(ERC223ReceivingContract) := TMP_113(ERC223ReceivingContract)""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
_data = new bytes(1)

IRs:
TMP_115 = new bytes(1)
_data(bytes) := TMP_115(bytes)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
receiver.tokenFallback(msg.sender,_value,_data)

IRs:
HIGH_LEVEL_CALL, dest:receiver(ERC223ReceivingContract), function:tokenFallback, arguments:['msg.sender', '_value', '_data']  ""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
balances[_from] = SafeMath.sub(balances[_from],_value)

IRs:
REF_76(uint256) -> balances[_from]
REF_78(uint256) -> balances[_from]
TMP_117(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_78', '_value'] 
REF_76(uint256) (->balances) := TMP_117(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
balances[_to] = SafeMath.add(balances[_to],_value)

IRs:
REF_79(uint256) -> balances[_to]
REF_81(uint256) -> balances[_to]
TMP_118(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_81', '_value'] 
REF_79(uint256) (->balances) := TMP_118(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender],_value)

IRs:
REF_82(mapping(address => uint256)) -> allowed[_from]
REF_83(uint256) -> REF_82[msg.sender]
REF_85(mapping(address => uint256)) -> allowed[_from]
REF_86(uint256) -> REF_85[msg.sender]
TMP_119(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_86', '_value'] 
REF_83(uint256) (->allowed) := TMP_119(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
15->16;
16[label=""Node Type: RETURN 16

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,"require(bool)(_to != address(0));require(bool)(_value <= balances[_from]);require(bool)(_value <= allowed[_from][msg.sender]);_from == fundsWallet;require(bool)(_value <= balances[_from]);;isContract(_to);receiver = ERC223ReceivingContract(_to);;_data = new bytes(1);receiver.tokenFallback(msg.sender,_value,_data);balances[_from] = SafeMath.sub(balances[_from],_value);balances[_to] = SafeMath.add(balances[_to],_value);allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender],_value);Transfer(_from,_to,_value);true"
./0x031e8de47dee0fdde1969a93b64bb8f8fbcba65d_ext.sol,lockEtherPay.lock,87,93,"TMP_27 = UnaryType.BANG isLocked ,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),TMP_29(uint256) = INTERNAL_CALL, lockEtherPay.tokenBalance()(),TMP_30(bool) = TMP_29 > 0,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),start_time(uint256) := now(uint256),TMP_32(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['start_time', 'fifty_two_weeks'] ,end_time(uint256) := TMP_32(uint256),isLocked(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isLocked)

IRs:
TMP_27 = UnaryType.BANG isLocked 
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(tokenBalance() > 0)

IRs:
TMP_29(uint256) = INTERNAL_CALL, lockEtherPay.tokenBalance()()
TMP_30(bool) = TMP_29 > 0
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
start_time = now

IRs:
start_time(uint256) := now(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
end_time = start_time.add(fifty_two_weeks)

IRs:
TMP_32(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['start_time', 'fifty_two_weeks'] 
end_time(uint256) := TMP_32(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
isLocked = true

IRs:
isLocked(bool) := True(bool)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",1,0,0,0,onlyOwner();require(bool)(! isLocked);require(bool)(tokenBalance() > 0);start_time = now;end_time = start_time.add(fifty_two_weeks);isLocked = true
./0x6b62f10b1d042d3ed601899ca25f80f9dbc92644_ext.sol,TwoCoinsOneMoonGame.betRedCoin,90,98,"TMP_14(uint256) = INTERNAL_CALL, TwoCoinsOneMoonGame.getBetAmount()(),betAmount(uint256) := TMP_14(uint256),marketCapRed(uint256) = marketCapRed + betAmount,TMP_15(TwoCoinsOneMoonGame.Bettor) = new Bettor(msg.sender,betAmount),REF_7 -> LENGTH bettorsRed,TMP_17(uint256) := REF_7(uint256),TMP_18(uint256) = TMP_17 + 1,REF_7(uint256) (->bettorsRed) := TMP_18(uint256),REF_8(TwoCoinsOneMoonGame.Bettor) -> bettorsRed[TMP_17],REF_8(TwoCoinsOneMoonGame.Bettor) (->bettorsRed) := TMP_15(TwoCoinsOneMoonGame.Bettor),REF_9 -> LENGTH bettorsRed,endBetRed(uint256) := REF_9(uint256),INTERNAL_CALL, TwoCoinsOneMoonGame.checkMoon()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
betAmount = getBetAmount()

IRs:
TMP_14(uint256) = INTERNAL_CALL, TwoCoinsOneMoonGame.getBetAmount()()
betAmount(uint256) := TMP_14(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
marketCapRed += betAmount

IRs:
marketCapRed(uint256) = marketCapRed + betAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
bettorsRed.push(Bettor({account:msg.sender,amount:betAmount}))

IRs:
TMP_15(TwoCoinsOneMoonGame.Bettor) = new Bettor(msg.sender,betAmount)
REF_7 -> LENGTH bettorsRed
TMP_17(uint256) := REF_7(uint256)
TMP_18(uint256) = TMP_17 + 1
REF_7(uint256) (->bettorsRed) := TMP_18(uint256)
REF_8(TwoCoinsOneMoonGame.Bettor) -> bettorsRed[TMP_17]
REF_8(TwoCoinsOneMoonGame.Bettor) (->bettorsRed) := TMP_15(TwoCoinsOneMoonGame.Bettor)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
endBetRed = bettorsRed.length

IRs:
REF_9 -> LENGTH bettorsRed
endBetRed(uint256) := REF_9(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
checkMoon()

IRs:
INTERNAL_CALL, TwoCoinsOneMoonGame.checkMoon()()""];
}
",1,0,0,0,"betAmount = getBetAmount();marketCapRed += betAmount;bettorsRed.push(Bettor({account:msg.sender,amount:betAmount}));endBetRed = bettorsRed.length;checkMoon()"
./0x3a2fd07ec2ad6f355f93af695a7cf858f5967b78_ext.sol,MTVote.onTokenReceived,122,144,"TMP_32(bool) = msg.sender == TVTokenAddress,TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32),TMP_34 = UnaryType.BANG pause ,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),TMP_36(bytes32) = INTERNAL_CALL, MTVote.convertBytesToBytes32(bytes)(_data),TMP_37 = CONVERT TMP_36 to uint256,targetId(uint256) := TMP_37(uint256),REF_4(uint256) -> targets[targetId],REF_4(-> targets) = REF_4 + _value,TMP_38 = CONVERT TVTokenAddress to TVToken,TMP_39(bool) = HIGH_LEVEL_CALL, dest:TMP_38(TVToken), function:transfer, arguments:['wallet', '_value']  ,TMP_40 = CONVERT 0 to address,checkAndBuySender(address) := TMP_40(address),inList(bool) := False(bool),i(uint256) := 0(uint256),TMP_41(bool) = i < targetIdsSize,CONDITION TMP_41,REF_6(uint256) -> targetIds[i],TMP_42(bool) = REF_6 == targetId,CONDITION TMP_42,inList(bool) := True(bool),TMP_43(uint256) := i(uint256),i(uint256) = i + 1,TMP_44 = UnaryType.BANG inList ,CONDITION TMP_44,REF_8 -> LENGTH targetIds,TMP_46(uint256) := REF_8(uint256),TMP_47(uint256) = TMP_46 + 1,REF_8(uint256) (->targetIds) := TMP_47(uint256),REF_9(uint256) -> targetIds[TMP_46],REF_9(uint256) (->targetIds) := targetId(uint256),TMP_48(uint256) := targetIdsSize(uint256),targetIdsSize(uint256) = targetIdsSize + 1,Emit TokenReceived(_from,_value,targetId),RETURN TOKEN_RECEIVED,TMP_50(bool) = this == _from,CONDITION TMP_50,_from(address) := checkAndBuySender(address),_from(address) := _from(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == TVTokenAddress)

IRs:
TMP_32(bool) = msg.sender == TVTokenAddress
TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! pause)

IRs:
TMP_34 = UnaryType.BANG pause 
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
targetId = uint256(convertBytesToBytes32(_data))

IRs:
TMP_36(bytes32) = INTERNAL_CALL, MTVote.convertBytesToBytes32(bytes)(_data)
TMP_37 = CONVERT TMP_36 to uint256
targetId(uint256) := TMP_37(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
targets[targetId] += _value

IRs:
REF_4(uint256) -> targets[targetId]
REF_4(-> targets) = REF_4 + _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
TVToken(TVTokenAddress).transfer(wallet,_value)

IRs:
TMP_38 = CONVERT TVTokenAddress to TVToken
TMP_39(bool) = HIGH_LEVEL_CALL, dest:TMP_38(TVToken), function:transfer, arguments:['wallet', '_value']  ""];
5->23;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
checkAndBuySender = address(0)

IRs:
TMP_40 = CONVERT 0 to address
checkAndBuySender(address) := TMP_40(address)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
inList = false

IRs:
inList(bool) := False(bool)""];
8->11;
9[label=""Node Type: BEGIN_LOOP 9
""];
9->12;
10[label=""Node Type: END_LOOP 10
""];
10->17;
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
11->9;
12[label=""Node Type: IF_LOOP 12

EXPRESSION:
i < targetIdsSize

IRs:
TMP_41(bool) = i < targetIdsSize
CONDITION TMP_41""];
12->13[label=""True""];
12->10[label=""False""];
13[label=""Node Type: IF 13

EXPRESSION:
targetIds[i] == targetId

IRs:
REF_6(uint256) -> targetIds[i]
TMP_42(bool) = REF_6 == targetId
CONDITION TMP_42""];
13->14[label=""True""];
13->15[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
inList = true

IRs:
inList(bool) := True(bool)""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
i ++

IRs:
TMP_43(uint256) := i(uint256)
i(uint256) = i + 1""];
16->12;
17[label=""Node Type: IF 17

EXPRESSION:
! inList

IRs:
TMP_44 = UnaryType.BANG inList 
CONDITION TMP_44""];
17->18[label=""True""];
17->20[label=""False""];
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
targetIds.push(targetId)

IRs:
REF_8 -> LENGTH targetIds
TMP_46(uint256) := REF_8(uint256)
TMP_47(uint256) = TMP_46 + 1
REF_8(uint256) (->targetIds) := TMP_47(uint256)
REF_9(uint256) -> targetIds[TMP_46]
REF_9(uint256) (->targetIds) := targetId(uint256)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
targetIdsSize ++

IRs:
TMP_48(uint256) := targetIdsSize(uint256)
targetIdsSize(uint256) = targetIdsSize + 1""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
TokenReceived(_from,_value,targetId)

IRs:
Emit TokenReceived(_from,_value,targetId)""];
21->22;
22[label=""Node Type: RETURN 22

EXPRESSION:
TOKEN_RECEIVED

IRs:
RETURN TOKEN_RECEIVED""];
23[label=""Node Type: IF 23

EXPRESSION:
this == _from

IRs:
TMP_50(bool) = this == _from
CONDITION TMP_50""];
23->24[label=""True""];
23->25[label=""False""];
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
_from = checkAndBuySender

IRs:
_from(address) := checkAndBuySender(address)""];
24->26;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
_from = _from

IRs:
_from(address) := _from(address)""];
25->26;
26[label=""Node Type: END_IF 26
""];
26->7;
}
",1,0,0,0,"require(bool)(msg.sender == TVTokenAddress);require(bool)(! pause);targetId = uint256(convertBytesToBytes32(_data));targets[targetId] += _value;TVToken(TVTokenAddress).transfer(wallet,_value);this == _from;checkAndBuySender = address(0);inList = false;i = 0;;i < targetIdsSize;;! inList;targetIds[i] == targetId;inList = true;;i ++;targetIds.push(targetId);;targetIdsSize ++;TokenReceived(_from,_value,targetId);TOKEN_RECEIVED;_from = checkAndBuySender;_from = _from;"
./0x4d0dc912fcad3b070d187ab8ac89e63d2b532b8a_ext.sol,BliBliToken.migrate,178,192,"CONDITION isFunding,TMP_80 = CONVERT 0 to address,TMP_81(bool) = newContractAddr == TMP_80,CONDITION TMP_81,REF_31(uint256) -> balances[msg.sender],tokens(uint256) := REF_31(uint256),TMP_82(bool) = tokens == 0,CONDITION TMP_82,REF_32(uint256) -> balances[msg.sender],REF_32(uint256) (->balances) := 0(uint256),TMP_83(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(tokenMigrated,tokens),tokenMigrated(uint256) := TMP_83(uint256),TMP_84 = CONVERT newContractAddr to IMigrationContract,newContract(IMigrationContract) := TMP_84(IMigrationContract),TMP_85(bool) = HIGH_LEVEL_CALL, dest:newContract(IMigrationContract), function:migrate, arguments:['msg.sender', 'tokens']  ,TMP_86 = UnaryType.BANG TMP_85 ,CONDITION TMP_86,Emit Migrate(msg.sender,tokens)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
isFunding

IRs:
CONDITION isFunding""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
newContractAddr == address(0x0)

IRs:
TMP_80 = CONVERT 0 to address
TMP_81(bool) = newContractAddr == TMP_80
CONDITION TMP_81""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: THROW 5
""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
tokens = balances[msg.sender]

IRs:
REF_31(uint256) -> balances[msg.sender]
tokens(uint256) := REF_31(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
tokens == 0

IRs:
TMP_82(bool) = tokens == 0
CONDITION TMP_82""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: THROW 9
""];
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
balances[msg.sender] = 0

IRs:
REF_32(uint256) -> balances[msg.sender]
REF_32(uint256) (->balances) := 0(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
tokenMigrated = safeAdd(tokenMigrated,tokens)

IRs:
TMP_83(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(tokenMigrated,tokens)
tokenMigrated(uint256) := TMP_83(uint256)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
newContract = IMigrationContract(newContractAddr)

IRs:
TMP_84 = CONVERT newContractAddr to IMigrationContract
newContract(IMigrationContract) := TMP_84(IMigrationContract)""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
! newContract.migrate(msg.sender,tokens)

IRs:
TMP_85(bool) = HIGH_LEVEL_CALL, dest:newContract(IMigrationContract), function:migrate, arguments:['msg.sender', 'tokens']  
TMP_86 = UnaryType.BANG TMP_85 
CONDITION TMP_86""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: THROW 15
""];
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
Migrate(msg.sender,tokens)

IRs:
Emit Migrate(msg.sender,tokens)""];
}
",1,0,0,0,"isFunding;;;newContractAddr == address(0x0);;;tokens = balances[msg.sender];tokens == 0;;;balances[msg.sender] = 0;tokenMigrated = safeAdd(tokenMigrated,tokens);newContract = IMigrationContract(newContractAddr);! newContract.migrate(msg.sender,tokens);;;Migrate(msg.sender,tokens)"
./0x56ffb3c578906ba9658fccb052fc1a5672275b6a_ext.sol,OpiriaCrowdsale.addBonusBatch,1085,1095,"i(uint256) := 0(uint256),REF_194 -> LENGTH recipients,TMP_610(bool) = i < REF_194,CONDITION TMP_610,TMP_611 = CONVERT token to PausableToken,REF_196(address) -> recipients[i],TMP_612(uint256) = HIGH_LEVEL_CALL, dest:TMP_611(PausableToken), function:balanceOf, arguments:['REF_196']  ,TMP_613(bool) = TMP_612 > 0,TMP_614(None) = SOLIDITY_CALL require(bool)(TMP_613),REF_197(uint256) -> amounts[i],TMP_615(bool) = INTERNAL_CALL, TokenCappedCrowdsale.notExceedingSaleCap(uint256)(REF_197),TMP_616(None) = SOLIDITY_CALL require(bool)(TMP_615),REF_199(uint256) -> amounts[i],TMP_617(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalBonus', 'REF_199'] ,totalBonus(uint256) := TMP_617(uint256),REF_201(uint256) -> amounts[i],TMP_618(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['soldTokens', 'REF_201'] ,soldTokens(uint256) := TMP_618(uint256),REF_202(address) -> recipients[i],REF_203(uint256) -> bonusOf[REF_202],REF_204(address) -> recipients[i],REF_205(uint256) -> bonusOf[REF_204],REF_207(uint256) -> amounts[i],TMP_619(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_205', 'REF_207'] ,REF_203(uint256) (->bonusOf) := TMP_619(uint256),TMP_620(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < recipients.length

IRs:
REF_194 -> LENGTH recipients
TMP_610(bool) = i < REF_194
CONDITION TMP_610""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(PausableToken(token).balanceOf(recipients[i]) > 0)

IRs:
TMP_611 = CONVERT token to PausableToken
REF_196(address) -> recipients[i]
TMP_612(uint256) = HIGH_LEVEL_CALL, dest:TMP_611(PausableToken), function:balanceOf, arguments:['REF_196']  
TMP_613(bool) = TMP_612 > 0
TMP_614(None) = SOLIDITY_CALL require(bool)(TMP_613)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(notExceedingSaleCap(amounts[i]))

IRs:
REF_197(uint256) -> amounts[i]
TMP_615(bool) = INTERNAL_CALL, TokenCappedCrowdsale.notExceedingSaleCap(uint256)(REF_197)
TMP_616(None) = SOLIDITY_CALL require(bool)(TMP_615)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
totalBonus = totalBonus.add(amounts[i])

IRs:
REF_199(uint256) -> amounts[i]
TMP_617(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalBonus', 'REF_199'] 
totalBonus(uint256) := TMP_617(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
soldTokens = soldTokens.add(amounts[i])

IRs:
REF_201(uint256) -> amounts[i]
TMP_618(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['soldTokens', 'REF_201'] 
soldTokens(uint256) := TMP_618(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
bonusOf[recipients[i]] = bonusOf[recipients[i]].add(amounts[i])

IRs:
REF_202(address) -> recipients[i]
REF_203(uint256) -> bonusOf[REF_202]
REF_204(address) -> recipients[i]
REF_205(uint256) -> bonusOf[REF_204]
REF_207(uint256) -> amounts[i]
TMP_619(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_205', 'REF_207'] 
REF_203(uint256) (->bonusOf) := TMP_619(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
i ++

IRs:
TMP_620(uint256) := i(uint256)
i(uint256) = i + 1""];
10->4;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
11->3;
}
",1,0,0,0,onlyOwner();;i < recipients.length;;i = 0;require(bool)(PausableToken(token).balanceOf(recipients[i]) > 0);require(bool)(notExceedingSaleCap(amounts[i]));totalBonus = totalBonus.add(amounts[i]);soldTokens = soldTokens.add(amounts[i]);bonusOf[recipients[i]] = bonusOf[recipients[i]].add(amounts[i]);i ++
./0x48ec79ffdd733e72046533baafcc19864a976da0_ext.sol,Richer3D.calculateTarget,76,126,"REF_23(DataModal.RoundInfo) -> rInfoXrID[roundNumber],REF_24(uint256) -> REF_23.lastCalculateTime,TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['now', 'REF_24'] ,TMP_27(bool) = TMP_26 >= cycleTime,TMP_28(None) = SOLIDITY_CALL require(bool,string)(TMP_27,Less than cycle Time from last operation),TMP_29(uint256) = HIGH_LEVEL_CALL, dest:p3dContract(HourglassInterface), function:myDividends, arguments:['True']  ,dividends(uint256) := TMP_29(uint256),TMP_30(bool) = dividends > 0,CONDITION TMP_30,REF_26(DataModal.RoundInfo) -> rInfoXrID[roundNumber],REF_27(mapping(uint256 => DataModal.DayInfo)) -> REF_26.dayInfoXDay,REF_28(DataModal.DayInfo) -> REF_27[dayNumber],REF_29(uint256) -> REF_28.playerNumber,TMP_31(bool) = REF_29 > 0,CONDITION TMP_31,REF_30(uint256) -> p3dDividesXroundID[roundNumber],REF_31(uint256) -> p3dDividesXroundID[roundNumber],TMP_32(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_31', 'dividends'] ,REF_30(uint256) (->p3dDividesXroundID) := TMP_32(uint256),HIGH_LEVEL_CALL, dest:p3dContract(HourglassInterface), function:withdraw, arguments:[]  ,TMP_34(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['platformBalance', 'dividends'] ,platformBalance(uint256) := TMP_34(uint256),HIGH_LEVEL_CALL, dest:p3dContract(HourglassInterface), function:withdraw, arguments:[]  ,TMP_36(uint256) = INTERNAL_CALL, Richer3D.getIncreaseBalance(uint256,uint256)(dayNumber,roundNumber),increaseBalance(uint256) := TMP_36(uint256),TMP_37(uint256) = INTERNAL_CALL, Richer3D.getDailyTarget(uint256,uint256)(roundNumber,dayNumber),targetBalance(uint256) := TMP_37(uint256),TMP_38(bool) = increaseBalance >= targetBalance,CONDITION TMP_38,TMP_39(uint256) = INTERNAL_CALL, Richer3D.getIncreaseBalance(uint256,uint256)(dayNumber,roundNumber),TMP_40(bool) = TMP_39 > 0,CONDITION TMP_40,TMP_41(uint256) = INTERNAL_CALL, Richer3D.getIncreaseBalance(uint256,uint256)(dayNumber,roundNumber),TMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_41', '100'] ,TMP_44(uint256) = HIGH_LEVEL_CALL, dest:p3dContract(HourglassInterface), function:buy, arguments:['p3dInviterAddress'] value:TMP_42 ,TMP_45(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dayNumber', '1'] ,dayNumber(uint256) := TMP_45(uint256),REF_40(DataModal.RoundInfo) -> rInfoXrID[roundNumber],REF_41(uint256) -> REF_40.totalDay,REF_41(uint256) (->rInfoXrID) := dayNumber(uint256),REF_42(DataModal.RoundInfo) -> rInfoXrID[roundNumber],REF_43(uint256) -> REF_42.startTime,TMP_46(bool) = REF_43 == 0,CONDITION TMP_46,REF_44(DataModal.RoundInfo) -> rInfoXrID[roundNumber],REF_45(uint256) -> REF_44.startTime,REF_45(uint256) (->rInfoXrID) := now(uint256),REF_46(DataModal.RoundInfo) -> rInfoXrID[roundNumber],REF_47(uint256) -> REF_46.lastCalculateTime,REF_47(uint256) (->rInfoXrID) := now(uint256),REF_48(DataModal.RoundInfo) -> rInfoXrID[roundNumber],REF_49(uint256) -> REF_48.lastCalculateTime,REF_50(DataModal.RoundInfo) -> rInfoXrID[roundNumber],REF_51(uint256) -> REF_50.startTime,TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['dayNumber', '1'] ,TMP_48(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['cycleTime', 'TMP_47'] ,TMP_49(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_51', 'TMP_48'] ,REF_49(uint256) (->rInfoXrID) := TMP_49(uint256),Emit calculateTargetEvent(0),haveWinner(bool) := False(bool),TMP_51(bool) = dayNumber > 1,CONDITION TMP_51,INTERNAL_CALL, Richer3D.sendBalanceForDevelop(uint256)(roundNumber),haveWinner(bool) := True(bool),REF_55(DataModal.RoundInfo) -> rInfoXrID[roundNumber],REF_56(uint256) -> REF_55.winnerDay,TMP_53(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['dayNumber', '1'] ,REF_56(uint256) (->rInfoXrID) := TMP_53(uint256),TMP_54(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['roundNumber', '1'] ,roundNumber(uint256) := TMP_54(uint256),dayNumber(uint256) := 1(uint256),CONDITION haveWinner,REF_59(DataModal.RoundInfo) -> rInfoXrID[roundNumber],REF_60(uint256) -> REF_59.bounsInitNumber,TMP_55(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['roundNumber', '1'] ,TMP_56(uint256) = INTERNAL_CALL, Richer3D.getBounsWithRoundID(uint256)(TMP_55),TMP_57(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_56', '10'] ,REF_60(uint256) (->rInfoXrID) := TMP_57(uint256),REF_63(DataModal.RoundInfo) -> rInfoXrID[roundNumber],REF_64(uint256) -> REF_63.bounsInitNumber,TMP_58(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['roundNumber', '1'] ,TMP_59(uint256) = INTERNAL_CALL, Richer3D.getBounsWithRoundID(uint256)(TMP_58),REF_64(uint256) (->rInfoXrID) := TMP_59(uint256),REF_66(DataModal.RoundInfo) -> rInfoXrID[roundNumber],REF_67(uint256) -> REF_66.totalDay,REF_67(uint256) (->rInfoXrID) := 1(uint256),REF_68(DataModal.RoundInfo) -> rInfoXrID[roundNumber],REF_69(uint256) -> REF_68.startTime,REF_69(uint256) (->rInfoXrID) := now(uint256),REF_70(DataModal.RoundInfo) -> rInfoXrID[roundNumber],REF_71(uint256) -> REF_70.lastCalculateTime,REF_71(uint256) (->rInfoXrID) := now(uint256),Emit calculateTargetEvent(roundNumber)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(now.sub(rInfoXrID[roundNumber].lastCalculateTime) >= cycleTime,Less than cycle Time from last operation)

IRs:
REF_23(DataModal.RoundInfo) -> rInfoXrID[roundNumber]
REF_24(uint256) -> REF_23.lastCalculateTime
TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['now', 'REF_24'] 
TMP_27(bool) = TMP_26 >= cycleTime
TMP_28(None) = SOLIDITY_CALL require(bool,string)(TMP_27,Less than cycle Time from last operation)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
dividends = p3dContract.myDividends(true)

IRs:
TMP_29(uint256) = HIGH_LEVEL_CALL, dest:p3dContract(HourglassInterface), function:myDividends, arguments:['True']  
dividends(uint256) := TMP_29(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
dividends > 0

IRs:
TMP_30(bool) = dividends > 0
CONDITION TMP_30""];
3->4[label=""True""];
3->10[label=""False""];
4[label=""Node Type: IF 4

EXPRESSION:
rInfoXrID[roundNumber].dayInfoXDay[dayNumber].playerNumber > 0

IRs:
REF_26(DataModal.RoundInfo) -> rInfoXrID[roundNumber]
REF_27(mapping(uint256 => DataModal.DayInfo)) -> REF_26.dayInfoXDay
REF_28(DataModal.DayInfo) -> REF_27[dayNumber]
REF_29(uint256) -> REF_28.playerNumber
TMP_31(bool) = REF_29 > 0
CONDITION TMP_31""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
p3dDividesXroundID[roundNumber] = p3dDividesXroundID[roundNumber].add(dividends)

IRs:
REF_30(uint256) -> p3dDividesXroundID[roundNumber]
REF_31(uint256) -> p3dDividesXroundID[roundNumber]
TMP_32(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_31', 'dividends'] 
REF_30(uint256) (->p3dDividesXroundID) := TMP_32(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
p3dContract.withdraw()

IRs:
HIGH_LEVEL_CALL, dest:p3dContract(HourglassInterface), function:withdraw, arguments:[]  ""];
6->9;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
platformBalance = platformBalance.add(dividends)

IRs:
TMP_34(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['platformBalance', 'dividends'] 
platformBalance(uint256) := TMP_34(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
p3dContract.withdraw()

IRs:
HIGH_LEVEL_CALL, dest:p3dContract(HourglassInterface), function:withdraw, arguments:[]  ""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
increaseBalance = getIncreaseBalance(dayNumber,roundNumber)

IRs:
TMP_36(uint256) = INTERNAL_CALL, Richer3D.getIncreaseBalance(uint256,uint256)(dayNumber,roundNumber)
increaseBalance(uint256) := TMP_36(uint256)""];
11->12;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
targetBalance = getDailyTarget(roundNumber,dayNumber)

IRs:
TMP_37(uint256) = INTERNAL_CALL, Richer3D.getDailyTarget(uint256,uint256)(roundNumber,dayNumber)
targetBalance(uint256) := TMP_37(uint256)""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
increaseBalance >= targetBalance

IRs:
TMP_38(bool) = increaseBalance >= targetBalance
CONDITION TMP_38""];
13->14[label=""True""];
13->25[label=""False""];
14[label=""Node Type: IF 14

EXPRESSION:
getIncreaseBalance(dayNumber,roundNumber) > 0

IRs:
TMP_39(uint256) = INTERNAL_CALL, Richer3D.getIncreaseBalance(uint256,uint256)(dayNumber,roundNumber)
TMP_40(bool) = TMP_39 > 0
CONDITION TMP_40""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
p3dContract.buy.value(getIncreaseBalance(dayNumber,roundNumber).div(100))(p3dInviterAddress)

IRs:
TMP_41(uint256) = INTERNAL_CALL, Richer3D.getIncreaseBalance(uint256,uint256)(dayNumber,roundNumber)
TMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_41', '100'] 
TMP_44(uint256) = HIGH_LEVEL_CALL, dest:p3dContract(HourglassInterface), function:buy, arguments:['p3dInviterAddress'] value:TMP_42 ""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
dayNumber = dayNumber.add(1)

IRs:
TMP_45(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dayNumber', '1'] 
dayNumber(uint256) := TMP_45(uint256)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
rInfoXrID[roundNumber].totalDay = dayNumber

IRs:
REF_40(DataModal.RoundInfo) -> rInfoXrID[roundNumber]
REF_41(uint256) -> REF_40.totalDay
REF_41(uint256) (->rInfoXrID) := dayNumber(uint256)""];
18->19;
19[label=""Node Type: IF 19

EXPRESSION:
rInfoXrID[roundNumber].startTime == 0

IRs:
REF_42(DataModal.RoundInfo) -> rInfoXrID[roundNumber]
REF_43(uint256) -> REF_42.startTime
TMP_46(bool) = REF_43 == 0
CONDITION TMP_46""];
19->20[label=""True""];
19->22[label=""False""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
rInfoXrID[roundNumber].startTime = now

IRs:
REF_44(DataModal.RoundInfo) -> rInfoXrID[roundNumber]
REF_45(uint256) -> REF_44.startTime
REF_45(uint256) (->rInfoXrID) := now(uint256)""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
rInfoXrID[roundNumber].lastCalculateTime = now

IRs:
REF_46(DataModal.RoundInfo) -> rInfoXrID[roundNumber]
REF_47(uint256) -> REF_46.lastCalculateTime
REF_47(uint256) (->rInfoXrID) := now(uint256)""];
21->23;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
rInfoXrID[roundNumber].lastCalculateTime = rInfoXrID[roundNumber].startTime.add((cycleTime).mul(dayNumber.sub(1)))

IRs:
REF_48(DataModal.RoundInfo) -> rInfoXrID[roundNumber]
REF_49(uint256) -> REF_48.lastCalculateTime
REF_50(DataModal.RoundInfo) -> rInfoXrID[roundNumber]
REF_51(uint256) -> REF_50.startTime
TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['dayNumber', '1'] 
TMP_48(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['cycleTime', 'TMP_47'] 
TMP_49(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_51', 'TMP_48'] 
REF_49(uint256) (->rInfoXrID) := TMP_49(uint256)""];
22->23;
23[label=""Node Type: END_IF 23
""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
calculateTargetEvent(0)

IRs:
Emit calculateTargetEvent(0)""];
24->41;
25[label=""Node Type: NEW VARIABLE 25

EXPRESSION:
haveWinner = false

IRs:
haveWinner(bool) := False(bool)""];
25->26;
26[label=""Node Type: IF 26

EXPRESSION:
dayNumber > 1

IRs:
TMP_51(bool) = dayNumber > 1
CONDITION TMP_51""];
26->27[label=""True""];
26->29[label=""False""];
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
sendBalanceForDevelop(roundNumber)

IRs:
INTERNAL_CALL, Richer3D.sendBalanceForDevelop(uint256)(roundNumber)""];
27->28;
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
haveWinner = true

IRs:
haveWinner(bool) := True(bool)""];
28->29;
29[label=""Node Type: END_IF 29
""];
29->30;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
rInfoXrID[roundNumber].winnerDay = dayNumber.sub(1)

IRs:
REF_55(DataModal.RoundInfo) -> rInfoXrID[roundNumber]
REF_56(uint256) -> REF_55.winnerDay
TMP_53(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['dayNumber', '1'] 
REF_56(uint256) (->rInfoXrID) := TMP_53(uint256)""];
30->31;
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
roundNumber = roundNumber.add(1)

IRs:
TMP_54(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['roundNumber', '1'] 
roundNumber(uint256) := TMP_54(uint256)""];
31->32;
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
dayNumber = 1

IRs:
dayNumber(uint256) := 1(uint256)""];
32->33;
33[label=""Node Type: IF 33

EXPRESSION:
haveWinner

IRs:
CONDITION haveWinner""];
33->34[label=""True""];
33->35[label=""False""];
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
rInfoXrID[roundNumber].bounsInitNumber = getBounsWithRoundID(roundNumber.sub(1)).div(10)

IRs:
REF_59(DataModal.RoundInfo) -> rInfoXrID[roundNumber]
REF_60(uint256) -> REF_59.bounsInitNumber
TMP_55(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['roundNumber', '1'] 
TMP_56(uint256) = INTERNAL_CALL, Richer3D.getBounsWithRoundID(uint256)(TMP_55)
TMP_57(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_56', '10'] 
REF_60(uint256) (->rInfoXrID) := TMP_57(uint256)""];
34->36;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
rInfoXrID[roundNumber].bounsInitNumber = getBounsWithRoundID(roundNumber.sub(1))

IRs:
REF_63(DataModal.RoundInfo) -> rInfoXrID[roundNumber]
REF_64(uint256) -> REF_63.bounsInitNumber
TMP_58(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['roundNumber', '1'] 
TMP_59(uint256) = INTERNAL_CALL, Richer3D.getBounsWithRoundID(uint256)(TMP_58)
REF_64(uint256) (->rInfoXrID) := TMP_59(uint256)""];
35->36;
36[label=""Node Type: END_IF 36
""];
36->37;
37[label=""Node Type: EXPRESSION 37

EXPRESSION:
rInfoXrID[roundNumber].totalDay = 1

IRs:
REF_66(DataModal.RoundInfo) -> rInfoXrID[roundNumber]
REF_67(uint256) -> REF_66.totalDay
REF_67(uint256) (->rInfoXrID) := 1(uint256)""];
37->38;
38[label=""Node Type: EXPRESSION 38

EXPRESSION:
rInfoXrID[roundNumber].startTime = now

IRs:
REF_68(DataModal.RoundInfo) -> rInfoXrID[roundNumber]
REF_69(uint256) -> REF_68.startTime
REF_69(uint256) (->rInfoXrID) := now(uint256)""];
38->39;
39[label=""Node Type: EXPRESSION 39

EXPRESSION:
rInfoXrID[roundNumber].lastCalculateTime = now

IRs:
REF_70(DataModal.RoundInfo) -> rInfoXrID[roundNumber]
REF_71(uint256) -> REF_70.lastCalculateTime
REF_71(uint256) (->rInfoXrID) := now(uint256)""];
39->40;
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
calculateTargetEvent(roundNumber)

IRs:
Emit calculateTargetEvent(roundNumber)""];
40->41;
41[label=""Node Type: END_IF 41
""];
}
",1,0,0,0,"require(bool,string)(now.sub(rInfoXrID[roundNumber].lastCalculateTime) >= cycleTime,Less than cycle Time from last operation);dividends = p3dContract.myDividends(true);dividends > 0;rInfoXrID[roundNumber].dayInfoXDay[dayNumber].playerNumber > 0;;p3dDividesXroundID[roundNumber] = p3dDividesXroundID[roundNumber].add(dividends);platformBalance = platformBalance.add(dividends);p3dContract.withdraw();;p3dContract.withdraw();increaseBalance = getIncreaseBalance(dayNumber,roundNumber);targetBalance = getDailyTarget(roundNumber,dayNumber);increaseBalance >= targetBalance;getIncreaseBalance(dayNumber,roundNumber) > 0;haveWinner = false;p3dContract.buy.value(getIncreaseBalance(dayNumber,roundNumber).div(100))(p3dInviterAddress);;dayNumber = dayNumber.add(1);rInfoXrID[roundNumber].totalDay = dayNumber;rInfoXrID[roundNumber].startTime == 0;rInfoXrID[roundNumber].startTime = now;rInfoXrID[roundNumber].lastCalculateTime = rInfoXrID[roundNumber].startTime.add((cycleTime).mul(dayNumber.sub(1)));rInfoXrID[roundNumber].lastCalculateTime = now;;calculateTargetEvent(0);;dayNumber > 1;sendBalanceForDevelop(roundNumber);;haveWinner = true;rInfoXrID[roundNumber].winnerDay = dayNumber.sub(1);roundNumber = roundNumber.add(1);dayNumber = 1;haveWinner;rInfoXrID[roundNumber].bounsInitNumber = getBounsWithRoundID(roundNumber.sub(1)).div(10);rInfoXrID[roundNumber].bounsInitNumber = getBounsWithRoundID(roundNumber.sub(1));;rInfoXrID[roundNumber].totalDay = 1;rInfoXrID[roundNumber].startTime = now;rInfoXrID[roundNumber].lastCalculateTime = now;calculateTargetEvent(roundNumber)"
./0x4c84949b55f21a376dba12e732958ede8b033b0e_ext.sol,TokenVesting.release,220,224,"INTERNAL_CALL, TokenVesting.releaseFor(address)(msg.sender)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
releaseFor(msg.sender)

IRs:
INTERNAL_CALL, TokenVesting.releaseFor(address)(msg.sender)""];
}
",1,0,0,0,releaseFor(msg.sender)
./0x8615ddfe9d4c9e58abff01c999731f3e9e556e80_ext.sol,FrozenToken.approveAndCall,574,586,"TMP_380 = CONVERT _spender to ITokenRecipient,spender(ITokenRecipient) := TMP_380(ITokenRecipient),TMP_381(bool) = INTERNAL_CALL, FrozenToken.approve(address,uint256)(_spender,_value),CONDITION TMP_381,HIGH_LEVEL_CALL, dest:spender(ITokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,Emit ApproveAndCall(_spender,_value,_extraData),RETURN True,MODIFIER_CALL, Utils.validAddress(address)(_spender),MODIFIER_CALL, Utils.greaterThanZero(uint256)(_value),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = ITokenRecipient(_spender)

IRs:
TMP_380 = CONVERT _spender to ITokenRecipient
spender(ITokenRecipient) := TMP_380(ITokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_381(bool) = INTERNAL_CALL, FrozenToken.approve(address,uint256)(_spender,_value)
CONDITION TMP_381""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(ITokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ApproveAndCall(_spender,_value,_extraData)

IRs:
Emit ApproveAndCall(_spender,_value,_extraData)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: END_IF 6
""];
6->9;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
validAddress(_spender)

IRs:
MODIFIER_CALL, Utils.validAddress(address)(_spender)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
greaterThanZero(_value)

IRs:
MODIFIER_CALL, Utils.greaterThanZero(uint256)(_value)""];
8->1;
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,0,0,0,"validAddress(_spender);spender = ITokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;ApproveAndCall(_spender,_value,_extraData);true;success;greaterThanZero(_value)"
./0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06_ext.sol,SaleClockAuction.bidGift,1145,1157,"REF_364(ClockAuctionBase.Auction) -> tokenIdToAuction[_tokenId],REF_365(address) -> REF_364.seller,seller(address) := REF_365(address),TMP_1131(uint256) = INTERNAL_CALL, ClockAuctionBase._bid(uint256,uint256,address)(_tokenId,msg.value,msg.sender),price(uint256) := TMP_1131(uint256),INTERNAL_CALL, ClockAuctionBase._transfer(address,uint256)(_to,_tokenId),TMP_1133 = CONVERT gen0SellerAddress to address,TMP_1134(bool) = seller == TMP_1133,CONDITION TMP_1134,TMP_1135(uint256) = gen0SaleCount % 5,REF_366(uint256) -> lastGen0SalePrices[TMP_1135],REF_366(uint256) (->lastGen0SalePrices) := price(uint256),TMP_1136(uint256) := gen0SaleCount(uint256),gen0SaleCount(uint256) = gen0SaleCount + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
seller = tokenIdToAuction[_tokenId].seller

IRs:
REF_364(ClockAuctionBase.Auction) -> tokenIdToAuction[_tokenId]
REF_365(address) -> REF_364.seller
seller(address) := REF_365(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
price = _bid(_tokenId,msg.value,msg.sender)

IRs:
TMP_1131(uint256) = INTERNAL_CALL, ClockAuctionBase._bid(uint256,uint256,address)(_tokenId,msg.value,msg.sender)
price(uint256) := TMP_1131(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_transfer(_to,_tokenId)

IRs:
INTERNAL_CALL, ClockAuctionBase._transfer(address,uint256)(_to,_tokenId)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
seller == address(gen0SellerAddress)

IRs:
TMP_1133 = CONVERT gen0SellerAddress to address
TMP_1134(bool) = seller == TMP_1133
CONDITION TMP_1134""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
lastGen0SalePrices[gen0SaleCount % 5] = price

IRs:
TMP_1135(uint256) = gen0SaleCount % 5
REF_366(uint256) -> lastGen0SalePrices[TMP_1135]
REF_366(uint256) (->lastGen0SalePrices) := price(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
gen0SaleCount ++

IRs:
TMP_1136(uint256) := gen0SaleCount(uint256)
gen0SaleCount(uint256) = gen0SaleCount + 1""];
6->7;
7[label=""Node Type: END_IF 7
""];
}
",1,0,0,0,"seller = tokenIdToAuction[_tokenId].seller;price = _bid(_tokenId,msg.value,msg.sender);_transfer(_to,_tokenId);seller == address(gen0SellerAddress);lastGen0SalePrices[gen0SaleCount % 5] = price;;gen0SaleCount ++"
./0x3fde21c4118a7ac77e113920f76f68edd4fc144d_ext.sol,BEBmining.BebTomining,69,101,"TMP_9(uint256) = _value * ethExchuangeRate,TMP_10(uint256) = TMP_9 / bebethexchuang,usdt(uint256) := TMP_10(uint256),TMP_11(uint256) = 10 ** 18,TMP_12(uint256) = usdt * TMP_11,_udst(uint256) := TMP_12(uint256),REF_0(BEBmining.miner) -> miners[_addr],user(BEBmining.miner) := REF_0(BEBmining.miner),TMP_13(bool) = usdt > 50,TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13),TMP_15(bool) = usdt > 4900,CONDITION TMP_15,TMP_16(uint256) = _value * ethExchuangeRate,TMP_17(uint256) = TMP_16 / bebethexchuang,TMP_18(uint256) = TMP_17 * 150,TMP_19(uint256) = TMP_18 / 100,usdt(uint256) := TMP_19(uint256),TMP_20(uint256) = 10 ** 18,TMP_21(uint256) = usdt * TMP_20,_udst(uint256) := TMP_21(uint256),TMP_22(bool) = usdt > 900,CONDITION TMP_22,TMP_23(uint256) = _value * ethExchuangeRate,TMP_24(uint256) = TMP_23 / bebethexchuang,TMP_25(uint256) = TMP_24 * 130,TMP_26(uint256) = TMP_25 / 100,usdt(uint256) := TMP_26(uint256),TMP_27(uint256) = 10 ** 18,TMP_28(uint256) = usdt * TMP_27,_udst(uint256) := TMP_28(uint256),TMP_29(bool) = usdt > 450,CONDITION TMP_29,TMP_30(uint256) = _value * ethExchuangeRate,TMP_31(uint256) = TMP_30 / bebethexchuang,TMP_32(uint256) = TMP_31 * 120,TMP_33(uint256) = TMP_32 / 100,usdt(uint256) := TMP_33(uint256),TMP_34(uint256) = 10 ** 18,TMP_35(uint256) = usdt * TMP_34,_udst(uint256) := TMP_35(uint256),TMP_36(bool) = usdt > 270,CONDITION TMP_36,TMP_37(uint256) = _value * ethExchuangeRate,TMP_38(uint256) = TMP_37 / bebethexchuang,TMP_39(uint256) = TMP_38 * 110,TMP_40(uint256) = TMP_39 / 100,usdt(uint256) := TMP_40(uint256),TMP_41(uint256) = 10 ** 18,TMP_42(uint256) = usdt * TMP_41,_udst(uint256) := TMP_42(uint256),TMP_43 = CONVERT this to address,TMP_44(uint256) = 10 ** 18,TMP_45(uint256) = _value * TMP_44,HIGH_LEVEL_CALL, dest:bebTokenTransfer(tokenTransfer), function:transferFrom, arguments:['_addr', 'TMP_43', 'TMP_45']  ,TotalInvestment(uint256) = TotalInvestment + _udst,REF_2(uint256) -> user.mining,REF_2(-> user) = REF_2 + _udst,REF_3(uint256) -> user.lastDate,REF_3(uint256) (->user) := now(uint256),Emit bomus(_addr,_udst,Purchase success!)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
usdt = _value * ethExchuangeRate / bebethexchuang

IRs:
TMP_9(uint256) = _value * ethExchuangeRate
TMP_10(uint256) = TMP_9 / bebethexchuang
usdt(uint256) := TMP_10(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
_udst = usdt * 10 ** 18

IRs:
TMP_11(uint256) = 10 ** 18
TMP_12(uint256) = usdt * TMP_11
_udst(uint256) := TMP_12(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
user = miners[_addr]

IRs:
REF_0(BEBmining.miner) -> miners[_addr]
user(BEBmining.miner) := REF_0(BEBmining.miner)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(usdt > 50)

IRs:
TMP_13(bool) = usdt > 50
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
usdt > 4900

IRs:
TMP_15(bool) = usdt > 4900
CONDITION TMP_15""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
usdt = _value * ethExchuangeRate / bebethexchuang * 150 / 100

IRs:
TMP_16(uint256) = _value * ethExchuangeRate
TMP_17(uint256) = TMP_16 / bebethexchuang
TMP_18(uint256) = TMP_17 * 150
TMP_19(uint256) = TMP_18 / 100
usdt(uint256) := TMP_19(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
_udst = usdt * 10 ** 18

IRs:
TMP_20(uint256) = 10 ** 18
TMP_21(uint256) = usdt * TMP_20
_udst(uint256) := TMP_21(uint256)""];
7->20;
8[label=""Node Type: IF 8

EXPRESSION:
usdt > 900

IRs:
TMP_22(bool) = usdt > 900
CONDITION TMP_22""];
8->9[label=""True""];
8->11[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
usdt = _value * ethExchuangeRate / bebethexchuang * 130 / 100

IRs:
TMP_23(uint256) = _value * ethExchuangeRate
TMP_24(uint256) = TMP_23 / bebethexchuang
TMP_25(uint256) = TMP_24 * 130
TMP_26(uint256) = TMP_25 / 100
usdt(uint256) := TMP_26(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
_udst = usdt * 10 ** 18

IRs:
TMP_27(uint256) = 10 ** 18
TMP_28(uint256) = usdt * TMP_27
_udst(uint256) := TMP_28(uint256)""];
10->19;
11[label=""Node Type: IF 11

EXPRESSION:
usdt > 450

IRs:
TMP_29(bool) = usdt > 450
CONDITION TMP_29""];
11->12[label=""True""];
11->14[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
usdt = _value * ethExchuangeRate / bebethexchuang * 120 / 100

IRs:
TMP_30(uint256) = _value * ethExchuangeRate
TMP_31(uint256) = TMP_30 / bebethexchuang
TMP_32(uint256) = TMP_31 * 120
TMP_33(uint256) = TMP_32 / 100
usdt(uint256) := TMP_33(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
_udst = usdt * 10 ** 18

IRs:
TMP_34(uint256) = 10 ** 18
TMP_35(uint256) = usdt * TMP_34
_udst(uint256) := TMP_35(uint256)""];
13->18;
14[label=""Node Type: IF 14

EXPRESSION:
usdt > 270

IRs:
TMP_36(bool) = usdt > 270
CONDITION TMP_36""];
14->15[label=""True""];
14->17[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
usdt = _value * ethExchuangeRate / bebethexchuang * 110 / 100

IRs:
TMP_37(uint256) = _value * ethExchuangeRate
TMP_38(uint256) = TMP_37 / bebethexchuang
TMP_39(uint256) = TMP_38 * 110
TMP_40(uint256) = TMP_39 / 100
usdt(uint256) := TMP_40(uint256)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
_udst = usdt * 10 ** 18

IRs:
TMP_41(uint256) = 10 ** 18
TMP_42(uint256) = usdt * TMP_41
_udst(uint256) := TMP_42(uint256)""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
bebTokenTransfer.transferFrom(_addr,address(this),_value * 10 ** 18)

IRs:
TMP_43 = CONVERT this to address
TMP_44(uint256) = 10 ** 18
TMP_45(uint256) = _value * TMP_44
HIGH_LEVEL_CALL, dest:bebTokenTransfer(tokenTransfer), function:transferFrom, arguments:['_addr', 'TMP_43', 'TMP_45']  ""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
TotalInvestment += _udst

IRs:
TotalInvestment(uint256) = TotalInvestment + _udst""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
user.mining += _udst

IRs:
REF_2(uint256) -> user.mining
REF_2(-> user) = REF_2 + _udst""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
user.lastDate = now

IRs:
REF_3(uint256) -> user.lastDate
REF_3(uint256) (->user) := now(uint256)""];
24->25;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
bomus(_addr,_udst,Purchase success!)

IRs:
Emit bomus(_addr,_udst,Purchase success!)""];
}
",1,0,0,0,"usdt = _value * ethExchuangeRate / bebethexchuang;_udst = usdt * 10 ** 18;user = miners[_addr];require(bool)(usdt > 50);usdt > 4900;usdt = _value * ethExchuangeRate / bebethexchuang * 150 / 100;usdt > 900;_udst = usdt * 10 ** 18;;usdt = _value * ethExchuangeRate / bebethexchuang * 130 / 100;usdt > 450;_udst = usdt * 10 ** 18;;usdt = _value * ethExchuangeRate / bebethexchuang * 120 / 100;usdt > 270;_udst = usdt * 10 ** 18;;usdt = _value * ethExchuangeRate / bebethexchuang * 110 / 100;;_udst = usdt * 10 ** 18;bebTokenTransfer.transferFrom(_addr,address(this),_value * 10 ** 18);TotalInvestment += _udst;user.mining += _udst;user.lastDate = now;bomus(_addr,_udst,Purchase success!)"
./0x418d25d31c0a3c5559d8aa0c1c17d9cb3af9f59e_ext.sol,Deposit.transferEthTo,188,203,"TMP_37 = CONVERT this to address,TMP_38(uint256) = SOLIDITY_CALL balance(address)(TMP_37),TMP_39(bool) = TMP_38 > amount,TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39),TMP_41(uint256) = HIGH_LEVEL_CALL, dest:mp(MarketplaceProxy), function:calculatePlatformCommission, arguments:['amount']  ,commission(uint256) := TMP_41(uint256),TMP_42 = CONVERT this to address,TMP_43(uint256) = SOLIDITY_CALL balance(address)(TMP_42),TMP_44(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['amount', 'commission'] ,TMP_45(bool) = TMP_43 > TMP_44,TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45),HIGH_LEVEL_CALL, dest:mp(MarketplaceProxy), function:payPlatformOutgoingTransactionCommission, arguments:[] value:commission ,Emit PlatformOutgoingTransactionCommission(commission),Transfer dest:to value:amount,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(address(this).balance > amount)

IRs:
TMP_37 = CONVERT this to address
TMP_38(uint256) = SOLIDITY_CALL balance(address)(TMP_37)
TMP_39(bool) = TMP_38 > amount
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
commission = mp.calculatePlatformCommission(amount)

IRs:
TMP_41(uint256) = HIGH_LEVEL_CALL, dest:mp(MarketplaceProxy), function:calculatePlatformCommission, arguments:['amount']  
commission(uint256) := TMP_41(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(address(this).balance > amount.add(commission))

IRs:
TMP_42 = CONVERT this to address
TMP_43(uint256) = SOLIDITY_CALL balance(address)(TMP_42)
TMP_44(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['amount', 'commission'] 
TMP_45(bool) = TMP_43 > TMP_44
TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
mp.payPlatformOutgoingTransactionCommission.value(commission)()

IRs:
HIGH_LEVEL_CALL, dest:mp(MarketplaceProxy), function:payPlatformOutgoingTransactionCommission, arguments:[] value:commission ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
PlatformOutgoingTransactionCommission(commission)

IRs:
Emit PlatformOutgoingTransactionCommission(commission)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
to.transfer(amount)

IRs:
Transfer dest:to value:amount""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->1;
}
",1,0,0,0,onlyOwner();require(bool)(address(this).balance > amount);commission = mp.calculatePlatformCommission(amount);require(bool)(address(this).balance > amount.add(commission));mp.payPlatformOutgoingTransactionCommission.value(commission)();PlatformOutgoingTransactionCommission(commission);to.transfer(amount)
./0x77ceff4173a56cd22b6184fa59c668b364ae55b8_ext.sol,CarTaxiIco.importTokens,421,435,"TMP_249(bool) = msg.sender == icoManager,TMP_250(bool) = msg.sender == _account,TMP_251(bool) = TMP_249 || TMP_250,TMP_252(None) = SOLIDITY_CALL require(bool)(TMP_251),REF_74(bool) -> importedFromPreIco[_account],TMP_253 = UnaryType.BANG REF_74 ,TMP_254(None) = SOLIDITY_CALL require(bool)(TMP_253),TMP_255(uint256) = HIGH_LEVEL_CALL, dest:preIcoToken(AbstractToken), function:balanceOf, arguments:['_account']  ,preIcoBal(uint256) := TMP_255(uint256),TMP_256(uint256) = INTERNAL_CALL, SafeMath.presaleVolumeBonus(uint256)(preIcoBal),preIcoBalance(uint256) := TMP_256(uint256),TMP_257(bool) = preIcoBalance > 0,CONDITION TMP_257,HIGH_LEVEL_CALL, dest:cartaxiToken(CarTaxiToken), function:emitTokens, arguments:['_account', 'preIcoBalance']  ,TMP_259(uint256) = INTERNAL_CALL, SafeMath.add(uint256,uint256)(importedTokens,preIcoBalance),importedTokens(uint256) := TMP_259(uint256),REF_77(bool) -> importedFromPreIco[_account],REF_77(bool) (->importedFromPreIco) := True(bool)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == icoManager || msg.sender == _account)

IRs:
TMP_249(bool) = msg.sender == icoManager
TMP_250(bool) = msg.sender == _account
TMP_251(bool) = TMP_249 || TMP_250
TMP_252(None) = SOLIDITY_CALL require(bool)(TMP_251)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! importedFromPreIco[_account])

IRs:
REF_74(bool) -> importedFromPreIco[_account]
TMP_253 = UnaryType.BANG REF_74 
TMP_254(None) = SOLIDITY_CALL require(bool)(TMP_253)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
preIcoBal = preIcoToken.balanceOf(_account)

IRs:
TMP_255(uint256) = HIGH_LEVEL_CALL, dest:preIcoToken(AbstractToken), function:balanceOf, arguments:['_account']  
preIcoBal(uint256) := TMP_255(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
preIcoBalance = presaleVolumeBonus(preIcoBal)

IRs:
TMP_256(uint256) = INTERNAL_CALL, SafeMath.presaleVolumeBonus(uint256)(preIcoBal)
preIcoBalance(uint256) := TMP_256(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
preIcoBalance > 0

IRs:
TMP_257(bool) = preIcoBalance > 0
CONDITION TMP_257""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
cartaxiToken.emitTokens(_account,preIcoBalance)

IRs:
HIGH_LEVEL_CALL, dest:cartaxiToken(CarTaxiToken), function:emitTokens, arguments:['_account', 'preIcoBalance']  ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
importedTokens = add(importedTokens,preIcoBalance)

IRs:
TMP_259(uint256) = INTERNAL_CALL, SafeMath.add(uint256,uint256)(importedTokens,preIcoBalance)
importedTokens(uint256) := TMP_259(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
importedFromPreIco[_account] = true

IRs:
REF_77(bool) -> importedFromPreIco[_account]
REF_77(bool) (->importedFromPreIco) := True(bool)""];
}
",1,0,0,0,"require(bool)(msg.sender == icoManager || msg.sender == _account);require(bool)(! importedFromPreIco[_account]);preIcoBal = preIcoToken.balanceOf(_account);preIcoBalance = presaleVolumeBonus(preIcoBal);preIcoBalance > 0;cartaxiToken.emitTokens(_account,preIcoBalance);;importedTokens = add(importedTokens,preIcoBalance);importedFromPreIco[_account] = true"
./0x4c84949b55f21a376dba12e732958ede8b033b0e_ext.sol,TokenVesting.release,220,224,"INTERNAL_CALL, TokenVesting.releaseFor(address)(msg.sender)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
releaseFor(msg.sender)

IRs:
INTERNAL_CALL, TokenVesting.releaseFor(address)(msg.sender)""];
}
",1,0,0,0,releaseFor(msg.sender)
./0x574fb6d9d090042a04d0d12a4e87217f8303a5ca_ext.sol,GoldBackedToken.addAllocationPartOne,466,517,"thisAllocation(uint256) := newAllocation(uint256),TMP_292(bool) = totAllocation < maxAllocation,TMP_293(None) = SOLIDITY_CALL require(bool)(TMP_292),REF_74 -> LENGTH currentAllocations,REF_75 -> LENGTH partAllocations,TMP_294(bool) = REF_74 > REF_75,CONDITION TMP_294,partAllocations(GoldBackedToken.allocation[]) := currentAllocations(GoldBackedToken.allocation[]),TMP_295(uint256) = totAllocation + thisAllocation,TMP_296(bool) = TMP_295 > maxAllocation,CONDITION TMP_296,TMP_297(uint256) = maxAllocation - totAllocation,thisAllocation(uint256) := TMP_297(uint256),TMP_298(None) = SOLIDITY_CALL log0(bytes32)(max alloc reached),totAllocation(uint256) = totAllocation + thisAllocation,Emit Allocation(thisAllocation,now),REF_76(uint256) -> newDiv.amount,REF_76(uint256) (->newDiv) := thisAllocation(uint256),REF_77(uint256) -> newDiv.date,REF_77(uint256) (->newDiv) := now(uint256),REF_79 -> LENGTH allocationsOverTime,TMP_301(uint256) := REF_79(uint256),TMP_302(uint256) = TMP_301 + 1,REF_79(uint256) (->allocationsOverTime) := TMP_302(uint256),REF_80(GoldBackedToken.allocation) -> allocationsOverTime[TMP_301],REF_80(GoldBackedToken.allocation) (->allocationsOverTime) := newDiv(GoldBackedToken.allocation),REF_82 -> LENGTH partAllocations,TMP_304(uint256) := REF_82(uint256),TMP_305(uint256) = TMP_304 + 1,REF_82(uint256) (->partAllocations) := TMP_305(uint256),REF_83(GoldBackedToken.allocation) -> partAllocations[TMP_304],REF_83(GoldBackedToken.allocation) (->partAllocations) := newDiv(GoldBackedToken.allocation),partL(uint256) := TMP_303(None),REF_84 -> LENGTH partAllocations,TMP_306(bool) = REF_84 < 2,CONDITION TMP_306,Emit PartComplete(),currentAllocations(GoldBackedToken.allocation[]) := partAllocations(GoldBackedToken.allocation[]),Emit FeeOnAllocation(0,now),REF_85 -> LENGTH partAllocations,TMP_309(uint256) = REF_85 - 2,partPos(uint256) := TMP_309(uint256),TMP_310(bool) = partPos >= 0,CONDITION TMP_310,REF_86(GoldBackedToken.allocation) -> partAllocations[partPos],REF_87(uint256) -> REF_86.amount,REF_88(GoldBackedToken.allocation) -> partAllocations[partPos],REF_89(uint256) -> REF_88.date,REF_90(GoldBackedToken.allocation) -> partAllocations[partPos],REF_91(uint256) -> REF_90.amount,TUPLE_5(uint256,uint256) = INTERNAL_CALL, GoldBackedToken.calcFees(uint256,uint256,uint256)(REF_89,now,REF_91),REF_87(uint256)= UNPACK TUPLE_5 index: 0 ,partFees(uint256)= UNPACK TUPLE_5 index: 1 ,REF_92(GoldBackedToken.allocation) -> partAllocations[partPos],REF_93(uint256) -> REF_92.amount,TMP_311(uint256) = partL - 1,REF_94(GoldBackedToken.allocation) -> partAllocations[TMP_311],REF_95(uint256) -> REF_94.amount,REF_93(-> partAllocations) = REF_93 + REF_95,REF_96(GoldBackedToken.allocation) -> partAllocations[partPos],REF_97(uint256) -> REF_96.date,REF_97(uint256) (->partAllocations) := now(uint256),TMP_312(bool) = partPos == 0,REF_98 -> LENGTH partAllocations,TMP_313(uint256) = REF_98 - numSteps,TMP_314(bool) = partPos == TMP_313,TMP_315(bool) = TMP_312 || TMP_314,CONDITION TMP_315,TMP_316(uint256) := partPos(uint256),partPos(uint256) = partPos - 1,TMP_317(bool) = partPos != 0,CONDITION TMP_317,Emit StillToGo(partPos),Emit PartComplete(),Emit FeeOnAllocation(partFees,now),currentAllocations(GoldBackedToken.allocation[]) := partAllocations(GoldBackedToken.allocation[]),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->41;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
thisAllocation = newAllocation

IRs:
thisAllocation(uint256) := newAllocation(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(totAllocation < maxAllocation)

IRs:
TMP_292(bool) = totAllocation < maxAllocation
TMP_293(None) = SOLIDITY_CALL require(bool)(TMP_292)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
currentAllocations.length > partAllocations.length

IRs:
REF_74 -> LENGTH currentAllocations
REF_75 -> LENGTH partAllocations
TMP_294(bool) = REF_74 > REF_75
CONDITION TMP_294""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
partAllocations = currentAllocations

IRs:
partAllocations(GoldBackedToken.allocation[]) := currentAllocations(GoldBackedToken.allocation[])""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
totAllocation + thisAllocation > maxAllocation

IRs:
TMP_295(uint256) = totAllocation + thisAllocation
TMP_296(bool) = TMP_295 > maxAllocation
CONDITION TMP_296""];
6->7[label=""True""];
6->9[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
thisAllocation = maxAllocation - totAllocation

IRs:
TMP_297(uint256) = maxAllocation - totAllocation
thisAllocation(uint256) := TMP_297(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
log0(bytes32)(max alloc reached)

IRs:
TMP_298(None) = SOLIDITY_CALL log0(bytes32)(max alloc reached)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
totAllocation += thisAllocation

IRs:
totAllocation(uint256) = totAllocation + thisAllocation""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
Allocation(thisAllocation,now)

IRs:
Emit Allocation(thisAllocation,now)""];
11->12;
12[label=""Node Type: NEW VARIABLE 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
newDiv.amount = thisAllocation

IRs:
REF_76(uint256) -> newDiv.amount
REF_76(uint256) (->newDiv) := thisAllocation(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
newDiv.date = now

IRs:
REF_77(uint256) -> newDiv.date
REF_77(uint256) (->newDiv) := now(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
allocationsOverTime.push(newDiv)

IRs:
REF_79 -> LENGTH allocationsOverTime
TMP_301(uint256) := REF_79(uint256)
TMP_302(uint256) = TMP_301 + 1
REF_79(uint256) (->allocationsOverTime) := TMP_302(uint256)
REF_80(GoldBackedToken.allocation) -> allocationsOverTime[TMP_301]
REF_80(GoldBackedToken.allocation) (->allocationsOverTime) := newDiv(GoldBackedToken.allocation)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
partL = partAllocations.push(newDiv)

IRs:
REF_82 -> LENGTH partAllocations
TMP_304(uint256) := REF_82(uint256)
TMP_305(uint256) = TMP_304 + 1
REF_82(uint256) (->partAllocations) := TMP_305(uint256)
REF_83(GoldBackedToken.allocation) -> partAllocations[TMP_304]
REF_83(GoldBackedToken.allocation) (->partAllocations) := newDiv(GoldBackedToken.allocation)
partL(uint256) := TMP_303(None)""];
16->17;
17[label=""Node Type: IF 17

EXPRESSION:
partAllocations.length < 2

IRs:
REF_84 -> LENGTH partAllocations
TMP_306(bool) = REF_84 < 2
CONDITION TMP_306""];
17->18[label=""True""];
17->22[label=""False""];
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
PartComplete()

IRs:
Emit PartComplete()""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
currentAllocations = partAllocations

IRs:
currentAllocations(GoldBackedToken.allocation[]) := partAllocations(GoldBackedToken.allocation[])""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
FeeOnAllocation(0,now)

IRs:
Emit FeeOnAllocation(0,now)""];
20->21;
21[label=""Node Type: RETURN 21
""];
22[label=""Node Type: END_IF 22
""];
22->25;
23[label=""Node Type: BEGIN_LOOP 23
""];
23->26;
24[label=""Node Type: END_LOOP 24
""];
24->34;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
partPos = partAllocations.length - 2

IRs:
REF_85 -> LENGTH partAllocations
TMP_309(uint256) = REF_85 - 2
partPos(uint256) := TMP_309(uint256)""];
25->23;
26[label=""Node Type: IF_LOOP 26

EXPRESSION:
partPos >= 0

IRs:
TMP_310(bool) = partPos >= 0
CONDITION TMP_310""];
26->27[label=""True""];
26->24[label=""False""];
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
(partAllocations[partPos].amount,partFees) = calcFees(partAllocations[partPos].date,now,partAllocations[partPos].amount)

IRs:
REF_86(GoldBackedToken.allocation) -> partAllocations[partPos]
REF_87(uint256) -> REF_86.amount
REF_88(GoldBackedToken.allocation) -> partAllocations[partPos]
REF_89(uint256) -> REF_88.date
REF_90(GoldBackedToken.allocation) -> partAllocations[partPos]
REF_91(uint256) -> REF_90.amount
TUPLE_5(uint256,uint256) = INTERNAL_CALL, GoldBackedToken.calcFees(uint256,uint256,uint256)(REF_89,now,REF_91)
REF_87(uint256)= UNPACK TUPLE_5 index: 0 
partFees(uint256)= UNPACK TUPLE_5 index: 1 ""];
27->28;
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
partAllocations[partPos].amount += partAllocations[partL - 1].amount

IRs:
REF_92(GoldBackedToken.allocation) -> partAllocations[partPos]
REF_93(uint256) -> REF_92.amount
TMP_311(uint256) = partL - 1
REF_94(GoldBackedToken.allocation) -> partAllocations[TMP_311]
REF_95(uint256) -> REF_94.amount
REF_93(-> partAllocations) = REF_93 + REF_95""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
partAllocations[partPos].date = now

IRs:
REF_96(GoldBackedToken.allocation) -> partAllocations[partPos]
REF_97(uint256) -> REF_96.date
REF_97(uint256) (->partAllocations) := now(uint256)""];
29->30;
30[label=""Node Type: IF 30

EXPRESSION:
(partPos == 0) || (partPos == partAllocations.length - numSteps)

IRs:
TMP_312(bool) = partPos == 0
REF_98 -> LENGTH partAllocations
TMP_313(uint256) = REF_98 - numSteps
TMP_314(bool) = partPos == TMP_313
TMP_315(bool) = TMP_312 || TMP_314
CONDITION TMP_315""];
30->31[label=""True""];
30->32[label=""False""];
31[label=""Node Type: BREAK 31
""];
31->24;
32[label=""Node Type: END_IF 32
""];
32->33;
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
partPos --

IRs:
TMP_316(uint256) := partPos(uint256)
partPos(uint256) = partPos - 1""];
33->26;
34[label=""Node Type: IF 34

EXPRESSION:
partPos != 0

IRs:
TMP_317(bool) = partPos != 0
CONDITION TMP_317""];
34->35[label=""True""];
34->37[label=""False""];
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
StillToGo(partPos)

IRs:
Emit StillToGo(partPos)""];
35->36;
36[label=""Node Type: RETURN 36
""];
37[label=""Node Type: END_IF 37
""];
37->38;
38[label=""Node Type: EXPRESSION 38

EXPRESSION:
PartComplete()

IRs:
Emit PartComplete()""];
38->39;
39[label=""Node Type: EXPRESSION 39

EXPRESSION:
FeeOnAllocation(partFees,now)

IRs:
Emit FeeOnAllocation(partFees,now)""];
39->40;
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
currentAllocations = partAllocations

IRs:
currentAllocations(GoldBackedToken.allocation[]) := partAllocations(GoldBackedToken.allocation[])""];
41[label=""Node Type: EXPRESSION 41

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
41->1;
}
",1,0,0,0,"onlyOwner();thisAllocation = newAllocation;require(bool)(totAllocation < maxAllocation);currentAllocations.length > partAllocations.length;partAllocations = currentAllocations;;totAllocation + thisAllocation > maxAllocation;thisAllocation = maxAllocation - totAllocation;;log0(bytes32)(max alloc reached);totAllocation += thisAllocation;Allocation(thisAllocation,now);;newDiv.amount = thisAllocation;newDiv.date = now;allocationsOverTime.push(newDiv);partL = partAllocations.push(newDiv);partAllocations.length < 2;PartComplete();;currentAllocations = partAllocations;FeeOnAllocation(0,now);;partPos = partAllocations.length - 2;;partPos >= 0;;partPos != 0;(partAllocations[partPos].amount,partFees) = calcFees(partAllocations[partPos].date,now,partAllocations[partPos].amount);partAllocations[partPos].amount += partAllocations[partL - 1].amount;partAllocations[partPos].date = now;(partPos == 0) || (partPos == partAllocations.length - numSteps);;;partPos --;StillToGo(partPos);;;PartComplete();FeeOnAllocation(partFees,now);currentAllocations = partAllocations"
./0xa304100e0d17a972f34ed8a961034ce2fc47f9ca_ext.sol,FomoBet.takeOffer,97,114,"sender(address) := msg.sender(address),value(uint256) := msg.value(uint256),timer(uint256) := now(uint256),REF_45(FomoBet.offer) -> OpenOffers[offerNumber],REF_46(uint256) -> REF_45.amount,TMP_36(bool) = amountOffers >= REF_46,TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36),REF_48(FomoBet.offer) -> OpenOffers[offerNumber],REF_49(uint256) -> REF_48.takerSize,TMP_38(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['amountOffers', 'REF_49'] ,TMP_39(bool) = value >= TMP_38,TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39),REF_50(FomoBet.bet) -> placedBets[nextBetInLine],REF_51(bool) -> REF_50.longOrShort,REF_52(FomoBet.offer) -> OpenOffers[offerNumber],REF_53(bool) -> REF_52.longOrShort,REF_51(bool) (->placedBets) := REF_53(bool),REF_54(FomoBet.bet) -> placedBets[nextBetInLine],REF_55(address) -> REF_54.maker,REF_56(FomoBet.offer) -> OpenOffers[offerNumber],REF_57(address) -> REF_56.maker,REF_55(address) (->placedBets) := REF_57(address),REF_58(FomoBet.bet) -> placedBets[nextBetInLine],REF_59(address) -> REF_58.taker,REF_59(address) (->placedBets) := sender(address),REF_60(FomoBet.offer) -> OpenOffers[offerNumber],REF_61(uint256) -> REF_60.betEndInDays,TMP_41(uint256) = REF_61 * 86400,timeframe(uint256) := TMP_41(uint256),REF_62(FomoBet.bet) -> placedBets[nextBetInLine],REF_63(uint256) -> REF_62.betEnd,TMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['timer', 'timeframe'] ,REF_63(uint256) (->placedBets) := TMP_42(uint256),REF_65(FomoBet.bet) -> placedBets[nextBetInLine],REF_66(uint256) -> REF_65.round,TMP_43(uint256) = HIGH_LEVEL_CALL, dest:FoMo3Dlong_(FoMo3Dlong), function:rID_, arguments:[]  ,REF_66(uint256) (->placedBets) := TMP_43(uint256),REF_68(FomoBet.bet) -> placedBets[nextBetInLine],REF_69(uint256) -> REF_68.betSize,REF_72(FomoBet.offer) -> OpenOffers[offerNumber],REF_73(uint256) -> REF_72.betSize,TMP_44(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['amountOffers', 'REF_73'] ,TMP_45(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['value', 'TMP_44'] ,REF_69(uint256) (->placedBets) := TMP_45(uint256),REF_74(FomoBet.offer) -> OpenOffers[offerNumber],REF_75(uint256) -> REF_74.amount,REF_76(FomoBet.offer) -> OpenOffers[offerNumber],REF_77(uint256) -> REF_76.amount,TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_77', 'amountOffers'] ,REF_75(uint256) (->OpenOffers) := TMP_46(uint256),TMP_47(uint256) := nextBetInLine(uint256),nextBetInLine(uint256) = nextBetInLine + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
sender = msg.sender

IRs:
sender(address) := msg.sender(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
value = msg.value

IRs:
value(uint256) := msg.value(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
timer = now

IRs:
timer(uint256) := now(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(amountOffers >= OpenOffers[offerNumber].amount)

IRs:
REF_45(FomoBet.offer) -> OpenOffers[offerNumber]
REF_46(uint256) -> REF_45.amount
TMP_36(bool) = amountOffers >= REF_46
TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(value >= amountOffers.mul(OpenOffers[offerNumber].takerSize))

IRs:
REF_48(FomoBet.offer) -> OpenOffers[offerNumber]
REF_49(uint256) -> REF_48.takerSize
TMP_38(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['amountOffers', 'REF_49'] 
TMP_39(bool) = value >= TMP_38
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
placedBets[nextBetInLine].longOrShort = OpenOffers[offerNumber].longOrShort

IRs:
REF_50(FomoBet.bet) -> placedBets[nextBetInLine]
REF_51(bool) -> REF_50.longOrShort
REF_52(FomoBet.offer) -> OpenOffers[offerNumber]
REF_53(bool) -> REF_52.longOrShort
REF_51(bool) (->placedBets) := REF_53(bool)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
placedBets[nextBetInLine].maker = OpenOffers[offerNumber].maker

IRs:
REF_54(FomoBet.bet) -> placedBets[nextBetInLine]
REF_55(address) -> REF_54.maker
REF_56(FomoBet.offer) -> OpenOffers[offerNumber]
REF_57(address) -> REF_56.maker
REF_55(address) (->placedBets) := REF_57(address)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
placedBets[nextBetInLine].taker = sender

IRs:
REF_58(FomoBet.bet) -> placedBets[nextBetInLine]
REF_59(address) -> REF_58.taker
REF_59(address) (->placedBets) := sender(address)""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
timeframe = OpenOffers[offerNumber].betEndInDays * 86400

IRs:
REF_60(FomoBet.offer) -> OpenOffers[offerNumber]
REF_61(uint256) -> REF_60.betEndInDays
TMP_41(uint256) = REF_61 * 86400
timeframe(uint256) := TMP_41(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
placedBets[nextBetInLine].betEnd = timer.add(timeframe)

IRs:
REF_62(FomoBet.bet) -> placedBets[nextBetInLine]
REF_63(uint256) -> REF_62.betEnd
TMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['timer', 'timeframe'] 
REF_63(uint256) (->placedBets) := TMP_42(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
placedBets[nextBetInLine].round = FoMo3Dlong_.rID_()

IRs:
REF_65(FomoBet.bet) -> placedBets[nextBetInLine]
REF_66(uint256) -> REF_65.round
TMP_43(uint256) = HIGH_LEVEL_CALL, dest:FoMo3Dlong_(FoMo3Dlong), function:rID_, arguments:[]  
REF_66(uint256) (->placedBets) := TMP_43(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
placedBets[nextBetInLine].betSize = value.add(amountOffers.mul(OpenOffers[offerNumber].betSize))

IRs:
REF_68(FomoBet.bet) -> placedBets[nextBetInLine]
REF_69(uint256) -> REF_68.betSize
REF_72(FomoBet.offer) -> OpenOffers[offerNumber]
REF_73(uint256) -> REF_72.betSize
TMP_44(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['amountOffers', 'REF_73'] 
TMP_45(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['value', 'TMP_44'] 
REF_69(uint256) (->placedBets) := TMP_45(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
OpenOffers[offerNumber].amount = OpenOffers[offerNumber].amount.sub(amountOffers)

IRs:
REF_74(FomoBet.offer) -> OpenOffers[offerNumber]
REF_75(uint256) -> REF_74.amount
REF_76(FomoBet.offer) -> OpenOffers[offerNumber]
REF_77(uint256) -> REF_76.amount
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_77', 'amountOffers'] 
REF_75(uint256) (->OpenOffers) := TMP_46(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
nextBetInLine ++

IRs:
TMP_47(uint256) := nextBetInLine(uint256)
nextBetInLine(uint256) = nextBetInLine + 1""];
}
",1,0,0,0,sender = msg.sender;value = msg.value;timer = now;require(bool)(amountOffers >= OpenOffers[offerNumber].amount);require(bool)(value >= amountOffers.mul(OpenOffers[offerNumber].takerSize));placedBets[nextBetInLine].longOrShort = OpenOffers[offerNumber].longOrShort;placedBets[nextBetInLine].maker = OpenOffers[offerNumber].maker;placedBets[nextBetInLine].taker = sender;timeframe = OpenOffers[offerNumber].betEndInDays * 86400;placedBets[nextBetInLine].betEnd = timer.add(timeframe);placedBets[nextBetInLine].round = FoMo3Dlong_.rID_();placedBets[nextBetInLine].betSize = value.add(amountOffers.mul(OpenOffers[offerNumber].betSize));OpenOffers[offerNumber].amount = OpenOffers[offerNumber].amount.sub(amountOffers);nextBetInLine ++
./0x00c315ac9ff89bb6afa7524cd159f0a9766e8c89_ext.sol,IMDEXDexchange.IMDEXdepositToken,109,114,"REF_3(mapping(address => uint256)) -> tokens[token],REF_4(uint256) -> REF_3[msg.sender],REF_5(mapping(address => uint256)) -> tokens[token],REF_6(uint256) -> REF_5[msg.sender],TMP_34(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_6,amount),REF_4(uint256) (->tokens) := TMP_34(uint256),REF_7(uint256) -> lastActiveTransaction[msg.sender],REF_7(uint256) (->lastActiveTransaction) := block.number(uint256),TMP_35 = CONVERT token to IMDEX,TMP_36(bool) = HIGH_LEVEL_CALL, dest:TMP_35(IMDEX), function:transferFrom, arguments:['msg.sender', 'this', 'amount']  ,TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36),REF_9(mapping(address => uint256)) -> tokens[token],REF_10(uint256) -> REF_9[msg.sender],Emit Deposit(token,msg.sender,amount,REF_10)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender],amount)

IRs:
REF_3(mapping(address => uint256)) -> tokens[token]
REF_4(uint256) -> REF_3[msg.sender]
REF_5(mapping(address => uint256)) -> tokens[token]
REF_6(uint256) -> REF_5[msg.sender]
TMP_34(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_6,amount)
REF_4(uint256) (->tokens) := TMP_34(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
lastActiveTransaction[msg.sender] = block.number

IRs:
REF_7(uint256) -> lastActiveTransaction[msg.sender]
REF_7(uint256) (->lastActiveTransaction) := block.number(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(IMDEX(token).transferFrom(msg.sender,this,amount))

IRs:
TMP_35 = CONVERT token to IMDEX
TMP_36(bool) = HIGH_LEVEL_CALL, dest:TMP_35(IMDEX), function:transferFrom, arguments:['msg.sender', 'this', 'amount']  
TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Deposit(token,msg.sender,amount,tokens[token][msg.sender])

IRs:
REF_9(mapping(address => uint256)) -> tokens[token]
REF_10(uint256) -> REF_9[msg.sender]
Emit Deposit(token,msg.sender,amount,REF_10)""];
}
",1,0,0,0,"tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender],amount);lastActiveTransaction[msg.sender] = block.number;require(bool)(IMDEX(token).transferFrom(msg.sender,this,amount));Deposit(token,msg.sender,amount,tokens[token][msg.sender])"
./0x21ad0028fea5fafa55b9b60e9c065db9f1c0616e_ext.sol,LikeCrowdsale.addPrivateFund,452,457,"TMP_256(bool) = now < start,TMP_257(None) = SOLIDITY_CALL require(bool)(TMP_256),TMP_258(bool) = _value > 0,TMP_259(None) = SOLIDITY_CALL require(bool)(TMP_258),TMP_260(bool) = HIGH_LEVEL_CALL, dest:like(LikeCoin), function:transferAndLock, arguments:['_addr', '_value']  ,Emit AddPrivateFund(_addr,_value),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now < start)

IRs:
TMP_256(bool) = now < start
TMP_257(None) = SOLIDITY_CALL require(bool)(TMP_256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_258(bool) = _value > 0
TMP_259(None) = SOLIDITY_CALL require(bool)(TMP_258)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
like.transferAndLock(_addr,_value)

IRs:
TMP_260(bool) = HIGH_LEVEL_CALL, dest:like(LikeCoin), function:transferAndLock, arguments:['_addr', '_value']  ""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
AddPrivateFund(_addr,_value)

IRs:
Emit AddPrivateFund(_addr,_value)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",1,0,0,0,"onlyOwner();require(bool)(now < start);require(bool)(_value > 0);like.transferAndLock(_addr,_value);AddPrivateFund(_addr,_value)"
./0x2898ca01df2dc4062e8b269806de4996295a1f5c_ext.sol,SaleAuction.createAuction,226,237,"INTERNAL_CALL, AuctionBase._escrow(address,uint256)(_seller,_tokenId),TMP_56(AuctionBase.Auction) = new Auction(_seller,_sellPrice),auction(AuctionBase.Auction) := TMP_56(AuctionBase.Auction),INTERNAL_CALL, AuctionBase._addAuction(uint256,AuctionBase.Auction)(_tokenId,auction)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_escrow(_seller,_tokenId)

IRs:
INTERNAL_CALL, AuctionBase._escrow(address,uint256)(_seller,_tokenId)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
auction = Auction(_seller,_sellPrice)

IRs:
TMP_56(AuctionBase.Auction) = new Auction(_seller,_sellPrice)
auction(AuctionBase.Auction) := TMP_56(AuctionBase.Auction)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_addAuction(_tokenId,auction)

IRs:
INTERNAL_CALL, AuctionBase._addAuction(uint256,AuctionBase.Auction)(_tokenId,auction)""];
}
",1,0,0,0,"_escrow(_seller,_tokenId);auction = Auction(_seller,_sellPrice);_addAuction(_tokenId,auction)"
./0x797d713d8d7a2815ccf3dcf9719e3e9f1712c370_ext.sol,Trustee.grant,568,596,"TMP_290 = CONVERT 0 to address,TMP_291(bool) = _to != TMP_290,TMP_292(None) = SOLIDITY_CALL require(bool)(TMP_291),TMP_293(bool) = _value > 0,TMP_294(None) = SOLIDITY_CALL require(bool)(TMP_293),REF_71(Trustee.Grant) -> grants[_to],REF_72(uint256) -> REF_71.value,TMP_295(bool) = REF_72 == 0,TMP_296(None) = SOLIDITY_CALL require(bool)(TMP_295),TMP_297(bool) = _start <= _cliff,TMP_298(bool) = _cliff <= _end,TMP_299(bool) = TMP_297 && TMP_298,TMP_300(None) = SOLIDITY_CALL require(bool)(TMP_299),TMP_301(uint256) = LIBRARY_CALL, dest:SaferMath, function:SaferMath.add(uint256,uint256), arguments:['totalVesting', '_value'] ,TMP_302 = CONVERT this to address,TMP_303(uint256) = HIGH_LEVEL_CALL, dest:stox(StoxSmartToken), function:balanceOf, arguments:['TMP_302']  ,TMP_304(bool) = TMP_301 <= TMP_303,TMP_305(None) = SOLIDITY_CALL require(bool)(TMP_304),REF_75(Trustee.Grant) -> grants[_to],TMP_306(Trustee.Grant) = new Grant(_value,_start,_cliff,_end,0,_revokable),REF_75(Trustee.Grant) (->grants) := TMP_306(Trustee.Grant),TMP_307(uint256) = LIBRARY_CALL, dest:SaferMath, function:SaferMath.add(uint256,uint256), arguments:['totalVesting', '_value'] ,totalVesting(uint256) := TMP_307(uint256),Emit NewGrant(msg.sender,_to,_value),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_290 = CONVERT 0 to address
TMP_291(bool) = _to != TMP_290
TMP_292(None) = SOLIDITY_CALL require(bool)(TMP_291)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_293(bool) = _value > 0
TMP_294(None) = SOLIDITY_CALL require(bool)(TMP_293)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(grants[_to].value == 0)

IRs:
REF_71(Trustee.Grant) -> grants[_to]
REF_72(uint256) -> REF_71.value
TMP_295(bool) = REF_72 == 0
TMP_296(None) = SOLIDITY_CALL require(bool)(TMP_295)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_start <= _cliff && _cliff <= _end)

IRs:
TMP_297(bool) = _start <= _cliff
TMP_298(bool) = _cliff <= _end
TMP_299(bool) = TMP_297 && TMP_298
TMP_300(None) = SOLIDITY_CALL require(bool)(TMP_299)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(totalVesting.add(_value) <= stox.balanceOf(address(this)))

IRs:
TMP_301(uint256) = LIBRARY_CALL, dest:SaferMath, function:SaferMath.add(uint256,uint256), arguments:['totalVesting', '_value'] 
TMP_302 = CONVERT this to address
TMP_303(uint256) = HIGH_LEVEL_CALL, dest:stox(StoxSmartToken), function:balanceOf, arguments:['TMP_302']  
TMP_304(bool) = TMP_301 <= TMP_303
TMP_305(None) = SOLIDITY_CALL require(bool)(TMP_304)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
grants[_to] = Grant({value:_value,start:_start,cliff:_cliff,end:_end,transferred:0,revokable:_revokable})

IRs:
REF_75(Trustee.Grant) -> grants[_to]
TMP_306(Trustee.Grant) = new Grant(_value,_start,_cliff,_end,0,_revokable)
REF_75(Trustee.Grant) (->grants) := TMP_306(Trustee.Grant)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
totalVesting = totalVesting.add(_value)

IRs:
TMP_307(uint256) = LIBRARY_CALL, dest:SaferMath, function:SaferMath.add(uint256,uint256), arguments:['totalVesting', '_value'] 
totalVesting(uint256) := TMP_307(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
NewGrant(msg.sender,_to,_value)

IRs:
Emit NewGrant(msg.sender,_to,_value)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
9->1;
}
",1,0,0,0,"onlyOwner();require(bool)(_to != address(0));require(bool)(_value > 0);require(bool)(grants[_to].value == 0);require(bool)(_start <= _cliff && _cliff <= _end);require(bool)(totalVesting.add(_value) <= stox.balanceOf(address(this)));grants[_to] = Grant({value:_value,start:_start,cliff:_cliff,end:_end,transferred:0,revokable:_revokable});totalVesting = totalVesting.add(_value);NewGrant(msg.sender,_to,_value)"
./0x174bb5d84b78e9e2248e7aa2c789aeba82f72f68_ext.sol,LuckyTree.manuallyProcessTransaction,348,357,"TMP_126(bool) = _value == leafPrice,TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126),TMP_128 = CONVERT tokenAddress to IERC20Token,TMP_129 = CONVERT this to address,TMP_130(uint256) = HIGH_LEVEL_CALL, dest:TMP_128(IERC20Token), function:balanceOf, arguments:['TMP_129']  ,TMP_131(uint256) = _value + totalParticipationAmount,TMP_132(bool) = TMP_130 >= TMP_131,TMP_133(None) = SOLIDITY_CALL require(bool)(TMP_132),REF_42(LuckyTree.state) -> state.running,TMP_134(bool) = gameState == REF_42,TMP_135(bool) = block.number < gameDuration,TMP_136(bool) = TMP_134 && TMP_135,CONDITION TMP_136,TMP_137(uint256) = INTERNAL_CALL, LuckyTree.processTransaction(address,uint256)(_from,_value),tokensToTake(uint256) := TMP_137(uint256),TMP_138 = CONVERT tokenAddress to IERC20Token,TMP_139 = CONVERT this to address,TMP_140(bool) = HIGH_LEVEL_CALL, dest:TMP_138(IERC20Token), function:transferFrom, arguments:['_from', 'TMP_139', 'tokensToTake']  ,MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value == leafPrice)

IRs:
TMP_126(bool) = _value == leafPrice
TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(IERC20Token(tokenAddress).balanceOf(address(this)) >= _value + totalParticipationAmount)

IRs:
TMP_128 = CONVERT tokenAddress to IERC20Token
TMP_129 = CONVERT this to address
TMP_130(uint256) = HIGH_LEVEL_CALL, dest:TMP_128(IERC20Token), function:balanceOf, arguments:['TMP_129']  
TMP_131(uint256) = _value + totalParticipationAmount
TMP_132(bool) = TMP_130 >= TMP_131
TMP_133(None) = SOLIDITY_CALL require(bool)(TMP_132)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
gameState == state.running && block.number < gameDuration

IRs:
REF_42(LuckyTree.state) -> state.running
TMP_134(bool) = gameState == REF_42
TMP_135(bool) = block.number < gameDuration
TMP_136(bool) = TMP_134 && TMP_135
CONDITION TMP_136""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
tokensToTake = processTransaction(_from,_value)

IRs:
TMP_137(uint256) = INTERNAL_CALL, LuckyTree.processTransaction(address,uint256)(_from,_value)
tokensToTake(uint256) := TMP_137(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
IERC20Token(tokenAddress).transferFrom(_from,address(this),tokensToTake)

IRs:
TMP_138 = CONVERT tokenAddress to IERC20Token
TMP_139 = CONVERT this to address
TMP_140(bool) = HIGH_LEVEL_CALL, dest:TMP_138(IERC20Token), function:transferFrom, arguments:['_from', 'TMP_139', 'tokensToTake']  ""];
5->6;
6[label=""Node Type: END_IF 6
""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
7->1;
}
",1,0,0,0,"onlyOwner();require(bool)(_value == leafPrice);require(bool)(IERC20Token(tokenAddress).balanceOf(address(this)) >= _value + totalParticipationAmount);gameState == state.running && block.number < gameDuration;tokensToTake = processTransaction(_from,_value);;IERC20Token(tokenAddress).transferFrom(_from,address(this),tokensToTake)"
./0xc3e329ca5380c6b416cf095ed1a662c378a2b630_ext.sol,TaurusPay.claim,353,372,"currentTime(uint256) := now(uint256),TMP_177(bool) = INTERNAL_CALL, TaurusPay.validPurchaseTime(uint256)(currentTime),TMP_178(None) = SOLIDITY_CALL require(bool)(TMP_177),TMP_179(bool) = msg.value >= priceClaim,TMP_180(None) = SOLIDITY_CALL require(bool)(TMP_179),beneficiar(address) := msg.sender(address),TMP_181 = CONVERT 0 to address,TMP_182(bool) = beneficiar != TMP_181,TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182),TMP_184 = UnaryType.BANG mintingFinished ,TMP_185(None) = SOLIDITY_CALL require(bool)(TMP_184),TMP_186(uint256) = INTERNAL_CALL, TaurusPay.calcAmount(address)(beneficiar),amount(uint256) := TMP_186(uint256),REF_134(uint256) -> balances[owner],TMP_187(bool) = amount <= REF_134,TMP_188(None) = SOLIDITY_CALL require(bool)(TMP_187),REF_135(uint256) -> balances[beneficiar],REF_136(uint256) -> balances[beneficiar],TMP_189(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_136', 'amount'] ,REF_135(uint256) (->balances) := TMP_189(uint256),REF_138(uint256) -> balances[owner],REF_139(uint256) -> balances[owner],TMP_190(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_139', 'amount'] ,REF_138(uint256) (->balances) := TMP_190(uint256),TMP_191(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokenAllocated', 'amount'] ,tokenAllocated(uint256) := TMP_191(uint256),Transfer dest:owner value:msg.value,Emit Mint(beneficiar,amount),Emit Transfer(owner,beneficiar,amount),RETURN True,MODIFIER_CALL, TaurusPay.canMint()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->16;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
currentTime = now

IRs:
currentTime(uint256) := now(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(validPurchaseTime(currentTime))

IRs:
TMP_177(bool) = INTERNAL_CALL, TaurusPay.validPurchaseTime(uint256)(currentTime)
TMP_178(None) = SOLIDITY_CALL require(bool)(TMP_177)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(msg.value >= priceClaim)

IRs:
TMP_179(bool) = msg.value >= priceClaim
TMP_180(None) = SOLIDITY_CALL require(bool)(TMP_179)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
beneficiar = msg.sender

IRs:
beneficiar(address) := msg.sender(address)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(beneficiar != address(0))

IRs:
TMP_181 = CONVERT 0 to address
TMP_182(bool) = beneficiar != TMP_181
TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(! mintingFinished)

IRs:
TMP_184 = UnaryType.BANG mintingFinished 
TMP_185(None) = SOLIDITY_CALL require(bool)(TMP_184)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
amount = calcAmount(beneficiar)

IRs:
TMP_186(uint256) = INTERNAL_CALL, TaurusPay.calcAmount(address)(beneficiar)
amount(uint256) := TMP_186(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(amount <= balances[owner])

IRs:
REF_134(uint256) -> balances[owner]
TMP_187(bool) = amount <= REF_134
TMP_188(None) = SOLIDITY_CALL require(bool)(TMP_187)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
balances[beneficiar] = balances[beneficiar].add(amount)

IRs:
REF_135(uint256) -> balances[beneficiar]
REF_136(uint256) -> balances[beneficiar]
TMP_189(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_136', 'amount'] 
REF_135(uint256) (->balances) := TMP_189(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
balances[owner] = balances[owner].sub(amount)

IRs:
REF_138(uint256) -> balances[owner]
REF_139(uint256) -> balances[owner]
TMP_190(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_139', 'amount'] 
REF_138(uint256) (->balances) := TMP_190(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
tokenAllocated = tokenAllocated.add(amount)

IRs:
TMP_191(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokenAllocated', 'amount'] 
tokenAllocated(uint256) := TMP_191(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
owner.transfer(msg.value)

IRs:
Transfer dest:owner value:msg.value""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
Mint(beneficiar,amount)

IRs:
Emit Mint(beneficiar,amount)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
Transfer(owner,beneficiar,amount)

IRs:
Emit Transfer(owner,beneficiar,amount)""];
14->15;
15[label=""Node Type: RETURN 15

EXPRESSION:
true

IRs:
RETURN True""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, TaurusPay.canMint()()""];
16->1;
}
",1,0,0,0,"canMint();currentTime = now;require(bool)(validPurchaseTime(currentTime));require(bool)(msg.value >= priceClaim);beneficiar = msg.sender;require(bool)(beneficiar != address(0));require(bool)(! mintingFinished);amount = calcAmount(beneficiar);require(bool)(amount <= balances[owner]);balances[beneficiar] = balances[beneficiar].add(amount);balances[owner] = balances[owner].sub(amount);tokenAllocated = tokenAllocated.add(amount);owner.transfer(msg.value);Mint(beneficiar,amount);Transfer(owner,beneficiar,amount);true"
./0x0356e14c2f8de339131c668c1747def594467a9a_ext.sol,Club1VIT.transfer,139,152,"_value(uint256) := 1(uint256),REF_6(uint256) -> balances[msg.sender],TMP_31(bool) = REF_6 == 1,TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31),TMP_33(bool) = _to == owner,TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33),TMP_35(bytes32) = SOLIDITY_CALL keccak256()(resetToken()),TMP_36 = CONVERT TMP_35 to bytes4,TMP_37(bool) = LOW_LEVEL_CALL, dest:owner, function:call, arguments:['TMP_36']  ,TMP_38 = UnaryType.BANG TMP_37 ,CONDITION TMP_38,TMP_39(None) = SOLIDITY_CALL revert()(),REF_8(uint256) -> balances[msg.sender],REF_8(uint256) (->balances) := 0(uint256),REF_9(uint256) -> balances[_to],REF_9(uint256) (->balances) := 1(uint256),Emit Transfer(msg.sender,_to),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_value = 1

IRs:
_value(uint256) := 1(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[msg.sender] == 1)

IRs:
REF_6(uint256) -> balances[msg.sender]
TMP_31(bool) = REF_6 == 1
TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_to == owner)

IRs:
TMP_33(bool) = _to == owner
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
! owner.call(bytes4(keccak256()(resetToken())))

IRs:
TMP_35(bytes32) = SOLIDITY_CALL keccak256()(resetToken())
TMP_36 = CONVERT TMP_35 to bytes4
TMP_37(bool) = LOW_LEVEL_CALL, dest:owner, function:call, arguments:['TMP_36']  
TMP_38 = UnaryType.BANG TMP_37 
CONDITION TMP_38""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
revert()()

IRs:
TMP_39(None) = SOLIDITY_CALL revert()()""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[msg.sender] = 0

IRs:
REF_8(uint256) -> balances[msg.sender]
REF_8(uint256) (->balances) := 0(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[_to] = 1

IRs:
REF_9(uint256) -> balances[_to]
REF_9(uint256) (->balances) := 1(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
Transfer(msg.sender,_to)

IRs:
Emit Transfer(msg.sender,_to)""];
9->10;
10[label=""Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,"_value = 1;require(bool)(balances[msg.sender] == 1);require(bool)(_to == owner);! owner.call(bytes4(keccak256()(resetToken())));revert()();;balances[msg.sender] = 0;balances[_to] = 1;Transfer(msg.sender,_to);true"
./0xaa63c8683647ef91b3fdab4b4989ee9588da297b_ext.sol,DSProxyFactory.build,162,167,"TMP_43(DSProxy) = INTERNAL_CALL, DSProxyFactory.build(address)(msg.sender),proxy(DSProxy) := TMP_43(DSProxy),RETURN proxy","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
proxy = build(msg.sender)

IRs:
TMP_43(DSProxy) = INTERNAL_CALL, DSProxyFactory.build(address)(msg.sender)
proxy(DSProxy) := TMP_43(DSProxy)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
proxy

IRs:
RETURN proxy""];
}
",1,0,0,0,proxy = build(msg.sender);proxy
./0x861a174d677946d8c2bea8f9636a53fde1668215_ext.sol,SmartContractBank.increasePercent,350,356,"REF_86(SmartContractBank.Investor) -> investors[msg.sender],investor(SmartContractBank.Investor) := REF_86(SmartContractBank.Investor),TMP_119(uint256) = HIGH_LEVEL_CALL, dest:CBCTokenContract(CBCToken), function:balanceOf, arguments:['msg.sender']  ,TMP_120(bool) = TMP_119 >= 10000000000000000000,CONDITION TMP_120,HIGH_LEVEL_CALL, dest:MainSaleContract(MainSale), function:authorizedBurnTokens, arguments:['msg.sender', '10000000000000000000']  ,REF_89(bool) -> investor.increasedPercent,REF_89(bool) (->investor) := True(bool)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
investor = investors[msg.sender]

IRs:
REF_86(SmartContractBank.Investor) -> investors[msg.sender]
investor(SmartContractBank.Investor) := REF_86(SmartContractBank.Investor)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
CBCTokenContract.balanceOf(msg.sender) >= 10000000000000000000

IRs:
TMP_119(uint256) = HIGH_LEVEL_CALL, dest:CBCTokenContract(CBCToken), function:balanceOf, arguments:['msg.sender']  
TMP_120(bool) = TMP_119 >= 10000000000000000000
CONDITION TMP_120""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
MainSaleContract.authorizedBurnTokens(msg.sender,10000000000000000000)

IRs:
HIGH_LEVEL_CALL, dest:MainSaleContract(MainSale), function:authorizedBurnTokens, arguments:['msg.sender', '10000000000000000000']  ""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
investor.increasedPercent = true

IRs:
REF_89(bool) -> investor.increasedPercent
REF_89(bool) (->investor) := True(bool)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",1,0,0,0,"investor = investors[msg.sender];CBCTokenContract.balanceOf(msg.sender) >= 10000000000000000000;MainSaleContract.authorizedBurnTokens(msg.sender,10000000000000000000);;investor.increasedPercent = true"
./0x6fc22d1f6852af2bcea6cb749033ccb6b4d3177a_ext.sol,BitSTDView.burnFrom,534,539,"TMP_167(bool) = HIGH_LEVEL_CALL, dest:logic(BitSTDLogic), function:burnFrom, arguments:['_from', 'msg.sender', '_value']  ,TMP_168(bool) = TMP_167 == True,CONDITION TMP_168,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
logic.burnFrom(_from,msg.sender,_value) == true

IRs:
TMP_167(bool) = HIGH_LEVEL_CALL, dest:logic(BitSTDLogic), function:burnFrom, arguments:['_from', 'msg.sender', '_value']  
TMP_168(bool) = TMP_167 == True
CONDITION TMP_168""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,0,0,0,"logic.burnFrom(_from,msg.sender,_value) == true;Burn(_from,_value);;true;success"
./0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497_ext.sol,LockinManager.removeValidContract,632,642,"REF_131(uint256) -> allowedContracts[_address],TMP_170(bool) = REF_131 == 0,CONDITION TMP_170,REF_132(uint256) -> allowedContracts[_address],REF_132(uint256) (->allowedContracts) := 0(uint256),Emit ValidContractRemoved(msg.sender,_address,now),MODIFIER_CALL, LockinManager.adminOnly()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: IF 1

EXPRESSION:
allowedContracts[_address] == 0

IRs:
REF_131(uint256) -> allowedContracts[_address]
TMP_170(bool) = REF_131 == 0
CONDITION TMP_170""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowedContracts[_address] = 0

IRs:
REF_132(uint256) -> allowedContracts[_address]
REF_132(uint256) (->allowedContracts) := 0(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
ValidContractRemoved(msg.sender,_address,now)

IRs:
Emit ValidContractRemoved(msg.sender,_address,now)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
adminOnly()

IRs:
MODIFIER_CALL, LockinManager.adminOnly()()""];
6->1;
}
",1,0,0,0,"adminOnly();allowedContracts[_address] == 0;;;allowedContracts[_address] = 0;ValidContractRemoved(msg.sender,_address,now)"
./0x4c13184721de2d1b47a8875775ba3ce0b2e00ee0_ext.sol,SharkPool.mine,258,295,"TMP_58(uint256) = INTERNAL_CALL, SharkPool.current_external_block()(),TMP_59(uint256) = INTERNAL_CALL, SharkPool.external_to_internal_block_number(uint256)(TMP_58),_blockNum(uint256) := TMP_59(uint256),TMP_60(bool) = HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:checkMiningAttempt, arguments:['_blockNum', 'this']  ,TMP_61 = UnaryType.BANG TMP_60 ,TMP_62(None) = SOLIDITY_CALL require(bool)(TMP_61),total_attempt(uint256) := 0(uint256),total_ejected(uint8) := 0(uint256),i(uint8) := 0(uint256),TMP_63(bool) = i < total_users,CONDITION TMP_63,REF_36(address) -> active_users[i],user_address(address) := REF_36(address),TMP_64(bool) = user_address > 0,CONDITION TMP_64,REF_37(SharkPool.user) -> users[user_address],u(SharkPool.user) := REF_37(SharkPool.user),REF_38(uint256) -> u.end_block,TMP_65(bool) = REF_38 <= mined_blocks,CONDITION TMP_65,TMP_66(bool) = total_ejected < 10,CONDITION TMP_66,REF_39(address) -> active_users[i],active_users = delete REF_39 ,REF_41 -> LENGTH slots,TMP_68(uint256) := REF_41(uint256),TMP_69(uint256) = TMP_68 + 1,REF_41(uint256) (->slots) := TMP_69(uint256),REF_42(uint8) -> slots[TMP_68],REF_42(uint8) (->slots) := i(uint8),REF_43(address) -> active_users[i],REF_44(SharkPool.user) -> users[REF_43],users = delete REF_44 ,TMP_70(uint8) = total_ejected + 1,total_ejected(uint8) := TMP_70(uint8),REF_45(uint256) -> u.proportional_contribution,TMP_71(uint256) = total_attempt + REF_45,total_attempt(uint256) := TMP_71(uint256),TMP_72(uint8) := i(uint8),i(uint8) = i + 1,TMP_73(bool) = total_attempt > 0,CONDITION TMP_73,REF_46(uint256) -> attempts[_blockNum],REF_46(uint256) (->attempts) := total_attempt(uint256),HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:mine, arguments:[] value:total_attempt ,TMP_76(uint256) = mined_blocks + 1,mined_blocks(uint256) := TMP_76(uint256),MODIFIER_CALL, ReentrancyGuard.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->28;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_blockNum = external_to_internal_block_number(current_external_block())

IRs:
TMP_58(uint256) = INTERNAL_CALL, SharkPool.current_external_block()()
TMP_59(uint256) = INTERNAL_CALL, SharkPool.external_to_internal_block_number(uint256)(TMP_58)
_blockNum(uint256) := TMP_59(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! base_contract.checkMiningAttempt(_blockNum,this))

IRs:
TMP_60(bool) = HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:checkMiningAttempt, arguments:['_blockNum', 'this']  
TMP_61 = UnaryType.BANG TMP_60 
TMP_62(None) = SOLIDITY_CALL require(bool)(TMP_61)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
total_attempt = 0

IRs:
total_attempt(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
total_ejected = 0

IRs:
total_ejected(uint8) := 0(uint256)""];
4->7;
5[label=""Node Type: BEGIN_LOOP 5
""];
5->8;
6[label=""Node Type: END_LOOP 6
""];
6->23;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)""];
7->5;
8[label=""Node Type: IF_LOOP 8

EXPRESSION:
i < total_users

IRs:
TMP_63(bool) = i < total_users
CONDITION TMP_63""];
8->9[label=""True""];
8->6[label=""False""];
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
user_address = active_users[i]

IRs:
REF_36(address) -> active_users[i]
user_address(address) := REF_36(address)""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
user_address > 0

IRs:
TMP_64(bool) = user_address > 0
CONDITION TMP_64""];
10->11[label=""True""];
10->21[label=""False""];
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
u = users[user_address]

IRs:
REF_37(SharkPool.user) -> users[user_address]
u(SharkPool.user) := REF_37(SharkPool.user)""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
u.end_block <= mined_blocks

IRs:
REF_38(uint256) -> u.end_block
TMP_65(bool) = REF_38 <= mined_blocks
CONDITION TMP_65""];
12->13[label=""True""];
12->19[label=""False""];
13[label=""Node Type: IF 13

EXPRESSION:
total_ejected < 10

IRs:
TMP_66(bool) = total_ejected < 10
CONDITION TMP_66""];
13->14[label=""True""];
13->18[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
delete active_users[i]

IRs:
REF_39(address) -> active_users[i]
active_users = delete REF_39 ""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
slots.push(i)

IRs:
REF_41 -> LENGTH slots
TMP_68(uint256) := REF_41(uint256)
TMP_69(uint256) = TMP_68 + 1
REF_41(uint256) (->slots) := TMP_69(uint256)
REF_42(uint8) -> slots[TMP_68]
REF_42(uint8) (->slots) := i(uint8)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
delete users[active_users[i]]

IRs:
REF_43(address) -> active_users[i]
REF_44(SharkPool.user) -> users[REF_43]
users = delete REF_44 ""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
total_ejected = total_ejected + 1

IRs:
TMP_70(uint8) = total_ejected + 1
total_ejected(uint8) := TMP_70(uint8)""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->20;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
total_attempt = total_attempt + u.proportional_contribution

IRs:
REF_45(uint256) -> u.proportional_contribution
TMP_71(uint256) = total_attempt + REF_45
total_attempt(uint256) := TMP_71(uint256)""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: END_IF 21
""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
i ++

IRs:
TMP_72(uint8) := i(uint8)
i(uint8) = i + 1""];
22->8;
23[label=""Node Type: IF 23

EXPRESSION:
total_attempt > 0

IRs:
TMP_73(bool) = total_attempt > 0
CONDITION TMP_73""];
23->24[label=""True""];
23->27[label=""False""];
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
attempts[_blockNum] = total_attempt

IRs:
REF_46(uint256) -> attempts[_blockNum]
REF_46(uint256) (->attempts) := total_attempt(uint256)""];
24->25;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
base_contract.mine.value(total_attempt)()

IRs:
HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:mine, arguments:[] value:total_attempt ""];
25->26;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
mined_blocks = mined_blocks + 1

IRs:
TMP_76(uint256) = mined_blocks + 1
mined_blocks(uint256) := TMP_76(uint256)""];
26->27;
27[label=""Node Type: END_IF 27
""];
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, ReentrancyGuard.nonReentrant()()""];
28->1;
}
",1,0,0,0,"nonReentrant();_blockNum = external_to_internal_block_number(current_external_block());require(bool)(! base_contract.checkMiningAttempt(_blockNum,this));total_attempt = 0;total_ejected = 0;i = 0;;i < total_users;;total_attempt > 0;user_address = active_users[i];user_address > 0;u = users[user_address];;u.end_block <= mined_blocks;total_ejected < 10;total_attempt = total_attempt + u.proportional_contribution;delete active_users[i];;slots.push(i);delete users[active_users[i]];total_ejected = total_ejected + 1;;i ++;attempts[_blockNum] = total_attempt;;base_contract.mine.value(total_attempt)();mined_blocks = mined_blocks + 1"
./0x3a37dcda0503f92626c082540dfbc9d95104ab96_ext.sol,EthernautsLogic.setEthernautsStorageContract,987,991,"TMP_567 = CONVERT _CStorageAddress to EthernautsStorage,candidateContract(EthernautsStorage) := TMP_567(EthernautsStorage),TMP_568(bool) = HIGH_LEVEL_CALL, dest:candidateContract(EthernautsStorage), function:isEthernautsStorage, arguments:[]  ,TMP_569(None) = SOLIDITY_CALL require(bool)(TMP_568),ethernautsStorage(EthernautsStorage) := candidateContract(EthernautsStorage),MODIFIER_CALL, EthernautsAccessControl.onlyCLevel()(),MODIFIER_CALL, EthernautsAccessControl.whenPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
candidateContract = EthernautsStorage(_CStorageAddress)

IRs:
TMP_567 = CONVERT _CStorageAddress to EthernautsStorage
candidateContract(EthernautsStorage) := TMP_567(EthernautsStorage)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(candidateContract.isEthernautsStorage())

IRs:
TMP_568(bool) = HIGH_LEVEL_CALL, dest:candidateContract(EthernautsStorage), function:isEthernautsStorage, arguments:[]  
TMP_569(None) = SOLIDITY_CALL require(bool)(TMP_568)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ethernautsStorage = candidateContract

IRs:
ethernautsStorage(EthernautsStorage) := candidateContract(EthernautsStorage)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyCLevel()

IRs:
MODIFIER_CALL, EthernautsAccessControl.onlyCLevel()()""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
whenPaused()

IRs:
MODIFIER_CALL, EthernautsAccessControl.whenPaused()()""];
5->1;
}
",1,0,0,0,onlyCLevel();candidateContract = EthernautsStorage(_CStorageAddress);require(bool)(candidateContract.isEthernautsStorage());ethernautsStorage = candidateContract;whenPaused()
./0x0e752b742f744fdc2d93774da44c37b72c3e6952_ext.sol,CraftyCrowdsale.finishCrowdsale,553,562,"TMP_202(bool) = now > saleEnd,TMP_203(None) = SOLIDITY_CALL require(bool)(TMP_202),TMP_204(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['hardCap', 'issuedTokens'] ,unspentTokens(uint256) := TMP_204(uint256),TMP_205(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['fundWallet', 'unspentTokens']  ,REF_86(CraftyCrowdsale.State) -> State.CLOSED,currentState(CraftyCrowdsale.State) := REF_86(CraftyCrowdsale.State),TMP_206(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:finishMinting, arguments:[]  ,MODIFIER_CALL, Ownable.onlyOwner()(),REF_88(CraftyCrowdsale.State) -> State.SALE,MODIFIER_CALL, CraftyCrowdsale.inState(CraftyCrowdsale.State)(REF_88)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now > saleEnd)

IRs:
TMP_202(bool) = now > saleEnd
TMP_203(None) = SOLIDITY_CALL require(bool)(TMP_202)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
unspentTokens = hardCap.sub(issuedTokens)

IRs:
TMP_204(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['hardCap', 'issuedTokens'] 
unspentTokens(uint256) := TMP_204(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
token.mint(fundWallet,unspentTokens)

IRs:
TMP_205(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['fundWallet', 'unspentTokens']  ""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
currentState = State.CLOSED

IRs:
REF_86(CraftyCrowdsale.State) -> State.CLOSED
currentState(CraftyCrowdsale.State) := REF_86(CraftyCrowdsale.State)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
token.finishMinting()

IRs:
TMP_206(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:finishMinting, arguments:[]  ""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
inState(State.SALE)

IRs:
REF_88(CraftyCrowdsale.State) -> State.SALE
MODIFIER_CALL, CraftyCrowdsale.inState(CraftyCrowdsale.State)(REF_88)""];
7->1;
}
",1,0,0,0,"onlyOwner();require(bool)(now > saleEnd);unspentTokens = hardCap.sub(issuedTokens);token.mint(fundWallet,unspentTokens);currentState = State.CLOSED;token.finishMinting();inState(State.SALE)"
./0x58b334f15d7c7e08287b4ae57d11f35e0c2ad497_ext.sol,Token.destroyTokens,455,474,"TMP_123(bool) = refundManagerContractAddress == 0,TMP_124(bool) = msg.sender != refundManagerContractAddress,TMP_125(bool) = TMP_123 || TMP_124,CONDITION TMP_125,TMP_126(uint256) = INTERNAL_CALL, Token.availableBalance(address)(_investor),balance(uint256) := TMP_126(uint256),TMP_127(bool) = balance < tokenCount,CONDITION TMP_127,RETURN False,REF_93(uint256) -> balances[_investor],REF_93(-> balances) = REF_93 - tokenCount,totalSupplyAmount(uint256) = totalSupplyAmount - tokenCount,REF_94(uint256) -> balances[_investor],TMP_128(bool) = REF_94 <= 0,CONDITION TMP_128,INTERNAL_CALL, Token.tokenOwnerRemove(address)(_investor),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
refundManagerContractAddress == 0x0 || msg.sender != refundManagerContractAddress

IRs:
TMP_123(bool) = refundManagerContractAddress == 0
TMP_124(bool) = msg.sender != refundManagerContractAddress
TMP_125(bool) = TMP_123 || TMP_124
CONDITION TMP_125""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
balance = availableBalance(_investor)

IRs:
TMP_126(uint256) = INTERNAL_CALL, Token.availableBalance(address)(_investor)
balance(uint256) := TMP_126(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
balance < tokenCount

IRs:
TMP_127(bool) = balance < tokenCount
CONDITION TMP_127""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False""];
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[_investor] -= tokenCount

IRs:
REF_93(uint256) -> balances[_investor]
REF_93(-> balances) = REF_93 - tokenCount""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
totalSupplyAmount -= tokenCount

IRs:
totalSupplyAmount(uint256) = totalSupplyAmount - tokenCount""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
balances[_investor] <= 0

IRs:
REF_94(uint256) -> balances[_investor]
TMP_128(bool) = REF_94 <= 0
CONDITION TMP_128""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
tokenOwnerRemove(_investor)

IRs:
INTERNAL_CALL, Token.tokenOwnerRemove(address)(_investor)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: RETURN 13

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,refundManagerContractAddress == 0x0 || msg.sender != refundManagerContractAddress;;;balance = availableBalance(_investor);balance < tokenCount;false;;balances[_investor] -= tokenCount;totalSupplyAmount -= tokenCount;balances[_investor] <= 0;tokenOwnerRemove(_investor);;true
./0x5af9ec6df6edea0761fa841ce56c2e4deb000b31_ext.sol,ZebiMainCrowdsale.buyTokens,981,1020,"transStartTime(uint256) := now(uint256),REF_268(bool) -> goldList[beneficiary],REF_269(bool) -> kycAcceptedList[beneficiary],TMP_450(bool) = REF_268 || REF_269,TMP_451(None) = SOLIDITY_CALL require(bool)(TMP_450),goldListPeriodFlag(bool) := False(bool),TMP_452 = CONVERT 0 to address,TMP_453(bool) = beneficiary != TMP_452,TMP_454(None) = SOLIDITY_CALL require(bool)(TMP_453),TMP_455(bool) = INTERNAL_CALL, ZebiMainCrowdsale.validPurchase()(),TMP_456(None) = SOLIDITY_CALL require(bool)(TMP_455),extraEth(uint256) := 0(uint256),weiAmount(uint256) := msg.value(uint256),TMP_457(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['ethCap', 'mainWeiRaised'] ,TMP_458(bool) = msg.value > TMP_457,TMP_459 = UnaryType.BANG goldListPeriodFlag ,TMP_460(bool) = TMP_458 && TMP_459,CONDITION TMP_460,TMP_461(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['ethCap', 'mainWeiRaised'] ,weiAmount(uint256) := TMP_461(uint256),TMP_462(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.value', 'weiAmount'] ,extraEth(uint256) := TMP_462(uint256),TMP_463(uint256) = INTERNAL_CALL, ZebiMainCrowdsale.getTokenAmount(uint256)(weiAmount),tokens(uint256) := TMP_463(uint256),TMP_464(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['mainWeiRaised', 'weiAmount'] ,mainWeiRaised(uint256) := TMP_464(uint256),TMP_465(bool) = HIGH_LEVEL_CALL, dest:token(ZebiCoin), function:mint, arguments:['beneficiary', 'tokens']  ,REF_275(uint256) -> mainContribution[beneficiary],REF_276(uint256) -> mainContribution[beneficiary],TMP_466(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_276', 'weiAmount'] ,REF_275(uint256) (->mainContribution) := TMP_466(uint256),CONDITION goldListPeriodFlag,REF_278(uint256) -> goldListContribution[beneficiary],REF_279(uint256) -> goldListContribution[beneficiary],TMP_467(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_279', 'weiAmount'] ,REF_278(uint256) (->goldListContribution) := TMP_467(uint256),Emit TokenPurchase(beneficiary,weiAmount,tokens),INTERNAL_CALL, ZebiMainCrowdsale.forwardFunds()(),TMP_470(bool) = extraEth > 0,CONDITION TMP_470,Transfer dest:beneficiary value:extraEth","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
transStartTime = now

IRs:
transStartTime(uint256) := now(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(goldList[beneficiary] || kycAcceptedList[beneficiary])

IRs:
REF_268(bool) -> goldList[beneficiary]
REF_269(bool) -> kycAcceptedList[beneficiary]
TMP_450(bool) = REF_268 || REF_269
TMP_451(None) = SOLIDITY_CALL require(bool)(TMP_450)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
goldListPeriodFlag = false

IRs:
goldListPeriodFlag(bool) := False(bool)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(beneficiary != address(0))

IRs:
TMP_452 = CONVERT 0 to address
TMP_453(bool) = beneficiary != TMP_452
TMP_454(None) = SOLIDITY_CALL require(bool)(TMP_453)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(validPurchase())

IRs:
TMP_455(bool) = INTERNAL_CALL, ZebiMainCrowdsale.validPurchase()()
TMP_456(None) = SOLIDITY_CALL require(bool)(TMP_455)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
extraEth = 0

IRs:
extraEth(uint256) := 0(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
(msg.value > ethCap.sub(mainWeiRaised)) && ! goldListPeriodFlag

IRs:
TMP_457(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['ethCap', 'mainWeiRaised'] 
TMP_458(bool) = msg.value > TMP_457
TMP_459 = UnaryType.BANG goldListPeriodFlag 
TMP_460(bool) = TMP_458 && TMP_459
CONDITION TMP_460""];
8->9[label=""True""];
8->11[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
weiAmount = ethCap.sub(mainWeiRaised)

IRs:
TMP_461(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['ethCap', 'mainWeiRaised'] 
weiAmount(uint256) := TMP_461(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
extraEth = (msg.value).sub(weiAmount)

IRs:
TMP_462(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.value', 'weiAmount'] 
extraEth(uint256) := TMP_462(uint256)""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
tokens = getTokenAmount(weiAmount)

IRs:
TMP_463(uint256) = INTERNAL_CALL, ZebiMainCrowdsale.getTokenAmount(uint256)(weiAmount)
tokens(uint256) := TMP_463(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
mainWeiRaised = mainWeiRaised.add(weiAmount)

IRs:
TMP_464(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['mainWeiRaised', 'weiAmount'] 
mainWeiRaised(uint256) := TMP_464(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
token.mint(beneficiary,tokens)

IRs:
TMP_465(bool) = HIGH_LEVEL_CALL, dest:token(ZebiCoin), function:mint, arguments:['beneficiary', 'tokens']  ""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
mainContribution[beneficiary] = mainContribution[beneficiary].add(weiAmount)

IRs:
REF_275(uint256) -> mainContribution[beneficiary]
REF_276(uint256) -> mainContribution[beneficiary]
TMP_466(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_276', 'weiAmount'] 
REF_275(uint256) (->mainContribution) := TMP_466(uint256)""];
15->16;
16[label=""Node Type: IF 16

EXPRESSION:
goldListPeriodFlag

IRs:
CONDITION goldListPeriodFlag""];
16->17[label=""True""];
16->18[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
goldListContribution[beneficiary] = goldListContribution[beneficiary].add(weiAmount)

IRs:
REF_278(uint256) -> goldListContribution[beneficiary]
REF_279(uint256) -> goldListContribution[beneficiary]
TMP_467(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_279', 'weiAmount'] 
REF_278(uint256) (->goldListContribution) := TMP_467(uint256)""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
TokenPurchase(beneficiary,weiAmount,tokens)

IRs:
Emit TokenPurchase(beneficiary,weiAmount,tokens)""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
forwardFunds()

IRs:
INTERNAL_CALL, ZebiMainCrowdsale.forwardFunds()()""];
20->21;
21[label=""Node Type: IF 21

EXPRESSION:
extraEth > 0

IRs:
TMP_470(bool) = extraEth > 0
CONDITION TMP_470""];
21->22[label=""True""];
21->23[label=""False""];
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
beneficiary.transfer(extraEth)

IRs:
Transfer dest:beneficiary value:extraEth""];
22->23;
23[label=""Node Type: END_IF 23
""];
}
",1,0,0,0,"transStartTime = now;require(bool)(goldList[beneficiary] || kycAcceptedList[beneficiary]);goldListPeriodFlag = false;require(bool)(beneficiary != address(0));require(bool)(validPurchase());extraEth = 0;weiAmount = msg.value;(msg.value > ethCap.sub(mainWeiRaised)) && ! goldListPeriodFlag;weiAmount = ethCap.sub(mainWeiRaised);;extraEth = (msg.value).sub(weiAmount);tokens = getTokenAmount(weiAmount);mainWeiRaised = mainWeiRaised.add(weiAmount);token.mint(beneficiary,tokens);mainContribution[beneficiary] = mainContribution[beneficiary].add(weiAmount);goldListPeriodFlag;goldListContribution[beneficiary] = goldListContribution[beneficiary].add(weiAmount);;TokenPurchase(beneficiary,weiAmount,tokens);forwardFunds();extraEth > 0;beneficiary.transfer(extraEth);"
./0xdda80deeb2db6d63247b9be73bacd00184fbc83f_ext.sol,OwnerContract.changeOwnershipto,281,285,"HIGH_LEVEL_CALL, dest:ownedContract(Claimable), function:transferOwnership, arguments:['_nextOwner']  ,TMP_122 = CONVERT 0 to address,TMP_123 = CONVERT TMP_122 to Claimable,ownedContract(Claimable) := TMP_123(Claimable),TMP_124 = CONVERT 0 to address,origOwner(address) := TMP_124(address),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownedContract.transferOwnership(_nextOwner)

IRs:
HIGH_LEVEL_CALL, dest:ownedContract(Claimable), function:transferOwnership, arguments:['_nextOwner']  ""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ownedContract = Claimable(address(0))

IRs:
TMP_122 = CONVERT 0 to address
TMP_123 = CONVERT TMP_122 to Claimable
ownedContract(Claimable) := TMP_123(Claimable)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
origOwner = address(0)

IRs:
TMP_124 = CONVERT 0 to address
origOwner(address) := TMP_124(address)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->1;
}
",1,0,0,0,onlyOwner();ownedContract.transferOwnership(_nextOwner);ownedContract = Claimable(address(0));origOwner = address(0)
./0xec2e5c8d51fdd54fef83db8300399a3c2e167922_ext.sol,CrowdsaleToken.allocate,188,203,"TMP_74 = CONVERT 0 to address,TMP_75(bool) = _sale != TMP_74,TMP_76(None) = SOLIDITY_CALL require(bool)(TMP_75),TMP_77 = CONVERT _sale to Crowdsale,sale(Crowdsale) := TMP_77(Crowdsale),TMP_78(address) = HIGH_LEVEL_CALL, dest:sale(Crowdsale), function:pool, arguments:[]  ,pool(address) := TMP_78(address),TMP_79 = CONVERT 0 to address,TMP_80(bool) = _investor != TMP_79,TMP_81(None) = SOLIDITY_CALL require(bool)(TMP_80),REF_25(uint256) -> balances[pool],TMP_82(bool) = _value <= REF_25,TMP_83(None) = SOLIDITY_CALL require(bool)(TMP_82),REF_26(mapping(address => uint256)) -> allowed[pool],REF_27(uint256) -> REF_26[msg.sender],TMP_84(bool) = _value <= REF_27,TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84),REF_28(uint256) -> balances[pool],REF_29(uint256) -> balances[pool],TMP_86(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_29', '_value'] ,REF_28(uint256) (->balances) := TMP_86(uint256),REF_31(uint256) -> balances[_investor],REF_32(uint256) -> balances[_investor],TMP_87(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_32', '_value'] ,REF_31(uint256) (->balances) := TMP_87(uint256),REF_34(mapping(address => uint256)) -> allowed[pool],REF_35(uint256) -> REF_34[_sale],REF_36(mapping(address => uint256)) -> allowed[pool],REF_37(uint256) -> REF_36[_sale],TMP_88(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_37', '_value'] ,REF_35(uint256) (->allowed) := TMP_88(uint256),Emit Transfer(pool,_investor,_value),MODIFIER_CALL, Manageable.onlyOwnerOrManager()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_sale != address(0))

IRs:
TMP_74 = CONVERT 0 to address
TMP_75(bool) = _sale != TMP_74
TMP_76(None) = SOLIDITY_CALL require(bool)(TMP_75)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
sale = Crowdsale(_sale)

IRs:
TMP_77 = CONVERT _sale to Crowdsale
sale(Crowdsale) := TMP_77(Crowdsale)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
pool = sale.pool()

IRs:
TMP_78(address) = HIGH_LEVEL_CALL, dest:sale(Crowdsale), function:pool, arguments:[]  
pool(address) := TMP_78(address)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_investor != address(0))

IRs:
TMP_79 = CONVERT 0 to address
TMP_80(bool) = _investor != TMP_79
TMP_81(None) = SOLIDITY_CALL require(bool)(TMP_80)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(_value <= balances[pool])

IRs:
REF_25(uint256) -> balances[pool]
TMP_82(bool) = _value <= REF_25
TMP_83(None) = SOLIDITY_CALL require(bool)(TMP_82)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(_value <= allowed[pool][msg.sender])

IRs:
REF_26(mapping(address => uint256)) -> allowed[pool]
REF_27(uint256) -> REF_26[msg.sender]
TMP_84(bool) = _value <= REF_27
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[pool] = balances[pool].sub(_value)

IRs:
REF_28(uint256) -> balances[pool]
REF_29(uint256) -> balances[pool]
TMP_86(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_29', '_value'] 
REF_28(uint256) (->balances) := TMP_86(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[_investor] = balances[_investor].add(_value)

IRs:
REF_31(uint256) -> balances[_investor]
REF_32(uint256) -> balances[_investor]
TMP_87(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_32', '_value'] 
REF_31(uint256) (->balances) := TMP_87(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
allowed[pool][_sale] = allowed[pool][_sale].sub(_value)

IRs:
REF_34(mapping(address => uint256)) -> allowed[pool]
REF_35(uint256) -> REF_34[_sale]
REF_36(mapping(address => uint256)) -> allowed[pool]
REF_37(uint256) -> REF_36[_sale]
TMP_88(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_37', '_value'] 
REF_35(uint256) (->allowed) := TMP_88(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Transfer(pool,_investor,_value)

IRs:
Emit Transfer(pool,_investor,_value)""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
onlyOwnerOrManager()

IRs:
MODIFIER_CALL, Manageable.onlyOwnerOrManager()()""];
11->1;
}
",1,0,0,0,"onlyOwnerOrManager();require(bool)(_sale != address(0));sale = Crowdsale(_sale);pool = sale.pool();require(bool)(_investor != address(0));require(bool)(_value <= balances[pool]);require(bool)(_value <= allowed[pool][msg.sender]);balances[pool] = balances[pool].sub(_value);balances[_investor] = balances[_investor].add(_value);allowed[pool][_sale] = allowed[pool][_sale].sub(_value);Transfer(pool,_investor,_value)"
./0x2737e022e8bf733b05fa0706b0e80003a576ccb4_ext.sol,TokenValueRelayer.tokenValuePublish,229,235,"REF_35 -> LENGTH values,TMP_41(uint256) := REF_35(uint256),REF_35(-> values) = REF_35 + 1,REF_36 -> LENGTH values,TMP_42(uint256) = REF_36 - 1,REF_37(TokenValueRelayer.TokenValueRepresentation) -> values[TMP_42],TMP_43(TokenValueRelayer.TokenValueRepresentation) = new TokenValueRepresentation(_value,_currency,_timestamp),REF_37(TokenValueRelayer.TokenValueRepresentation) (->values) := TMP_43(TokenValueRelayer.TokenValueRepresentation),Emit TokenValue(_value,_currency,_timestamp),MODIFIER_CALL, TokenValueRelayer.adminOnly()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
values.length ++

IRs:
REF_35 -> LENGTH values
TMP_41(uint256) := REF_35(uint256)
REF_35(-> values) = REF_35 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
values[values.length - 1] = TokenValueRepresentation(_value,_currency,_timestamp)

IRs:
REF_36 -> LENGTH values
TMP_42(uint256) = REF_36 - 1
REF_37(TokenValueRelayer.TokenValueRepresentation) -> values[TMP_42]
TMP_43(TokenValueRelayer.TokenValueRepresentation) = new TokenValueRepresentation(_value,_currency,_timestamp)
REF_37(TokenValueRelayer.TokenValueRepresentation) (->values) := TMP_43(TokenValueRelayer.TokenValueRepresentation)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
TokenValue(_value,_currency,_timestamp)

IRs:
Emit TokenValue(_value,_currency,_timestamp)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
adminOnly()

IRs:
MODIFIER_CALL, TokenValueRelayer.adminOnly()()""];
4->1;
}
",1,0,0,0,"adminOnly();values.length ++;values[values.length - 1] = TokenValueRepresentation(_value,_currency,_timestamp);TokenValue(_value,_currency,_timestamp)"
./0x3325e30f4326f17bdd79146db0a3835175f0e982_ext.sol,SAMIToken.refundTokens,355,361,"TMP_111(bool) = msg.sender == owner,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113 = CONVERT this to address,TMP_114(bool) = _token != TMP_113,TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114),TMP_116 = CONVERT _token to AbstractToken,token(AbstractToken) := TMP_116(AbstractToken),TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ,Emit RefundTokens(_token,_refund,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_111(bool) = msg.sender == owner
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_113 = CONVERT this to address
TMP_114(bool) = _token != TMP_113
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
token = AbstractToken(_token)

IRs:
TMP_116 = CONVERT _token to AbstractToken
token(AbstractToken) := TMP_116(AbstractToken)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(_refund,_value)

IRs:
TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RefundTokens(_token,_refund,_value)

IRs:
Emit RefundTokens(_token,_refund,_value)""];
}
",1,0,0,0,"require(bool)(msg.sender == owner);require(bool)(_token != address(this));token = AbstractToken(_token);token.transfer(_refund,_value);RefundTokens(_token,_refund,_value)"
./0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0_ext.sol,Play0x_LottoBall.sendTokenFundsToManager,864,867,"TMP_461 = CONVERT ERC20ContractAddres to ERC20,HIGH_LEVEL_CALL, dest:TMP_461(ERC20), function:transfer, arguments:['manager', 'amount']  ,Emit TokenPayment(manager,amount),MODIFIER_CALL, Play0x_LottoBall.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ERC20(ERC20ContractAddres).transfer(manager,amount)

IRs:
TMP_461 = CONVERT ERC20ContractAddres to ERC20
HIGH_LEVEL_CALL, dest:TMP_461(ERC20), function:transfer, arguments:['manager', 'amount']  ""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
TokenPayment(manager,amount)

IRs:
Emit TokenPayment(manager,amount)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Play0x_LottoBall.onlyOwner()()""];
3->1;
}
",1,0,0,0,"onlyOwner();ERC20(ERC20ContractAddres).transfer(manager,amount);TokenPayment(manager,amount)"
./0x88355a32a8c5cc399aa09b9d21ebcba935ae5d2f_ext.sol,BankWallet.deposit,190,194,"TMP_109 = CONVERT edgelessCasino to Casino,__casino(Casino) := TMP_109(Casino),HIGH_LEVEL_CALL, dest:__casino(Casino), function:deposit, arguments:['_address', '_amount', '_chargeGas']  ,Emit Deposit(_address,_amount),MODIFIER_CALL, RequiringAuthorization.onlyAuthorized()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
__casino = Casino(edgelessCasino)

IRs:
TMP_109 = CONVERT edgelessCasino to Casino
__casino(Casino) := TMP_109(Casino)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
__casino.deposit(_address,_amount,_chargeGas)

IRs:
HIGH_LEVEL_CALL, dest:__casino(Casino), function:deposit, arguments:['_address', '_amount', '_chargeGas']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Deposit(_address,_amount)

IRs:
Emit Deposit(_address,_amount)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyAuthorized()

IRs:
MODIFIER_CALL, RequiringAuthorization.onlyAuthorized()()""];
4->1;
}
",1,0,0,0,"onlyAuthorized();__casino = Casino(edgelessCasino);__casino.deposit(_address,_amount,_chargeGas);Deposit(_address,_amount)"
./0xb620cee6b52f96f3c6b253e6eea556aa2d214a99_ext.sol,DrainMe.winPrize,123,125,"TMP_44(bool) = LOW_LEVEL_CALL, dest:owner, function:call, arguments:[] value:1 ,MODIFIER_CALL, DrainMe.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.call.value(1)()

IRs:
TMP_44(bool) = LOW_LEVEL_CALL, dest:owner, function:call, arguments:[] value:1 ""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, DrainMe.onlyOwner()()""];
2->1;
}
",1,0,0,0,onlyOwner();owner.call.value(1)()
./0x4c7f666ca30fe548fbdc08b0308927327f08336d_ext.sol,EthicHubTokenDistributionStrategy.returnUnsoldTokens,652,666,"MODIFIER_CALL, TokenDistributionStrategy.onlyCrowdsale()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
onlyCrowdsale()

IRs:
MODIFIER_CALL, TokenDistributionStrategy.onlyCrowdsale()()""];
}
",1,0,0,0,onlyCrowdsale()
./0x470142a1834438515b757118f322703aba6e1e05_ext.sol,PolicyPalNetworkAirdrop.signatureDropMultipleAmount,251,272,"i(uint256) := 0(uint256),REF_37 -> LENGTH _recipients,TMP_52(bool) = i < REF_37,CONDITION TMP_52,REF_38(address) -> _recipients[i],recipient(address) := REF_38(address),REF_39(uint256) -> _amounts[i],amount(uint256) := REF_39(uint256),REF_40(bool) -> signaturedrops[recipient],TMP_53 = UnaryType.BANG REF_40 ,CONDITION TMP_53,TMP_54(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', 'amount']  ,TMP_55(None) = SOLIDITY_CALL assert(bool)(TMP_54),REF_42(bool) -> signaturedrops[recipient],REF_42(bool) (->signaturedrops) := True(bool),TMP_56(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] ,numDrops(uint256) := TMP_56(uint256),TMP_57(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', 'amount'] ,dropAmount(uint256) := TMP_57(uint256),Emit TokenDrop(recipient,amount,SIGNATURE),TMP_59(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()(),MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalanceMultiple(address[],uint256[])(_recipients,_amounts)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->15;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _recipients.length

IRs:
REF_37 -> LENGTH _recipients
TMP_52(bool) = i < REF_37
CONDITION TMP_52""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
recipient = _recipients[i]

IRs:
REF_38(address) -> _recipients[i]
recipient(address) := REF_38(address)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
amount = _amounts[i]

IRs:
REF_39(uint256) -> _amounts[i]
amount(uint256) := REF_39(uint256)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
! signaturedrops[recipient]

IRs:
REF_40(bool) -> signaturedrops[recipient]
TMP_53 = UnaryType.BANG REF_40 
CONDITION TMP_53""];
7->8[label=""True""];
7->13[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(token.transfer(recipient,amount))

IRs:
TMP_54(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', 'amount']  
TMP_55(None) = SOLIDITY_CALL assert(bool)(TMP_54)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
signaturedrops[recipient] = true

IRs:
REF_42(bool) -> signaturedrops[recipient]
REF_42(bool) (->signaturedrops) := True(bool)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
numDrops = numDrops.add(1)

IRs:
TMP_56(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] 
numDrops(uint256) := TMP_56(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
dropAmount = dropAmount.add(amount)

IRs:
TMP_57(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', 'amount'] 
dropAmount(uint256) := TMP_57(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
TokenDrop(recipient,amount,SIGNATURE)

IRs:
Emit TokenDrop(recipient,amount,SIGNATURE)""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
i ++

IRs:
TMP_59(uint256) := i(uint256)
i(uint256) = i + 1""];
14->4;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()()""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
validBalanceMultiple(_recipients,_amounts)

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalanceMultiple(address[],uint256[])(_recipients,_amounts)""];
16->3;
}
",1,0,0,0,"onlyAdmin();;i < _recipients.length;;i = 0;recipient = _recipients[i];amount = _amounts[i];! signaturedrops[recipient];assert(bool)(token.transfer(recipient,amount));;signaturedrops[recipient] = true;numDrops = numDrops.add(1);dropAmount = dropAmount.add(amount);TokenDrop(recipient,amount,SIGNATURE);i ++;validBalanceMultiple(_recipients,_amounts)"
./0x6fbc1b8f756f43cfbfd45085380cc375650ff3d6_ext.sol,ZethrSnap.walletCreateSnap,166,183,"REF_3 -> LENGTH snaps,index(uint256) := REF_3(uint256),REF_4 -> LENGTH snaps,TMP_25(uint256) := REF_4(uint256),REF_4(-> snaps) = REF_4 + 1,REF_5(ZethrSnap.SnapEntry) -> snaps[index],REF_6(uint256) -> REF_5.blockNumber,REF_6(uint256) (->snaps) := _blockNumber(uint256),REF_7(ZethrSnap.SnapEntry) -> snaps[index],REF_8(uint256) -> REF_7.profit,REF_8(uint256) (->snaps) := _profitToShare(uint256),TMP_26(uint256) = HIGH_LEVEL_CALL, dest:zethr(ZethrInterface), function:myFrontEndTokens, arguments:[]  ,balance(uint256) := TMP_26(uint256),TMP_27(uint256) = balance - allocatedTokens,balance(uint256) := TMP_27(uint256),TMP_28(bool) = balance >= _profitToShare,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),TMP_30(uint256) = allocatedTokens + _profitToShare,allocatedTokens(uint256) := TMP_30(uint256),MODIFIER_CALL, ZethrSnap.walletOnly()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
index = snaps.length

IRs:
REF_3 -> LENGTH snaps
index(uint256) := REF_3(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
snaps.length ++

IRs:
REF_4 -> LENGTH snaps
TMP_25(uint256) := REF_4(uint256)
REF_4(-> snaps) = REF_4 + 1""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
snaps[index].blockNumber = _blockNumber

IRs:
REF_5(ZethrSnap.SnapEntry) -> snaps[index]
REF_6(uint256) -> REF_5.blockNumber
REF_6(uint256) (->snaps) := _blockNumber(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
snaps[index].profit = _profitToShare

IRs:
REF_7(ZethrSnap.SnapEntry) -> snaps[index]
REF_8(uint256) -> REF_7.profit
REF_8(uint256) (->snaps) := _profitToShare(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
balance = zethr.myFrontEndTokens()

IRs:
TMP_26(uint256) = HIGH_LEVEL_CALL, dest:zethr(ZethrInterface), function:myFrontEndTokens, arguments:[]  
balance(uint256) := TMP_26(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balance = balance - allocatedTokens

IRs:
TMP_27(uint256) = balance - allocatedTokens
balance(uint256) := TMP_27(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(balance >= _profitToShare)

IRs:
TMP_28(bool) = balance >= _profitToShare
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
allocatedTokens = allocatedTokens + _profitToShare

IRs:
TMP_30(uint256) = allocatedTokens + _profitToShare
allocatedTokens(uint256) := TMP_30(uint256)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
walletOnly()

IRs:
MODIFIER_CALL, ZethrSnap.walletOnly()()""];
9->1;
}
",1,0,0,0,walletOnly();index = snaps.length;snaps.length ++;snaps[index].blockNumber = _blockNumber;snaps[index].profit = _profitToShare;balance = zethr.myFrontEndTokens();balance = balance - allocatedTokens;require(bool)(balance >= _profitToShare);allocatedTokens = allocatedTokens + _profitToShare
./0x402fa04ccd2c2568e1a53dbecec1bd572303663a_ext.sol,HarborPresale.finalize,468,475,"TMP_209 = UnaryType.BANG isFinalized ,TMP_210(None) = SOLIDITY_CALL require(bool)(TMP_209),TMP_211(bool) = INTERNAL_CALL, HarborPresale.hasEnded()(),TMP_212(None) = SOLIDITY_CALL require(bool)(TMP_211),INTERNAL_CALL, HarborPresale.finalization()(),Emit Finalized(),isFinalized(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, Haltable.stopInEmergency()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isFinalized)

IRs:
TMP_209 = UnaryType.BANG isFinalized 
TMP_210(None) = SOLIDITY_CALL require(bool)(TMP_209)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(hasEnded())

IRs:
TMP_211(bool) = INTERNAL_CALL, HarborPresale.hasEnded()()
TMP_212(None) = SOLIDITY_CALL require(bool)(TMP_211)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
finalization()

IRs:
INTERNAL_CALL, HarborPresale.finalization()()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Finalized()

IRs:
Emit Finalized()""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
isFinalized = true

IRs:
isFinalized(bool) := True(bool)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
stopInEmergency()

IRs:
MODIFIER_CALL, Haltable.stopInEmergency()()""];
7->1;
}
",1,0,0,0,onlyOwner();require(bool)(! isFinalized);require(bool)(hasEnded());finalization();Finalized();isFinalized = true;stopInEmergency()
./0x56853ab9006e0712b05c68b586372fcdde5236b9_ext.sol,AirDrop.sendTokensSingleValue,61,68,"i(uint256) := 0(uint256),TMP_20(uint256) = 10 ** 18,TMP_21(uint256) = value * TMP_20,toSend(uint256) := TMP_21(uint256),REF_4 -> LENGTH dests,TMP_22(bool) = i < REF_4,CONDITION TMP_22,REF_5(address) -> dests[i],INTERNAL_CALL, AirDrop.sendInternally(address,uint256,uint256)(REF_5,toSend,value),TMP_24(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, AirDrop.whenDropIsActive()(),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
toSend = value * 10 ** 18

IRs:
TMP_20(uint256) = 10 ** 18
TMP_21(uint256) = value * TMP_20
toSend(uint256) := TMP_21(uint256)""];
2->3;
3[label=""Node Type: BEGIN_LOOP 3
""];
3->4;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < dests.length

IRs:
REF_4 -> LENGTH dests
TMP_22(bool) = i < REF_4
CONDITION TMP_22""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
sendInternally(dests[i],toSend,value)

IRs:
REF_5(address) -> dests[i]
INTERNAL_CALL, AirDrop.sendInternally(address,uint256,uint256)(REF_5,toSend,value)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_24(uint256) := i(uint256)
i(uint256) = i + 1""];
6->4;
7[label=""Node Type: END_LOOP 7
""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
whenDropIsActive()

IRs:
MODIFIER_CALL, AirDrop.whenDropIsActive()()""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
9->1;
}
",1,0,0,0,"whenDropIsActive();i = 0;toSend = value * 10 ** 18;;i < dests.length;sendInternally(dests[i],toSend,value);;i ++;onlyOwner()"
./0x7868fc162988289062dbcdb670a3cf6c8da66f84_ext.sol,CDMarketplace.changeAndBuy,274,284,"TMP_57 = CONVERT TVCrowdsaleAddress to TVCrowdsale,TMP_58(uint256) = HIGH_LEVEL_CALL, dest:TMP_57(TVCrowdsale), function:currentRate, arguments:[]  ,rate(uint256) := TMP_58(uint256),REF_15(uint256) -> priceList[_id],TMP_59(uint256) = REF_15 / rate,priceWei(uint256) := TMP_59(uint256),TMP_60(bool) = priceWei == msg.value,TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60),TMP_62 = CONVERT TVCrowdsaleAddress to TVCrowdsale,HIGH_LEVEL_CALL, dest:TMP_62(TVCrowdsale), function:buyTokens, arguments:['this'] value:msg.value ,TMP_65(bytes) = INTERNAL_CALL, CDMarketplace.toBytes(uint256)(_id),data(bytes) := TMP_65(bytes),checkAndBuySender(address) := msg.sender(address),TMP_66 = CONVERT TVTokenAddress to TVToken,REF_19(uint256) -> priceList[_id],HIGH_LEVEL_CALL, dest:TMP_66(TVToken), function:safeTransfer, arguments:['this', 'REF_19', 'data']  ,RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
rate = TVCrowdsale(TVCrowdsaleAddress).currentRate()

IRs:
TMP_57 = CONVERT TVCrowdsaleAddress to TVCrowdsale
TMP_58(uint256) = HIGH_LEVEL_CALL, dest:TMP_57(TVCrowdsale), function:currentRate, arguments:[]  
rate(uint256) := TMP_58(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
priceWei = priceList[_id] / rate

IRs:
REF_15(uint256) -> priceList[_id]
TMP_59(uint256) = REF_15 / rate
priceWei(uint256) := TMP_59(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(priceWei == msg.value)

IRs:
TMP_60(bool) = priceWei == msg.value
TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
TVCrowdsale(TVCrowdsaleAddress).buyTokens.value(msg.value)(this)

IRs:
TMP_62 = CONVERT TVCrowdsaleAddress to TVCrowdsale
HIGH_LEVEL_CALL, dest:TMP_62(TVCrowdsale), function:buyTokens, arguments:['this'] value:msg.value ""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
data = toBytes(_id)

IRs:
TMP_65(bytes) = INTERNAL_CALL, CDMarketplace.toBytes(uint256)(_id)
data(bytes) := TMP_65(bytes)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
checkAndBuySender = msg.sender

IRs:
checkAndBuySender(address) := msg.sender(address)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
TVToken(TVTokenAddress).safeTransfer(this,priceList[_id],data)

IRs:
TMP_66 = CONVERT TVTokenAddress to TVToken
REF_19(uint256) -> priceList[_id]
HIGH_LEVEL_CALL, dest:TMP_66(TVToken), function:safeTransfer, arguments:['this', 'REF_19', 'data']  ""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,"rate = TVCrowdsale(TVCrowdsaleAddress).currentRate();priceWei = priceList[_id] / rate;require(bool)(priceWei == msg.value);TVCrowdsale(TVCrowdsaleAddress).buyTokens.value(msg.value)(this);data = toBytes(_id);checkAndBuySender = msg.sender;TVToken(TVTokenAddress).safeTransfer(this,priceList[_id],data);true"
./0x85b794252e7f1b2b24392a5267ff2086c0c3d7d1_ext.sol,CashPokerProPreICO.transfer,216,224,"TMP_75(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['tokensLimit', 'tokensSold'] ,tokenAmountEnable(uint256) := TMP_75(uint256),TMP_76(bool) = amount > tokenAmountEnable,CONDITION TMP_76,amount(uint256) := tokenAmountEnable(uint256),TMP_77(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transferFrom, arguments:['tokenWallet', 'to', 'amount']  ,TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77),TMP_79(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokensSold', 'amount'] ,tokensSold(uint256) := TMP_79(uint256),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokenAmountEnable = tokensLimit.sub(tokensSold)

IRs:
TMP_75(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['tokensLimit', 'tokensSold'] 
tokenAmountEnable(uint256) := TMP_75(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
amount > tokenAmountEnable

IRs:
TMP_76(bool) = amount > tokenAmountEnable
CONDITION TMP_76""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
amount = tokenAmountEnable

IRs:
amount(uint256) := tokenAmountEnable(uint256)""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(token.transferFrom(tokenWallet,to,amount))

IRs:
TMP_77(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transferFrom, arguments:['tokenWallet', 'to', 'amount']  
TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tokensSold = tokensSold.add(amount)

IRs:
TMP_79(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokensSold', 'amount'] 
tokensSold(uint256) := TMP_79(uint256)""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->1;
}
",1,0,0,0,"onlyOwner();tokenAmountEnable = tokensLimit.sub(tokensSold);amount > tokenAmountEnable;amount = tokenAmountEnable;;require(bool)(token.transferFrom(tokenWallet,to,amount));tokensSold = tokensSold.add(amount)"
./0x514bc174df04a4b04ae2be81ee8c788c3796b06b_ext.sol,Deco.transfer,102,106,"TMP_14(bool) = INTERNAL_CALL, Deco.performTransfer(address,address,uint256,bytes)(msg.sender,_to,_value,),Emit Transfer(msg.sender,_to,_value),RETURN True,TMP_16(uint256) = 2 * 32,MODIFIER_CALL, Deco.onlyPayloadSize(uint256)(TMP_16)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
performTransfer(msg.sender,_to,_value,)

IRs:
TMP_14(bool) = INTERNAL_CALL, Deco.performTransfer(address,address,uint256,bytes)(msg.sender,_to,_value,)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyPayloadSize(2 * 32)

IRs:
TMP_16(uint256) = 2 * 32
MODIFIER_CALL, Deco.onlyPayloadSize(uint256)(TMP_16)""];
4->1;
}
",1,0,0,0,"onlyPayloadSize(2 * 32);performTransfer(msg.sender,_to,_value,);Transfer(msg.sender,_to,_value);true"
./0x18f0cd26c06449d967ca6aef8b5f9d8ee9fd7992_ext.sol,Exch.deposit,140,143,"REF_4(mapping(address => uint256)) -> tokens[0],REF_5(uint256) -> REF_4[msg.sender],REF_6(mapping(address => uint256)) -> tokens[0],REF_7(uint256) -> REF_6[msg.sender],TMP_43(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_7,msg.value),REF_5(uint256) (->tokens) := TMP_43(uint256),REF_8(mapping(address => uint256)) -> tokens[0],REF_9(uint256) -> REF_8[msg.sender],Emit Deposit(0,msg.sender,msg.value,REF_9)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender],msg.value)

IRs:
REF_4(mapping(address => uint256)) -> tokens[0]
REF_5(uint256) -> REF_4[msg.sender]
REF_6(mapping(address => uint256)) -> tokens[0]
REF_7(uint256) -> REF_6[msg.sender]
TMP_43(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_7,msg.value)
REF_5(uint256) (->tokens) := TMP_43(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Deposit(0,msg.sender,msg.value,tokens[0][msg.sender])

IRs:
REF_8(mapping(address => uint256)) -> tokens[0]
REF_9(uint256) -> REF_8[msg.sender]
Emit Deposit(0,msg.sender,msg.value,REF_9)""];
}
",1,0,0,0,"tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender],msg.value);Deposit(0,msg.sender,msg.value,tokens[0][msg.sender])"
./0x44f958d420f0543353a5e4f14e827d73f01b4261_ext.sol,EBBToken.migrate,195,209,"CONDITION isFunding,TMP_80 = CONVERT 0 to address,TMP_81(bool) = newContractAddr == TMP_80,CONDITION TMP_81,REF_31(uint256) -> balances[msg.sender],tokens(uint256) := REF_31(uint256),TMP_82(bool) = tokens == 0,CONDITION TMP_82,REF_32(uint256) -> balances[msg.sender],REF_32(uint256) (->balances) := 0(uint256),TMP_83(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(tokenMigrated,tokens),tokenMigrated(uint256) := TMP_83(uint256),TMP_84 = CONVERT newContractAddr to IMigrationContract,newContract(IMigrationContract) := TMP_84(IMigrationContract),TMP_85(bool) = HIGH_LEVEL_CALL, dest:newContract(IMigrationContract), function:migrate, arguments:['msg.sender', 'tokens']  ,TMP_86 = UnaryType.BANG TMP_85 ,CONDITION TMP_86,Emit Migrate(msg.sender,tokens)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
isFunding

IRs:
CONDITION isFunding""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
newContractAddr == address(0x0)

IRs:
TMP_80 = CONVERT 0 to address
TMP_81(bool) = newContractAddr == TMP_80
CONDITION TMP_81""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: THROW 5
""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
tokens = balances[msg.sender]

IRs:
REF_31(uint256) -> balances[msg.sender]
tokens(uint256) := REF_31(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
tokens == 0

IRs:
TMP_82(bool) = tokens == 0
CONDITION TMP_82""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: THROW 9
""];
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
balances[msg.sender] = 0

IRs:
REF_32(uint256) -> balances[msg.sender]
REF_32(uint256) (->balances) := 0(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
tokenMigrated = safeAdd(tokenMigrated,tokens)

IRs:
TMP_83(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(tokenMigrated,tokens)
tokenMigrated(uint256) := TMP_83(uint256)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
newContract = IMigrationContract(newContractAddr)

IRs:
TMP_84 = CONVERT newContractAddr to IMigrationContract
newContract(IMigrationContract) := TMP_84(IMigrationContract)""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
! newContract.migrate(msg.sender,tokens)

IRs:
TMP_85(bool) = HIGH_LEVEL_CALL, dest:newContract(IMigrationContract), function:migrate, arguments:['msg.sender', 'tokens']  
TMP_86 = UnaryType.BANG TMP_85 
CONDITION TMP_86""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: THROW 15
""];
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
Migrate(msg.sender,tokens)

IRs:
Emit Migrate(msg.sender,tokens)""];
}
",1,0,0,0,"isFunding;;;newContractAddr == address(0x0);;;tokens = balances[msg.sender];tokens == 0;;;balances[msg.sender] = 0;tokenMigrated = safeAdd(tokenMigrated,tokens);newContract = IMigrationContract(newContractAddr);! newContract.migrate(msg.sender,tokens);;;Migrate(msg.sender,tokens)"
./0x9ac36892387ed90df9af3de1b7082153f08f3ef8_ext.sol,DSProxy.setCache,151,160,"TMP_35(bool) = _cacheAddr != 0,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),TMP_37 = CONVERT _cacheAddr to DSProxyCache,cache(DSProxyCache) := TMP_37(DSProxyCache),RETURN True,MODIFIER_CALL, DSAuth.auth()(),MODIFIER_CALL, DSNote.note()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_cacheAddr != 0x0)

IRs:
TMP_35(bool) = _cacheAddr != 0
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
cache = DSProxyCache(_cacheAddr)

IRs:
TMP_37 = CONVERT _cacheAddr to DSProxyCache
cache(DSProxyCache) := TMP_37(DSProxyCache)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
note()

IRs:
MODIFIER_CALL, DSNote.note()()""];
5->1;
}
",1,0,0,0,auth();require(bool)(_cacheAddr != 0x0);cache = DSProxyCache(_cacheAddr);true;note()
./0xee91e81927bb047ea0f4b24e43dd5dc0684827a0_ext.sol,BINGToken.refundTokens,355,361,"TMP_111(bool) = msg.sender == owner,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113 = CONVERT this to address,TMP_114(bool) = _token != TMP_113,TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114),TMP_116 = CONVERT _token to AbstractToken,token(AbstractToken) := TMP_116(AbstractToken),TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ,Emit RefundTokens(_token,_refund,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_111(bool) = msg.sender == owner
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_113 = CONVERT this to address
TMP_114(bool) = _token != TMP_113
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
token = AbstractToken(_token)

IRs:
TMP_116 = CONVERT _token to AbstractToken
token(AbstractToken) := TMP_116(AbstractToken)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(_refund,_value)

IRs:
TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RefundTokens(_token,_refund,_value)

IRs:
Emit RefundTokens(_token,_refund,_value)""];
}
",1,0,0,0,"require(bool)(msg.sender == owner);require(bool)(_token != address(this));token = AbstractToken(_token);token.transfer(_refund,_value);RefundTokens(_token,_refund,_value)"
./0x5af9ec6df6edea0761fa841ce56c2e4deb000b31_ext.sol,ZebiCoinTempMgr.allocatenonCSTokens,681,688,"TMP_363 = CONVERT 0 to address,TMP_364(bool) = beneficiary != TMP_363,TMP_365(None) = SOLIDITY_CALL require(bool)(TMP_364),TMP_366(uint256) = 10 ** tokenDecimals,TMP_367(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokens', 'TMP_366'] ,Zweitokens(uint256) := TMP_367(uint256),REF_225(uint256) -> noncsAllocations[beneficiary],REF_227(uint256) -> noncsAllocations[beneficiary],TMP_368(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['Zweitokens', 'REF_227'] ,REF_225(uint256) (->noncsAllocations) := TMP_368(uint256),TMP_369(bool) = HIGH_LEVEL_CALL, dest:tsc(ZebiCoin), function:mint, arguments:['beneficiary', 'Zweitokens']  ,Emit AllocatenonCSTokens(beneficiary,Zweitokens),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != address(0))

IRs:
TMP_363 = CONVERT 0 to address
TMP_364(bool) = beneficiary != TMP_363
TMP_365(None) = SOLIDITY_CALL require(bool)(TMP_364)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
Zweitokens = tokens.mul(10 ** (tokenDecimals))

IRs:
TMP_366(uint256) = 10 ** tokenDecimals
TMP_367(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokens', 'TMP_366'] 
Zweitokens(uint256) := TMP_367(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
noncsAllocations[beneficiary] = Zweitokens.add(noncsAllocations[beneficiary])

IRs:
REF_225(uint256) -> noncsAllocations[beneficiary]
REF_227(uint256) -> noncsAllocations[beneficiary]
TMP_368(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['Zweitokens', 'REF_227'] 
REF_225(uint256) (->noncsAllocations) := TMP_368(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
tsc.mint(beneficiary,Zweitokens)

IRs:
TMP_369(bool) = HIGH_LEVEL_CALL, dest:tsc(ZebiCoin), function:mint, arguments:['beneficiary', 'Zweitokens']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
AllocatenonCSTokens(beneficiary,Zweitokens)

IRs:
Emit AllocatenonCSTokens(beneficiary,Zweitokens)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",1,0,0,0,"onlyOwner();require(bool)(beneficiary != address(0));Zweitokens = tokens.mul(10 ** (tokenDecimals));noncsAllocations[beneficiary] = Zweitokens.add(noncsAllocations[beneficiary]);tsc.mint(beneficiary,Zweitokens);AllocatenonCSTokens(beneficiary,Zweitokens)"
./0xa5e5be69c923c701ae6ac8f1f5936af3ae610c68_ext.sol,Collectables.mint,908,914,"TMP_537(Delegate) = INTERNAL_CALL, Collectables.getDelegate(uint32)(delegateID),delegate(Delegate) := TMP_537(Delegate),TMP_538(bool) = HIGH_LEVEL_CALL, dest:delegate(Delegate), function:mint, arguments:['msg.sender', 'to']  ,TMP_539(None) = SOLIDITY_CALL require(bool,string)(TMP_538,delegate could not mint token),REF_275 -> LENGTH collectables,TMP_542(uint256) := REF_275(uint256),TMP_543(uint256) = TMP_542 + 1,REF_275(uint256) (->collectables) := TMP_543(uint256),REF_276(uint32) -> collectables[TMP_542],REF_276(uint32) (->collectables) := delegateID(uint32),TMP_541(None) = TMP_540 - 1,id(uint256) := TMP_541(None),INTERNAL_CALL, ERC721Enumerable._mint(address,uint256)(to,id),RETURN id","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
delegate = getDelegate(delegateID)

IRs:
TMP_537(Delegate) = INTERNAL_CALL, Collectables.getDelegate(uint32)(delegateID)
delegate(Delegate) := TMP_537(Delegate)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(delegate.mint(msg.sender,to),delegate could not mint token)

IRs:
TMP_538(bool) = HIGH_LEVEL_CALL, dest:delegate(Delegate), function:mint, arguments:['msg.sender', 'to']  
TMP_539(None) = SOLIDITY_CALL require(bool,string)(TMP_538,delegate could not mint token)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
id = collectables.push(delegateID) - 1

IRs:
REF_275 -> LENGTH collectables
TMP_542(uint256) := REF_275(uint256)
TMP_543(uint256) = TMP_542 + 1
REF_275(uint256) (->collectables) := TMP_543(uint256)
REF_276(uint32) -> collectables[TMP_542]
REF_276(uint32) (->collectables) := delegateID(uint32)
TMP_541(None) = TMP_540 - 1
id(uint256) := TMP_541(None)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
super._mint(to,id)

IRs:
INTERNAL_CALL, ERC721Enumerable._mint(address,uint256)(to,id)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
id

IRs:
RETURN id""];
}
",1,0,0,0,"delegate = getDelegate(delegateID);require(bool,string)(delegate.mint(msg.sender,to),delegate could not mint token);id = collectables.push(delegateID) - 1;super._mint(to,id);id"
./0x4cf488387f035ff08c371515562cba712f9015d4_ext.sol,WPR.claimTokens,388,398,"TMP_219(bool) = _token == 0,CONDITION TMP_219,REF_185(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:owner value:REF_185,TMP_221 = CONVERT _token to ERC20,token(ERC20) := TMP_221(ERC20),TMP_222(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_222(uint256),TMP_223(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['owner', 'balance']  ,Emit ClaimedTokens(_token,owner,balance),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_219(bool) = _token == 0
CONDITION TMP_219""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(this.balance)

IRs:
REF_185(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:owner value:REF_185""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
token = ERC20(_token)

IRs:
TMP_221 = CONVERT _token to ERC20
token(ERC20) := TMP_221(ERC20)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_222(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_222(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(owner,balance)

IRs:
TMP_223(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['owner', 'balance']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,owner,balance)

IRs:
Emit ClaimedTokens(_token,owner,balance)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
9->1;
}
",1,0,0,0,"onlyOwner();_token == 0x0;owner.transfer(this.balance);;;token = ERC20(_token);balance = token.balanceOf(this);token.transfer(owner,balance);ClaimedTokens(_token,owner,balance)"
./0xa2edca10311a70883c5019b51048f55fd1508fe6_ext.sol,FoMo3DshortAgain.registerNameXID,594,608,"TMP_91(bytes32) = LIBRARY_CALL, dest:NameFilter, function:NameFilter.nameFilter(string), arguments:['_nameString'] ,_name(bytes32) := TMP_91(bytes32),_addr(address) := msg.sender(address),_paid(uint256) := msg.value(uint256),TUPLE_0(bool,uint256) = HIGH_LEVEL_CALL, dest:PlayerBook(PlayerBookInterface), function:registerNameXIDFromDapp, arguments:['_addr', '_name', '_affCode', '_all'] value:_paid ,_isNewPlayer(bool)= UNPACK TUPLE_0 index: 0 ,_affID(uint256)= UNPACK TUPLE_0 index: 1 ,REF_105(uint256) -> pIDxAddr_[_addr],_pID(uint256) := REF_105(uint256),REF_107(F3Ddatasets.Player) -> plyr_[_affID],REF_108(address) -> REF_107.addr,REF_109(F3Ddatasets.Player) -> plyr_[_affID],REF_110(bytes32) -> REF_109.name,Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_108,REF_110,_paid,now),MODIFIER_CALL, FoMo3DshortAgain.isHuman()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_name = _nameString.nameFilter()

IRs:
TMP_91(bytes32) = LIBRARY_CALL, dest:NameFilter, function:NameFilter.nameFilter(string), arguments:['_nameString'] 
_name(bytes32) := TMP_91(bytes32)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
_addr = msg.sender

IRs:
_addr(address) := msg.sender(address)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
_paid = msg.value

IRs:
_paid(uint256) := msg.value(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
(_isNewPlayer,_affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr,_name,_affCode,_all)

IRs:
TUPLE_0(bool,uint256) = HIGH_LEVEL_CALL, dest:PlayerBook(PlayerBookInterface), function:registerNameXIDFromDapp, arguments:['_addr', '_name', '_affCode', '_all'] value:_paid 
_isNewPlayer(bool)= UNPACK TUPLE_0 index: 0 
_affID(uint256)= UNPACK TUPLE_0 index: 1 ""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
_pID = pIDxAddr_[_addr]

IRs:
REF_105(uint256) -> pIDxAddr_[_addr]
_pID(uint256) := REF_105(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
F3Devents.onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,_paid,now)

IRs:
REF_107(F3Ddatasets.Player) -> plyr_[_affID]
REF_108(address) -> REF_107.addr
REF_109(F3Ddatasets.Player) -> plyr_[_affID]
REF_110(bytes32) -> REF_109.name
Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_108,REF_110,_paid,now)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
isHuman()

IRs:
MODIFIER_CALL, FoMo3DshortAgain.isHuman()()""];
9->1;
}
",1,0,0,0,"isHuman();_name = _nameString.nameFilter();_addr = msg.sender;_paid = msg.value;;;(_isNewPlayer,_affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr,_name,_affCode,_all);_pID = pIDxAddr_[_addr];F3Devents.onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,_paid,now)"
./0x5155a0722a45905dacf49598a02eff3777340acd_ext.sol,RegistryUpdater.updateFromRegistry,814,819,"TMP_158 = CONVERT polymathRegistry to PolymathRegistry,TMP_159(address) = HIGH_LEVEL_CALL, dest:TMP_158(PolymathRegistry), function:getAddress, arguments:['ModuleRegistry']  ,moduleRegistry(address) := TMP_159(address),TMP_160 = CONVERT polymathRegistry to PolymathRegistry,TMP_161(address) = HIGH_LEVEL_CALL, dest:TMP_160(PolymathRegistry), function:getAddress, arguments:['SecurityTokenRegistry']  ,securityTokenRegistry(address) := TMP_161(address),TMP_162 = CONVERT polymathRegistry to PolymathRegistry,TMP_163(address) = HIGH_LEVEL_CALL, dest:TMP_162(PolymathRegistry), function:getAddress, arguments:['FeatureRegistry']  ,featureRegistry(address) := TMP_163(address),TMP_164 = CONVERT polymathRegistry to PolymathRegistry,TMP_165(address) = HIGH_LEVEL_CALL, dest:TMP_164(PolymathRegistry), function:getAddress, arguments:['PolyToken']  ,polyToken(address) := TMP_165(address),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
moduleRegistry = PolymathRegistry(polymathRegistry).getAddress(ModuleRegistry)

IRs:
TMP_158 = CONVERT polymathRegistry to PolymathRegistry
TMP_159(address) = HIGH_LEVEL_CALL, dest:TMP_158(PolymathRegistry), function:getAddress, arguments:['ModuleRegistry']  
moduleRegistry(address) := TMP_159(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
securityTokenRegistry = PolymathRegistry(polymathRegistry).getAddress(SecurityTokenRegistry)

IRs:
TMP_160 = CONVERT polymathRegistry to PolymathRegistry
TMP_161(address) = HIGH_LEVEL_CALL, dest:TMP_160(PolymathRegistry), function:getAddress, arguments:['SecurityTokenRegistry']  
securityTokenRegistry(address) := TMP_161(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
featureRegistry = PolymathRegistry(polymathRegistry).getAddress(FeatureRegistry)

IRs:
TMP_162 = CONVERT polymathRegistry to PolymathRegistry
TMP_163(address) = HIGH_LEVEL_CALL, dest:TMP_162(PolymathRegistry), function:getAddress, arguments:['FeatureRegistry']  
featureRegistry(address) := TMP_163(address)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
polyToken = PolymathRegistry(polymathRegistry).getAddress(PolyToken)

IRs:
TMP_164 = CONVERT polymathRegistry to PolymathRegistry
TMP_165(address) = HIGH_LEVEL_CALL, dest:TMP_164(PolymathRegistry), function:getAddress, arguments:['PolyToken']  
polyToken(address) := TMP_165(address)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",1,0,0,0,onlyOwner();moduleRegistry = PolymathRegistry(polymathRegistry).getAddress(ModuleRegistry);securityTokenRegistry = PolymathRegistry(polymathRegistry).getAddress(SecurityTokenRegistry);featureRegistry = PolymathRegistry(polymathRegistry).getAddress(FeatureRegistry);polyToken = PolymathRegistry(polymathRegistry).getAddress(PolyToken)
./0x3420894bf786866a09937b0369d5b4781870c21f_ext.sol,LikeCoin.transferDelegated,314,325,"TMP_160(bool) = HIGH_LEVEL_CALL, dest:signatureChecker(SignatureChecker), function:checkTransferDelegated, arguments:['_from', '_to', '_value', '_maxReward', '_nonce', '_signature']  ,TMP_161(None) = SOLIDITY_CALL require(bool)(TMP_160),TMP_162(bool) = INTERNAL_CALL, LikeCoin._transfer(address,address,uint256)(_from,_to,_value),RETURN TMP_162,MODIFIER_CALL, LikeCoin.isDelegated(address,uint256,uint256,uint256)(_from,_maxReward,_claimedReward,_nonce),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(signatureChecker.checkTransferDelegated(_from,_to,_value,_maxReward,_nonce,_signature))

IRs:
TMP_160(bool) = HIGH_LEVEL_CALL, dest:signatureChecker(SignatureChecker), function:checkTransferDelegated, arguments:['_from', '_to', '_value', '_maxReward', '_nonce', '_signature']  
TMP_161(None) = SOLIDITY_CALL require(bool)(TMP_160)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
_transfer(_from,_to,_value)

IRs:
TMP_162(bool) = INTERNAL_CALL, LikeCoin._transfer(address,address,uint256)(_from,_to,_value)
RETURN TMP_162""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
isDelegated(_from,_maxReward,_claimedReward,_nonce)

IRs:
MODIFIER_CALL, LikeCoin.isDelegated(address,uint256,uint256,uint256)(_from,_maxReward,_claimedReward,_nonce)""];
3->1;
4[label=""Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,0,0,0,"isDelegated(_from,_maxReward,_claimedReward,_nonce);require(bool)(signatureChecker.checkTransferDelegated(_from,_to,_value,_maxReward,_nonce,_signature));_transfer(_from,_to,_value);success"
./0xb4a3fb248d39370c1f8081b73fa7098167c8142b_ext.sol,LPCWalletReserveWrapper.switchReserve,618,621,"TMP_536 = CONVERT walletReserve_ to address,TMP_537(bool) = TMP_536 != 0,TMP_538(None) = SOLIDITY_CALL assert(bool)(TMP_537),walletReserve(address) := walletReserve_(address),MODIFIER_CALL, DSNote.note()(),MODIFIER_CALL, DSAuth.auth()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(address(walletReserve_) != 0)

IRs:
TMP_536 = CONVERT walletReserve_ to address
TMP_537(bool) = TMP_536 != 0
TMP_538(None) = SOLIDITY_CALL assert(bool)(TMP_537)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
walletReserve = walletReserve_

IRs:
walletReserve(address) := walletReserve_(address)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
note()

IRs:
MODIFIER_CALL, DSNote.note()()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
4->1;
}
",1,0,0,0,note();assert(bool)(address(walletReserve_) != 0);walletReserve = walletReserve_;auth()
./0xdc919494349e803fbd2d4064106944418381edb3_ext.sol,SaiTub.cage,941,948,"TMP_709 = UnaryType.BANG off ,TMP_710(bool) = fit_ != 0,TMP_711(bool) = TMP_709 && TMP_710,TMP_712(None) = SOLIDITY_CALL require(bool)(TMP_711),off(bool) := True(bool),axe(uint256) := RAY(uint256),gap(uint256) := WAD(uint256),fit(uint256) := fit_(uint256),TMP_713(bool) = HIGH_LEVEL_CALL, dest:gem(ERC20), function:transfer, arguments:['tap', 'jam']  ,TMP_714(None) = SOLIDITY_CALL require(bool)(TMP_713),MODIFIER_CALL, DSNote.note()(),MODIFIER_CALL, DSAuth.auth()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! off && fit_ != 0)

IRs:
TMP_709 = UnaryType.BANG off 
TMP_710(bool) = fit_ != 0
TMP_711(bool) = TMP_709 && TMP_710
TMP_712(None) = SOLIDITY_CALL require(bool)(TMP_711)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
off = true

IRs:
off(bool) := True(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
axe = RAY

IRs:
axe(uint256) := RAY(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
gap = WAD

IRs:
gap(uint256) := WAD(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
fit = fit_

IRs:
fit(uint256) := fit_(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(gem.transfer(tap,jam))

IRs:
TMP_713(bool) = HIGH_LEVEL_CALL, dest:gem(ERC20), function:transfer, arguments:['tap', 'jam']  
TMP_714(None) = SOLIDITY_CALL require(bool)(TMP_713)""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
note()

IRs:
MODIFIER_CALL, DSNote.note()()""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
8->1;
}
",1,0,0,0,"note();require(bool)(! off && fit_ != 0);off = true;axe = RAY;gap = WAD;fit = fit_;require(bool)(gem.transfer(tap,jam));auth()"
./0x6f9ef4d30498f23e7d3116e272b855597fba83bd_ext.sol,P3DRaffle.devfeetodev,179,183,"HIGH_LEVEL_CALL, dest:SPASM_(SPASMInterface), function:disburse, arguments:[] value:devfee ,devfee(uint256) := 0(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
SPASM_.disburse.value(devfee)()

IRs:
HIGH_LEVEL_CALL, dest:SPASM_(SPASMInterface), function:disburse, arguments:[] value:devfee ""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
devfee = 0

IRs:
devfee(uint256) := 0(uint256)""];
}
",1,0,0,0,SPASM_.disburse.value(devfee)();devfee = 0
./0x470142a1834438515b757118f322703aba6e1e05_ext.sol,PolicyPalNetworkAirdrop.airDropSingleAmount,114,134,"i(uint256) := 0(uint256),REF_0 -> LENGTH _recipients,TMP_2(bool) = i < REF_0,CONDITION TMP_2,REF_1(address) -> _recipients[i],recipient(address) := REF_1(address),REF_2(bool) -> airdrops[recipient],TMP_3 = UnaryType.BANG REF_2 ,CONDITION TMP_3,TMP_4(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', '_amount']  ,TMP_5(None) = SOLIDITY_CALL assert(bool)(TMP_4),REF_4(bool) -> airdrops[recipient],REF_4(bool) (->airdrops) := True(bool),TMP_6(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] ,numDrops(uint256) := TMP_6(uint256),TMP_7(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', '_amount'] ,dropAmount(uint256) := TMP_7(uint256),Emit TokenDrop(recipient,_amount,AIRDROP),TMP_9(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()(),MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalance(address[],uint256)(_recipients,_amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _recipients.length

IRs:
REF_0 -> LENGTH _recipients
TMP_2(bool) = i < REF_0
CONDITION TMP_2""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
recipient = _recipients[i]

IRs:
REF_1(address) -> _recipients[i]
recipient(address) := REF_1(address)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
! airdrops[recipient]

IRs:
REF_2(bool) -> airdrops[recipient]
TMP_3 = UnaryType.BANG REF_2 
CONDITION TMP_3""];
6->7[label=""True""];
6->12[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(token.transfer(recipient,_amount))

IRs:
TMP_4(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', '_amount']  
TMP_5(None) = SOLIDITY_CALL assert(bool)(TMP_4)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
airdrops[recipient] = true

IRs:
REF_4(bool) -> airdrops[recipient]
REF_4(bool) (->airdrops) := True(bool)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
numDrops = numDrops.add(1)

IRs:
TMP_6(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] 
numDrops(uint256) := TMP_6(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
dropAmount = dropAmount.add(_amount)

IRs:
TMP_7(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', '_amount'] 
dropAmount(uint256) := TMP_7(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
TokenDrop(recipient,_amount,AIRDROP)

IRs:
Emit TokenDrop(recipient,_amount,AIRDROP)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
i ++

IRs:
TMP_9(uint256) := i(uint256)
i(uint256) = i + 1""];
13->4;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()()""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
validBalance(_recipients,_amount)

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalance(address[],uint256)(_recipients,_amount)""];
15->3;
}
",1,0,0,0,"onlyAdmin();;i < _recipients.length;;i = 0;recipient = _recipients[i];! airdrops[recipient];assert(bool)(token.transfer(recipient,_amount));;airdrops[recipient] = true;numDrops = numDrops.add(1);dropAmount = dropAmount.add(_amount);TokenDrop(recipient,_amount,AIRDROP);i ++;validBalance(_recipients,_amount)"
./0x359a46571d4bc22a6a9310038b51e2d91163412f_ext.sol,TokenSale.allocateServusTokens,794,798,"TMP_227 = UnaryType.BANG servusTokensAllocated ,TMP_228(None) = SOLIDITY_CALL require(bool)(TMP_227),TMP_229(bool) = HIGH_LEVEL_CALL, dest:servusToken(ServusTokenInterface), function:mint, arguments:['servusMultiSig', 'TOKENS_ALLOCATED_TO_SERVUS']  ,servusTokensAllocated(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, TokenSale.whenNotFinalized()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! servusTokensAllocated)

IRs:
TMP_227 = UnaryType.BANG servusTokensAllocated 
TMP_228(None) = SOLIDITY_CALL require(bool)(TMP_227)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
servusToken.mint(servusMultiSig,TOKENS_ALLOCATED_TO_SERVUS)

IRs:
TMP_229(bool) = HIGH_LEVEL_CALL, dest:servusToken(ServusTokenInterface), function:mint, arguments:['servusMultiSig', 'TOKENS_ALLOCATED_TO_SERVUS']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
servusTokensAllocated = true

IRs:
servusTokensAllocated(bool) := True(bool)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
whenNotFinalized()

IRs:
MODIFIER_CALL, TokenSale.whenNotFinalized()()""];
5->1;
}
",1,0,0,0,"onlyOwner();require(bool)(! servusTokensAllocated);servusToken.mint(servusMultiSig,TOKENS_ALLOCATED_TO_SERVUS);servusTokensAllocated = true;whenNotFinalized()"
./0x5af7af54e8bc34b293e356ef11fffe51d6f9ae78_ext.sol,Sample.mint,312,321,"TMP_119(uint256) = HIGH_LEVEL_CALL, dest:sampleStorage(SampleStorage), function:getType, arguments:['_randomNum']  ,sampleType(uint256) := TMP_119(uint256),INTERNAL_CALL, Sample.addSample(address,uint256,uint256)(_owner,sampleType,numOfSamples),Emit Mint(_owner,numOfSamples),TMP_122(uint256) := numOfSamples(uint256),numOfSamples(uint256) = numOfSamples + 1,MODIFIER_CALL, Sample.onlyCryptoJingles()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
sampleType = sampleStorage.getType(_randomNum)

IRs:
TMP_119(uint256) = HIGH_LEVEL_CALL, dest:sampleStorage(SampleStorage), function:getType, arguments:['_randomNum']  
sampleType(uint256) := TMP_119(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
addSample(_owner,sampleType,numOfSamples)

IRs:
INTERNAL_CALL, Sample.addSample(address,uint256,uint256)(_owner,sampleType,numOfSamples)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Mint(_owner,numOfSamples)

IRs:
Emit Mint(_owner,numOfSamples)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
numOfSamples ++

IRs:
TMP_122(uint256) := numOfSamples(uint256)
numOfSamples(uint256) = numOfSamples + 1""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyCryptoJingles()

IRs:
MODIFIER_CALL, Sample.onlyCryptoJingles()()""];
5->1;
}
",1,0,0,0,"onlyCryptoJingles();sampleType = sampleStorage.getType(_randomNum);addSample(_owner,sampleType,numOfSamples);Mint(_owner,numOfSamples);numOfSamples ++"
./0x46c9f93c3249c430c6ca19f02240ef9e038ba9d1_ext.sol,Escapable.escapeHatch,161,177,"REF_2(bool) -> escapeBlacklist[_token],TMP_30(bool) = REF_2 == False,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),TMP_32(bool) = _token == 0,CONDITION TMP_32,REF_3(uint256) = SOLIDITY_CALL balance(address)(this),balance(uint256) := REF_3([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B94689A0>]),Transfer dest:escapeHatchDestination value:balance,Emit EscapeHatchCalled(_token,balance),TMP_35 = CONVERT _token to ERC20,token(ERC20) := TMP_35(ERC20),TMP_36(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_36(uint256),TMP_37(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['escapeHatchDestination', 'balance']  ,Emit EscapeHatchCalled(_token,balance),MODIFIER_CALL, Escapable.onlyEscapeHatchCallerOrOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->13;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(escapeBlacklist[_token] == false)

IRs:
REF_2(bool) -> escapeBlacklist[_token]
TMP_30(bool) = REF_2 == False
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_token == 0x0

IRs:
TMP_32(bool) = _token == 0
CONDITION TMP_32""];
3->4[label=""True""];
3->8[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balance = this.balance

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
balance(uint256) := REF_3([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B94689A0>])""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
escapeHatchDestination.transfer(balance)

IRs:
Transfer dest:escapeHatchDestination value:balance""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
EscapeHatchCalled(_token,balance)

IRs:
Emit EscapeHatchCalled(_token,balance)""];
6->7;
7[label=""Node Type: RETURN 7
""];
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
token = ERC20(_token)

IRs:
TMP_35 = CONVERT _token to ERC20
token(ERC20) := TMP_35(ERC20)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_36(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_36(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
token.transfer(escapeHatchDestination,balance)

IRs:
TMP_37(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['escapeHatchDestination', 'balance']  ""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
EscapeHatchCalled(_token,balance)

IRs:
Emit EscapeHatchCalled(_token,balance)""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
onlyEscapeHatchCallerOrOwner()

IRs:
MODIFIER_CALL, Escapable.onlyEscapeHatchCallerOrOwner()()""];
13->1;
}
",1,0,1,0,"onlyEscapeHatchCallerOrOwner();require(bool)(escapeBlacklist[_token] == false);;_token == 0x0;balance = this.balance;;escapeHatchDestination.transfer(balance);EscapeHatchCalled(_token,balance);;token = ERC20(_token);balance = token.balanceOf(this);token.transfer(escapeHatchDestination,balance);EscapeHatchCalled(_token,balance)"
./0xc3e43d422d5e6f94315622d96a96058689c52ec8_ext.sol,BitNauticCrowdsaleTokenDistributor.grantContributorTokens,136,146,"REF_1(bool) -> hasClaimedTokens[contributor],TMP_30 = UnaryType.BANG REF_1 ,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),TMP_32(uint256) = HIGH_LEVEL_CALL, dest:crowdsale(BitNauticCrowdsale), function:creditOf, arguments:['contributor']  ,TMP_33(bool) = TMP_32 > 0,TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33),TMP_35(bool) = HIGH_LEVEL_CALL, dest:whitelist(BitNauticWhitelist), function:AMLWhitelisted, arguments:['contributor']  ,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),TMP_37(bool) = now > ICOEndTime,TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37),TMP_39(uint256) = HIGH_LEVEL_CALL, dest:crowdsale(BitNauticCrowdsale), function:creditOf, arguments:['contributor']  ,TMP_40(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['contributor', 'TMP_39']  ,TMP_41(None) = SOLIDITY_CALL assert(bool)(TMP_40),REF_6(bool) -> hasClaimedTokens[contributor],REF_6(bool) (->hasClaimedTokens) := True(bool),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! hasClaimedTokens[contributor])

IRs:
REF_1(bool) -> hasClaimedTokens[contributor]
TMP_30 = UnaryType.BANG REF_1 
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(crowdsale.creditOf(contributor) > 0)

IRs:
TMP_32(uint256) = HIGH_LEVEL_CALL, dest:crowdsale(BitNauticCrowdsale), function:creditOf, arguments:['contributor']  
TMP_33(bool) = TMP_32 > 0
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(whitelist.AMLWhitelisted(contributor))

IRs:
TMP_35(bool) = HIGH_LEVEL_CALL, dest:whitelist(BitNauticWhitelist), function:AMLWhitelisted, arguments:['contributor']  
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(now > ICOEndTime)

IRs:
TMP_37(bool) = now > ICOEndTime
TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(token.mint(contributor,crowdsale.creditOf(contributor)))

IRs:
TMP_39(uint256) = HIGH_LEVEL_CALL, dest:crowdsale(BitNauticCrowdsale), function:creditOf, arguments:['contributor']  
TMP_40(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['contributor', 'TMP_39']  
TMP_41(None) = SOLIDITY_CALL assert(bool)(TMP_40)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
hasClaimedTokens[contributor] = true

IRs:
REF_6(bool) -> hasClaimedTokens[contributor]
REF_6(bool) (->hasClaimedTokens) := True(bool)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,"require(bool)(! hasClaimedTokens[contributor]);require(bool)(crowdsale.creditOf(contributor) > 0);require(bool)(whitelist.AMLWhitelisted(contributor));require(bool)(now > ICOEndTime);assert(bool)(token.mint(contributor,crowdsale.creditOf(contributor)));hasClaimedTokens[contributor] = true;true"
./0xec841c878435ba4f28bf305a00c1483db0d96a20_ext.sol,Events.registration,267,271,"TMP_50(bytes) = SOLIDITY_CALL abi.encodePacked()(_message),TMP_51(bytes32) = SOLIDITY_CALL keccak256()(TMP_50),Emit LogAddress(_message,TMP_51,_account,tx.origin),MODIFIER_CALL, Events.onlyApprovedContract()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
LogAddress(_message,keccak256()(abi.encodePacked(_message)),_account,tx.origin)

IRs:
TMP_50(bytes) = SOLIDITY_CALL abi.encodePacked()(_message)
TMP_51(bytes32) = SOLIDITY_CALL keccak256()(TMP_50)
Emit LogAddress(_message,TMP_51,_account,tx.origin)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyApprovedContract()

IRs:
MODIFIER_CALL, Events.onlyApprovedContract()()""];
2->1;
}
",1,0,0,0,"onlyApprovedContract();LogAddress(_message,keccak256()(abi.encodePacked(_message)),_account,tx.origin)"
./0x29632c10d76bd1aed6b1524bf5bde4c992610670_ext.sol,ApplicationEntity.doStateChanges,975,993,"TMP_95 = UnaryType.BANG _locked ,CONDITION TMP_95,INTERNAL_CALL, ApplicationEntity.AssetProcessor()(),TUPLE_0(uint8,uint8) = INTERNAL_CALL, ApplicationEntity.getRequiredStateChanges()(),returnedCurrentEntityState(uint8)= UNPACK TUPLE_0 index: 0 ,EntityStateRequired(uint8)= UNPACK TUPLE_0 index: 1 ,callAgain(bool) := False(bool),Emit DebugApplicationRequiredChanges(returnedCurrentEntityState,EntityStateRequired),TMP_98(uint8) = INTERNAL_CALL, ApplicationEntity.getEntityState(bytes32)(__IGNORED__),TMP_99(bool) = EntityStateRequired != TMP_98,CONDITION TMP_99,INTERNAL_CALL, ApplicationEntity.EntityProcessor(uint8)(EntityStateRequired),callAgain(bool) := True(bool),TMP_101(None) = SOLIDITY_CALL revert()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
! _locked

IRs:
TMP_95 = UnaryType.BANG _locked 
CONDITION TMP_95""];
1->2[label=""True""];
1->12[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
AssetProcessor()

IRs:
INTERNAL_CALL, ApplicationEntity.AssetProcessor()()""];
2->3;
3[label=""Node Type: NEW VARIABLE 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
(returnedCurrentEntityState,EntityStateRequired) = getRequiredStateChanges()

IRs:
TUPLE_0(uint8,uint8) = INTERNAL_CALL, ApplicationEntity.getRequiredStateChanges()()
returnedCurrentEntityState(uint8)= UNPACK TUPLE_0 index: 0 
EntityStateRequired(uint8)= UNPACK TUPLE_0 index: 1 ""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
callAgain = false

IRs:
callAgain(bool) := False(bool)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
DebugApplicationRequiredChanges(returnedCurrentEntityState,EntityStateRequired)

IRs:
Emit DebugApplicationRequiredChanges(returnedCurrentEntityState,EntityStateRequired)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
EntityStateRequired != getEntityState(__IGNORED__)

IRs:
TMP_98(uint8) = INTERNAL_CALL, ApplicationEntity.getEntityState(bytes32)(__IGNORED__)
TMP_99(bool) = EntityStateRequired != TMP_98
CONDITION TMP_99""];
8->9[label=""True""];
8->11[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
EntityProcessor(EntityStateRequired)

IRs:
INTERNAL_CALL, ApplicationEntity.EntityProcessor(uint8)(EntityStateRequired)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
callAgain = true

IRs:
callAgain(bool) := True(bool)""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->13;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
revert()()

IRs:
TMP_101(None) = SOLIDITY_CALL revert()()""];
12->13;
13[label=""Node Type: END_IF 13
""];
}
",1,0,0,0,"! _locked;AssetProcessor();revert()();;;(returnedCurrentEntityState,EntityStateRequired) = getRequiredStateChanges();callAgain = false;DebugApplicationRequiredChanges(returnedCurrentEntityState,EntityStateRequired);EntityStateRequired != getEntityState(__IGNORED__);EntityProcessor(EntityStateRequired);;callAgain = true;"
./0x6d84769b1e287a27f282a938c8110b22714dbf78_ext.sol,ABIO_preICO.supplyICOContract,169,175,"TMP_101(bool) = _addr != 0,TMP_102(None) = SOLIDITY_CALL require(bool)(TMP_101),ICOAddress(address) := _addr(address),TMP_103 = CONVERT _addr to ABIO_ICO,ICO(ABIO_ICO) := TMP_103(ABIO_ICO),TMP_104 = UnaryType.BANG fundingGoalReached ,TMP_105(uint256) = HIGH_LEVEL_CALL, dest:ICO(ABIO_ICO), function:weiRaised, arguments:[]  ,TMP_106(uint256) = weiRaised + TMP_105,TMP_107(bool) = TMP_106 >= fundingGoal,TMP_108(bool) = TMP_104 && TMP_107,CONDITION TMP_108,INTERNAL_CALL, ABIO_preICO.goalReached()(),TMP_110(uint256) = HIGH_LEVEL_CALL, dest:ICO(ABIO_ICO), function:deadline, arguments:[]  ,finalDeadline(uint256) := TMP_110(uint256),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_addr != 0x0)

IRs:
TMP_101(bool) = _addr != 0
TMP_102(None) = SOLIDITY_CALL require(bool)(TMP_101)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ICOAddress = _addr

IRs:
ICOAddress(address) := _addr(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ICO = ABIO_ICO(_addr)

IRs:
TMP_103 = CONVERT _addr to ABIO_ICO
ICO(ABIO_ICO) := TMP_103(ABIO_ICO)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
! fundingGoalReached && weiRaised + ICO.weiRaised() >= fundingGoal

IRs:
TMP_104 = UnaryType.BANG fundingGoalReached 
TMP_105(uint256) = HIGH_LEVEL_CALL, dest:ICO(ABIO_ICO), function:weiRaised, arguments:[]  
TMP_106(uint256) = weiRaised + TMP_105
TMP_107(bool) = TMP_106 >= fundingGoal
TMP_108(bool) = TMP_104 && TMP_107
CONDITION TMP_108""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
goalReached()

IRs:
INTERNAL_CALL, ABIO_preICO.goalReached()()""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
finalDeadline = ICO.deadline()

IRs:
TMP_110(uint256) = HIGH_LEVEL_CALL, dest:ICO(ABIO_ICO), function:deadline, arguments:[]  
finalDeadline(uint256) := TMP_110(uint256)""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
8->1;
}
",1,0,0,0,onlyOwner();require(bool)(_addr != 0x0);ICOAddress = _addr;ICO = ABIO_ICO(_addr);! fundingGoalReached && weiRaised + ICO.weiRaised() >= fundingGoal;goalReached();;finalDeadline = ICO.deadline()
./0x5b82f83eeb171f829e5ca6d2c6205cd22ce7b821_ext.sol,FBBCToken.migrate,193,207,"CONDITION isFunding,TMP_74 = CONVERT 0 to address,TMP_75(bool) = newContractAddr == TMP_74,CONDITION TMP_75,REF_31(uint256) -> balances[msg.sender],tokens(uint256) := REF_31(uint256),TMP_76(bool) = tokens == 0,CONDITION TMP_76,REF_32(uint256) -> balances[msg.sender],REF_32(uint256) (->balances) := 0(uint256),TMP_77(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(tokenMigrated,tokens),tokenMigrated(uint256) := TMP_77(uint256),TMP_78 = CONVERT newContractAddr to IMigrationContract,newContract(IMigrationContract) := TMP_78(IMigrationContract),TMP_79(bool) = HIGH_LEVEL_CALL, dest:newContract(IMigrationContract), function:migrate, arguments:['msg.sender', 'tokens']  ,TMP_80 = UnaryType.BANG TMP_79 ,CONDITION TMP_80,Emit Migrate(msg.sender,tokens)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
isFunding

IRs:
CONDITION isFunding""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
newContractAddr == address(0x0)

IRs:
TMP_74 = CONVERT 0 to address
TMP_75(bool) = newContractAddr == TMP_74
CONDITION TMP_75""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: THROW 5
""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
tokens = balances[msg.sender]

IRs:
REF_31(uint256) -> balances[msg.sender]
tokens(uint256) := REF_31(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
tokens == 0

IRs:
TMP_76(bool) = tokens == 0
CONDITION TMP_76""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: THROW 9
""];
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
balances[msg.sender] = 0

IRs:
REF_32(uint256) -> balances[msg.sender]
REF_32(uint256) (->balances) := 0(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
tokenMigrated = safeAdd(tokenMigrated,tokens)

IRs:
TMP_77(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(tokenMigrated,tokens)
tokenMigrated(uint256) := TMP_77(uint256)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
newContract = IMigrationContract(newContractAddr)

IRs:
TMP_78 = CONVERT newContractAddr to IMigrationContract
newContract(IMigrationContract) := TMP_78(IMigrationContract)""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
! newContract.migrate(msg.sender,tokens)

IRs:
TMP_79(bool) = HIGH_LEVEL_CALL, dest:newContract(IMigrationContract), function:migrate, arguments:['msg.sender', 'tokens']  
TMP_80 = UnaryType.BANG TMP_79 
CONDITION TMP_80""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: THROW 15
""];
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
Migrate(msg.sender,tokens)

IRs:
Emit Migrate(msg.sender,tokens)""];
}
",1,0,0,0,"isFunding;;;newContractAddr == address(0x0);;;tokens = balances[msg.sender];tokens == 0;;;balances[msg.sender] = 0;tokenMigrated = safeAdd(tokenMigrated,tokens);newContract = IMigrationContract(newContractAddr);! newContract.migrate(msg.sender,tokens);;;Migrate(msg.sender,tokens)"
./0x750c1d91864171d7e1715a6b53ee28c72b8faa09_ext.sol,EthicHubUser.registerLocalNode,143,154,"TMP_58 = CONVERT 0 to address,TMP_59(bool) = target != TMP_58,TMP_60(None) = SOLIDITY_CALL require(bool)(TMP_59),TMP_61(bytes32) = SOLIDITY_CALL keccak256()(user,localNode,target),TMP_62(bool) = HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:getBool, arguments:['TMP_61']  ,isRegistered(bool) := TMP_62(bool),TMP_63 = UnaryType.BANG isRegistered ,CONDITION TMP_63,INTERNAL_CALL, EthicHubUser.changeUserStatus(address,string,bool)(target,localNode,True),TMP_65(bytes32) = SOLIDITY_CALL keccak256()(contract.name,reputation),TMP_66(address) = HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:getAddress, arguments:['TMP_65']  ,TMP_67 = CONVERT TMP_66 to EthicHubReputationInterface,rep(EthicHubReputationInterface) := TMP_67(EthicHubReputationInterface),HIGH_LEVEL_CALL, dest:rep(EthicHubReputationInterface), function:initLocalNodeReputation, arguments:['target']  ,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(target != address(0))

IRs:
TMP_58 = CONVERT 0 to address
TMP_59(bool) = target != TMP_58
TMP_60(None) = SOLIDITY_CALL require(bool)(TMP_59)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
isRegistered = ethicHubStorage.getBool(keccak256()(user,localNode,target))

IRs:
TMP_61(bytes32) = SOLIDITY_CALL keccak256()(user,localNode,target)
TMP_62(bool) = HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:getBool, arguments:['TMP_61']  
isRegistered(bool) := TMP_62(bool)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
! isRegistered

IRs:
TMP_63 = UnaryType.BANG isRegistered 
CONDITION TMP_63""];
3->4[label=""True""];
3->7[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
changeUserStatus(target,localNode,true)

IRs:
INTERNAL_CALL, EthicHubUser.changeUserStatus(address,string,bool)(target,localNode,True)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
rep = EthicHubReputationInterface(ethicHubStorage.getAddress(keccak256()(contract.name,reputation)))

IRs:
TMP_65(bytes32) = SOLIDITY_CALL keccak256()(contract.name,reputation)
TMP_66(address) = HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:getAddress, arguments:['TMP_65']  
TMP_67 = CONVERT TMP_66 to EthicHubReputationInterface
rep(EthicHubReputationInterface) := TMP_67(EthicHubReputationInterface)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
rep.initLocalNodeReputation(target)

IRs:
HIGH_LEVEL_CALL, dest:rep(EthicHubReputationInterface), function:initLocalNodeReputation, arguments:['target']  ""];
6->7;
7[label=""Node Type: END_IF 7
""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
8->1;
}
",1,0,0,0,"onlyOwner();require(bool)(target != address(0));isRegistered = ethicHubStorage.getBool(keccak256()(user,localNode,target));! isRegistered;changeUserStatus(target,localNode,true);;rep = EthicHubReputationInterface(ethicHubStorage.getAddress(keccak256()(contract.name,reputation)));rep.initLocalNodeReputation(target)"
./0x44f958d420f0543353a5e4f14e827d73f01b4261_ext.sol,EBBToken.migrate,195,209,"CONDITION isFunding,TMP_80 = CONVERT 0 to address,TMP_81(bool) = newContractAddr == TMP_80,CONDITION TMP_81,REF_31(uint256) -> balances[msg.sender],tokens(uint256) := REF_31(uint256),TMP_82(bool) = tokens == 0,CONDITION TMP_82,REF_32(uint256) -> balances[msg.sender],REF_32(uint256) (->balances) := 0(uint256),TMP_83(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(tokenMigrated,tokens),tokenMigrated(uint256) := TMP_83(uint256),TMP_84 = CONVERT newContractAddr to IMigrationContract,newContract(IMigrationContract) := TMP_84(IMigrationContract),TMP_85(bool) = HIGH_LEVEL_CALL, dest:newContract(IMigrationContract), function:migrate, arguments:['msg.sender', 'tokens']  ,TMP_86 = UnaryType.BANG TMP_85 ,CONDITION TMP_86,Emit Migrate(msg.sender,tokens)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
isFunding

IRs:
CONDITION isFunding""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
newContractAddr == address(0x0)

IRs:
TMP_80 = CONVERT 0 to address
TMP_81(bool) = newContractAddr == TMP_80
CONDITION TMP_81""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: THROW 5
""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
tokens = balances[msg.sender]

IRs:
REF_31(uint256) -> balances[msg.sender]
tokens(uint256) := REF_31(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
tokens == 0

IRs:
TMP_82(bool) = tokens == 0
CONDITION TMP_82""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: THROW 9
""];
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
balances[msg.sender] = 0

IRs:
REF_32(uint256) -> balances[msg.sender]
REF_32(uint256) (->balances) := 0(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
tokenMigrated = safeAdd(tokenMigrated,tokens)

IRs:
TMP_83(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(tokenMigrated,tokens)
tokenMigrated(uint256) := TMP_83(uint256)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
newContract = IMigrationContract(newContractAddr)

IRs:
TMP_84 = CONVERT newContractAddr to IMigrationContract
newContract(IMigrationContract) := TMP_84(IMigrationContract)""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
! newContract.migrate(msg.sender,tokens)

IRs:
TMP_85(bool) = HIGH_LEVEL_CALL, dest:newContract(IMigrationContract), function:migrate, arguments:['msg.sender', 'tokens']  
TMP_86 = UnaryType.BANG TMP_85 
CONDITION TMP_86""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: THROW 15
""];
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
Migrate(msg.sender,tokens)

IRs:
Emit Migrate(msg.sender,tokens)""];
}
",1,0,0,0,"isFunding;;;newContractAddr == address(0x0);;;tokens = balances[msg.sender];tokens == 0;;;balances[msg.sender] = 0;tokenMigrated = safeAdd(tokenMigrated,tokens);newContract = IMigrationContract(newContractAddr);! newContract.migrate(msg.sender,tokens);;;Migrate(msg.sender,tokens)"
./0xc58f1f3ec051b51f10c4feb0cfd10d811d055ef5_ext.sol,ldoh.Holdplatform_Deposit,486,496,"TMP_203(bool) = amount > 0,TMP_204(None) = SOLIDITY_CALL require(bool)(TMP_203),TMP_205 = CONVERT Holdplatform_address to ERC20Interface,token(ERC20Interface) := TMP_205(ERC20Interface),TMP_206 = CONVERT this to address,TMP_207(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Interface), function:transferFrom, arguments:['msg.sender', 'TMP_206', 'amount']  ,TMP_208(None) = SOLIDITY_CALL require(bool)(TMP_207),TMP_209(uint256) = INTERNAL_CALL, ldoh.add(uint256,uint256)(Holdplatform_balance,amount),newbalance(uint256) := TMP_209(uint256),Holdplatform_balance(uint256) := newbalance(uint256),Emit onHoldplatformdeposit(amount,newbalance,now),MODIFIER_CALL, EthereumSmartContract.restricted()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_203(bool) = amount > 0
TMP_204(None) = SOLIDITY_CALL require(bool)(TMP_203)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
token = ERC20Interface(Holdplatform_address)

IRs:
TMP_205 = CONVERT Holdplatform_address to ERC20Interface
token(ERC20Interface) := TMP_205(ERC20Interface)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(token.transferFrom(msg.sender,address(this),amount))

IRs:
TMP_206 = CONVERT this to address
TMP_207(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Interface), function:transferFrom, arguments:['msg.sender', 'TMP_206', 'amount']  
TMP_208(None) = SOLIDITY_CALL require(bool)(TMP_207)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
newbalance = add(Holdplatform_balance,amount)

IRs:
TMP_209(uint256) = INTERNAL_CALL, ldoh.add(uint256,uint256)(Holdplatform_balance,amount)
newbalance(uint256) := TMP_209(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Holdplatform_balance = newbalance

IRs:
Holdplatform_balance(uint256) := newbalance(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onHoldplatformdeposit(amount,newbalance,now)

IRs:
Emit onHoldplatformdeposit(amount,newbalance,now)""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
restricted()

IRs:
MODIFIER_CALL, EthereumSmartContract.restricted()()""];
7->1;
}
",1,0,0,0,"restricted();require(bool)(amount > 0);token = ERC20Interface(Holdplatform_address);require(bool)(token.transferFrom(msg.sender,address(this),amount));newbalance = add(Holdplatform_balance,amount);Holdplatform_balance = newbalance;onHoldplatformdeposit(amount,newbalance,now)"
./0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06_ext.sol,BreedingClockAuction.createAuction,1081,1094,"TMP_841 = CONVERT _startingPrice to uint128,TMP_842 = CONVERT TMP_841 to uint256,TMP_843(bool) = _startingPrice == TMP_842,TMP_844(None) = SOLIDITY_CALL require(bool)(TMP_843),TMP_845 = CONVERT _endingPrice to uint128,TMP_846 = CONVERT TMP_845 to uint256,TMP_847(bool) = _endingPrice == TMP_846,TMP_848(None) = SOLIDITY_CALL require(bool)(TMP_847),TMP_849 = CONVERT _duration to uint64,TMP_850 = CONVERT TMP_849 to uint256,TMP_851(bool) = _duration == TMP_850,TMP_852(None) = SOLIDITY_CALL require(bool)(TMP_851),TMP_853(bool) = INTERNAL_CALL, ClockAuctionBase.isOwnerOf(address,uint256)(msg.sender,_tokenId),TMP_854(None) = SOLIDITY_CALL require(bool)(TMP_853),INTERNAL_CALL, ClockAuctionBase._escrow(address,uint256)(msg.sender,_tokenId),startAt(uint64) := _startAt(uint64),TMP_856(bool) = _startAt == 0,CONDITION TMP_856,TMP_857 = CONVERT now to uint64,startAt(uint64) := TMP_857(uint64),TMP_858 = CONVERT _startingPrice to uint128,TMP_859 = CONVERT _endingPrice to uint128,TMP_860 = CONVERT _duration to uint64,TMP_861 = CONVERT startAt to uint64,TMP_862(ClockAuctionBase.Auction) = new Auction(_seller,TMP_858,TMP_859,TMP_860,TMP_861),auction(ClockAuctionBase.Auction) := TMP_862(ClockAuctionBase.Auction),INTERNAL_CALL, ClockAuctionBase._addAuction(uint256,ClockAuctionBase.Auction)(_tokenId,auction),MODIFIER_CALL, Pausable.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_startingPrice == uint256(uint128(_startingPrice)))

IRs:
TMP_841 = CONVERT _startingPrice to uint128
TMP_842 = CONVERT TMP_841 to uint256
TMP_843(bool) = _startingPrice == TMP_842
TMP_844(None) = SOLIDITY_CALL require(bool)(TMP_843)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_endingPrice == uint256(uint128(_endingPrice)))

IRs:
TMP_845 = CONVERT _endingPrice to uint128
TMP_846 = CONVERT TMP_845 to uint256
TMP_847(bool) = _endingPrice == TMP_846
TMP_848(None) = SOLIDITY_CALL require(bool)(TMP_847)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_duration == uint256(uint64(_duration)))

IRs:
TMP_849 = CONVERT _duration to uint64
TMP_850 = CONVERT TMP_849 to uint256
TMP_851(bool) = _duration == TMP_850
TMP_852(None) = SOLIDITY_CALL require(bool)(TMP_851)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(isOwnerOf(msg.sender,_tokenId))

IRs:
TMP_853(bool) = INTERNAL_CALL, ClockAuctionBase.isOwnerOf(address,uint256)(msg.sender,_tokenId)
TMP_854(None) = SOLIDITY_CALL require(bool)(TMP_853)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_escrow(msg.sender,_tokenId)

IRs:
INTERNAL_CALL, ClockAuctionBase._escrow(address,uint256)(msg.sender,_tokenId)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
startAt = _startAt

IRs:
startAt(uint64) := _startAt(uint64)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
_startAt == 0

IRs:
TMP_856(bool) = _startAt == 0
CONDITION TMP_856""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
startAt = uint64(now)

IRs:
TMP_857 = CONVERT now to uint64
startAt(uint64) := TMP_857(uint64)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
auction = Auction(_seller,uint128(_startingPrice),uint128(_endingPrice),uint64(_duration),uint64(startAt))

IRs:
TMP_858 = CONVERT _startingPrice to uint128
TMP_859 = CONVERT _endingPrice to uint128
TMP_860 = CONVERT _duration to uint64
TMP_861 = CONVERT startAt to uint64
TMP_862(ClockAuctionBase.Auction) = new Auction(_seller,TMP_858,TMP_859,TMP_860,TMP_861)
auction(ClockAuctionBase.Auction) := TMP_862(ClockAuctionBase.Auction)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
_addAuction(_tokenId,auction)

IRs:
INTERNAL_CALL, ClockAuctionBase._addAuction(uint256,ClockAuctionBase.Auction)(_tokenId,auction)""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
12->1;
}
",1,0,0,0,"whenNotPaused();require(bool)(_startingPrice == uint256(uint128(_startingPrice)));require(bool)(_endingPrice == uint256(uint128(_endingPrice)));require(bool)(_duration == uint256(uint64(_duration)));require(bool)(isOwnerOf(msg.sender,_tokenId));_escrow(msg.sender,_tokenId);startAt = _startAt;_startAt == 0;startAt = uint64(now);;auction = Auction(_seller,uint128(_startingPrice),uint128(_endingPrice),uint64(_duration),uint64(startAt));_addAuction(_tokenId,auction)"
./0x003ffefefbc4a6f34a62a3ca7b7937a880065bcb_ext.sol,Token.airDropToken,203,208,"i(uint256) := 0(uint256),REF_104 -> LENGTH owners,TMP_126(bool) = i < REF_104,CONDITION TMP_126,TMP_127 = CONVERT _tokenAddr to Coin,REF_106(address) -> owners[i],TMP_128 = CONVERT REF_106 to address,REF_107(address) -> owners[i],REF_108(uint256) -> balanceOf[REF_107],TMP_129(uint256) = REF_108 / _value,TMP_130(bool) = HIGH_LEVEL_CALL, dest:TMP_127(Coin), function:transfer, arguments:['TMP_128', 'TMP_129']  ,TMP_131(bool) = TMP_130 == True,TMP_132(None) = SOLIDITY_CALL assert(bool)(TMP_131),TMP_133 = CONVERT _tokenAddr to address,REF_109(address) -> owners[i],TMP_134 = CONVERT REF_109 to address,REF_110(address) -> owners[i],REF_111(uint256) -> balanceOf[REF_110],REF_112(address) -> owners[i],REF_113(uint256) -> balanceOf[REF_112],TMP_135(uint256) = REF_113 / _value,Emit AirDropToken(TMP_133,TMP_134,REF_111,_value,TMP_135),TMP_137(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < owners.length

IRs:
REF_104 -> LENGTH owners
TMP_126(bool) = i < REF_104
CONDITION TMP_126""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)((Coin(_tokenAddr).transfer(address(owners[i]),balanceOf[owners[i]] / _value)) == true)

IRs:
TMP_127 = CONVERT _tokenAddr to Coin
REF_106(address) -> owners[i]
TMP_128 = CONVERT REF_106 to address
REF_107(address) -> owners[i]
REF_108(uint256) -> balanceOf[REF_107]
TMP_129(uint256) = REF_108 / _value
TMP_130(bool) = HIGH_LEVEL_CALL, dest:TMP_127(Coin), function:transfer, arguments:['TMP_128', 'TMP_129']  
TMP_131(bool) = TMP_130 == True
TMP_132(None) = SOLIDITY_CALL assert(bool)(TMP_131)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
AirDropToken(address(_tokenAddr),address(owners[i]),balanceOf[owners[i]],_value,(balanceOf[owners[i]] / _value))

IRs:
TMP_133 = CONVERT _tokenAddr to address
REF_109(address) -> owners[i]
TMP_134 = CONVERT REF_109 to address
REF_110(address) -> owners[i]
REF_111(uint256) -> balanceOf[REF_110]
REF_112(address) -> owners[i]
REF_113(uint256) -> balanceOf[REF_112]
TMP_135(uint256) = REF_113 / _value
Emit AirDropToken(TMP_133,TMP_134,REF_111,_value,TMP_135)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_137(uint256) := i(uint256)
i(uint256) = i + 1""];
7->4;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
8->3;
}
",1,0,0,0,"onlyOwner();;i < owners.length;;i = 0;assert(bool)((Coin(_tokenAddr).transfer(address(owners[i]),balanceOf[owners[i]] / _value)) == true);AirDropToken(address(_tokenAddr),address(owners[i]),balanceOf[owners[i]],_value,(balanceOf[owners[i]] / _value));i ++"
./0xc45865b235a7c6693b9db5fed46ea8a3022d9b07_ext.sol,DcorpCrowdsaleProxy.updateBalances,661,673,"updating(bool) := True(bool),TMP_51(uint256) = totalTokensReceived - totalTokensWithdrawn,recordedBalance(uint256) := TMP_51(uint256),TMP_52(uint256) = HIGH_LEVEL_CALL, dest:token(IToken), function:balanceOf, arguments:['this']  ,actualBalance(uint256) := TMP_52(uint256),TMP_53(bool) = actualBalance > recordedBalance,CONDITION TMP_53,TMP_54(uint256) = actualBalance - recordedBalance,totalTokensReceived(uint256) = totalTokensReceived + TMP_54,updating(bool) := False(bool),MODIFIER_CALL, DcorpCrowdsaleProxy.only_when_not_updating()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
updating = true

IRs:
updating(bool) := True(bool)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
recordedBalance = totalTokensReceived - totalTokensWithdrawn

IRs:
TMP_51(uint256) = totalTokensReceived - totalTokensWithdrawn
recordedBalance(uint256) := TMP_51(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
actualBalance = token.balanceOf(this)

IRs:
TMP_52(uint256) = HIGH_LEVEL_CALL, dest:token(IToken), function:balanceOf, arguments:['this']  
actualBalance(uint256) := TMP_52(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
actualBalance > recordedBalance

IRs:
TMP_53(bool) = actualBalance > recordedBalance
CONDITION TMP_53""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalTokensReceived += actualBalance - recordedBalance

IRs:
TMP_54(uint256) = actualBalance - recordedBalance
totalTokensReceived(uint256) = totalTokensReceived + TMP_54""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
updating = false

IRs:
updating(bool) := False(bool)""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
only_when_not_updating()

IRs:
MODIFIER_CALL, DcorpCrowdsaleProxy.only_when_not_updating()()""];
8->1;
}
",1,0,0,0,only_when_not_updating();updating = true;recordedBalance = totalTokensReceived - totalTokensWithdrawn;actualBalance = token.balanceOf(this);actualBalance > recordedBalance;totalTokensReceived += actualBalance - recordedBalance;;updating = false
./0x341f9c6c60c07fd11ef0bbc93586a2b9d68bfcf0_ext.sol,VINContract.sendTokensToFounders,522,536,"TMP_395 = UnaryType.BANG sentTokensToFounders ,TMP_396(bool) = now >= foundersRewardTime,TMP_397(bool) = TMP_395 && TMP_396,TMP_398(None) = SOLIDITY_CALL require(bool)(TMP_397),TMP_399(uint256) = INTERNAL_CALL, SafeMath.add(uint256,uint256)(totalSoldOnICO,totalSoldOnPresale),tokensSold(uint256) := TMP_399(uint256),TMP_400(uint256) = INTERNAL_CALL, SafeMath.add(uint256,uint256)(ICOCap,presaleCap),totalTokenToSold(uint256) := TMP_400(uint256),TMP_401(uint256) = INTERNAL_CALL, SafeMath.mul(uint256,uint256)(tokensSold,totalCap),TMP_402(uint256) = INTERNAL_CALL, SafeMath.mul(uint256,uint256)(TMP_401,35),x(uint256) := TMP_402(uint256),TMP_403(uint256) = INTERNAL_CALL, SafeMath.mul(uint256,uint256)(100,totalTokenToSold),y(uint256) := TMP_403(uint256),TMP_404(uint256) = INTERNAL_CALL, SafeMath.div(uint256,uint256)(x,y),result(uint256) := TMP_404(uint256),HIGH_LEVEL_CALL, dest:VINToken(VINNDTokenContract), function:emitTokens, arguments:['founder', 'result']  ,sentTokensToFounders(bool) := True(bool),MODIFIER_CALL, VINContract.onlyManager()(),MODIFIER_CALL, VINContract.whenInitialized()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! sentTokensToFounders && now >= foundersRewardTime)

IRs:
TMP_395 = UnaryType.BANG sentTokensToFounders 
TMP_396(bool) = now >= foundersRewardTime
TMP_397(bool) = TMP_395 && TMP_396
TMP_398(None) = SOLIDITY_CALL require(bool)(TMP_397)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
tokensSold = add(totalSoldOnICO,totalSoldOnPresale)

IRs:
TMP_399(uint256) = INTERNAL_CALL, SafeMath.add(uint256,uint256)(totalSoldOnICO,totalSoldOnPresale)
tokensSold(uint256) := TMP_399(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
totalTokenToSold = add(ICOCap,presaleCap)

IRs:
TMP_400(uint256) = INTERNAL_CALL, SafeMath.add(uint256,uint256)(ICOCap,presaleCap)
totalTokenToSold(uint256) := TMP_400(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
x = mul(mul(tokensSold,totalCap),35)

IRs:
TMP_401(uint256) = INTERNAL_CALL, SafeMath.mul(uint256,uint256)(tokensSold,totalCap)
TMP_402(uint256) = INTERNAL_CALL, SafeMath.mul(uint256,uint256)(TMP_401,35)
x(uint256) := TMP_402(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
y = mul(100,totalTokenToSold)

IRs:
TMP_403(uint256) = INTERNAL_CALL, SafeMath.mul(uint256,uint256)(100,totalTokenToSold)
y(uint256) := TMP_403(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
result = div(x,y)

IRs:
TMP_404(uint256) = INTERNAL_CALL, SafeMath.div(uint256,uint256)(x,y)
result(uint256) := TMP_404(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
VINToken.emitTokens(founder,result)

IRs:
HIGH_LEVEL_CALL, dest:VINToken(VINNDTokenContract), function:emitTokens, arguments:['founder', 'result']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
sentTokensToFounders = true

IRs:
sentTokensToFounders(bool) := True(bool)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyManager()

IRs:
MODIFIER_CALL, VINContract.onlyManager()()""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
whenInitialized()

IRs:
MODIFIER_CALL, VINContract.whenInitialized()()""];
10->1;
}
",1,0,0,0,"onlyManager();require(bool)(! sentTokensToFounders && now >= foundersRewardTime);tokensSold = add(totalSoldOnICO,totalSoldOnPresale);totalTokenToSold = add(ICOCap,presaleCap);x = mul(mul(tokensSold,totalCap),35);y = mul(100,totalTokenToSold);result = div(x,y);VINToken.emitTokens(founder,result);sentTokensToFounders = true;whenInitialized()"
./0x75a17c63c2121447655955b55aaa1a413e750232_ext.sol,CryderCrowdsale.requestTokens,523,528,"TMP_219(uint256) = HIGH_LEVEL_CALL, dest:presaleToken(CryderToken), function:balanceOf, arguments:['msg.sender']  ,TMP_220(bool) = TMP_219 > 0,REF_138(bool) -> tokenRequests[msg.sender],TMP_221(bool) = REF_138 == False,TMP_222(bool) = TMP_220 && TMP_221,TMP_223(None) = SOLIDITY_CALL require(bool)(TMP_222),TMP_224(uint256) = HIGH_LEVEL_CALL, dest:presaleToken(CryderToken), function:balanceOf, arguments:['msg.sender']  ,TMP_225(bool) = HIGH_LEVEL_CALL, dest:token(CryderToken), function:mint, arguments:['msg.sender', 'TMP_224']  ,REF_141(bool) -> tokenRequests[msg.sender],REF_141(bool) (->tokenRequests) := True(bool),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(presaleToken.balanceOf(msg.sender) > 0 && tokenRequests[msg.sender] == false)

IRs:
TMP_219(uint256) = HIGH_LEVEL_CALL, dest:presaleToken(CryderToken), function:balanceOf, arguments:['msg.sender']  
TMP_220(bool) = TMP_219 > 0
REF_138(bool) -> tokenRequests[msg.sender]
TMP_221(bool) = REF_138 == False
TMP_222(bool) = TMP_220 && TMP_221
TMP_223(None) = SOLIDITY_CALL require(bool)(TMP_222)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
token.mint(msg.sender,presaleToken.balanceOf(msg.sender))

IRs:
TMP_224(uint256) = HIGH_LEVEL_CALL, dest:presaleToken(CryderToken), function:balanceOf, arguments:['msg.sender']  
TMP_225(bool) = HIGH_LEVEL_CALL, dest:token(CryderToken), function:mint, arguments:['msg.sender', 'TMP_224']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tokenRequests[msg.sender] = true

IRs:
REF_141(bool) -> tokenRequests[msg.sender]
REF_141(bool) (->tokenRequests) := True(bool)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,"require(bool)(presaleToken.balanceOf(msg.sender) > 0 && tokenRequests[msg.sender] == false);token.mint(msg.sender,presaleToken.balanceOf(msg.sender));tokenRequests[msg.sender] = true;true"
./0x9271a6512b8f27a5f8daa01a62bdc533709e859a_ext.sol,LockToken.lock,86,92,"TMP_27 = UnaryType.BANG isLocked ,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),TMP_29(uint256) = INTERNAL_CALL, LockToken.tokenBalance()(),TMP_30(bool) = TMP_29 > 0,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),start_time(uint256) := now(uint256),end_time(uint256) := lockTime(uint256),isLocked(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isLocked)

IRs:
TMP_27 = UnaryType.BANG isLocked 
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(tokenBalance() > 0)

IRs:
TMP_29(uint256) = INTERNAL_CALL, LockToken.tokenBalance()()
TMP_30(bool) = TMP_29 > 0
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
start_time = now

IRs:
start_time(uint256) := now(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
end_time = lockTime

IRs:
end_time(uint256) := lockTime(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
isLocked = true

IRs:
isLocked(bool) := True(bool)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",1,0,0,0,onlyOwner();require(bool)(! isLocked);require(bool)(tokenBalance() > 0);start_time = now;end_time = lockTime;isLocked = true
./0xedf19b437d1a67e18b15dd4a859dd52f9cfa012f_ext.sol,ERC777TokenScheduledTimelock.scheduleTimelock,315,322,"TMP_115 = CONVERT 0 to address,TMP_116(bool) = _beneficiary != TMP_115,TMP_117(None) = SOLIDITY_CALL require(bool)(TMP_116),TMP_118(uint256) = INTERNAL_CALL, ERC777TokenScheduledTimelock.getNow()(),TMP_119(bool) = _lockTill > TMP_118,TMP_120(None) = SOLIDITY_CALL require(bool)(TMP_119),TMP_121 = CONVERT this to address,TMP_122(uint256) = HIGH_LEVEL_CALL, dest:token(ERC777Token), function:balanceOf, arguments:['TMP_121']  ,TMP_123(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalVested', '_lockTokenAmount'] ,TMP_124(bool) = TMP_122 >= TMP_123,TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124),TMP_126(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalVested', '_lockTokenAmount'] ,totalVested(uint256) := TMP_126(uint256),REF_26(ERC777TokenScheduledTimelock.Timelock[]) -> schedule[_beneficiary],TMP_127(ERC777TokenScheduledTimelock.Timelock) = new Timelock(_lockTill,_lockTokenAmount),REF_28 -> LENGTH REF_26,TMP_129(uint256) := REF_28(uint256),TMP_130(uint256) = TMP_129 + 1,REF_28(uint256) (->schedule) := TMP_130(uint256),REF_29(ERC777TokenScheduledTimelock.Timelock) -> REF_26[TMP_129],REF_29(ERC777TokenScheduledTimelock.Timelock) (->schedule) := TMP_127(ERC777TokenScheduledTimelock.Timelock),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_beneficiary != address(0))

IRs:
TMP_115 = CONVERT 0 to address
TMP_116(bool) = _beneficiary != TMP_115
TMP_117(None) = SOLIDITY_CALL require(bool)(TMP_116)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_lockTill > getNow())

IRs:
TMP_118(uint256) = INTERNAL_CALL, ERC777TokenScheduledTimelock.getNow()()
TMP_119(bool) = _lockTill > TMP_118
TMP_120(None) = SOLIDITY_CALL require(bool)(TMP_119)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(token.balanceOf(address(this)) >= totalVested.add(_lockTokenAmount))

IRs:
TMP_121 = CONVERT this to address
TMP_122(uint256) = HIGH_LEVEL_CALL, dest:token(ERC777Token), function:balanceOf, arguments:['TMP_121']  
TMP_123(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalVested', '_lockTokenAmount'] 
TMP_124(bool) = TMP_122 >= TMP_123
TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
totalVested = totalVested.add(_lockTokenAmount)

IRs:
TMP_126(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalVested', '_lockTokenAmount'] 
totalVested(uint256) := TMP_126(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
schedule[_beneficiary].push(Timelock({till:_lockTill,amount:_lockTokenAmount}))

IRs:
REF_26(ERC777TokenScheduledTimelock.Timelock[]) -> schedule[_beneficiary]
TMP_127(ERC777TokenScheduledTimelock.Timelock) = new Timelock(_lockTill,_lockTokenAmount)
REF_28 -> LENGTH REF_26
TMP_129(uint256) := REF_28(uint256)
TMP_130(uint256) = TMP_129 + 1
REF_28(uint256) (->schedule) := TMP_130(uint256)
REF_29(ERC777TokenScheduledTimelock.Timelock) -> REF_26[TMP_129]
REF_29(ERC777TokenScheduledTimelock.Timelock) (->schedule) := TMP_127(ERC777TokenScheduledTimelock.Timelock)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",1,0,0,0,"onlyOwner();require(bool)(_beneficiary != address(0));require(bool)(_lockTill > getNow());require(bool)(token.balanceOf(address(this)) >= totalVested.add(_lockTokenAmount));totalVested = totalVested.add(_lockTokenAmount);schedule[_beneficiary].push(Timelock({till:_lockTill,amount:_lockTokenAmount}))"
./0x32c62c965db5fdac0f94e6276d6884070068d4be_ext.sol,MyAdvancedToken.mint,71,75,"REF_16(uint256) -> balances_[who],REF_16(-> balances_) = REF_16 + val,totalSupply_(uint256) = totalSupply_ + val,Emit Transfer(0,who,val),MODIFIER_CALL, MyAdvancedToken.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances_[who] += val

IRs:
REF_16(uint256) -> balances_[who]
REF_16(-> balances_) = REF_16 + val""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply_ += val

IRs:
totalSupply_(uint256) = totalSupply_ + val""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,who,val)

IRs:
Emit Transfer(0,who,val)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, MyAdvancedToken.whenNotPaused()()""];
4->1;
}
",1,1,0,0,"whenNotPaused();balances_[who] += val;totalSupply_ += val;Transfer(0,who,val)"
./0xee3aaa50b8000cc87d66cd3d4704fd3316fc8725_ext.sol,MineFarmer.seedMarket,89,96,"TMP_58(bool) = marketEggs == 0,TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58),TMP_60(bool) = tkn > 0,CONDITION TMP_60,TMP_61 = CONVERT this to address,TMP_62(bool) = HIGH_LEVEL_CALL, dest:Token(_0xBitcoinToken), function:transferFrom, arguments:['msg.sender', 'TMP_61', 'tkn']  ,initialized(bool) := True(bool),marketEggs(uint256) := eggs(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(marketEggs == 0)

IRs:
TMP_58(bool) = marketEggs == 0
TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
tkn > 0

IRs:
TMP_60(bool) = tkn > 0
CONDITION TMP_60""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Token.transferFrom(msg.sender,address(this),tkn)

IRs:
TMP_61 = CONVERT this to address
TMP_62(bool) = HIGH_LEVEL_CALL, dest:Token(_0xBitcoinToken), function:transferFrom, arguments:['msg.sender', 'TMP_61', 'tkn']  ""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
initialized = true

IRs:
initialized(bool) := True(bool)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
marketEggs = eggs

IRs:
marketEggs(uint256) := eggs(uint256)""];
}
",1,0,0,0,"require(bool)(marketEggs == 0);tkn > 0;Token.transferFrom(msg.sender,address(this),tkn);;initialized = true;marketEggs = eggs"
./0x1cca91a47db357445b89269f2fb4f647cd209968_ext.sol,Distribution.sendTokensSingleValue,82,89,"i(uint256) := 0(uint256),TMP_22(uint256) = 10 ** 8,TMP_23(uint256) = value * TMP_22,toSend(uint256) := TMP_23(uint256),REF_4 -> LENGTH dests,TMP_24(bool) = i < REF_4,CONDITION TMP_24,REF_5(address) -> dests[i],INTERNAL_CALL, Distribution.sendInternally(address,uint256,uint256)(REF_5,toSend,value),TMP_26(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Distribution.whenDropIsActive()(),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
toSend = value * 10 ** 8

IRs:
TMP_22(uint256) = 10 ** 8
TMP_23(uint256) = value * TMP_22
toSend(uint256) := TMP_23(uint256)""];
2->3;
3[label=""Node Type: BEGIN_LOOP 3
""];
3->4;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < dests.length

IRs:
REF_4 -> LENGTH dests
TMP_24(bool) = i < REF_4
CONDITION TMP_24""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
sendInternally(dests[i],toSend,value)

IRs:
REF_5(address) -> dests[i]
INTERNAL_CALL, Distribution.sendInternally(address,uint256,uint256)(REF_5,toSend,value)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_26(uint256) := i(uint256)
i(uint256) = i + 1""];
6->4;
7[label=""Node Type: END_LOOP 7
""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
whenDropIsActive()

IRs:
MODIFIER_CALL, Distribution.whenDropIsActive()()""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
9->1;
}
",1,0,0,0,"whenDropIsActive();i = 0;toSend = value * 10 ** 8;;i < dests.length;sendInternally(dests[i],toSend,value);;i ++;onlyOwner()"
./0x17b031b3802789a458955b3d27c60a0379f187b4_ext.sol,Bitbegin.transfer,173,185,"TMP_34(bool) = _value > 0,REF_27(uint256) -> _balanceOf[msg.sender],TMP_35(bool) = _value <= REF_27,TMP_36(bool) = TMP_34 && TMP_35,TMP_37(bool) = INTERNAL_CALL, Bitbegin.isContract(address)(_to),TMP_38 = UnaryType.BANG TMP_37 ,TMP_39(bool) = TMP_36 && TMP_38,TMP_40(bool) = INTERNAL_CALL, Bitbegin.isLock(address)(msg.sender),TMP_41 = UnaryType.BANG TMP_40 ,TMP_42(bool) = TMP_39 && TMP_41,CONDITION TMP_42,REF_28(uint256) -> _balanceOf[msg.sender],REF_29(uint256) -> _balanceOf[msg.sender],TMP_43(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_29', '_value'] ,REF_28(uint256) (->_balanceOf) := TMP_43(uint256),REF_31(uint256) -> _balanceOf[_to],REF_32(uint256) -> _balanceOf[_to],TMP_44(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_32', '_value'] ,REF_31(uint256) (->_balanceOf) := TMP_44(uint256),Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN False","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_value > 0 && _value <= _balanceOf[msg.sender] && ! isContract(_to) && ! isLock(msg.sender)

IRs:
TMP_34(bool) = _value > 0
REF_27(uint256) -> _balanceOf[msg.sender]
TMP_35(bool) = _value <= REF_27
TMP_36(bool) = TMP_34 && TMP_35
TMP_37(bool) = INTERNAL_CALL, Bitbegin.isContract(address)(_to)
TMP_38 = UnaryType.BANG TMP_37 
TMP_39(bool) = TMP_36 && TMP_38
TMP_40(bool) = INTERNAL_CALL, Bitbegin.isLock(address)(msg.sender)
TMP_41 = UnaryType.BANG TMP_40 
TMP_42(bool) = TMP_39 && TMP_41
CONDITION TMP_42""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_balanceOf[msg.sender] = _balanceOf[msg.sender].sub(_value)

IRs:
REF_28(uint256) -> _balanceOf[msg.sender]
REF_29(uint256) -> _balanceOf[msg.sender]
TMP_43(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_29', '_value'] 
REF_28(uint256) (->_balanceOf) := TMP_43(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_balanceOf[_to] = _balanceOf[_to].add(_value)

IRs:
REF_31(uint256) -> _balanceOf[_to]
REF_32(uint256) -> _balanceOf[_to]
TMP_44(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_32', '_value'] 
REF_31(uint256) (->_balanceOf) := TMP_44(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
}
",1,0,0,0,"_value > 0 && _value <= _balanceOf[msg.sender] && ! isContract(_to) && ! isLock(msg.sender);_balanceOf[msg.sender] = _balanceOf[msg.sender].sub(_value);;_balanceOf[_to] = _balanceOf[_to].add(_value);Transfer(msg.sender,_to,_value);true;false"
./0x2d820ea3a6b9302c500feeb7f6361ba1ddfa5aba_ext.sol,BancorLender.offerToLend,1047,1056,"TMP_389(bool) = HIGH_LEVEL_CALL, dest:bancorToken(IERC20Token), function:transferFrom, arguments:['msg.sender', 'this', '_amount']  ,TMP_390(None) = SOLIDITY_CALL assert(bool)(TMP_389),REF_113(address) -> agreement.lender,REF_113(address) (->agreement) := msg.sender(address),REF_114(address) -> agreement.borrower,REF_114(address) (->agreement) := 0(uint256),REF_115(uint256) -> agreement.tokenAmount,REF_115(uint256) (->agreement) := _amount(uint256),REF_116(uint256) -> agreement.expiration,REF_116(uint256) (->agreement) := _expiration(uint256),REF_118 -> LENGTH agreements,TMP_392(uint256) := REF_118(uint256),TMP_393(uint256) = TMP_392 + 1,REF_118(uint256) (->agreements) := TMP_393(uint256),REF_119(BancorLender.BorrowAgreement) -> agreements[TMP_392],REF_119(BancorLender.BorrowAgreement) (->agreements) := agreement(BancorLender.BorrowAgreement)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(bancorToken.transferFrom(msg.sender,this,_amount))

IRs:
TMP_389(bool) = HIGH_LEVEL_CALL, dest:bancorToken(IERC20Token), function:transferFrom, arguments:['msg.sender', 'this', '_amount']  
TMP_390(None) = SOLIDITY_CALL assert(bool)(TMP_389)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
agreement.lender = msg.sender

IRs:
REF_113(address) -> agreement.lender
REF_113(address) (->agreement) := msg.sender(address)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
agreement.borrower = 0

IRs:
REF_114(address) -> agreement.borrower
REF_114(address) (->agreement) := 0(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
agreement.tokenAmount = _amount

IRs:
REF_115(uint256) -> agreement.tokenAmount
REF_115(uint256) (->agreement) := _amount(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
agreement.expiration = _expiration

IRs:
REF_116(uint256) -> agreement.expiration
REF_116(uint256) (->agreement) := _expiration(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
agreements.push(agreement)

IRs:
REF_118 -> LENGTH agreements
TMP_392(uint256) := REF_118(uint256)
TMP_393(uint256) = TMP_392 + 1
REF_118(uint256) (->agreements) := TMP_393(uint256)
REF_119(BancorLender.BorrowAgreement) -> agreements[TMP_392]
REF_119(BancorLender.BorrowAgreement) (->agreements) := agreement(BancorLender.BorrowAgreement)""];
}
",1,0,0,0,"assert(bool)(bancorToken.transferFrom(msg.sender,this,_amount));;agreement.lender = msg.sender;agreement.borrower = 0;agreement.tokenAmount = _amount;agreement.expiration = _expiration;agreements.push(agreement)"
./0x25cf23787ac0f92a3eafa61f458ad0b7c4b27c3d_ext.sol,Zethroll.ownerTransferZTH,364,374,"TMP_85(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['contractBalance', 'amount'] ,contractBalance(uint256) := TMP_85(uint256),INTERNAL_CALL, Zethroll.setMaxProfit()(),TMP_87(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:transfer, arguments:['sendTo', 'amount']  ,TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87),Emit LogOwnerTransfer(sendTo,amount),MODIFIER_CALL, Zethroll.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
contractBalance = contractBalance.sub(amount)

IRs:
TMP_85(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['contractBalance', 'amount'] 
contractBalance(uint256) := TMP_85(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
setMaxProfit()

IRs:
INTERNAL_CALL, Zethroll.setMaxProfit()()""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(ZTHTKN.transfer(sendTo,amount))

IRs:
TMP_87(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:transfer, arguments:['sendTo', 'amount']  
TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
LogOwnerTransfer(sendTo,amount)

IRs:
Emit LogOwnerTransfer(sendTo,amount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Zethroll.onlyOwner()()""];
5->1;
}
",1,0,0,0,"onlyOwner();contractBalance = contractBalance.sub(amount);setMaxProfit();require(bool)(ZTHTKN.transfer(sendTo,amount));LogOwnerTransfer(sendTo,amount)"
./0x00ec5112673b69bd5f545dc6a3bede8674f878eb_ext.sol,CCPToken.refundTokens,388,394,"TMP_118(bool) = msg.sender == owner,TMP_119(None) = SOLIDITY_CALL require(bool)(TMP_118),TMP_120 = CONVERT this to address,TMP_121(bool) = _token != TMP_120,TMP_122(None) = SOLIDITY_CALL require(bool)(TMP_121),TMP_123 = CONVERT _token to AbstractToken,token(AbstractToken) := TMP_123(AbstractToken),TMP_124(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ,Emit RefundTokens(_token,_refund,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_118(bool) = msg.sender == owner
TMP_119(None) = SOLIDITY_CALL require(bool)(TMP_118)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_120 = CONVERT this to address
TMP_121(bool) = _token != TMP_120
TMP_122(None) = SOLIDITY_CALL require(bool)(TMP_121)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
token = AbstractToken(_token)

IRs:
TMP_123 = CONVERT _token to AbstractToken
token(AbstractToken) := TMP_123(AbstractToken)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(_refund,_value)

IRs:
TMP_124(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RefundTokens(_token,_refund,_value)

IRs:
Emit RefundTokens(_token,_refund,_value)""];
}
",1,0,0,0,"require(bool)(msg.sender == owner);require(bool)(_token != address(this));token = AbstractToken(_token);token.transfer(_refund,_value);RefundTokens(_token,_refund,_value)"
./0x0e54b1b8ff833b5f2b0d17453d97d340cb7576e4_ext.sol,ERC223Token.transfer,13,13,"TMP_24(bool) = INTERNAL_CALL, ERC223Token.isContract(address)(_to),CONDITION TMP_24,TMP_25(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(msg.sender),TMP_26(bool) = TMP_25 < _value,CONDITION TMP_26,TMP_27(None) = SOLIDITY_CALL revert()(),REF_1(uint256) -> balances[msg.sender],TMP_28(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(msg.sender),TMP_29(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(TMP_28,_value),REF_1(uint256) (->balances) := TMP_29(uint256),REF_2(uint256) -> balances[_to],TMP_30(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(_to),TMP_31(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(TMP_30,_value),REF_2(uint256) (->balances) := TMP_31(uint256),TMP_33(bytes32) = SOLIDITY_CALL keccak256()(_custom_fallback),TMP_34 = CONVERT TMP_33 to bytes4,TMP_35(bool) = LOW_LEVEL_CALL, dest:_to, function:call, arguments:['TMP_34', 'msg.sender', '_value', '_data'] value:0 ,TMP_36(None) = SOLIDITY_CALL assert(bool)(TMP_35),Emit Transfer(msg.sender,_to,_value,_data),RETURN True,TMP_38(bool) = INTERNAL_CALL, ERC223Token.transferToAddress(address,uint256,bytes)(_to,_value,_data),RETURN TMP_38,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
isContract(_to)

IRs:
TMP_24(bool) = INTERNAL_CALL, ERC223Token.isContract(address)(_to)
CONDITION TMP_24""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
balanceOf(msg.sender) < _value

IRs:
TMP_25(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(msg.sender)
TMP_26(bool) = TMP_25 < _value
CONDITION TMP_26""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
revert()()

IRs:
TMP_27(None) = SOLIDITY_CALL revert()()""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[msg.sender] = safeSub(balanceOf(msg.sender),_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_28(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(msg.sender)
TMP_29(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(TMP_28,_value)
REF_1(uint256) (->balances) := TMP_29(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[_to] = safeAdd(balanceOf(_to),_value)

IRs:
REF_2(uint256) -> balances[_to]
TMP_30(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(_to)
TMP_31(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(TMP_30,_value)
REF_2(uint256) (->balances) := TMP_31(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(_to.call.value(0)(bytes4(keccak256()(_custom_fallback)),msg.sender,_value,_data))

IRs:
TMP_33(bytes32) = SOLIDITY_CALL keccak256()(_custom_fallback)
TMP_34 = CONVERT TMP_33 to bytes4
TMP_35(bool) = LOW_LEVEL_CALL, dest:_to, function:call, arguments:['TMP_34', 'msg.sender', '_value', '_data'] value:0 
TMP_36(None) = SOLIDITY_CALL assert(bool)(TMP_35)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(msg.sender,_to,_value,_data)

IRs:
Emit Transfer(msg.sender,_to,_value,_data)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: RETURN 10

EXPRESSION:
transferToAddress(_to,_value,_data)

IRs:
TMP_38(bool) = INTERNAL_CALL, ERC223Token.transferToAddress(address,uint256,bytes)(_to,_value,_data)
RETURN TMP_38""];
12[label=""Node Type: RETURN 12

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,0,0,0,"isContract(_to);balanceOf(msg.sender) < _value;transferToAddress(_to,_value,_data);revert()();;balances[msg.sender] = safeSub(balanceOf(msg.sender),_value);balances[_to] = safeAdd(balanceOf(_to),_value);assert(bool)(_to.call.value(0)(bytes4(keccak256()(_custom_fallback)),msg.sender,_value,_data));Transfer(msg.sender,_to,_value,_data);true;success"
./0x5c2978a171033a19c1a455c84875f3609dab0a7e_ext.sol,ETYCSale.ownerAllocateTokens,639,650,"TMP_223(address) = HIGH_LEVEL_CALL, dest:tokenReward(ETYCToken), function:owner, arguments:[]  ,TMP_224(bool) = HIGH_LEVEL_CALL, dest:tokenReward(ETYCToken), function:transferFrom, arguments:['TMP_223', '_to', 'amountMiniEtyc']  ,TMP_225 = UnaryType.BANG TMP_224 ,CONDITION TMP_225,TMP_226(None) = SOLIDITY_CALL revert()(),REF_125(uint256) -> balanceOf[_to],REF_126(uint256) -> balanceOf[_to],TMP_227(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_126', 'amountWei'] ,REF_125(uint256) (->balanceOf) := TMP_227(uint256),TMP_228(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['amountRaised', 'amountWei'] ,amountRaised(uint256) := TMP_228(uint256),Emit FundTransfer(_to,amountWei,True),INTERNAL_CALL, ETYCSale.checkFundingGoal()(),INTERNAL_CALL, ETYCSale.checkFundingCap()(),MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, ETYCSale.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
! tokenReward.transferFrom(tokenReward.owner(),_to,amountMiniEtyc)

IRs:
TMP_223(address) = HIGH_LEVEL_CALL, dest:tokenReward(ETYCToken), function:owner, arguments:[]  
TMP_224(bool) = HIGH_LEVEL_CALL, dest:tokenReward(ETYCToken), function:transferFrom, arguments:['TMP_223', '_to', 'amountMiniEtyc']  
TMP_225 = UnaryType.BANG TMP_224 
CONDITION TMP_225""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_226(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[_to] = balanceOf[_to].add(amountWei)

IRs:
REF_125(uint256) -> balanceOf[_to]
REF_126(uint256) -> balanceOf[_to]
TMP_227(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_126', 'amountWei'] 
REF_125(uint256) (->balanceOf) := TMP_227(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
amountRaised = amountRaised.add(amountWei)

IRs:
TMP_228(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['amountRaised', 'amountWei'] 
amountRaised(uint256) := TMP_228(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
FundTransfer(_to,amountWei,true)

IRs:
Emit FundTransfer(_to,amountWei,True)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
checkFundingGoal()

IRs:
INTERNAL_CALL, ETYCSale.checkFundingGoal()()""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
checkFundingCap()

IRs:
INTERNAL_CALL, ETYCSale.checkFundingCap()()""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, ETYCSale.nonReentrant()()""];
10->1;
}
",1,0,0,0,"onlyOwner();! tokenReward.transferFrom(tokenReward.owner(),_to,amountMiniEtyc);revert()();;balanceOf[_to] = balanceOf[_to].add(amountWei);amountRaised = amountRaised.add(amountWei);FundTransfer(_to,amountWei,true);checkFundingGoal();checkFundingCap();nonReentrant()"
./0x271a0b465d5b453bb835afd2d671c76b2b76900e_ext.sol,ClockAuction.createAuction,551,580,"TMP_234(bool) = INTERNAL_CALL, ClockAuctionBase._isAddressSupportedContract(address)(_contract),TMP_235(None) = SOLIDITY_CALL require(bool)(TMP_234),TMP_236 = CONVERT _startingPrice to uint128,TMP_237 = CONVERT TMP_236 to uint256,TMP_238(bool) = _startingPrice == TMP_237,TMP_239(None) = SOLIDITY_CALL require(bool)(TMP_238),TMP_240 = CONVERT _endingPrice to uint128,TMP_241 = CONVERT TMP_240 to uint256,TMP_242(bool) = _endingPrice == TMP_241,TMP_243(None) = SOLIDITY_CALL require(bool)(TMP_242),TMP_244 = CONVERT _duration to uint64,TMP_245 = CONVERT TMP_244 to uint256,TMP_246(bool) = _duration == TMP_245,TMP_247(None) = SOLIDITY_CALL require(bool)(TMP_246),INTERNAL_CALL, ClockAuctionBase._escrow(address,address,uint256)(_contract,_seller,_tokenId),TMP_249 = CONVERT _startingPrice to uint128,TMP_250 = CONVERT _endingPrice to uint128,TMP_251 = CONVERT _duration to uint64,TMP_252 = CONVERT now to uint64,TMP_253(ClockAuctionBase.Auction) = new Auction(_contract,_seller,TMP_249,TMP_250,TMP_251,TMP_252),auction(ClockAuctionBase.Auction) := TMP_253(ClockAuctionBase.Auction),INTERNAL_CALL, ClockAuctionBase._addAuction(address,uint256,ClockAuctionBase.Auction)(_contract,_tokenId,auction),MODIFIER_CALL, Pausable.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_isAddressSupportedContract(_contract))

IRs:
TMP_234(bool) = INTERNAL_CALL, ClockAuctionBase._isAddressSupportedContract(address)(_contract)
TMP_235(None) = SOLIDITY_CALL require(bool)(TMP_234)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_startingPrice == uint256(uint128(_startingPrice)))

IRs:
TMP_236 = CONVERT _startingPrice to uint128
TMP_237 = CONVERT TMP_236 to uint256
TMP_238(bool) = _startingPrice == TMP_237
TMP_239(None) = SOLIDITY_CALL require(bool)(TMP_238)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_endingPrice == uint256(uint128(_endingPrice)))

IRs:
TMP_240 = CONVERT _endingPrice to uint128
TMP_241 = CONVERT TMP_240 to uint256
TMP_242(bool) = _endingPrice == TMP_241
TMP_243(None) = SOLIDITY_CALL require(bool)(TMP_242)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_duration == uint256(uint64(_duration)))

IRs:
TMP_244 = CONVERT _duration to uint64
TMP_245 = CONVERT TMP_244 to uint256
TMP_246(bool) = _duration == TMP_245
TMP_247(None) = SOLIDITY_CALL require(bool)(TMP_246)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_escrow(_contract,_seller,_tokenId)

IRs:
INTERNAL_CALL, ClockAuctionBase._escrow(address,address,uint256)(_contract,_seller,_tokenId)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
auction = Auction(_contract,_seller,uint128(_startingPrice),uint128(_endingPrice),uint64(_duration),uint64(now))

IRs:
TMP_249 = CONVERT _startingPrice to uint128
TMP_250 = CONVERT _endingPrice to uint128
TMP_251 = CONVERT _duration to uint64
TMP_252 = CONVERT now to uint64
TMP_253(ClockAuctionBase.Auction) = new Auction(_contract,_seller,TMP_249,TMP_250,TMP_251,TMP_252)
auction(ClockAuctionBase.Auction) := TMP_253(ClockAuctionBase.Auction)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
_addAuction(_contract,_tokenId,auction)

IRs:
INTERNAL_CALL, ClockAuctionBase._addAuction(address,uint256,ClockAuctionBase.Auction)(_contract,_tokenId,auction)""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
8->1;
}
",1,0,0,0,"whenNotPaused();require(bool)(_isAddressSupportedContract(_contract));require(bool)(_startingPrice == uint256(uint128(_startingPrice)));require(bool)(_endingPrice == uint256(uint128(_endingPrice)));require(bool)(_duration == uint256(uint64(_duration)));_escrow(_contract,_seller,_tokenId);auction = Auction(_contract,_seller,uint128(_startingPrice),uint128(_endingPrice),uint64(_duration),uint64(now));_addAuction(_contract,_tokenId,auction)"
./0x74f887f5b336704be1591f8a2f2e419767134316_ext.sol,ERC20.transfer,85,85,"INTERNAL_CALL, ERC20._transfer(address,address,uint256)(msg.sender,to,value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_transfer(msg.sender,to,value)

IRs:
INTERNAL_CALL, ERC20._transfer(address,address,uint256)(msg.sender,to,value)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,"_transfer(msg.sender,to,value);true"
./0xaa63c8683647ef91b3fdab4b4989ee9588da297b_ext.sol,DSProxyFactory.build,156,158,"TMP_43(DSProxy) = INTERNAL_CALL, DSProxyFactory.build(address)(msg.sender),proxy(DSProxy) := TMP_43(DSProxy),RETURN proxy","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
proxy = build(msg.sender)

IRs:
TMP_43(DSProxy) = INTERNAL_CALL, DSProxyFactory.build(address)(msg.sender)
proxy(DSProxy) := TMP_43(DSProxy)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
proxy

IRs:
RETURN proxy""];
}
",1,0,0,0,proxy = build(msg.sender);proxy
./0x6c764fac2ed1c5fabf8bcd86bae68d8cdbe8290e_ext.sol,BaseWallet.init,570,581,"TMP_131 = CONVERT 0 to address,TMP_132(bool) = owner == TMP_131,TMP_133(bool) = modules == 0,TMP_134(bool) = TMP_132 && TMP_133,TMP_135(None) = SOLIDITY_CALL require(bool,string)(TMP_134,BW: wallet already initialised),REF_51 -> LENGTH _modules,TMP_136(bool) = REF_51 > 0,TMP_137(None) = SOLIDITY_CALL require(bool,string)(TMP_136,BW: construction requires at least 1 module),owner(address) := _owner(address),REF_52 -> LENGTH _modules,modules(uint256) := REF_52(uint256),i(uint256) := 0(uint256),REF_53 -> LENGTH _modules,TMP_138(bool) = i < REF_53,CONDITION TMP_138,REF_54(address) -> _modules[i],REF_55(bool) -> authorised[REF_54],TMP_139(bool) = REF_55 == False,TMP_140(None) = SOLIDITY_CALL require(bool,string)(TMP_139,BW: module is already added),REF_56(address) -> _modules[i],REF_57(bool) -> authorised[REF_56],REF_57(bool) (->authorised) := True(bool),REF_58(address) -> _modules[i],TMP_141 = CONVERT REF_58 to Module,HIGH_LEVEL_CALL, dest:TMP_141(Module), function:init, arguments:['this']  ,REF_60(address) -> _modules[i],Emit AuthorisedModule(REF_60,True),TMP_144(uint256) := i(uint256),i(uint256) = i + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(owner == address(0) && modules == 0,BW: wallet already initialised)

IRs:
TMP_131 = CONVERT 0 to address
TMP_132(bool) = owner == TMP_131
TMP_133(bool) = modules == 0
TMP_134(bool) = TMP_132 && TMP_133
TMP_135(None) = SOLIDITY_CALL require(bool,string)(TMP_134,BW: wallet already initialised)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(_modules.length > 0,BW: construction requires at least 1 module)

IRs:
REF_51 -> LENGTH _modules
TMP_136(bool) = REF_51 > 0
TMP_137(None) = SOLIDITY_CALL require(bool,string)(TMP_136,BW: construction requires at least 1 module)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner = _owner

IRs:
owner(address) := _owner(address)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
modules = _modules.length

IRs:
REF_52 -> LENGTH _modules
modules(uint256) := REF_52(uint256)""];
4->7;
5[label=""Node Type: BEGIN_LOOP 5
""];
5->8;
6[label=""Node Type: END_LOOP 6
""];
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
7->5;
8[label=""Node Type: IF_LOOP 8

EXPRESSION:
i < _modules.length

IRs:
REF_53 -> LENGTH _modules
TMP_138(bool) = i < REF_53
CONDITION TMP_138""];
8->9[label=""True""];
8->6[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool,string)(authorised[_modules[i]] == false,BW: module is already added)

IRs:
REF_54(address) -> _modules[i]
REF_55(bool) -> authorised[REF_54]
TMP_139(bool) = REF_55 == False
TMP_140(None) = SOLIDITY_CALL require(bool,string)(TMP_139,BW: module is already added)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
authorised[_modules[i]] = true

IRs:
REF_56(address) -> _modules[i]
REF_57(bool) -> authorised[REF_56]
REF_57(bool) (->authorised) := True(bool)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
Module(_modules[i]).init(this)

IRs:
REF_58(address) -> _modules[i]
TMP_141 = CONVERT REF_58 to Module
HIGH_LEVEL_CALL, dest:TMP_141(Module), function:init, arguments:['this']  ""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
AuthorisedModule(_modules[i],true)

IRs:
REF_60(address) -> _modules[i]
Emit AuthorisedModule(REF_60,True)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
i ++

IRs:
TMP_144(uint256) := i(uint256)
i(uint256) = i + 1""];
13->8;
}
",1,0,0,0,"require(bool,string)(owner == address(0) && modules == 0,BW: wallet already initialised);require(bool,string)(_modules.length > 0,BW: construction requires at least 1 module);owner = _owner;modules = _modules.length;i = 0;;i < _modules.length;;require(bool,string)(authorised[_modules[i]] == false,BW: module is already added);authorised[_modules[i]] = true;Module(_modules[i]).init(this);AuthorisedModule(_modules[i],true);i ++"
./0x25cf23787ac0f92a3eafa61f458ad0b7c4b27c3d_ext.sol,Zethroll.ownerSetBankroll,384,390,"TMP_92(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:approve, arguments:['ZethrBankroll', '0']  ,ZethrBankroll(address) := newBankroll(address),TMP_93(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:approve, arguments:['newBankroll', 'MAX_INT']  ,MODIFIER_CALL, Zethroll.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ZTHTKN.approve(ZethrBankroll,0)

IRs:
TMP_92(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:approve, arguments:['ZethrBankroll', '0']  ""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ZethrBankroll = newBankroll

IRs:
ZethrBankroll(address) := newBankroll(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ZTHTKN.approve(newBankroll,MAX_INT)

IRs:
TMP_93(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:approve, arguments:['newBankroll', 'MAX_INT']  ""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Zethroll.onlyOwner()()""];
4->1;
}
",1,0,0,0,"onlyOwner();ZTHTKN.approve(ZethrBankroll,0);ZethrBankroll = newBankroll;ZTHTKN.approve(newBankroll,MAX_INT)"
./0x0002325fcaaac6ebf1254a626589147bde1a2394_ext.sol,HorseyToken.renameHorsey,752,766,"TMP_229 = CONVERT newName to bytes,REF_73 -> LENGTH TMP_229,TMP_230(uint256) = renamingCostsPerChar * REF_73,renamingFee(uint256) := TMP_230(uint256),TMP_231(bool) = msg.value > renamingFee,CONDITION TMP_231,TMP_232(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.value', 'renamingFee'] ,Transfer dest:msg.sender value:TMP_232,HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:storeName, arguments:['tokenId', 'newName']  ,Emit HorseyRenamed(tokenId,newName),MODIFIER_CALL, Pausable.whenNotPaused()(),MODIFIER_CALL, HorseyToken.onlyOwnerOf(uint256)(tokenId),TMP_238 = CONVERT newName to bytes,REF_77 -> LENGTH TMP_238,TMP_239(uint256) = renamingCostsPerChar * REF_77,MODIFIER_CALL, HorseyToken.costs(uint256)(TMP_239)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
renamingFee = renamingCostsPerChar * bytes(newName).length

IRs:
TMP_229 = CONVERT newName to bytes
REF_73 -> LENGTH TMP_229
TMP_230(uint256) = renamingCostsPerChar * REF_73
renamingFee(uint256) := TMP_230(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
msg.value > renamingFee

IRs:
TMP_231(bool) = msg.value > renamingFee
CONDITION TMP_231""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(msg.value.sub(renamingFee))

IRs:
TMP_232(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.value', 'renamingFee'] 
Transfer dest:msg.sender value:TMP_232""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
stables.storeName(tokenId,newName)

IRs:
HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:storeName, arguments:['tokenId', 'newName']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
HorseyRenamed(tokenId,newName)

IRs:
Emit HorseyRenamed(tokenId,newName)""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwnerOf(tokenId)

IRs:
MODIFIER_CALL, HorseyToken.onlyOwnerOf(uint256)(tokenId)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
costs(renamingCostsPerChar * bytes(newName).length)

IRs:
TMP_238 = CONVERT newName to bytes
REF_77 -> LENGTH TMP_238
TMP_239(uint256) = renamingCostsPerChar * REF_77
MODIFIER_CALL, HorseyToken.costs(uint256)(TMP_239)""];
9->1;
}
",1,0,0,0,"whenNotPaused();renamingFee = renamingCostsPerChar * bytes(newName).length;msg.value > renamingFee;msg.sender.transfer(msg.value.sub(renamingFee));;stables.storeName(tokenId,newName);HorseyRenamed(tokenId,newName);onlyOwnerOf(tokenId);costs(renamingCostsPerChar * bytes(newName).length)"
./0x517c8bbb18d69d7d8f059175f612d556670b22c3_ext.sol,AirDropAFTKSeven.sendTokensTo7,98,130,"TMP_29(uint256) = 10 ** 18,TMP_30(uint256) = quantity * TMP_29,Emit TokenSendStart(dests1,TMP_30),TMP_32(uint256) = 10 ** 18,TMP_33(uint256) = quantity * TMP_32,TMP_34(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:approve, arguments:['dests1', 'TMP_33']  ,TMP_35(uint256) = 10 ** 18,TMP_36(uint256) = quantity * TMP_35,TMP_37(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transferFrom, arguments:['owner', 'dests1', 'TMP_36']  ,TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37),TMP_39(uint256) = 10 ** 18,TMP_40(uint256) = quantity * TMP_39,Emit TokenSendStart(dests2,TMP_40),TMP_42(uint256) = 10 ** 18,TMP_43(uint256) = quantity * TMP_42,TMP_44(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:approve, arguments:['dests2', 'TMP_43']  ,TMP_45(uint256) = 10 ** 18,TMP_46(uint256) = quantity * TMP_45,TMP_47(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transferFrom, arguments:['owner', 'dests2', 'TMP_46']  ,TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47),TMP_49(uint256) = 10 ** 18,TMP_50(uint256) = quantity * TMP_49,Emit TokenSendStart(dests3,TMP_50),TMP_52(uint256) = 10 ** 18,TMP_53(uint256) = quantity * TMP_52,TMP_54(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:approve, arguments:['dests3', 'TMP_53']  ,TMP_55(uint256) = 10 ** 18,TMP_56(uint256) = quantity * TMP_55,TMP_57(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transferFrom, arguments:['owner', 'dests3', 'TMP_56']  ,TMP_58(None) = SOLIDITY_CALL require(bool)(TMP_57),TMP_59(uint256) = 10 ** 18,TMP_60(uint256) = quantity * TMP_59,Emit TokenSendStart(dests4,TMP_60),TMP_62(uint256) = 10 ** 18,TMP_63(uint256) = quantity * TMP_62,TMP_64(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:approve, arguments:['dests4', 'TMP_63']  ,TMP_65(uint256) = 10 ** 18,TMP_66(uint256) = quantity * TMP_65,TMP_67(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transferFrom, arguments:['owner', 'dests4', 'TMP_66']  ,TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67),TMP_69(uint256) = 10 ** 18,TMP_70(uint256) = quantity * TMP_69,Emit TokenSendStart(dests5,TMP_70),TMP_72(uint256) = 10 ** 18,TMP_73(uint256) = quantity * TMP_72,TMP_74(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:approve, arguments:['dests5', 'TMP_73']  ,TMP_75(uint256) = 10 ** 18,TMP_76(uint256) = quantity * TMP_75,TMP_77(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transferFrom, arguments:['owner', 'dests5', 'TMP_76']  ,TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77),TMP_79(uint256) = 10 ** 18,TMP_80(uint256) = quantity * TMP_79,Emit TokenSendStart(dests6,TMP_80),TMP_82(uint256) = 10 ** 18,TMP_83(uint256) = quantity * TMP_82,TMP_84(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:approve, arguments:['dests6', 'TMP_83']  ,TMP_85(uint256) = 10 ** 18,TMP_86(uint256) = quantity * TMP_85,TMP_87(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transferFrom, arguments:['owner', 'dests6', 'TMP_86']  ,TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87),TMP_89(uint256) = 10 ** 18,TMP_90(uint256) = quantity * TMP_89,Emit TokenSendStart(dests7,TMP_90),TMP_92(uint256) = 10 ** 18,TMP_93(uint256) = quantity * TMP_92,TMP_94(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:approve, arguments:['dests7', 'TMP_93']  ,TMP_95(uint256) = 10 ** 18,TMP_96(uint256) = quantity * TMP_95,TMP_97(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transferFrom, arguments:['owner', 'dests7', 'TMP_96']  ,TMP_98(None) = SOLIDITY_CALL require(bool)(TMP_97),TMP_99(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:balanceOf, arguments:['dests7']  ,RETURN TMP_99,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->23;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
TokenSendStart(dests1,quantity * 10 ** 18)

IRs:
TMP_29(uint256) = 10 ** 18
TMP_30(uint256) = quantity * TMP_29
Emit TokenSendStart(dests1,TMP_30)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
token.approve(dests1,quantity * 10 ** 18)

IRs:
TMP_32(uint256) = 10 ** 18
TMP_33(uint256) = quantity * TMP_32
TMP_34(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:approve, arguments:['dests1', 'TMP_33']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(token.transferFrom(owner,dests1,quantity * 10 ** 18))

IRs:
TMP_35(uint256) = 10 ** 18
TMP_36(uint256) = quantity * TMP_35
TMP_37(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transferFrom, arguments:['owner', 'dests1', 'TMP_36']  
TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
TokenSendStart(dests2,quantity * 10 ** 18)

IRs:
TMP_39(uint256) = 10 ** 18
TMP_40(uint256) = quantity * TMP_39
Emit TokenSendStart(dests2,TMP_40)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
token.approve(dests2,quantity * 10 ** 18)

IRs:
TMP_42(uint256) = 10 ** 18
TMP_43(uint256) = quantity * TMP_42
TMP_44(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:approve, arguments:['dests2', 'TMP_43']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(token.transferFrom(owner,dests2,quantity * 10 ** 18))

IRs:
TMP_45(uint256) = 10 ** 18
TMP_46(uint256) = quantity * TMP_45
TMP_47(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transferFrom, arguments:['owner', 'dests2', 'TMP_46']  
TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
TokenSendStart(dests3,quantity * 10 ** 18)

IRs:
TMP_49(uint256) = 10 ** 18
TMP_50(uint256) = quantity * TMP_49
Emit TokenSendStart(dests3,TMP_50)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
token.approve(dests3,quantity * 10 ** 18)

IRs:
TMP_52(uint256) = 10 ** 18
TMP_53(uint256) = quantity * TMP_52
TMP_54(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:approve, arguments:['dests3', 'TMP_53']  ""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(token.transferFrom(owner,dests3,quantity * 10 ** 18))

IRs:
TMP_55(uint256) = 10 ** 18
TMP_56(uint256) = quantity * TMP_55
TMP_57(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transferFrom, arguments:['owner', 'dests3', 'TMP_56']  
TMP_58(None) = SOLIDITY_CALL require(bool)(TMP_57)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
TokenSendStart(dests4,quantity * 10 ** 18)

IRs:
TMP_59(uint256) = 10 ** 18
TMP_60(uint256) = quantity * TMP_59
Emit TokenSendStart(dests4,TMP_60)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
token.approve(dests4,quantity * 10 ** 18)

IRs:
TMP_62(uint256) = 10 ** 18
TMP_63(uint256) = quantity * TMP_62
TMP_64(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:approve, arguments:['dests4', 'TMP_63']  ""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
require(bool)(token.transferFrom(owner,dests4,quantity * 10 ** 18))

IRs:
TMP_65(uint256) = 10 ** 18
TMP_66(uint256) = quantity * TMP_65
TMP_67(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transferFrom, arguments:['owner', 'dests4', 'TMP_66']  
TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
TokenSendStart(dests5,quantity * 10 ** 18)

IRs:
TMP_69(uint256) = 10 ** 18
TMP_70(uint256) = quantity * TMP_69
Emit TokenSendStart(dests5,TMP_70)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
token.approve(dests5,quantity * 10 ** 18)

IRs:
TMP_72(uint256) = 10 ** 18
TMP_73(uint256) = quantity * TMP_72
TMP_74(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:approve, arguments:['dests5', 'TMP_73']  ""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
require(bool)(token.transferFrom(owner,dests5,quantity * 10 ** 18))

IRs:
TMP_75(uint256) = 10 ** 18
TMP_76(uint256) = quantity * TMP_75
TMP_77(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transferFrom, arguments:['owner', 'dests5', 'TMP_76']  
TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
TokenSendStart(dests6,quantity * 10 ** 18)

IRs:
TMP_79(uint256) = 10 ** 18
TMP_80(uint256) = quantity * TMP_79
Emit TokenSendStart(dests6,TMP_80)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
token.approve(dests6,quantity * 10 ** 18)

IRs:
TMP_82(uint256) = 10 ** 18
TMP_83(uint256) = quantity * TMP_82
TMP_84(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:approve, arguments:['dests6', 'TMP_83']  ""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
require(bool)(token.transferFrom(owner,dests6,quantity * 10 ** 18))

IRs:
TMP_85(uint256) = 10 ** 18
TMP_86(uint256) = quantity * TMP_85
TMP_87(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transferFrom, arguments:['owner', 'dests6', 'TMP_86']  
TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
TokenSendStart(dests7,quantity * 10 ** 18)

IRs:
TMP_89(uint256) = 10 ** 18
TMP_90(uint256) = quantity * TMP_89
Emit TokenSendStart(dests7,TMP_90)""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
token.approve(dests7,quantity * 10 ** 18)

IRs:
TMP_92(uint256) = 10 ** 18
TMP_93(uint256) = quantity * TMP_92
TMP_94(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:approve, arguments:['dests7', 'TMP_93']  ""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
require(bool)(token.transferFrom(owner,dests7,quantity * 10 ** 18))

IRs:
TMP_95(uint256) = 10 ** 18
TMP_96(uint256) = quantity * TMP_95
TMP_97(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transferFrom, arguments:['owner', 'dests7', 'TMP_96']  
TMP_98(None) = SOLIDITY_CALL require(bool)(TMP_97)""];
21->22;
22[label=""Node Type: RETURN 22

EXPRESSION:
token.balanceOf(dests7)

IRs:
TMP_99(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:balanceOf, arguments:['dests7']  
RETURN TMP_99""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
23->1;
}
",1,0,0,0,"onlyOwner();TokenSendStart(dests1,quantity * 10 ** 18);token.approve(dests1,quantity * 10 ** 18);require(bool)(token.transferFrom(owner,dests1,quantity * 10 ** 18));TokenSendStart(dests2,quantity * 10 ** 18);token.approve(dests2,quantity * 10 ** 18);require(bool)(token.transferFrom(owner,dests2,quantity * 10 ** 18));TokenSendStart(dests3,quantity * 10 ** 18);token.approve(dests3,quantity * 10 ** 18);require(bool)(token.transferFrom(owner,dests3,quantity * 10 ** 18));TokenSendStart(dests4,quantity * 10 ** 18);token.approve(dests4,quantity * 10 ** 18);require(bool)(token.transferFrom(owner,dests4,quantity * 10 ** 18));TokenSendStart(dests5,quantity * 10 ** 18);token.approve(dests5,quantity * 10 ** 18);require(bool)(token.transferFrom(owner,dests5,quantity * 10 ** 18));TokenSendStart(dests6,quantity * 10 ** 18);token.approve(dests6,quantity * 10 ** 18);require(bool)(token.transferFrom(owner,dests6,quantity * 10 ** 18));TokenSendStart(dests7,quantity * 10 ** 18);token.approve(dests7,quantity * 10 ** 18);require(bool)(token.transferFrom(owner,dests7,quantity * 10 ** 18));token.balanceOf(dests7)"
./0xc849a5fff9befa297d1c3a772bafac9f3c9004ec_ext.sol,Bounty0xEscrow.distributeTokenToAddress,202,212,"TMP_76 = CONVERT 0 to address,TMP_77(bool) = _hunter != TMP_76,TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77),REF_22(mapping(address => uint256)) -> tokens[_token],REF_23(uint256) -> REF_22[_host],TMP_79(bool) = REF_23 >= _amount,TMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79),REF_24(mapping(address => uint256)) -> tokens[_token],REF_25(uint256) -> REF_24[_host],REF_27(mapping(address => uint256)) -> tokens[_token],REF_28(uint256) -> REF_27[_host],TMP_81(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_amount'] ,REF_25(uint256) (->tokens) := TMP_81(uint256),TMP_82 = CONVERT 0 to address,TMP_83(bool) = _token == TMP_82,CONDITION TMP_83,TMP_84 = SEND dest:_hunter value:_amount,TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84),TMP_86 = CONVERT _token to ERC20,HIGH_LEVEL_CALL, dest:TMP_86(ERC20), function:transfer, arguments:['_hunter', '_amount']  ,Emit Distribution(_token,_host,_hunter,_amount),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_hunter != address(0))

IRs:
TMP_76 = CONVERT 0 to address
TMP_77(bool) = _hunter != TMP_76
TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(tokens[_token][_host] >= _amount)

IRs:
REF_22(mapping(address => uint256)) -> tokens[_token]
REF_23(uint256) -> REF_22[_host]
TMP_79(bool) = REF_23 >= _amount
TMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tokens[_token][_host] = SafeMath.sub(tokens[_token][_host],_amount)

IRs:
REF_24(mapping(address => uint256)) -> tokens[_token]
REF_25(uint256) -> REF_24[_host]
REF_27(mapping(address => uint256)) -> tokens[_token]
REF_28(uint256) -> REF_27[_host]
TMP_81(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_amount'] 
REF_25(uint256) (->tokens) := TMP_81(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
_token == address(0)

IRs:
TMP_82 = CONVERT 0 to address
TMP_83(bool) = _token == TMP_82
CONDITION TMP_83""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(_hunter.send(_amount))

IRs:
TMP_84 = SEND dest:_hunter value:_amount
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)""];
5->7;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
ERC20(_token).transfer(_hunter,_amount)

IRs:
TMP_86 = CONVERT _token to ERC20
HIGH_LEVEL_CALL, dest:TMP_86(ERC20), function:transfer, arguments:['_hunter', '_amount']  ""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Distribution(_token,_host,_hunter,_amount)

IRs:
Emit Distribution(_token,_host,_hunter,_amount)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
9->1;
}
",1,0,1,0,"onlyOwner();require(bool)(_hunter != address(0));require(bool)(tokens[_token][_host] >= _amount);tokens[_token][_host] = SafeMath.sub(tokens[_token][_host],_amount);_token == address(0);require(bool)(_hunter.send(_amount));ERC20(_token).transfer(_hunter,_amount);;Distribution(_token,_host,_hunter,_amount)"
./0x4176f0f2b7c95486a5ae06e3d1b29201a42e7630_ext.sol,Bounty0xEscrow.depositToken,249,257,"TMP_61 = CONVERT 0 to address,TMP_62(bool) = _token != TMP_61,TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62),TMP_64 = CONVERT _token to ERC20,HIGH_LEVEL_CALL, dest:TMP_64(ERC20), function:transferFrom, arguments:['msg.sender', 'this', '_amount']  ,REF_8(mapping(address => uint256)) -> tokens[_token],REF_9(uint256) -> REF_8[msg.sender],REF_11(mapping(address => uint256)) -> tokens[_token],REF_12(uint256) -> REF_11[msg.sender],TMP_66(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_12', '_amount'] ,REF_9(uint256) (->tokens) := TMP_66(uint256),REF_13(mapping(address => uint256)) -> tokens[_token],REF_14(uint256) -> REF_13[msg.sender],Emit Deposit(_token,msg.sender,_amount,REF_14),MODIFIER_CALL, Pausable.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_token != address(0))

IRs:
TMP_61 = CONVERT 0 to address
TMP_62(bool) = _token != TMP_61
TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ERC20(_token).transferFrom(msg.sender,this,_amount)

IRs:
TMP_64 = CONVERT _token to ERC20
HIGH_LEVEL_CALL, dest:TMP_64(ERC20), function:transferFrom, arguments:['msg.sender', 'this', '_amount']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tokens[_token][msg.sender] = SafeMath.add(tokens[_token][msg.sender],_amount)

IRs:
REF_8(mapping(address => uint256)) -> tokens[_token]
REF_9(uint256) -> REF_8[msg.sender]
REF_11(mapping(address => uint256)) -> tokens[_token]
REF_12(uint256) -> REF_11[msg.sender]
TMP_66(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_12', '_amount'] 
REF_9(uint256) (->tokens) := TMP_66(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Deposit(_token,msg.sender,_amount,tokens[_token][msg.sender])

IRs:
REF_13(mapping(address => uint256)) -> tokens[_token]
REF_14(uint256) -> REF_13[msg.sender]
Emit Deposit(_token,msg.sender,_amount,REF_14)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
5->1;
}
",1,0,0,0,"whenNotPaused();require(bool)(_token != address(0));ERC20(_token).transferFrom(msg.sender,this,_amount);tokens[_token][msg.sender] = SafeMath.add(tokens[_token][msg.sender],_amount);Deposit(_token,msg.sender,_amount,tokens[_token][msg.sender])"
./0x27c48b2f1d99cab6f6f6ae143204a0029666e29b_ext.sol,CardAuction.setSaleAuction,438,442,"TMP_302 = CONVERT _address to ClockAuctionBase,candidateContract(ClockAuctionBase) := TMP_302(ClockAuctionBase),TMP_303(bool) = HIGH_LEVEL_CALL, dest:candidateContract(ClockAuctionBase), function:isSaleAuction, arguments:[]  ,TMP_304(None) = SOLIDITY_CALL require(bool)(TMP_303),saleAuction(ClockAuctionBase) := candidateContract(ClockAuctionBase),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
candidateContract = ClockAuctionBase(_address)

IRs:
TMP_302 = CONVERT _address to ClockAuctionBase
candidateContract(ClockAuctionBase) := TMP_302(ClockAuctionBase)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(candidateContract.isSaleAuction())

IRs:
TMP_303(bool) = HIGH_LEVEL_CALL, dest:candidateContract(ClockAuctionBase), function:isSaleAuction, arguments:[]  
TMP_304(None) = SOLIDITY_CALL require(bool)(TMP_303)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
saleAuction = candidateContract

IRs:
saleAuction(ClockAuctionBase) := candidateContract(ClockAuctionBase)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->1;
}
",1,0,0,0,onlyOwner();candidateContract = ClockAuctionBase(_address);require(bool)(candidateContract.isSaleAuction());saleAuction = candidateContract
./0x190646e10b85fbcd631c23c8cd175e25df92c338_ext.sol,EthBattle.depositGTA,285,289,"TMP_100(bool) = HIGH_LEVEL_CALL, dest:token(GTAInterface), function:transferFrom, arguments:['msg.sender', 'this', '_amount']  ,TMP_101(None) = SOLIDITY_CALL require(bool,string)(TMP_100,Insufficient funds),REF_30(uint256) -> tokens[msg.sender],REF_31(uint256) -> tokens[msg.sender],TMP_102(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_31', '_amount'] ,REF_30(uint256) (->tokens) := TMP_102(uint256),REF_33(uint256) -> tokens[msg.sender],Emit Deposit(msg.sender,_amount,REF_33)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(token.transferFrom(msg.sender,this,_amount),Insufficient funds)

IRs:
TMP_100(bool) = HIGH_LEVEL_CALL, dest:token(GTAInterface), function:transferFrom, arguments:['msg.sender', 'this', '_amount']  
TMP_101(None) = SOLIDITY_CALL require(bool,string)(TMP_100,Insufficient funds)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
tokens[msg.sender] = tokens[msg.sender].add(_amount)

IRs:
REF_30(uint256) -> tokens[msg.sender]
REF_31(uint256) -> tokens[msg.sender]
TMP_102(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_31', '_amount'] 
REF_30(uint256) (->tokens) := TMP_102(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Deposit(msg.sender,_amount,tokens[msg.sender])

IRs:
REF_33(uint256) -> tokens[msg.sender]
Emit Deposit(msg.sender,_amount,REF_33)""];
}
",1,0,0,0,"require(bool,string)(token.transferFrom(msg.sender,this,_amount),Insufficient funds);tokens[msg.sender] = tokens[msg.sender].add(_amount);Deposit(msg.sender,_amount,tokens[msg.sender])"
./0xa5cc679a3528956e8032df4f03756c077c1ee3f4_ext.sol,Exchange.adminWithdraw,231,251,"TMP_91(bytes32) = SOLIDITY_CALL keccak256()(this,token,amount,user,nonce),hash(bytes32) := TMP_91(bytes32),REF_43(bool) -> withdrawn[hash],CONDITION REF_43,REF_44(bool) -> withdrawn[hash],REF_44(bool) (->withdrawn) := True(bool),TMP_92(bytes32) = SOLIDITY_CALL keccak256()(Ethereum Signed Message:
32,hash),TMP_93(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(TMP_92,v,r,s),TMP_94(bool) = TMP_93 != user,CONDITION TMP_94,TMP_95(bool) = feeWithdrawal > 50000000000000000,CONDITION TMP_95,feeWithdrawal(uint256) := 50000000000000000(uint256),REF_45(mapping(address => uint256)) -> tokens[token],REF_46(uint256) -> REF_45[user],TMP_96(bool) = REF_46 < amount,CONDITION TMP_96,REF_47(mapping(address => uint256)) -> tokens[token],REF_48(uint256) -> REF_47[user],REF_49(mapping(address => uint256)) -> tokens[token],REF_50(uint256) -> REF_49[user],TMP_97(uint256) = INTERNAL_CALL, Exchange.safeSub(uint256,uint256)(REF_50,amount),REF_48(uint256) (->tokens) := TMP_97(uint256),TMP_98 = CONVERT 0 to address,REF_51(mapping(address => uint256)) -> tokens[TMP_98],REF_52(uint256) -> REF_51[user],TMP_99 = CONVERT 0 to address,REF_53(mapping(address => uint256)) -> tokens[TMP_99],REF_54(uint256) -> REF_53[user],TMP_100(uint256) = INTERNAL_CALL, Exchange.safeSub(uint256,uint256)(REF_54,feeWithdrawal),REF_52(uint256) (->tokens) := TMP_100(uint256),TMP_101 = CONVERT 0 to address,REF_55(mapping(address => uint256)) -> tokens[TMP_101],REF_56(uint256) -> REF_55[feeAccount],TMP_102 = CONVERT 0 to address,REF_57(mapping(address => uint256)) -> tokens[TMP_102],REF_58(uint256) -> REF_57[feeAccount],TMP_103(uint256) = INTERNAL_CALL, Exchange.safeAdd(uint256,uint256)(REF_58,feeWithdrawal),REF_56(uint256) (->tokens) := TMP_103(uint256),TMP_104 = CONVERT 0 to address,TMP_105(bool) = token == TMP_104,CONDITION TMP_105,TMP_106 = SEND dest:user value:amount,TMP_107 = UnaryType.BANG TMP_106 ,CONDITION TMP_107,TMP_108 = CONVERT token to Token,TMP_109(bool) = HIGH_LEVEL_CALL, dest:TMP_108(Token), function:transfer, arguments:['user', 'amount']  ,TMP_110 = UnaryType.BANG TMP_109 ,CONDITION TMP_110,REF_61(uint256) -> lastActiveTransaction[user],REF_61(uint256) (->lastActiveTransaction) := block.number(uint256),REF_62(mapping(address => uint256)) -> tokens[token],REF_63(uint256) -> REF_62[user],Emit Withdraw(token,user,amount,REF_63,feeWithdrawal),MODIFIER_CALL, Exchange.onlyAdmin()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->28;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
hash = keccak256()(this,token,amount,user,nonce)

IRs:
TMP_91(bytes32) = SOLIDITY_CALL keccak256()(this,token,amount,user,nonce)
hash(bytes32) := TMP_91(bytes32)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
withdrawn[hash]

IRs:
REF_43(bool) -> withdrawn[hash]
CONDITION REF_43""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: THROW 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
withdrawn[hash] = true

IRs:
REF_44(bool) -> withdrawn[hash]
REF_44(bool) (->withdrawn) := True(bool)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
ecrecover(bytes32,uint8,bytes32,bytes32)(keccak256()(Ethereum Signed Message:
32,hash),v,r,s) != user

IRs:
TMP_92(bytes32) = SOLIDITY_CALL keccak256()(Ethereum Signed Message:
32,hash)
TMP_93(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(TMP_92,v,r,s)
TMP_94(bool) = TMP_93 != user
CONDITION TMP_94""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: THROW 7
""];
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
feeWithdrawal > 50000000000000000

IRs:
TMP_95(bool) = feeWithdrawal > 50000000000000000
CONDITION TMP_95""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
feeWithdrawal = 50000000000000000

IRs:
feeWithdrawal(uint256) := 50000000000000000(uint256)""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
tokens[token][user] < amount

IRs:
REF_45(mapping(address => uint256)) -> tokens[token]
REF_46(uint256) -> REF_45[user]
TMP_96(bool) = REF_46 < amount
CONDITION TMP_96""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: THROW 13
""];
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
tokens[token][user] = safeSub(tokens[token][user],amount)

IRs:
REF_47(mapping(address => uint256)) -> tokens[token]
REF_48(uint256) -> REF_47[user]
REF_49(mapping(address => uint256)) -> tokens[token]
REF_50(uint256) -> REF_49[user]
TMP_97(uint256) = INTERNAL_CALL, Exchange.safeSub(uint256,uint256)(REF_50,amount)
REF_48(uint256) (->tokens) := TMP_97(uint256)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
tokens[address(0)][user] = safeSub(tokens[address(0x0)][user],feeWithdrawal)

IRs:
TMP_98 = CONVERT 0 to address
REF_51(mapping(address => uint256)) -> tokens[TMP_98]
REF_52(uint256) -> REF_51[user]
TMP_99 = CONVERT 0 to address
REF_53(mapping(address => uint256)) -> tokens[TMP_99]
REF_54(uint256) -> REF_53[user]
TMP_100(uint256) = INTERNAL_CALL, Exchange.safeSub(uint256,uint256)(REF_54,feeWithdrawal)
REF_52(uint256) (->tokens) := TMP_100(uint256)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
tokens[address(0)][feeAccount] = safeAdd(tokens[address(0)][feeAccount],feeWithdrawal)

IRs:
TMP_101 = CONVERT 0 to address
REF_55(mapping(address => uint256)) -> tokens[TMP_101]
REF_56(uint256) -> REF_55[feeAccount]
TMP_102 = CONVERT 0 to address
REF_57(mapping(address => uint256)) -> tokens[TMP_102]
REF_58(uint256) -> REF_57[feeAccount]
TMP_103(uint256) = INTERNAL_CALL, Exchange.safeAdd(uint256,uint256)(REF_58,feeWithdrawal)
REF_56(uint256) (->tokens) := TMP_103(uint256)""];
17->18;
18[label=""Node Type: IF 18

EXPRESSION:
token == address(0)

IRs:
TMP_104 = CONVERT 0 to address
TMP_105(bool) = token == TMP_104
CONDITION TMP_105""];
18->19[label=""True""];
18->22[label=""False""];
19[label=""Node Type: IF 19

EXPRESSION:
! user.send(amount)

IRs:
TMP_106 = SEND dest:user value:amount
TMP_107 = UnaryType.BANG TMP_106 
CONDITION TMP_107""];
19->20[label=""True""];
19->21[label=""False""];
20[label=""Node Type: THROW 20
""];
21[label=""Node Type: END_IF 21
""];
21->25;
22[label=""Node Type: IF 22

EXPRESSION:
! Token(token).transfer(user,amount)

IRs:
TMP_108 = CONVERT token to Token
TMP_109(bool) = HIGH_LEVEL_CALL, dest:TMP_108(Token), function:transfer, arguments:['user', 'amount']  
TMP_110 = UnaryType.BANG TMP_109 
CONDITION TMP_110""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: THROW 23
""];
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->26;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
lastActiveTransaction[user] = block.number

IRs:
REF_61(uint256) -> lastActiveTransaction[user]
REF_61(uint256) (->lastActiveTransaction) := block.number(uint256)""];
26->27;
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
Withdraw(token,user,amount,tokens[token][user],feeWithdrawal)

IRs:
REF_62(mapping(address => uint256)) -> tokens[token]
REF_63(uint256) -> REF_62[user]
Emit Withdraw(token,user,amount,REF_63,feeWithdrawal)""];
27->29;
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Exchange.onlyAdmin()()""];
28->1;
29[label=""Node Type: RETURN 29

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,0,0,0,"onlyAdmin();hash = keccak256()(this,token,amount,user,nonce);withdrawn[hash];;;withdrawn[hash] = true;;;;feeWithdrawal > 50000000000000000;feeWithdrawal = 50000000000000000;;tokens[token][user] < amount;;;tokens[token][user] = safeSub(tokens[token][user],amount);tokens[address(0)][user] = safeSub(tokens[address(0x0)][user],feeWithdrawal);tokens[address(0)][feeAccount] = safeAdd(tokens[address(0)][feeAccount],feeWithdrawal);token == address(0);! user.send(amount);! Token(token).transfer(user,amount);;;;;;lastActiveTransaction[user] = block.number;Withdraw(token,user,amount,tokens[token][user],feeWithdrawal);success"
./0x56ce81f0ede8716a2f3b6349f805e0f13643c168_ext.sol,TokenVesting.fundVesting,201,207,"TMP_33(bool) = totalTokens == 0,TMP_34(None) = SOLIDITY_CALL require(bool,string)(TMP_33,Vesting already funded),TMP_35 = CONVERT this to address,TMP_36(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:allowance, arguments:['owner', 'TMP_35']  ,TMP_37(bool) = TMP_36 == _totalTokens,TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37),totalTokens(uint256) := _totalTokens(uint256),TMP_39 = CONVERT this to address,TMP_40(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transferFrom, arguments:['owner', 'TMP_39', 'totalTokens']  ,Emit VestingFunded(_totalTokens),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(totalTokens == 0,Vesting already funded)

IRs:
TMP_33(bool) = totalTokens == 0
TMP_34(None) = SOLIDITY_CALL require(bool,string)(TMP_33,Vesting already funded)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(token.allowance(owner,address(this)) == _totalTokens)

IRs:
TMP_35 = CONVERT this to address
TMP_36(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:allowance, arguments:['owner', 'TMP_35']  
TMP_37(bool) = TMP_36 == _totalTokens
TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalTokens = _totalTokens

IRs:
totalTokens(uint256) := _totalTokens(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transferFrom(owner,address(this),totalTokens)

IRs:
TMP_39 = CONVERT this to address
TMP_40(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transferFrom, arguments:['owner', 'TMP_39', 'totalTokens']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
VestingFunded(_totalTokens)

IRs:
Emit VestingFunded(_totalTokens)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",1,0,0,0,"onlyOwner();require(bool,string)(totalTokens == 0,Vesting already funded);require(bool)(token.allowance(owner,address(this)) == _totalTokens);totalTokens = _totalTokens;token.transferFrom(owner,address(this),totalTokens);VestingFunded(_totalTokens)"
./0x0e6e19549a89c9bec84b5b632cd1674f8e066d06_ext.sol,EtheremonAdventureItem.useMultipleItem,533,548,"TMP_501(bool) = _token1 > 0,REF_298(address) -> idToOwner[_token1],TMP_502(bool) = REF_298 != msg.sender,TMP_503(bool) = TMP_501 && TMP_502,CONDITION TMP_503,TMP_504(None) = SOLIDITY_CALL revert()(),TMP_505(bool) = _token2 > 0,REF_299(address) -> idToOwner[_token2],TMP_506(bool) = REF_299 != msg.sender,TMP_507(bool) = TMP_505 && TMP_506,CONDITION TMP_507,TMP_508(None) = SOLIDITY_CALL revert()(),TMP_509(bool) = _token3 > 0,REF_300(address) -> idToOwner[_token3],TMP_510(bool) = REF_300 != msg.sender,TMP_511(bool) = TMP_509 && TMP_510,CONDITION TMP_511,TMP_512(None) = SOLIDITY_CALL revert()(),REF_301(EtheremonAdventureItem.Item) -> items[_token1],item1(EtheremonAdventureItem.Item) := REF_301(EtheremonAdventureItem.Item),REF_302(EtheremonAdventureItem.Item) -> items[_token2],item2(EtheremonAdventureItem.Item) := REF_302(EtheremonAdventureItem.Item),REF_303(EtheremonAdventureItem.Item) -> items[_token3],item3(EtheremonAdventureItem.Item) := REF_303(EtheremonAdventureItem.Item),TMP_513 = CONVERT adventureHandler to EtheremonAdventureHandler,handler(EtheremonAdventureHandler) := TMP_513(EtheremonAdventureHandler),REF_305(uint256) -> item1.classId,REF_306(uint256) -> item2.classId,REF_307(uint256) -> item3.classId,HIGH_LEVEL_CALL, dest:handler(EtheremonAdventureHandler), function:handleMultipleItems, arguments:['msg.sender', 'REF_305', 'REF_306', 'REF_307', '_target', '_param']  ,TMP_515(bool) = _token1 > 0,CONDITION TMP_515,INTERNAL_CALL, NFTStandard._burn(address,uint256)(msg.sender,_token1),TMP_517(bool) = _token2 > 0,CONDITION TMP_517,INTERNAL_CALL, NFTStandard._burn(address,uint256)(msg.sender,_token2),TMP_519(bool) = _token3 > 0,CONDITION TMP_519,INTERNAL_CALL, NFTStandard._burn(address,uint256)(msg.sender,_token3),MODIFIER_CALL, BasicAccessControl.isActive()(),MODIFIER_CALL, EtheremonAdventureItem.requireAdventureHandler()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->24;
1[label=""Node Type: IF 1

EXPRESSION:
_token1 > 0 && idToOwner[_token1] != msg.sender

IRs:
TMP_501(bool) = _token1 > 0
REF_298(address) -> idToOwner[_token1]
TMP_502(bool) = REF_298 != msg.sender
TMP_503(bool) = TMP_501 && TMP_502
CONDITION TMP_503""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_504(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
_token2 > 0 && idToOwner[_token2] != msg.sender

IRs:
TMP_505(bool) = _token2 > 0
REF_299(address) -> idToOwner[_token2]
TMP_506(bool) = REF_299 != msg.sender
TMP_507(bool) = TMP_505 && TMP_506
CONDITION TMP_507""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
revert()()

IRs:
TMP_508(None) = SOLIDITY_CALL revert()()""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
_token3 > 0 && idToOwner[_token3] != msg.sender

IRs:
TMP_509(bool) = _token3 > 0
REF_300(address) -> idToOwner[_token3]
TMP_510(bool) = REF_300 != msg.sender
TMP_511(bool) = TMP_509 && TMP_510
CONDITION TMP_511""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
revert()()

IRs:
TMP_512(None) = SOLIDITY_CALL revert()()""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
item1 = items[_token1]

IRs:
REF_301(EtheremonAdventureItem.Item) -> items[_token1]
item1(EtheremonAdventureItem.Item) := REF_301(EtheremonAdventureItem.Item)""];
10->11;
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
item2 = items[_token2]

IRs:
REF_302(EtheremonAdventureItem.Item) -> items[_token2]
item2(EtheremonAdventureItem.Item) := REF_302(EtheremonAdventureItem.Item)""];
11->12;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
item3 = items[_token3]

IRs:
REF_303(EtheremonAdventureItem.Item) -> items[_token3]
item3(EtheremonAdventureItem.Item) := REF_303(EtheremonAdventureItem.Item)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
handler = EtheremonAdventureHandler(adventureHandler)

IRs:
TMP_513 = CONVERT adventureHandler to EtheremonAdventureHandler
handler(EtheremonAdventureHandler) := TMP_513(EtheremonAdventureHandler)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
handler.handleMultipleItems(msg.sender,item1.classId,item2.classId,item3.classId,_target,_param)

IRs:
REF_305(uint256) -> item1.classId
REF_306(uint256) -> item2.classId
REF_307(uint256) -> item3.classId
HIGH_LEVEL_CALL, dest:handler(EtheremonAdventureHandler), function:handleMultipleItems, arguments:['msg.sender', 'REF_305', 'REF_306', 'REF_307', '_target', '_param']  ""];
14->15;
15[label=""Node Type: IF 15

EXPRESSION:
_token1 > 0

IRs:
TMP_515(bool) = _token1 > 0
CONDITION TMP_515""];
15->16[label=""True""];
15->17[label=""False""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
_burn(msg.sender,_token1)

IRs:
INTERNAL_CALL, NFTStandard._burn(address,uint256)(msg.sender,_token1)""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: IF 18

EXPRESSION:
_token2 > 0

IRs:
TMP_517(bool) = _token2 > 0
CONDITION TMP_517""];
18->19[label=""True""];
18->20[label=""False""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
_burn(msg.sender,_token2)

IRs:
INTERNAL_CALL, NFTStandard._burn(address,uint256)(msg.sender,_token2)""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: IF 21

EXPRESSION:
_token3 > 0

IRs:
TMP_519(bool) = _token3 > 0
CONDITION TMP_519""];
21->22[label=""True""];
21->23[label=""False""];
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
_burn(msg.sender,_token3)

IRs:
INTERNAL_CALL, NFTStandard._burn(address,uint256)(msg.sender,_token3)""];
22->23;
23[label=""Node Type: END_IF 23
""];
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
isActive()

IRs:
MODIFIER_CALL, BasicAccessControl.isActive()()""];
24->25;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
requireAdventureHandler()

IRs:
MODIFIER_CALL, EtheremonAdventureItem.requireAdventureHandler()()""];
25->1;
}
",1,0,0,0,"isActive();_token1 > 0 && idToOwner[_token1] != msg.sender;revert()();;_token2 > 0 && idToOwner[_token2] != msg.sender;revert()();;_token3 > 0 && idToOwner[_token3] != msg.sender;revert()();;item1 = items[_token1];item2 = items[_token2];item3 = items[_token3];handler = EtheremonAdventureHandler(adventureHandler);handler.handleMultipleItems(msg.sender,item1.classId,item2.classId,item3.classId,_target,_param);_token1 > 0;_burn(msg.sender,_token1);;_token2 > 0;_burn(msg.sender,_token2);;_token3 > 0;_burn(msg.sender,_token3);;requireAdventureHandler()"
./0x0f1da17b33df90c078fd2fb4b9011a64af3c67a6_ext.sol,ERC20.transferFrom,89,89,"INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from,to,value),REF_3(mapping(address => uint256)) -> _allowed[from],REF_4(uint256) -> REF_3[msg.sender],TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_4', 'value'] ,INTERNAL_CALL, ERC20._approve(address,address,uint256)(from,msg.sender,TMP_16),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_transfer(from,to,value)

IRs:
INTERNAL_CALL, ERC20._transfer(address,address,uint256)(from,to,value)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_approve(from,msg.sender,_allowed[from][msg.sender].sub(value))

IRs:
REF_3(mapping(address => uint256)) -> _allowed[from]
REF_4(uint256) -> REF_3[msg.sender]
TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_4', 'value'] 
INTERNAL_CALL, ERC20._approve(address,address,uint256)(from,msg.sender,TMP_16)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,"_transfer(from,to,value);_approve(from,msg.sender,_allowed[from][msg.sender].sub(value));true"
./0xdcf67546f2253c9c90c2b55447e1efecebcf83d6_ext.sol,HorseyToken.feed,828,839,"REF_86(HorseyToken.FeedingData) -> pendingFeedings[msg.sender],TMP_237(HorseyToken.FeedingData) = new FeedingData(block.number,tokenId),REF_86(HorseyToken.FeedingData) (->pendingFeedings) := TMP_237(HorseyToken.FeedingData),TUPLE_8(address,bytes32,uint8,uint8) = HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:horseys, arguments:['tokenId']  ,feedingCounter(uint8)= UNPACK TUPLE_8 index: 2 ,TMP_238(uint32) = HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:carrot_credits, arguments:['msg.sender']  ,TMP_239 = CONVERT feedingCounter to uint32,TMP_240(uint32) = TMP_238 - TMP_239,HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:storeCarrotsCredit, arguments:['msg.sender', 'TMP_240']  ,Emit Feeding(tokenId),MODIFIER_CALL, Pausable.whenNotPaused()(),MODIFIER_CALL, HorseyToken.onlyOwnerOf(uint256)(tokenId),MODIFIER_CALL, HorseyToken.carrotsMeetLevel(uint256)(tokenId),MODIFIER_CALL, HorseyToken.noFeedingInProgress()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
pendingFeedings[msg.sender] = FeedingData(block.number,tokenId)

IRs:
REF_86(HorseyToken.FeedingData) -> pendingFeedings[msg.sender]
TMP_237(HorseyToken.FeedingData) = new FeedingData(block.number,tokenId)
REF_86(HorseyToken.FeedingData) (->pendingFeedings) := TMP_237(HorseyToken.FeedingData)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
(None,None,feedingCounter,None) = stables.horseys(tokenId)

IRs:
TUPLE_8(address,bytes32,uint8,uint8) = HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:horseys, arguments:['tokenId']  
feedingCounter(uint8)= UNPACK TUPLE_8 index: 2 ""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) - uint32(feedingCounter))

IRs:
TMP_238(uint32) = HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:carrot_credits, arguments:['msg.sender']  
TMP_239 = CONVERT feedingCounter to uint32
TMP_240(uint32) = TMP_238 - TMP_239
HIGH_LEVEL_CALL, dest:stables(RoyalStablesInterface), function:storeCarrotsCredit, arguments:['msg.sender', 'TMP_240']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Feeding(tokenId)

IRs:
Emit Feeding(tokenId)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwnerOf(tokenId)

IRs:
MODIFIER_CALL, HorseyToken.onlyOwnerOf(uint256)(tokenId)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
carrotsMeetLevel(tokenId)

IRs:
MODIFIER_CALL, HorseyToken.carrotsMeetLevel(uint256)(tokenId)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
noFeedingInProgress()

IRs:
MODIFIER_CALL, HorseyToken.noFeedingInProgress()()""];
9->1;
}
",1,0,0,0,"whenNotPaused();pendingFeedings[msg.sender] = FeedingData(block.number,tokenId);;(None,None,feedingCounter,None) = stables.horseys(tokenId);stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) - uint32(feedingCounter));Feeding(tokenId);onlyOwnerOf(tokenId);carrotsMeetLevel(tokenId);noFeedingInProgress()"
./0xed6cd75aac7db5abbf382673dfe76e27c7399150_ext.sol,VIPSToken.refundTokens,355,361,"TMP_111(bool) = msg.sender == owner,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113 = CONVERT this to address,TMP_114(bool) = _token != TMP_113,TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114),TMP_116 = CONVERT _token to AbstractToken,token(AbstractToken) := TMP_116(AbstractToken),TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ,Emit RefundTokens(_token,_refund,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_111(bool) = msg.sender == owner
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_113 = CONVERT this to address
TMP_114(bool) = _token != TMP_113
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
token = AbstractToken(_token)

IRs:
TMP_116 = CONVERT _token to AbstractToken
token(AbstractToken) := TMP_116(AbstractToken)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(_refund,_value)

IRs:
TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RefundTokens(_token,_refund,_value)

IRs:
Emit RefundTokens(_token,_refund,_value)""];
}
",1,0,0,0,"require(bool)(msg.sender == owner);require(bool)(_token != address(this));token = AbstractToken(_token);token.transfer(_refund,_value);RefundTokens(_token,_refund,_value)"
./0x1d1811189e2a8dd8d5f22cdc164273bf3d6fdd43_ext.sol,BasicToken.transfer,149,161,"TMP_17 = CONVERT 0 to address,TMP_18(bool) = _to != TMP_17,TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18),REF_0(uint256) -> balances[msg.sender],TMP_20(bool) = _value <= REF_0,TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20),TMP_22(bool) = INTERNAL_CALL, BasicToken.isContract(address)(_to),TMP_23 = UnaryType.BANG TMP_22 ,CONDITION TMP_23,REF_1(uint256) -> balances[msg.sender],REF_2(uint256) -> balances[msg.sender],TMP_24(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] ,REF_1(uint256) (->balances) := TMP_24(uint256),REF_4(uint256) -> balances[_to],REF_5(uint256) -> balances[_to],TMP_25(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] ,REF_4(uint256) (->balances) := TMP_25(uint256),Emit Transfer(msg.sender,_to,_value),RETURN True,REF_7(uint256) -> balances[msg.sender],TMP_27(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(msg.sender),TMP_28(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_27', '_value'] ,REF_7(uint256) (->balances) := TMP_28(uint256),REF_9(uint256) -> balances[_to],TMP_29(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(_to),TMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_29', '_value'] ,REF_9(uint256) (->balances) := TMP_30(uint256),TMP_31 = CONVERT _to to NSPReceiver,receiver(NSPReceiver) := TMP_31(NSPReceiver),HIGH_LEVEL_CALL, dest:receiver(NSPReceiver), function:NSPFallback, arguments:['msg.sender', '_value', '0']  ,Emit Transfer(msg.sender,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_17 = CONVERT 0 to address
TMP_18(bool) = _to != TMP_17
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_20(bool) = _value <= REF_0
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
! isContract(_to)

IRs:
TMP_22(bool) = INTERNAL_CALL, BasicToken.isContract(address)(_to)
TMP_23 = UnaryType.BANG TMP_22 
CONDITION TMP_23""];
3->4[label=""True""];
3->8[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_2(uint256) -> balances[msg.sender]
TMP_24(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] 
REF_1(uint256) (->balances) := TMP_24(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_4(uint256) -> balances[_to]
REF_5(uint256) -> balances[_to]
TMP_25(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_5', '_value'] 
REF_4(uint256) (->balances) := TMP_25(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[msg.sender] = balanceOf(msg.sender).sub(_value)

IRs:
REF_7(uint256) -> balances[msg.sender]
TMP_27(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(msg.sender)
TMP_28(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_27', '_value'] 
REF_7(uint256) (->balances) := TMP_28(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
balances[_to] = balanceOf(_to).add(_value)

IRs:
REF_9(uint256) -> balances[_to]
TMP_29(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(_to)
TMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_29', '_value'] 
REF_9(uint256) (->balances) := TMP_30(uint256)""];
9->10;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
receiver = NSPReceiver(_to)

IRs:
TMP_31 = CONVERT _to to NSPReceiver
receiver(NSPReceiver) := TMP_31(NSPReceiver)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
receiver.NSPFallback(msg.sender,_value,0)

IRs:
HIGH_LEVEL_CALL, dest:receiver(NSPReceiver), function:NSPFallback, arguments:['msg.sender', '_value', '0']  ""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
12->13;
13[label=""Node Type: RETURN 13

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,"require(bool)(_to != address(0));require(bool)(_value <= balances[msg.sender]);! isContract(_to);balances[msg.sender] = balances[msg.sender].sub(_value);balances[msg.sender] = balanceOf(msg.sender).sub(_value);balances[_to] = balances[_to].add(_value);Transfer(msg.sender,_to,_value);true;balances[_to] = balanceOf(_to).add(_value);receiver = NSPReceiver(_to);receiver.NSPFallback(msg.sender,_value,0);Transfer(msg.sender,_to,_value);true"
./0xb3b3fa00a534ab0c7437bc5e9f4f97f1f98b930d_ext.sol,LuckyCoin.registerNameXname,759,773,"TMP_283(bytes32) = LIBRARY_CALL, dest:NameFilter, function:NameFilter.nameFilter(string), arguments:['_nameString'] ,_name(bytes32) := TMP_283(bytes32),_addr(address) := msg.sender(address),_paid(uint256) := msg.value(uint256),TUPLE_0(bool,uint256) = HIGH_LEVEL_CALL, dest:PlayerBook(PlayerBookInterface), function:registerNameXnameFromDapp, arguments:['msg.sender', '_name', '_affCode', '_all'] value:msg.value ,_isNewPlayer(bool)= UNPACK TUPLE_0 index: 0 ,_affID(uint256)= UNPACK TUPLE_0 index: 1 ,REF_425(uint256) -> pIDxAddr_[_addr],_pID(uint256) := REF_425(uint256),REF_427(Coindatasets.Player) -> plyr_[_affID],REF_428(address) -> REF_427.addr,REF_429(Coindatasets.Player) -> plyr_[_affID],REF_430(bytes32) -> REF_429.name,Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_428,REF_430,_paid,now),MODIFIER_CALL, LuckyCoin.isHuman()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_name = _nameString.nameFilter()

IRs:
TMP_283(bytes32) = LIBRARY_CALL, dest:NameFilter, function:NameFilter.nameFilter(string), arguments:['_nameString'] 
_name(bytes32) := TMP_283(bytes32)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
_addr = msg.sender

IRs:
_addr(address) := msg.sender(address)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
_paid = msg.value

IRs:
_paid(uint256) := msg.value(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
(_isNewPlayer,_affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender,_name,_affCode,_all)

IRs:
TUPLE_0(bool,uint256) = HIGH_LEVEL_CALL, dest:PlayerBook(PlayerBookInterface), function:registerNameXnameFromDapp, arguments:['msg.sender', '_name', '_affCode', '_all'] value:msg.value 
_isNewPlayer(bool)= UNPACK TUPLE_0 index: 0 
_affID(uint256)= UNPACK TUPLE_0 index: 1 ""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
_pID = pIDxAddr_[_addr]

IRs:
REF_425(uint256) -> pIDxAddr_[_addr]
_pID(uint256) := REF_425(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Coinevents.onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,_paid,now)

IRs:
REF_427(Coindatasets.Player) -> plyr_[_affID]
REF_428(address) -> REF_427.addr
REF_429(Coindatasets.Player) -> plyr_[_affID]
REF_430(bytes32) -> REF_429.name
Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_428,REF_430,_paid,now)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
isHuman()

IRs:
MODIFIER_CALL, LuckyCoin.isHuman()()""];
9->1;
}
",1,0,0,0,"isHuman();_name = _nameString.nameFilter();_addr = msg.sender;_paid = msg.value;;;(_isNewPlayer,_affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender,_name,_affCode,_all);_pID = pIDxAddr_[_addr];Coinevents.onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,_paid,now)"
./0x4d4377ef856e89cbf76f8e994ab3065445d82f4f_ext.sol,Airdrop.drop,578,584,"TMP_473(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokens_sold', '_amount'] ,TMP_474(bool) = TMP_473 <= total_tokens,TMP_475(None) = SOLIDITY_CALL require(bool)(TMP_474),TMP_476(bool) = HIGH_LEVEL_CALL, dest:token(GenbbyToken), function:mint, arguments:['_to', '_amount']  ,TMP_477(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokens_sold', '_amount'] ,tokens_sold(uint256) := TMP_477(uint256),Emit Drop(_to,_amount),RETURN True,MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, Pausable.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(tokens_sold.add(_amount) <= total_tokens)

IRs:
TMP_473(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokens_sold', '_amount'] 
TMP_474(bool) = TMP_473 <= total_tokens
TMP_475(None) = SOLIDITY_CALL require(bool)(TMP_474)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
token.mint(_to,_amount)

IRs:
TMP_476(bool) = HIGH_LEVEL_CALL, dest:token(GenbbyToken), function:mint, arguments:['_to', '_amount']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tokens_sold = tokens_sold.add(_amount)

IRs:
TMP_477(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokens_sold', '_amount'] 
tokens_sold(uint256) := TMP_477(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Drop(_to,_amount)

IRs:
Emit Drop(_to,_amount)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
7->1;
}
",1,0,0,0,"onlyOwner();require(bool)(tokens_sold.add(_amount) <= total_tokens);token.mint(_to,_amount);tokens_sold = tokens_sold.add(_amount);Drop(_to,_amount);true;whenNotPaused()"
./0x78a73b6cbc5d183ce56e786f6e905cadec63547b_ext.sol,FabricTokenFundraiser.finalize,793,816,"TMP_308(bool) = totalSupply >= hardCap,TMP_309(bool) = now >= endDate,TMP_310(bool) = TMP_308 || TMP_309,TMP_311(None) = SOLIDITY_CALL require(bool)(TMP_310),TMP_312 = UnaryType.BANG finalized ,TMP_313(None) = SOLIDITY_CALL require(bool)(TMP_312),REF_150(uint256) = SOLIDITY_CALL balance(address)(this),Emit Finalized(beneficiary,REF_150,totalSupply),REF_152(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:beneficiary value:REF_152,TMP_316(uint256) = HIGH_LEVEL_CALL, dest:fabricTokenSafe(FabricTokenSafe), function:totalTokensLocked, arguments:[]  ,totalTokensLocked(uint256) := TMP_316(uint256),TMP_317 = CONVERT fabricTokenSafe to address,REF_154(uint256) -> balances[TMP_317],TMP_318 = CONVERT fabricTokenSafe to address,REF_155(uint256) -> balances[TMP_318],TMP_319(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['REF_155', 'totalTokensLocked'] ,REF_154(uint256) (->balances) := TMP_319(uint256),TMP_320(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['totalSupply', 'totalTokensLocked'] ,totalSupply(uint256) := TMP_320(uint256),REF_158(uint256) -> balances[owner],REF_159(uint256) -> balances[owner],TMP_321(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['REF_159', 'TOKENS_BOUNTY_PROGRAM'] ,REF_158(uint256) (->balances) := TMP_321(uint256),TMP_322(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['totalSupply', 'TOKENS_BOUNTY_PROGRAM'] ,totalSupply(uint256) := TMP_322(uint256),finalized(bool) := True(bool),INTERNAL_CALL, Freezable.unfreeze()(),MODIFIER_CALL, HasOwner.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((totalSupply >= hardCap) || (now >= endDate))

IRs:
TMP_308(bool) = totalSupply >= hardCap
TMP_309(bool) = now >= endDate
TMP_310(bool) = TMP_308 || TMP_309
TMP_311(None) = SOLIDITY_CALL require(bool)(TMP_310)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! finalized)

IRs:
TMP_312 = UnaryType.BANG finalized 
TMP_313(None) = SOLIDITY_CALL require(bool)(TMP_312)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Finalized(beneficiary,this.balance,totalSupply)

IRs:
REF_150(uint256) = SOLIDITY_CALL balance(address)(this)
Emit Finalized(beneficiary,REF_150,totalSupply)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
beneficiary.transfer(this.balance)

IRs:
REF_152(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:beneficiary value:REF_152""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
totalTokensLocked = fabricTokenSafe.totalTokensLocked()

IRs:
TMP_316(uint256) = HIGH_LEVEL_CALL, dest:fabricTokenSafe(FabricTokenSafe), function:totalTokensLocked, arguments:[]  
totalTokensLocked(uint256) := TMP_316(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[address(fabricTokenSafe)] = balances[address(fabricTokenSafe)].plus(totalTokensLocked)

IRs:
TMP_317 = CONVERT fabricTokenSafe to address
REF_154(uint256) -> balances[TMP_317]
TMP_318 = CONVERT fabricTokenSafe to address
REF_155(uint256) -> balances[TMP_318]
TMP_319(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['REF_155', 'totalTokensLocked'] 
REF_154(uint256) (->balances) := TMP_319(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
totalSupply = totalSupply.plus(totalTokensLocked)

IRs:
TMP_320(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['totalSupply', 'totalTokensLocked'] 
totalSupply(uint256) := TMP_320(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[owner] = balances[owner].plus(TOKENS_BOUNTY_PROGRAM)

IRs:
REF_158(uint256) -> balances[owner]
REF_159(uint256) -> balances[owner]
TMP_321(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['REF_159', 'TOKENS_BOUNTY_PROGRAM'] 
REF_158(uint256) (->balances) := TMP_321(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
totalSupply = totalSupply.plus(TOKENS_BOUNTY_PROGRAM)

IRs:
TMP_322(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['totalSupply', 'TOKENS_BOUNTY_PROGRAM'] 
totalSupply(uint256) := TMP_322(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
finalized = true

IRs:
finalized(bool) := True(bool)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
unfreeze()

IRs:
INTERNAL_CALL, Freezable.unfreeze()()""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, HasOwner.onlyOwner()()""];
12->1;
}
",1,0,1,0,"onlyOwner();require(bool)((totalSupply >= hardCap) || (now >= endDate));require(bool)(! finalized);Finalized(beneficiary,this.balance,totalSupply);beneficiary.transfer(this.balance);totalTokensLocked = fabricTokenSafe.totalTokensLocked();balances[address(fabricTokenSafe)] = balances[address(fabricTokenSafe)].plus(totalTokensLocked);totalSupply = totalSupply.plus(totalTokensLocked);balances[owner] = balances[owner].plus(TOKENS_BOUNTY_PROGRAM);totalSupply = totalSupply.plus(TOKENS_BOUNTY_PROGRAM);finalized = true;unfreeze()"
./0x0096dc2246fc3627cc2bf87a3b0d2e0f87b58589_ext.sol,Zethroll.ownerSetBankroll,359,365,"TMP_83(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:approve, arguments:['ZethrBankroll', '0']  ,ZethrBankroll(address) := newBankroll(address),TMP_84(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:approve, arguments:['newBankroll', 'MAX_INT']  ,MODIFIER_CALL, Zethroll.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ZTHTKN.approve(ZethrBankroll,0)

IRs:
TMP_83(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:approve, arguments:['ZethrBankroll', '0']  ""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ZethrBankroll = newBankroll

IRs:
ZethrBankroll(address) := newBankroll(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ZTHTKN.approve(newBankroll,MAX_INT)

IRs:
TMP_84(bool) = HIGH_LEVEL_CALL, dest:ZTHTKN(ZTHInterface), function:approve, arguments:['newBankroll', 'MAX_INT']  ""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Zethroll.onlyOwner()()""];
4->1;
}
",1,0,0,0,"onlyOwner();ZTHTKN.approve(ZethrBankroll,0);ZethrBankroll = newBankroll;ZTHTKN.approve(newBankroll,MAX_INT)"
./0x3fe1bd3f808682e10cc16ccfc0e9476555ed93a7_ext.sol,WFCToken.migrate,193,207,"CONDITION isFunding,TMP_74 = CONVERT 0 to address,TMP_75(bool) = newContractAddr == TMP_74,CONDITION TMP_75,REF_31(uint256) -> balances[msg.sender],tokens(uint256) := REF_31(uint256),TMP_76(bool) = tokens == 0,CONDITION TMP_76,REF_32(uint256) -> balances[msg.sender],REF_32(uint256) (->balances) := 0(uint256),TMP_77(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(tokenMigrated,tokens),tokenMigrated(uint256) := TMP_77(uint256),TMP_78 = CONVERT newContractAddr to IMigrationContract,newContract(IMigrationContract) := TMP_78(IMigrationContract),TMP_79(bool) = HIGH_LEVEL_CALL, dest:newContract(IMigrationContract), function:migrate, arguments:['msg.sender', 'tokens']  ,TMP_80 = UnaryType.BANG TMP_79 ,CONDITION TMP_80,Emit Migrate(msg.sender,tokens)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
isFunding

IRs:
CONDITION isFunding""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
newContractAddr == address(0x0)

IRs:
TMP_74 = CONVERT 0 to address
TMP_75(bool) = newContractAddr == TMP_74
CONDITION TMP_75""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: THROW 5
""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
tokens = balances[msg.sender]

IRs:
REF_31(uint256) -> balances[msg.sender]
tokens(uint256) := REF_31(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
tokens == 0

IRs:
TMP_76(bool) = tokens == 0
CONDITION TMP_76""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: THROW 9
""];
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
balances[msg.sender] = 0

IRs:
REF_32(uint256) -> balances[msg.sender]
REF_32(uint256) (->balances) := 0(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
tokenMigrated = safeAdd(tokenMigrated,tokens)

IRs:
TMP_77(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(tokenMigrated,tokens)
tokenMigrated(uint256) := TMP_77(uint256)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
newContract = IMigrationContract(newContractAddr)

IRs:
TMP_78 = CONVERT newContractAddr to IMigrationContract
newContract(IMigrationContract) := TMP_78(IMigrationContract)""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
! newContract.migrate(msg.sender,tokens)

IRs:
TMP_79(bool) = HIGH_LEVEL_CALL, dest:newContract(IMigrationContract), function:migrate, arguments:['msg.sender', 'tokens']  
TMP_80 = UnaryType.BANG TMP_79 
CONDITION TMP_80""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: THROW 15
""];
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
Migrate(msg.sender,tokens)

IRs:
Emit Migrate(msg.sender,tokens)""];
}
",1,0,0,0,"isFunding;;;newContractAddr == address(0x0);;;tokens = balances[msg.sender];tokens == 0;;;balances[msg.sender] = 0;tokenMigrated = safeAdd(tokenMigrated,tokens);newContract = IMigrationContract(newContractAddr);! newContract.migrate(msg.sender,tokens);;;Migrate(msg.sender,tokens)"
./0x0692de52a966c107021e8a84db8486b4be57ecf1_ext.sol,OQToken.refundTokens,355,361,"TMP_111(bool) = msg.sender == owner,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113 = CONVERT this to address,TMP_114(bool) = _token != TMP_113,TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114),TMP_116 = CONVERT _token to AbstractToken,token(AbstractToken) := TMP_116(AbstractToken),TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ,Emit RefundTokens(_token,_refund,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_111(bool) = msg.sender == owner
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_113 = CONVERT this to address
TMP_114(bool) = _token != TMP_113
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
token = AbstractToken(_token)

IRs:
TMP_116 = CONVERT _token to AbstractToken
token(AbstractToken) := TMP_116(AbstractToken)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(_refund,_value)

IRs:
TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RefundTokens(_token,_refund,_value)

IRs:
Emit RefundTokens(_token,_refund,_value)""];
}
",1,0,0,0,"require(bool)(msg.sender == owner);require(bool)(_token != address(this));token = AbstractToken(_token);token.transfer(_refund,_value);RefundTokens(_token,_refund,_value)"
./0x797d713d8d7a2815ccf3dcf9719e3e9f1712c370_ext.sol,Trustee.revoke,600,615,"REF_77(Trustee.Grant) -> grants[_holder],grant(Trustee.Grant) := REF_77(Trustee.Grant),REF_78(bool) -> grant.revokable,TMP_310(None) = SOLIDITY_CALL require(bool)(REF_78),REF_79(uint256) -> grant.value,REF_81(uint256) -> grant.transferred,TMP_311(uint256) = LIBRARY_CALL, dest:SaferMath, function:SaferMath.sub(uint256,uint256), arguments:['REF_79', 'REF_81'] ,refund(uint256) := TMP_311(uint256),REF_82(Trustee.Grant) -> grants[_holder],grants = delete REF_82 ,TMP_312(uint256) = LIBRARY_CALL, dest:SaferMath, function:SaferMath.sub(uint256,uint256), arguments:['totalVesting', 'refund'] ,totalVesting(uint256) := TMP_312(uint256),TMP_313(bool) = HIGH_LEVEL_CALL, dest:stox(StoxSmartToken), function:transfer, arguments:['msg.sender', 'refund']  ,Emit RevokeGrant(_holder,refund),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
grant = grants[_holder]

IRs:
REF_77(Trustee.Grant) -> grants[_holder]
grant(Trustee.Grant) := REF_77(Trustee.Grant)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(grant.revokable)

IRs:
REF_78(bool) -> grant.revokable
TMP_310(None) = SOLIDITY_CALL require(bool)(REF_78)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
refund = grant.value.sub(grant.transferred)

IRs:
REF_79(uint256) -> grant.value
REF_81(uint256) -> grant.transferred
TMP_311(uint256) = LIBRARY_CALL, dest:SaferMath, function:SaferMath.sub(uint256,uint256), arguments:['REF_79', 'REF_81'] 
refund(uint256) := TMP_311(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
delete grants[_holder]

IRs:
REF_82(Trustee.Grant) -> grants[_holder]
grants = delete REF_82 ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalVesting = totalVesting.sub(refund)

IRs:
TMP_312(uint256) = LIBRARY_CALL, dest:SaferMath, function:SaferMath.sub(uint256,uint256), arguments:['totalVesting', 'refund'] 
totalVesting(uint256) := TMP_312(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
stox.transfer(msg.sender,refund)

IRs:
TMP_313(bool) = HIGH_LEVEL_CALL, dest:stox(StoxSmartToken), function:transfer, arguments:['msg.sender', 'refund']  ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
RevokeGrant(_holder,refund)

IRs:
Emit RevokeGrant(_holder,refund)""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
8->1;
}
",1,0,0,0,"onlyOwner();grant = grants[_holder];require(bool)(grant.revokable);refund = grant.value.sub(grant.transferred);delete grants[_holder];totalVesting = totalVesting.sub(refund);stox.transfer(msg.sender,refund);RevokeGrant(_holder,refund)"
./0xc4aad17558fa95c8937d0856b2dad74c1a7a095f_ext.sol,AgiCrowdsale.finalize,482,501,"TMP_245 = UnaryType.BANG isFinalized ,TMP_246(None) = SOLIDITY_CALL require(bool)(TMP_245),TMP_247(bool) = INTERNAL_CALL, AgiCrowdsale.hasEnded()(),TMP_248(None) = SOLIDITY_CALL require(bool)(TMP_247),TMP_249(bool) = INTERNAL_CALL, AgiCrowdsale.goalReached()(),CONDITION TMP_249,HIGH_LEVEL_CALL, dest:vault(RefundVault), function:close, arguments:[]  ,HIGH_LEVEL_CALL, dest:token(SingularityNetToken), function:unpause, arguments:[]  ,HIGH_LEVEL_CALL, dest:token(SingularityNetToken), function:transferOwnership, arguments:['owner']  ,HIGH_LEVEL_CALL, dest:vault(RefundVault), function:enableRefunds, arguments:[]  ,isFinalized(bool) := True(bool),Emit Finalized(),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isFinalized)

IRs:
TMP_245 = UnaryType.BANG isFinalized 
TMP_246(None) = SOLIDITY_CALL require(bool)(TMP_245)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(hasEnded())

IRs:
TMP_247(bool) = INTERNAL_CALL, AgiCrowdsale.hasEnded()()
TMP_248(None) = SOLIDITY_CALL require(bool)(TMP_247)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
goalReached()

IRs:
TMP_249(bool) = INTERNAL_CALL, AgiCrowdsale.goalReached()()
CONDITION TMP_249""];
3->4[label=""True""];
3->7[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
vault.close()

IRs:
HIGH_LEVEL_CALL, dest:vault(RefundVault), function:close, arguments:[]  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
token.unpause()

IRs:
HIGH_LEVEL_CALL, dest:token(SingularityNetToken), function:unpause, arguments:[]  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
token.transferOwnership(owner)

IRs:
HIGH_LEVEL_CALL, dest:token(SingularityNetToken), function:transferOwnership, arguments:['owner']  ""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
vault.enableRefunds()

IRs:
HIGH_LEVEL_CALL, dest:vault(RefundVault), function:enableRefunds, arguments:[]  ""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
isFinalized = true

IRs:
isFinalized(bool) := True(bool)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Finalized()

IRs:
Emit Finalized()""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
11->1;
}
",1,0,0,0,onlyOwner();require(bool)(! isFinalized);require(bool)(hasEnded());goalReached();vault.close();vault.enableRefunds();token.unpause();token.transferOwnership(owner);;isFinalized = true;Finalized()
./0x17f68886d00845867c154c912b4ccc506ec92fc7_ext.sol,DelegatedShareholderAssociation.newProposal,271,298,"TMP_49 = CONVERT tokenLocker to address,TMP_50(bool) = beneficiary != TMP_49,TMP_51(None) = SOLIDITY_CALL require(bool)(TMP_50),REF_21 -> LENGTH proposals,TMP_52(uint256) := REF_21(uint256),REF_21(-> proposals) = REF_21 + 1,proposalID(uint256) := TMP_52(uint256),REF_22(DelegatedShareholderAssociation.Proposal) -> proposals[proposalID],p(DelegatedShareholderAssociation.Proposal) := REF_22(DelegatedShareholderAssociation.Proposal),REF_23(address) -> p.recipient,REF_23(address) (->p) := beneficiary(address),REF_24(uint256) -> p.amount,REF_24(uint256) (->p) := weiAmount(uint256),REF_25(bytes) -> p.metadataHash,REF_25(bytes) (->p) := jobMetadataHash(bytes),REF_26(bytes32) -> p.proposalHash,TMP_53(bytes32) = SOLIDITY_CALL keccak256()(beneficiary,weiAmount,transactionBytecode),REF_26(bytes32) (->p) := TMP_53(bytes32),REF_27(uint256) -> p.timeCreated,REF_27(uint256) (->p) := now(uint256),REF_28(uint256) -> p.votingDeadline,TMP_54(uint256) = debatingPeriodInMinutes * 60,TMP_55(uint256) = now + TMP_54,REF_28(uint256) (->p) := TMP_55(uint256),REF_29(bool) -> p.finalized,REF_29(bool) (->p) := False(bool),REF_30(bool) -> p.proposalPassed,REF_30(bool) (->p) := False(bool),REF_31(uint256) -> p.numberOfVotes,REF_31(uint256) (->p) := 0(uint256),Emit ProposalAdded(proposalID,beneficiary,weiAmount,jobMetadataHash),TMP_57(uint256) = proposalID + 1,numProposals(uint256) := TMP_57(uint256),RETURN proposalID,MODIFIER_CALL, DelegatedShareholderAssociation.onlyBoardMembers()(),MODIFIER_CALL, DelegatedShareholderAssociation.notSelf()(),RETURN proposalID","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->16;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != address(tokenLocker))

IRs:
TMP_49 = CONVERT tokenLocker to address
TMP_50(bool) = beneficiary != TMP_49
TMP_51(None) = SOLIDITY_CALL require(bool)(TMP_50)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
proposalID = proposals.length ++

IRs:
REF_21 -> LENGTH proposals
TMP_52(uint256) := REF_21(uint256)
REF_21(-> proposals) = REF_21 + 1
proposalID(uint256) := TMP_52(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
p = proposals[proposalID]

IRs:
REF_22(DelegatedShareholderAssociation.Proposal) -> proposals[proposalID]
p(DelegatedShareholderAssociation.Proposal) := REF_22(DelegatedShareholderAssociation.Proposal)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
p.recipient = beneficiary

IRs:
REF_23(address) -> p.recipient
REF_23(address) (->p) := beneficiary(address)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
p.amount = weiAmount

IRs:
REF_24(uint256) -> p.amount
REF_24(uint256) (->p) := weiAmount(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
p.metadataHash = jobMetadataHash

IRs:
REF_25(bytes) -> p.metadataHash
REF_25(bytes) (->p) := jobMetadataHash(bytes)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
p.proposalHash = keccak256()(beneficiary,weiAmount,transactionBytecode)

IRs:
REF_26(bytes32) -> p.proposalHash
TMP_53(bytes32) = SOLIDITY_CALL keccak256()(beneficiary,weiAmount,transactionBytecode)
REF_26(bytes32) (->p) := TMP_53(bytes32)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
p.timeCreated = now

IRs:
REF_27(uint256) -> p.timeCreated
REF_27(uint256) (->p) := now(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
p.votingDeadline = now + debatingPeriodInMinutes * 60

IRs:
REF_28(uint256) -> p.votingDeadline
TMP_54(uint256) = debatingPeriodInMinutes * 60
TMP_55(uint256) = now + TMP_54
REF_28(uint256) (->p) := TMP_55(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
p.finalized = false

IRs:
REF_29(bool) -> p.finalized
REF_29(bool) (->p) := False(bool)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
p.proposalPassed = false

IRs:
REF_30(bool) -> p.proposalPassed
REF_30(bool) (->p) := False(bool)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
p.numberOfVotes = 0

IRs:
REF_31(uint256) -> p.numberOfVotes
REF_31(uint256) (->p) := 0(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
ProposalAdded(proposalID,beneficiary,weiAmount,jobMetadataHash)

IRs:
Emit ProposalAdded(proposalID,beneficiary,weiAmount,jobMetadataHash)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
numProposals = proposalID + 1

IRs:
TMP_57(uint256) = proposalID + 1
numProposals(uint256) := TMP_57(uint256)""];
14->15;
15[label=""Node Type: RETURN 15

EXPRESSION:
proposalID

IRs:
RETURN proposalID""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
onlyBoardMembers()

IRs:
MODIFIER_CALL, DelegatedShareholderAssociation.onlyBoardMembers()()""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
notSelf()

IRs:
MODIFIER_CALL, DelegatedShareholderAssociation.notSelf()()""];
17->1;
18[label=""Node Type: RETURN 18

EXPRESSION:
proposalID

IRs:
RETURN proposalID""];
}
",1,0,0,0,"onlyBoardMembers();require(bool)(beneficiary != address(tokenLocker));proposalID = proposals.length ++;p = proposals[proposalID];p.recipient = beneficiary;p.amount = weiAmount;p.metadataHash = jobMetadataHash;p.proposalHash = keccak256()(beneficiary,weiAmount,transactionBytecode);p.timeCreated = now;p.votingDeadline = now + debatingPeriodInMinutes * 60;p.finalized = false;p.proposalPassed = false;p.numberOfVotes = 0;ProposalAdded(proposalID,beneficiary,weiAmount,jobMetadataHash);numProposals = proposalID + 1;proposalID;notSelf();proposalID"
./0x470142a1834438515b757118f322703aba6e1e05_ext.sol,PolicyPalNetworkAirdrop.airDropMultipleAmount,141,162,"i(uint256) := 0(uint256),REF_7 -> LENGTH _recipients,TMP_12(bool) = i < REF_7,CONDITION TMP_12,REF_8(address) -> _recipients[i],recipient(address) := REF_8(address),REF_9(uint256) -> _amounts[i],amount(uint256) := REF_9(uint256),REF_10(bool) -> airdrops[recipient],TMP_13 = UnaryType.BANG REF_10 ,CONDITION TMP_13,TMP_14(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', 'amount']  ,TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14),REF_12(bool) -> airdrops[recipient],REF_12(bool) (->airdrops) := True(bool),TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] ,numDrops(uint256) := TMP_16(uint256),TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', 'amount'] ,dropAmount(uint256) := TMP_17(uint256),Emit TokenDrop(recipient,amount,AIRDROP),TMP_19(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()(),MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalanceMultiple(address[],uint256[])(_recipients,_amounts)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->15;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _recipients.length

IRs:
REF_7 -> LENGTH _recipients
TMP_12(bool) = i < REF_7
CONDITION TMP_12""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
recipient = _recipients[i]

IRs:
REF_8(address) -> _recipients[i]
recipient(address) := REF_8(address)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
amount = _amounts[i]

IRs:
REF_9(uint256) -> _amounts[i]
amount(uint256) := REF_9(uint256)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
! airdrops[recipient]

IRs:
REF_10(bool) -> airdrops[recipient]
TMP_13 = UnaryType.BANG REF_10 
CONDITION TMP_13""];
7->8[label=""True""];
7->13[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(token.transfer(recipient,amount))

IRs:
TMP_14(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', 'amount']  
TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
airdrops[recipient] = true

IRs:
REF_12(bool) -> airdrops[recipient]
REF_12(bool) (->airdrops) := True(bool)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
numDrops = numDrops.add(1)

IRs:
TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] 
numDrops(uint256) := TMP_16(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
dropAmount = dropAmount.add(amount)

IRs:
TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', 'amount'] 
dropAmount(uint256) := TMP_17(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
TokenDrop(recipient,amount,AIRDROP)

IRs:
Emit TokenDrop(recipient,amount,AIRDROP)""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
i ++

IRs:
TMP_19(uint256) := i(uint256)
i(uint256) = i + 1""];
14->4;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()()""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
validBalanceMultiple(_recipients,_amounts)

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalanceMultiple(address[],uint256[])(_recipients,_amounts)""];
16->3;
}
",1,1,0,0,"onlyAdmin();;i < _recipients.length;;i = 0;recipient = _recipients[i];amount = _amounts[i];! airdrops[recipient];assert(bool)(token.transfer(recipient,amount));;airdrops[recipient] = true;numDrops = numDrops.add(1);dropAmount = dropAmount.add(amount);TokenDrop(recipient,amount,AIRDROP);i ++;validBalanceMultiple(_recipients,_amounts)"
./0x6fbc1b8f756f43cfbfd45085380cc375650ff3d6_ext.sol,ZethrSnap.walletCreateSnap,166,183,"REF_3 -> LENGTH snaps,index(uint256) := REF_3(uint256),REF_4 -> LENGTH snaps,TMP_25(uint256) := REF_4(uint256),REF_4(-> snaps) = REF_4 + 1,REF_5(ZethrSnap.SnapEntry) -> snaps[index],REF_6(uint256) -> REF_5.blockNumber,REF_6(uint256) (->snaps) := _blockNumber(uint256),REF_7(ZethrSnap.SnapEntry) -> snaps[index],REF_8(uint256) -> REF_7.profit,REF_8(uint256) (->snaps) := _profitToShare(uint256),TMP_26(uint256) = HIGH_LEVEL_CALL, dest:zethr(ZethrInterface), function:myFrontEndTokens, arguments:[]  ,balance(uint256) := TMP_26(uint256),TMP_27(uint256) = balance - allocatedTokens,balance(uint256) := TMP_27(uint256),TMP_28(bool) = balance >= _profitToShare,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),TMP_30(uint256) = allocatedTokens + _profitToShare,allocatedTokens(uint256) := TMP_30(uint256),MODIFIER_CALL, ZethrSnap.walletOnly()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
index = snaps.length

IRs:
REF_3 -> LENGTH snaps
index(uint256) := REF_3(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
snaps.length ++

IRs:
REF_4 -> LENGTH snaps
TMP_25(uint256) := REF_4(uint256)
REF_4(-> snaps) = REF_4 + 1""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
snaps[index].blockNumber = _blockNumber

IRs:
REF_5(ZethrSnap.SnapEntry) -> snaps[index]
REF_6(uint256) -> REF_5.blockNumber
REF_6(uint256) (->snaps) := _blockNumber(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
snaps[index].profit = _profitToShare

IRs:
REF_7(ZethrSnap.SnapEntry) -> snaps[index]
REF_8(uint256) -> REF_7.profit
REF_8(uint256) (->snaps) := _profitToShare(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
balance = zethr.myFrontEndTokens()

IRs:
TMP_26(uint256) = HIGH_LEVEL_CALL, dest:zethr(ZethrInterface), function:myFrontEndTokens, arguments:[]  
balance(uint256) := TMP_26(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balance = balance - allocatedTokens

IRs:
TMP_27(uint256) = balance - allocatedTokens
balance(uint256) := TMP_27(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(balance >= _profitToShare)

IRs:
TMP_28(bool) = balance >= _profitToShare
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
allocatedTokens = allocatedTokens + _profitToShare

IRs:
TMP_30(uint256) = allocatedTokens + _profitToShare
allocatedTokens(uint256) := TMP_30(uint256)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
walletOnly()

IRs:
MODIFIER_CALL, ZethrSnap.walletOnly()()""];
9->1;
}
",1,0,0,0,walletOnly();index = snaps.length;snaps.length ++;snaps[index].blockNumber = _blockNumber;snaps[index].profit = _profitToShare;balance = zethr.myFrontEndTokens();balance = balance - allocatedTokens;require(bool)(balance >= _profitToShare);allocatedTokens = allocatedTokens + _profitToShare
./0x0e69d0a2bbb30abcb7e5cfea0e4fde19c00a8d47_ext.sol,ContractLock.setOwner,23,29,"owner(address) := owner_(address),Emit LogSetOwner(owner),MODIFIER_CALL, DSAuth.auth()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner = owner_

IRs:
owner(address) := owner_(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
LogSetOwner(owner)

IRs:
Emit LogSetOwner(owner)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
3->1;
}
",1,0,0,0,auth();owner = owner_;LogSetOwner(owner)
./0x88355a32a8c5cc399aa09b9d21ebcba935ae5d2f_ext.sol,BankWallet.deposit,190,194,"TMP_109 = CONVERT edgelessCasino to Casino,__casino(Casino) := TMP_109(Casino),HIGH_LEVEL_CALL, dest:__casino(Casino), function:deposit, arguments:['_address', '_amount', '_chargeGas']  ,Emit Deposit(_address,_amount),MODIFIER_CALL, RequiringAuthorization.onlyAuthorized()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
__casino = Casino(edgelessCasino)

IRs:
TMP_109 = CONVERT edgelessCasino to Casino
__casino(Casino) := TMP_109(Casino)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
__casino.deposit(_address,_amount,_chargeGas)

IRs:
HIGH_LEVEL_CALL, dest:__casino(Casino), function:deposit, arguments:['_address', '_amount', '_chargeGas']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Deposit(_address,_amount)

IRs:
Emit Deposit(_address,_amount)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyAuthorized()

IRs:
MODIFIER_CALL, RequiringAuthorization.onlyAuthorized()()""];
4->1;
}
",1,0,0,0,"onlyAuthorized();__casino = Casino(edgelessCasino);__casino.deposit(_address,_amount,_chargeGas);Deposit(_address,_amount)"
./0x27e1d539cb59518bf14e4525b1c3b4721aaa9080_ext.sol,FourCrowdsale.processPresaleOrEarlyContributors,923,934,"TMP_889(bool) = now <= endTime,TMP_890(None) = SOLIDITY_CALL require(bool)(TMP_889),i(uint256) := 0(uint256),REF_573 -> LENGTH _beneficiaries,TMP_891(bool) = i < REF_573,CONDITION TMP_891,REF_575(uint256) -> _tokenAmounts[i],TMP_892(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokensSold', 'REF_575'] ,tokensSold(uint256) := TMP_892(uint256),REF_577(address) -> _beneficiaries[i],REF_578(uint256) -> _tokenAmounts[i],TMP_893(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['REF_577', 'REF_578']  ,REF_579(address) -> _beneficiaries[i],REF_580(uint256) -> _tokenAmounts[i],Emit TokenPurchase(msg.sender,REF_579,0,REF_580),TMP_895(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now <= endTime)

IRs:
TMP_889(bool) = now <= endTime
TMP_890(None) = SOLIDITY_CALL require(bool)(TMP_889)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < _beneficiaries.length

IRs:
REF_573 -> LENGTH _beneficiaries
TMP_891(bool) = i < REF_573
CONDITION TMP_891""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tokensSold = tokensSold.add(_tokenAmounts[i])

IRs:
REF_575(uint256) -> _tokenAmounts[i]
TMP_892(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokensSold', 'REF_575'] 
tokensSold(uint256) := TMP_892(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.mint(_beneficiaries[i],_tokenAmounts[i])

IRs:
REF_577(address) -> _beneficiaries[i]
REF_578(uint256) -> _tokenAmounts[i]
TMP_893(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['REF_577', 'REF_578']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
TokenPurchase(msg.sender,_beneficiaries[i],0,_tokenAmounts[i])

IRs:
REF_579(address) -> _beneficiaries[i]
REF_580(uint256) -> _tokenAmounts[i]
Emit TokenPurchase(msg.sender,REF_579,0,REF_580)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_895(uint256) := i(uint256)
i(uint256) = i + 1""];
9->5;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
10->1;
}
",1,0,0,0,"onlyOwner();require(bool)(now <= endTime);i = 0;;i < _beneficiaries.length;;tokensSold = tokensSold.add(_tokenAmounts[i]);token.mint(_beneficiaries[i],_tokenAmounts[i]);TokenPurchase(msg.sender,_beneficiaries[i],0,_tokenAmounts[i]);i ++"
./0x0e8175729e02db48ca0e2ca80efb72fe84a7dedd_ext.sol,MechanicKittyUnit.equipUnit,95,104,"TMP_17(bool) = msg.sender == player,TMP_18(bool) = msg.sender == factories,TMP_19(bool) = TMP_17 || TMP_18,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),HIGH_LEVEL_CALL, dest:units(Units), function:mintUnitExternal, arguments:['unitId', 'amount', 'player', 'chosenPosition']  ,REF_29(uint256) -> balances[player],REF_30(uint256) -> balances[player],TMP_22(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_30', 'amount'] ,REF_29(uint256) (->balances) := TMP_22(uint256),TMP_23(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply', 'amount'] ,totalSupply(uint256) := TMP_23(uint256),TMP_24 = CONVERT 0 to address,Emit Transfer(player,TMP_24,amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == player || msg.sender == factories)

IRs:
TMP_17(bool) = msg.sender == player
TMP_18(bool) = msg.sender == factories
TMP_19(bool) = TMP_17 || TMP_18
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
units.mintUnitExternal(unitId,amount,player,chosenPosition)

IRs:
HIGH_LEVEL_CALL, dest:units(Units), function:mintUnitExternal, arguments:['unitId', 'amount', 'player', 'chosenPosition']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[player] = balances[player].sub(amount)

IRs:
REF_29(uint256) -> balances[player]
REF_30(uint256) -> balances[player]
TMP_22(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_30', 'amount'] 
REF_29(uint256) (->balances) := TMP_22(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
totalSupply = totalSupply.sub(amount)

IRs:
TMP_23(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSupply', 'amount'] 
totalSupply(uint256) := TMP_23(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(player,address(0),amount)

IRs:
TMP_24 = CONVERT 0 to address
Emit Transfer(player,TMP_24,amount)""];
}
",1,0,0,0,"require(bool)(msg.sender == player || msg.sender == factories);units.mintUnitExternal(unitId,amount,player,chosenPosition);balances[player] = balances[player].sub(amount);totalSupply = totalSupply.sub(amount);Transfer(player,address(0),amount)"
./0xbccfe34a2c6c59e396d2873d0d5bcb4736c8e2e7_ext.sol,SwapController.addGuard,168,171,"TMP_36 = CONVERT _guard to TokenTransferGuard,REF_9 -> LENGTH guards,TMP_38(uint256) := REF_9(uint256),TMP_39(uint256) = TMP_38 + 1,REF_9(uint256) (->guards) := TMP_39(uint256),REF_10(TokenTransferGuard) -> guards[TMP_38],REF_10(TokenTransferGuard) (->guards) := TMP_36(TokenTransferGuard),MODIFIER_CALL, DSAuth.auth()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
guards.push(TokenTransferGuard(_guard))

IRs:
TMP_36 = CONVERT _guard to TokenTransferGuard
REF_9 -> LENGTH guards
TMP_38(uint256) := REF_9(uint256)
TMP_39(uint256) = TMP_38 + 1
REF_9(uint256) (->guards) := TMP_39(uint256)
REF_10(TokenTransferGuard) -> guards[TMP_38]
REF_10(TokenTransferGuard) (->guards) := TMP_36(TokenTransferGuard)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
2->1;
}
",1,0,0,0,auth();guards.push(TokenTransferGuard(_guard))
./0x174bb5d84b78e9e2248e7aa2c789aeba82f72f68_ext.sol,LuckyTree.receiveApproval,283,292,"TMP_98(bool) = _to == tokenAddress,TMP_99(None) = SOLIDITY_CALL require(bool)(TMP_98),TMP_100(bool) = _value == leafPrice,TMP_101(None) = SOLIDITY_CALL require(bool)(TMP_100),REF_26(LuckyTree.state) -> state.closed,TMP_102(bool) = gameState != REF_26,TMP_103(None) = SOLIDITY_CALL require(bool)(TMP_102),TMP_104 = CONVERT creditGameAddress to CreditGAMEInterface,TMP_105 = CONVERT this to address,TMP_106(bool) = HIGH_LEVEL_CALL, dest:TMP_104(CreditGAMEInterface), function:isGameApproved, arguments:['TMP_105']  ,TMP_107(bool) = TMP_106 == True,TMP_108(None) = SOLIDITY_CALL require(bool)(TMP_107),TMP_109(uint256) = INTERNAL_CALL, LuckyTree.processTransaction(address,uint256)(_from,_value),tokensToTake(uint256) := TMP_109(uint256),TMP_110 = CONVERT tokenAddress to IERC20Token,TMP_111 = CONVERT this to address,TMP_112(bool) = HIGH_LEVEL_CALL, dest:TMP_110(IERC20Token), function:transferFrom, arguments:['_from', 'TMP_111', 'tokensToTake']  ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to == tokenAddress)

IRs:
TMP_98(bool) = _to == tokenAddress
TMP_99(None) = SOLIDITY_CALL require(bool)(TMP_98)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value == leafPrice)

IRs:
TMP_100(bool) = _value == leafPrice
TMP_101(None) = SOLIDITY_CALL require(bool)(TMP_100)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(gameState != state.closed)

IRs:
REF_26(LuckyTree.state) -> state.closed
TMP_102(bool) = gameState != REF_26
TMP_103(None) = SOLIDITY_CALL require(bool)(TMP_102)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(CreditGAMEInterface(creditGameAddress).isGameApproved(address(this)) == true)

IRs:
TMP_104 = CONVERT creditGameAddress to CreditGAMEInterface
TMP_105 = CONVERT this to address
TMP_106(bool) = HIGH_LEVEL_CALL, dest:TMP_104(CreditGAMEInterface), function:isGameApproved, arguments:['TMP_105']  
TMP_107(bool) = TMP_106 == True
TMP_108(None) = SOLIDITY_CALL require(bool)(TMP_107)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
tokensToTake = processTransaction(_from,_value)

IRs:
TMP_109(uint256) = INTERNAL_CALL, LuckyTree.processTransaction(address,uint256)(_from,_value)
tokensToTake(uint256) := TMP_109(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
IERC20Token(tokenAddress).transferFrom(_from,address(this),tokensToTake)

IRs:
TMP_110 = CONVERT tokenAddress to IERC20Token
TMP_111 = CONVERT this to address
TMP_112(bool) = HIGH_LEVEL_CALL, dest:TMP_110(IERC20Token), function:transferFrom, arguments:['_from', 'TMP_111', 'tokensToTake']  ""];
}
",1,0,0,0,"require(bool)(_to == tokenAddress);require(bool)(_value == leafPrice);require(bool)(gameState != state.closed);require(bool)(CreditGAMEInterface(creditGameAddress).isGameApproved(address(this)) == true);tokensToTake = processTransaction(_from,_value);IERC20Token(tokenAddress).transferFrom(_from,address(this),tokensToTake)"
./0x26a9bab7b085582f56885f084174115e51fb58e4_ext.sol,Lottery.deposit,81,125,"TMP_1(bool) = msg.value >= 1000000000000000,TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1),customerAddress(address) := msg.sender(address),TMP_4(uint256) = HIGH_LEVEL_CALL, dest:poohContract(POOH), function:buy, arguments:['customerAddress'] value:msg.value ,Emit Deposit(msg.value,msg.sender),TMP_6(bool) = msg.value > 1000000000000000,CONDITION TMP_6,TMP_7(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['msg.value', '1000000000000000'] ,extraTickets(uint256) := TMP_7(uint256),ticketNumber(uint256) = ticketNumber + extraTickets,TMP_8(bool) = ticketNumber >= winningNumber,CONDITION TMP_8,HIGH_LEVEL_CALL, dest:poohContract(POOH), function:exit, arguments:[]  ,INTERNAL_CALL, Lottery.payDev(address)(owner),INTERNAL_CALL, Lottery.payWinner(address)(customerAddress),TMP_12 = CONVERT this to address,TMP_13(uint256) = SOLIDITY_CALL balance(address)(TMP_12),TMP_15(uint256) = HIGH_LEVEL_CALL, dest:poohContract(POOH), function:buy, arguments:['customerAddress'] value:TMP_13 ,INTERNAL_CALL, Lottery.resetLottery()(),TMP_17(uint256) := ticketNumber(uint256),ticketNumber(uint256) = ticketNumber + 1,MODIFIER_CALL, Lottery.isOpenToPublic()(),MODIFIER_CALL, Lottery.onlyHuman()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->17;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= 1000000000000000)

IRs:
TMP_1(bool) = msg.value >= 1000000000000000
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
customerAddress = msg.sender

IRs:
customerAddress(address) := msg.sender(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
poohContract.buy.value(msg.value)(customerAddress)

IRs:
TMP_4(uint256) = HIGH_LEVEL_CALL, dest:poohContract(POOH), function:buy, arguments:['customerAddress'] value:msg.value ""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Deposit(msg.value,msg.sender)

IRs:
Emit Deposit(msg.value,msg.sender)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
msg.value > 1000000000000000

IRs:
TMP_6(bool) = msg.value > 1000000000000000
CONDITION TMP_6""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
extraTickets = SafeMath.div(msg.value,1000000000000000)

IRs:
TMP_7(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['msg.value', '1000000000000000'] 
extraTickets(uint256) := TMP_7(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
ticketNumber += extraTickets

IRs:
ticketNumber(uint256) = ticketNumber + extraTickets""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
ticketNumber >= winningNumber

IRs:
TMP_8(bool) = ticketNumber >= winningNumber
CONDITION TMP_8""];
9->10[label=""True""];
9->15[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
poohContract.exit()

IRs:
HIGH_LEVEL_CALL, dest:poohContract(POOH), function:exit, arguments:[]  ""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
payDev(owner)

IRs:
INTERNAL_CALL, Lottery.payDev(address)(owner)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
payWinner(customerAddress)

IRs:
INTERNAL_CALL, Lottery.payWinner(address)(customerAddress)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
poohContract.buy.value(address(this).balance)(customerAddress)

IRs:
TMP_12 = CONVERT this to address
TMP_13(uint256) = SOLIDITY_CALL balance(address)(TMP_12)
TMP_15(uint256) = HIGH_LEVEL_CALL, dest:poohContract(POOH), function:buy, arguments:['customerAddress'] value:TMP_13 ""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
resetLottery()

IRs:
INTERNAL_CALL, Lottery.resetLottery()()""];
14->16;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
ticketNumber ++

IRs:
TMP_17(uint256) := ticketNumber(uint256)
ticketNumber(uint256) = ticketNumber + 1""];
15->16;
16[label=""Node Type: END_IF 16
""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
isOpenToPublic()

IRs:
MODIFIER_CALL, Lottery.isOpenToPublic()()""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
onlyHuman()

IRs:
MODIFIER_CALL, Lottery.onlyHuman()()""];
18->1;
}
",1,0,0,0,"isOpenToPublic();require(bool)(msg.value >= 1000000000000000);customerAddress = msg.sender;poohContract.buy.value(msg.value)(customerAddress);Deposit(msg.value,msg.sender);msg.value > 1000000000000000;extraTickets = SafeMath.div(msg.value,1000000000000000);;ticketNumber += extraTickets;ticketNumber >= winningNumber;poohContract.exit();ticketNumber ++;payDev(owner);payWinner(customerAddress);poohContract.buy.value(address(this).balance)(customerAddress);resetLottery();;onlyHuman()"
./0x39de38ba63d172b962db2fc2ee5e4376287c50bf_ext.sol,ImmlaIco.importTokens,411,423,"TMP_163(bool) = msg.sender == tokenImporter,TMP_164(bool) = msg.sender == icoManager,TMP_165(bool) = TMP_163 || TMP_164,TMP_166(bool) = msg.sender == _account,TMP_167(bool) = TMP_165 || TMP_166,TMP_168(None) = SOLIDITY_CALL require(bool)(TMP_167),REF_68(bool) -> importedFromPreIco[_account],TMP_169 = UnaryType.BANG REF_68 ,TMP_170(None) = SOLIDITY_CALL require(bool)(TMP_169),TMP_171(uint256) = HIGH_LEVEL_CALL, dest:preIcoToken(AbstractToken), function:balanceOf, arguments:['_account']  ,preIcoBalance(uint256) := TMP_171(uint256),TMP_172(bool) = preIcoBalance > 0,CONDITION TMP_172,HIGH_LEVEL_CALL, dest:immlaToken(ImmlaToken), function:emitTokens, arguments:['_account', 'preIcoBalance']  ,TMP_174(uint256) = INTERNAL_CALL, SafeMath.add(uint256,uint256)(importedTokens,preIcoBalance),importedTokens(uint256) := TMP_174(uint256),REF_71(bool) -> importedFromPreIco[_account],REF_71(bool) (->importedFromPreIco) := True(bool)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tokenImporter || msg.sender == icoManager || msg.sender == _account)

IRs:
TMP_163(bool) = msg.sender == tokenImporter
TMP_164(bool) = msg.sender == icoManager
TMP_165(bool) = TMP_163 || TMP_164
TMP_166(bool) = msg.sender == _account
TMP_167(bool) = TMP_165 || TMP_166
TMP_168(None) = SOLIDITY_CALL require(bool)(TMP_167)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! importedFromPreIco[_account])

IRs:
REF_68(bool) -> importedFromPreIco[_account]
TMP_169 = UnaryType.BANG REF_68 
TMP_170(None) = SOLIDITY_CALL require(bool)(TMP_169)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
preIcoBalance = preIcoToken.balanceOf(_account)

IRs:
TMP_171(uint256) = HIGH_LEVEL_CALL, dest:preIcoToken(AbstractToken), function:balanceOf, arguments:['_account']  
preIcoBalance(uint256) := TMP_171(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
preIcoBalance > 0

IRs:
TMP_172(bool) = preIcoBalance > 0
CONDITION TMP_172""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
immlaToken.emitTokens(_account,preIcoBalance)

IRs:
HIGH_LEVEL_CALL, dest:immlaToken(ImmlaToken), function:emitTokens, arguments:['_account', 'preIcoBalance']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
importedTokens = add(importedTokens,preIcoBalance)

IRs:
TMP_174(uint256) = INTERNAL_CALL, SafeMath.add(uint256,uint256)(importedTokens,preIcoBalance)
importedTokens(uint256) := TMP_174(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
importedFromPreIco[_account] = true

IRs:
REF_71(bool) -> importedFromPreIco[_account]
REF_71(bool) (->importedFromPreIco) := True(bool)""];
}
",1,0,0,0,"require(bool)(msg.sender == tokenImporter || msg.sender == icoManager || msg.sender == _account);require(bool)(! importedFromPreIco[_account]);preIcoBalance = preIcoToken.balanceOf(_account);preIcoBalance > 0;immlaToken.emitTokens(_account,preIcoBalance);;importedTokens = add(importedTokens,preIcoBalance);importedFromPreIco[_account] = true"
./0x39f89421c5bf8bb0d855c0216b00b45e3733b515_ext.sol,DINOSale.withdrawToken,648,661,"TMP_263(uint256) = INTERNAL_CALL, DINOSale.convertToMini(uint256)(tokensToWithdraw),tokensInWei(uint256) := TMP_263(uint256),TMP_264(uint256) = HIGH_LEVEL_CALL, dest:tokenReward(DINOToken), function:balanceOf, arguments:['msg.sender']  ,TMP_265(bool) = tokensInWei <= TMP_264,TMP_266(None) = SOLIDITY_CALL require(bool,string)(TMP_265,You do not have sufficient balance to withdraw),TMP_267(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['tokensInWei', 'withdrawRate'] ,ethToGive(uint256) := TMP_267(uint256),TMP_268 = CONVERT this to address,TMP_269(uint256) = SOLIDITY_CALL balance(address)(TMP_268),TMP_270(bool) = ethToGive <= TMP_269,TMP_271(None) = SOLIDITY_CALL require(bool,string)(TMP_270,Insufficient ethers.),TMP_272 = CONVERT this to address,TMP_273(bool) = HIGH_LEVEL_CALL, dest:tokenReward(DINOToken), function:setAllowanceBeforeWithdrawal, arguments:['msg.sender', 'TMP_272', 'tokensInWei']  ,TMP_274(address) = HIGH_LEVEL_CALL, dest:tokenReward(DINOToken), function:owner, arguments:[]  ,TMP_275(bool) = HIGH_LEVEL_CALL, dest:tokenReward(DINOToken), function:transferFrom, arguments:['msg.sender', 'TMP_274', 'tokensInWei']  ,Transfer dest:msg.sender value:ethToGive,TMP_277(address) = HIGH_LEVEL_CALL, dest:this(address), function:owner, arguments:[]  ,Emit FundTransfer(TMP_277,ethToGive,True)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokensInWei = convertToMini(tokensToWithdraw)

IRs:
TMP_263(uint256) = INTERNAL_CALL, DINOSale.convertToMini(uint256)(tokensToWithdraw)
tokensInWei(uint256) := TMP_263(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(tokensInWei <= tokenReward.balanceOf(msg.sender),You do not have sufficient balance to withdraw)

IRs:
TMP_264(uint256) = HIGH_LEVEL_CALL, dest:tokenReward(DINOToken), function:balanceOf, arguments:['msg.sender']  
TMP_265(bool) = tokensInWei <= TMP_264
TMP_266(None) = SOLIDITY_CALL require(bool,string)(TMP_265,You do not have sufficient balance to withdraw)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
ethToGive = tokensInWei.div(withdrawRate)

IRs:
TMP_267(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['tokensInWei', 'withdrawRate'] 
ethToGive(uint256) := TMP_267(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool,string)(ethToGive <= address(this).balance,Insufficient ethers.)

IRs:
TMP_268 = CONVERT this to address
TMP_269(uint256) = SOLIDITY_CALL balance(address)(TMP_268)
TMP_270(bool) = ethToGive <= TMP_269
TMP_271(None) = SOLIDITY_CALL require(bool,string)(TMP_270,Insufficient ethers.)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
tokenReward.setAllowanceBeforeWithdrawal(msg.sender,address(this),tokensInWei)

IRs:
TMP_272 = CONVERT this to address
TMP_273(bool) = HIGH_LEVEL_CALL, dest:tokenReward(DINOToken), function:setAllowanceBeforeWithdrawal, arguments:['msg.sender', 'TMP_272', 'tokensInWei']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tokenReward.transferFrom(msg.sender,tokenReward.owner(),tokensInWei)

IRs:
TMP_274(address) = HIGH_LEVEL_CALL, dest:tokenReward(DINOToken), function:owner, arguments:[]  
TMP_275(bool) = HIGH_LEVEL_CALL, dest:tokenReward(DINOToken), function:transferFrom, arguments:['msg.sender', 'TMP_274', 'tokensInWei']  ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
msg.sender.transfer(ethToGive)

IRs:
Transfer dest:msg.sender value:ethToGive""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
FundTransfer(this.owner(),ethToGive,true)

IRs:
TMP_277(address) = HIGH_LEVEL_CALL, dest:this(address), function:owner, arguments:[]  
Emit FundTransfer(TMP_277,ethToGive,True)""];
}
",1,0,0,0,"tokensInWei = convertToMini(tokensToWithdraw);require(bool,string)(tokensInWei <= tokenReward.balanceOf(msg.sender),You do not have sufficient balance to withdraw);ethToGive = tokensInWei.div(withdrawRate);require(bool,string)(ethToGive <= address(this).balance,Insufficient ethers.);tokenReward.setAllowanceBeforeWithdrawal(msg.sender,address(this),tokensInWei);tokenReward.transferFrom(msg.sender,tokenReward.owner(),tokensInWei);msg.sender.transfer(ethToGive);FundTransfer(this.owner(),ethToGive,true)"
./0xb44a823579aa618b96d6f20a3330901e85f96f73_ext.sol,ClockAuction.bid,394,401,"TMP_133(uint256) = INTERNAL_CALL, ClockAuctionBase._bid(uint256,uint256)(_tokenId,msg.value),INTERNAL_CALL, ClockAuctionBase._transfer(address,uint256)(msg.sender,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_bid(_tokenId,msg.value)

IRs:
TMP_133(uint256) = INTERNAL_CALL, ClockAuctionBase._bid(uint256,uint256)(_tokenId,msg.value)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_transfer(msg.sender,_tokenId)

IRs:
INTERNAL_CALL, ClockAuctionBase._transfer(address,uint256)(msg.sender,_tokenId)""];
}
",1,0,0,0,"_bid(_tokenId,msg.value);_transfer(msg.sender,_tokenId)"
./0x6c26dab04c8f2bb07e60f205118e36850fe90981_ext.sol,PoWMLottery.donateToLottery,39,45,"TMP_0(uint256) = HIGH_LEVEL_CALL, dest:maths(POWM), function:myTokens, arguments:[]  ,tokens_before(uint256) := TMP_0(uint256),TMP_2(uint256) = HIGH_LEVEL_CALL, dest:maths(POWM), function:buy, arguments:['masternode_referrer'] value:msg.value ,TMP_3(uint256) = HIGH_LEVEL_CALL, dest:maths(POWM), function:myTokens, arguments:[]  ,tokens_after(uint256) := TMP_3(uint256),TMP_4(uint256) = HIGH_LEVEL_CALL, dest:maths(POWM), function:myTokens, arguments:[]  ,numTokensInLottery(uint256) := TMP_4(uint256),TMP_5(uint256) = tokens_after - tokens_before,RETURN TMP_5","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens_before = maths.myTokens()

IRs:
TMP_0(uint256) = HIGH_LEVEL_CALL, dest:maths(POWM), function:myTokens, arguments:[]  
tokens_before(uint256) := TMP_0(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
maths.buy.value(msg.value)(masternode_referrer)

IRs:
TMP_2(uint256) = HIGH_LEVEL_CALL, dest:maths(POWM), function:buy, arguments:['masternode_referrer'] value:msg.value ""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
tokens_after = maths.myTokens()

IRs:
TMP_3(uint256) = HIGH_LEVEL_CALL, dest:maths(POWM), function:myTokens, arguments:[]  
tokens_after(uint256) := TMP_3(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
numTokensInLottery = maths.myTokens()

IRs:
TMP_4(uint256) = HIGH_LEVEL_CALL, dest:maths(POWM), function:myTokens, arguments:[]  
numTokensInLottery(uint256) := TMP_4(uint256)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
tokens_after - tokens_before

IRs:
TMP_5(uint256) = tokens_after - tokens_before
RETURN TMP_5""];
}
",1,0,0,0,tokens_before = maths.myTokens();maths.buy.value(msg.value)(masternode_referrer);tokens_after = maths.myTokens();numTokensInLottery = maths.myTokens();tokens_after - tokens_before
./0x18da8521c333aed9de8f512e847734cb7be42e38_ext.sol,Crowdsale.finalize,310,325,"TMP_128(bool) = now < endTime,CONDITION TMP_128,TMP_129(bool) = coinSentToEther == MAX_CAP,CONDITION TMP_129,TMP_130(bool) = coinSentToEther < MIN_CAP,TMP_131(uint256) = endTime + 259200,TMP_132(bool) = now < TMP_131,TMP_133(bool) = TMP_130 && TMP_132,CONDITION TMP_133,REF_94(uint256) = SOLIDITY_CALL balance(address)(this),TMP_134 = SEND dest:multisigEther value:REF_94,TMP_135 = UnaryType.BANG TMP_134 ,CONDITION TMP_135,TMP_136(uint256) = HIGH_LEVEL_CALL, dest:coin(ProjectX), function:balanceOf, arguments:['this']  ,remains(uint256) := TMP_136(uint256),TMP_137(bool) = remains > 0,CONDITION TMP_137,TMP_138(bool) = HIGH_LEVEL_CALL, dest:coin(ProjectX), function:burn, arguments:['remains']  ,TMP_139 = UnaryType.BANG TMP_138 ,CONDITION TMP_139,crowdsaleClosed(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->19;
1[label=""Node Type: IF 1

EXPRESSION:
now < endTime

IRs:
TMP_128(bool) = now < endTime
CONDITION TMP_128""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
coinSentToEther == MAX_CAP

IRs:
TMP_129(bool) = coinSentToEther == MAX_CAP
CONDITION TMP_129""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: THROW 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
coinSentToEther < MIN_CAP && now < endTime + 259200

IRs:
TMP_130(bool) = coinSentToEther < MIN_CAP
TMP_131(uint256) = endTime + 259200
TMP_132(bool) = now < TMP_131
TMP_133(bool) = TMP_130 && TMP_132
CONDITION TMP_133""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: THROW 7
""];
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
! multisigEther.send(this.balance)

IRs:
REF_94(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_134 = SEND dest:multisigEther value:REF_94
TMP_135 = UnaryType.BANG TMP_134 
CONDITION TMP_135""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: THROW 10
""];
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
remains = coin.balanceOf(this)

IRs:
TMP_136(uint256) = HIGH_LEVEL_CALL, dest:coin(ProjectX), function:balanceOf, arguments:['this']  
remains(uint256) := TMP_136(uint256)""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
remains > 0

IRs:
TMP_137(bool) = remains > 0
CONDITION TMP_137""];
13->14[label=""True""];
13->17[label=""False""];
14[label=""Node Type: IF 14

EXPRESSION:
! coin.burn(remains)

IRs:
TMP_138(bool) = HIGH_LEVEL_CALL, dest:coin(ProjectX), function:burn, arguments:['remains']  
TMP_139 = UnaryType.BANG TMP_138 
CONDITION TMP_139""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: THROW 15
""];
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
crowdsaleClosed = true

IRs:
crowdsaleClosed(bool) := True(bool)""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
19->1;
}
",1,0,1,0,onlyOwner();now < endTime;coinSentToEther == MAX_CAP;;;;coinSentToEther < MIN_CAP && now < endTime + 259200;;;! multisigEther.send(this.balance);;;remains = coin.balanceOf(this);remains > 0;! coin.burn(remains);;;;crowdsaleClosed = true
./0x0e752b742f744fdc2d93774da44c37b72c3e6952_ext.sol,CraftyCrowdsale.generateTokens,540,548,"TMP_190 = CONVERT 0 to address,TMP_191(bool) = beneficiary != TMP_190,TMP_192(None) = SOLIDITY_CALL require(bool)(TMP_191),TMP_193(bool) = newTokens > 0,TMP_194(None) = SOLIDITY_CALL require(bool)(TMP_193),TMP_195(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['issuedTokens', 'newTokens'] ,TMP_196(bool) = TMP_195 <= hardCap,TMP_197(None) = SOLIDITY_CALL require(bool)(TMP_196),TMP_198(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['issuedTokens', 'newTokens'] ,issuedTokens(uint256) := TMP_198(uint256),TMP_199(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['beneficiary', 'newTokens']  ,Emit TokenPurchase(msg.sender,beneficiary,newTokens),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != address(0))

IRs:
TMP_190 = CONVERT 0 to address
TMP_191(bool) = beneficiary != TMP_190
TMP_192(None) = SOLIDITY_CALL require(bool)(TMP_191)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(newTokens > 0)

IRs:
TMP_193(bool) = newTokens > 0
TMP_194(None) = SOLIDITY_CALL require(bool)(TMP_193)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(issuedTokens.add(newTokens) <= hardCap)

IRs:
TMP_195(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['issuedTokens', 'newTokens'] 
TMP_196(bool) = TMP_195 <= hardCap
TMP_197(None) = SOLIDITY_CALL require(bool)(TMP_196)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
issuedTokens = issuedTokens.add(newTokens)

IRs:
TMP_198(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['issuedTokens', 'newTokens'] 
issuedTokens(uint256) := TMP_198(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
token.mint(beneficiary,newTokens)

IRs:
TMP_199(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['beneficiary', 'newTokens']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
TokenPurchase(msg.sender,beneficiary,newTokens)

IRs:
Emit TokenPurchase(msg.sender,beneficiary,newTokens)""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->1;
}
",1,0,0,0,"onlyOwner();require(bool)(beneficiary != address(0));require(bool)(newTokens > 0);require(bool)(issuedTokens.add(newTokens) <= hardCap);issuedTokens = issuedTokens.add(newTokens);token.mint(beneficiary,newTokens);TokenPurchase(msg.sender,beneficiary,newTokens)"
./0x020ddc98365d0199b4c7a2d769d685480789f67e_ext.sol,EOSclassic.claimEOSclassicFor,400,432,"TMP_117 = CONVERT 0 to address,TMP_118(bool) = _toAddress != TMP_117,TMP_119(None) = SOLIDITY_CALL require(bool)(TMP_118),TMP_120(bool) = INTERNAL_CALL, EOSclassic.isClaimed(address)(_toAddress),TMP_121(bool) = TMP_120 == False,TMP_122(None) = SOLIDITY_CALL require(bool)(TMP_121),TMP_123(uint256) = INTERNAL_CALL, EOSclassic.queryEOSTokenBalance(address)(_toAddress),_eosContractBalance(uint256) := TMP_123(uint256),TMP_124(bool) = _eosContractBalance > 0,TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124),TMP_126 = CONVERT this to address,REF_103(uint256) -> balances[TMP_126],TMP_127(bool) = _eosContractBalance <= REF_103,TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127),REF_104(bool) -> eosClassicClaimed[_toAddress],REF_104(bool) (->eosClassicClaimed) := True(bool),TMP_129 = CONVERT this to address,REF_105(uint256) -> balances[TMP_129],TMP_130 = CONVERT this to address,REF_106(uint256) -> balances[TMP_130],TMP_131(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_106', '_eosContractBalance'] ,REF_105(uint256) (->balances) := TMP_131(uint256),REF_108(uint256) -> balances[_toAddress],REF_109(uint256) -> balances[_toAddress],TMP_132(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_109', '_eosContractBalance'] ,REF_108(uint256) (->balances) := TMP_132(uint256),TMP_133 = CONVERT this to address,Emit Transfer(TMP_133,_toAddress,_eosContractBalance),Emit LogClaim(_toAddress,_eosContractBalance),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_toAddress != address(0))

IRs:
TMP_117 = CONVERT 0 to address
TMP_118(bool) = _toAddress != TMP_117
TMP_119(None) = SOLIDITY_CALL require(bool)(TMP_118)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(isClaimed(_toAddress) == false)

IRs:
TMP_120(bool) = INTERNAL_CALL, EOSclassic.isClaimed(address)(_toAddress)
TMP_121(bool) = TMP_120 == False
TMP_122(None) = SOLIDITY_CALL require(bool)(TMP_121)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
_eosContractBalance = queryEOSTokenBalance(_toAddress)

IRs:
TMP_123(uint256) = INTERNAL_CALL, EOSclassic.queryEOSTokenBalance(address)(_toAddress)
_eosContractBalance(uint256) := TMP_123(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_eosContractBalance > 0)

IRs:
TMP_124(bool) = _eosContractBalance > 0
TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(_eosContractBalance <= balances[address(this)])

IRs:
TMP_126 = CONVERT this to address
REF_103(uint256) -> balances[TMP_126]
TMP_127(bool) = _eosContractBalance <= REF_103
TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
eosClassicClaimed[_toAddress] = true

IRs:
REF_104(bool) -> eosClassicClaimed[_toAddress]
REF_104(bool) (->eosClassicClaimed) := True(bool)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[address(this)] = balances[address(this)].sub(_eosContractBalance)

IRs:
TMP_129 = CONVERT this to address
REF_105(uint256) -> balances[TMP_129]
TMP_130 = CONVERT this to address
REF_106(uint256) -> balances[TMP_130]
TMP_131(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_106', '_eosContractBalance'] 
REF_105(uint256) (->balances) := TMP_131(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[_toAddress] = balances[_toAddress].add(_eosContractBalance)

IRs:
REF_108(uint256) -> balances[_toAddress]
REF_109(uint256) -> balances[_toAddress]
TMP_132(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_109', '_eosContractBalance'] 
REF_108(uint256) (->balances) := TMP_132(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
Transfer(address(this),_toAddress,_eosContractBalance)

IRs:
TMP_133 = CONVERT this to address
Emit Transfer(TMP_133,_toAddress,_eosContractBalance)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
LogClaim(_toAddress,_eosContractBalance)

IRs:
Emit LogClaim(_toAddress,_eosContractBalance)""];
10->11;
11[label=""Node Type: RETURN 11

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,"require(bool)(_toAddress != address(0));require(bool)(isClaimed(_toAddress) == false);_eosContractBalance = queryEOSTokenBalance(_toAddress);require(bool)(_eosContractBalance > 0);require(bool)(_eosContractBalance <= balances[address(this)]);eosClassicClaimed[_toAddress] = true;balances[address(this)] = balances[address(this)].sub(_eosContractBalance);balances[_toAddress] = balances[_toAddress].add(_eosContractBalance);Transfer(address(this),_toAddress,_eosContractBalance);LogClaim(_toAddress,_eosContractBalance);true"
./0x51c22c78d753939c8aebae437c2f18eee43ca296_ext.sol,PrivateSale.buyTokens,250,256,"TMP_151(bool) = msg.sender == buyer,TMP_152(None) = SOLIDITY_CALL require(bool)(TMP_151),TMP_153(bool) = msg.value >= priceInWei,TMP_154(None) = SOLIDITY_CALL require(bool)(TMP_153),INTERNAL_CALL, PrivateSale.transferWeiToWallet()(),INTERNAL_CALL, PrivateSale.issueTokensToBuyer()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == buyer)

IRs:
TMP_151(bool) = msg.sender == buyer
TMP_152(None) = SOLIDITY_CALL require(bool)(TMP_151)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.value >= priceInWei)

IRs:
TMP_153(bool) = msg.value >= priceInWei
TMP_154(None) = SOLIDITY_CALL require(bool)(TMP_153)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
transferWeiToWallet()

IRs:
INTERNAL_CALL, PrivateSale.transferWeiToWallet()()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
issueTokensToBuyer()

IRs:
INTERNAL_CALL, PrivateSale.issueTokensToBuyer()()""];
}
",1,0,0,0,require(bool)(msg.sender == buyer);require(bool)(msg.value >= priceInWei);transferWeiToWallet();issueTokensToBuyer()
./0x750c1d91864171d7e1715a6b53ee28c72b8faa09_ext.sol,EthicHubUser.registerLocalNode,143,154,"TMP_58 = CONVERT 0 to address,TMP_59(bool) = target != TMP_58,TMP_60(None) = SOLIDITY_CALL require(bool)(TMP_59),TMP_61(bytes32) = SOLIDITY_CALL keccak256()(user,localNode,target),TMP_62(bool) = HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:getBool, arguments:['TMP_61']  ,isRegistered(bool) := TMP_62(bool),TMP_63 = UnaryType.BANG isRegistered ,CONDITION TMP_63,INTERNAL_CALL, EthicHubUser.changeUserStatus(address,string,bool)(target,localNode,True),TMP_65(bytes32) = SOLIDITY_CALL keccak256()(contract.name,reputation),TMP_66(address) = HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:getAddress, arguments:['TMP_65']  ,TMP_67 = CONVERT TMP_66 to EthicHubReputationInterface,rep(EthicHubReputationInterface) := TMP_67(EthicHubReputationInterface),HIGH_LEVEL_CALL, dest:rep(EthicHubReputationInterface), function:initLocalNodeReputation, arguments:['target']  ,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(target != address(0))

IRs:
TMP_58 = CONVERT 0 to address
TMP_59(bool) = target != TMP_58
TMP_60(None) = SOLIDITY_CALL require(bool)(TMP_59)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
isRegistered = ethicHubStorage.getBool(keccak256()(user,localNode,target))

IRs:
TMP_61(bytes32) = SOLIDITY_CALL keccak256()(user,localNode,target)
TMP_62(bool) = HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:getBool, arguments:['TMP_61']  
isRegistered(bool) := TMP_62(bool)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
! isRegistered

IRs:
TMP_63 = UnaryType.BANG isRegistered 
CONDITION TMP_63""];
3->4[label=""True""];
3->7[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
changeUserStatus(target,localNode,true)

IRs:
INTERNAL_CALL, EthicHubUser.changeUserStatus(address,string,bool)(target,localNode,True)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
rep = EthicHubReputationInterface(ethicHubStorage.getAddress(keccak256()(contract.name,reputation)))

IRs:
TMP_65(bytes32) = SOLIDITY_CALL keccak256()(contract.name,reputation)
TMP_66(address) = HIGH_LEVEL_CALL, dest:ethicHubStorage(EthicHubStorageInterface), function:getAddress, arguments:['TMP_65']  
TMP_67 = CONVERT TMP_66 to EthicHubReputationInterface
rep(EthicHubReputationInterface) := TMP_67(EthicHubReputationInterface)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
rep.initLocalNodeReputation(target)

IRs:
HIGH_LEVEL_CALL, dest:rep(EthicHubReputationInterface), function:initLocalNodeReputation, arguments:['target']  ""];
6->7;
7[label=""Node Type: END_IF 7
""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
8->1;
}
",1,0,0,0,"onlyOwner();require(bool)(target != address(0));isRegistered = ethicHubStorage.getBool(keccak256()(user,localNode,target));! isRegistered;changeUserStatus(target,localNode,true);;rep = EthicHubReputationInterface(ethicHubStorage.getAddress(keccak256()(contract.name,reputation)));rep.initLocalNodeReputation(target)"
./0x470142a1834438515b757118f322703aba6e1e05_ext.sol,PolicyPalNetworkAirdrop.signatureDropSingleAmount,224,244,"i(uint256) := 0(uint256),REF_30 -> LENGTH _recipients,TMP_42(bool) = i < REF_30,CONDITION TMP_42,REF_31(address) -> _recipients[i],recipient(address) := REF_31(address),REF_32(bool) -> signaturedrops[recipient],TMP_43 = UnaryType.BANG REF_32 ,CONDITION TMP_43,TMP_44(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', '_amount']  ,TMP_45(None) = SOLIDITY_CALL assert(bool)(TMP_44),REF_34(bool) -> signaturedrops[recipient],REF_34(bool) (->signaturedrops) := True(bool),TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] ,numDrops(uint256) := TMP_46(uint256),TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', '_amount'] ,dropAmount(uint256) := TMP_47(uint256),Emit TokenDrop(recipient,_amount,SIGNATURE),TMP_49(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()(),MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalance(address[],uint256)(_recipients,_amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _recipients.length

IRs:
REF_30 -> LENGTH _recipients
TMP_42(bool) = i < REF_30
CONDITION TMP_42""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
recipient = _recipients[i]

IRs:
REF_31(address) -> _recipients[i]
recipient(address) := REF_31(address)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
! signaturedrops[recipient]

IRs:
REF_32(bool) -> signaturedrops[recipient]
TMP_43 = UnaryType.BANG REF_32 
CONDITION TMP_43""];
6->7[label=""True""];
6->12[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(token.transfer(recipient,_amount))

IRs:
TMP_44(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', '_amount']  
TMP_45(None) = SOLIDITY_CALL assert(bool)(TMP_44)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
signaturedrops[recipient] = true

IRs:
REF_34(bool) -> signaturedrops[recipient]
REF_34(bool) (->signaturedrops) := True(bool)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
numDrops = numDrops.add(1)

IRs:
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] 
numDrops(uint256) := TMP_46(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
dropAmount = dropAmount.add(_amount)

IRs:
TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', '_amount'] 
dropAmount(uint256) := TMP_47(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
TokenDrop(recipient,_amount,SIGNATURE)

IRs:
Emit TokenDrop(recipient,_amount,SIGNATURE)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
i ++

IRs:
TMP_49(uint256) := i(uint256)
i(uint256) = i + 1""];
13->4;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()()""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
validBalance(_recipients,_amount)

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalance(address[],uint256)(_recipients,_amount)""];
15->3;
}
",1,0,0,0,"onlyAdmin();;i < _recipients.length;;i = 0;recipient = _recipients[i];! signaturedrops[recipient];assert(bool)(token.transfer(recipient,_amount));;signaturedrops[recipient] = true;numDrops = numDrops.add(1);dropAmount = dropAmount.add(_amount);TokenDrop(recipient,_amount,SIGNATURE);i ++;validBalance(_recipients,_amount)"
./0xebbdf302c940c6bfd49c6b165f457fdb324649bc_ext.sol,HydroToken.authenticate,219,223,"TMP_54 = CONVERT raindropAddress to Raindrop,raindrop(Raindrop) := TMP_54(Raindrop),HIGH_LEVEL_CALL, dest:raindrop(Raindrop), function:authenticate, arguments:['msg.sender', '_value', '_challenge', '_partnerId']  ,INTERNAL_CALL, HydroToken.doTransfer(address,address,uint256)(msg.sender,owner,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
raindrop = Raindrop(raindropAddress)

IRs:
TMP_54 = CONVERT raindropAddress to Raindrop
raindrop(Raindrop) := TMP_54(Raindrop)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
raindrop.authenticate(msg.sender,_value,_challenge,_partnerId)

IRs:
HIGH_LEVEL_CALL, dest:raindrop(Raindrop), function:authenticate, arguments:['msg.sender', '_value', '_challenge', '_partnerId']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
doTransfer(msg.sender,owner,_value)

IRs:
INTERNAL_CALL, HydroToken.doTransfer(address,address,uint256)(msg.sender,owner,_value)""];
}
",1,0,0,0,"raindrop = Raindrop(raindropAddress);raindrop.authenticate(msg.sender,_value,_challenge,_partnerId);doTransfer(msg.sender,owner,_value)"
./0x01e0f57c42bf976676ea1daa1b04d69aba6bdaf3_ext.sol,BatchTransferWallet.withdraw,164,171,"TMP_49 = CONVERT _tokenAddress to ERC20BasicInterface,token(ERC20BasicInterface) := TMP_49(ERC20BasicInterface),TMP_50(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20BasicInterface), function:balanceOf, arguments:['this']  ,tokenBalanceOfContract(uint256) := TMP_50(uint256),TMP_51 = CONVERT 0 to address,TMP_52(bool) = _address != TMP_51,TMP_53(bool) = tokenBalanceOfContract > 0,TMP_54(bool) = TMP_52 && TMP_53,TMP_55(None) = SOLIDITY_CALL require(bool)(TMP_54),TMP_56(bool) = HIGH_LEVEL_CALL, dest:token(ERC20BasicInterface), function:transfer, arguments:['_address', 'tokenBalanceOfContract']  ,TMP_57(None) = SOLIDITY_CALL require(bool)(TMP_56),Emit LogWithdrawal(_address,tokenBalanceOfContract),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
token = ERC20BasicInterface(_tokenAddress)

IRs:
TMP_49 = CONVERT _tokenAddress to ERC20BasicInterface
token(ERC20BasicInterface) := TMP_49(ERC20BasicInterface)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
tokenBalanceOfContract = token.balanceOf(this)

IRs:
TMP_50(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20BasicInterface), function:balanceOf, arguments:['this']  
tokenBalanceOfContract(uint256) := TMP_50(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_address != address(0) && tokenBalanceOfContract > 0)

IRs:
TMP_51 = CONVERT 0 to address
TMP_52(bool) = _address != TMP_51
TMP_53(bool) = tokenBalanceOfContract > 0
TMP_54(bool) = TMP_52 && TMP_53
TMP_55(None) = SOLIDITY_CALL require(bool)(TMP_54)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(token.transfer(_address,tokenBalanceOfContract))

IRs:
TMP_56(bool) = HIGH_LEVEL_CALL, dest:token(ERC20BasicInterface), function:transfer, arguments:['_address', 'tokenBalanceOfContract']  
TMP_57(None) = SOLIDITY_CALL require(bool)(TMP_56)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
LogWithdrawal(_address,tokenBalanceOfContract)

IRs:
Emit LogWithdrawal(_address,tokenBalanceOfContract)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",1,0,0,0,"onlyOwner();token = ERC20BasicInterface(_tokenAddress);tokenBalanceOfContract = token.balanceOf(this);require(bool)(_address != address(0) && tokenBalanceOfContract > 0);require(bool)(token.transfer(_address,tokenBalanceOfContract));LogWithdrawal(_address,tokenBalanceOfContract)"
./0x0e752b742f744fdc2d93774da44c37b72c3e6952_ext.sol,CraftyCrowdsale.finishCrowdsale,553,562,"TMP_202(bool) = now > saleEnd,TMP_203(None) = SOLIDITY_CALL require(bool)(TMP_202),TMP_204(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['hardCap', 'issuedTokens'] ,unspentTokens(uint256) := TMP_204(uint256),TMP_205(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['fundWallet', 'unspentTokens']  ,REF_86(CraftyCrowdsale.State) -> State.CLOSED,currentState(CraftyCrowdsale.State) := REF_86(CraftyCrowdsale.State),TMP_206(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:finishMinting, arguments:[]  ,MODIFIER_CALL, Ownable.onlyOwner()(),REF_88(CraftyCrowdsale.State) -> State.SALE,MODIFIER_CALL, CraftyCrowdsale.inState(CraftyCrowdsale.State)(REF_88)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now > saleEnd)

IRs:
TMP_202(bool) = now > saleEnd
TMP_203(None) = SOLIDITY_CALL require(bool)(TMP_202)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
unspentTokens = hardCap.sub(issuedTokens)

IRs:
TMP_204(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['hardCap', 'issuedTokens'] 
unspentTokens(uint256) := TMP_204(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
token.mint(fundWallet,unspentTokens)

IRs:
TMP_205(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['fundWallet', 'unspentTokens']  ""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
currentState = State.CLOSED

IRs:
REF_86(CraftyCrowdsale.State) -> State.CLOSED
currentState(CraftyCrowdsale.State) := REF_86(CraftyCrowdsale.State)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
token.finishMinting()

IRs:
TMP_206(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:finishMinting, arguments:[]  ""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
inState(State.SALE)

IRs:
REF_88(CraftyCrowdsale.State) -> State.SALE
MODIFIER_CALL, CraftyCrowdsale.inState(CraftyCrowdsale.State)(REF_88)""];
7->1;
}
",1,0,0,0,"onlyOwner();require(bool)(now > saleEnd);unspentTokens = hardCap.sub(issuedTokens);token.mint(fundWallet,unspentTokens);currentState = State.CLOSED;token.finishMinting();inState(State.SALE)"
./0x019e41a2acdffafc0303e840fbd7934234e68f45_ext.sol,contractDeployer.deployCrowdsale,115,118,"TMP_23(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transferFrom, arguments:['msg.sender', 'owner', 'crowdsaleFee']  ,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),TMP_25(address) = HIGH_LEVEL_CALL, dest:cdep(cDeployer), function:deployCrowdsale, arguments:['_eWallet', '_token', '_tWallet', '_maxETH', 'msg.sender']  ,Emit ContractCreated(TMP_25)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(token.transferFrom(msg.sender,owner,crowdsaleFee))

IRs:
TMP_23(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transferFrom, arguments:['msg.sender', 'owner', 'crowdsaleFee']  
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ContractCreated(cdep.deployCrowdsale(_eWallet,_token,_tWallet,_maxETH,msg.sender))

IRs:
TMP_25(address) = HIGH_LEVEL_CALL, dest:cdep(cDeployer), function:deployCrowdsale, arguments:['_eWallet', '_token', '_tWallet', '_maxETH', 'msg.sender']  
Emit ContractCreated(TMP_25)""];
}
",1,0,0,0,"require(bool)(token.transferFrom(msg.sender,owner,crowdsaleFee));ContractCreated(cdep.deployCrowdsale(_eWallet,_token,_tWallet,_maxETH,msg.sender))"
./0x0dae7caf45d9c473a8f6ae0d4934e5c3b2dbc371_ext.sol,SafeGuardsToken.transfer,426,438,"TMP_188 = CONVERT 0 to address,TMP_189(bool) = _to != TMP_188,TMP_190(None) = SOLIDITY_CALL require(bool)(TMP_189),REF_182(uint256) -> balances[msg.sender],TMP_191(bool) = _value <= REF_182,TMP_192(None) = SOLIDITY_CALL require(bool)(TMP_191),REF_183(uint256) -> balances[msg.sender],REF_184(uint256) -> balances[msg.sender],TMP_193(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_184', '_value'] ,REF_183(uint256) (->balances) := TMP_193(uint256),REF_186(uint256) -> balances[_to],REF_187(uint256) -> balances[_to],TMP_194(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_187', '_value'] ,REF_186(uint256) (->balances) := TMP_194(uint256),Emit Transfer(msg.sender,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_188 = CONVERT 0 to address
TMP_189(bool) = _to != TMP_188
TMP_190(None) = SOLIDITY_CALL require(bool)(TMP_189)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_182(uint256) -> balances[msg.sender]
TMP_191(bool) = _value <= REF_182
TMP_192(None) = SOLIDITY_CALL require(bool)(TMP_191)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_183(uint256) -> balances[msg.sender]
REF_184(uint256) -> balances[msg.sender]
TMP_193(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_184', '_value'] 
REF_183(uint256) (->balances) := TMP_193(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_186(uint256) -> balances[_to]
REF_187(uint256) -> balances[_to]
TMP_194(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_187', '_value'] 
REF_186(uint256) (->balances) := TMP_194(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
}
",1,0,0,0,"require(bool)(_to != address(0));require(bool)(_value <= balances[msg.sender]);balances[msg.sender] = balances[msg.sender].sub(_value);balances[_to] = balances[_to].add(_value);Transfer(msg.sender,_to,_value);true"
./0x56ffb3c578906ba9658fccb052fc1a5672275b6a_ext.sol,OpiriaCrowdsale.unlockTokenTransfers,1097,1103,"TMP_622(None) = SOLIDITY_CALL require(bool)(isFinalized),TMP_623(uint256) = closingTime + 2592000,TMP_624(bool) = now > TMP_623,TMP_625(None) = SOLIDITY_CALL require(bool)(TMP_624),TMP_626 = CONVERT token to PausableToken,TMP_627(bool) = HIGH_LEVEL_CALL, dest:TMP_626(PausableToken), function:paused, arguments:[]  ,TMP_628(None) = SOLIDITY_CALL require(bool)(TMP_627),TMP_629(uint256) = now + 2592000,bonusUnlockTime(uint256) := TMP_629(uint256),TMP_630 = CONVERT token to PausableToken,HIGH_LEVEL_CALL, dest:TMP_630(PausableToken), function:unpause, arguments:[]  ,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isFinalized)

IRs:
TMP_622(None) = SOLIDITY_CALL require(bool)(isFinalized)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(now > closingTime + 2592000)

IRs:
TMP_623(uint256) = closingTime + 2592000
TMP_624(bool) = now > TMP_623
TMP_625(None) = SOLIDITY_CALL require(bool)(TMP_624)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(PausableToken(token).paused())

IRs:
TMP_626 = CONVERT token to PausableToken
TMP_627(bool) = HIGH_LEVEL_CALL, dest:TMP_626(PausableToken), function:paused, arguments:[]  
TMP_628(None) = SOLIDITY_CALL require(bool)(TMP_627)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
bonusUnlockTime = now + 2592000

IRs:
TMP_629(uint256) = now + 2592000
bonusUnlockTime(uint256) := TMP_629(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
PausableToken(token).unpause()

IRs:
TMP_630 = CONVERT token to PausableToken
HIGH_LEVEL_CALL, dest:TMP_630(PausableToken), function:unpause, arguments:[]  ""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",1,0,0,0,onlyOwner();require(bool)(isFinalized);require(bool)(now > closingTime + 2592000);require(bool)(PausableToken(token).paused());bonusUnlockTime = now + 2592000;PausableToken(token).unpause()
./0x6c602f1798a453f90f249e208e2b64c7c09226f7_ext.sol,Mentoring.changeLevelPrice,385,390,"TMP_118(bool) = _levelPrice > 0,TMP_119(None) = SOLIDITY_CALL require(bool)(TMP_118),TMP_120(bool) = INTERNAL_CALL, Mentoring.isMentor(uint256)(_mentorId),TMP_121(None) = SOLIDITY_CALL require(bool)(TMP_120),REF_17(uint256) -> prices[_mentorId],REF_17(uint256) (->prices) := _levelPrice(uint256),Emit ChangeLevelPrice(_mentorId,_levelPrice),MODIFIER_CALL, Mentoring.onlyOwnerOf(uint256)(_mentorId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_levelPrice > 0)

IRs:
TMP_118(bool) = _levelPrice > 0
TMP_119(None) = SOLIDITY_CALL require(bool)(TMP_118)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(isMentor(_mentorId))

IRs:
TMP_120(bool) = INTERNAL_CALL, Mentoring.isMentor(uint256)(_mentorId)
TMP_121(None) = SOLIDITY_CALL require(bool)(TMP_120)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
prices[_mentorId] = _levelPrice

IRs:
REF_17(uint256) -> prices[_mentorId]
REF_17(uint256) (->prices) := _levelPrice(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ChangeLevelPrice(_mentorId,_levelPrice)

IRs:
Emit ChangeLevelPrice(_mentorId,_levelPrice)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwnerOf(_mentorId)

IRs:
MODIFIER_CALL, Mentoring.onlyOwnerOf(uint256)(_mentorId)""];
5->1;
}
",1,0,0,0,"onlyOwnerOf(_mentorId);require(bool)(_levelPrice > 0);require(bool)(isMentor(_mentorId));prices[_mentorId] = _levelPrice;ChangeLevelPrice(_mentorId,_levelPrice)"
./0x031e8de47dee0fdde1969a93b64bb8f8fbcba65d_ext.sol,lockEtherPay.release,100,108,"TMP_35(None) = SOLIDITY_CALL require(bool)(isLocked),TMP_36 = UnaryType.BANG isReleased ,TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36),TMP_38(bool) = INTERNAL_CALL, lockEtherPay.lockOver()(),TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38),TMP_40(uint256) = INTERNAL_CALL, lockEtherPay.tokenBalance()(),token_amount(uint256) := TMP_40(uint256),TMP_41(bool) = HIGH_LEVEL_CALL, dest:token_reward(token), function:transfer, arguments:['beneficiary', 'token_amount']  ,Emit TokenReleased(beneficiary,token_amount),isReleased(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isLocked)

IRs:
TMP_35(None) = SOLIDITY_CALL require(bool)(isLocked)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! isReleased)

IRs:
TMP_36 = UnaryType.BANG isReleased 
TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(lockOver())

IRs:
TMP_38(bool) = INTERNAL_CALL, lockEtherPay.lockOver()()
TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
token_amount = tokenBalance()

IRs:
TMP_40(uint256) = INTERNAL_CALL, lockEtherPay.tokenBalance()()
token_amount(uint256) := TMP_40(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
token_reward.transfer(beneficiary,token_amount)

IRs:
TMP_41(bool) = HIGH_LEVEL_CALL, dest:token_reward(token), function:transfer, arguments:['beneficiary', 'token_amount']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
TokenReleased(beneficiary,token_amount)

IRs:
Emit TokenReleased(beneficiary,token_amount)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
isReleased = true

IRs:
isReleased(bool) := True(bool)""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
8->1;
}
",1,0,0,0,"onlyOwner();require(bool)(isLocked);require(bool)(! isReleased);require(bool)(lockOver());token_amount = tokenBalance();token_reward.transfer(beneficiary,token_amount);TokenReleased(beneficiary,token_amount);isReleased = true"
./0x4c13184721de2d1b47a8875775ba3ce0b2e00ee0_ext.sol,SharkPool.claim,297,314,"TMP_78(bool) = HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:checkWinning, arguments:['_blockNumber']  ,TMP_79(None) = SOLIDITY_CALL require(bool)(TMP_78),TMP_80(uint256) = HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:balanceOf, arguments:['this']  ,initial_balance(uint256) := TMP_80(uint256),HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:claim, arguments:['_blockNumber', 'this']  ,TMP_82(uint256) = HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_82(uint256),REF_53(uint256) -> attempts[_blockNumber],total_attempt(uint256) := REF_53(uint256),TMP_83(uint256) = balance - initial_balance,INTERNAL_CALL, SharkPool.distribute_reward(uint256,uint256)(total_attempt,TMP_83),TMP_85(uint256) = claimed_blocks + 1,claimed_blocks(uint256) := TMP_85(uint256),MODIFIER_CALL, ReentrancyGuard.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(base_contract.checkWinning(_blockNumber))

IRs:
TMP_78(bool) = HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:checkWinning, arguments:['_blockNumber']  
TMP_79(None) = SOLIDITY_CALL require(bool)(TMP_78)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
initial_balance = base_contract.balanceOf(this)

IRs:
TMP_80(uint256) = HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:balanceOf, arguments:['this']  
initial_balance(uint256) := TMP_80(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
base_contract.claim(_blockNumber,this)

IRs:
HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:claim, arguments:['_blockNumber', 'this']  ""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
balance = base_contract.balanceOf(this)

IRs:
TMP_82(uint256) = HIGH_LEVEL_CALL, dest:base_contract(BitcoineumInterface), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_82(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
total_attempt = attempts[_blockNumber]

IRs:
REF_53(uint256) -> attempts[_blockNumber]
total_attempt(uint256) := REF_53(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
distribute_reward(total_attempt,balance - initial_balance)

IRs:
TMP_83(uint256) = balance - initial_balance
INTERNAL_CALL, SharkPool.distribute_reward(uint256,uint256)(total_attempt,TMP_83)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
claimed_blocks = claimed_blocks + 1

IRs:
TMP_85(uint256) = claimed_blocks + 1
claimed_blocks(uint256) := TMP_85(uint256)""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, ReentrancyGuard.nonReentrant()()""];
8->1;
}
",1,0,0,0,"nonReentrant();require(bool)(base_contract.checkWinning(_blockNumber));initial_balance = base_contract.balanceOf(this);base_contract.claim(_blockNumber,this);balance = base_contract.balanceOf(this);total_attempt = attempts[_blockNumber];distribute_reward(total_attempt,balance - initial_balance);claimed_blocks = claimed_blocks + 1"
./0xebcf88fb2783bbb75b12df3f33627efa894afea4_ext.sol,SPACEDICE.bet,70,97,"TMP_14(bool) = tx.origin == msg.sender,TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14),TMP_16(bool) = _diceOne > 0,TMP_17(bool) = _diceOne <= 6,TMP_18(bool) = TMP_16 && TMP_17,TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18),TMP_20(bool) = _diceTwo > 0,TMP_21(bool) = _diceTwo <= 6,TMP_22(bool) = TMP_20 && TMP_21,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),TMP_24(bool) = msg.value >= minBet,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),TMP_26(uint256) = INTERNAL_CALL, usingNRE.ra()(),TMP_27(uint256) = TMP_26 % 6,TMP_28(uint256) = TMP_27 + 1,rollone(uint256) := TMP_28(uint256),TMP_29(uint256) = INTERNAL_CALL, usingNRE.rx()(),TMP_30(uint256) = TMP_29 % 6,TMP_31(uint256) = TMP_30 + 1,rolltwo(uint256) := TMP_31(uint256),TMP_32(uint256) = rollone + rolltwo,totalroll(uint256) := TMP_32(uint256),TMP_33(uint256) = _diceOne + _diceTwo,totaldice(uint256) := TMP_33(uint256),TMP_34(bool) = totaldice == totalroll,CONDITION TMP_34,amountWon(uint256) := msg.value(uint256),TMP_35(bool) = rollone != rolltwo,TMP_36(bool) = _diceOne == _diceTwo,TMP_37(bool) = TMP_35 && TMP_36,CONDITION TMP_37,Emit Roll(False,_diceOne,_diceTwo,rollone,rolltwo,0),TMP_39(bool) = totalroll == 7,CONDITION TMP_39,TMP_40(uint256) = msg.value * 5,amountWon(uint256) := TMP_40(uint256),TMP_41(bool) = totalroll == 6,TMP_42(bool) = totalroll == 8,TMP_43(bool) = TMP_41 || TMP_42,CONDITION TMP_43,TMP_44(uint256) = msg.value * 6,amountWon(uint256) := TMP_44(uint256),TMP_45(bool) = totalroll == 5,TMP_46(bool) = totalroll == 9,TMP_47(bool) = TMP_45 || TMP_46,CONDITION TMP_47,TMP_48(uint256) = msg.value * 8,amountWon(uint256) := TMP_48(uint256),TMP_49(bool) = totalroll == 4,TMP_50(bool) = totalroll == 10,TMP_51(bool) = TMP_49 || TMP_50,CONDITION TMP_51,TMP_52(uint256) = msg.value * 10,amountWon(uint256) := TMP_52(uint256),TMP_53(bool) = totalroll == 3,TMP_54(bool) = totalroll == 11,TMP_55(bool) = TMP_53 || TMP_54,CONDITION TMP_55,TMP_56(uint256) = msg.value * 16,amountWon(uint256) := TMP_56(uint256),TMP_57(bool) = rollone == rolltwo,TMP_58(bool) = _diceOne == _diceTwo,TMP_59(bool) = TMP_57 && TMP_58,CONDITION TMP_59,TMP_60(uint256) = msg.value * 30,amountWon(uint256) := TMP_60(uint256),TMP_61(bool) = totalroll == 2,TMP_62(bool) = totalroll == 12,TMP_63(bool) = TMP_61 || TMP_62,CONDITION TMP_63,TMP_64(uint256) = msg.value * 33,amountWon(uint256) := TMP_64(uint256),TMP_65 = SEND dest:msg.sender value:amountWon,TMP_66 = UnaryType.BANG TMP_65 ,CONDITION TMP_66,TMP_67(None) = SOLIDITY_CALL revert()(),Emit Roll(True,_diceOne,_diceTwo,rollone,rolltwo,amountWon),Emit Roll(False,_diceOne,_diceTwo,rollone,rolltwo,0)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(tx.origin == msg.sender)

IRs:
TMP_14(bool) = tx.origin == msg.sender
TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_diceOne > 0 && _diceOne <= 6)

IRs:
TMP_16(bool) = _diceOne > 0
TMP_17(bool) = _diceOne <= 6
TMP_18(bool) = TMP_16 && TMP_17
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_diceTwo > 0 && _diceTwo <= 6)

IRs:
TMP_20(bool) = _diceTwo > 0
TMP_21(bool) = _diceTwo <= 6
TMP_22(bool) = TMP_20 && TMP_21
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(msg.value >= minBet)

IRs:
TMP_24(bool) = msg.value >= minBet
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
rollone = ra() % 6 + 1

IRs:
TMP_26(uint256) = INTERNAL_CALL, usingNRE.ra()()
TMP_27(uint256) = TMP_26 % 6
TMP_28(uint256) = TMP_27 + 1
rollone(uint256) := TMP_28(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
rolltwo = rx() % 6 + 1

IRs:
TMP_29(uint256) = INTERNAL_CALL, usingNRE.rx()()
TMP_30(uint256) = TMP_29 % 6
TMP_31(uint256) = TMP_30 + 1
rolltwo(uint256) := TMP_31(uint256)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
totalroll = rollone + rolltwo

IRs:
TMP_32(uint256) = rollone + rolltwo
totalroll(uint256) := TMP_32(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
totaldice = _diceOne + _diceTwo

IRs:
TMP_33(uint256) = _diceOne + _diceTwo
totaldice(uint256) := TMP_33(uint256)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
totaldice == totalroll

IRs:
TMP_34(bool) = totaldice == totalroll
CONDITION TMP_34""];
9->10[label=""True""];
9->39[label=""False""];
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
amountWon = msg.value

IRs:
amountWon(uint256) := msg.value(uint256)""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
rollone != rolltwo && _diceOne == _diceTwo

IRs:
TMP_35(bool) = rollone != rolltwo
TMP_36(bool) = _diceOne == _diceTwo
TMP_37(bool) = TMP_35 && TMP_36
CONDITION TMP_37""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
Roll(false,_diceOne,_diceTwo,rollone,rolltwo,0)

IRs:
Emit Roll(False,_diceOne,_diceTwo,rollone,rolltwo,0)""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
totalroll == 7

IRs:
TMP_39(bool) = totalroll == 7
CONDITION TMP_39""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
amountWon = msg.value * 5

IRs:
TMP_40(uint256) = msg.value * 5
amountWon(uint256) := TMP_40(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: IF 17

EXPRESSION:
totalroll == 6 || totalroll == 8

IRs:
TMP_41(bool) = totalroll == 6
TMP_42(bool) = totalroll == 8
TMP_43(bool) = TMP_41 || TMP_42
CONDITION TMP_43""];
17->18[label=""True""];
17->19[label=""False""];
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
amountWon = msg.value * 6

IRs:
TMP_44(uint256) = msg.value * 6
amountWon(uint256) := TMP_44(uint256)""];
18->19;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: IF 20

EXPRESSION:
totalroll == 5 || totalroll == 9

IRs:
TMP_45(bool) = totalroll == 5
TMP_46(bool) = totalroll == 9
TMP_47(bool) = TMP_45 || TMP_46
CONDITION TMP_47""];
20->21[label=""True""];
20->22[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
amountWon = msg.value * 8

IRs:
TMP_48(uint256) = msg.value * 8
amountWon(uint256) := TMP_48(uint256)""];
21->22;
22[label=""Node Type: END_IF 22
""];
22->23;
23[label=""Node Type: IF 23

EXPRESSION:
totalroll == 4 || totalroll == 10

IRs:
TMP_49(bool) = totalroll == 4
TMP_50(bool) = totalroll == 10
TMP_51(bool) = TMP_49 || TMP_50
CONDITION TMP_51""];
23->24[label=""True""];
23->25[label=""False""];
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
amountWon = msg.value * 10

IRs:
TMP_52(uint256) = msg.value * 10
amountWon(uint256) := TMP_52(uint256)""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->26;
26[label=""Node Type: IF 26

EXPRESSION:
totalroll == 3 || totalroll == 11

IRs:
TMP_53(bool) = totalroll == 3
TMP_54(bool) = totalroll == 11
TMP_55(bool) = TMP_53 || TMP_54
CONDITION TMP_55""];
26->27[label=""True""];
26->28[label=""False""];
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
amountWon = msg.value * 16

IRs:
TMP_56(uint256) = msg.value * 16
amountWon(uint256) := TMP_56(uint256)""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: IF 29

EXPRESSION:
rollone == rolltwo && _diceOne == _diceTwo

IRs:
TMP_57(bool) = rollone == rolltwo
TMP_58(bool) = _diceOne == _diceTwo
TMP_59(bool) = TMP_57 && TMP_58
CONDITION TMP_59""];
29->30[label=""True""];
29->31[label=""False""];
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
amountWon = msg.value * 30

IRs:
TMP_60(uint256) = msg.value * 30
amountWon(uint256) := TMP_60(uint256)""];
30->31;
31[label=""Node Type: END_IF 31
""];
31->32;
32[label=""Node Type: IF 32

EXPRESSION:
totalroll == 2 || totalroll == 12

IRs:
TMP_61(bool) = totalroll == 2
TMP_62(bool) = totalroll == 12
TMP_63(bool) = TMP_61 || TMP_62
CONDITION TMP_63""];
32->33[label=""True""];
32->34[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
amountWon = msg.value * 33

IRs:
TMP_64(uint256) = msg.value * 33
amountWon(uint256) := TMP_64(uint256)""];
33->34;
34[label=""Node Type: END_IF 34
""];
34->35;
35[label=""Node Type: IF 35

EXPRESSION:
! msg.sender.send(amountWon)

IRs:
TMP_65 = SEND dest:msg.sender value:amountWon
TMP_66 = UnaryType.BANG TMP_65 
CONDITION TMP_66""];
35->36[label=""True""];
35->37[label=""False""];
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
revert()()

IRs:
TMP_67(None) = SOLIDITY_CALL revert()()""];
36->37;
37[label=""Node Type: END_IF 37
""];
37->38;
38[label=""Node Type: EXPRESSION 38

EXPRESSION:
Roll(true,_diceOne,_diceTwo,rollone,rolltwo,amountWon)

IRs:
Emit Roll(True,_diceOne,_diceTwo,rollone,rolltwo,amountWon)""];
38->40;
39[label=""Node Type: EXPRESSION 39

EXPRESSION:
Roll(false,_diceOne,_diceTwo,rollone,rolltwo,0)

IRs:
Emit Roll(False,_diceOne,_diceTwo,rollone,rolltwo,0)""];
39->40;
40[label=""Node Type: END_IF 40
""];
}
",1,0,0,0,"require(bool)(tx.origin == msg.sender);require(bool)(_diceOne > 0 && _diceOne <= 6);require(bool)(_diceTwo > 0 && _diceTwo <= 6);require(bool)(msg.value >= minBet);rollone = ra() % 6 + 1;rolltwo = rx() % 6 + 1;totalroll = rollone + rolltwo;totaldice = _diceOne + _diceTwo;totaldice == totalroll;amountWon = msg.value;Roll(false,_diceOne,_diceTwo,rollone,rolltwo,0);rollone != rolltwo && _diceOne == _diceTwo;Roll(false,_diceOne,_diceTwo,rollone,rolltwo,0);;totalroll == 7;amountWon = msg.value * 5;;totalroll == 6 || totalroll == 8;amountWon = msg.value * 6;;totalroll == 5 || totalroll == 9;amountWon = msg.value * 8;;totalroll == 4 || totalroll == 10;amountWon = msg.value * 10;;totalroll == 3 || totalroll == 11;amountWon = msg.value * 16;;rollone == rolltwo && _diceOne == _diceTwo;amountWon = msg.value * 30;;totalroll == 2 || totalroll == 12;amountWon = msg.value * 33;;! msg.sender.send(amountWon);revert()();;Roll(true,_diceOne,_diceTwo,rollone,rolltwo,amountWon);"
./0x2791528f5617e187a6d73c30034ac211b2f47042_ext.sol,CardsRaffle.startRareRaffle,187,205,"TMP_58(bool) = rareId > 0,TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58),TMP_60(address) = HIGH_LEVEL_CALL, dest:rare(RareInterface), function:getRareItemsOwner, arguments:['rareId']  ,TMP_61(address) = INTERNAL_CALL, CardsRaffle.getRareAddress()(),TMP_62(bool) = TMP_60 == TMP_61,TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62),TMP_64(bool) = block.timestamp < endTime,TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64),TMP_66(bool) = raffleRareId != 0,CONDITION TMP_66,TMP_67(bool) = raffleWinner != 0,TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67),raffleWinningTicketSelected(bool) := False(bool),raffleTicketThatWon(uint256) := 0(uint256),raffleWinner(address) := 0(uint256),raffleTicketsBought(uint256) := 0(uint256),raffleEndTime(uint256) := endTime(uint256),raffleRareId(uint256) := rareId(uint256),MODIFIER_CALL, AccessAdmin.onlyAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->13;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(rareId > 0)

IRs:
TMP_58(bool) = rareId > 0
TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(rare.getRareItemsOwner(rareId) == getRareAddress())

IRs:
TMP_60(address) = HIGH_LEVEL_CALL, dest:rare(RareInterface), function:getRareItemsOwner, arguments:['rareId']  
TMP_61(address) = INTERNAL_CALL, CardsRaffle.getRareAddress()()
TMP_62(bool) = TMP_60 == TMP_61
TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(block.timestamp < endTime)

IRs:
TMP_64(bool) = block.timestamp < endTime
TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
raffleRareId != 0

IRs:
TMP_66(bool) = raffleRareId != 0
CONDITION TMP_66""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(raffleWinner != 0)

IRs:
TMP_67(bool) = raffleWinner != 0
TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
raffleWinningTicketSelected = false

IRs:
raffleWinningTicketSelected(bool) := False(bool)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
raffleTicketThatWon = 0

IRs:
raffleTicketThatWon(uint256) := 0(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
raffleWinner = 0

IRs:
raffleWinner(address) := 0(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
raffleTicketsBought = 0

IRs:
raffleTicketsBought(uint256) := 0(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
raffleEndTime = endTime

IRs:
raffleEndTime(uint256) := endTime(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
raffleRareId = rareId

IRs:
raffleRareId(uint256) := rareId(uint256)""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, AccessAdmin.onlyAdmin()()""];
13->1;
}
",1,0,0,0,onlyAdmin();require(bool)(rareId > 0);require(bool)(rare.getRareItemsOwner(rareId) == getRareAddress());require(bool)(block.timestamp < endTime);raffleRareId != 0;require(bool)(raffleWinner != 0);;raffleWinningTicketSelected = false;raffleTicketThatWon = 0;raffleWinner = 0;raffleTicketsBought = 0;raffleEndTime = endTime;raffleRareId = rareId
./0x9271a6512b8f27a5f8daa01a62bdc533709e859a_ext.sol,LockToken.release,99,107,"TMP_34(None) = SOLIDITY_CALL require(bool)(isLocked),TMP_35 = UnaryType.BANG isReleased ,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),TMP_37(bool) = INTERNAL_CALL, LockToken.lockOver()(),TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37),TMP_39(uint256) = INTERNAL_CALL, LockToken.tokenBalance()(),token_amount(uint256) := TMP_39(uint256),TMP_40(bool) = HIGH_LEVEL_CALL, dest:token_reward(token), function:transfer, arguments:['beneficiary', 'token_amount']  ,Emit TokenReleased(beneficiary,token_amount),isReleased(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isLocked)

IRs:
TMP_34(None) = SOLIDITY_CALL require(bool)(isLocked)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! isReleased)

IRs:
TMP_35 = UnaryType.BANG isReleased 
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(lockOver())

IRs:
TMP_37(bool) = INTERNAL_CALL, LockToken.lockOver()()
TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
token_amount = tokenBalance()

IRs:
TMP_39(uint256) = INTERNAL_CALL, LockToken.tokenBalance()()
token_amount(uint256) := TMP_39(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
token_reward.transfer(beneficiary,token_amount)

IRs:
TMP_40(bool) = HIGH_LEVEL_CALL, dest:token_reward(token), function:transfer, arguments:['beneficiary', 'token_amount']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
TokenReleased(beneficiary,token_amount)

IRs:
Emit TokenReleased(beneficiary,token_amount)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
isReleased = true

IRs:
isReleased(bool) := True(bool)""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
8->1;
}
",1,0,0,0,"onlyOwner();require(bool)(isLocked);require(bool)(! isReleased);require(bool)(lockOver());token_amount = tokenBalance();token_reward.transfer(beneficiary,token_amount);TokenReleased(beneficiary,token_amount);isReleased = true"
./0xf244176246168f24e3187f7288edbca29267739b_ext.sol,ExternStateProxyToken.approve,1944,1953,"sender(address) := messageSender(address),HIGH_LEVEL_CALL, dest:state(TokenState), function:setAllowance, arguments:['sender', 'spender', 'value']  ,Emit Approval(sender,spender,value),RETURN True,MODIFIER_CALL, Proxyable.optionalProxy()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
sender = messageSender

IRs:
sender(address) := messageSender(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
state.setAllowance(sender,spender,value)

IRs:
HIGH_LEVEL_CALL, dest:state(TokenState), function:setAllowance, arguments:['sender', 'spender', 'value']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Approval(sender,spender,value)

IRs:
Emit Approval(sender,spender,value)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
optionalProxy()

IRs:
MODIFIER_CALL, Proxyable.optionalProxy()()""];
5->1;
}
",1,0,0,0,"optionalProxy();sender = messageSender;state.setAllowance(sender,spender,value);Approval(sender,spender,value);true"
./0x470142a1834438515b757118f322703aba6e1e05_ext.sol,PolicyPalNetworkAirdrop.airDropSingleAmount,114,134,"i(uint256) := 0(uint256),REF_0 -> LENGTH _recipients,TMP_2(bool) = i < REF_0,CONDITION TMP_2,REF_1(address) -> _recipients[i],recipient(address) := REF_1(address),REF_2(bool) -> airdrops[recipient],TMP_3 = UnaryType.BANG REF_2 ,CONDITION TMP_3,TMP_4(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', '_amount']  ,TMP_5(None) = SOLIDITY_CALL assert(bool)(TMP_4),REF_4(bool) -> airdrops[recipient],REF_4(bool) (->airdrops) := True(bool),TMP_6(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] ,numDrops(uint256) := TMP_6(uint256),TMP_7(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', '_amount'] ,dropAmount(uint256) := TMP_7(uint256),Emit TokenDrop(recipient,_amount,AIRDROP),TMP_9(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()(),MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalance(address[],uint256)(_recipients,_amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _recipients.length

IRs:
REF_0 -> LENGTH _recipients
TMP_2(bool) = i < REF_0
CONDITION TMP_2""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
recipient = _recipients[i]

IRs:
REF_1(address) -> _recipients[i]
recipient(address) := REF_1(address)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
! airdrops[recipient]

IRs:
REF_2(bool) -> airdrops[recipient]
TMP_3 = UnaryType.BANG REF_2 
CONDITION TMP_3""];
6->7[label=""True""];
6->12[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(token.transfer(recipient,_amount))

IRs:
TMP_4(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', '_amount']  
TMP_5(None) = SOLIDITY_CALL assert(bool)(TMP_4)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
airdrops[recipient] = true

IRs:
REF_4(bool) -> airdrops[recipient]
REF_4(bool) (->airdrops) := True(bool)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
numDrops = numDrops.add(1)

IRs:
TMP_6(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] 
numDrops(uint256) := TMP_6(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
dropAmount = dropAmount.add(_amount)

IRs:
TMP_7(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', '_amount'] 
dropAmount(uint256) := TMP_7(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
TokenDrop(recipient,_amount,AIRDROP)

IRs:
Emit TokenDrop(recipient,_amount,AIRDROP)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
i ++

IRs:
TMP_9(uint256) := i(uint256)
i(uint256) = i + 1""];
13->4;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()()""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
validBalance(_recipients,_amount)

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalance(address[],uint256)(_recipients,_amount)""];
15->3;
}
",1,0,0,0,"onlyAdmin();;i < _recipients.length;;i = 0;recipient = _recipients[i];! airdrops[recipient];assert(bool)(token.transfer(recipient,_amount));;airdrops[recipient] = true;numDrops = numDrops.add(1);dropAmount = dropAmount.add(_amount);TokenDrop(recipient,_amount,AIRDROP);i ++;validBalance(_recipients,_amount)"
./0x0e69d0a2bbb30abcb7e5cfea0e4fde19c00a8d47_ext.sol,ContractLock.addAdmin,265,271,"REF_24(bool) -> isAdmin[admin],TMP_156(bool) = REF_24 == False,CONDITION TMP_156,REF_25(bool) -> isAdmin[admin],REF_25(bool) (->isAdmin) := True(bool),Emit LogAddAdmin(msg.sender,admin),RETURN True,MODIFIER_CALL, DSAuth.auth()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: IF 1

EXPRESSION:
isAdmin[admin] == false

IRs:
REF_24(bool) -> isAdmin[admin]
TMP_156(bool) = REF_24 == False
CONDITION TMP_156""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin[admin] = true

IRs:
REF_25(bool) -> isAdmin[admin]
REF_25(bool) (->isAdmin) := True(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
LogAddAdmin(msg.sender,admin)

IRs:
Emit LogAddAdmin(msg.sender,admin)""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
6->1;
}
",1,0,0,0,"auth();isAdmin[admin] == false;isAdmin[admin] = true;;LogAddAdmin(msg.sender,admin);true"
./0xeb86a173e0311a28cadc24f85dbad867bbf34f73_ext.sol,Bussiness.setPrice,109,113,"TMP_16(address) = HIGH_LEVEL_CALL, dest:erc721Address(IERC721), function:ownerOf, arguments:['_tokenId']  ,TMP_17(bool) = TMP_16 == msg.sender,TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17),REF_3(Bussiness.Price) -> prices[_tokenId],TMP_19(Bussiness.Price) = new Price(msg.sender,_ethPrice,0),REF_3(Bussiness.Price) (->prices) := TMP_19(Bussiness.Price),REF_4(Bussiness.Price) -> usdtPrices[_tokenId],TMP_20(Bussiness.Price) = new Price(msg.sender,_usdtPrice,0),REF_4(Bussiness.Price) (->usdtPrices) := TMP_20(Bussiness.Price)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(erc721Address.ownerOf(_tokenId) == msg.sender)

IRs:
TMP_16(address) = HIGH_LEVEL_CALL, dest:erc721Address(IERC721), function:ownerOf, arguments:['_tokenId']  
TMP_17(bool) = TMP_16 == msg.sender
TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
prices[_tokenId] = Price(msg.sender,_ethPrice,0)

IRs:
REF_3(Bussiness.Price) -> prices[_tokenId]
TMP_19(Bussiness.Price) = new Price(msg.sender,_ethPrice,0)
REF_3(Bussiness.Price) (->prices) := TMP_19(Bussiness.Price)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
usdtPrices[_tokenId] = Price(msg.sender,_usdtPrice,0)

IRs:
REF_4(Bussiness.Price) -> usdtPrices[_tokenId]
TMP_20(Bussiness.Price) = new Price(msg.sender,_usdtPrice,0)
REF_4(Bussiness.Price) (->usdtPrices) := TMP_20(Bussiness.Price)""];
}
",1,0,0,0,"require(bool)(erc721Address.ownerOf(_tokenId) == msg.sender);prices[_tokenId] = Price(msg.sender,_ethPrice,0);usdtPrices[_tokenId] = Price(msg.sender,_usdtPrice,0)"
./0x02f61fd266da6e8b102d4121f5ce7b992640cf98_ext.sol,LikeCoin.transferDelegated,288,299,"TMP_132(bool) = HIGH_LEVEL_CALL, dest:signatureChecker(SignatureChecker), function:checkTransferDelegated, arguments:['_from', '_to', '_value', '_maxReward', '_nonce', '_signature']  ,TMP_133(None) = SOLIDITY_CALL require(bool)(TMP_132),TMP_134(bool) = INTERNAL_CALL, LikeCoin._transfer(address,address,uint256)(_from,_to,_value),RETURN TMP_134,MODIFIER_CALL, LikeCoin.isDelegated(address,uint256,uint256,uint256)(_from,_maxReward,_claimedReward,_nonce),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(signatureChecker.checkTransferDelegated(_from,_to,_value,_maxReward,_nonce,_signature))

IRs:
TMP_132(bool) = HIGH_LEVEL_CALL, dest:signatureChecker(SignatureChecker), function:checkTransferDelegated, arguments:['_from', '_to', '_value', '_maxReward', '_nonce', '_signature']  
TMP_133(None) = SOLIDITY_CALL require(bool)(TMP_132)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
_transfer(_from,_to,_value)

IRs:
TMP_134(bool) = INTERNAL_CALL, LikeCoin._transfer(address,address,uint256)(_from,_to,_value)
RETURN TMP_134""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
isDelegated(_from,_maxReward,_claimedReward,_nonce)

IRs:
MODIFIER_CALL, LikeCoin.isDelegated(address,uint256,uint256,uint256)(_from,_maxReward,_claimedReward,_nonce)""];
3->1;
4[label=""Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,0,0,0,"isDelegated(_from,_maxReward,_claimedReward,_nonce);require(bool)(signatureChecker.checkTransferDelegated(_from,_to,_value,_maxReward,_nonce,_signature));_transfer(_from,_to,_value);success"
./0x39f996a2cafca0e593d0c46b8365d3936b6cc1cf_ext.sol,Etherauction.auction,244,287,"CONDITION ended,TMP_65(None) = SOLIDITY_CALL revert(string)(this round end!!!),REF_22(Etherauction.PlayerAuction[]) -> gameAuction[gameId],REF_23 -> LENGTH REF_22,len(uint256) := REF_23(uint256),TMP_66(bool) = len > 1,CONDITION TMP_66,REF_24(Etherauction.PlayerAuction[]) -> gameAuction[gameId],TMP_67(uint256) = len - 1,REF_25(Etherauction.PlayerAuction) -> REF_24[TMP_67],REF_26(address) -> REF_25.addr,bidder(address) := REF_26(address),TMP_68(bool) = msg.sender == bidder,CONDITION TMP_68,TMP_69(None) = SOLIDITY_CALL revert(string)(wrong action),TMP_70(uint256) = INTERNAL_CALL, Etherauction._getGameAuctionGap()(),gap(uint256) := TMP_70(uint256),TMP_71(uint256) = gap + gameLastAuctionMoney,auctionValue(uint256) := TMP_71(uint256),TMP_72(uint256) = 3 * gap,TMP_73(uint256) = TMP_72 + gameLastAuctionMoney,maxAuctionValue(uint256) := TMP_73(uint256),TMP_74(bool) = msg.value < auctionValue,CONDITION TMP_74,TMP_75(None) = SOLIDITY_CALL revert(string)(wrong eth value!),TMP_76(bool) = msg.value >= maxAuctionValue,CONDITION TMP_76,auctionValue(uint256) := maxAuctionValue(uint256),auctionValue(uint256) := msg.value(uint256),gameLastAuctionMoney(uint256) := auctionValue(uint256),INTERNAL_CALL, Etherauction._inMoney(uint256)(auctionValue),gameLastAuctionTime(uint256) := block.timestamp(uint256),TMP_78(uint256) = INTERNAL_CALL, Etherauction.getRandom()(),random(uint256) := TMP_78(uint256),TMP_79(uint256) = INTERNAL_CALL, Etherauction._getMaxAuctionSeconds()(),TMP_80(uint256) = INTERNAL_CALL, Etherauction._getMinAuctionSeconds()(),TMP_81(uint256) = TMP_79 - TMP_80,TMP_82(uint256) = random * TMP_81,TMP_83(uint256) = TMP_82 / 100,TMP_84(uint256) = INTERNAL_CALL, Etherauction._getMinAuctionSeconds()(),TMP_85(uint256) = TMP_83 + TMP_84,gameSecondLeft(uint256) := TMP_85(uint256),REF_27(Etherauction.PlayerAuction[]) -> gameAuction[gameId],REF_29 -> LENGTH REF_27,TMP_87(uint256) := REF_29(uint256),TMP_88(uint256) = TMP_87 + 1,REF_29(uint256) (->gameAuction) := TMP_88(uint256),REF_30(Etherauction.PlayerAuction) -> REF_27[TMP_87],REF_30(Etherauction.PlayerAuction) (->gameAuction) := p(Etherauction.PlayerAuction),REF_31(Etherauction.PlayerAuction[]) -> gameAuction[gameId],REF_32(Etherauction.PlayerAuction[]) -> gameAuction[gameId],REF_33 -> LENGTH REF_32,TMP_89(uint256) = REF_33 - 1,REF_34(Etherauction.PlayerAuction) -> REF_31[TMP_89],REF_35(address) -> REF_34.addr,REF_35(address) (->gameAuction) := msg.sender(address),REF_36(Etherauction.PlayerAuction[]) -> gameAuction[gameId],REF_37(Etherauction.PlayerAuction[]) -> gameAuction[gameId],REF_38 -> LENGTH REF_37,TMP_90(uint256) = REF_38 - 1,REF_39(Etherauction.PlayerAuction) -> REF_36[TMP_90],REF_40(uint256) -> REF_39.money,REF_40(uint256) (->gameAuction) := msg.value(uint256),REF_41(Etherauction.PlayerAuction[]) -> gameAuction[gameId],REF_42(Etherauction.PlayerAuction[]) -> gameAuction[gameId],REF_43 -> LENGTH REF_42,TMP_91(uint256) = REF_43 - 1,REF_44(Etherauction.PlayerAuction) -> REF_41[TMP_91],REF_45(uint256) -> REF_44.bid,REF_45(uint256) (->gameAuction) := auctionValue(uint256),REF_46(Etherauction.PlayerAuction[]) -> gameAuction[gameId],REF_47(Etherauction.PlayerAuction[]) -> gameAuction[gameId],REF_48 -> LENGTH REF_47,TMP_92(uint256) = REF_48 - 1,REF_49(Etherauction.PlayerAuction) -> REF_46[TMP_92],REF_50(bool) -> REF_49.refunded,REF_50(bool) (->gameAuction) := False(bool),REF_51(Etherauction.PlayerAuction[]) -> gameAuction[gameId],REF_52(Etherauction.PlayerAuction[]) -> gameAuction[gameId],REF_53 -> LENGTH REF_52,TMP_93(uint256) = REF_53 - 1,REF_54(Etherauction.PlayerAuction) -> REF_51[TMP_93],REF_55(bool) -> REF_54.dividended,REF_55(bool) (->gameAuction) := False(bool),Emit GameAuction(gameId,msg.sender,msg.value,auctionValue,gameSecondLeft,block.timestamp),TMP_95(uint256) = gameLastAuctionTime + gameSecondLeft,TMP_96(bool) = block.timestamp > TMP_95,CONDITION TMP_96,ended(bool) := True(bool),ended(bool) := False(bool)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->35;
2[label=""Node Type: IF 2

EXPRESSION:
ended

IRs:
CONDITION ended""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
revert(string)(this round end!!!)

IRs:
TMP_65(None) = SOLIDITY_CALL revert(string)(this round end!!!)""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
len = gameAuction[gameId].length

IRs:
REF_22(Etherauction.PlayerAuction[]) -> gameAuction[gameId]
REF_23 -> LENGTH REF_22
len(uint256) := REF_23(uint256)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
len > 1

IRs:
TMP_66(bool) = len > 1
CONDITION TMP_66""];
6->7[label=""True""];
6->11[label=""False""];
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
bidder = gameAuction[gameId][len - 1].addr

IRs:
REF_24(Etherauction.PlayerAuction[]) -> gameAuction[gameId]
TMP_67(uint256) = len - 1
REF_25(Etherauction.PlayerAuction) -> REF_24[TMP_67]
REF_26(address) -> REF_25.addr
bidder(address) := REF_26(address)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
msg.sender == bidder

IRs:
TMP_68(bool) = msg.sender == bidder
CONDITION TMP_68""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
revert(string)(wrong action)

IRs:
TMP_69(None) = SOLIDITY_CALL revert(string)(wrong action)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
gap = _getGameAuctionGap()

IRs:
TMP_70(uint256) = INTERNAL_CALL, Etherauction._getGameAuctionGap()()
gap(uint256) := TMP_70(uint256)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
auctionValue = gap + gameLastAuctionMoney

IRs:
TMP_71(uint256) = gap + gameLastAuctionMoney
auctionValue(uint256) := TMP_71(uint256)""];
13->14;
14[label=""Node Type: NEW VARIABLE 14

EXPRESSION:
maxAuctionValue = 3 * gap + gameLastAuctionMoney

IRs:
TMP_72(uint256) = 3 * gap
TMP_73(uint256) = TMP_72 + gameLastAuctionMoney
maxAuctionValue(uint256) := TMP_73(uint256)""];
14->15;
15[label=""Node Type: IF 15

EXPRESSION:
msg.value < auctionValue

IRs:
TMP_74(bool) = msg.value < auctionValue
CONDITION TMP_74""];
15->16[label=""True""];
15->17[label=""False""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
revert(string)(wrong eth value!)

IRs:
TMP_75(None) = SOLIDITY_CALL revert(string)(wrong eth value!)""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: IF 18

EXPRESSION:
msg.value >= maxAuctionValue

IRs:
TMP_76(bool) = msg.value >= maxAuctionValue
CONDITION TMP_76""];
18->19[label=""True""];
18->20[label=""False""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
auctionValue = maxAuctionValue

IRs:
auctionValue(uint256) := maxAuctionValue(uint256)""];
19->21;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
auctionValue = msg.value

IRs:
auctionValue(uint256) := msg.value(uint256)""];
20->21;
21[label=""Node Type: END_IF 21
""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
gameLastAuctionMoney = auctionValue

IRs:
gameLastAuctionMoney(uint256) := auctionValue(uint256)""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
_inMoney(auctionValue)

IRs:
INTERNAL_CALL, Etherauction._inMoney(uint256)(auctionValue)""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
gameLastAuctionTime = block.timestamp

IRs:
gameLastAuctionTime(uint256) := block.timestamp(uint256)""];
24->25;
25[label=""Node Type: NEW VARIABLE 25

EXPRESSION:
random = getRandom()

IRs:
TMP_78(uint256) = INTERNAL_CALL, Etherauction.getRandom()()
random(uint256) := TMP_78(uint256)""];
25->26;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
gameSecondLeft = random * (_getMaxAuctionSeconds() - _getMinAuctionSeconds()) / 100 + _getMinAuctionSeconds()

IRs:
TMP_79(uint256) = INTERNAL_CALL, Etherauction._getMaxAuctionSeconds()()
TMP_80(uint256) = INTERNAL_CALL, Etherauction._getMinAuctionSeconds()()
TMP_81(uint256) = TMP_79 - TMP_80
TMP_82(uint256) = random * TMP_81
TMP_83(uint256) = TMP_82 / 100
TMP_84(uint256) = INTERNAL_CALL, Etherauction._getMinAuctionSeconds()()
TMP_85(uint256) = TMP_83 + TMP_84
gameSecondLeft(uint256) := TMP_85(uint256)""];
26->27;
27[label=""Node Type: NEW VARIABLE 27
""];
27->28;
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
gameAuction[gameId].push(p)

IRs:
REF_27(Etherauction.PlayerAuction[]) -> gameAuction[gameId]
REF_29 -> LENGTH REF_27
TMP_87(uint256) := REF_29(uint256)
TMP_88(uint256) = TMP_87 + 1
REF_29(uint256) (->gameAuction) := TMP_88(uint256)
REF_30(Etherauction.PlayerAuction) -> REF_27[TMP_87]
REF_30(Etherauction.PlayerAuction) (->gameAuction) := p(Etherauction.PlayerAuction)""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
gameAuction[gameId][gameAuction[gameId].length - 1].addr = msg.sender

IRs:
REF_31(Etherauction.PlayerAuction[]) -> gameAuction[gameId]
REF_32(Etherauction.PlayerAuction[]) -> gameAuction[gameId]
REF_33 -> LENGTH REF_32
TMP_89(uint256) = REF_33 - 1
REF_34(Etherauction.PlayerAuction) -> REF_31[TMP_89]
REF_35(address) -> REF_34.addr
REF_35(address) (->gameAuction) := msg.sender(address)""];
29->30;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
gameAuction[gameId][gameAuction[gameId].length - 1].money = msg.value

IRs:
REF_36(Etherauction.PlayerAuction[]) -> gameAuction[gameId]
REF_37(Etherauction.PlayerAuction[]) -> gameAuction[gameId]
REF_38 -> LENGTH REF_37
TMP_90(uint256) = REF_38 - 1
REF_39(Etherauction.PlayerAuction) -> REF_36[TMP_90]
REF_40(uint256) -> REF_39.money
REF_40(uint256) (->gameAuction) := msg.value(uint256)""];
30->31;
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
gameAuction[gameId][gameAuction[gameId].length - 1].bid = auctionValue

IRs:
REF_41(Etherauction.PlayerAuction[]) -> gameAuction[gameId]
REF_42(Etherauction.PlayerAuction[]) -> gameAuction[gameId]
REF_43 -> LENGTH REF_42
TMP_91(uint256) = REF_43 - 1
REF_44(Etherauction.PlayerAuction) -> REF_41[TMP_91]
REF_45(uint256) -> REF_44.bid
REF_45(uint256) (->gameAuction) := auctionValue(uint256)""];
31->32;
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
gameAuction[gameId][gameAuction[gameId].length - 1].refunded = false

IRs:
REF_46(Etherauction.PlayerAuction[]) -> gameAuction[gameId]
REF_47(Etherauction.PlayerAuction[]) -> gameAuction[gameId]
REF_48 -> LENGTH REF_47
TMP_92(uint256) = REF_48 - 1
REF_49(Etherauction.PlayerAuction) -> REF_46[TMP_92]
REF_50(bool) -> REF_49.refunded
REF_50(bool) (->gameAuction) := False(bool)""];
32->33;
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
gameAuction[gameId][gameAuction[gameId].length - 1].dividended = false

IRs:
REF_51(Etherauction.PlayerAuction[]) -> gameAuction[gameId]
REF_52(Etherauction.PlayerAuction[]) -> gameAuction[gameId]
REF_53 -> LENGTH REF_52
TMP_93(uint256) = REF_53 - 1
REF_54(Etherauction.PlayerAuction) -> REF_51[TMP_93]
REF_55(bool) -> REF_54.dividended
REF_55(bool) (->gameAuction) := False(bool)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
GameAuction(gameId,msg.sender,msg.value,auctionValue,gameSecondLeft,block.timestamp)

IRs:
Emit GameAuction(gameId,msg.sender,msg.value,auctionValue,gameSecondLeft,block.timestamp)""];
35[label=""Node Type: IF 35

EXPRESSION:
(block.timestamp > gameLastAuctionTime + gameSecondLeft)

IRs:
TMP_95(uint256) = gameLastAuctionTime + gameSecondLeft
TMP_96(bool) = block.timestamp > TMP_95
CONDITION TMP_96""];
35->36[label=""True""];
35->37[label=""False""];
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
ended = true

IRs:
ended(bool) := True(bool)""];
36->38;
37[label=""Node Type: EXPRESSION 37

EXPRESSION:
ended = false

IRs:
ended(bool) := False(bool)""];
37->38;
38[label=""Node Type: END_IF 38
""];
38->2;
}
",1,0,0,0,"(block.timestamp > gameLastAuctionTime + gameSecondLeft);ended;revert(string)(this round end!!!);;len = gameAuction[gameId].length;len > 1;bidder = gameAuction[gameId][len - 1].addr;;msg.sender == bidder;revert(string)(wrong action);;gap = _getGameAuctionGap();auctionValue = gap + gameLastAuctionMoney;maxAuctionValue = 3 * gap + gameLastAuctionMoney;msg.value < auctionValue;revert(string)(wrong eth value!);;msg.value >= maxAuctionValue;auctionValue = maxAuctionValue;auctionValue = msg.value;;gameLastAuctionMoney = auctionValue;_inMoney(auctionValue);gameLastAuctionTime = block.timestamp;random = getRandom();gameSecondLeft = random * (_getMaxAuctionSeconds() - _getMinAuctionSeconds()) / 100 + _getMinAuctionSeconds();;gameAuction[gameId].push(p);gameAuction[gameId][gameAuction[gameId].length - 1].addr = msg.sender;gameAuction[gameId][gameAuction[gameId].length - 1].money = msg.value;gameAuction[gameId][gameAuction[gameId].length - 1].bid = auctionValue;gameAuction[gameId][gameAuction[gameId].length - 1].refunded = false;gameAuction[gameId][gameAuction[gameId].length - 1].dividended = false;GameAuction(gameId,msg.sender,msg.value,auctionValue,gameSecondLeft,block.timestamp);ended = true;ended = false;"
./0x0e54b1b8ff833b5f2b0d17453d97d340cb7576e4_ext.sol,ERC223Token.transfer,14,14,"TMP_24(bool) = INTERNAL_CALL, ERC223Token.isContract(address)(_to),CONDITION TMP_24,TMP_25(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(msg.sender),TMP_26(bool) = TMP_25 < _value,CONDITION TMP_26,TMP_27(None) = SOLIDITY_CALL revert()(),REF_1(uint256) -> balances[msg.sender],TMP_28(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(msg.sender),TMP_29(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(TMP_28,_value),REF_1(uint256) (->balances) := TMP_29(uint256),REF_2(uint256) -> balances[_to],TMP_30(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(_to),TMP_31(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(TMP_30,_value),REF_2(uint256) (->balances) := TMP_31(uint256),TMP_33(bytes32) = SOLIDITY_CALL keccak256()(_custom_fallback),TMP_34 = CONVERT TMP_33 to bytes4,TMP_35(bool) = LOW_LEVEL_CALL, dest:_to, function:call, arguments:['TMP_34', 'msg.sender', '_value', '_data'] value:0 ,TMP_36(None) = SOLIDITY_CALL assert(bool)(TMP_35),Emit Transfer(msg.sender,_to,_value,_data),RETURN True,TMP_38(bool) = INTERNAL_CALL, ERC223Token.transferToAddress(address,uint256,bytes)(_to,_value,_data),RETURN TMP_38,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
isContract(_to)

IRs:
TMP_24(bool) = INTERNAL_CALL, ERC223Token.isContract(address)(_to)
CONDITION TMP_24""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
balanceOf(msg.sender) < _value

IRs:
TMP_25(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(msg.sender)
TMP_26(bool) = TMP_25 < _value
CONDITION TMP_26""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
revert()()

IRs:
TMP_27(None) = SOLIDITY_CALL revert()()""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[msg.sender] = safeSub(balanceOf(msg.sender),_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_28(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(msg.sender)
TMP_29(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(TMP_28,_value)
REF_1(uint256) (->balances) := TMP_29(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[_to] = safeAdd(balanceOf(_to),_value)

IRs:
REF_2(uint256) -> balances[_to]
TMP_30(uint256) = INTERNAL_CALL, ERC223Token.balanceOf(address)(_to)
TMP_31(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(TMP_30,_value)
REF_2(uint256) (->balances) := TMP_31(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(_to.call.value(0)(bytes4(keccak256()(_custom_fallback)),msg.sender,_value,_data))

IRs:
TMP_33(bytes32) = SOLIDITY_CALL keccak256()(_custom_fallback)
TMP_34 = CONVERT TMP_33 to bytes4
TMP_35(bool) = LOW_LEVEL_CALL, dest:_to, function:call, arguments:['TMP_34', 'msg.sender', '_value', '_data'] value:0 
TMP_36(None) = SOLIDITY_CALL assert(bool)(TMP_35)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(msg.sender,_to,_value,_data)

IRs:
Emit Transfer(msg.sender,_to,_value,_data)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: RETURN 10

EXPRESSION:
transferToAddress(_to,_value,_data)

IRs:
TMP_38(bool) = INTERNAL_CALL, ERC223Token.transferToAddress(address,uint256,bytes)(_to,_value,_data)
RETURN TMP_38""];
12[label=""Node Type: RETURN 12

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,0,0,0,"isContract(_to);balanceOf(msg.sender) < _value;transferToAddress(_to,_value,_data);revert()();;balances[msg.sender] = safeSub(balanceOf(msg.sender),_value);balances[_to] = safeAdd(balanceOf(_to),_value);assert(bool)(_to.call.value(0)(bytes4(keccak256()(_custom_fallback)),msg.sender,_value,_data));Transfer(msg.sender,_to,_value,_data);true;success"
./0xb4a448387403554616eb5b50aa4c48f75243a015_ext.sol,Mobius2Dv2.upgrade,1310,1315,"TMP_1065 = CONVERT 0 to address,TMP_1066(bool) = _nextVersion != TMP_1065,TMP_1067(None) = SOLIDITY_CALL require(bool,string)(TMP_1066,Invalid Address!),TMP_1068 = UnaryType.BANG upgraded ,TMP_1069(None) = SOLIDITY_CALL require(bool,string)(TMP_1068,Already upgraded!),upgraded(bool) := True(bool),nextVersion(address) := _nextVersion(address),MODIFIER_CALL, DSAuth.auth()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(_nextVersion != address(0x0),Invalid Address!)

IRs:
TMP_1065 = CONVERT 0 to address
TMP_1066(bool) = _nextVersion != TMP_1065
TMP_1067(None) = SOLIDITY_CALL require(bool,string)(TMP_1066,Invalid Address!)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(! upgraded,Already upgraded!)

IRs:
TMP_1068 = UnaryType.BANG upgraded 
TMP_1069(None) = SOLIDITY_CALL require(bool,string)(TMP_1068,Already upgraded!)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
upgraded = true

IRs:
upgraded(bool) := True(bool)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
nextVersion = _nextVersion

IRs:
nextVersion(address) := _nextVersion(address)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
5->1;
}
",1,0,0,0,"auth();require(bool,string)(_nextVersion != address(0x0),Invalid Address!);require(bool,string)(! upgraded,Already upgraded!);upgraded = true;nextVersion = _nextVersion"
./0xec8f9a0de90487e7aa172fe5291fd19ad7163aa1_ext.sol,BDSMAirdrop.tokensBack,37,40,"TMP_5(uint256) = HIGH_LEVEL_CALL, dest:sharesTokenAddress(token), function:balanceOf, arguments:['this']  ,HIGH_LEVEL_CALL, dest:sharesTokenAddress(token), function:transfer, arguments:['owner', 'TMP_5']  ,tokenFree(uint256) := 0(uint256),MODIFIER_CALL, BDSMAirdrop.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
sharesTokenAddress.transfer(owner,sharesTokenAddress.balanceOf(this))

IRs:
TMP_5(uint256) = HIGH_LEVEL_CALL, dest:sharesTokenAddress(token), function:balanceOf, arguments:['this']  
HIGH_LEVEL_CALL, dest:sharesTokenAddress(token), function:transfer, arguments:['owner', 'TMP_5']  ""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
tokenFree = 0

IRs:
tokenFree(uint256) := 0(uint256)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, BDSMAirdrop.onlyOwner()()""];
3->1;
}
",1,0,0,0,"onlyOwner();sharesTokenAddress.transfer(owner,sharesTokenAddress.balanceOf(this));tokenFree = 0"
./0x00fa44d91d7541d16dd18a48dd6a011de5e887df_ext.sol,Sale.buyTokens,85,94,"weiAmount(uint256) := msg.value(uint256),TMP_13(uint256) = HIGH_LEVEL_CALL, dest:calculator(Calculator), function:getAmount, arguments:['weiAmount']  ,tokens(uint256) := TMP_13(uint256),TMP_14(bool) = tokens >= minimalTokens,TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14),TMP_16(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transferFrom, arguments:['tokenSeller', 'msg.sender', 'tokens']  ,Emit TokenPurchase(msg.sender,weiAmount,tokens)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
weiAmount = msg.value

IRs:
weiAmount(uint256) := msg.value(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
tokens = calculator.getAmount(weiAmount)

IRs:
TMP_13(uint256) = HIGH_LEVEL_CALL, dest:calculator(Calculator), function:getAmount, arguments:['weiAmount']  
tokens(uint256) := TMP_13(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
assert(bool)(tokens >= minimalTokens)

IRs:
TMP_14(bool) = tokens >= minimalTokens
TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transferFrom(tokenSeller,msg.sender,tokens)

IRs:
TMP_16(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transferFrom, arguments:['tokenSeller', 'msg.sender', 'tokens']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
TokenPurchase(msg.sender,weiAmount,tokens)

IRs:
Emit TokenPurchase(msg.sender,weiAmount,tokens)""];
}
",1,0,0,0,"weiAmount = msg.value;tokens = calculator.getAmount(weiAmount);assert(bool)(tokens >= minimalTokens);token.transferFrom(tokenSeller,msg.sender,tokens);TokenPurchase(msg.sender,weiAmount,tokens)"
./0xdbe13bf528ca21bb6c306539109c21a304191f72_ext.sol,HISToken.refundTokens,355,361,"TMP_111(bool) = msg.sender == owner,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113 = CONVERT this to address,TMP_114(bool) = _token != TMP_113,TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114),TMP_116 = CONVERT _token to AbstractToken,token(AbstractToken) := TMP_116(AbstractToken),TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ,Emit RefundTokens(_token,_refund,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_111(bool) = msg.sender == owner
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_113 = CONVERT this to address
TMP_114(bool) = _token != TMP_113
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
token = AbstractToken(_token)

IRs:
TMP_116 = CONVERT _token to AbstractToken
token(AbstractToken) := TMP_116(AbstractToken)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(_refund,_value)

IRs:
TMP_117(bool) = HIGH_LEVEL_CALL, dest:token(AbstractToken), function:transfer, arguments:['_refund', '_value']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RefundTokens(_token,_refund,_value)

IRs:
Emit RefundTokens(_token,_refund,_value)""];
}
",1,0,0,0,"require(bool)(msg.sender == owner);require(bool)(_token != address(this));token = AbstractToken(_token);token.transfer(_refund,_value);RefundTokens(_token,_refund,_value)"
./0xb471c695dd5ea02035275d4b88077490c1e380ba_ext.sol,ERC20x.transfer,30,34,"INTERNAL_CALL, ERC20x._transferBalance(address,address,uint256)(msg.sender,_to,_value),Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_transferBalance(msg.sender,_to,_value)

IRs:
INTERNAL_CALL, ERC20x._transferBalance(address,address,uint256)(msg.sender,_to,_value)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
4[label=""Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success""];
}
",1,0,0,0,"_transferBalance(msg.sender,_to,_value);Transfer(msg.sender,_to,_value);true;success"
./0xf1a47b728439730e9f83054d7c352575bf13f0b4_ext.sol,RPTCrowdsale.endCrowdfund,291,304,"TMP_98(bool) = now > crowdfundEndTime,TMP_99(None) = SOLIDITY_CALL require(bool)(TMP_98),TMP_100(uint256) = HIGH_LEVEL_CALL, dest:token(RPTToken), function:balanceOf, arguments:['this']  ,remainingToken(uint256) := TMP_100(uint256),TMP_101(bool) = remainingToken != 0,CONDITION TMP_101,TMP_102(bool) = HIGH_LEVEL_CALL, dest:token(RPTToken), function:transfer, arguments:['remainingTokenHolder', 'remainingToken']  ,Emit CrowdFundClosed(now),RETURN True,Emit CrowdFundClosed(now),RETURN False,MODIFIER_CALL, RPTCrowdsale.onlyFounders()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now > crowdfundEndTime)

IRs:
TMP_98(bool) = now > crowdfundEndTime
TMP_99(None) = SOLIDITY_CALL require(bool)(TMP_98)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
remainingToken = token.balanceOf(this)

IRs:
TMP_100(uint256) = HIGH_LEVEL_CALL, dest:token(RPTToken), function:balanceOf, arguments:['this']  
remainingToken(uint256) := TMP_100(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
remainingToken != 0

IRs:
TMP_101(bool) = remainingToken != 0
CONDITION TMP_101""];
3->4[label=""True""];
3->7[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
token.transfer(remainingTokenHolder,remainingToken)

IRs:
TMP_102(bool) = HIGH_LEVEL_CALL, dest:token(RPTToken), function:transfer, arguments:['remainingTokenHolder', 'remainingToken']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
CrowdFundClosed(now)

IRs:
Emit CrowdFundClosed(now)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
CrowdFundClosed(now)

IRs:
Emit CrowdFundClosed(now)""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyFounders()

IRs:
MODIFIER_CALL, RPTCrowdsale.onlyFounders()()""];
10->1;
}
",1,0,0,0,"onlyFounders();require(bool)(now > crowdfundEndTime);remainingToken = token.balanceOf(this);remainingToken != 0;token.transfer(remainingTokenHolder,remainingToken);CrowdFundClosed(now);CrowdFundClosed(now);true;false"
./0xcdf35c3fe4ccfacb3b1bbedfe71ca3a5ff6f2db1_ext.sol,AdvisorsTokensHolder.claimTokens,450,461,"TMP_244 = CONVERT token to address,TMP_245(bool) = _token != TMP_244,TMP_246(None) = SOLIDITY_CALL require(bool)(TMP_245),TMP_247(bool) = _token == 0,CONDITION TMP_247,REF_103(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:owner value:REF_103,TMP_249 = CONVERT _token to MyDFSToken,token(MyDFSToken) := TMP_249(MyDFSToken),TMP_250(uint256) = HIGH_LEVEL_CALL, dest:token(MyDFSToken), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_250(uint256),TMP_251(bool) = HIGH_LEVEL_CALL, dest:token(MyDFSToken), function:transfer, arguments:['owner', 'balance']  ,Emit ClaimedTokens(_token,balance),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_token != address(token))

IRs:
TMP_244 = CONVERT token to address
TMP_245(bool) = _token != TMP_244
TMP_246(None) = SOLIDITY_CALL require(bool)(TMP_245)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
_token == 0x0

IRs:
TMP_247(bool) = _token == 0
CONDITION TMP_247""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(this.balance)

IRs:
REF_103(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:owner value:REF_103""];
3->4;
4[label=""Node Type: RETURN 4
""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
token = MyDFSToken(_token)

IRs:
TMP_249 = CONVERT _token to MyDFSToken
token(MyDFSToken) := TMP_249(MyDFSToken)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_250(uint256) = HIGH_LEVEL_CALL, dest:token(MyDFSToken), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_250(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
token.transfer(owner,balance)

IRs:
TMP_251(bool) = HIGH_LEVEL_CALL, dest:token(MyDFSToken), function:transfer, arguments:['owner', 'balance']  ""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
ClaimedTokens(_token,balance)

IRs:
Emit ClaimedTokens(_token,balance)""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
10->1;
}
",1,0,0,0,"onlyOwner();require(bool)(_token != address(token));_token == 0x0;owner.transfer(this.balance);;;token = MyDFSToken(_token);balance = token.balanceOf(this);token.transfer(owner,balance);ClaimedTokens(_token,balance)"
./0xedf19b437d1a67e18b15dd4a859dd52f9cfa012f_ext.sol,ERC777TokenScheduledTimelock.scheduleTimelock,315,322,"TMP_115 = CONVERT 0 to address,TMP_116(bool) = _beneficiary != TMP_115,TMP_117(None) = SOLIDITY_CALL require(bool)(TMP_116),TMP_118(uint256) = INTERNAL_CALL, ERC777TokenScheduledTimelock.getNow()(),TMP_119(bool) = _lockTill > TMP_118,TMP_120(None) = SOLIDITY_CALL require(bool)(TMP_119),TMP_121 = CONVERT this to address,TMP_122(uint256) = HIGH_LEVEL_CALL, dest:token(ERC777Token), function:balanceOf, arguments:['TMP_121']  ,TMP_123(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalVested', '_lockTokenAmount'] ,TMP_124(bool) = TMP_122 >= TMP_123,TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124),TMP_126(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalVested', '_lockTokenAmount'] ,totalVested(uint256) := TMP_126(uint256),REF_26(ERC777TokenScheduledTimelock.Timelock[]) -> schedule[_beneficiary],TMP_127(ERC777TokenScheduledTimelock.Timelock) = new Timelock(_lockTill,_lockTokenAmount),REF_28 -> LENGTH REF_26,TMP_129(uint256) := REF_28(uint256),TMP_130(uint256) = TMP_129 + 1,REF_28(uint256) (->schedule) := TMP_130(uint256),REF_29(ERC777TokenScheduledTimelock.Timelock) -> REF_26[TMP_129],REF_29(ERC777TokenScheduledTimelock.Timelock) (->schedule) := TMP_127(ERC777TokenScheduledTimelock.Timelock),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_beneficiary != address(0))

IRs:
TMP_115 = CONVERT 0 to address
TMP_116(bool) = _beneficiary != TMP_115
TMP_117(None) = SOLIDITY_CALL require(bool)(TMP_116)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_lockTill > getNow())

IRs:
TMP_118(uint256) = INTERNAL_CALL, ERC777TokenScheduledTimelock.getNow()()
TMP_119(bool) = _lockTill > TMP_118
TMP_120(None) = SOLIDITY_CALL require(bool)(TMP_119)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(token.balanceOf(address(this)) >= totalVested.add(_lockTokenAmount))

IRs:
TMP_121 = CONVERT this to address
TMP_122(uint256) = HIGH_LEVEL_CALL, dest:token(ERC777Token), function:balanceOf, arguments:['TMP_121']  
TMP_123(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalVested', '_lockTokenAmount'] 
TMP_124(bool) = TMP_122 >= TMP_123
TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
totalVested = totalVested.add(_lockTokenAmount)

IRs:
TMP_126(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalVested', '_lockTokenAmount'] 
totalVested(uint256) := TMP_126(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
schedule[_beneficiary].push(Timelock({till:_lockTill,amount:_lockTokenAmount}))

IRs:
REF_26(ERC777TokenScheduledTimelock.Timelock[]) -> schedule[_beneficiary]
TMP_127(ERC777TokenScheduledTimelock.Timelock) = new Timelock(_lockTill,_lockTokenAmount)
REF_28 -> LENGTH REF_26
TMP_129(uint256) := REF_28(uint256)
TMP_130(uint256) = TMP_129 + 1
REF_28(uint256) (->schedule) := TMP_130(uint256)
REF_29(ERC777TokenScheduledTimelock.Timelock) -> REF_26[TMP_129]
REF_29(ERC777TokenScheduledTimelock.Timelock) (->schedule) := TMP_127(ERC777TokenScheduledTimelock.Timelock)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",1,0,0,0,"onlyOwner();require(bool)(_beneficiary != address(0));require(bool)(_lockTill > getNow());require(bool)(token.balanceOf(address(this)) >= totalVested.add(_lockTokenAmount));totalVested = totalVested.add(_lockTokenAmount);schedule[_beneficiary].push(Timelock({till:_lockTill,amount:_lockTokenAmount}))"
