file,function,start,end,code,graph,RE,IO,TO,SAFE,expression
./0x778e763c4a09c74b2de221b4d3c92d8c7f27a038_ext.sol,TokenERC20.locks,279,293,"REF_60(TokenERC20.Userinfo) -> userinfos[_owner],REF_61(uint256) -> REF_60.lockstime,TMP_80(uint256) = REF_61 + 10368000,TMP_81(bool) = now >= TMP_80,CONDITION TMP_81,REF_62(TokenERC20.Userinfo) -> userinfos[_owner],REF_63(uint256) -> REF_62.lockstime,TMP_82(uint256) = now - REF_63,TMP_83(uint256) = TMP_82 - 10368000,amounttime(uint256) := TMP_83(uint256),TMP_84(uint256) = amounttime / 2592000,a(uint256) := TMP_84(uint256),TMP_85(bool) = a >= 4,CONDITION TMP_85,a(uint256) := 4(uint256),REF_64(TokenERC20.Userinfo) -> userinfos[_owner],REF_65(bool) -> REF_64.locksstatus,REF_65(bool) (->userinfos) := False(bool),REF_66(TokenERC20.Userinfo) -> userinfos[_owner],REF_67(uint256) -> REF_66.locksnumber,TMP_86(uint256) = 4 - a,TMP_87(uint256) = REF_67 * TMP_86,TMP_88(uint256) = TMP_87 * 25,TMP_89(uint256) = TMP_88 / 100,b(uint256) := TMP_89(uint256),REF_68(uint256) -> balances[_owner],TMP_90(uint256) = REF_68 - b,TMP_91(bool) = TMP_90 >= value_,TMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91),REF_69(uint256) -> balances[_owner],REF_70(TokenERC20.Userinfo) -> userinfos[_owner],REF_71(uint256) -> REF_70.locksnumber,TMP_93(uint256) = REF_69 - REF_71,TMP_94(bool) = TMP_93 >= value_,TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
now >= userinfos[_owner].lockstime + 10368000

IRs:
REF_60(TokenERC20.Userinfo) -> userinfos[_owner]
REF_61(uint256) -> REF_60.lockstime
TMP_80(uint256) = REF_61 + 10368000
TMP_81(bool) = now >= TMP_80
CONDITION TMP_81""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amounttime = now - userinfos[_owner].lockstime - 10368000

IRs:
REF_62(TokenERC20.Userinfo) -> userinfos[_owner]
REF_63(uint256) -> REF_62.lockstime
TMP_82(uint256) = now - REF_63
TMP_83(uint256) = TMP_82 - 10368000
amounttime(uint256) := TMP_83(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
a = amounttime / 2592000

IRs:
TMP_84(uint256) = amounttime / 2592000
a(uint256) := TMP_84(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
a >= 4

IRs:
TMP_85(bool) = a >= 4
CONDITION TMP_85""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
a = 4

IRs:
a(uint256) := 4(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
userinfos[_owner].locksstatus = false

IRs:
REF_64(TokenERC20.Userinfo) -> userinfos[_owner]
REF_65(bool) -> REF_64.locksstatus
REF_65(bool) (->userinfos) := False(bool)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
b = (userinfos[_owner].locksnumber * (4 - a)) * 25 / 100

IRs:
REF_66(TokenERC20.Userinfo) -> userinfos[_owner]
REF_67(uint256) -> REF_66.locksnumber
TMP_86(uint256) = 4 - a
TMP_87(uint256) = REF_67 * TMP_86
TMP_88(uint256) = TMP_87 * 25
TMP_89(uint256) = TMP_88 / 100
b(uint256) := TMP_89(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(balances[_owner] - b >= value_)

IRs:
REF_68(uint256) -> balances[_owner]
TMP_90(uint256) = REF_68 - b
TMP_91(bool) = TMP_90 >= value_
TMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91)""];
9->11;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(balances[_owner] - userinfos[_owner].locksnumber >= value_)

IRs:
REF_69(uint256) -> balances[_owner]
REF_70(TokenERC20.Userinfo) -> userinfos[_owner]
REF_71(uint256) -> REF_70.locksnumber
TMP_93(uint256) = REF_69 - REF_71
TMP_94(bool) = TMP_93 >= value_
TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94)""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: RETURN 12

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,now >= userinfos[_owner].lockstime + 10368000;amounttime = now - userinfos[_owner].lockstime - 10368000;require(bool)(balances[_owner] - userinfos[_owner].locksnumber >= value_);a = amounttime / 2592000;a >= 4;a = 4;;userinfos[_owner].locksstatus = false;b = (userinfos[_owner].locksnumber * (4 - a)) * 25 / 100;require(bool)(balances[_owner] - b >= value_);;true
./0x260cd379410a753cb602c76ae59bfba68246e789_ext.sol,Token365.approveAndCall,71,79,"TMP_22 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_22(tokenRecipient),TMP_23(bool) = INTERNAL_CALL, Token365.approve(address,uint256)(_spender,_value),CONDITION TMP_23,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_22 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_22(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_23(bool) = INTERNAL_CALL, Token365.approve(address,uint256)(_spender,_value)
CONDITION TMP_23""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x365a3335866ac0b5f7002608eae1043d526f44d7_ext.sol,multifund.setup_key,23,28,"TMP_9(bool) = keyHash == 0,CONDITION TMP_9,TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10),keyHash(bytes32) := TMP_11(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
keyHash == 0x0

IRs:
TMP_9(bool) = keyHash == 0
CONDITION TMP_9""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
keyHash = keccak256()(abi.encodePacked(key))

IRs:
TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10)
keyHash(bytes32) := TMP_11(bytes32)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,1,0,0,keyHash == 0x0;keyHash = keccak256()(abi.encodePacked(key));
./0x6be66252c14915e2a4f7e9621bc17365c4f35244_ext.sol,StandardToken.transferFrom,43,53,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0xaa57e849341a2899110ba676a49302c069251d19_ext.sol,EditionStorage.nextOffsetIndex,315,317,"TMP_174(uint256) := offsetIndex(uint256),offsetIndex(uint256) = offsetIndex + 1,MODIFIER_CALL, BaseStorage.canWrite()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
offsetIndex ++

IRs:
TMP_174(uint256) := offsetIndex(uint256)
offsetIndex(uint256) = offsetIndex + 1""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
canWrite()

IRs:
MODIFIER_CALL, BaseStorage.canWrite()()""];
2->1;
}
",0,1,0,0,canWrite();offsetIndex ++
./0x5ac8359a7d38afedf7ed0d4abb283cd2654d126a_ext.sol,StandardToken.increaseApproval,61,66,"TMP_15(bool) = _addedValue > 0,TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15),REF_17(mapping(address => uint256)) -> allowed[msg.sender],REF_18(uint256) -> REF_17[_spender],REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[_spender],TMP_17(uint256) = REF_20 + _addedValue,REF_18(uint256) (->allowed) := TMP_17(uint256),REF_21(mapping(address => uint256)) -> allowed[msg.sender],REF_22(uint256) -> REF_21[_spender],Emit Approval(msg.sender,_spender,REF_22),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_addedValue > 0)

IRs:
TMP_15(bool) = _addedValue > 0
TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender] + _addedValue

IRs:
REF_17(mapping(address => uint256)) -> allowed[msg.sender]
REF_18(uint256) -> REF_17[_spender]
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[_spender]
TMP_17(uint256) = REF_20 + _addedValue
REF_18(uint256) (->allowed) := TMP_17(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_21(mapping(address => uint256)) -> allowed[msg.sender]
REF_22(uint256) -> REF_21[_spender]
Emit Approval(msg.sender,_spender,REF_22)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(_addedValue > 0);allowed[msg.sender][_spender] = allowed[msg.sender][_spender] + _addedValue;Approval(msg.sender,_spender,allowed[msg.sender][_spender]);true"
./0x861a174d677946d8c2bea8f9636a53fde1668215_ext.sol,ExchangeRate.getRate,533,535,"TMP_173(bytes32) = SOLIDITY_CALL keccak256()(_symbol),REF_116(uint256) -> rates[TMP_173],RETURN REF_116","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
rates[keccak256()(_symbol)]

IRs:
TMP_173(bytes32) = SOLIDITY_CALL keccak256()(_symbol)
REF_116(uint256) -> rates[TMP_173]
RETURN REF_116""];
}
",0,1,0,0,rates[keccak256()(_symbol)]
./0xbcef236c69228f004da2fa693c3347946798e0c3_ext.sol,TokenERC20.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x4c2085edeefa307e73a10e3e7224886e6b6a0586_ext.sol,BREDToken.approveAndCall,200,205,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xe319847f14624ad62a99c7eb5e6d738f61fcf185_ext.sol,EtherPaint.dividends,179,184,"TMP_66(bool) = colorid >= 16,CONDITION TMP_66,TMP_67(None) = SOLIDITY_CALL revert()(),REF_22(uint256) -> earningsPerToken[colorid],REF_23(uint256[16]) -> tokenBalance[_owner],REF_24(uint256) -> REF_23[colorid],TMP_68(uint256) = REF_22 * REF_24,TMP_69 = CONVERT TMP_68 to int256,REF_25(int256[16]) -> payouts[_owner],REF_26(int256) -> REF_25[colorid],TMP_70(int256) = TMP_69 - REF_26,TMP_71 = CONVERT TMP_70 to uint256,TMP_72(uint256) = TMP_71 / scaleFactor,RETURN TMP_72,RETURN amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
colorid >= 16

IRs:
TMP_66(bool) = colorid >= 16
CONDITION TMP_66""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_67(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
uint256(int256(earningsPerToken[colorid] * tokenBalance[_owner][colorid]) - payouts[_owner][colorid]) / scaleFactor

IRs:
REF_22(uint256) -> earningsPerToken[colorid]
REF_23(uint256[16]) -> tokenBalance[_owner]
REF_24(uint256) -> REF_23[colorid]
TMP_68(uint256) = REF_22 * REF_24
TMP_69 = CONVERT TMP_68 to int256
REF_25(int256[16]) -> payouts[_owner]
REF_26(int256) -> REF_25[colorid]
TMP_70(int256) = TMP_69 - REF_26
TMP_71 = CONVERT TMP_70 to uint256
TMP_72(uint256) = TMP_71 / scaleFactor
RETURN TMP_72""];
5[label=""Node Type: RETURN 5

EXPRESSION:
amount

IRs:
RETURN amount""];
}
",0,1,0,0,colorid >= 16;revert()();;uint256(int256(earningsPerToken[colorid] * tokenBalance[_owner][colorid]) - payouts[_owner][colorid]) / scaleFactor;amount
./0xf066a61ebcb0a11ec3921cf9fbcca4561877526f_ext.sol,MasterNodeMining.TEAMmint,108,116,"TMP_45(uint256) = maximumSupply - totalSupply,addSupply(uint256) := TMP_45(uint256),TMP_46(uint256) = totalSupply + addSupply,currentSupply(uint256) := TMP_46(uint256),TMP_47(bool) = now > teamTokens,TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47),TMP_49(bool) = totalSupply > 0,TMP_50(bool) = addSupply > 0,TMP_51(bool) = TMP_49 && TMP_50,TMP_52(None) = SOLIDITY_CALL require(bool)(TMP_51),TMP_53(bool) = maximumSupply >= currentSupply,TMP_54(None) = SOLIDITY_CALL require(bool)(TMP_53),totalSupply(uint256) = totalSupply + addSupply,REF_22(uint256) -> balances[owner],REF_22(-> balances) = REF_22 + addSupply,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
addSupply = maximumSupply - totalSupply

IRs:
TMP_45(uint256) = maximumSupply - totalSupply
addSupply(uint256) := TMP_45(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
currentSupply = totalSupply + addSupply

IRs:
TMP_46(uint256) = totalSupply + addSupply
currentSupply(uint256) := TMP_46(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(now > teamTokens)

IRs:
TMP_47(bool) = now > teamTokens
TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(totalSupply > 0 && addSupply > 0)

IRs:
TMP_49(bool) = totalSupply > 0
TMP_50(bool) = addSupply > 0
TMP_51(bool) = TMP_49 && TMP_50
TMP_52(None) = SOLIDITY_CALL require(bool)(TMP_51)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(maximumSupply >= currentSupply)

IRs:
TMP_53(bool) = maximumSupply >= currentSupply
TMP_54(None) = SOLIDITY_CALL require(bool)(TMP_53)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
totalSupply += addSupply

IRs:
totalSupply(uint256) = totalSupply + addSupply""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[owner] += addSupply

IRs:
REF_22(uint256) -> balances[owner]
REF_22(-> balances) = REF_22 + addSupply""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
8->1;
}
",0,1,0,0,onlyOwner();addSupply = maximumSupply - totalSupply;currentSupply = totalSupply + addSupply;require(bool)(now > teamTokens);require(bool)(totalSupply > 0 && addSupply > 0);require(bool)(maximumSupply >= currentSupply);totalSupply += addSupply;balances[owner] += addSupply
./0x92251fd0e744f7c5aac55c60c98ddafc48e97e18_ext.sol,GCCTTOKEN._transfer,26,35,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 > REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value > balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 > REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value > balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xd8cc0ef2b26ff52f86de029cb38ed53b7ed98a57_ext.sol,PumpAndDump.dividendsOf,475,481,"REF_35(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_65(uint256) = profitPerShare_ * REF_35,TMP_66 = CONVERT TMP_65 to int256,REF_36(int256) -> payoutsTo_[_customerAddress],TMP_67(int256) = TMP_66 - REF_36,TMP_68 = CONVERT TMP_67 to uint256,TMP_69(uint256) = TMP_68 / magnitude,RETURN TMP_69","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_35(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_65(uint256) = profitPerShare_ * REF_35
TMP_66 = CONVERT TMP_65 to int256
REF_36(int256) -> payoutsTo_[_customerAddress]
TMP_67(int256) = TMP_66 - REF_36
TMP_68 = CONVERT TMP_67 to uint256
TMP_69(uint256) = TMP_68 / magnitude
RETURN TMP_69""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x7287bef78619e10c32a1eee82046fa3c4a29f17d_ext.sol,CryptoPornSmartContract._transfer,367,382,"REF_60(uint256) -> ownershipTokenCount[_to],TMP_89(uint256) := REF_60(uint256),REF_60(-> ownershipTokenCount) = REF_60 + 1,REF_61(address) -> personIndexToOwner[_tokenId],REF_61(address) (->personIndexToOwner) := _to(address),TMP_90(bool) = INTERNAL_CALL, CryptoPornSmartContract._addressNotNull(address)(_from),CONDITION TMP_90,REF_62(uint256) -> ownershipTokenCount[_from],TMP_91(uint256) := REF_62(uint256),REF_62(-> ownershipTokenCount) = REF_62 - 1,REF_63(address) -> personIndexToApproved[_tokenId],personIndexToApproved = delete REF_63 ,Emit Transfer(_from,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownershipTokenCount[_to] ++

IRs:
REF_60(uint256) -> ownershipTokenCount[_to]
TMP_89(uint256) := REF_60(uint256)
REF_60(-> ownershipTokenCount) = REF_60 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
personIndexToOwner[_tokenId] = _to

IRs:
REF_61(address) -> personIndexToOwner[_tokenId]
REF_61(address) (->personIndexToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_addressNotNull(_from)

IRs:
TMP_90(bool) = INTERNAL_CALL, CryptoPornSmartContract._addressNotNull(address)(_from)
CONDITION TMP_90""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownershipTokenCount[_from] --

IRs:
REF_62(uint256) -> ownershipTokenCount[_from]
TMP_91(uint256) := REF_62(uint256)
REF_62(-> ownershipTokenCount) = REF_62 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete personIndexToApproved[_tokenId]

IRs:
REF_63(address) -> personIndexToApproved[_tokenId]
personIndexToApproved = delete REF_63 ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
}
",0,1,0,0,"ownershipTokenCount[_to] ++;personIndexToOwner[_tokenId] = _to;_addressNotNull(_from);ownershipTokenCount[_from] --;;delete personIndexToApproved[_tokenId];Transfer(_from,_to,_tokenId)"
./0x28f272fb35039753be682dc9a0f416c487c0bc89_ext.sol,continuousBacking.backAtIndex,82,100,"totalAmount(uint256) := msg.value(uint256),REF_4(continuousBacking.Reward) -> rewards[index],REF_5(address) -> REF_4.host,TMP_18(bool) = msg.sender == REF_5,REF_6(continuousBacking.Reward) -> rewards[index],REF_7(address) -> REF_6.creator,TMP_19(bool) = msg.sender == REF_7,TMP_20(bool) = TMP_18 || TMP_19,CONDITION TMP_20,TMP_21(None) = SOLIDITY_CALL revert()(),REF_8(continuousBacking.Reward) -> rewards[index],REF_9(uint256) -> REF_8.spmPreventionAmt,TMP_22(bool) = totalAmount < REF_9,CONDITION TMP_22,TMP_23(None) = SOLIDITY_CALL revert()(),TMP_24(bool) = totalAmount == 0,CONDITION TMP_24,TMP_25(None) = SOLIDITY_CALL revert()(),REF_10(continuousBacking.Reward) -> rewards[index],REF_11(uint256) -> REF_10.numTaken,REF_12(continuousBacking.Reward) -> rewards[index],REF_13(uint256) -> REF_12.numAvailable,TMP_26(bool) = REF_11 == REF_13,CONDITION TMP_26,TMP_27(None) = SOLIDITY_CALL revert()(),REF_14(continuousBacking.Reward) -> rewards[index],REF_15(uint256) -> REF_14.numTaken,REF_15(-> rewards) = REF_15 + 1,REF_16(continuousBacking.Reward) -> rewards[index],REF_17(address) -> REF_16.host,host(address) := REF_17(address),REF_18(continuousBacking.Reward) -> rewards[index],REF_19(address) -> REF_18.creator,creator(address) := REF_19(address),TUPLE_0(uint256,uint256) = INTERNAL_CALL, continuousBacking.returnHostAndCreatorCut(uint256)(totalAmount),hostCut(uint256)= UNPACK TUPLE_0 index: 0 ,creatorCut(uint256)= UNPACK TUPLE_0 index: 1 ,Transfer dest:host value:hostCut,Transfer dest:creator value:creatorCut,Emit ClaimedReward(index,totalAmount,numUnitsDesired,hostCut,creatorCut,msg.sender)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
totalAmount = msg.value

IRs:
totalAmount(uint256) := msg.value(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
msg.sender == rewards[index].host || msg.sender == rewards[index].creator

IRs:
REF_4(continuousBacking.Reward) -> rewards[index]
REF_5(address) -> REF_4.host
TMP_18(bool) = msg.sender == REF_5
REF_6(continuousBacking.Reward) -> rewards[index]
REF_7(address) -> REF_6.creator
TMP_19(bool) = msg.sender == REF_7
TMP_20(bool) = TMP_18 || TMP_19
CONDITION TMP_20""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
revert()()

IRs:
TMP_21(None) = SOLIDITY_CALL revert()()""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
totalAmount < rewards[index].spmPreventionAmt

IRs:
REF_8(continuousBacking.Reward) -> rewards[index]
REF_9(uint256) -> REF_8.spmPreventionAmt
TMP_22(bool) = totalAmount < REF_9
CONDITION TMP_22""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
revert()()

IRs:
TMP_23(None) = SOLIDITY_CALL revert()()""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
totalAmount == 0

IRs:
TMP_24(bool) = totalAmount == 0
CONDITION TMP_24""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
revert()()

IRs:
TMP_25(None) = SOLIDITY_CALL revert()()""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
rewards[index].numTaken == rewards[index].numAvailable

IRs:
REF_10(continuousBacking.Reward) -> rewards[index]
REF_11(uint256) -> REF_10.numTaken
REF_12(continuousBacking.Reward) -> rewards[index]
REF_13(uint256) -> REF_12.numAvailable
TMP_26(bool) = REF_11 == REF_13
CONDITION TMP_26""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
revert()()

IRs:
TMP_27(None) = SOLIDITY_CALL revert()()""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
rewards[index].numTaken += 1

IRs:
REF_14(continuousBacking.Reward) -> rewards[index]
REF_15(uint256) -> REF_14.numTaken
REF_15(-> rewards) = REF_15 + 1""];
14->15;
15[label=""Node Type: NEW VARIABLE 15

EXPRESSION:
host = rewards[index].host

IRs:
REF_16(continuousBacking.Reward) -> rewards[index]
REF_17(address) -> REF_16.host
host(address) := REF_17(address)""];
15->16;
16[label=""Node Type: NEW VARIABLE 16

EXPRESSION:
creator = rewards[index].creator

IRs:
REF_18(continuousBacking.Reward) -> rewards[index]
REF_19(address) -> REF_18.creator
creator(address) := REF_19(address)""];
16->17;
17[label=""Node Type: NEW VARIABLE 17
""];
17->18;
18[label=""Node Type: NEW VARIABLE 18
""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
(hostCut,creatorCut) = returnHostAndCreatorCut(totalAmount)

IRs:
TUPLE_0(uint256,uint256) = INTERNAL_CALL, continuousBacking.returnHostAndCreatorCut(uint256)(totalAmount)
hostCut(uint256)= UNPACK TUPLE_0 index: 0 
creatorCut(uint256)= UNPACK TUPLE_0 index: 1 ""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
host.transfer(hostCut)

IRs:
Transfer dest:host value:hostCut""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
creator.transfer(creatorCut)

IRs:
Transfer dest:creator value:creatorCut""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
ClaimedReward(index,totalAmount,numUnitsDesired,hostCut,creatorCut,msg.sender)

IRs:
Emit ClaimedReward(index,totalAmount,numUnitsDesired,hostCut,creatorCut,msg.sender)""];
}
",0,1,0,0,"totalAmount = msg.value;msg.sender == rewards[index].host || msg.sender == rewards[index].creator;revert()();;totalAmount < rewards[index].spmPreventionAmt;revert()();;totalAmount == 0;revert()();;rewards[index].numTaken == rewards[index].numAvailable;revert()();;rewards[index].numTaken += 1;host = rewards[index].host;creator = rewards[index].creator;;;(hostCut,creatorCut) = returnHostAndCreatorCut(totalAmount);host.transfer(hostCut);creator.transfer(creatorCut);ClaimedReward(index,totalAmount,numUnitsDesired,hostCut,creatorCut,msg.sender)"
./0x280daacbd812725baf46e273b84426b1e10ab410_ext.sol,CBEXTOKEN.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0xdf195c2101959f6f39f583ffa5a2aeae71c0f503_ext.sol,SCOIN._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xd0d6b03cb90ec013c6a00ff60e30c3a350c1df94_ext.sol,NamiTrade._transfer,1332,1348,"TMP_462(bool) = _to != 0,TMP_463(None) = SOLIDITY_CALL require(bool)(TMP_462),REF_262(uint256) -> balanceOf[_from],TMP_464(bool) = REF_262 >= _value,TMP_465(None) = SOLIDITY_CALL require(bool)(TMP_464),REF_263(uint256) -> balanceOf[_to],TMP_466(uint256) = REF_263 + _value,REF_264(uint256) -> balanceOf[_to],TMP_467(bool) = TMP_466 >= REF_264,TMP_468(None) = SOLIDITY_CALL require(bool)(TMP_467),REF_265(uint256) -> balanceOf[_from],REF_266(uint256) -> balanceOf[_to],TMP_469(uint256) = REF_265 + REF_266,previousBalances(uint256) := TMP_469(uint256),REF_267(uint256) -> balanceOf[_from],REF_267(-> balanceOf) = REF_267 - _value,REF_268(uint256) -> balanceOf[_to],REF_268(-> balanceOf) = REF_268 + _value,Emit Transfer(_from,_to,_value),REF_269(uint256) -> balanceOf[_from],REF_270(uint256) -> balanceOf[_to],TMP_471(uint256) = REF_269 + REF_270,TMP_472(bool) = TMP_471 == previousBalances,TMP_473(None) = SOLIDITY_CALL assert(bool)(TMP_472)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_462(bool) = _to != 0
TMP_463(None) = SOLIDITY_CALL require(bool)(TMP_462)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_262(uint256) -> balanceOf[_from]
TMP_464(bool) = REF_262 >= _value
TMP_465(None) = SOLIDITY_CALL require(bool)(TMP_464)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_263(uint256) -> balanceOf[_to]
TMP_466(uint256) = REF_263 + _value
REF_264(uint256) -> balanceOf[_to]
TMP_467(bool) = TMP_466 >= REF_264
TMP_468(None) = SOLIDITY_CALL require(bool)(TMP_467)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_265(uint256) -> balanceOf[_from]
REF_266(uint256) -> balanceOf[_to]
TMP_469(uint256) = REF_265 + REF_266
previousBalances(uint256) := TMP_469(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_267(uint256) -> balanceOf[_from]
REF_267(-> balanceOf) = REF_267 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_268(uint256) -> balanceOf[_to]
REF_268(-> balanceOf) = REF_268 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_269(uint256) -> balanceOf[_from]
REF_270(uint256) -> balanceOf[_to]
TMP_471(uint256) = REF_269 + REF_270
TMP_472(bool) = TMP_471 == previousBalances
TMP_473(None) = SOLIDITY_CALL assert(bool)(TMP_472)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x50d1eea88e9be7a39601f4b693887e21a601fd58_ext.sol,ContractReceiver.tokenFallback,51,58,"REF_0(address) -> tkn.sender,REF_0(address) (->tkn) := _from(address),REF_1(uint256) -> tkn.value,REF_1(uint256) (->tkn) := _value(uint256),REF_2(bytes) -> tkn.data,REF_2(bytes) (->tkn) := _data(bytes),REF_3(None) -> _data[3],TMP_12 = CONVERT REF_3 to uint32,REF_4(None) -> _data[2],TMP_13 = CONVERT REF_4 to uint32,TMP_14(uint32) = TMP_13 << 8,TMP_15(uint32) = TMP_12 + TMP_14,REF_5(None) -> _data[1],TMP_16 = CONVERT REF_5 to uint32,TMP_17(uint32) = TMP_16 << 16,TMP_18(uint32) = TMP_15 + TMP_17,REF_6(None) -> _data[0],TMP_19 = CONVERT REF_6 to uint32,TMP_20(uint32) = TMP_19 << 24,TMP_21(uint32) = TMP_18 + TMP_20,u(uint32) := TMP_21(uint32),REF_7(bytes4) -> tkn.sig,TMP_22 = CONVERT u to bytes4,REF_7(bytes4) (->tkn) := TMP_22(bytes4)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
tkn.sender = _from

IRs:
REF_0(address) -> tkn.sender
REF_0(address) (->tkn) := _from(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tkn.value = _value

IRs:
REF_1(uint256) -> tkn.value
REF_1(uint256) (->tkn) := _value(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
tkn.data = _data

IRs:
REF_2(bytes) -> tkn.data
REF_2(bytes) (->tkn) := _data(bytes)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24)

IRs:
REF_3(None) -> _data[3]
TMP_12 = CONVERT REF_3 to uint32
REF_4(None) -> _data[2]
TMP_13 = CONVERT REF_4 to uint32
TMP_14(uint32) = TMP_13 << 8
TMP_15(uint32) = TMP_12 + TMP_14
REF_5(None) -> _data[1]
TMP_16 = CONVERT REF_5 to uint32
TMP_17(uint32) = TMP_16 << 16
TMP_18(uint32) = TMP_15 + TMP_17
REF_6(None) -> _data[0]
TMP_19 = CONVERT REF_6 to uint32
TMP_20(uint32) = TMP_19 << 24
TMP_21(uint32) = TMP_18 + TMP_20
u(uint32) := TMP_21(uint32)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tkn.sig = bytes4(u)

IRs:
REF_7(bytes4) -> tkn.sig
TMP_22 = CONVERT u to bytes4
REF_7(bytes4) (->tkn) := TMP_22(bytes4)""];
}
",0,1,0,0,;tkn.sender = _from;tkn.value = _value;tkn.data = _data;u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);tkn.sig = bytes4(u)
./0x556241b90b4c55457a31e27eb612bdc11815d989_ext.sol,NemixToken.burnFrom,140,148,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xef86db910c71ffa3c80233bc9108dc51ad1e008a_ext.sol,CommonWallet.depoEther,33,35,"REF_0(uint256) -> etherBalance[msg.sender],REF_0(-> etherBalance) = REF_0 + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
etherBalance[msg.sender] += msg.value

IRs:
REF_0(uint256) -> etherBalance[msg.sender]
REF_0(-> etherBalance) = REF_0 + msg.value""];
}
",0,1,0,0,etherBalance[msg.sender] += msg.value
./0xd9d42c6d1ebf9083d9514e5ae5f53cd627708c12_ext.sol,TokenERC20.burn,135,141,"REF_17(uint256) -> balanceOf[msg.sender],TMP_25(bool) = REF_17 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_25(bool) = REF_17 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x346b7ac48f05e505dd7c1c9e861577f7e793cf17_ext.sol,Registry.latestTemplateOf,350,353,"REF_35(uint256[]) -> versionsOfIdentifier[_identifier],versions(uint256[]) = ['REF_35(uint256[])'],REF_36(mapping(uint256 => Template)) -> templateOfVersionOfIdentifier[_identifier],REF_37 -> LENGTH versions,TMP_105(uint256) = REF_37 - 1,REF_38(uint256) -> versions[TMP_105],REF_39(Template) -> REF_36[REF_38],RETURN REF_39,RETURN template","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
versions = versionsOfIdentifier[_identifier]

IRs:
REF_35(uint256[]) -> versionsOfIdentifier[_identifier]
versions(uint256[]) = ['REF_35(uint256[])']""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
templateOfVersionOfIdentifier[_identifier][versions[versions.length - 1]]

IRs:
REF_36(mapping(uint256 => Template)) -> templateOfVersionOfIdentifier[_identifier]
REF_37 -> LENGTH versions
TMP_105(uint256) = REF_37 - 1
REF_38(uint256) -> versions[TMP_105]
REF_39(Template) -> REF_36[REF_38]
RETURN REF_39""];
3[label=""Node Type: RETURN 3

EXPRESSION:
template

IRs:
RETURN template""];
}
",0,1,0,0,versions = versionsOfIdentifier[_identifier];templateOfVersionOfIdentifier[_identifier][versions[versions.length - 1]];template
./0x6b775965ff81583429ee39f4f6a5fb6889ab61eb_ext.sol,ZTKDIGITALTOKEN.approveAndCall,197,202,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x02dd48ff449f57a4632c39068e0ca0f4325c3a8d_ext.sol,Log.AddMessage,69,77,"REF_13(address) -> LastMsg.Sender,REF_13(address) (->LastMsg) := _adr(address),REF_14(uint256) -> LastMsg.Time,REF_14(uint256) (->LastMsg) := now(uint256),REF_15(uint256) -> LastMsg.Val,REF_15(uint256) (->LastMsg) := _val(uint256),REF_16(string) -> LastMsg.Data,REF_16(string) (->LastMsg) := _data(string),REF_18 -> LENGTH History,TMP_13(uint256) := REF_18(uint256),TMP_14(uint256) = TMP_13 + 1,REF_18(uint256) (->History) := TMP_14(uint256),REF_19(Log.Message) -> History[TMP_13],REF_19(Log.Message) (->History) := LastMsg(Log.Message)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
LastMsg.Sender = _adr

IRs:
REF_13(address) -> LastMsg.Sender
REF_13(address) (->LastMsg) := _adr(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
LastMsg.Time = now

IRs:
REF_14(uint256) -> LastMsg.Time
REF_14(uint256) (->LastMsg) := now(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
LastMsg.Val = _val

IRs:
REF_15(uint256) -> LastMsg.Val
REF_15(uint256) (->LastMsg) := _val(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
LastMsg.Data = _data

IRs:
REF_16(string) -> LastMsg.Data
REF_16(string) (->LastMsg) := _data(string)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
History.push(LastMsg)

IRs:
REF_18 -> LENGTH History
TMP_13(uint256) := REF_18(uint256)
TMP_14(uint256) = TMP_13 + 1
REF_18(uint256) (->History) := TMP_14(uint256)
REF_19(Log.Message) -> History[TMP_13]
REF_19(Log.Message) (->History) := LastMsg(Log.Message)""];
}
",0,1,0,0,LastMsg.Sender = _adr;LastMsg.Time = now;LastMsg.Val = _val;LastMsg.Data = _data;History.push(LastMsg)
./0x579fa0a1872459138aad423644c9c5038fa31807_ext.sol,EOMarketToken._transfer,160,190,"TMP_99 = CONVERT 0 to address,TMP_100(bool) = _to != TMP_99,TMP_101(None) = SOLIDITY_CALL require(bool)(TMP_100),REF_19(uint256) -> balances[_to],oldToVal(uint256) := REF_19(uint256),REF_20(uint256) -> balances[_from],oldFromVal(uint256) := REF_20(uint256),TMP_102(bool) = _value > 0,TMP_103(bool) = _value <= oldFromVal,TMP_104(bool) = TMP_102 && TMP_103,TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104),TMP_106(uint256) = oldToVal + _value,newToVal(uint256) := TMP_106(uint256),TMP_107(bool) = newToVal >= oldToVal,TMP_108(None) = SOLIDITY_CALL assert(bool)(TMP_107),TMP_109(bool) = newToVal <= 10,TMP_110(None) = SOLIDITY_CALL require(bool)(TMP_109),TMP_111(uint256) = oldFromVal - _value,newFromVal(uint256) := TMP_111(uint256),REF_21(uint256) -> balances[_from],REF_21(uint256) (->balances) := newFromVal(uint256),REF_22(uint256) -> balances[_to],REF_22(uint256) (->balances) := newToVal(uint256),TMP_112(bool) = newFromVal == 0,TMP_113 = CONVERT this to address,TMP_114(bool) = _from != TMP_113,TMP_115(bool) = TMP_112 && TMP_114,CONDITION TMP_115,REF_23(uint256) -> addressToIndex[_from],index(uint256) := REF_23(uint256),REF_24 -> LENGTH shareholders,TMP_116(uint256) = REF_24 - 1,lastIndex(uint256) := TMP_116(uint256),TMP_117(bool) = index != lastIndex,CONDITION TMP_117,REF_25(address) -> shareholders[index],REF_26(address) -> shareholders[lastIndex],REF_25(address) (->shareholders) := REF_26(address),REF_27(address) -> shareholders[index],REF_28(uint256) -> addressToIndex[REF_27],REF_28(uint256) (->addressToIndex) := index(uint256),REF_29(uint256) -> addressToIndex[_from],addressToIndex = delete REF_29 ,REF_30 -> LENGTH shareholders,REF_30(-> shareholders) = REF_30 - 1,TMP_118(bool) = oldToVal == 0,CONDITION TMP_118,REF_31(uint256) -> addressToIndex[_to],REF_32 -> LENGTH shareholders,REF_31(uint256) (->addressToIndex) := REF_32(uint256),REF_34 -> LENGTH shareholders,TMP_120(uint256) := REF_34(uint256),TMP_121(uint256) = TMP_120 + 1,REF_34(uint256) (->shareholders) := TMP_121(uint256),REF_35(address) -> shareholders[TMP_120],REF_35(address) (->shareholders) := _to(address),Emit Transfer(_from,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_99 = CONVERT 0 to address
TMP_100(bool) = _to != TMP_99
TMP_101(None) = SOLIDITY_CALL require(bool)(TMP_100)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
oldToVal = balances[_to]

IRs:
REF_19(uint256) -> balances[_to]
oldToVal(uint256) := REF_19(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
oldFromVal = balances[_from]

IRs:
REF_20(uint256) -> balances[_from]
oldFromVal(uint256) := REF_20(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_value > 0 && _value <= oldFromVal)

IRs:
TMP_102(bool) = _value > 0
TMP_103(bool) = _value <= oldFromVal
TMP_104(bool) = TMP_102 && TMP_103
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
newToVal = oldToVal + _value

IRs:
TMP_106(uint256) = oldToVal + _value
newToVal(uint256) := TMP_106(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
assert(bool)(newToVal >= oldToVal)

IRs:
TMP_107(bool) = newToVal >= oldToVal
TMP_108(None) = SOLIDITY_CALL assert(bool)(TMP_107)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(newToVal <= 10)

IRs:
TMP_109(bool) = newToVal <= 10
TMP_110(None) = SOLIDITY_CALL require(bool)(TMP_109)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
newFromVal = oldFromVal - _value

IRs:
TMP_111(uint256) = oldFromVal - _value
newFromVal(uint256) := TMP_111(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
balances[_from] = newFromVal

IRs:
REF_21(uint256) -> balances[_from]
REF_21(uint256) (->balances) := newFromVal(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
balances[_to] = newToVal

IRs:
REF_22(uint256) -> balances[_to]
REF_22(uint256) (->balances) := newToVal(uint256)""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
newFromVal == 0 && _from != address(this)

IRs:
TMP_112(bool) = newFromVal == 0
TMP_113 = CONVERT this to address
TMP_114(bool) = _from != TMP_113
TMP_115(bool) = TMP_112 && TMP_114
CONDITION TMP_115""];
11->12[label=""True""];
11->20[label=""False""];
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
index = addressToIndex[_from]

IRs:
REF_23(uint256) -> addressToIndex[_from]
index(uint256) := REF_23(uint256)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
lastIndex = shareholders.length - 1

IRs:
REF_24 -> LENGTH shareholders
TMP_116(uint256) = REF_24 - 1
lastIndex(uint256) := TMP_116(uint256)""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
index != lastIndex

IRs:
TMP_117(bool) = index != lastIndex
CONDITION TMP_117""];
14->15[label=""True""];
14->18[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
shareholders[index] = shareholders[lastIndex]

IRs:
REF_25(address) -> shareholders[index]
REF_26(address) -> shareholders[lastIndex]
REF_25(address) (->shareholders) := REF_26(address)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
addressToIndex[shareholders[index]] = index

IRs:
REF_27(address) -> shareholders[index]
REF_28(uint256) -> addressToIndex[REF_27]
REF_28(uint256) (->addressToIndex) := index(uint256)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
delete addressToIndex[_from]

IRs:
REF_29(uint256) -> addressToIndex[_from]
addressToIndex = delete REF_29 ""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
shareholders.length -= 1

IRs:
REF_30 -> LENGTH shareholders
REF_30(-> shareholders) = REF_30 - 1""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: IF 21

EXPRESSION:
oldToVal == 0

IRs:
TMP_118(bool) = oldToVal == 0
CONDITION TMP_118""];
21->22[label=""True""];
21->24[label=""False""];
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
addressToIndex[_to] = shareholders.length

IRs:
REF_31(uint256) -> addressToIndex[_to]
REF_32 -> LENGTH shareholders
REF_31(uint256) (->addressToIndex) := REF_32(uint256)""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
shareholders.push(_to)

IRs:
REF_34 -> LENGTH shareholders
TMP_120(uint256) := REF_34(uint256)
TMP_121(uint256) = TMP_120 + 1
REF_34(uint256) (->shareholders) := TMP_121(uint256)
REF_35(address) -> shareholders[TMP_120]
REF_35(address) (->shareholders) := _to(address)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
25->26;
26[label=""Node Type: RETURN 26

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(_to != address(0));oldToVal = balances[_to];oldFromVal = balances[_from];require(bool)(_value > 0 && _value <= oldFromVal);newToVal = oldToVal + _value;assert(bool)(newToVal >= oldToVal);require(bool)(newToVal <= 10);newFromVal = oldFromVal - _value;balances[_from] = newFromVal;balances[_to] = newToVal;newFromVal == 0 && _from != address(this);index = addressToIndex[_from];;lastIndex = shareholders.length - 1;index != lastIndex;shareholders[index] = shareholders[lastIndex];;addressToIndex[shareholders[index]] = index;delete addressToIndex[_from];shareholders.length -= 1;oldToVal == 0;addressToIndex[_to] = shareholders.length;;shareholders.push(_to);Transfer(_from,_to,_value);true"
./0xf36d9bb4e6b60ff069e5e18caeb1071f10d4cb66_ext.sol,ARMtest.approveAndCall,204,209,"REF_18(mapping(address => uint256)) -> allowed[msg.sender],REF_19(uint256) -> REF_18[spender],REF_19(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_18(mapping(address => uint256)) -> allowed[msg.sender]
REF_19(uint256) -> REF_18[spender]
REF_19(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x2716d9189adc5ee2fb35f193b79b5578c3d7bcda_ext.sol,token.approveAndCall,52,59,"TMP_4 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_4(tokenRecipient),TMP_5(bool) = INTERNAL_CALL, token.approve(address,uint256)(_spender,_value),CONDITION TMP_5,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_4 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_4(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_5(bool) = INTERNAL_CALL, token.approve(address,uint256)(_spender,_value)
CONDITION TMP_5""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0xc6720198a6f7ee5711e3491b14a5fc821174295c_ext.sol,OPTToken.burnFrom,141,149,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x35b5abaedeed12c63e04029120fa6bb084342b4d_ext.sol,BLITZ_GAME.NewQuestion,34,39,"TMP_12(bool) = msg.sender == questionSender,CONDITION TMP_12,question(string) := _question(string),responseHash(bytes32) := _responseHash(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == questionSender

IRs:
TMP_12(bool) = msg.sender == questionSender
CONDITION TMP_12""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
responseHash = _responseHash

IRs:
responseHash(bytes32) := _responseHash(bytes32)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,msg.sender == questionSender;question = _question;;responseHash = _responseHash
./0x5b72cae52d7d4cda632595574fcefdea3ae37143_ext.sol,fund_raising.setup_key,23,28,"TMP_9(bool) = keyHash == 0,CONDITION TMP_9,TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10),keyHash(bytes32) := TMP_11(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
keyHash == 0x0

IRs:
TMP_9(bool) = keyHash == 0
CONDITION TMP_9""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
keyHash = keccak256()(abi.encodePacked(key))

IRs:
TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10)
keyHash(bytes32) := TMP_11(bytes32)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,1,0,0,keyHash == 0x0;keyHash = keccak256()(abi.encodePacked(key));
./0x5ab883cfde389e09c623c049939d7553f312ac43_ext.sol,Control.fallback,44,48,"TMP_6(uint256) = totalDonateWEI + msg.value,totalDonateWEI(uint256) := TMP_6(uint256),Emit Donate(msg.sender,msg.value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
totalDonateWEI = totalDonateWEI + msg.value

IRs:
TMP_6(uint256) = totalDonateWEI + msg.value
totalDonateWEI(uint256) := TMP_6(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Donate(msg.sender,msg.value)

IRs:
Emit Donate(msg.sender,msg.value)""];
}
",0,1,0,0,"totalDonateWEI = totalDonateWEI + msg.value;Donate(msg.sender,msg.value)"
./0x0de1beed64aa3ca5f563a1ba585861748c352231_ext.sol,BioCoin.totalSupply,84,86,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x184001d794a8c91def72b8a488b67cc907d4e5be_ext.sol,Ore.transfer,22,29,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x5bd8a1298c2266f75a304581cc0d1e81f3f2a4fc_ext.sol,SUPERBRAAI.burnFrom,86,94,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xbc7981956a44b5c5de21ad30aec8099c3ca27dba_ext.sol,HodlETH.personalPercent,72,90,"REF_0(uint256) -> entryTime[msg.sender],TMP_10(uint256) = block.number - REF_0,hodl(uint256) := TMP_10(uint256),TMP_11(bool) = hodl < 30500,CONDITION TMP_11,RETURN startPercent,TMP_12(bool) = hodl > 30500,TMP_13(bool) = hodl < 61000,TMP_14(bool) = TMP_12 && TMP_13,CONDITION TMP_14,RETURN fiveDayHodlPercent,TMP_15(bool) = hodl > 61000,TMP_16(bool) = hodl < 122000,TMP_17(bool) = TMP_15 && TMP_16,CONDITION TMP_17,RETURN tenDayHodlPercent,TMP_18(bool) = hodl > 122000,CONDITION TMP_18,RETURN twentyDayHodlPercent","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
hodl = block.number - entryTime[msg.sender]

IRs:
REF_0(uint256) -> entryTime[msg.sender]
TMP_10(uint256) = block.number - REF_0
hodl(uint256) := TMP_10(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
hodl < 30500

IRs:
TMP_11(bool) = hodl < 30500
CONDITION TMP_11""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3

EXPRESSION:
(startPercent)

IRs:
RETURN startPercent""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
hodl > 30500 && hodl < 61000

IRs:
TMP_12(bool) = hodl > 30500
TMP_13(bool) = hodl < 61000
TMP_14(bool) = TMP_12 && TMP_13
CONDITION TMP_14""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: RETURN 6

EXPRESSION:
(fiveDayHodlPercent)

IRs:
RETURN fiveDayHodlPercent""];
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
hodl > 61000 && hodl < 122000

IRs:
TMP_15(bool) = hodl > 61000
TMP_16(bool) = hodl < 122000
TMP_17(bool) = TMP_15 && TMP_16
CONDITION TMP_17""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
(tenDayHodlPercent)

IRs:
RETURN tenDayHodlPercent""];
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
hodl > 122000

IRs:
TMP_18(bool) = hodl > 122000
CONDITION TMP_18""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: RETURN 12

EXPRESSION:
(twentyDayHodlPercent)

IRs:
RETURN twentyDayHodlPercent""];
13[label=""Node Type: END_IF 13
""];
}
",0,1,0,0,hodl = block.number - entryTime[msg.sender];hodl < 30500;(startPercent);;hodl > 30500 && hodl < 61000;(fiveDayHodlPercent);;hodl > 61000 && hodl < 122000;(tenDayHodlPercent);;hodl > 122000;(twentyDayHodlPercent);
./0xc79d1b9d77dcf62add2f90c827e87e29d5934d37_ext.sol,SevenTreasureGold.burnFrom,149,157,"REF_19(uint256) -> balanceOf[_from],TMP_26(bool) = REF_19 >= _value,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_28(bool) = _value <= REF_21,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_26(bool) = REF_19 >= _value
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_28(bool) = _value <= REF_21
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x1c3f48ae556893ef033e37d673f7a218454692fa_ext.sol,SWEDEN_WINS.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x2716d9189adc5ee2fb35f193b79b5578c3d7bcda_ext.sol,token.approveAndCall,52,59,"TMP_4 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_4(tokenRecipient),TMP_5(bool) = INTERNAL_CALL, token.approve(address,uint256)(_spender,_value),CONDITION TMP_5,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_4 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_4(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_5(bool) = INTERNAL_CALL, token.approve(address,uint256)(_spender,_value)
CONDITION TMP_5""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0xd389c08bb987dd7daeb31f51fce1b5b73710b38e_ext.sol,token.burnFrom,117,125,"REF_15(uint256) -> balanceOf[_from],TMP_22(bool) = REF_15 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_16(mapping(address => uint256)) -> allowance[_from],REF_17(uint256) -> REF_16[msg.sender],TMP_24(bool) = _value <= REF_17,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_18(uint256) -> balanceOf[_from],REF_18(-> balanceOf) = REF_18 - _value,REF_19(mapping(address => uint256)) -> allowance[_from],REF_20(uint256) -> REF_19[msg.sender],REF_20(-> allowance) = REF_20 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_15(uint256) -> balanceOf[_from]
TMP_22(bool) = REF_15 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_16(mapping(address => uint256)) -> allowance[_from]
REF_17(uint256) -> REF_16[msg.sender]
TMP_24(bool) = _value <= REF_17
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_18(uint256) -> balanceOf[_from]
REF_18(-> balanceOf) = REF_18 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_19(mapping(address => uint256)) -> allowance[_from]
REF_20(uint256) -> REF_19[msg.sender]
REF_20(-> allowance) = REF_20 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x848bcb77c97d449312ece071cd999e5f0d30f849_ext.sol,TokenMCT.burnFrom,148,163,"REF_19(uint256) -> balanceOf[_from],TMP_41(bool) = REF_19 >= _value,TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_43(bool) = _value <= REF_21,TMP_44(None) = SOLIDITY_CALL require(bool)(TMP_43),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_41(bool) = REF_19 >= _value
TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_43(bool) = _value <= REF_21
TMP_44(None) = SOLIDITY_CALL require(bool)(TMP_43)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xc14c848a2a5945e1a415976fc059550ecbe7b034_ext.sol,Line.random,134,141,"TMP_43(bytes) = SOLIDITY_CALL abi.encodePacked()(now,msg.sender,nonce),TMP_44(bytes32) = SOLIDITY_CALL keccak256()(TMP_43),output(bytes32) := TMP_44(bytes32),TMP_45 = CONVERT output to uint256,TMP_46(uint256) = TMP_45 % 1024,rand(uint256) := TMP_46(uint256),TMP_47(uint256) := nonce(uint256),nonce(uint256) = nonce + 1,RETURN rand","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
output = keccak256()(abi.encodePacked(now,msg.sender,nonce))

IRs:
TMP_43(bytes) = SOLIDITY_CALL abi.encodePacked()(now,msg.sender,nonce)
TMP_44(bytes32) = SOLIDITY_CALL keccak256()(TMP_43)
output(bytes32) := TMP_44(bytes32)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
rand = uint256(output) % 1024

IRs:
TMP_45 = CONVERT output to uint256
TMP_46(uint256) = TMP_45 % 1024
rand(uint256) := TMP_46(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
nonce ++

IRs:
TMP_47(uint256) := nonce(uint256)
nonce(uint256) = nonce + 1""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
rand

IRs:
RETURN rand""];
}
",0,1,0,0,"output = keccak256()(abi.encodePacked(now,msg.sender,nonce));rand = uint256(output) % 1024;nonce ++;rand"
./0x178381837f84a7a636f57a3f2946cda512e5caab_ext.sol,TreasureToken.burn,79,84,"REF_19(uint256) -> balanceOf[msg.sender],TMP_29(bool) = REF_19 >= _value,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),REF_20(uint256) -> balanceOf[msg.sender],REF_20(-> balanceOf) = REF_20 - _value,REF_21(uint256) -> balanceOf[0],REF_21(-> balanceOf) = REF_21 + _value,Emit Transfer(msg.sender,0,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_19(uint256) -> balanceOf[msg.sender]
TMP_29(bool) = REF_19 >= _value
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_20(uint256) -> balanceOf[msg.sender]
REF_20(-> balanceOf) = REF_20 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[0x0] += _value

IRs:
REF_21(uint256) -> balanceOf[0]
REF_21(-> balanceOf) = REF_21 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,0x0,_value)

IRs:
Emit Transfer(msg.sender,0,_value)""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;balanceOf[0x0] += _value;Transfer(msg.sender,0x0,_value)"
./0x505d0c2061f124c0ae03f795c4aeddd7ff9d471e_ext.sol,StandardToken.transferFrom,58,68,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0xc7db6a0e78efb4d64bb06359faf83420f04cfb52_ext.sol,play_IQUIZ.Start,28,33,"TMP_7(bool) = responseHash == 0,CONDITION TMP_7,TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response),responseHash(bytes32) := TMP_8(bytes32),question(string) := _question(string),MODIFIER_CALL, play_IQUIZ.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
responseHash == 0x0

IRs:
TMP_7(bool) = responseHash == 0
CONDITION TMP_7""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
responseHash = keccak256()(_response)

IRs:
TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response)
responseHash(bytes32) := TMP_8(bytes32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, play_IQUIZ.isAdmin()()""];
5->1;
}
",0,1,0,0,isAdmin();responseHash == 0x0;responseHash = keccak256()(_response);;question = _question
./0x07b2f3fbfda96208704e14068a50144f2ec6a37c_ext.sol,Evocoin.buyout,59,72,"TMP_23(bool) = msg.sender != owner,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),REF_20(uint256) -> balances[msg.sender],TMP_25(bool) = REF_20 > 0,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_21(uint256) -> balances[msg.sender],_value(uint256) := REF_21(uint256),REF_22(uint256) -> balances[msg.sender],REF_22(uint256) (->balances) := 0(uint256),REF_23(uint256) -> balances[owner],REF_23(-> balances) = REF_23 + _value,REF_24(Evocoin.user) -> users[userIndex],REF_25(address) -> REF_24._adress,REF_25(address) (->users) := msg.sender(address),REF_26(Evocoin.user) -> users[userIndex],REF_27(uint256) -> REF_26._value,REF_27(uint256) (->users) := _value(uint256),userIndex(uint256) = userIndex + 1,Emit Transfer(msg.sender,owner,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender != owner)

IRs:
TMP_23(bool) = msg.sender != owner
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[msg.sender] > 0)

IRs:
REF_20(uint256) -> balances[msg.sender]
TMP_25(bool) = REF_20 > 0
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
_value = balances[msg.sender]

IRs:
REF_21(uint256) -> balances[msg.sender]
_value(uint256) := REF_21(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[msg.sender] = 0

IRs:
REF_22(uint256) -> balances[msg.sender]
REF_22(uint256) (->balances) := 0(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[owner] += _value

IRs:
REF_23(uint256) -> balances[owner]
REF_23(-> balances) = REF_23 + _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
users[userIndex]._adress = msg.sender

IRs:
REF_24(Evocoin.user) -> users[userIndex]
REF_25(address) -> REF_24._adress
REF_25(address) (->users) := msg.sender(address)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
users[userIndex]._value = _value

IRs:
REF_26(Evocoin.user) -> users[userIndex]
REF_27(uint256) -> REF_26._value
REF_27(uint256) (->users) := _value(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
++ userIndex

IRs:
userIndex(uint256) = userIndex + 1""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
Transfer(msg.sender,owner,_value)

IRs:
Emit Transfer(msg.sender,owner,_value)""];
}
",0,1,0,0,"require(bool)(msg.sender != owner);require(bool)(balances[msg.sender] > 0);_value = balances[msg.sender];balances[msg.sender] = 0;balances[owner] += _value;users[userIndex]._adress = msg.sender;users[userIndex]._value = _value;++ userIndex;Transfer(msg.sender,owner,_value)"
./0x5258e585f8efe5d7ecca0a9232fc26fd8ca02436_ext.sol,KCOIN.burn,128,134,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x1d9562d5f3b53316e25952079227621adca9eb49_ext.sol,Test.burn,129,135,"REF_12(uint256) -> balanceOf[msg.sender],TMP_17(bool) = REF_12 >= _value,TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17),REF_13(uint256) -> balanceOf[msg.sender],REF_13(-> balanceOf) = REF_13 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_12(uint256) -> balanceOf[msg.sender]
TMP_17(bool) = REF_12 >= _value
TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_13(uint256) -> balanceOf[msg.sender]
REF_13(-> balanceOf) = REF_13 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xdc24f9cc79f802587b56f27a7db0833e40c8a22c_ext.sol,FuckCoin.dividendsOf,447,453,"REF_38(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_65(uint256) = profitPerShare_ * REF_38,TMP_66 = CONVERT TMP_65 to int256,REF_39(int256) -> payoutsTo_[_customerAddress],TMP_67(int256) = TMP_66 - REF_39,TMP_68 = CONVERT TMP_67 to uint256,TMP_69(uint256) = TMP_68 / magnitude,RETURN TMP_69","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_38(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_65(uint256) = profitPerShare_ * REF_38
TMP_66 = CONVERT TMP_65 to int256
REF_39(int256) -> payoutsTo_[_customerAddress]
TMP_67(int256) = TMP_66 - REF_39
TMP_68 = CONVERT TMP_67 to uint256
TMP_69(uint256) = TMP_68 / magnitude
RETURN TMP_69""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x6cbadb622d30a8c998c907911a9b160e735348fc_ext.sol,BitEspritCoin.burn,231,237,"REF_26(uint256) -> _balances[msg.sender],TMP_67(bool) = REF_26 >= _value,TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67),REF_27(uint256) -> _balances[msg.sender],REF_27(-> _balances) = REF_27 - _value,_totalSupply(uint256) = _totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,MODIFIER_CALL, Owned.onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_balances[msg.sender] >= _value)

IRs:
REF_26(uint256) -> _balances[msg.sender]
TMP_67(bool) = REF_26 >= _value
TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_balances[msg.sender] -= _value

IRs:
REF_27(uint256) -> _balances[msg.sender]
REF_27(-> _balances) = REF_27 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_totalSupply -= _value

IRs:
_totalSupply(uint256) = _totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
6->1;
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"onlyOwner();require(bool)(_balances[msg.sender] >= _value);_balances[msg.sender] -= _value;_totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xd0823c151d23678c6efe2b73b70aedf25be469fa_ext.sol,AIOToken.totalSupply,131,133,"TMP_49 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_49],TMP_50(uint256) = totalSupply - REF_1,RETURN TMP_50","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
totalSupply - balances[address(0)]

IRs:
TMP_49 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_49]
TMP_50(uint256) = totalSupply - REF_1
RETURN TMP_50""];
}
",0,1,0,0,totalSupply - balances[address(0)]
./0xf2f2a1fba8f86eed1af20e06657bbb5a4416527c_ext.sol,DiscToken.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x25c08bb7aa204d221288d9739899f4edf96f5fba_ext.sol,PornTokenV2Crowdsale.fallback,53,64,"TMP_4 = UnaryType.BANG crowdsaleClosed ,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),amount(uint256) := msg.value(uint256),TMP_6(bool) = amount > 0,CONDITION TMP_6,REF_0(uint256) -> balanceOf[msg.sender],REF_0(-> balanceOf) = REF_0 + amount,amountRaised(uint256) = amountRaised + amount,currentBalance(uint256) = currentBalance + amount,TMP_7(uint256) = amount / price,tokenAmount(uint256) := TMP_7(uint256),currentTokenAmount(uint256) = currentTokenAmount - tokenAmount,TMP_8(uint256) = tokenAmount * 1000000000000000000,HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['msg.sender', 'TMP_8']  ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! crowdsaleClosed)

IRs:
TMP_4 = UnaryType.BANG crowdsaleClosed 
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = msg.value

IRs:
amount(uint256) := msg.value(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
amount > 0

IRs:
TMP_6(bool) = amount > 0
CONDITION TMP_6""];
3->4[label=""True""];
3->10[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[msg.sender] += amount

IRs:
REF_0(uint256) -> balanceOf[msg.sender]
REF_0(-> balanceOf) = REF_0 + amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
amountRaised += amount

IRs:
amountRaised(uint256) = amountRaised + amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
currentBalance += amount

IRs:
currentBalance(uint256) = currentBalance + amount""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
tokenAmount = amount / price

IRs:
TMP_7(uint256) = amount / price
tokenAmount(uint256) := TMP_7(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
currentTokenAmount -= tokenAmount

IRs:
currentTokenAmount(uint256) = currentTokenAmount - tokenAmount""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
tokenReward.transfer(msg.sender,tokenAmount * 1000000000000000000)

IRs:
TMP_8(uint256) = tokenAmount * 1000000000000000000
HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['msg.sender', 'TMP_8']  ""];
9->10;
10[label=""Node Type: END_IF 10
""];
}
",0,1,0,0,"require(bool)(! crowdsaleClosed);amount = msg.value;amount > 0;balanceOf[msg.sender] += amount;;amountRaised += amount;currentBalance += amount;tokenAmount = amount / price;currentTokenAmount -= tokenAmount;tokenReward.transfer(msg.sender,tokenAmount * 1000000000000000000)"
./0x40d612fe5ebef1a539e5b4a6bfcab8d09aee223f_ext.sol,POTJ.dividendsOf,464,470,"REF_36(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_68(uint256) = profitPerShare_ * REF_36,TMP_69 = CONVERT TMP_68 to int256,REF_37(int256) -> payoutsTo_[_customerAddress],TMP_70(int256) = TMP_69 - REF_37,TMP_71 = CONVERT TMP_70 to uint256,TMP_72(uint256) = TMP_71 / magnitude,RETURN TMP_72","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_36(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_68(uint256) = profitPerShare_ * REF_36
TMP_69 = CONVERT TMP_68 to int256
REF_37(int256) -> payoutsTo_[_customerAddress]
TMP_70(int256) = TMP_69 - REF_37
TMP_71 = CONVERT TMP_70 to uint256
TMP_72(uint256) = TMP_71 / magnitude
RETURN TMP_72""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0xee6465f5df390676c02ebe15cdad07d63e4b1ad6_ext.sol,EthereumMoon.burn,130,136,"REF_17(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_17 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_17 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x53c2159fa4690ccaa773086a137fb1cd17f65f35_ext.sol,SafeMath.getRandomNumber,73,76,"TMP_25(uint256) = block.number - 1,TMP_26(uint256) = SOLIDITY_CALL blockhash(uint256)(TMP_25),TMP_27 = CONVERT TMP_26 to uint256,TMP_28 = CONVERT privateAddress to uint256,TMP_29(uint256) = TMP_27 + TMP_28,genNum(uint256) := TMP_29(uint256),TMP_30(uint16) = maxRandom - min,TMP_31(uint16) = TMP_30 + 1,TMP_32(uint256) = genNum % TMP_31,TMP_33(uint256) = TMP_32 + min,TMP_34 = CONVERT TMP_33 to uint8,RETURN TMP_34","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
genNum = uint256(block.blockhash(block.number - 1)) + uint256(privateAddress)

IRs:
TMP_25(uint256) = block.number - 1
TMP_26(uint256) = SOLIDITY_CALL blockhash(uint256)(TMP_25)
TMP_27 = CONVERT TMP_26 to uint256
TMP_28 = CONVERT privateAddress to uint256
TMP_29(uint256) = TMP_27 + TMP_28
genNum(uint256) := TMP_29(uint256)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
uint8(genNum % (maxRandom - min + 1) + min)

IRs:
TMP_30(uint16) = maxRandom - min
TMP_31(uint16) = TMP_30 + 1
TMP_32(uint256) = genNum % TMP_31
TMP_33(uint256) = TMP_32 + min
TMP_34 = CONVERT TMP_33 to uint8
RETURN TMP_34""];
}
",0,1,0,0,genNum = uint256(block.blockhash(block.number - 1)) + uint256(privateAddress);uint8(genNum % (maxRandom - min + 1) + min)
./0x842d6da3097b5efde5a81535144f947ab482b6ee_ext.sol,WhoTheEth.setName,30,36,"TMP_3(bool) = msg.value >= 1000000000000000,TMP_4(bool) = numberOfNames < 500,TMP_5(bool) = TMP_3 || TMP_4,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),TMP_7(uint256) := numberOfNames(uint256),numberOfNames(uint256) = numberOfNames + 1,REF_4(string) -> names[msg.sender],REF_4(string) (->names) := newName(string),REF_5(uint256) -> bank[owner],REF_5(-> bank) = REF_5 + msg.value,Emit AddedName(msg.sender,newName,now,owner,msg.value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= 1000000000000000 || numberOfNames < 500)

IRs:
TMP_3(bool) = msg.value >= 1000000000000000
TMP_4(bool) = numberOfNames < 500
TMP_5(bool) = TMP_3 || TMP_4
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
numberOfNames ++

IRs:
TMP_7(uint256) := numberOfNames(uint256)
numberOfNames(uint256) = numberOfNames + 1""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
names[msg.sender] = newName

IRs:
REF_4(string) -> names[msg.sender]
REF_4(string) (->names) := newName(string)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
bank[owner] += msg.value

IRs:
REF_5(uint256) -> bank[owner]
REF_5(-> bank) = REF_5 + msg.value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
AddedName(msg.sender,newName,now,owner,msg.value)

IRs:
Emit AddedName(msg.sender,newName,now,owner,msg.value)""];
}
",0,1,0,0,"require(bool)(msg.value >= 1000000000000000 || numberOfNames < 500);numberOfNames ++;names[msg.sender] = newName;bank[owner] += msg.value;AddedName(msg.sender,newName,now,owner,msg.value)"
./0x92e55c6ee3171779174cebb27211120b730c155c_ext.sol,SantimentWhiteList.addPack,59,84,"REF_0 -> LENGTH addrs,len(uint256) := REF_0(uint256),TMP_0(uint16) := chunkNr(uint16),chunkNr(uint16) = chunkNr + 1,TMP_1(bool) = TMP_0 == _chunkNr,TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1),REF_1 -> LENGTH mins,TMP_3(bool) = REF_1 == len,REF_2 -> LENGTH mins,TMP_4(bool) = REF_2 == len,TMP_5(bool) = TMP_3 && TMP_4,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),i(uint16) := 0(uint256),TMP_7(bool) = i < len,CONDITION TMP_7,REF_3(address) -> addrs[i],addr(address) := REF_3(address),REF_4(uint24) -> maxs[i],max(uint24) := REF_4(uint24),REF_5(uint24) -> mins[i],min(uint24) := REF_5(uint24),REF_6(SantimentWhiteList.Limit) -> allowed[addr],lim(SantimentWhiteList.Limit) := REF_6(SantimentWhiteList.Limit),REF_7(uint24) -> lim.max,TMP_8(bool) = REF_7 > 0,CONDITION TMP_8,TMP_9 = CONVERT addr to uint160,REF_8(uint24) -> lim.min,TMP_10(uint160) = TMP_9 + REF_8,REF_9(uint24) -> lim.max,TMP_11(uint160) = TMP_10 + REF_9,controlSum(uint256) = controlSum - TMP_11,REF_10(SantimentWhiteList.Limit) -> allowed[addr],allowed = delete REF_10 ,TMP_12(bool) = max > 0,CONDITION TMP_12,REF_11(SantimentWhiteList.Limit) -> allowed[addr],TMP_13(SantimentWhiteList.Limit) = new Limit(min,max),REF_11(SantimentWhiteList.Limit) (->allowed) := TMP_13(SantimentWhiteList.Limit),TMP_14 = CONVERT addr to uint160,TMP_15(uint160) = TMP_14 + min,TMP_16(uint160) = TMP_15 + max,controlSum(uint256) = controlSum + TMP_16,i(uint16) = i + 1,recordNum(uint256) = recordNum + len,MODIFIER_CALL, SantimentWhiteList.setupOnly()(),MODIFIER_CALL, SantimentWhiteList.adminOnly()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->22;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
len = addrs.length

IRs:
REF_0 -> LENGTH addrs
len(uint256) := REF_0(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(chunkNr ++ == _chunkNr)

IRs:
TMP_0(uint16) := chunkNr(uint16)
chunkNr(uint16) = chunkNr + 1
TMP_1(bool) = TMP_0 == _chunkNr
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(mins.length == len && mins.length == len)

IRs:
REF_1 -> LENGTH mins
TMP_3(bool) = REF_1 == len
REF_2 -> LENGTH mins
TMP_4(bool) = REF_2 == len
TMP_5(bool) = TMP_3 && TMP_4
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
3->6;
4[label=""Node Type: BEGIN_LOOP 4
""];
4->7;
5[label=""Node Type: END_LOOP 5
""];
5->21;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint16) := 0(uint256)""];
6->4;
7[label=""Node Type: IF_LOOP 7

EXPRESSION:
i < len

IRs:
TMP_7(bool) = i < len
CONDITION TMP_7""];
7->8[label=""True""];
7->5[label=""False""];
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
addr = addrs[i]

IRs:
REF_3(address) -> addrs[i]
addr(address) := REF_3(address)""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
max = maxs[i]

IRs:
REF_4(uint24) -> maxs[i]
max(uint24) := REF_4(uint24)""];
9->10;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
min = mins[i]

IRs:
REF_5(uint24) -> mins[i]
min(uint24) := REF_5(uint24)""];
10->11;
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
lim = allowed[addr]

IRs:
REF_6(SantimentWhiteList.Limit) -> allowed[addr]
lim(SantimentWhiteList.Limit) := REF_6(SantimentWhiteList.Limit)""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
lim.max > 0

IRs:
REF_7(uint24) -> lim.max
TMP_8(bool) = REF_7 > 0
CONDITION TMP_8""];
12->13[label=""True""];
12->15[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
controlSum -= uint160(addr) + lim.min + lim.max

IRs:
TMP_9 = CONVERT addr to uint160
REF_8(uint24) -> lim.min
TMP_10(uint160) = TMP_9 + REF_8
REF_9(uint24) -> lim.max
TMP_11(uint160) = TMP_10 + REF_9
controlSum(uint256) = controlSum - TMP_11""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
delete allowed[addr]

IRs:
REF_10(SantimentWhiteList.Limit) -> allowed[addr]
allowed = delete REF_10 ""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: IF 16

EXPRESSION:
max > 0

IRs:
TMP_12(bool) = max > 0
CONDITION TMP_12""];
16->17[label=""True""];
16->19[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
allowed[addr] = Limit({min:min,max:max})

IRs:
REF_11(SantimentWhiteList.Limit) -> allowed[addr]
TMP_13(SantimentWhiteList.Limit) = new Limit(min,max)
REF_11(SantimentWhiteList.Limit) (->allowed) := TMP_13(SantimentWhiteList.Limit)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
controlSum += uint160(addr) + min + max

IRs:
TMP_14 = CONVERT addr to uint160
TMP_15(uint160) = TMP_14 + min
TMP_16(uint160) = TMP_15 + max
controlSum(uint256) = controlSum + TMP_16""];
18->19;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
++ i

IRs:
i(uint16) = i + 1""];
20->7;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
recordNum += len

IRs:
recordNum(uint256) = recordNum + len""];
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
setupOnly()

IRs:
MODIFIER_CALL, SantimentWhiteList.setupOnly()()""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
adminOnly()

IRs:
MODIFIER_CALL, SantimentWhiteList.adminOnly()()""];
23->1;
}
",0,1,0,0,"setupOnly();len = addrs.length;require(bool)(chunkNr ++ == _chunkNr);require(bool)(mins.length == len && mins.length == len);i = 0;;i < len;;recordNum += len;addr = addrs[i];max = maxs[i];min = mins[i];lim = allowed[addr];lim.max > 0;controlSum -= uint160(addr) + lim.min + lim.max;;delete allowed[addr];max > 0;allowed[addr] = Limit({min:min,max:max});;controlSum += uint160(addr) + min + max;++ i;adminOnly()"
./0xd4b36aadb0d90a32dbc15537db6e3054c52a3f62_ext.sol,TokenERC20.burn,145,151,"REF_17(uint256) -> balanceOf[msg.sender],TMP_25(bool) = REF_17 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_25(bool) = REF_17 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x6c940a8d477922f1cffe012449321098e06db3f7_ext.sol,CryptoGain.search_winner_bid_address,99,119,"TMP_32(bool) = slot < 128,CONDITION TMP_32,i(uint8) := 0(uint256),REF_8 -> LENGTH bids,TMP_33(bool) = i < REF_8,CONDITION TMP_33,REF_9(CryptoGain.Bid) -> bids[i],REF_10(uint8) -> REF_9.slot_from,REF_11(CryptoGain.Bid) -> bids[i],REF_12(uint8) -> REF_11.slot_to,TMP_34(bool) = INTERNAL_CALL, CryptoGain.is_slot_in_bid(uint8,uint8,uint8)(REF_10,REF_12,slot),CONDITION TMP_34,REF_13(CryptoGain.Bid) -> bids[i],REF_14(address) -> REF_13.player,RETURN REF_14,TMP_35(uint8) := i(uint8),i(uint8) = i + 1,REF_15 -> LENGTH bids,TMP_36 = CONVERT REF_15 to uint8,TMP_37(uint8) = TMP_36 - 1,i(uint8) := TMP_37(uint8),TMP_38(bool) = i >= 0,CONDITION TMP_38,REF_16(CryptoGain.Bid) -> bids[i],REF_17(uint8) -> REF_16.slot_from,REF_18(CryptoGain.Bid) -> bids[i],REF_19(uint8) -> REF_18.slot_to,TMP_39(bool) = INTERNAL_CALL, CryptoGain.is_slot_in_bid(uint8,uint8,uint8)(REF_17,REF_19,slot),CONDITION TMP_39,REF_20(CryptoGain.Bid) -> bids[i],REF_21(address) -> REF_20.player,RETURN REF_21,TMP_40(uint8) := i(uint8),i(uint8) = i - 1,TMP_41(None) = SOLIDITY_CALL assert(bool)(False)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
slot < 128

IRs:
TMP_32(bool) = slot < 128
CONDITION TMP_32""];
2->5[label=""True""];
2->13[label=""False""];
3[label=""Node Type: BEGIN_LOOP 3
""];
3->6;
4[label=""Node Type: END_LOOP 4
""];
4->19;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)""];
5->3;
6[label=""Node Type: IF_LOOP 6

EXPRESSION:
i < bids.length

IRs:
REF_8 -> LENGTH bids
TMP_33(bool) = i < REF_8
CONDITION TMP_33""];
6->7[label=""True""];
6->4[label=""False""];
7[label=""Node Type: IF 7

EXPRESSION:
is_slot_in_bid(bids[i].slot_from,bids[i].slot_to,slot)

IRs:
REF_9(CryptoGain.Bid) -> bids[i]
REF_10(uint8) -> REF_9.slot_from
REF_11(CryptoGain.Bid) -> bids[i]
REF_12(uint8) -> REF_11.slot_to
TMP_34(bool) = INTERNAL_CALL, CryptoGain.is_slot_in_bid(uint8,uint8,uint8)(REF_10,REF_12,slot)
CONDITION TMP_34""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: RETURN 8

EXPRESSION:
bids[i].player

IRs:
REF_13(CryptoGain.Bid) -> bids[i]
REF_14(address) -> REF_13.player
RETURN REF_14""];
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
i ++

IRs:
TMP_35(uint8) := i(uint8)
i(uint8) = i + 1""];
10->6;
11[label=""Node Type: BEGIN_LOOP 11
""];
11->14;
12[label=""Node Type: END_LOOP 12
""];
12->19;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
i = uint8(bids.length) - 1

IRs:
REF_15 -> LENGTH bids
TMP_36 = CONVERT REF_15 to uint8
TMP_37(uint8) = TMP_36 - 1
i(uint8) := TMP_37(uint8)""];
13->11;
14[label=""Node Type: IF_LOOP 14

EXPRESSION:
i >= 0

IRs:
TMP_38(bool) = i >= 0
CONDITION TMP_38""];
14->15[label=""True""];
14->12[label=""False""];
15[label=""Node Type: IF 15

EXPRESSION:
is_slot_in_bid(bids[i].slot_from,bids[i].slot_to,slot)

IRs:
REF_16(CryptoGain.Bid) -> bids[i]
REF_17(uint8) -> REF_16.slot_from
REF_18(CryptoGain.Bid) -> bids[i]
REF_19(uint8) -> REF_18.slot_to
TMP_39(bool) = INTERNAL_CALL, CryptoGain.is_slot_in_bid(uint8,uint8,uint8)(REF_17,REF_19,slot)
CONDITION TMP_39""];
15->16[label=""True""];
15->17[label=""False""];
16[label=""Node Type: RETURN 16

EXPRESSION:
bids[i].player

IRs:
REF_20(CryptoGain.Bid) -> bids[i]
REF_21(address) -> REF_20.player
RETURN REF_21""];
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
i --

IRs:
TMP_40(uint8) := i(uint8)
i(uint8) = i - 1""];
18->14;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
assert(bool)(false)

IRs:
TMP_41(None) = SOLIDITY_CALL assert(bool)(False)""];
}
",0,1,0,0,";slot < 128;i = 0;i = uint8(bids.length) - 1;;i < bids.length;;;is_slot_in_bid(bids[i].slot_from,bids[i].slot_to,slot);bids[i].player;;i ++;;i >= 0;;is_slot_in_bid(bids[i].slot_from,bids[i].slot_to,slot);bids[i].player;;i --;assert(bool)(false)"
./0x9c49b65ddef30ad4a32c0ff6bf103144cd7733fc_ext.sol,Sports3D.dividendsOf,381,383,"REF_59(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_87(uint256) = profitPerShare_ * REF_59,TMP_88 = CONVERT TMP_87 to int256,REF_60(int256) -> payoutsTo_[_customerAddress],TMP_89(int256) = TMP_88 - REF_60,TMP_90 = CONVERT TMP_89 to uint256,TMP_91(uint256) = TMP_90 / magnitude,RETURN TMP_91","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_59(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_87(uint256) = profitPerShare_ * REF_59
TMP_88 = CONVERT TMP_87 to int256
REF_60(int256) -> payoutsTo_[_customerAddress]
TMP_89(int256) = TMP_88 - REF_60
TMP_90 = CONVERT TMP_89 to uint256
TMP_91(uint256) = TMP_90 / magnitude
RETURN TMP_91""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0xf2d3bee00851fdf205f4fe825fe89d2abff88231_ext.sol,WOB._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xbca5b3524e2d52c38fd6ca6dd10233575baa8533_ext.sol,VOCC_I098_20181211.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x480b94c1c794299157765988746cd97bea20a9b9_ext.sol,TasnimCoin.burnFrom,151,159,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x87b9d30c83317d1c07f49c7583bef7e8eea24107_ext.sol,SecurityTokenZhiFu.transfer,109,119,"REF_1(uint256) -> balances[msg.sender],TMP_21(bool) = REF_1 >= _value,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),TMP_23(bool) = msg.sender == _to,REF_2(uint256) -> balances[_to],TMP_24(uint256) = MAX_UINT256 - _value,TMP_25(bool) = REF_2 <= TMP_24,TMP_26(bool) = TMP_23 || TMP_25,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_3(uint256) -> balances[msg.sender],REF_3(-> balances) = REF_3 - _value,REF_4(uint256) -> balances[_to],REF_4(-> balances) = REF_4 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_21(bool) = REF_1 >= _value
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == _to || balances[_to] <= MAX_UINT256 - _value)

IRs:
TMP_23(bool) = msg.sender == _to
REF_2(uint256) -> balances[_to]
TMP_24(uint256) = MAX_UINT256 - _value
TMP_25(bool) = REF_2 <= TMP_24
TMP_26(bool) = TMP_23 || TMP_25
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_3(uint256) -> balances[msg.sender]
REF_3(-> balances) = REF_3 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] += _value

IRs:
REF_4(uint256) -> balances[_to]
REF_4(-> balances) = REF_4 + _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);require(bool)(msg.sender == _to || balances[_to] <= MAX_UINT256 - _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true"
./0x454a5244556e044ad6ecfcf3f59290fae47484e8_ext.sol,MintableToken.mint,178,184,"totalSupply(uint256) = totalSupply + _amount,REF_50(uint256) -> balances[_to],REF_50(-> balances) = REF_50 + _amount,Emit Mint(_to,_amount),TMP_57 = CONVERT 0 to address,Emit Transfer(TMP_57,_to,_amount),RETURN True,MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, MintableToken.canMint()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
totalSupply += _amount

IRs:
totalSupply(uint256) = totalSupply + _amount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _amount

IRs:
REF_50(uint256) -> balances[_to]
REF_50(-> balances) = REF_50 + _amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Mint(_to,_amount)

IRs:
Emit Mint(_to,_amount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(address(0),_to,_amount)

IRs:
TMP_57 = CONVERT 0 to address
Emit Transfer(TMP_57,_to,_amount)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()""];
7->1;
}
",0,1,0,0,"onlyOwner();totalSupply += _amount;balances[_to] += _amount;Mint(_to,_amount);Transfer(address(0),_to,_amount);true;canMint()"
./0x2b684e8905a850a91f5eea913a19dae3926a6703_ext.sol,BWUtility.ceil,9,11,"TMP_0(uint256) = _amount + _multiple,TMP_1(uint256) = TMP_0 - 1,TMP_2(uint256) = TMP_1 / _multiple,TMP_3(uint256) = TMP_2 * _multiple,RETURN TMP_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
((_amount + _multiple - 1) / _multiple) * _multiple

IRs:
TMP_0(uint256) = _amount + _multiple
TMP_1(uint256) = TMP_0 - 1
TMP_2(uint256) = TMP_1 / _multiple
TMP_3(uint256) = TMP_2 * _multiple
RETURN TMP_3""];
}
",0,1,0,0,((_amount + _multiple - 1) / _multiple) * _multiple
./0x6e850bf8607a37e84a489008eeb94fb19331b061_ext.sol,FastEth.getQueueLength,223,225,"REF_25 -> LENGTH queue,TMP_45(uint256) = REF_25 - currentReceiverIndex,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
queue.length - currentReceiverIndex

IRs:
REF_25 -> LENGTH queue
TMP_45(uint256) = REF_25 - currentReceiverIndex
RETURN TMP_45""];
}
",0,1,0,0,queue.length - currentReceiverIndex
./0x737717b587fae986354660d023eefbcec4552558_ext.sol,TokenERC20.burnFrom,71,79,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x6c605dafbb54c2bc2cbc8446b645a9835ed56cce_ext.sol,Botcash.transfer,53,64,"REF_8(uint256) -> balanceOf[msg.sender],TMP_21(bool) = REF_8 >= _value,REF_9(uint256) -> balanceOf[_to],TMP_22(uint256) = REF_9 + _value,REF_10(uint256) -> balanceOf[_to],TMP_23(bool) = TMP_22 >= REF_10,TMP_24(bool) = TMP_21 && TMP_23,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_11(uint256) -> balanceOf[msg.sender],REF_11(-> balanceOf) = REF_11 - _value,REF_12(uint256) -> balanceOf[_to],REF_12(-> balanceOf) = REF_12 + _value,REF_13(uint256) = SOLIDITY_CALL balance(address)(msg.sender),TMP_26(bool) = REF_13 < minBalanceForAccounts,CONDITION TMP_26,REF_14(uint256) = SOLIDITY_CALL balance(address)(msg.sender),TMP_27(uint256) = minBalanceForAccounts - REF_14,TMP_28(uint256) = TMP_27 / sellPrice,TMP_29(uint256) = INTERNAL_CALL, Botcash.sell(uint256)(TMP_28),Emit Transfer(msg.sender,_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_8(uint256) -> balanceOf[msg.sender]
TMP_21(bool) = REF_8 >= _value
REF_9(uint256) -> balanceOf[_to]
TMP_22(uint256) = REF_9 + _value
REF_10(uint256) -> balanceOf[_to]
TMP_23(bool) = TMP_22 >= REF_10
TMP_24(bool) = TMP_21 && TMP_23
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_11(uint256) -> balanceOf[msg.sender]
REF_11(-> balanceOf) = REF_11 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_12(uint256) -> balanceOf[_to]
REF_12(-> balanceOf) = REF_12 + _value""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
msg.sender.balance < minBalanceForAccounts

IRs:
REF_13(uint256) = SOLIDITY_CALL balance(address)(msg.sender)
TMP_26(bool) = REF_13 < minBalanceForAccounts
CONDITION TMP_26""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
sell((minBalanceForAccounts - msg.sender.balance) / sellPrice)

IRs:
REF_14(uint256) = SOLIDITY_CALL balance(address)(msg.sender)
TMP_27(uint256) = minBalanceForAccounts - REF_14
TMP_28(uint256) = TMP_27 / sellPrice
TMP_29(uint256) = INTERNAL_CALL, Botcash.sell(uint256)(TMP_28)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);balanceOf[msg.sender] -= _value;balanceOf[_to] += _value;msg.sender.balance < minBalanceForAccounts;sell((minBalanceForAccounts - msg.sender.balance) / sellPrice);;Transfer(msg.sender,_to,_value)"
./0x6ce4642936028cf493c9bdd72e78130297cb77ea_ext.sol,Ownable.confirmOwnership,245,255,"TMP_60(bool) = msg.sender == ownerCandidate,TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60),owner(address) := ownerCandidate(address),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == ownerCandidate)

IRs:
TMP_60(bool) = msg.sender == ownerCandidate
TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner = ownerCandidate

IRs:
owner(address) := ownerCandidate(address)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,require(bool)(msg.sender == ownerCandidate);owner = ownerCandidate;true
./0x5aa4769f204f0b9e8d9c852377bf90fbe5bf2aeb_ext.sol,MultiX250max03eth.getQueueLength,187,189,"REF_30 -> LENGTH queue,TMP_43(uint256) = REF_30 - currentReceiverIndex,RETURN TMP_43","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
queue.length - currentReceiverIndex

IRs:
REF_30 -> LENGTH queue
TMP_43(uint256) = REF_30 - currentReceiverIndex
RETURN TMP_43""];
}
",0,1,0,0,queue.length - currentReceiverIndex
./0x00ea6f91b00e080e816f1bb2fad71b0fe1528983_ext.sol,VCOIN.approveAndCall,155,160,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xf2f2a1fba8f86eed1af20e06657bbb5a4416527c_ext.sol,DiscToken.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x5544138f866b9a76c7c020719a094c530bac72fe_ext.sol,LuckGameToken.burn,117,123,"REF_14(uint256) -> balanceOf[msg.sender],TMP_67(bool) = REF_14 >= _value,TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67),REF_15(uint256) -> balanceOf[msg.sender],REF_15(-> balanceOf) = REF_15 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,MODIFIER_CALL, LuckGameToken.onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_14(uint256) -> balanceOf[msg.sender]
TMP_67(bool) = REF_14 >= _value
TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_15(uint256) -> balanceOf[msg.sender]
REF_15(-> balanceOf) = REF_15 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, LuckGameToken.onlyOwner()()""];
6->1;
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"onlyOwner();require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xdfbfd64726b1b178ef8204ae4992f641f31c8248_ext.sol,EloPlayToken.buyPriceAt,339,360,"TMP_59(bool) = _at < START_TS,CONDITION TMP_59,RETURN 0,TMP_60(uint256) = START_TS + 3600,TMP_61(bool) = _at < TMP_60,CONDITION TMP_61,RETURN 12000,TMP_62(uint256) = 3600 * 24,TMP_63(uint256) = START_TS + TMP_62,TMP_64(bool) = _at < TMP_63,CONDITION TMP_64,RETURN 11500,TMP_65(uint256) = 3600 * 24,TMP_66(uint256) = TMP_65 * 7,TMP_67(uint256) = START_TS + TMP_66,TMP_68(bool) = _at < TMP_67,CONDITION TMP_68,RETURN 11000,TMP_69(uint256) = 3600 * 24,TMP_70(uint256) = TMP_69 * 7,TMP_71(uint256) = TMP_70 * 2,TMP_72(uint256) = START_TS + TMP_71,TMP_73(bool) = _at < TMP_72,CONDITION TMP_73,RETURN 10500,TMP_74(bool) = _at <= END_TS,CONDITION TMP_74,RETURN 10000,RETURN 0","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_at < START_TS

IRs:
TMP_59(bool) = _at < START_TS
CONDITION TMP_59""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0""];
3[label=""Node Type: IF 3

EXPRESSION:
_at < START_TS + 3600

IRs:
TMP_60(uint256) = START_TS + 3600
TMP_61(bool) = _at < TMP_60
CONDITION TMP_61""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: RETURN 4

EXPRESSION:
12000

IRs:
RETURN 12000""];
5[label=""Node Type: IF 5

EXPRESSION:
_at < START_TS + 3600 * 24

IRs:
TMP_62(uint256) = 3600 * 24
TMP_63(uint256) = START_TS + TMP_62
TMP_64(bool) = _at < TMP_63
CONDITION TMP_64""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: RETURN 6

EXPRESSION:
11500

IRs:
RETURN 11500""];
7[label=""Node Type: IF 7

EXPRESSION:
_at < START_TS + 3600 * 24 * 7

IRs:
TMP_65(uint256) = 3600 * 24
TMP_66(uint256) = TMP_65 * 7
TMP_67(uint256) = START_TS + TMP_66
TMP_68(bool) = _at < TMP_67
CONDITION TMP_68""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: RETURN 8

EXPRESSION:
11000

IRs:
RETURN 11000""];
9[label=""Node Type: IF 9

EXPRESSION:
_at < START_TS + 3600 * 24 * 7 * 2

IRs:
TMP_69(uint256) = 3600 * 24
TMP_70(uint256) = TMP_69 * 7
TMP_71(uint256) = TMP_70 * 2
TMP_72(uint256) = START_TS + TMP_71
TMP_73(bool) = _at < TMP_72
CONDITION TMP_73""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: RETURN 10

EXPRESSION:
10500

IRs:
RETURN 10500""];
11[label=""Node Type: IF 11

EXPRESSION:
_at <= END_TS

IRs:
TMP_74(bool) = _at <= END_TS
CONDITION TMP_74""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: RETURN 12

EXPRESSION:
10000

IRs:
RETURN 10000""];
13[label=""Node Type: RETURN 13

EXPRESSION:
0

IRs:
RETURN 0""];
}
",0,1,0,0,_at < START_TS;0;_at < START_TS + 3600;12000;_at < START_TS + 3600 * 24;11500;_at < START_TS + 3600 * 24 * 7;11000;_at < START_TS + 3600 * 24 * 7 * 2;10500;_at <= END_TS;10000;0
./0x128a0cdaf3bb00e4b5357e02ff0682933beb407f_ext.sol,ERC20Connect.totalSupply,87,89,"TMP_32 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_32],TMP_33(uint256) = _totalSupply - REF_1,RETURN TMP_33","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_32 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_32]
TMP_33(uint256) = _totalSupply - REF_1
RETURN TMP_33""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x26c0e6f69b18125f68ac55f439b1e10c2a2e5c03_ext.sol,Owners.addOwner,214,219,"TMP_65 = CONVERT 0 to address,TMP_66(bool) = _address != TMP_65,TMP_67(None) = SOLIDITY_CALL require(bool)(TMP_66),REF_55(bool) -> owners[_address],REF_55(bool) (->owners) := True(bool),TMP_68(uint256) := ownersCount(uint256),ownersCount(uint256) = ownersCount + 1,Emit OwnerAdded(_address),MODIFIER_CALL, Owners.ownerOnly()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_address != address(0))

IRs:
TMP_65 = CONVERT 0 to address
TMP_66(bool) = _address != TMP_65
TMP_67(None) = SOLIDITY_CALL require(bool)(TMP_66)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owners[_address] = true

IRs:
REF_55(bool) -> owners[_address]
REF_55(bool) (->owners) := True(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ownersCount ++

IRs:
TMP_68(uint256) := ownersCount(uint256)
ownersCount(uint256) = ownersCount + 1""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
OwnerAdded(_address)

IRs:
Emit OwnerAdded(_address)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
ownerOnly()

IRs:
MODIFIER_CALL, Owners.ownerOnly()()""];
5->1;
}
",0,1,0,0,ownerOnly();require(bool)(_address != address(0));owners[_address] = true;ownersCount ++;OwnerAdded(_address)
./0x268f03c41d3f33a697eed9c7f0632053556fae9e_ext.sol,BountyClaims.setUsersBounty,150,154,"i(uint256) := 0(uint256),REF_0 -> LENGTH _beneficiaries,TMP_31(bool) = i < REF_0,CONDITION TMP_31,REF_1(address) -> _beneficiaries[i],REF_2(uint256) -> bountyTokens[REF_1],REF_3(uint256) -> _amounts[i],REF_2(uint256) (->bountyTokens) := REF_3(uint256),TMP_32(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _beneficiaries.length

IRs:
REF_0 -> LENGTH _beneficiaries
TMP_31(bool) = i < REF_0
CONDITION TMP_31""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
bountyTokens[_beneficiaries[i]] = _amounts[i]

IRs:
REF_1(address) -> _beneficiaries[i]
REF_2(uint256) -> bountyTokens[REF_1]
REF_3(uint256) -> _amounts[i]
REF_2(uint256) (->bountyTokens) := REF_3(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_32(uint256) := i(uint256)
i(uint256) = i + 1""];
6->4;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->3;
}
",0,1,0,0,onlyOwner();;i < _beneficiaries.length;;i = 0;bountyTokens[_beneficiaries[i]] = _amounts[i];i ++
./0x8bf1e43e3ca6f5c25c380803154ae687d682ad32_ext.sol,RDFDM.quickAuditEthCredited,271,301,"TMP_79(bool) = _charity < charityCount,TMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79),REF_72(RDFDM.Charity) -> charities[_charity],REF_73(uint256) -> REF_72.fiatCollected,_fiatCollected(uint256) := REF_73(uint256),REF_74(RDFDM.Charity) -> charities[_charity],REF_75(uint256) -> REF_74.fiatBalanceIn,_fiatToEthNotProcessed(uint256) := REF_75(uint256),TMP_81(uint256) = _fiatCollected - _fiatToEthNotProcessed,_fiatToEthProcessed(uint256) := TMP_81(uint256),REF_76(RDFDM.Charity) -> charities[_charity],REF_77(uint256) -> REF_76.fiatToEthPriceAccEth,TMP_82(bool) = REF_77 == 0,CONDITION TMP_82,_fiatToEthPricePerEth(uint256) := 0(uint256),_fiatToEthCreditedFinney(uint256) := 0(uint256),REF_78(RDFDM.Charity) -> charities[_charity],REF_79(uint256) -> REF_78.fiatToEthPriceAccFiat,TMP_83(uint256) = REF_79 * 1000000000000000000,REF_80(RDFDM.Charity) -> charities[_charity],REF_81(uint256) -> REF_80.fiatToEthPriceAccEth,TMP_84(uint256) = TMP_83 / REF_81,_fiatToEthPricePerEth(uint256) := TMP_84(uint256),TMP_85(uint256) = 1000000000000000000 / 1000000000000000,TMP_86(uint256) = _fiatToEthProcessed * TMP_85,TMP_87(uint256) = TMP_86 / _fiatToEthPricePerEth,_fiatToEthCreditedFinney(uint256) := TMP_87(uint256),TMP_88(uint256) = _fiatToEthCreditedFinney * 8,TMP_89(uint256) = TMP_88 / 10,_fiatToEthAfterFeesFinney(uint256) := TMP_89(uint256),REF_82(RDFDM.Charity) -> charities[_charity],REF_83(uint256) -> REF_82.ethDonated,TMP_90(uint256) = REF_83 / 1000000000000000,_ethDonatedFinney(uint256) := TMP_90(uint256),TMP_91(uint256) = _ethDonatedFinney * 98,TMP_92(uint256) = TMP_91 / 100,_ethDonatedAfterFeesFinney(uint256) := TMP_92(uint256),TMP_93(uint256) = _fiatToEthAfterFeesFinney + _ethDonatedAfterFeesFinney,_totalEthCreditedFinney(uint256) := TMP_93(uint256),REF_84(RDFDM.Charity) -> charities[_charity],REF_85(uint256) -> REF_84.ethCredited,TMP_94(uint256) = 1000000000000000000 / 1000000000000000,TMP_95(uint256) = REF_85 * TMP_94,tecf(uint256) := TMP_95(uint256),TMP_96 = CONVERT _totalEthCreditedFinney to int256,TMP_97 = CONVERT tecf to int256,TMP_98(int256) = TMP_96 - TMP_97,_quickDiscrepancy(int256) := TMP_98(int256),RETURN _fiatCollected,_fiatToEthNotProcessed,_fiatToEthProcessed,_fiatToEthPricePerEth,_fiatToEthCreditedFinney,_fiatToEthAfterFeesFinney,_ethDonatedFinney,_ethDonatedAfterFeesFinney,_totalEthCreditedFinney,_quickDiscrepancy","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_charity < charityCount)

IRs:
TMP_79(bool) = _charity < charityCount
TMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_fiatCollected = charities[_charity].fiatCollected

IRs:
REF_72(RDFDM.Charity) -> charities[_charity]
REF_73(uint256) -> REF_72.fiatCollected
_fiatCollected(uint256) := REF_73(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_fiatToEthNotProcessed = charities[_charity].fiatBalanceIn

IRs:
REF_74(RDFDM.Charity) -> charities[_charity]
REF_75(uint256) -> REF_74.fiatBalanceIn
_fiatToEthNotProcessed(uint256) := REF_75(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
_fiatToEthProcessed = _fiatCollected - _fiatToEthNotProcessed

IRs:
TMP_81(uint256) = _fiatCollected - _fiatToEthNotProcessed
_fiatToEthProcessed(uint256) := TMP_81(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
charities[_charity].fiatToEthPriceAccEth == 0

IRs:
REF_76(RDFDM.Charity) -> charities[_charity]
REF_77(uint256) -> REF_76.fiatToEthPriceAccEth
TMP_82(bool) = REF_77 == 0
CONDITION TMP_82""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
_fiatToEthPricePerEth = 0

IRs:
_fiatToEthPricePerEth(uint256) := 0(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
_fiatToEthCreditedFinney = 0

IRs:
_fiatToEthCreditedFinney(uint256) := 0(uint256)""];
7->11;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
_fiatToEthPricePerEth = (charities[_charity].fiatToEthPriceAccFiat * (1000000000000000000)) / charities[_charity].fiatToEthPriceAccEth

IRs:
REF_78(RDFDM.Charity) -> charities[_charity]
REF_79(uint256) -> REF_78.fiatToEthPriceAccFiat
TMP_83(uint256) = REF_79 * 1000000000000000000
REF_80(RDFDM.Charity) -> charities[_charity]
REF_81(uint256) -> REF_80.fiatToEthPriceAccEth
TMP_84(uint256) = TMP_83 / REF_81
_fiatToEthPricePerEth(uint256) := TMP_84(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
_fiatToEthCreditedFinney = _fiatToEthProcessed * (1000000000000000000 / 1000000000000000) / _fiatToEthPricePerEth

IRs:
TMP_85(uint256) = 1000000000000000000 / 1000000000000000
TMP_86(uint256) = _fiatToEthProcessed * TMP_85
TMP_87(uint256) = TMP_86 / _fiatToEthPricePerEth
_fiatToEthCreditedFinney(uint256) := TMP_87(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
_fiatToEthAfterFeesFinney = _fiatToEthCreditedFinney * 8 / 10

IRs:
TMP_88(uint256) = _fiatToEthCreditedFinney * 8
TMP_89(uint256) = TMP_88 / 10
_fiatToEthAfterFeesFinney(uint256) := TMP_89(uint256)""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
_ethDonatedFinney = charities[_charity].ethDonated / (1000000000000000)

IRs:
REF_82(RDFDM.Charity) -> charities[_charity]
REF_83(uint256) -> REF_82.ethDonated
TMP_90(uint256) = REF_83 / 1000000000000000
_ethDonatedFinney(uint256) := TMP_90(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
_ethDonatedAfterFeesFinney = _ethDonatedFinney * 98 / 100

IRs:
TMP_91(uint256) = _ethDonatedFinney * 98
TMP_92(uint256) = TMP_91 / 100
_ethDonatedAfterFeesFinney(uint256) := TMP_92(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
_totalEthCreditedFinney = _fiatToEthAfterFeesFinney + _ethDonatedAfterFeesFinney

IRs:
TMP_93(uint256) = _fiatToEthAfterFeesFinney + _ethDonatedAfterFeesFinney
_totalEthCreditedFinney(uint256) := TMP_93(uint256)""];
14->15;
15[label=""Node Type: NEW VARIABLE 15

EXPRESSION:
tecf = charities[_charity].ethCredited * (1000000000000000000 / 1000000000000000)

IRs:
REF_84(RDFDM.Charity) -> charities[_charity]
REF_85(uint256) -> REF_84.ethCredited
TMP_94(uint256) = 1000000000000000000 / 1000000000000000
TMP_95(uint256) = REF_85 * TMP_94
tecf(uint256) := TMP_95(uint256)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
_quickDiscrepancy = int256(_totalEthCreditedFinney) - int256(tecf)

IRs:
TMP_96 = CONVERT _totalEthCreditedFinney to int256
TMP_97 = CONVERT tecf to int256
TMP_98(int256) = TMP_96 - TMP_97
_quickDiscrepancy(int256) := TMP_98(int256)""];
16->17;
17[label=""Node Type: RETURN 17

EXPRESSION:
(_fiatCollected,_fiatToEthNotProcessed,_fiatToEthProcessed,_fiatToEthPricePerEth,_fiatToEthCreditedFinney,_fiatToEthAfterFeesFinney,_ethDonatedFinney,_ethDonatedAfterFeesFinney,_totalEthCreditedFinney,_quickDiscrepancy)

IRs:
RETURN _fiatCollected,_fiatToEthNotProcessed,_fiatToEthProcessed,_fiatToEthPricePerEth,_fiatToEthCreditedFinney,_fiatToEthAfterFeesFinney,_ethDonatedFinney,_ethDonatedAfterFeesFinney,_totalEthCreditedFinney,_quickDiscrepancy""];
}
",0,1,0,0,"require(bool)(_charity < charityCount);_fiatCollected = charities[_charity].fiatCollected;_fiatToEthNotProcessed = charities[_charity].fiatBalanceIn;_fiatToEthProcessed = _fiatCollected - _fiatToEthNotProcessed;charities[_charity].fiatToEthPriceAccEth == 0;_fiatToEthPricePerEth = 0;_fiatToEthPricePerEth = (charities[_charity].fiatToEthPriceAccFiat * (1000000000000000000)) / charities[_charity].fiatToEthPriceAccEth;_fiatToEthCreditedFinney = 0;;_fiatToEthCreditedFinney = _fiatToEthProcessed * (1000000000000000000 / 1000000000000000) / _fiatToEthPricePerEth;_fiatToEthAfterFeesFinney = _fiatToEthCreditedFinney * 8 / 10;_ethDonatedFinney = charities[_charity].ethDonated / (1000000000000000);_ethDonatedAfterFeesFinney = _ethDonatedFinney * 98 / 100;_totalEthCreditedFinney = _fiatToEthAfterFeesFinney + _ethDonatedAfterFeesFinney;tecf = charities[_charity].ethCredited * (1000000000000000000 / 1000000000000000);_quickDiscrepancy = int256(_totalEthCreditedFinney) - int256(tecf);(_fiatCollected,_fiatToEthNotProcessed,_fiatToEthProcessed,_fiatToEthPricePerEth,_fiatToEthCreditedFinney,_fiatToEthAfterFeesFinney,_ethDonatedFinney,_ethDonatedAfterFeesFinney,_totalEthCreditedFinney,_quickDiscrepancy)"
./0x1fab9d2996767db0ca6af12fd92c1f2aab2675a0_ext.sol,ZethrSlots.getSpinOutput,2886,2930,"TMP_776(uint256[])  = new uint256[](_numSpins),output(uint256[]) = ['TMP_776(uint256[])'],TMP_777(uint256) = block.number - _blockNumber,TMP_778(bool) = TMP_777 > 255,CONDITION TMP_778,TMP_779(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '_numSpins'] ,TMP_780(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_779', '99'] ,TMP_781(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_780', '100'] ,lossAmount(uint256) := TMP_781(uint256),TMP_782(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '_numSpins'] ,TMP_783(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_782', '100'] ,jackpotAmount(uint256) := TMP_783(uint256),i(uint256) := 0(uint256),TMP_784(bool) = i < _numSpins,CONDITION TMP_784,REF_373(uint256) -> output[i],TMP_785(uint256) = INTERNAL_CALL, ZethrSlots.random(uint256,uint256,address,uint256)(1000000,_blockNumber,_target,i),TMP_786(uint256) = TMP_785 + 1,REF_373(uint256) (->output) := TMP_786(uint256),REF_374(uint256) -> output[i],TMP_787(bool) = REF_374 < 2,CONDITION TMP_787,TMP_788(uint256) := jackpotWins(uint256),jackpotWins(uint256) = jackpotWins + 1,lossAmount(uint256) = lossAmount + _tokenValue,REF_375(uint256) -> output[i],TMP_789(bool) = REF_375 > 506856,CONDITION TMP_789,TMP_790(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '99'] ,TMP_791(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_790', '100'] ,lossAmount(uint256) = lossAmount + TMP_791,TMP_792(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_tokenValue', '100'] ,jackpotAmount(uint256) = jackpotAmount + TMP_792,index(uint256) := 0(uint256),REF_379 -> LENGTH MULTIPLIER_BOUNDARIES,TMP_793(bool) = index < REF_379,CONDITION TMP_793,REF_380(uint256) -> output[i],REF_381(uint256) -> MULTIPLIER_BOUNDARIES[index],TMP_794(bool) = REF_380 < REF_381,CONDITION TMP_794,TMP_795(uint256) := index(uint256),index(uint256) = index + 1,REF_383(uint256) -> MULTIPLIERS[index],TMP_796(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', 'REF_383'] ,TMP_797(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_796', '100'] ,winAmount(uint256) = winAmount + TMP_797,TMP_798(uint256) := i(uint256),i(uint256) = i + 1,Emit SlotsResult(_blockNumber,_target,_numSpins,_tokenValue,winAmount,lossAmount,output),RETURN winAmount,lossAmount,jackpotAmount,jackpotWins,output,RETURN winAmount,lossAmount,jackpotAmount,jackpotWins,output","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
output = new uint256[](_numSpins)

IRs:
TMP_776(uint256[])  = new uint256[](_numSpins)
output(uint256[]) = ['TMP_776(uint256[])']""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
block.number - _blockNumber > 255

IRs:
TMP_777(uint256) = block.number - _blockNumber
TMP_778(bool) = TMP_777 > 255
CONDITION TMP_778""];
2->3[label=""True""];
2->7[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
lossAmount = (_tokenValue.mul(_numSpins).mul(99)).div(100)

IRs:
TMP_779(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '_numSpins'] 
TMP_780(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_779', '99'] 
TMP_781(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_780', '100'] 
lossAmount(uint256) := TMP_781(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
jackpotAmount = _tokenValue.mul(_numSpins).div(100)

IRs:
TMP_782(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '_numSpins'] 
TMP_783(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_782', '100'] 
jackpotAmount(uint256) := TMP_783(uint256)""];
4->29;
5[label=""Node Type: BEGIN_LOOP 5
""];
5->8;
6[label=""Node Type: END_LOOP 6
""];
6->29;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
7->5;
8[label=""Node Type: IF_LOOP 8

EXPRESSION:
i < _numSpins

IRs:
TMP_784(bool) = i < _numSpins
CONDITION TMP_784""];
8->9[label=""True""];
8->6[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
output[i] = random(1000000,_blockNumber,_target,i) + 1

IRs:
REF_373(uint256) -> output[i]
TMP_785(uint256) = INTERNAL_CALL, ZethrSlots.random(uint256,uint256,address,uint256)(1000000,_blockNumber,_target,i)
TMP_786(uint256) = TMP_785 + 1
REF_373(uint256) (->output) := TMP_786(uint256)""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
output[i] < 2

IRs:
REF_374(uint256) -> output[i]
TMP_787(bool) = REF_374 < 2
CONDITION TMP_787""];
10->11[label=""True""];
10->13[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
jackpotWins ++

IRs:
TMP_788(uint256) := jackpotWins(uint256)
jackpotWins(uint256) = jackpotWins + 1""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
lossAmount += _tokenValue

IRs:
lossAmount(uint256) = lossAmount + _tokenValue""];
12->27;
13[label=""Node Type: IF 13

EXPRESSION:
output[i] > 506856

IRs:
REF_375(uint256) -> output[i]
TMP_789(bool) = REF_375 > 506856
CONDITION TMP_789""];
13->14[label=""True""];
13->16[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
lossAmount += (_tokenValue.mul(99)).div(100)

IRs:
TMP_790(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '99'] 
TMP_791(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_790', '100'] 
lossAmount(uint256) = lossAmount + TMP_791""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
jackpotAmount += _tokenValue.div(100)

IRs:
TMP_792(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_tokenValue', '100'] 
jackpotAmount(uint256) = jackpotAmount + TMP_792""];
15->26;
16[label=""Node Type: NEW VARIABLE 16
""];
16->19;
17[label=""Node Type: BEGIN_LOOP 17
""];
17->20;
18[label=""Node Type: END_LOOP 18
""];
18->25;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
index = 0

IRs:
index(uint256) := 0(uint256)""];
19->17;
20[label=""Node Type: IF_LOOP 20

EXPRESSION:
index < MULTIPLIER_BOUNDARIES.length

IRs:
REF_379 -> LENGTH MULTIPLIER_BOUNDARIES
TMP_793(bool) = index < REF_379
CONDITION TMP_793""];
20->21[label=""True""];
20->18[label=""False""];
21[label=""Node Type: IF 21

EXPRESSION:
output[i] < MULTIPLIER_BOUNDARIES[index]

IRs:
REF_380(uint256) -> output[i]
REF_381(uint256) -> MULTIPLIER_BOUNDARIES[index]
TMP_794(bool) = REF_380 < REF_381
CONDITION TMP_794""];
21->22[label=""True""];
21->23[label=""False""];
22[label=""Node Type: BREAK 22
""];
22->18;
23[label=""Node Type: END_IF 23
""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
index ++

IRs:
TMP_795(uint256) := index(uint256)
index(uint256) = index + 1""];
24->20;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
winAmount += _tokenValue.mul(MULTIPLIERS[index]).div(100)

IRs:
REF_383(uint256) -> MULTIPLIERS[index]
TMP_796(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', 'REF_383'] 
TMP_797(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_796', '100'] 
winAmount(uint256) = winAmount + TMP_797""];
25->26;
26[label=""Node Type: END_IF 26
""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
i ++

IRs:
TMP_798(uint256) := i(uint256)
i(uint256) = i + 1""];
28->8;
29[label=""Node Type: END_IF 29
""];
29->30;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
SlotsResult(_blockNumber,_target,_numSpins,_tokenValue,winAmount,lossAmount,output)

IRs:
Emit SlotsResult(_blockNumber,_target,_numSpins,_tokenValue,winAmount,lossAmount,output)""];
30->31;
31[label=""Node Type: RETURN 31

EXPRESSION:
(winAmount,lossAmount,jackpotAmount,jackpotWins,output)

IRs:
RETURN winAmount,lossAmount,jackpotAmount,jackpotWins,output""];
32[label=""Node Type: RETURN 32

EXPRESSION:
(winAmount,lossAmount,jackpotAmount,jackpotWins,output)

IRs:
RETURN winAmount,lossAmount,jackpotAmount,jackpotWins,output""];
}
",0,1,0,0,"output = new uint256[](_numSpins);block.number - _blockNumber > 255;lossAmount = (_tokenValue.mul(_numSpins).mul(99)).div(100);i = 0;jackpotAmount = _tokenValue.mul(_numSpins).div(100);;;i < _numSpins;;output[i] = random(1000000,_blockNumber,_target,i) + 1;output[i] < 2;jackpotWins ++;output[i] > 506856;lossAmount += _tokenValue;;lossAmount += (_tokenValue.mul(99)).div(100);;jackpotAmount += _tokenValue.div(100);;index = 0;;index < MULTIPLIER_BOUNDARIES.length;;winAmount += _tokenValue.mul(MULTIPLIERS[index]).div(100);output[i] < MULTIPLIER_BOUNDARIES[index];;;index ++;i ++;SlotsResult(_blockNumber,_target,_numSpins,_tokenValue,winAmount,lossAmount,output);(winAmount,lossAmount,jackpotAmount,jackpotWins,output);(winAmount,lossAmount,jackpotAmount,jackpotWins,output)"
./0x6e5dce687b949b52dad8bb1cc467d0205cb4b6e3_ext.sol,CAC.getFreeBalances,406,418,"REF_151(uint256) -> balanceLocked[_addr],TMP_159(bool) = REF_151 > 0,CONDITION TMP_159,REF_152(uint256) -> lockAtTime[_addr],TMP_160(uint256) = REF_152 + 15552000,TMP_161(bool) = now > TMP_160,CONDITION TMP_161,REF_153(uint256) -> balances[_addr],RETURN REF_153,REF_154(uint256) -> lockAtTime[_addr],TMP_162(uint256) = REF_154 + 7776000,TMP_163(bool) = now > TMP_162,CONDITION TMP_163,REF_155(uint256) -> balances[_addr],REF_156(uint256) -> balanceLocked[_addr],TMP_164(uint256) = REF_156 / 10,TMP_165(uint256) = TMP_164 * 4,TMP_166(uint256) = REF_155 - TMP_165,RETURN TMP_166,REF_157(uint256) -> balances[_addr],REF_158(uint256) -> balanceLocked[_addr],TMP_167(uint256) = REF_158 / 10,TMP_168(uint256) = TMP_167 * 7,TMP_169(uint256) = REF_157 - TMP_168,RETURN TMP_169,REF_159(uint256) -> balances[_addr],RETURN REF_159","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balanceLocked[_addr] > 0

IRs:
REF_151(uint256) -> balanceLocked[_addr]
TMP_159(bool) = REF_151 > 0
CONDITION TMP_159""];
1->2[label=""True""];
1->9[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
now > lockAtTime[_addr] + 15552000

IRs:
REF_152(uint256) -> lockAtTime[_addr]
TMP_160(uint256) = REF_152 + 15552000
TMP_161(bool) = now > TMP_160
CONDITION TMP_161""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3

EXPRESSION:
balances[_addr]

IRs:
REF_153(uint256) -> balances[_addr]
RETURN REF_153""];
4[label=""Node Type: IF 4

EXPRESSION:
now > lockAtTime[_addr] + 7776000

IRs:
REF_154(uint256) -> lockAtTime[_addr]
TMP_162(uint256) = REF_154 + 7776000
TMP_163(bool) = now > TMP_162
CONDITION TMP_163""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: RETURN 5

EXPRESSION:
balances[_addr] - balanceLocked[_addr] / 10 * 4

IRs:
REF_155(uint256) -> balances[_addr]
REF_156(uint256) -> balanceLocked[_addr]
TMP_164(uint256) = REF_156 / 10
TMP_165(uint256) = TMP_164 * 4
TMP_166(uint256) = REF_155 - TMP_165
RETURN TMP_166""];
6[label=""Node Type: RETURN 6

EXPRESSION:
balances[_addr] - balanceLocked[_addr] / 10 * 7

IRs:
REF_157(uint256) -> balances[_addr]
REF_158(uint256) -> balanceLocked[_addr]
TMP_167(uint256) = REF_158 / 10
TMP_168(uint256) = TMP_167 * 7
TMP_169(uint256) = REF_157 - TMP_168
RETURN TMP_169""];
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: RETURN 10

EXPRESSION:
balances[_addr]

IRs:
REF_159(uint256) -> balances[_addr]
RETURN REF_159""];
}
",0,1,0,0,balanceLocked[_addr] > 0;now > lockAtTime[_addr] + 15552000;;balances[_addr];now > lockAtTime[_addr] + 7776000;balances[_addr] - balanceLocked[_addr] / 10 * 4;balances[_addr] - balanceLocked[_addr] / 10 * 7;balances[_addr]
./0x1ebd8d3ca115451b9b6bbaa7ee2f7b0f96e49fd8_ext.sol,ArthurStandardToken.approveAndCall,98,104,"REF_31(mapping(address => uint256)) -> allowed[msg.sender],REF_32(uint256) -> REF_31[_spender],REF_32(uint256) (->allowed) := _value(uint256),Emit Approval(msg.sender,_spender,_value),TMP_23(bytes32) = SOLIDITY_CALL keccak256()(receiveApproval(address,uint256,address,bytes)),TMP_24 = CONVERT TMP_23 to bytes32,TMP_25 = CONVERT TMP_24 to bytes4,TMP_26(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_25', 'msg.sender', '_value', 'this', '_extraData']  ,TMP_27 = UnaryType.BANG TMP_26 ,CONDITION TMP_27,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_31(mapping(address => uint256)) -> allowed[msg.sender]
REF_32(uint256) -> REF_31[_spender]
REF_32(uint256) (->allowed) := _value(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
! _spender.call(bytes4(bytes32(keccak256()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData)

IRs:
TMP_23(bytes32) = SOLIDITY_CALL keccak256()(receiveApproval(address,uint256,address,bytes))
TMP_24 = CONVERT TMP_23 to bytes32
TMP_25 = CONVERT TMP_24 to bytes4
TMP_26(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_25', 'msg.sender', '_value', 'this', '_extraData']  
TMP_27 = UnaryType.BANG TMP_26 
CONDITION TMP_27""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: THROW 4
""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][_spender] = _value;Approval(msg.sender,_spender,_value);! _spender.call(bytes4(bytes32(keccak256()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData);;;true;success"
./0x7220e734c524e8938a1553ae18e3c68aec8bf955_ext.sol,SmsCertifier.getUint,78,78,"REF_21(SmsCertifier.Certification) -> certs[_who],REF_22(mapping(string => bytes32)) -> REF_21.meta,REF_23(bytes32) -> REF_22[_field],TMP_20 = CONVERT REF_23 to uint256,RETURN TMP_20","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(certs[_who].meta[_field])

IRs:
REF_21(SmsCertifier.Certification) -> certs[_who]
REF_22(mapping(string => bytes32)) -> REF_21.meta
REF_23(bytes32) -> REF_22[_field]
TMP_20 = CONVERT REF_23 to uint256
RETURN TMP_20""];
}
",0,1,0,0,uint256(certs[_who].meta[_field])
./0xef828938155cabfe83affbe726b55d188b4f45c0_ext.sol,APPToken.tokenRate,97,101,"TMP_50(bool) = block.number >= fundingStartBlock,TMP_51(uint256) = fundingStartBlock + 23333,TMP_52(bool) = block.number < TMP_51,TMP_53(bool) = TMP_50 && TMP_52,CONDITION TMP_53,RETURN 360,TMP_54(bool) = block.number >= fundingStartBlock,TMP_55(uint256) = fundingStartBlock + 23333,TMP_56(bool) = block.number < TMP_55,TMP_57(bool) = TMP_54 && TMP_56,CONDITION TMP_57,RETURN 300,RETURN 250","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
block.number >= fundingStartBlock && block.number < fundingStartBlock + 23333

IRs:
TMP_50(bool) = block.number >= fundingStartBlock
TMP_51(uint256) = fundingStartBlock + 23333
TMP_52(bool) = block.number < TMP_51
TMP_53(bool) = TMP_50 && TMP_52
CONDITION TMP_53""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
360

IRs:
RETURN 360""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
block.number >= fundingStartBlock && block.number < fundingStartBlock + 23333

IRs:
TMP_54(bool) = block.number >= fundingStartBlock
TMP_55(uint256) = fundingStartBlock + 23333
TMP_56(bool) = block.number < TMP_55
TMP_57(bool) = TMP_54 && TMP_56
CONDITION TMP_57""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: RETURN 5

EXPRESSION:
300

IRs:
RETURN 300""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
250

IRs:
RETURN 250""];
}
",0,1,0,0,block.number >= fundingStartBlock && block.number < fundingStartBlock + 23333;360;;block.number >= fundingStartBlock && block.number < fundingStartBlock + 23333;300;;250
./0x580c1e3caca14826976b5820947f7ad486ac174d_ext.sol,TokenERC20.burn,141,147,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xc4a0ab20f1901c24740e06966cca9d5f2e5d5e79_ext.sol,LockBalance.lockTypeInfoGroup,328,331,"TMP_166 = CONVERT _type to uint256,key(uint256) := TMP_166(uint256),REF_175(LockBalance.sGroupLockDate) -> groupLockDate[key],REF_176(uint256[]) -> REF_175.lockTime,REF_177(LockBalance.sGroupLockDate) -> groupLockDate[key],REF_178(uint256[]) -> REF_177.lockPercent,RETURN REF_176,REF_178","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
key = uint256(_type)

IRs:
TMP_166 = CONVERT _type to uint256
key(uint256) := TMP_166(uint256)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
(groupLockDate[key].lockTime,groupLockDate[key].lockPercent)

IRs:
REF_175(LockBalance.sGroupLockDate) -> groupLockDate[key]
REF_176(uint256[]) -> REF_175.lockTime
REF_177(LockBalance.sGroupLockDate) -> groupLockDate[key]
REF_178(uint256[]) -> REF_177.lockPercent
RETURN REF_176,REF_178""];
}
",0,1,0,0,"key = uint256(_type);(groupLockDate[key].lockTime,groupLockDate[key].lockPercent)"
./0x4b5cd619741838cb3442831c3f268a78b7df859a_ext.sol,CryptoPeopleName.setName,11,13,"REF_0(string) -> nameOfAddress[msg.sender],REF_0(string) (->nameOfAddress) := name(string)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
nameOfAddress[msg.sender] = name

IRs:
REF_0(string) -> nameOfAddress[msg.sender]
REF_0(string) (->nameOfAddress) := name(string)""];
}
",0,1,0,0,nameOfAddress[msg.sender] = name
./0x00817122beef212ac22e65fc0fba8bc065fd5f66_ext.sol,UNTToken.lockToken,312,334,"TMP_109(bool) = owner == msg.sender,TMP_110(None) = SOLIDITY_CALL require(bool)(TMP_109),TMP_111(bool) = INTERNAL_CALL, UNTToken.hasAddress(address)(target),TMP_112(bool) = TMP_111 == False,CONDITION TMP_112,TMP_113(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(target),TMP_114(bool) = TMP_113 >= amount,CONDITION TMP_114,REF_117 -> LENGTH lockaddress,TMP_116(uint256) := REF_117(uint256),TMP_117(uint256) = TMP_116 + 1,REF_117(uint256) (->lockaddress) := TMP_117(uint256),REF_118(address) -> lockaddress[TMP_116],REF_118(address) (->lockaddress) := target(address),REF_119(uint256) -> lockamount[target],REF_119(uint256) (->lockamount) := amount(uint256),TMP_118(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(target),REF_120(uint256) -> lockamount[target],TMP_119(uint256) = TMP_118 - REF_120,TMP_120(bool) = TMP_119 >= amount,CONDITION TMP_120,REF_121(uint256) -> lockamount[target],REF_121(-> lockamount) = REF_121 + amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(owner == msg.sender)

IRs:
TMP_109(bool) = owner == msg.sender
TMP_110(None) = SOLIDITY_CALL require(bool)(TMP_109)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
hasAddress(target) == false

IRs:
TMP_111(bool) = INTERNAL_CALL, UNTToken.hasAddress(address)(target)
TMP_112(bool) = TMP_111 == False
CONDITION TMP_112""];
2->3[label=""True""];
2->7[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
balanceOf(target) >= amount

IRs:
TMP_113(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(target)
TMP_114(bool) = TMP_113 >= amount
CONDITION TMP_114""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
lockaddress.push(target)

IRs:
REF_117 -> LENGTH lockaddress
TMP_116(uint256) := REF_117(uint256)
TMP_117(uint256) = TMP_116 + 1
REF_117(uint256) (->lockaddress) := TMP_117(uint256)
REF_118(address) -> lockaddress[TMP_116]
REF_118(address) (->lockaddress) := target(address)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
lockamount[target] = amount

IRs:
REF_119(uint256) -> lockamount[target]
REF_119(uint256) (->lockamount) := amount(uint256)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->10;
7[label=""Node Type: IF 7

EXPRESSION:
balanceOf(target) - lockamount[target] >= amount

IRs:
TMP_118(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(target)
REF_120(uint256) -> lockamount[target]
TMP_119(uint256) = TMP_118 - REF_120
TMP_120(bool) = TMP_119 >= amount
CONDITION TMP_120""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
lockamount[target] += amount

IRs:
REF_121(uint256) -> lockamount[target]
REF_121(-> lockamount) = REF_121 + amount""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: END_IF 10
""];
}
",0,1,0,0,require(bool)(owner == msg.sender);hasAddress(target) == false;balanceOf(target) >= amount;balanceOf(target) - lockamount[target] >= amount;lockaddress.push(target);;lockamount[target] = amount;;lockamount[target] += amount;
./0x413e0794e1d2e7e26a9536a79a07b2ceb13fb994_ext.sol,SHERE_PFII_II_883.transferFrom,42,54,"REF_6(uint256) -> balanceOf[from],TMP_6(bool) = value <= REF_6,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_7(mapping(address => uint256)) -> allowance[from],REF_8(uint256) -> REF_7[msg.sender],TMP_8(bool) = value <= REF_8,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_9(uint256) -> balanceOf[from],REF_9(-> balanceOf) = REF_9 - value,REF_10(uint256) -> balanceOf[to],REF_10(-> balanceOf) = REF_10 + value,REF_11(mapping(address => uint256)) -> allowance[from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowance) = REF_12 - value,Emit Transfer(from,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(value <= balanceOf[from])

IRs:
REF_6(uint256) -> balanceOf[from]
TMP_6(bool) = value <= REF_6
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value <= allowance[from][msg.sender])

IRs:
REF_7(mapping(address => uint256)) -> allowance[from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_8(bool) = value <= REF_8
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[from] -= value

IRs:
REF_9(uint256) -> balanceOf[from]
REF_9(-> balanceOf) = REF_9 - value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[to] += value

IRs:
REF_10(uint256) -> balanceOf[to]
REF_10(-> balanceOf) = REF_10 + value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allowance[from][msg.sender] -= value

IRs:
REF_11(mapping(address => uint256)) -> allowance[from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowance) = REF_12 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(value <= balanceOf[from]);require(bool)(value <= allowance[from][msg.sender]);balanceOf[from] -= value;balanceOf[to] += value;allowance[from][msg.sender] -= value;Transfer(from,to,value);true;success"
./0xf27a6b9f1434de2a406ee0a9f94b4d5e89fb2681_ext.sol,TOP.burnFrom,153,161,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xf4a7c09a885a31755dd4cd1ce816d257fbe30dcf_ext.sol,BBTDonate.dispatch,42,45,"TMP_9 = CONVERT log to bytes,REF_6 -> LENGTH TMP_9,TMP_10(bool) = REF_6 != 0,TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10),TMP_12 = SEND dest:_receiver value:_amount,TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12),MODIFIER_CALL, BBTDonate.onlyAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(bytes(log).length != 0)

IRs:
TMP_9 = CONVERT log to bytes
REF_6 -> LENGTH TMP_9
TMP_10(bool) = REF_6 != 0
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_receiver.send(_amount))

IRs:
TMP_12 = SEND dest:_receiver value:_amount
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, BBTDonate.onlyAdmin()()""];
3->1;
}
",0,1,0,0,onlyAdmin();require(bool)(bytes(log).length != 0);require(bool)(_receiver.send(_amount))
./0x185480332ee00c4a23422df11e022172dc10d5a9_ext.sol,NausiCoin._transfer,129,142,"TMP_33(bool) = to != 0,TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33),REF_22(uint256) -> _balanceOf[from],TMP_35(bool) = REF_22 >= value,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),REF_23(uint256) -> _balanceOf[to],TMP_37(uint256) = REF_23 + value,REF_24(uint256) -> _balanceOf[to],TMP_38(bool) = TMP_37 >= REF_24,TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38),REF_25(uint256) -> _balanceOf[from],REF_26(uint256) -> _balanceOf[to],TMP_40(uint256) = REF_25 + REF_26,previousBalance(uint256) := TMP_40(uint256),REF_27(uint256) -> _balanceOf[from],REF_27(-> _balanceOf) = REF_27 - value,REF_28(uint256) -> _balanceOf[to],REF_28(-> _balanceOf) = REF_28 + value,Emit Transfer(from,to,value),REF_29(uint256) -> _balanceOf[from],REF_30(uint256) -> _balanceOf[to],TMP_42(uint256) = REF_29 + REF_30,TMP_43(bool) = TMP_42 == previousBalance,TMP_44(None) = SOLIDITY_CALL assert(bool)(TMP_43)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(to != 0x0)

IRs:
TMP_33(bool) = to != 0
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_balanceOf[from] >= value)

IRs:
REF_22(uint256) -> _balanceOf[from]
TMP_35(bool) = REF_22 >= value
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_balanceOf[to] + value >= _balanceOf[to])

IRs:
REF_23(uint256) -> _balanceOf[to]
TMP_37(uint256) = REF_23 + value
REF_24(uint256) -> _balanceOf[to]
TMP_38(bool) = TMP_37 >= REF_24
TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalance = _balanceOf[from] + _balanceOf[to]

IRs:
REF_25(uint256) -> _balanceOf[from]
REF_26(uint256) -> _balanceOf[to]
TMP_40(uint256) = REF_25 + REF_26
previousBalance(uint256) := TMP_40(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_balanceOf[from] -= value

IRs:
REF_27(uint256) -> _balanceOf[from]
REF_27(-> _balanceOf) = REF_27 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
_balanceOf[to] += value

IRs:
REF_28(uint256) -> _balanceOf[to]
REF_28(-> _balanceOf) = REF_28 + value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(_balanceOf[from] + _balanceOf[to] == previousBalance)

IRs:
REF_29(uint256) -> _balanceOf[from]
REF_30(uint256) -> _balanceOf[to]
TMP_42(uint256) = REF_29 + REF_30
TMP_43(bool) = TMP_42 == previousBalance
TMP_44(None) = SOLIDITY_CALL assert(bool)(TMP_43)""];
}
",0,1,0,0,"require(bool)(to != 0x0);require(bool)(_balanceOf[from] >= value);require(bool)(_balanceOf[to] + value >= _balanceOf[to]);previousBalance = _balanceOf[from] + _balanceOf[to];_balanceOf[from] -= value;_balanceOf[to] += value;Transfer(from,to,value);assert(bool)(_balanceOf[from] + _balanceOf[to] == previousBalance)"
./0x41e50bb0dfd21cd201b16a3d2f945920675a4408_ext.sol,LockRequestable.generateLockId,14,16,"TMP_0(uint256) = block.number - 1,TMP_1(uint256) = SOLIDITY_CALL blockhash(uint256)(TMP_0),TMP_2 = CONVERT this to address,lockRequestCount(uint256) = lockRequestCount + 1,TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_1,TMP_2,lockRequestCount),RETURN TMP_3,RETURN lockId","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
keccak256()(block.blockhash(block.number - 1),address(this),++ lockRequestCount)

IRs:
TMP_0(uint256) = block.number - 1
TMP_1(uint256) = SOLIDITY_CALL blockhash(uint256)(TMP_0)
TMP_2 = CONVERT this to address
lockRequestCount(uint256) = lockRequestCount + 1
TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_1,TMP_2,lockRequestCount)
RETURN TMP_3""];
2[label=""Node Type: RETURN 2

EXPRESSION:
lockId

IRs:
RETURN lockId""];
}
",0,1,0,0,"keccak256()(block.blockhash(block.number - 1),address(this),++ lockRequestCount);lockId"
./0xd0563bc1a5a824c17c0c73c98725234de9b1dd93_ext.sol,Depix.totalSupply,82,84,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0xbfb7eee5dbc373433a97431fd5a3010b53e16378_ext.sol,DDAContract.mint,78,83,"TMP_20(bool) = msg.sender == dedeAddress,TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20),_totalSupply(uint256) = _totalSupply + value,REF_20(uint256) -> balances[msg.sender],REF_20(-> balances) = REF_20 + value,Emit Transfer(0,msg.sender,value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == dedeAddress)

IRs:
TMP_20(bool) = msg.sender == dedeAddress
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_totalSupply += value

IRs:
_totalSupply(uint256) = _totalSupply + value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] += value

IRs:
REF_20(uint256) -> balances[msg.sender]
REF_20(-> balances) = REF_20 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(0,msg.sender,value)

IRs:
Emit Transfer(0,msg.sender,value)""];
}
",0,1,0,0,"require(bool)(msg.sender == dedeAddress);_totalSupply += value;balances[msg.sender] += value;Transfer(0,msg.sender,value)"
./0xb44a823579aa618b96d6f20a3330901e85f96f73_ext.sol,ArtworkOwnership.totalSupply,1015,1017,"REF_179 -> LENGTH artworks,TMP_584(uint256) = REF_179 - 1,RETURN TMP_584","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
artworks.length - 1

IRs:
REF_179 -> LENGTH artworks
TMP_584(uint256) = REF_179 - 1
RETURN TMP_584""];
}
",0,1,0,0,artworks.length - 1
./0x74e345b0597ea3bc5762df0092e6bf8c891a7d0f_ext.sol,StandardToken.transferFrom,55,65,"REF_3(uint256) -> balances[_from],TMP_18(bool) = REF_3 >= _value,REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],TMP_19(bool) = REF_5 >= _value,TMP_20(bool) = TMP_18 && TMP_19,TMP_21(bool) = _value > 0,TMP_22(bool) = TMP_20 && TMP_21,CONDITION TMP_22,REF_6(uint256) -> balances[_to],REF_6(-> balances) = REF_6 + _value,REF_7(uint256) -> balances[_from],REF_7(-> balances) = REF_7 - _value,REF_8(mapping(address => uint256)) -> allowed[_from],REF_9(uint256) -> REF_8[msg.sender],REF_9(-> allowed) = REF_9 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0

IRs:
REF_3(uint256) -> balances[_from]
TMP_18(bool) = REF_3 >= _value
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
TMP_19(bool) = REF_5 >= _value
TMP_20(bool) = TMP_18 && TMP_19
TMP_21(bool) = _value > 0
TMP_22(bool) = TMP_20 && TMP_21
CONDITION TMP_22""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_6(uint256) -> balances[_to]
REF_6(-> balances) = REF_6 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_7(uint256) -> balances[_from]
REF_7(-> balances) = REF_7 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_8(mapping(address => uint256)) -> allowed[_from]
REF_9(uint256) -> REF_8[msg.sender]
REF_9(-> allowed) = REF_9 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0;balances[_to] += _value;false;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true;success"
./0xf27a6b9f1434de2a406ee0a9f94b4d5e89fb2681_ext.sol,TOP._transfer,49,65,"TMP_3 = CONVERT 0 to address,TMP_4(bool) = _to != TMP_3,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_1(uint256) -> balanceOf[_from],TMP_6(bool) = REF_1 >= _value,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_2(uint256) -> balanceOf[_to],TMP_8(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_9(bool) = TMP_8 >= REF_3,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_11(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_11(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_13(uint256) = REF_8 + REF_9,TMP_14(bool) = TMP_13 == previousBalances,TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0x0))

IRs:
TMP_3 = CONVERT 0 to address
TMP_4(bool) = _to != TMP_3
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_6(bool) = REF_1 >= _value
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_8(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_9(bool) = TMP_8 >= REF_3
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_11(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_11(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_13(uint256) = REF_8 + REF_9
TMP_14(bool) = TMP_13 == previousBalances
TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)""];
}
",0,1,0,0,"require(bool)(_to != address(0x0));require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xc5d3b25a2ca77316b637106a749cd5e92a8e4702_ext.sol,COMMERCIALPOINTCHAINSYSTEM.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x00c2982959f852abbdb0f5ec023609ea1ca579e8_ext.sol,GAC._transfer,44,60,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x7895a43ae537e8e1ac97006ea9235807eea04cfa_ext.sol,YunMint.freeze,704,714,"REF_158(uint256) -> balances[msg.sender],TMP_290(bool) = REF_158 >= _value,TMP_291(None) = SOLIDITY_CALL require(bool)(TMP_290),TMP_292(bool) = _unFrozenTime > createTime,TMP_293(None) = SOLIDITY_CALL require(bool)(TMP_292),TMP_294(bool) = _unFrozenTime > block.timestamp,TMP_295(None) = SOLIDITY_CALL require(bool)(TMP_294),REF_159(uint256) -> balances[msg.sender],REF_160(uint256) -> balances[msg.sender],TMP_296(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_160', '_value'] ,REF_159(uint256) (->balances) := TMP_296(uint256),REF_162(YunMint.FrozenBalance) -> frozenBalances[frozenBalanceCount],TMP_297(YunMint.FrozenBalance) = new FrozenBalance(msg.sender,_value,_unFrozenTime),REF_162(YunMint.FrozenBalance) (->frozenBalances) := TMP_297(YunMint.FrozenBalance),TMP_298(uint256) := frozenBalanceCount(uint256),frozenBalanceCount(uint256) = frozenBalanceCount + 1,Emit Freeze(msg.sender,_value,_unFrozenTime),RETURN True,MODIFIER_CALL, ReentrancyGuard.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_158(uint256) -> balances[msg.sender]
TMP_290(bool) = REF_158 >= _value
TMP_291(None) = SOLIDITY_CALL require(bool)(TMP_290)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_unFrozenTime > createTime)

IRs:
TMP_292(bool) = _unFrozenTime > createTime
TMP_293(None) = SOLIDITY_CALL require(bool)(TMP_292)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_unFrozenTime > block.timestamp)

IRs:
TMP_294(bool) = _unFrozenTime > block.timestamp
TMP_295(None) = SOLIDITY_CALL require(bool)(TMP_294)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_159(uint256) -> balances[msg.sender]
REF_160(uint256) -> balances[msg.sender]
TMP_296(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_160', '_value'] 
REF_159(uint256) (->balances) := TMP_296(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
frozenBalances[frozenBalanceCount] = FrozenBalance({owner:msg.sender,value:_value,unFrozenTime:_unFrozenTime})

IRs:
REF_162(YunMint.FrozenBalance) -> frozenBalances[frozenBalanceCount]
TMP_297(YunMint.FrozenBalance) = new FrozenBalance(msg.sender,_value,_unFrozenTime)
REF_162(YunMint.FrozenBalance) (->frozenBalances) := TMP_297(YunMint.FrozenBalance)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
frozenBalanceCount ++

IRs:
TMP_298(uint256) := frozenBalanceCount(uint256)
frozenBalanceCount(uint256) = frozenBalanceCount + 1""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Freeze(msg.sender,_value,_unFrozenTime)

IRs:
Emit Freeze(msg.sender,_value,_unFrozenTime)""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, ReentrancyGuard.nonReentrant()()""];
9->1;
}
",0,1,0,0,"nonReentrant();require(bool)(balances[msg.sender] >= _value);require(bool)(_unFrozenTime > createTime);require(bool)(_unFrozenTime > block.timestamp);balances[msg.sender] = balances[msg.sender].sub(_value);frozenBalances[frozenBalanceCount] = FrozenBalance({owner:msg.sender,value:_value,unFrozenTime:_unFrozenTime});frozenBalanceCount ++;Freeze(msg.sender,_value,_unFrozenTime);true"
./0x3a8a6d2bc23fb68a245250ad34019a65cf057418_ext.sol,TokenERC20.burn,156,162,"REF_17(uint256) -> balanceOf[msg.sender],TMP_26(bool) = REF_17 >= _value,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_26(bool) = REF_17 >= _value
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x53ce47cbe7f2be0aecd086a70182a98c907d024d_ext.sol,EasyMineIco.buyTokens,396,438,"TMP_127(bool) = msg.value > 0,TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127),amountRemaining(uint256) := msg.value(uint256),tokensToReceive(uint256) := 0(uint256),i(uint8) := 0(uint256),REF_53 -> LENGTH priceThresholds,TMP_129(bool) = i < REF_53,CONDITION TMP_129,REF_54(EasyMineIco.PriceThreshold) -> priceThresholds[i],REF_55(uint256) -> REF_54.tokenCount,REF_56(EasyMineIco.PriceThreshold) -> priceThresholds[i],REF_57(uint256) -> REF_56.tokensSold,TMP_130(uint256) = REF_55 - REF_57,tokensAvailable(uint256) := TMP_130(uint256),TMP_131(uint256) = 10 ** 18,TMP_132(uint256) = amountRemaining * TMP_131,REF_58(EasyMineIco.PriceThreshold) -> priceThresholds[i],REF_59(uint256) -> REF_58.price,TMP_133(uint256) = TMP_132 / REF_59,maxTokensByAmount(uint256) := TMP_133(uint256),TMP_134(bool) = maxTokensByAmount > tokensAvailable,CONDITION TMP_134,tokens(uint256) := tokensAvailable(uint256),REF_60(EasyMineIco.PriceThreshold) -> priceThresholds[i],REF_61(uint256) -> REF_60.price,TMP_135(uint256) = REF_61 * tokens,TMP_136(uint256) = 10 ** 18,TMP_137(uint256) = TMP_135 / TMP_136,amountRemaining(uint256) = amountRemaining - TMP_137,tokens(uint256) := maxTokensByAmount(uint256),amountRemaining(uint256) := 0(uint256),REF_62(EasyMineIco.PriceThreshold) -> priceThresholds[i],REF_63(uint256) -> REF_62.tokensSold,REF_63(-> priceThresholds) = REF_63 + tokens,tokensToReceive(uint256) = tokensToReceive + tokens,TMP_138(uint8) := i(uint8),i(uint8) = i + 1,TMP_139(bool) = tokensToReceive > 0,TMP_140(None) = SOLIDITY_CALL assert(bool)(TMP_139),TMP_141(bool) = amountRemaining != 0,CONDITION TMP_141,TMP_142 = SEND dest:msg.sender value:amountRemaining,TMP_143(None) = SOLIDITY_CALL assert(bool)(TMP_142),TMP_144(uint256) = msg.value - amountRemaining,TMP_145 = SEND dest:wallet value:TMP_144,TMP_146(None) = SOLIDITY_CALL assert(bool)(TMP_145),TMP_147(bool) = HIGH_LEVEL_CALL, dest:easyMineToken(EasyMineToken), function:transfer, arguments:['msg.sender', 'tokensToReceive']  ,TMP_148(None) = SOLIDITY_CALL assert(bool)(TMP_147),TMP_149(uint256) = INTERNAL_CALL, EasyMineIco.totalTokensSold()(),TMP_150(uint256) = INTERNAL_CALL, EasyMineIco.maxTokensSold()(),TMP_151(bool) = TMP_149 == TMP_150,CONDITION TMP_151,INTERNAL_CALL, EasyMineIco.finalize()(),Emit TokensSold(msg.sender,tokensToReceive),MODIFIER_CALL, EasyMineIco.isValidPayload()(),MODIFIER_CALL, EasyMineIco.timedTransitions()(),REF_67(EasyMineIco.Stages) -> Stages.Started,MODIFIER_CALL, EasyMineIco.atStage(EasyMineIco.Stages)(REF_67)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->30;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value > 0)

IRs:
TMP_127(bool) = msg.value > 0
TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amountRemaining = msg.value

IRs:
amountRemaining(uint256) := msg.value(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
tokensToReceive = 0

IRs:
tokensToReceive(uint256) := 0(uint256)""];
3->6;
4[label=""Node Type: BEGIN_LOOP 4
""];
4->7;
5[label=""Node Type: END_LOOP 5
""];
5->20;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)""];
6->4;
7[label=""Node Type: IF_LOOP 7

EXPRESSION:
i < priceThresholds.length

IRs:
REF_53 -> LENGTH priceThresholds
TMP_129(bool) = i < REF_53
CONDITION TMP_129""];
7->8[label=""True""];
7->5[label=""False""];
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
tokensAvailable = priceThresholds[i].tokenCount - priceThresholds[i].tokensSold

IRs:
REF_54(EasyMineIco.PriceThreshold) -> priceThresholds[i]
REF_55(uint256) -> REF_54.tokenCount
REF_56(EasyMineIco.PriceThreshold) -> priceThresholds[i]
REF_57(uint256) -> REF_56.tokensSold
TMP_130(uint256) = REF_55 - REF_57
tokensAvailable(uint256) := TMP_130(uint256)""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
maxTokensByAmount = amountRemaining * 10 ** 18 / priceThresholds[i].price

IRs:
TMP_131(uint256) = 10 ** 18
TMP_132(uint256) = amountRemaining * TMP_131
REF_58(EasyMineIco.PriceThreshold) -> priceThresholds[i]
REF_59(uint256) -> REF_58.price
TMP_133(uint256) = TMP_132 / REF_59
maxTokensByAmount(uint256) := TMP_133(uint256)""];
9->10;
10[label=""Node Type: NEW VARIABLE 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
maxTokensByAmount > tokensAvailable

IRs:
TMP_134(bool) = maxTokensByAmount > tokensAvailable
CONDITION TMP_134""];
11->12[label=""True""];
11->14[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
tokens = tokensAvailable

IRs:
tokens(uint256) := tokensAvailable(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
amountRemaining -= (priceThresholds[i].price * tokens) / 10 ** 18

IRs:
REF_60(EasyMineIco.PriceThreshold) -> priceThresholds[i]
REF_61(uint256) -> REF_60.price
TMP_135(uint256) = REF_61 * tokens
TMP_136(uint256) = 10 ** 18
TMP_137(uint256) = TMP_135 / TMP_136
amountRemaining(uint256) = amountRemaining - TMP_137""];
13->16;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
tokens = maxTokensByAmount

IRs:
tokens(uint256) := maxTokensByAmount(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
amountRemaining = 0

IRs:
amountRemaining(uint256) := 0(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
priceThresholds[i].tokensSold += tokens

IRs:
REF_62(EasyMineIco.PriceThreshold) -> priceThresholds[i]
REF_63(uint256) -> REF_62.tokensSold
REF_63(-> priceThresholds) = REF_63 + tokens""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
tokensToReceive += tokens

IRs:
tokensToReceive(uint256) = tokensToReceive + tokens""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
i ++

IRs:
TMP_138(uint8) := i(uint8)
i(uint8) = i + 1""];
19->7;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
assert(bool)(tokensToReceive > 0)

IRs:
TMP_139(bool) = tokensToReceive > 0
TMP_140(None) = SOLIDITY_CALL assert(bool)(TMP_139)""];
20->21;
21[label=""Node Type: IF 21

EXPRESSION:
amountRemaining != 0

IRs:
TMP_141(bool) = amountRemaining != 0
CONDITION TMP_141""];
21->22[label=""True""];
21->23[label=""False""];
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
assert(bool)(msg.sender.send(amountRemaining))

IRs:
TMP_142 = SEND dest:msg.sender value:amountRemaining
TMP_143(None) = SOLIDITY_CALL assert(bool)(TMP_142)""];
22->23;
23[label=""Node Type: END_IF 23
""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
assert(bool)(wallet.send(msg.value - amountRemaining))

IRs:
TMP_144(uint256) = msg.value - amountRemaining
TMP_145 = SEND dest:wallet value:TMP_144
TMP_146(None) = SOLIDITY_CALL assert(bool)(TMP_145)""];
24->25;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
assert(bool)(easyMineToken.transfer(msg.sender,tokensToReceive))

IRs:
TMP_147(bool) = HIGH_LEVEL_CALL, dest:easyMineToken(EasyMineToken), function:transfer, arguments:['msg.sender', 'tokensToReceive']  
TMP_148(None) = SOLIDITY_CALL assert(bool)(TMP_147)""];
25->26;
26[label=""Node Type: IF 26

EXPRESSION:
totalTokensSold() == maxTokensSold()

IRs:
TMP_149(uint256) = INTERNAL_CALL, EasyMineIco.totalTokensSold()()
TMP_150(uint256) = INTERNAL_CALL, EasyMineIco.maxTokensSold()()
TMP_151(bool) = TMP_149 == TMP_150
CONDITION TMP_151""];
26->27[label=""True""];
26->28[label=""False""];
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
finalize()

IRs:
INTERNAL_CALL, EasyMineIco.finalize()()""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
TokensSold(msg.sender,tokensToReceive)

IRs:
Emit TokensSold(msg.sender,tokensToReceive)""];
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
isValidPayload()

IRs:
MODIFIER_CALL, EasyMineIco.isValidPayload()()""];
30->31;
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
timedTransitions()

IRs:
MODIFIER_CALL, EasyMineIco.timedTransitions()()""];
31->32;
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
atStage(Stages.Started)

IRs:
REF_67(EasyMineIco.Stages) -> Stages.Started
MODIFIER_CALL, EasyMineIco.atStage(EasyMineIco.Stages)(REF_67)""];
32->1;
}
",0,1,0,0,"isValidPayload();require(bool)(msg.value > 0);amountRemaining = msg.value;tokensToReceive = 0;i = 0;;i < priceThresholds.length;;assert(bool)(tokensToReceive > 0);tokensAvailable = priceThresholds[i].tokenCount - priceThresholds[i].tokensSold;maxTokensByAmount = amountRemaining * 10 ** 18 / priceThresholds[i].price;;maxTokensByAmount > tokensAvailable;tokens = tokensAvailable;tokens = maxTokensByAmount;amountRemaining -= (priceThresholds[i].price * tokens) / 10 ** 18;;amountRemaining = 0;priceThresholds[i].tokensSold += tokens;tokensToReceive += tokens;i ++;amountRemaining != 0;assert(bool)(msg.sender.send(amountRemaining));;assert(bool)(wallet.send(msg.value - amountRemaining));assert(bool)(easyMineToken.transfer(msg.sender,tokensToReceive));totalTokensSold() == maxTokensSold();finalize();;TokensSold(msg.sender,tokensToReceive);timedTransitions();atStage(Stages.Started)"
./0x5513401cb13ec32809d238ee19a84405759147cc_ext.sol,INTO_ICO.start,169,172,"openingTime(uint256) := now(uint256),TMP_49(uint256) = now + duration,closingTime(uint256) := TMP_49(uint256),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
openingTime = now

IRs:
openingTime(uint256) := now(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
closingTime = now + duration

IRs:
TMP_49(uint256) = now + duration
closingTime(uint256) := TMP_49(uint256)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
3->1;
}
",0,1,0,0,onlyOwner();openingTime = now;closingTime = now + duration
./0x5aa88d2901c68fda244f1d0584400368d2c8e739_ext.sol,MultiplicatorX3.Command,17,23,"TMP_3(bool) = msg.sender == Owner,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),TMP_6(bool) = LOW_LEVEL_CALL, dest:adr, function:call, arguments:['data'] value:msg.value ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == Owner)

IRs:
TMP_3(bool) = msg.sender == Owner
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
adr.call.value(msg.value)(data)

IRs:
TMP_6(bool) = LOW_LEVEL_CALL, dest:adr, function:call, arguments:['data'] value:msg.value ""];
}
",0,1,0,0,require(bool)(msg.sender == Owner);adr.call.value(msg.value)(data)
./0xa5e109d5879b81cd58f209ed29cd7ea43180eb9e_ext.sol,CSC.makeCoin,148,153,"TMP_48(bool) = msg.sender == owner,TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48),totalSupply(uint256) = totalSupply + _value,REF_16(uint256) -> balances[owner],REF_16(-> balances) = REF_16 + _value,RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_48(bool) = msg.sender == owner
TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += _value

IRs:
totalSupply(uint256) = totalSupply + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[owner] += _value

IRs:
REF_16(uint256) -> balances[owner]
REF_16(-> balances) = REF_16 + _value""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,require(bool)(msg.sender == owner);totalSupply += _value;balances[owner] += _value;true
./0x6e7a61fbe11873f4c7d0983c79683aad5c0788bd_ext.sol,ERC20Receive.tokenFallback,75,84,"REF_0(address) -> tkn.sender,REF_0(address) (->tkn) := _from(address),REF_1(uint256) -> tkn.value,REF_1(uint256) (->tkn) := _value(uint256),REF_2(bytes) -> tkn.data,REF_2(bytes) (->tkn) := _data(bytes),REF_3(None) -> _data[3],TMP_12 = CONVERT REF_3 to uint32,REF_4(None) -> _data[2],TMP_13 = CONVERT REF_4 to uint32,TMP_14(uint32) = TMP_13 << 8,TMP_15(uint32) = TMP_12 + TMP_14,REF_5(None) -> _data[1],TMP_16 = CONVERT REF_5 to uint32,TMP_17(uint32) = TMP_16 << 16,TMP_18(uint32) = TMP_15 + TMP_17,REF_6(None) -> _data[0],TMP_19 = CONVERT REF_6 to uint32,TMP_20(uint32) = TMP_19 << 24,TMP_21(uint32) = TMP_18 + TMP_20,u(uint32) := TMP_21(uint32),REF_7(bytes4) -> tkn.sig,TMP_22 = CONVERT u to bytes4,REF_7(bytes4) (->tkn) := TMP_22(bytes4)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
tkn.sender = _from

IRs:
REF_0(address) -> tkn.sender
REF_0(address) (->tkn) := _from(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tkn.value = _value

IRs:
REF_1(uint256) -> tkn.value
REF_1(uint256) (->tkn) := _value(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
tkn.data = _data

IRs:
REF_2(bytes) -> tkn.data
REF_2(bytes) (->tkn) := _data(bytes)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24)

IRs:
REF_3(None) -> _data[3]
TMP_12 = CONVERT REF_3 to uint32
REF_4(None) -> _data[2]
TMP_13 = CONVERT REF_4 to uint32
TMP_14(uint32) = TMP_13 << 8
TMP_15(uint32) = TMP_12 + TMP_14
REF_5(None) -> _data[1]
TMP_16 = CONVERT REF_5 to uint32
TMP_17(uint32) = TMP_16 << 16
TMP_18(uint32) = TMP_15 + TMP_17
REF_6(None) -> _data[0]
TMP_19 = CONVERT REF_6 to uint32
TMP_20(uint32) = TMP_19 << 24
TMP_21(uint32) = TMP_18 + TMP_20
u(uint32) := TMP_21(uint32)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tkn.sig = bytes4(u)

IRs:
REF_7(bytes4) -> tkn.sig
TMP_22 = CONVERT u to bytes4
REF_7(bytes4) (->tkn) := TMP_22(bytes4)""];
}
",0,1,0,0,;tkn.sender = _from;tkn.value = _value;tkn.data = _data;u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);tkn.sig = bytes4(u)
./0xe8c850af3e5c2c45cc85a3faa7a8fb259d939136_ext.sol,CRYPTOSSTOKEN.mintToken,213,218,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,TMP_84 = CONVERT 0 to address,TMP_85 = CONVERT this to address,Emit Transfer(TMP_84,TMP_85,mintedAmount),TMP_87 = CONVERT this to address,Emit Transfer(TMP_87,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(address(0),address(this),mintedAmount)

IRs:
TMP_84 = CONVERT 0 to address
TMP_85 = CONVERT this to address
Emit Transfer(TMP_84,TMP_85,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(address(this),target,mintedAmount)

IRs:
TMP_87 = CONVERT this to address
Emit Transfer(TMP_87,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(address(0),address(this),mintedAmount);Transfer(address(this),target,mintedAmount)"
./0x719e7f0dadfdea25b78595da944f44d15d7e6795_ext.sol,Musk.approveAndCall,112,121,"REF_31(mapping(address => uint256)) -> allowed[msg.sender],REF_32(uint256) -> REF_31[_spender],REF_32(uint256) (->allowed) := _value(uint256),Emit Approval(msg.sender,_spender,_value),TMP_23(bytes32) = SOLIDITY_CALL keccak256()(receiveApproval(address,uint256,address,bytes)),TMP_24 = CONVERT TMP_23 to bytes32,TMP_25 = CONVERT TMP_24 to bytes4,TMP_26(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_25', 'msg.sender', '_value', 'this', '_extraData']  ,TMP_27 = UnaryType.BANG TMP_26 ,CONDITION TMP_27,TMP_28(None) = SOLIDITY_CALL revert()(),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_31(mapping(address => uint256)) -> allowed[msg.sender]
REF_32(uint256) -> REF_31[_spender]
REF_32(uint256) (->allowed) := _value(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
! _spender.call(bytes4(bytes32(keccak256()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData)

IRs:
TMP_23(bytes32) = SOLIDITY_CALL keccak256()(receiveApproval(address,uint256,address,bytes))
TMP_24 = CONVERT TMP_23 to bytes32
TMP_25 = CONVERT TMP_24 to bytes4
TMP_26(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_25', 'msg.sender', '_value', 'this', '_extraData']  
TMP_27 = UnaryType.BANG TMP_26 
CONDITION TMP_27""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
revert()()

IRs:
TMP_28(None) = SOLIDITY_CALL revert()()""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][_spender] = _value;Approval(msg.sender,_spender,_value);! _spender.call(bytes4(bytes32(keccak256()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData);revert()();;true;success"
./0x7982a79ee90eb3682dcee66e47ba79c1cba44062_ext.sol,FlowerBase._transfer,170,178,"REF_9(uint256) -> ownerFlowersCount[_to],TMP_62(uint256) := REF_9(uint256),REF_9(-> ownerFlowersCount) = REF_9 + 1,REF_10(address) -> flowerIndexToOwner[_flowerId],REF_10(address) (->flowerIndexToOwner) := _to(address),TMP_63 = CONVERT 0 to address,TMP_64(bool) = _from != TMP_63,CONDITION TMP_64,REF_11(uint256) -> ownerFlowersCount[_from],TMP_65(uint256) := REF_11(uint256),REF_11(-> ownerFlowersCount) = REF_11 - 1,REF_12(address) -> flowerIndexToApproved[_flowerId],flowerIndexToApproved = delete REF_12 ,Emit Transfer(_from,_to,_flowerId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownerFlowersCount[_to] ++

IRs:
REF_9(uint256) -> ownerFlowersCount[_to]
TMP_62(uint256) := REF_9(uint256)
REF_9(-> ownerFlowersCount) = REF_9 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
flowerIndexToOwner[_flowerId] = _to

IRs:
REF_10(address) -> flowerIndexToOwner[_flowerId]
REF_10(address) (->flowerIndexToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_63 = CONVERT 0 to address
TMP_64(bool) = _from != TMP_63
CONDITION TMP_64""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownerFlowersCount[_from] --

IRs:
REF_11(uint256) -> ownerFlowersCount[_from]
TMP_65(uint256) := REF_11(uint256)
REF_11(-> ownerFlowersCount) = REF_11 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete flowerIndexToApproved[_flowerId]

IRs:
REF_12(address) -> flowerIndexToApproved[_flowerId]
flowerIndexToApproved = delete REF_12 ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_flowerId)

IRs:
Emit Transfer(_from,_to,_flowerId)""];
}
",0,1,0,0,"ownerFlowersCount[_to] ++;flowerIndexToOwner[_flowerId] = _to;_from != address(0);ownerFlowersCount[_from] --;;delete flowerIndexToApproved[_flowerId];Transfer(_from,_to,_flowerId)"
./0xecbed48098c4f25a16195c45ddf5fd736e28b14b_ext.sol,UserfeedsClaimWithConfigurableValueMultiTransfer.transfer,151,156,"i(uint256) := 0(uint256),REF_12 -> LENGTH recipients,TMP_77(bool) = i < REF_12,CONDITION TMP_77,REF_13(address) -> recipients[i],REF_15(uint256) -> values[i],Transfer dest:REF_13 value:REF_15,TMP_79(uint256) := i(uint256),i(uint256) = i + 1,TMP_80 = CONVERT this to address,TMP_81(uint256) = SOLIDITY_CALL balance(address)(TMP_80),Transfer dest:msg.sender value:TMP_81","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
2->7;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < recipients.length

IRs:
REF_12 -> LENGTH recipients
TMP_77(bool) = i < REF_12
CONDITION TMP_77""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
recipients[i].transfer(values[i])

IRs:
REF_13(address) -> recipients[i]
REF_15(uint256) -> values[i]
Transfer dest:REF_13 value:REF_15""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_79(uint256) := i(uint256)
i(uint256) = i + 1""];
6->4;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_80 = CONVERT this to address
TMP_81(uint256) = SOLIDITY_CALL balance(address)(TMP_80)
Transfer dest:msg.sender value:TMP_81""];
}
",0,1,0,0,i = 0;;i < recipients.length;;msg.sender.transfer(address(this).balance);recipients[i].transfer(values[i]);i ++
./0x6d3543d4b11683847697f5b9a3a9d116cf13dedd_ext.sol,Ledger.subtract,183,207,"TMP_42 = CONVERT 0 to address,TMP_43(bool) = _address == TMP_42,TMP_44(bool) = _amt == 0,TMP_45(bool) = TMP_43 || TMP_44,CONDITION TMP_45,REF_18(Ledger.Entry) -> entries[_address],entry(Ledger.Entry) := REF_18(Ledger.Entry),REF_19(uint256) -> entry.balance,_maxAmt(uint256) := REF_19(uint256),TMP_46(bool) = _maxAmt == 0,CONDITION TMP_46,TMP_47(bool) = _amt >= _maxAmt,CONDITION TMP_47,total(uint256) = total - _maxAmt,REF_20(address) -> entry.prev,REF_21(Ledger.Entry) -> entries[REF_20],REF_22(address) -> REF_21.next,REF_23(address) -> entry.next,REF_22(address) (->entries) := REF_23(address),REF_24(address) -> entry.next,REF_25(Ledger.Entry) -> entries[REF_24],REF_26(address) -> REF_25.prev,REF_27(address) -> entry.prev,REF_26(address) (->entries) := REF_27(address),REF_28(Ledger.Entry) -> entries[_address],entries = delete REF_28 ,RETURN _maxAmt,total(uint256) = total - _amt,REF_29(uint256) -> entry.balance,REF_29(-> entry) = REF_29 - _amt,RETURN _amt,MODIFIER_CALL, Ledger.fromOwner()(),RETURN _amtRemoved","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->19;
1[label=""Node Type: IF 1

EXPRESSION:
_address == address(0) || _amt == 0

IRs:
TMP_42 = CONVERT 0 to address
TMP_43(bool) = _address == TMP_42
TMP_44(bool) = _amt == 0
TMP_45(bool) = TMP_43 || TMP_44
CONDITION TMP_45""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
entry = entries[_address]

IRs:
REF_18(Ledger.Entry) -> entries[_address]
entry(Ledger.Entry) := REF_18(Ledger.Entry)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
_maxAmt = entry.balance

IRs:
REF_19(uint256) -> entry.balance
_maxAmt(uint256) := REF_19(uint256)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
_maxAmt == 0

IRs:
TMP_46(bool) = _maxAmt == 0
CONDITION TMP_46""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: RETURN 7
""];
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
_amt >= _maxAmt

IRs:
TMP_47(bool) = _amt >= _maxAmt
CONDITION TMP_47""];
9->10[label=""True""];
9->15[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
total -= _maxAmt

IRs:
total(uint256) = total - _maxAmt""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
entries[entry.prev].next = entry.next

IRs:
REF_20(address) -> entry.prev
REF_21(Ledger.Entry) -> entries[REF_20]
REF_22(address) -> REF_21.next
REF_23(address) -> entry.next
REF_22(address) (->entries) := REF_23(address)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
entries[entry.next].prev = entry.prev

IRs:
REF_24(address) -> entry.next
REF_25(Ledger.Entry) -> entries[REF_24]
REF_26(address) -> REF_25.prev
REF_27(address) -> entry.prev
REF_26(address) (->entries) := REF_27(address)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
delete entries[_address]

IRs:
REF_28(Ledger.Entry) -> entries[_address]
entries = delete REF_28 ""];
13->14;
14[label=""Node Type: RETURN 14

EXPRESSION:
_maxAmt

IRs:
RETURN _maxAmt""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
total -= _amt

IRs:
total(uint256) = total - _amt""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
entry.balance -= _amt

IRs:
REF_29(uint256) -> entry.balance
REF_29(-> entry) = REF_29 - _amt""];
16->17;
17[label=""Node Type: RETURN 17

EXPRESSION:
_amt

IRs:
RETURN _amt""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
fromOwner()

IRs:
MODIFIER_CALL, Ledger.fromOwner()()""];
19->1;
20[label=""Node Type: RETURN 20

EXPRESSION:
_amtRemoved

IRs:
RETURN _amtRemoved""];
}
",0,1,0,0,fromOwner();_address == address(0) || _amt == 0;;;entry = entries[_address];_maxAmt = entry.balance;_maxAmt == 0;;;_amt >= _maxAmt;total -= _maxAmt;total -= _amt;entries[entry.prev].next = entry.next;entries[entry.next].prev = entry.prev;delete entries[_address];_maxAmt;entry.balance -= _amt;_amt;_amtRemoved
./0x71be4a37ef6423c4dc0530410454d85da3d73d64_ext.sol,StandardToken.transferFrom,58,68,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x70f53cb14a08700d0816f01bdae54b3f507f2ce2_ext.sol,Contract50.fallback,15,42,"REF_0(uint256) -> invested[msg.sender],TMP_0(bool) = REF_0 != 0,CONDITION TMP_0,REF_1(uint256) -> invested[msg.sender],TMP_1(uint256) = REF_1 / 50,REF_2(uint256) -> atBlock[msg.sender],TMP_2(uint256) = block.number - REF_2,TMP_3(uint256) = TMP_1 * TMP_2,TMP_4(uint256) = TMP_3 / 5900,amount(uint256) := TMP_4(uint256),Transfer dest:msg.sender value:amount,REF_4(uint256) -> atBlock[msg.sender],REF_4(uint256) (->atBlock) := block.number(uint256),REF_5(uint256) -> invested[msg.sender],REF_5(-> invested) = REF_5 + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
invested[msg.sender] != 0

IRs:
REF_0(uint256) -> invested[msg.sender]
TMP_0(bool) = REF_0 != 0
CONDITION TMP_0""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = invested[msg.sender] / 50 * (block.number - atBlock[msg.sender]) / 5900

IRs:
REF_1(uint256) -> invested[msg.sender]
TMP_1(uint256) = REF_1 / 50
REF_2(uint256) -> atBlock[msg.sender]
TMP_2(uint256) = block.number - REF_2
TMP_3(uint256) = TMP_1 * TMP_2
TMP_4(uint256) = TMP_3 / 5900
amount(uint256) := TMP_4(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
atBlock[msg.sender] = block.number

IRs:
REF_4(uint256) -> atBlock[msg.sender]
REF_4(uint256) (->atBlock) := block.number(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
invested[msg.sender] += msg.value

IRs:
REF_5(uint256) -> invested[msg.sender]
REF_5(-> invested) = REF_5 + msg.value""];
}
",0,1,0,0,invested[msg.sender] != 0;amount = invested[msg.sender] / 50 * (block.number - atBlock[msg.sender]) / 5900;;msg.sender.transfer(amount);atBlock[msg.sender] = block.number;invested[msg.sender] += msg.value
./0x518049c81352636b34d82f0a3fad8cfe3571f35a_ext.sol,TICKET._transfer,45,61,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xf2d4dcfe87430ae9d1e0235edaa7cd3d445e2378_ext.sol,OPCToken.burn,128,134,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x41de5b7cf63c8d028daa2626d9aeaf02cad8c6c3_ext.sol,queue.queueSize,63,65,"REF_0(uint256) -> q.back,REF_1(uint256) -> q.front,TMP_15(uint256) = REF_0 - REF_1,r(uint256) := TMP_15(uint256),RETURN r","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
r = q.back - q.front

IRs:
REF_0(uint256) -> q.back
REF_1(uint256) -> q.front
TMP_15(uint256) = REF_0 - REF_1
r(uint256) := TMP_15(uint256)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
r

IRs:
RETURN r""];
}
",0,1,0,0,r = q.back - q.front;r
./0x271a0b465d5b453bb835afd2d671c76b2b76900e_ext.sol,ClockAuctionBase._computeCurrentPrice,442,477,"TMP_100(bool) = _secondsPassed >= _duration,CONDITION TMP_100,RETURN _endingPrice,TMP_101 = CONVERT _endingPrice to int256,TMP_102 = CONVERT _startingPrice to int256,TMP_103(int256) = TMP_101 - TMP_102,totalPriceChange(int256) := TMP_103(int256),TMP_104 = CONVERT _secondsPassed to int256,TMP_105(int256) = totalPriceChange * TMP_104,TMP_106 = CONVERT _duration to int256,TMP_107(int256) = TMP_105 / TMP_106,currentPriceChange(int256) := TMP_107(int256),TMP_108 = CONVERT _startingPrice to int256,TMP_109(int256) = TMP_108 + currentPriceChange,currentPrice(int256) := TMP_109(int256),TMP_110 = CONVERT currentPrice to uint256,RETURN TMP_110","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_secondsPassed >= _duration

IRs:
TMP_100(bool) = _secondsPassed >= _duration
CONDITION TMP_100""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
_endingPrice

IRs:
RETURN _endingPrice""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
totalPriceChange = int256(_endingPrice) - int256(_startingPrice)

IRs:
TMP_101 = CONVERT _endingPrice to int256
TMP_102 = CONVERT _startingPrice to int256
TMP_103(int256) = TMP_101 - TMP_102
totalPriceChange(int256) := TMP_103(int256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration)

IRs:
TMP_104 = CONVERT _secondsPassed to int256
TMP_105(int256) = totalPriceChange * TMP_104
TMP_106 = CONVERT _duration to int256
TMP_107(int256) = TMP_105 / TMP_106
currentPriceChange(int256) := TMP_107(int256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
currentPrice = int256(_startingPrice) + currentPriceChange

IRs:
TMP_108 = CONVERT _startingPrice to int256
TMP_109(int256) = TMP_108 + currentPriceChange
currentPrice(int256) := TMP_109(int256)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
uint256(currentPrice)

IRs:
TMP_110 = CONVERT currentPrice to uint256
RETURN TMP_110""];
}
",0,1,0,0,_secondsPassed >= _duration;_endingPrice;totalPriceChange = int256(_endingPrice) - int256(_startingPrice);currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);currentPrice = int256(_startingPrice) + currentPriceChange;uint256(currentPrice)
./0x51696e028e0fe5416481c28cf1a2626d43680751_ext.sol,IngridIsAHorribleHumanCoin.transfer,53,59,"REF_1(uint256) -> balances[msg.sender],TMP_0(bool) = REF_1 >= _value,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_2(uint256) -> balances[msg.sender],REF_2(-> balances) = REF_2 - _value,REF_3(uint256) -> balances[_to],REF_3(-> balances) = REF_3 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_0(bool) = REF_1 >= _value
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_2(uint256) -> balances[msg.sender]
REF_2(-> balances) = REF_2 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_3(uint256) -> balances[_to]
REF_3(-> balances) = REF_3 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0x5cb888182fbffdb62c08fb4b5a343914f00fdfee_ext.sol,TokenERC20.burnFrom,169,177,"REF_19(uint256) -> balanceOf[_from],TMP_29(bool) = REF_19 >= _value,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_31(bool) = _value <= REF_21,TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_29(bool) = REF_19 >= _value
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_31(bool) = _value <= REF_21
TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xdc52c48074c3dcf9acbcb90b468484284d777490_ext.sol,BDDBToken.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0xb3a0dc0daa5ce33fc14a142c0fd4a1586c4e8c82_ext.sol,Bitstraq_Token.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x874c3471d459f4107abaeb915cdba6c562cfba3d_ext.sol,Gorgona.getInvestorDividendsAmount,205,207,"REF_76(Gorgona.Investor) -> investors[addr],REF_77(uint256) -> REF_76.deposit,TMP_78(uint256) = REF_77 / 100,TMP_79(uint256) = TMP_78 * INTEREST,REF_78(Gorgona.Investor) -> investors[addr],REF_79(uint256) -> REF_78.date,TMP_80(uint256) = now - REF_79,TMP_81(uint256) = TMP_79 * TMP_80,TMP_82(uint256) = TMP_81 / 86400,RETURN TMP_82","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
investors[addr].deposit / 100 * INTEREST * (now - investors[addr].date) / 86400

IRs:
REF_76(Gorgona.Investor) -> investors[addr]
REF_77(uint256) -> REF_76.deposit
TMP_78(uint256) = REF_77 / 100
TMP_79(uint256) = TMP_78 * INTEREST
REF_78(Gorgona.Investor) -> investors[addr]
REF_79(uint256) -> REF_78.date
TMP_80(uint256) = now - REF_79
TMP_81(uint256) = TMP_79 * TMP_80
TMP_82(uint256) = TMP_81 / 86400
RETURN TMP_82""];
}
",0,1,0,0,investors[addr].deposit / 100 * INTEREST * (now - investors[addr].date) / 86400
./0x029fa59111136ce592e136760a1df1d4a6cd564b_ext.sol,RetailLoyaltySystemBase.burnFrom,166,174,"REF_22(uint256) -> balances[_from],TMP_26(bool) = REF_22 >= _value,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_23(mapping(address => uint256)) -> allowances[_from],REF_24(uint256) -> REF_23[msg.sender],TMP_28(bool) = _value <= REF_24,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_25(uint256) -> balances[_from],REF_25(-> balances) = REF_25 - _value,REF_26(mapping(address => uint256)) -> allowances[_from],REF_27(uint256) -> REF_26[msg.sender],REF_27(-> allowances) = REF_27 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[_from] >= _value)

IRs:
REF_22(uint256) -> balances[_from]
TMP_26(bool) = REF_22 >= _value
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowances[_from][msg.sender])

IRs:
REF_23(mapping(address => uint256)) -> allowances[_from]
REF_24(uint256) -> REF_23[msg.sender]
TMP_28(bool) = _value <= REF_24
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_25(uint256) -> balances[_from]
REF_25(-> balances) = REF_25 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowances[_from][msg.sender] -= _value

IRs:
REF_26(mapping(address => uint256)) -> allowances[_from]
REF_27(uint256) -> REF_26[msg.sender]
REF_27(-> allowances) = REF_27 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(balances[_from] >= _value);require(bool)(_value <= allowances[_from][msg.sender]);balances[_from] -= _value;allowances[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true"
./0xf3fb69ef211c6d1e838a5c2223ef54fed4f24090_ext.sol,SafeMath.add,22,26,"TMP_10(uint256) = a + b,c(uint256) := TMP_10(uint256),TMP_11(bool) = c >= a,TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11),RETURN c","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_10(uint256) = a + b
c(uint256) := TMP_10(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_11(bool) = c >= a
TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c""];
}
",0,1,0,0,c = a + b;assert(bool)(c >= a);c
./0xd0a024e4b057024f941051dc19220a3bab4b5d45_ext.sol,RelexLife.burn,125,131,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x78dd22e93357d6f926fa0f7cb860c5e6e1bcf484_ext.sol,LETSY.addTokenToTotalSupply,187,191,"TMP_54(bool) = _value > 0,TMP_55(None) = SOLIDITY_CALL require(bool)(TMP_54),REF_17(uint256) -> balances[msg.sender],REF_18(uint256) -> balances[msg.sender],TMP_56(uint256) = REF_18 + _value,REF_17(uint256) (->balances) := TMP_56(uint256),TMP_57(uint256) = _totalSupply + _value,_totalSupply(uint256) := TMP_57(uint256),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_54(bool) = _value > 0
TMP_55(None) = SOLIDITY_CALL require(bool)(TMP_54)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] = balances[msg.sender] + _value

IRs:
REF_17(uint256) -> balances[msg.sender]
REF_18(uint256) -> balances[msg.sender]
TMP_56(uint256) = REF_18 + _value
REF_17(uint256) (->balances) := TMP_56(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_totalSupply = _totalSupply + _value

IRs:
TMP_57(uint256) = _totalSupply + _value
_totalSupply(uint256) := TMP_57(uint256)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
4->1;
}
",0,1,0,0,onlyOwner();require(bool)(_value > 0);balances[msg.sender] = balances[msg.sender] + _value;_totalSupply = _totalSupply + _value
./0x03a9458d77dd705829fa758c64dbe770385295cc_ext.sol,PolicyRegistry.setPolicy,45,48,"REF_0(string) -> policies[_subcourtID],Emit PolicyUpdate(_subcourtID,REF_0),REF_1(string) -> policies[_subcourtID],REF_1(string) (->policies) := _policy(string),MODIFIER_CALL, PolicyRegistry.onlyByGovernor()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
PolicyUpdate(_subcourtID,policies[_subcourtID])

IRs:
REF_0(string) -> policies[_subcourtID]
Emit PolicyUpdate(_subcourtID,REF_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
policies[_subcourtID] = _policy

IRs:
REF_1(string) -> policies[_subcourtID]
REF_1(string) (->policies) := _policy(string)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyByGovernor()

IRs:
MODIFIER_CALL, PolicyRegistry.onlyByGovernor()()""];
3->1;
}
",0,1,0,0,"onlyByGovernor();PolicyUpdate(_subcourtID,policies[_subcourtID]);policies[_subcourtID] = _policy"
./0x48e3ec3d717ca867fa5b4ab61f6874dd0e3b8500_ext.sol,TokenERC20.burnFrom,166,174,"REF_19(uint256) -> balanceOf[_from],TMP_29(bool) = REF_19 >= _value,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_31(bool) = _value <= REF_21,TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_29(bool) = REF_19 >= _value
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_31(bool) = _value <= REF_21
TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x8c28350a9449397f6ccbc61dd724601193a5dea0_ext.sol,MGTToken.setSymbol,83,85,"symbol(string) := _symbol(string),MODIFIER_CALL, MGTToken.isOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
symbol = _symbol

IRs:
symbol(string) := _symbol(string)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isOwner()

IRs:
MODIFIER_CALL, MGTToken.isOwner()()""];
2->1;
}
",0,1,0,0,isOwner();symbol = _symbol
./0x264979ffd35d608e69b69681f4bbcba9877e6c4a_ext.sol,qz_game.start_qz_game,20,27,"TMP_7(bool) = responseHash == 0,CONDITION TMP_7,TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response),responseHash(bytes32) := TMP_8(bytes32),question(string) := _question(string),questionSender(address) := msg.sender(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
responseHash == 0x0

IRs:
TMP_7(bool) = responseHash == 0
CONDITION TMP_7""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
responseHash = keccak256()(_response)

IRs:
TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response)
responseHash(bytes32) := TMP_8(bytes32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
questionSender = msg.sender

IRs:
questionSender(address) := msg.sender(address)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,1,0,0,responseHash == 0x0;responseHash = keccak256()(_response);;question = _question;questionSender = msg.sender
./0x282d74cc2203e5c19b522876ca6fdee59d3b800b_ext.sol,RegularToken.transferFrom,90,109,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x722baa20d3b42fc1ec0b63fb84ba3fda47da4a26_ext.sol,ELHeroToken.totalSupply,278,280,"REF_16 -> LENGTH cardArray,TMP_102(uint256) = REF_16 - destroyCardCount,TMP_103(uint256) = TMP_102 - 1,RETURN TMP_103","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
cardArray.length - destroyCardCount - 1

IRs:
REF_16 -> LENGTH cardArray
TMP_102(uint256) = REF_16 - destroyCardCount
TMP_103(uint256) = TMP_102 - 1
RETURN TMP_103""];
}
",0,1,0,0,cardArray.length - destroyCardCount - 1
./0x20d2f8fdd0951f2f5249c86b3cdc2be7656f2c01_ext.sol,MyTokenEVC.burn,162,168,"REF_20(uint256) -> _balanceOf[msg.sender],TMP_30(bool) = REF_20 >= _value,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_21(uint256) -> _balanceOf[msg.sender],REF_21(-> _balanceOf) = REF_21 - _value,_totalSupply(uint256) = _totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,MODIFIER_CALL, owned.onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_balanceOf[msg.sender] >= _value)

IRs:
REF_20(uint256) -> _balanceOf[msg.sender]
TMP_30(bool) = REF_20 >= _value
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_balanceOf[msg.sender] -= _value

IRs:
REF_21(uint256) -> _balanceOf[msg.sender]
REF_21(-> _balanceOf) = REF_21 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_totalSupply -= _value

IRs:
_totalSupply(uint256) = _totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
6->1;
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"onlyOwner();require(bool)(_balanceOf[msg.sender] >= _value);_balanceOf[msg.sender] -= _value;_totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x6543cde961213e82001594bf4c34706579ce34ec_ext.sol,Whitelist.whitelist,1774,1780,"TMP_882(bool) = INTERNAL_CALL, RBAC.hasRole(address,string)(_operator,ROLE_WHITELISTED),RETURN TMP_882","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
hasRole(_operator,ROLE_WHITELISTED)

IRs:
TMP_882(bool) = INTERNAL_CALL, RBAC.hasRole(address,string)(_operator,ROLE_WHITELISTED)
RETURN TMP_882""];
}
",0,1,0,0,"hasRole(_operator,ROLE_WHITELISTED)"
./0xefc1b11ad4b183ad859ef220a9c498cb04716a31_ext.sol,Counter.inc,19,27,"TMP_2(bool) = msg.value >= 1000000000000000,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),TMP_4(uint256) := i(uint256),i(uint256) = i + 1,TMP_5(bool) = i == 2,CONDITION TMP_5,TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),Emit Won(msg.sender,TMP_7),TMP_9 = CONVERT this to address,TMP_10(uint256) = SOLIDITY_CALL balance(address)(TMP_9),Transfer dest:msg.sender value:TMP_10,i(uint256) := 0(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= 1000000000000000)

IRs:
TMP_2(bool) = msg.value >= 1000000000000000
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
i ++

IRs:
TMP_4(uint256) := i(uint256)
i(uint256) = i + 1""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
i == 2

IRs:
TMP_5(bool) = i == 2
CONDITION TMP_5""];
3->4[label=""True""];
3->7[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Won(msg.sender,address(this).balance)

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
Emit Won(msg.sender,TMP_7)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_9 = CONVERT this to address
TMP_10(uint256) = SOLIDITY_CALL balance(address)(TMP_9)
Transfer dest:msg.sender value:TMP_10""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
}
",0,1,0,0,"require(bool)(msg.value >= 1000000000000000);i ++;i == 2;Won(msg.sender,address(this).balance);;msg.sender.transfer(address(this).balance);i = 0"
./0x704079e823e42a936bbaac5163434c2515473836_ext.sol,CONUNDRUM.StartGame,12,22,"TMP_0(bool) = responseHash == 0,CONDITION TMP_0,TMP_1(bytes32) = SOLIDITY_CALL keccak256()(_response),responseHash(bytes32) := TMP_1(bytes32),question(string) := _question(string),questionSender(address) := msg.sender(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
responseHash == 0x0

IRs:
TMP_0(bool) = responseHash == 0
CONDITION TMP_0""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
responseHash = keccak256()(_response)

IRs:
TMP_1(bytes32) = SOLIDITY_CALL keccak256()(_response)
responseHash(bytes32) := TMP_1(bytes32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
questionSender = msg.sender

IRs:
questionSender(address) := msg.sender(address)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,1,0,0,responseHash == 0x0;responseHash = keccak256()(_response);;question = _question;questionSender = msg.sender
./0x296b3fc8e3cc768f834152586e5ad708bfe8f163_ext.sol,StandardToken.transferFrom,53,62,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x5abaff0b83f81dc061c590aadcba013c69237fd7_ext.sol,CryptoJade.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x219b9040eb7d8d8c2e8e84b87ce9ac1c83071980_ext.sol,RegularToken.transferFrom,109,128,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x1cd74dd56b0929f1505c6e1f9bdf57fb31d60631_ext.sol,BugisContract.burnFrom,142,150,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xa3fa17c51a77a79808f3c21948de3ea70391ce6a_ext.sol,CryptoAllStars._transfer,358,373,"REF_41(uint256) -> ownershipTokenCount[_to],TMP_95(uint256) := REF_41(uint256),REF_41(-> ownershipTokenCount) = REF_41 + 1,REF_42(address) -> personIndexToOwner[_tokenId],REF_42(address) (->personIndexToOwner) := _to(address),TMP_96 = CONVERT 0 to address,TMP_97(bool) = _from != TMP_96,CONDITION TMP_97,REF_43(uint256) -> ownershipTokenCount[_from],TMP_98(uint256) := REF_43(uint256),REF_43(-> ownershipTokenCount) = REF_43 - 1,REF_44(address) -> personIndexToApproved[_tokenId],personIndexToApproved = delete REF_44 ,Emit Transfer(_from,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownershipTokenCount[_to] ++

IRs:
REF_41(uint256) -> ownershipTokenCount[_to]
TMP_95(uint256) := REF_41(uint256)
REF_41(-> ownershipTokenCount) = REF_41 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
personIndexToOwner[_tokenId] = _to

IRs:
REF_42(address) -> personIndexToOwner[_tokenId]
REF_42(address) (->personIndexToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_96 = CONVERT 0 to address
TMP_97(bool) = _from != TMP_96
CONDITION TMP_97""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownershipTokenCount[_from] --

IRs:
REF_43(uint256) -> ownershipTokenCount[_from]
TMP_98(uint256) := REF_43(uint256)
REF_43(-> ownershipTokenCount) = REF_43 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete personIndexToApproved[_tokenId]

IRs:
REF_44(address) -> personIndexToApproved[_tokenId]
personIndexToApproved = delete REF_44 ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
}
",0,1,0,0,"ownershipTokenCount[_to] ++;personIndexToOwner[_tokenId] = _to;_from != address(0);ownershipTokenCount[_from] --;;delete personIndexToApproved[_tokenId];Transfer(_from,_to,_tokenId)"
./0x41c23bf53117806ce77ca65003d435c4d944f519_ext.sol,Contractus.fallback,68,96,"TMP_12(bool) = msg.value > 0,TMP_13(None) = SOLIDITY_CALL require(bool,string)(TMP_12,Zero. Access denied.),totalFunds(uint256) = totalFunds + msg.value,investor(address) := msg.sender(address),TMP_14(uint256) = msg.value * 3,TMP_15(uint256) = TMP_14 / 100,Transfer dest:support value:TMP_15,TMP_17(uint256) = msg.value * 7,TMP_18(uint256) = TMP_17 / 100,Transfer dest:marketing value:TMP_18,TMP_20(uint256) = INTERNAL_CALL, Contractus.calcProfit(address)(investor),profit(uint256) := TMP_20(uint256),Transfer dest:investor value:profit,TMP_22(bool) = INTERNAL_CALL, Contractus.isLastWithdraw(address)(investor),CONDITION TMP_22,REF_10(uint256) -> balances[investor],REF_10(uint256) (->balances) := 0(uint256),REF_11(uint256) -> receiveFunds[investor],REF_11(uint256) (->receiveFunds) := 0(uint256),REF_12(uint256) -> receiveFunds[investor],REF_12(-> receiveFunds) = REF_12 + profit,REF_13(uint256) -> balances[investor],REF_13(-> balances) = REF_13 + msg.value,REF_14(uint256) -> timestamp[investor],REF_14(uint256) (->timestamp) := now(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(msg.value > 0,Zero. Access denied.)

IRs:
TMP_12(bool) = msg.value > 0
TMP_13(None) = SOLIDITY_CALL require(bool,string)(TMP_12,Zero. Access denied.)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalFunds += msg.value

IRs:
totalFunds(uint256) = totalFunds + msg.value""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
support.transfer(msg.value * 3 / 100)

IRs:
TMP_14(uint256) = msg.value * 3
TMP_15(uint256) = TMP_14 / 100
Transfer dest:support value:TMP_15""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
marketing.transfer(msg.value * 7 / 100)

IRs:
TMP_17(uint256) = msg.value * 7
TMP_18(uint256) = TMP_17 / 100
Transfer dest:marketing value:TMP_18""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
profit = calcProfit(investor)

IRs:
TMP_20(uint256) = INTERNAL_CALL, Contractus.calcProfit(address)(investor)
profit(uint256) := TMP_20(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
investor.transfer(profit)

IRs:
Transfer dest:investor value:profit""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
isLastWithdraw(investor)

IRs:
TMP_22(bool) = INTERNAL_CALL, Contractus.isLastWithdraw(address)(investor)
CONDITION TMP_22""];
8->9[label=""True""];
8->11[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
balances[investor] = 0

IRs:
REF_10(uint256) -> balances[investor]
REF_10(uint256) (->balances) := 0(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
receiveFunds[investor] = 0

IRs:
REF_11(uint256) -> receiveFunds[investor]
REF_11(uint256) (->receiveFunds) := 0(uint256)""];
10->13;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
receiveFunds[investor] += profit

IRs:
REF_12(uint256) -> receiveFunds[investor]
REF_12(-> receiveFunds) = REF_12 + profit""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
balances[investor] += msg.value

IRs:
REF_13(uint256) -> balances[investor]
REF_13(-> balances) = REF_13 + msg.value""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
timestamp[investor] = now

IRs:
REF_14(uint256) -> timestamp[investor]
REF_14(uint256) (->timestamp) := now(uint256)""];
}
",0,1,0,0,"require(bool,string)(msg.value > 0,Zero. Access denied.);totalFunds += msg.value;investor = msg.sender;support.transfer(msg.value * 3 / 100);marketing.transfer(msg.value * 7 / 100);profit = calcProfit(investor);investor.transfer(profit);isLastWithdraw(investor);balances[investor] = 0;receiveFunds[investor] += profit;receiveFunds[investor] = 0;;balances[investor] += msg.value;timestamp[investor] = now"
./0x3a03afa73623b99eedaa6180a869dd5bde17a601_ext.sol,CheapLambos.burn,64,69,"REF_18(uint256) -> balanceOf[msg.sender],TMP_23(bool) = REF_18 >= _value,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),REF_19(uint256) -> balanceOf[msg.sender],REF_19(-> balanceOf) = REF_19 - _value,REF_20(uint256) -> balanceOf[0],REF_20(-> balanceOf) = REF_20 + _value,Emit Transfer(msg.sender,0,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
TMP_23(bool) = REF_18 >= _value
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_19(uint256) -> balanceOf[msg.sender]
REF_19(-> balanceOf) = REF_19 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[0x0] += _value

IRs:
REF_20(uint256) -> balanceOf[0]
REF_20(-> balanceOf) = REF_20 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,0x0,_value)

IRs:
Emit Transfer(msg.sender,0,_value)""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;balanceOf[0x0] += _value;Transfer(msg.sender,0x0,_value)"
./0xdbbb7c56a5c8f60a9e5a38501a168f673cd61754_ext.sol,AvPresale.sendMoneyBack,114,119,"REF_12(uint256) -> balances[msg.sender],REF_13(uint256) = SOLIDITY_CALL balance(address)(this),TMP_28([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9D3497940>]) = REF_13 - msg.value,TMP_29(uint256) = INTERNAL_CALL, AvPresale.min(uint256,uint256)(REF_12,TMP_28),amount_to_money_back(uint256) := TMP_29(uint256),REF_14(uint256) -> balances[msg.sender],REF_14(-> balances) = REF_14 - amount_to_money_back,total_money_back(uint256) = total_money_back + amount_to_money_back,TMP_30(uint256) = amount_to_money_back + msg.value,Transfer dest:msg.sender value:TMP_30,MODIFIER_CALL, AvPresale.tokenHoldersOnly()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
amount_to_money_back = min(balances[msg.sender],this.balance - msg.value)

IRs:
REF_12(uint256) -> balances[msg.sender]
REF_13(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_28([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9D3497940>]) = REF_13 - msg.value
TMP_29(uint256) = INTERNAL_CALL, AvPresale.min(uint256,uint256)(REF_12,TMP_28)
amount_to_money_back(uint256) := TMP_29(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= amount_to_money_back

IRs:
REF_14(uint256) -> balances[msg.sender]
REF_14(-> balances) = REF_14 - amount_to_money_back""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
total_money_back += amount_to_money_back

IRs:
total_money_back(uint256) = total_money_back + amount_to_money_back""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(amount_to_money_back + msg.value)

IRs:
TMP_30(uint256) = amount_to_money_back + msg.value
Transfer dest:msg.sender value:TMP_30""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
tokenHoldersOnly()

IRs:
MODIFIER_CALL, AvPresale.tokenHoldersOnly()()""];
5->1;
}
",0,1,1,0,"tokenHoldersOnly();amount_to_money_back = min(balances[msg.sender],this.balance - msg.value);balances[msg.sender] -= amount_to_money_back;total_money_back += amount_to_money_back;msg.sender.transfer(amount_to_money_back + msg.value)"
./0x2c82c73d5b34aa015989462b2948cd616a37641f_ext.sol,MiniMeTokenFactory.createCloneToken,663,683,"TMP_160(MiniMeToken) = new MiniMeToken(this,_parentToken,_snapshotBlock,_tokenName,_decimalUnits,_tokenSymbol,_transfersEnabled) ,newToken(MiniMeToken) := TMP_160(MiniMeToken),HIGH_LEVEL_CALL, dest:newToken(MiniMeToken), function:changeController, arguments:['msg.sender']  ,RETURN newToken","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
newToken = new MiniMeToken(this,_parentToken,_snapshotBlock,_tokenName,_decimalUnits,_tokenSymbol,_transfersEnabled)

IRs:
TMP_160(MiniMeToken) = new MiniMeToken(this,_parentToken,_snapshotBlock,_tokenName,_decimalUnits,_tokenSymbol,_transfersEnabled) 
newToken(MiniMeToken) := TMP_160(MiniMeToken)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
newToken.changeController(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:newToken(MiniMeToken), function:changeController, arguments:['msg.sender']  ""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
newToken

IRs:
RETURN newToken""];
}
",0,1,0,0,"newToken = new MiniMeToken(this,_parentToken,_snapshotBlock,_tokenName,_decimalUnits,_tokenSymbol,_transfersEnabled);newToken.changeController(msg.sender);newToken"
./0x6bef7336e8176ce577d32a4ffc8c7e87b726d4a3_ext.sol,FixedSupplyToken.approveAndCall,133,138,"REF_24(mapping(address => uint256)) -> allowed[msg.sender],REF_25(uint256) -> REF_24[spender],REF_25(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_43 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_43(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_24(mapping(address => uint256)) -> allowed[msg.sender]
REF_25(uint256) -> REF_24[spender]
REF_25(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_43 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_43(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xc41585205b83b7c643a37b87887c97cf31cb8867_ext.sol,QINTAR.approveAndCall,202,207,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x332eeaa966e0d7dcf2c5373b9b9c88f8be2eee15_ext.sol,EGFToken.mine,106,112,"totalSupply(uint256) = totalSupply + amount,REF_38(uint256) -> balanceOf[target],REF_38(-> balanceOf) = REF_38 + amount,Emit AddSupply(amount),Emit Transfer(0,target,amount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
totalSupply += amount

IRs:
totalSupply(uint256) = totalSupply + amount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[target] += amount

IRs:
REF_38(uint256) -> balanceOf[target]
REF_38(-> balanceOf) = REF_38 + amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
AddSupply(amount)

IRs:
Emit AddSupply(amount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(0,target,amount)

IRs:
Emit Transfer(0,target,amount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();totalSupply += amount;balanceOf[target] += amount;AddSupply(amount);Transfer(0,target,amount)"
./0x17c8d8b7659141273a1c2223030c89b96713a44a_ext.sol,XPS.burnFrom,141,149,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x7476c85d6dfc144c6b196d8956b4cc2bbfb860f2_ext.sol,TokenERC20._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x1f9033b3fdf74e1d7619447bc491d73a36967d71_ext.sol,Data.addBalance,270,272,"REF_82(uint256) -> balances[_addr],REF_82(-> balances) = REF_82 + amount,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances[_addr] += amount

IRs:
REF_82(uint256) -> balances[_addr]
REF_82(-> balances) = REF_82 + amount""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,1,0,0,onlyOwner();balances[_addr] += amount
./0x1d26883a84a81b3046e027bbcbe7506a90e6b5a5_ext.sol,PiToken.burnFrom,164,172,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x3595279a9f0658eb2649976f155111bae1ae9de6_ext.sol,GGE._transfer,45,61,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xa15b24b7b883aac6bc6582b0057c09d62a7a1b2c_ext.sol,Simply10.fallback,8,19,"sender(address) := msg.sender(address),REF_0(uint256) -> invests[sender],TMP_0(bool) = REF_0 != 0,CONDITION TMP_0,REF_1(uint256) -> invests[sender],TMP_1(uint256) = REF_1 / 100,TMP_2(uint256) = TMP_1 * 10,REF_2(uint256) -> dates[sender],TMP_3(uint256) = now - REF_2,TMP_4(uint256) = TMP_2 * TMP_3,TMP_5(uint256) = TMP_4 / 86400,payout(uint256) := TMP_5(uint256),TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),TMP_8(bool) = payout > TMP_7,CONDITION TMP_8,TMP_9 = CONVERT this to address,TMP_10(uint256) = SOLIDITY_CALL balance(address)(TMP_9),payout(uint256) := TMP_10(uint256),Transfer dest:sender value:payout,REF_4(uint256) -> dates[sender],REF_4(uint256) (->dates) := now(uint256),REF_5(uint256) -> invests[sender],REF_5(-> invests) = REF_5 + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
sender = msg.sender

IRs:
sender(address) := msg.sender(address)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
invests[sender] != 0

IRs:
REF_0(uint256) -> invests[sender]
TMP_0(bool) = REF_0 != 0
CONDITION TMP_0""];
2->3[label=""True""];
2->8[label=""False""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
payout = invests[sender] / 100 * 10 * (now - dates[sender]) / 86400

IRs:
REF_1(uint256) -> invests[sender]
TMP_1(uint256) = REF_1 / 100
TMP_2(uint256) = TMP_1 * 10
REF_2(uint256) -> dates[sender]
TMP_3(uint256) = now - REF_2
TMP_4(uint256) = TMP_2 * TMP_3
TMP_5(uint256) = TMP_4 / 86400
payout(uint256) := TMP_5(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
payout > address(this).balance

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
TMP_8(bool) = payout > TMP_7
CONDITION TMP_8""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
payout = address(this).balance

IRs:
TMP_9 = CONVERT this to address
TMP_10(uint256) = SOLIDITY_CALL balance(address)(TMP_9)
payout(uint256) := TMP_10(uint256)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
sender.transfer(payout)

IRs:
Transfer dest:sender value:payout""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
dates[sender] = now

IRs:
REF_4(uint256) -> dates[sender]
REF_4(uint256) (->dates) := now(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
invests[sender] += msg.value

IRs:
REF_5(uint256) -> invests[sender]
REF_5(-> invests) = REF_5 + msg.value""];
}
",0,1,0,0,sender = msg.sender;invests[sender] != 0;payout = invests[sender] / 100 * 10 * (now - dates[sender]) / 86400;;payout > address(this).balance;payout = address(this).balance;;sender.transfer(payout);dates[sender] = now;invests[sender] += msg.value
./0x18835a9009a2a1a1dc1dce33ba7e417f9cee1154_ext.sol,StandardToken.transfer,45,56,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0xdbcd6bd6ecaa36c8a6c554d70b7f39d6c0fd7ad2_ext.sol,BFBtoken.burnFrom,149,157,"REF_19(uint256) -> balanceOf[_from],TMP_26(bool) = REF_19 >= _value,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_28(bool) = _value <= REF_21,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_26(bool) = REF_19 >= _value
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_28(bool) = _value <= REF_21
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xc3c412b97dc3355f1bd060223e75fb047c869197_ext.sol,HngCoinSale.mintToken,288,293,"REF_65(uint256) -> balanceOf[target],REF_65(-> balanceOf) = REF_65 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_65(uint256) -> balanceOf[target]
REF_65(-> balanceOf) = REF_65 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x0d67440946949fe293b45c52efd8a9b3d51e2522_ext.sol,MultipleArbitrableTransaction.executeRuling,659,679,"REF_208(MultipleArbitrableTransaction.Transaction) -> transactions[_transactionID],transaction(MultipleArbitrableTransaction.Transaction) := REF_208(MultipleArbitrableTransaction.Transaction),TMP_227(bool) = _ruling <= AMOUNT_OF_CHOICES,TMP_228(None) = SOLIDITY_CALL require(bool,string)(TMP_227,Invalid ruling.),TMP_229(bool) = _ruling == SENDER_WINS,CONDITION TMP_229,REF_209(address) -> transaction.sender,REF_211(uint256) -> transaction.senderFee,REF_212(uint256) -> transaction.amount,TMP_230(uint256) = REF_211 + REF_212,TMP_231 = SEND dest:REF_209 value:TMP_230,TMP_232(bool) = _ruling == RECEIVER_WINS,CONDITION TMP_232,REF_213(address) -> transaction.receiver,REF_215(uint256) -> transaction.receiverFee,REF_216(uint256) -> transaction.amount,TMP_233(uint256) = REF_215 + REF_216,TMP_234 = SEND dest:REF_213 value:TMP_233,REF_217(uint256) -> transaction.senderFee,REF_218(uint256) -> transaction.amount,TMP_235(uint256) = REF_217 + REF_218,TMP_236(uint256) = TMP_235 / 2,split_amount(uint256) := TMP_236(uint256),REF_219(address) -> transaction.sender,TMP_237 = SEND dest:REF_219 value:split_amount,REF_221(address) -> transaction.receiver,TMP_238 = SEND dest:REF_221 value:split_amount,REF_223(uint256) -> transaction.amount,REF_223(uint256) (->transaction) := 0(uint256),REF_224(uint256) -> transaction.senderFee,REF_224(uint256) (->transaction) := 0(uint256),REF_225(uint256) -> transaction.receiverFee,REF_225(uint256) (->transaction) := 0(uint256),REF_226(MultipleArbitrableTransaction.Status) -> transaction.status,REF_227(MultipleArbitrableTransaction.Status) -> Status.Resolved,REF_226(MultipleArbitrableTransaction.Status) (->transaction) := REF_227(MultipleArbitrableTransaction.Status)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
transaction = transactions[_transactionID]

IRs:
REF_208(MultipleArbitrableTransaction.Transaction) -> transactions[_transactionID]
transaction(MultipleArbitrableTransaction.Transaction) := REF_208(MultipleArbitrableTransaction.Transaction)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(_ruling <= AMOUNT_OF_CHOICES,Invalid ruling.)

IRs:
TMP_227(bool) = _ruling <= AMOUNT_OF_CHOICES
TMP_228(None) = SOLIDITY_CALL require(bool,string)(TMP_227,Invalid ruling.)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_ruling == SENDER_WINS

IRs:
TMP_229(bool) = _ruling == SENDER_WINS
CONDITION TMP_229""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
transaction.sender.send(transaction.senderFee + transaction.amount)

IRs:
REF_209(address) -> transaction.sender
REF_211(uint256) -> transaction.senderFee
REF_212(uint256) -> transaction.amount
TMP_230(uint256) = REF_211 + REF_212
TMP_231 = SEND dest:REF_209 value:TMP_230""];
4->11;
5[label=""Node Type: IF 5

EXPRESSION:
_ruling == RECEIVER_WINS

IRs:
TMP_232(bool) = _ruling == RECEIVER_WINS
CONDITION TMP_232""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
transaction.receiver.send(transaction.receiverFee + transaction.amount)

IRs:
REF_213(address) -> transaction.receiver
REF_215(uint256) -> transaction.receiverFee
REF_216(uint256) -> transaction.amount
TMP_233(uint256) = REF_215 + REF_216
TMP_234 = SEND dest:REF_213 value:TMP_233""];
6->10;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
split_amount = (transaction.senderFee + transaction.amount) / 2

IRs:
REF_217(uint256) -> transaction.senderFee
REF_218(uint256) -> transaction.amount
TMP_235(uint256) = REF_217 + REF_218
TMP_236(uint256) = TMP_235 / 2
split_amount(uint256) := TMP_236(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
transaction.sender.send(split_amount)

IRs:
REF_219(address) -> transaction.sender
TMP_237 = SEND dest:REF_219 value:split_amount""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
transaction.receiver.send(split_amount)

IRs:
REF_221(address) -> transaction.receiver
TMP_238 = SEND dest:REF_221 value:split_amount""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
transaction.amount = 0

IRs:
REF_223(uint256) -> transaction.amount
REF_223(uint256) (->transaction) := 0(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
transaction.senderFee = 0

IRs:
REF_224(uint256) -> transaction.senderFee
REF_224(uint256) (->transaction) := 0(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
transaction.receiverFee = 0

IRs:
REF_225(uint256) -> transaction.receiverFee
REF_225(uint256) (->transaction) := 0(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
transaction.status = Status.Resolved

IRs:
REF_226(MultipleArbitrableTransaction.Status) -> transaction.status
REF_227(MultipleArbitrableTransaction.Status) -> Status.Resolved
REF_226(MultipleArbitrableTransaction.Status) (->transaction) := REF_227(MultipleArbitrableTransaction.Status)""];
}
",0,1,1,0,"transaction = transactions[_transactionID];require(bool,string)(_ruling <= AMOUNT_OF_CHOICES,Invalid ruling.);_ruling == SENDER_WINS;transaction.sender.send(transaction.senderFee + transaction.amount);_ruling == RECEIVER_WINS;;transaction.receiver.send(transaction.receiverFee + transaction.amount);split_amount = (transaction.senderFee + transaction.amount) / 2;;transaction.sender.send(split_amount);transaction.receiver.send(split_amount);transaction.amount = 0;transaction.senderFee = 0;transaction.receiverFee = 0;transaction.status = Status.Resolved"
./0x36cc5160e243f91157d8c14222f2ed5c52cf3d05_ext.sol,TokenERC20._transfer,47,63,"TMP_3 = CONVERT 0 to address,TMP_4(bool) = _to != TMP_3,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_1(uint256) -> balanceOf[_from],TMP_6(bool) = REF_1 >= _value,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_2(uint256) -> balanceOf[_to],TMP_8(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_9(bool) = TMP_8 >= REF_3,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_11(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_11(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_13(uint256) = REF_8 + REF_9,TMP_14(bool) = TMP_13 == previousBalances,TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0x0))

IRs:
TMP_3 = CONVERT 0 to address
TMP_4(bool) = _to != TMP_3
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_6(bool) = REF_1 >= _value
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_8(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_9(bool) = TMP_8 >= REF_3
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_11(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_11(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_13(uint256) = REF_8 + REF_9
TMP_14(bool) = TMP_13 == previousBalances
TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)""];
}
",0,1,0,0,"require(bool)(_to != address(0x0));require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x78af82f8924f99cec0afef357105382b8a44708f_ext.sol,EraTokens.BurnToken,194,203,"TMP_45(bool) = owner == msg.sender,TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45),REF_28(uint256) -> balances[_from],TMP_47(bool) = REF_28 > 0,TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47),REF_29(uint256) -> balances[_from],_value(uint256) := REF_29(uint256),REF_30(uint256) -> balances[_from],REF_30(-> balances) = REF_30 - _value,_totalSupply(uint256) = _totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(owner == msg.sender)

IRs:
TMP_45(bool) = owner == msg.sender
TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] > 0)

IRs:
REF_28(uint256) -> balances[_from]
TMP_47(bool) = REF_28 > 0
TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
_value = balances[_from]

IRs:
REF_29(uint256) -> balances[_from]
_value(uint256) := REF_29(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] -= _value

IRs:
REF_30(uint256) -> balances[_from]
REF_30(-> balances) = REF_30 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_totalSupply -= _value

IRs:
_totalSupply(uint256) = _totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(owner == msg.sender);require(bool)(balances[_from] > 0);_value = balances[_from];balances[_from] -= _value;_totalSupply -= _value;Burn(_from,_value);true;success"
./0x71fbecb11e291f824fd5dc9e760f56a5239e4702_ext.sol,HodlDAO.fallback,309,316,"amount(uint256) := msg.value(uint256),TMP_60(bool) = amount <= 0,CONDITION TMP_60,REF_43(uint256) -> balanceOf[msg.sender],REF_43(-> balanceOf) = REF_43 + amount,totalSupply(uint256) = totalSupply + amount,Emit Transfer(0,msg.sender,amount),Emit Deposited(msg.sender,amount),MODIFIER_CALL, HodlDAO.notPendingWithdrawal()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
amount = msg.value

IRs:
amount(uint256) := msg.value(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
amount <= 0

IRs:
TMP_60(bool) = amount <= 0
CONDITION TMP_60""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: THROW 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[msg.sender] += amount

IRs:
REF_43(uint256) -> balanceOf[msg.sender]
REF_43(-> balanceOf) = REF_43 + amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
totalSupply += amount

IRs:
totalSupply(uint256) = totalSupply + amount""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(0,msg.sender,amount)

IRs:
Emit Transfer(0,msg.sender,amount)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Deposited(msg.sender,amount)

IRs:
Emit Deposited(msg.sender,amount)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
notPendingWithdrawal()

IRs:
MODIFIER_CALL, HodlDAO.notPendingWithdrawal()()""];
9->1;
}
",0,1,0,0,"notPendingWithdrawal();amount = msg.value;amount <= 0;;;balanceOf[msg.sender] += amount;totalSupply += amount;Transfer(0,msg.sender,amount);Deposited(msg.sender,amount)"
./0x32d55157bd2ae652f4b6be48ee4a7a1686d28a3f_ext.sol,TokenERC20.burnFrom,161,169,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x945f171de4ea81a213dcc7a1e8c4f6feb3b4b806_ext.sol,ECP_Token.burn,220,228,"REF_27(uint256) -> balanceOf[msg.sender],TMP_57(bool) = REF_27 > _value,TMP_58(None) = SOLIDITY_CALL require(bool)(TMP_57),REF_28(uint256) -> balanceOf[msg.sender],REF_28(-> balanceOf) = REF_28 - _value,totalSupply(uint256) = totalSupply - _value,remaining(uint256) = remaining - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] > _value)

IRs:
REF_27(uint256) -> balanceOf[msg.sender]
TMP_57(bool) = REF_27 > _value
TMP_58(None) = SOLIDITY_CALL require(bool)(TMP_57)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_28(uint256) -> balanceOf[msg.sender]
REF_28(-> balanceOf) = REF_28 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
remaining -= _value

IRs:
remaining(uint256) = remaining - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] > _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;remaining -= _value;Burn(msg.sender,_value);true;success"
./0x4027c7262554ba72ccc3e346c6b71794299d3b99_ext.sol,CWT.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xf355164187e533b1969b4de46737c4e8bc9ae7e2_ext.sol,MASToken.burn,128,134,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x41dcc20e5fc42e21087afb0864683101be5a95ff_ext.sol,Farmcoin.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x059accb493f5a47dc97cc0443aeec8a3fd2591c1_ext.sol,TRXT.transfer,28,34,"REF_1(uint256) -> balances[msg.sender],TMP_0(bool) = REF_1 >= _value,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_2(uint256) -> balances[msg.sender],REF_2(-> balances) = REF_2 - _value,REF_3(uint256) -> balances[_to],REF_3(-> balances) = REF_3 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_0(bool) = REF_1 >= _value
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_2(uint256) -> balances[msg.sender]
REF_2(-> balances) = REF_2 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_3(uint256) -> balances[_to]
REF_3(-> balances) = REF_3 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0x28f1135e43e61ebf303c8f1f9beef4f6a00dcb34_ext.sol,XCPlugin.getProposal,539,547,"REF_102(mapping(string => XCPlugin.Proposal)) -> platform.proposals,REF_103(XCPlugin.Proposal) -> REF_102[txid],REF_104(address) -> REF_103.fromAccount,fromAccount(address) := REF_104(address),REF_105(mapping(string => XCPlugin.Proposal)) -> platform.proposals,REF_106(XCPlugin.Proposal) -> REF_105[txid],REF_107(address) -> REF_106.toAccount,toAccount(address) := REF_107(address),REF_108(mapping(string => XCPlugin.Proposal)) -> platform.proposals,REF_109(XCPlugin.Proposal) -> REF_108[txid],REF_110(uint256) -> REF_109.value,value(uint256) := REF_110(uint256),REF_111(mapping(string => XCPlugin.Proposal)) -> platform.proposals,REF_112(XCPlugin.Proposal) -> REF_111[txid],REF_113(address[]) -> REF_112.voters,voters(address[]) = ['REF_113(address[])'],REF_114(mapping(string => XCPlugin.Proposal)) -> platform.proposals,REF_115(XCPlugin.Proposal) -> REF_114[txid],REF_116(bool) -> REF_115.status,status(bool) := REF_116(bool),REF_117(mapping(string => XCPlugin.Proposal)) -> platform.proposals,REF_118(XCPlugin.Proposal) -> REF_117[txid],REF_119(uint256) -> REF_118.weight,weight(uint256) := REF_119(uint256),RETURN status,fromAccount,toAccount,value,voters,weight","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
fromAccount = platform.proposals[txid].fromAccount

IRs:
REF_102(mapping(string => XCPlugin.Proposal)) -> platform.proposals
REF_103(XCPlugin.Proposal) -> REF_102[txid]
REF_104(address) -> REF_103.fromAccount
fromAccount(address) := REF_104(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
toAccount = platform.proposals[txid].toAccount

IRs:
REF_105(mapping(string => XCPlugin.Proposal)) -> platform.proposals
REF_106(XCPlugin.Proposal) -> REF_105[txid]
REF_107(address) -> REF_106.toAccount
toAccount(address) := REF_107(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
value = platform.proposals[txid].value

IRs:
REF_108(mapping(string => XCPlugin.Proposal)) -> platform.proposals
REF_109(XCPlugin.Proposal) -> REF_108[txid]
REF_110(uint256) -> REF_109.value
value(uint256) := REF_110(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
voters = platform.proposals[txid].voters

IRs:
REF_111(mapping(string => XCPlugin.Proposal)) -> platform.proposals
REF_112(XCPlugin.Proposal) -> REF_111[txid]
REF_113(address[]) -> REF_112.voters
voters(address[]) = ['REF_113(address[])']""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
status = platform.proposals[txid].status

IRs:
REF_114(mapping(string => XCPlugin.Proposal)) -> platform.proposals
REF_115(XCPlugin.Proposal) -> REF_114[txid]
REF_116(bool) -> REF_115.status
status(bool) := REF_116(bool)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
weight = platform.proposals[txid].weight

IRs:
REF_117(mapping(string => XCPlugin.Proposal)) -> platform.proposals
REF_118(XCPlugin.Proposal) -> REF_117[txid]
REF_119(uint256) -> REF_118.weight
weight(uint256) := REF_119(uint256)""];
6->7;
7[label=""Node Type: RETURN 7
""];
8[label=""Node Type: RETURN 8

EXPRESSION:
(status,fromAccount,toAccount,value,voters,weight)

IRs:
RETURN status,fromAccount,toAccount,value,voters,weight""];
}
",0,1,0,0,"fromAccount = platform.proposals[txid].fromAccount;toAccount = platform.proposals[txid].toAccount;value = platform.proposals[txid].value;voters = platform.proposals[txid].voters;status = platform.proposals[txid].status;weight = platform.proposals[txid].weight;;(status,fromAccount,toAccount,value,voters,weight)"
./0x519e5585540ac8d5770cfcd8175bbbd2a6430367_ext.sol,Ethereum_Nika_Database_Service.Return_String7,163,165,"REF_99(mapping(uint256 => Ethereum_Nika_Database_Service.VariableAmounts)) -> data[msg.sender],REF_100(Ethereum_Nika_Database_Service.Ticker) -> personaldata[msg.sender],REF_101(uint256) -> REF_100.current_slot,REF_102(Ethereum_Nika_Database_Service.VariableAmounts) -> REF_99[REF_101],REF_103(string) -> REF_102.string7,RETURN REF_103","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
data[msg.sender][personaldata[msg.sender].current_slot].string7

IRs:
REF_99(mapping(uint256 => Ethereum_Nika_Database_Service.VariableAmounts)) -> data[msg.sender]
REF_100(Ethereum_Nika_Database_Service.Ticker) -> personaldata[msg.sender]
REF_101(uint256) -> REF_100.current_slot
REF_102(Ethereum_Nika_Database_Service.VariableAmounts) -> REF_99[REF_101]
REF_103(string) -> REF_102.string7
RETURN REF_103""];
}
",0,1,0,0,data[msg.sender][personaldata[msg.sender].current_slot].string7
./0x2612bb62eaa42991d12be0892c27040d4143e037_ext.sol,ToknTalkToken.transferFrom,30,44,"TMP_9 = CONVERT this to address,TMP_10(bool) = to != TMP_9,TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10),TMP_12(bool) = to != 0,TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12),REF_3(mapping(address => uint256)) -> allowance[from],REF_4(uint256) -> REF_3[msg.sender],allowanceMsgSender(uint256) := REF_4(uint256),TMP_14(bool) = allowanceMsgSender >= amount,TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14),TMP_16(bool) = allowanceMsgSender != MAX_UINT,CONDITION TMP_16,REF_5(mapping(address => uint256)) -> allowance[from],REF_6(uint256) -> REF_5[msg.sender],TMP_17(uint256) = allowanceMsgSender - amount,REF_6(uint256) (->allowance) := TMP_17(uint256),REF_7(uint256) -> balanceOf[from],balanceOfFrom(uint256) := REF_7(uint256),TMP_18(bool) = balanceOfFrom >= amount,TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18),REF_8(uint256) -> balanceOf[from],TMP_20(uint256) = balanceOfFrom - amount,REF_8(uint256) (->balanceOf) := TMP_20(uint256),REF_9(uint256) -> balanceOf[to],REF_9(-> balanceOf) = REF_9 + amount,Emit Transfer(from,to,amount),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(to != address(this))

IRs:
TMP_9 = CONVERT this to address
TMP_10(bool) = to != TMP_9
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(to != 0)

IRs:
TMP_12(bool) = to != 0
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
allowanceMsgSender = allowance[from][msg.sender]

IRs:
REF_3(mapping(address => uint256)) -> allowance[from]
REF_4(uint256) -> REF_3[msg.sender]
allowanceMsgSender(uint256) := REF_4(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(allowanceMsgSender >= amount)

IRs:
TMP_14(bool) = allowanceMsgSender >= amount
TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
allowanceMsgSender != MAX_UINT

IRs:
TMP_16(bool) = allowanceMsgSender != MAX_UINT
CONDITION TMP_16""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allowance[from][msg.sender] = allowanceMsgSender - amount

IRs:
REF_5(mapping(address => uint256)) -> allowance[from]
REF_6(uint256) -> REF_5[msg.sender]
TMP_17(uint256) = allowanceMsgSender - amount
REF_6(uint256) (->allowance) := TMP_17(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
balanceOfFrom = balanceOf[from]

IRs:
REF_7(uint256) -> balanceOf[from]
balanceOfFrom(uint256) := REF_7(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(balanceOfFrom >= amount)

IRs:
TMP_18(bool) = balanceOfFrom >= amount
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
balanceOf[from] = balanceOfFrom - amount

IRs:
REF_8(uint256) -> balanceOf[from]
TMP_20(uint256) = balanceOfFrom - amount
REF_8(uint256) (->balanceOf) := TMP_20(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
balanceOf[to] += amount

IRs:
REF_9(uint256) -> balanceOf[to]
REF_9(-> balanceOf) = REF_9 + amount""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
Transfer(from,to,amount)

IRs:
Emit Transfer(from,to,amount)""];
12->13;
13[label=""Node Type: RETURN 13

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(to != address(this));require(bool)(to != 0);allowanceMsgSender = allowance[from][msg.sender];require(bool)(allowanceMsgSender >= amount);allowanceMsgSender != MAX_UINT;allowance[from][msg.sender] = allowanceMsgSender - amount;;balanceOfFrom = balanceOf[from];require(bool)(balanceOfFrom >= amount);balanceOf[from] = balanceOfFrom - amount;balanceOf[to] += amount;Transfer(from,to,amount);true"
./0xd86dc5e1574491b3c4b68a30f0084d630a9ecc94_ext.sol,Token.burn,121,127,"REF_17(uint256) -> balanceOf[msg.sender],TMP_23(bool) = REF_17 >= _value,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_23(bool) = REF_17 >= _value
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x400c73395bbc01d9e757f02f267925e1de0779f8_ext.sol,TokenDrop.multiTransfer,34,40,"i(uint256) := 0(uint256),REF_0 -> LENGTH _to,TMP_1(bool) = i < REF_0,CONDITION TMP_1,REF_2(address) -> _to[i],TMP_2(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['REF_2', '_value']  ,TMP_3(uint256) := i(uint256),i(uint256) = i + 1,RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
2->7;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _to.length

IRs:
REF_0 -> LENGTH _to
TMP_1(bool) = i < REF_0
CONDITION TMP_1""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
token.transfer(_to[i],_value)

IRs:
REF_2(address) -> _to[i]
TMP_2(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['REF_2', '_value']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_3(uint256) := i(uint256)
i(uint256) = i + 1""];
6->4;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"i = 0;;i < _to.length;;true;token.transfer(_to[i],_value);i ++"
./0x31a6ba952064f3895e29a5a7f0731287368ab89e_ext.sol,NutrioCoin.burnTotalSupply,61,64,"totalSupply(uint256) = totalSupply - _amount,MODIFIER_CALL, NutrioCoin.isOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
totalSupply -= _amount

IRs:
totalSupply(uint256) = totalSupply - _amount""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isOwner()

IRs:
MODIFIER_CALL, NutrioCoin.isOwner()()""];
2->1;
}
",0,1,0,0,isOwner();totalSupply -= _amount
./0x31d4c5be1082a88f2abafea549b6c189c2cf057f_ext.sol,ClockAuctionBase._computeCurrentPrice,890,925,"TMP_487(bool) = _secondsPassed >= _duration,CONDITION TMP_487,RETURN _endingPrice,TMP_488 = CONVERT _endingPrice to int256,TMP_489 = CONVERT _startingPrice to int256,TMP_490(int256) = TMP_488 - TMP_489,totalPriceChange(int256) := TMP_490(int256),TMP_491 = CONVERT _secondsPassed to int256,TMP_492(int256) = totalPriceChange * TMP_491,TMP_493 = CONVERT _duration to int256,TMP_494(int256) = TMP_492 / TMP_493,currentPriceChange(int256) := TMP_494(int256),TMP_495 = CONVERT _startingPrice to int256,TMP_496(int256) = TMP_495 + currentPriceChange,currentPrice(int256) := TMP_496(int256),TMP_497 = CONVERT currentPrice to uint256,RETURN TMP_497","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_secondsPassed >= _duration

IRs:
TMP_487(bool) = _secondsPassed >= _duration
CONDITION TMP_487""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
_endingPrice

IRs:
RETURN _endingPrice""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
totalPriceChange = int256(_endingPrice) - int256(_startingPrice)

IRs:
TMP_488 = CONVERT _endingPrice to int256
TMP_489 = CONVERT _startingPrice to int256
TMP_490(int256) = TMP_488 - TMP_489
totalPriceChange(int256) := TMP_490(int256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration)

IRs:
TMP_491 = CONVERT _secondsPassed to int256
TMP_492(int256) = totalPriceChange * TMP_491
TMP_493 = CONVERT _duration to int256
TMP_494(int256) = TMP_492 / TMP_493
currentPriceChange(int256) := TMP_494(int256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
currentPrice = int256(_startingPrice) + currentPriceChange

IRs:
TMP_495 = CONVERT _startingPrice to int256
TMP_496(int256) = TMP_495 + currentPriceChange
currentPrice(int256) := TMP_496(int256)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
uint256(currentPrice)

IRs:
TMP_497 = CONVERT currentPrice to uint256
RETURN TMP_497""];
}
",0,1,0,0,_secondsPassed >= _duration;_endingPrice;totalPriceChange = int256(_endingPrice) - int256(_startingPrice);currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);currentPrice = int256(_startingPrice) + currentPriceChange;uint256(currentPrice)
./0x1ba2626b5753b7a6cfe785ed9e28fb1c85793fa6_ext.sol,SLUTZToken.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xcd6cb1b25006603382b9e9a832b8686ae240373b_ext.sol,EtheramaCore.getBlockNumSinceInit,274,276,"TMP_78(uint256) = INTERNAL_CALL, EtheramaCore.getInitBlockNum()(),TMP_79(uint256) = block.number - TMP_78,RETURN TMP_79","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
block.number - getInitBlockNum()

IRs:
TMP_78(uint256) = INTERNAL_CALL, EtheramaCore.getInitBlockNum()()
TMP_79(uint256) = block.number - TMP_78
RETURN TMP_79""];
}
",0,1,0,0,block.number - getInitBlockNum()
./0x261bb5e1c53248860f4bc405abaae3e0bfc12874_ext.sol,LockBalance.lockTypeInfoGroup,328,331,"TMP_166 = CONVERT _type to uint256,key(uint256) := TMP_166(uint256),REF_175(LockBalance.sGroupLockDate) -> groupLockDate[key],REF_176(uint256[]) -> REF_175.lockTime,REF_177(LockBalance.sGroupLockDate) -> groupLockDate[key],REF_178(uint256[]) -> REF_177.lockPercent,RETURN REF_176,REF_178","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
key = uint256(_type)

IRs:
TMP_166 = CONVERT _type to uint256
key(uint256) := TMP_166(uint256)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
(groupLockDate[key].lockTime,groupLockDate[key].lockPercent)

IRs:
REF_175(LockBalance.sGroupLockDate) -> groupLockDate[key]
REF_176(uint256[]) -> REF_175.lockTime
REF_177(LockBalance.sGroupLockDate) -> groupLockDate[key]
REF_178(uint256[]) -> REF_177.lockPercent
RETURN REF_176,REF_178""];
}
",0,1,0,0,"key = uint256(_type);(groupLockDate[key].lockTime,groupLockDate[key].lockPercent)"
./0x74a31dc20802cb1e41201af055ce7dfcd31d291d_ext.sol,m10fanclub.approveAndCall,196,201,"REF_18(mapping(address => uint256)) -> allowed[msg.sender],REF_19(uint256) -> REF_18[spender],REF_19(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_18(mapping(address => uint256)) -> allowed[msg.sender]
REF_19(uint256) -> REF_18[spender]
REF_19(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x17d0582dee50a5401bb8f65ac29ec2da50c670ea_ext.sol,Slot.distribute,246,285,"TMP_125(bool) = owner == msg.sender,isPartner(bool) := TMP_125(bool),totalShare(uint256) := 0(uint256),i(uint256) := 0(uint256),REF_66 -> LENGTH partners,TMP_126(bool) = i < REF_66,CONDITION TMP_126,REF_67(Slot.PartnerShare) -> partners[i],REF_68(address) -> REF_67.from,TMP_127(bool) = REF_68 == msg.sender,CONDITION TMP_127,isPartner(bool) := True(bool),REF_69(Slot.PartnerShare) -> partners[i],REF_70(uint256) -> REF_69.share,totalShare(uint256) = totalShare + REF_70,TMP_128(uint256) := i(uint256),i(uint256) = i + 1,TMP_129(None) = SOLIDITY_CALL require(bool,string)(isPartner,Only partner can distrubute bonus.),TMP_130(uint256) = INTERNAL_CALL, Slot.getBonus()(),bonus(uint256) := TMP_130(uint256),TMP_131(bool) = totalShare > 0,CONDITION TMP_131,TMP_132(uint256) = bonus / 10,TMP_133(uint256) = TMP_132 * 6,TMP_134(uint256) = TMP_133 / totalShare,price(uint256) := TMP_134(uint256),TMP_135(bool) = price > 0,CONDITION TMP_135,j(uint256) := 0(uint256),REF_71 -> LENGTH partners,TMP_136(bool) = j < REF_71,CONDITION TMP_136,REF_72(Slot.PartnerShare) -> partners[j],REF_73(uint256) -> REF_72.share,TMP_137(uint256) = REF_73 * price,share(uint256) := TMP_137(uint256),REF_74(Slot.PartnerShare) -> partners[j],REF_75(address) -> REF_74.from,Transfer dest:REF_75 value:share,REF_77(Slot.PartnerShare) -> partners[j],REF_78(address) -> REF_77.from,TMP_139(bool) = REF_78 == msg.sender,CONDITION TMP_139,result(uint256) = result + share,TMP_140(uint256) := j(uint256),j(uint256) = j + 1,TMP_141(uint256) = 2 * 1000000000000000,TMP_142(bool) = price > TMP_141,CONDITION TMP_142,partners = delete partners ,TMP_143(uint256) = bonus / 10,TMP_144(uint256) = TMP_143 * 4,ownerShare(uint256) := TMP_144(uint256),Transfer dest:owner value:ownerShare,TMP_146(bool) = owner == msg.sender,CONDITION TMP_146,result(uint256) = result + ownerShare,RETURN result","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
isPartner = (owner == msg.sender)

IRs:
TMP_125(bool) = owner == msg.sender
isPartner(bool) := TMP_125(bool)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
totalShare = 0

IRs:
totalShare(uint256) := 0(uint256)""];
2->5;
3[label=""Node Type: BEGIN_LOOP 3
""];
3->6;
4[label=""Node Type: END_LOOP 4
""];
4->12;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
5->3;
6[label=""Node Type: IF_LOOP 6

EXPRESSION:
i < partners.length

IRs:
REF_66 -> LENGTH partners
TMP_126(bool) = i < REF_66
CONDITION TMP_126""];
6->7[label=""True""];
6->4[label=""False""];
7[label=""Node Type: IF 7

EXPRESSION:
partners[i].from == msg.sender

IRs:
REF_67(Slot.PartnerShare) -> partners[i]
REF_68(address) -> REF_67.from
TMP_127(bool) = REF_68 == msg.sender
CONDITION TMP_127""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
isPartner = true

IRs:
isPartner(bool) := True(bool)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
totalShare += partners[i].share

IRs:
REF_69(Slot.PartnerShare) -> partners[i]
REF_70(uint256) -> REF_69.share
totalShare(uint256) = totalShare + REF_70""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_128(uint256) := i(uint256)
i(uint256) = i + 1""];
11->6;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
require(bool,string)(isPartner,Only partner can distrubute bonus.)

IRs:
TMP_129(None) = SOLIDITY_CALL require(bool,string)(isPartner,Only partner can distrubute bonus.)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
bonus = getBonus()

IRs:
TMP_130(uint256) = INTERNAL_CALL, Slot.getBonus()()
bonus(uint256) := TMP_130(uint256)""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
totalShare > 0

IRs:
TMP_131(bool) = totalShare > 0
CONDITION TMP_131""];
14->15[label=""True""];
14->31[label=""False""];
15[label=""Node Type: NEW VARIABLE 15

EXPRESSION:
price = ((bonus / 10) * 6) / totalShare

IRs:
TMP_132(uint256) = bonus / 10
TMP_133(uint256) = TMP_132 * 6
TMP_134(uint256) = TMP_133 / totalShare
price(uint256) := TMP_134(uint256)""];
15->16;
16[label=""Node Type: IF 16

EXPRESSION:
price > 0

IRs:
TMP_135(bool) = price > 0
CONDITION TMP_135""];
16->19[label=""True""];
16->27[label=""False""];
17[label=""Node Type: BEGIN_LOOP 17
""];
17->20;
18[label=""Node Type: END_LOOP 18
""];
18->27;
19[label=""Node Type: NEW VARIABLE 19

EXPRESSION:
j = 0

IRs:
j(uint256) := 0(uint256)""];
19->17;
20[label=""Node Type: IF_LOOP 20

EXPRESSION:
j < partners.length

IRs:
REF_71 -> LENGTH partners
TMP_136(bool) = j < REF_71
CONDITION TMP_136""];
20->21[label=""True""];
20->18[label=""False""];
21[label=""Node Type: NEW VARIABLE 21

EXPRESSION:
share = partners[j].share * price

IRs:
REF_72(Slot.PartnerShare) -> partners[j]
REF_73(uint256) -> REF_72.share
TMP_137(uint256) = REF_73 * price
share(uint256) := TMP_137(uint256)""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
partners[j].from.transfer(share)

IRs:
REF_74(Slot.PartnerShare) -> partners[j]
REF_75(address) -> REF_74.from
Transfer dest:REF_75 value:share""];
22->23;
23[label=""Node Type: IF 23

EXPRESSION:
partners[j].from == msg.sender

IRs:
REF_77(Slot.PartnerShare) -> partners[j]
REF_78(address) -> REF_77.from
TMP_139(bool) = REF_78 == msg.sender
CONDITION TMP_139""];
23->24[label=""True""];
23->25[label=""False""];
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
result += share

IRs:
result(uint256) = result + share""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->26;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
j ++

IRs:
TMP_140(uint256) := j(uint256)
j(uint256) = j + 1""];
26->20;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: IF 28

EXPRESSION:
price > 2 * 1000000000000000

IRs:
TMP_141(uint256) = 2 * 1000000000000000
TMP_142(bool) = price > TMP_141
CONDITION TMP_142""];
28->29[label=""True""];
28->30[label=""False""];
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
delete partners

IRs:
partners = delete partners ""];
29->30;
30[label=""Node Type: END_IF 30
""];
30->31;
31[label=""Node Type: END_IF 31
""];
31->32;
32[label=""Node Type: NEW VARIABLE 32

EXPRESSION:
ownerShare = (bonus / 10) * 4

IRs:
TMP_143(uint256) = bonus / 10
TMP_144(uint256) = TMP_143 * 4
ownerShare(uint256) := TMP_144(uint256)""];
32->33;
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
owner.transfer(ownerShare)

IRs:
Transfer dest:owner value:ownerShare""];
33->34;
34[label=""Node Type: IF 34

EXPRESSION:
owner == msg.sender

IRs:
TMP_146(bool) = owner == msg.sender
CONDITION TMP_146""];
34->35[label=""True""];
34->36[label=""False""];
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
result += ownerShare

IRs:
result(uint256) = result + ownerShare""];
35->36;
36[label=""Node Type: END_IF 36
""];
36->37;
37[label=""Node Type: RETURN 37

EXPRESSION:
result

IRs:
RETURN result""];
}
",0,1,0,0,"isPartner = (owner == msg.sender);totalShare = 0;i = 0;;i < partners.length;;require(bool,string)(isPartner,Only partner can distrubute bonus.);partners[i].from == msg.sender;isPartner = true;;totalShare += partners[i].share;i ++;bonus = getBonus();totalShare > 0;price = ((bonus / 10) * 6) / totalShare;;price > 0;j = 0;;;j < partners.length;;share = partners[j].share * price;partners[j].from.transfer(share);partners[j].from == msg.sender;result += share;;j ++;price > 2 * 1000000000000000;delete partners;;ownerShare = (bonus / 10) * 4;owner.transfer(ownerShare);owner == msg.sender;result += ownerShare;;result"
./0x00416b9d728069edb0ceb04bc2b203fa7336d1f1_ext.sol,SeedCrowdsaleContract.processTransaction,211,239,"TMP_59(uint256) = INTERNAL_CALL, SeedCrowdsaleContract.calculateMaxContribution(address)(_contributor),maxContribution(uint256) := TMP_59(uint256),contributionAmount(uint256) := _amount(uint256),returnAmount(uint256) := 0(uint256),TMP_60(bool) = maxContribution < _amount,CONDITION TMP_60,contributionAmount(uint256) := maxContribution(uint256),TMP_61(uint256) = _amount - maxContribution,returnAmount(uint256) := TMP_61(uint256),TMP_62(uint256) = ethRaised + contributionAmount,TMP_63(bool) = TMP_62 >= minCap,TMP_64(bool) = minCap > ethRaised,TMP_65(bool) = TMP_63 && TMP_64,CONDITION TMP_65,Emit MinCapReached(block.timestamp),REF_18(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor],REF_19(uint256) -> REF_18.contributionAmount,TMP_67(bool) = REF_19 == 0,CONDITION TMP_67,REF_20(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor],REF_21(uint256) -> REF_20.contributionAmount,REF_21(uint256) (->contributorList) := contributionAmount(uint256),REF_22(address) -> contributorIndexes[nextContributorIndex],REF_22(address) (->contributorIndexes) := _contributor(address),TMP_68(uint256) := nextContributorIndex(uint256),nextContributorIndex(uint256) = nextContributorIndex + 1,REF_23(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor],REF_24(uint256) -> REF_23.contributionAmount,REF_24(-> contributorList) = REF_24 + contributionAmount,ethRaised(uint256) = ethRaised + contributionAmount,Emit ContributionMade(msg.sender,contributionAmount),TMP_70(bool) = returnAmount != 0,CONDITION TMP_70,Transfer dest:_contributor value:returnAmount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
maxContribution = calculateMaxContribution(_contributor)

IRs:
TMP_59(uint256) = INTERNAL_CALL, SeedCrowdsaleContract.calculateMaxContribution(address)(_contributor)
maxContribution(uint256) := TMP_59(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
contributionAmount = _amount

IRs:
contributionAmount(uint256) := _amount(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
returnAmount = 0

IRs:
returnAmount(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
maxContribution < _amount

IRs:
TMP_60(bool) = maxContribution < _amount
CONDITION TMP_60""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
contributionAmount = maxContribution

IRs:
contributionAmount(uint256) := maxContribution(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
returnAmount = _amount - maxContribution

IRs:
TMP_61(uint256) = _amount - maxContribution
returnAmount(uint256) := TMP_61(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
ethRaised + contributionAmount >= minCap && minCap > ethRaised

IRs:
TMP_62(uint256) = ethRaised + contributionAmount
TMP_63(bool) = TMP_62 >= minCap
TMP_64(bool) = minCap > ethRaised
TMP_65(bool) = TMP_63 && TMP_64
CONDITION TMP_65""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
MinCapReached(block.timestamp)

IRs:
Emit MinCapReached(block.timestamp)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
contributorList[_contributor].contributionAmount == 0

IRs:
REF_18(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor]
REF_19(uint256) -> REF_18.contributionAmount
TMP_67(bool) = REF_19 == 0
CONDITION TMP_67""];
11->12[label=""True""];
11->15[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
contributorList[_contributor].contributionAmount = contributionAmount

IRs:
REF_20(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor]
REF_21(uint256) -> REF_20.contributionAmount
REF_21(uint256) (->contributorList) := contributionAmount(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
contributorIndexes[nextContributorIndex] = _contributor

IRs:
REF_22(address) -> contributorIndexes[nextContributorIndex]
REF_22(address) (->contributorIndexes) := _contributor(address)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
nextContributorIndex ++

IRs:
TMP_68(uint256) := nextContributorIndex(uint256)
nextContributorIndex(uint256) = nextContributorIndex + 1""];
14->16;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
contributorList[_contributor].contributionAmount += contributionAmount

IRs:
REF_23(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor]
REF_24(uint256) -> REF_23.contributionAmount
REF_24(-> contributorList) = REF_24 + contributionAmount""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
ethRaised += contributionAmount

IRs:
ethRaised(uint256) = ethRaised + contributionAmount""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
ContributionMade(msg.sender,contributionAmount)

IRs:
Emit ContributionMade(msg.sender,contributionAmount)""];
18->19;
19[label=""Node Type: IF 19

EXPRESSION:
returnAmount != 0

IRs:
TMP_70(bool) = returnAmount != 0
CONDITION TMP_70""];
19->20[label=""True""];
19->21[label=""False""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
_contributor.transfer(returnAmount)

IRs:
Transfer dest:_contributor value:returnAmount""];
20->21;
21[label=""Node Type: END_IF 21
""];
}
",0,1,1,0,"maxContribution = calculateMaxContribution(_contributor);contributionAmount = _amount;returnAmount = 0;maxContribution < _amount;contributionAmount = maxContribution;;returnAmount = _amount - maxContribution;ethRaised + contributionAmount >= minCap && minCap > ethRaised;MinCapReached(block.timestamp);;contributorList[_contributor].contributionAmount == 0;contributorList[_contributor].contributionAmount = contributionAmount;contributorList[_contributor].contributionAmount += contributionAmount;contributorIndexes[nextContributorIndex] = _contributor;nextContributorIndex ++;;ethRaised += contributionAmount;ContributionMade(msg.sender,contributionAmount);returnAmount != 0;_contributor.transfer(returnAmount);"
./0x37d82a4e03e93529c1a32429984e12e7875ea1d8_ext.sol,OMGCatCoin.approveAndCall,180,185,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_58 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_58(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_58 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_58(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x33b44a1d150f3feaa40503ad20a75634adc39b18_ext.sol,TimeCapsule.deposit,22,26,"TMP_3(bool) = msg.value >= 500000000000000000,CONDITION TMP_3,REF_0(uint256) -> deposits[msg.sender],REF_0(-> deposits) = REF_0 + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value >= 500000000000000000

IRs:
TMP_3(bool) = msg.value >= 500000000000000000
CONDITION TMP_3""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
deposits[msg.sender] += msg.value

IRs:
REF_0(uint256) -> deposits[msg.sender]
REF_0(-> deposits) = REF_0 + msg.value""];
2->4;
3[label=""Node Type: THROW 3
""];
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,msg.value >= 500000000000000000;deposits[msg.sender] += msg.value;;
./0x0094110c81183740c23d561818500ce0c8222d8b_ext.sol,Bitscreen.calculateCurrDynamicPrice,145,161,"REF_29(uint256) -> screenstate.PriceDecreasePeriodLengthSecs,periodLengthSecs(uint256) := REF_29(uint256),REF_30(uint256) -> screenstate.currTopBidTimeStamp,TMP_21(uint256) = now - REF_30,TMP_22(uint256) = TMP_21 / periodLengthSecs,ellapsedPeriodsSinceLastBid(uint256) := TMP_22(uint256),REF_31(uint256) -> screenstate.currTopBid,REF_32(uint256) -> screenstate.periodPercentagePriceDecrease,TMP_23(uint256) = REF_31 * REF_32,TMP_24(uint256) = TMP_23 * ellapsedPeriodsSinceLastBid,TMP_25(uint256) = TMP_24 / 100,totalDecrease(uint256) := TMP_25(uint256),REF_33(uint256) -> screenstate.currTopBid,TMP_26(bool) = totalDecrease > REF_33,CONDITION TMP_26,currDynamicPrice(uint256) := 0(uint256),REF_34(uint256) -> screenstate.currTopBid,TMP_27(uint256) = REF_34 - totalDecrease,currDynamicPrice(uint256) := TMP_27(uint256),RETURN currDynamicPrice","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
periodLengthSecs = screenstate.PriceDecreasePeriodLengthSecs

IRs:
REF_29(uint256) -> screenstate.PriceDecreasePeriodLengthSecs
periodLengthSecs(uint256) := REF_29(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
ellapsedPeriodsSinceLastBid = (now - screenstate.currTopBidTimeStamp) / periodLengthSecs

IRs:
REF_30(uint256) -> screenstate.currTopBidTimeStamp
TMP_21(uint256) = now - REF_30
TMP_22(uint256) = TMP_21 / periodLengthSecs
ellapsedPeriodsSinceLastBid(uint256) := TMP_22(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
totalDecrease = ((screenstate.currTopBid * screenstate.periodPercentagePriceDecrease * ellapsedPeriodsSinceLastBid) / 100)

IRs:
REF_31(uint256) -> screenstate.currTopBid
REF_32(uint256) -> screenstate.periodPercentagePriceDecrease
TMP_23(uint256) = REF_31 * REF_32
TMP_24(uint256) = TMP_23 * ellapsedPeriodsSinceLastBid
TMP_25(uint256) = TMP_24 / 100
totalDecrease(uint256) := TMP_25(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
totalDecrease > screenstate.currTopBid

IRs:
REF_33(uint256) -> screenstate.currTopBid
TMP_26(bool) = totalDecrease > REF_33
CONDITION TMP_26""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
currDynamicPrice = 0

IRs:
currDynamicPrice(uint256) := 0(uint256)""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
currDynamicPrice = screenstate.currTopBid - totalDecrease

IRs:
REF_34(uint256) -> screenstate.currTopBid
TMP_27(uint256) = REF_34 - totalDecrease
currDynamicPrice(uint256) := TMP_27(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
currDynamicPrice

IRs:
RETURN currDynamicPrice""];
}
",0,1,0,0,;periodLengthSecs = screenstate.PriceDecreasePeriodLengthSecs;ellapsedPeriodsSinceLastBid = (now - screenstate.currTopBidTimeStamp) / periodLengthSecs;totalDecrease = ((screenstate.currTopBid * screenstate.periodPercentagePriceDecrease * ellapsedPeriodsSinceLastBid) / 100);totalDecrease > screenstate.currTopBid;currDynamicPrice = 0;currDynamicPrice = screenstate.currTopBid - totalDecrease;;currDynamicPrice
./0xdc448e8a2a92a5ce799b197e982d773c605318a4_ext.sol,YESToken.mintToken,163,168,"REF_104(uint256) -> balanceOf[target],REF_104(-> balanceOf) = REF_104 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_104(uint256) -> balanceOf[target]
REF_104(-> balanceOf) = REF_104 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0xcfca01488643501cab56d1855921c897d5ee4b1b_ext.sol,BitcoinInw.totalSupply,95,97,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x1f9033b3fdf74e1d7619447bc491d73a36967d71_ext.sol,MintableToken.mint,178,184,"totalSupply(uint256) = totalSupply + _amount,REF_50(uint256) -> balances[_to],REF_50(-> balances) = REF_50 + _amount,Emit Mint(_to,_amount),TMP_57 = CONVERT 0 to address,Emit Transfer(TMP_57,_to,_amount),RETURN True,MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, MintableToken.canMint()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
totalSupply += _amount

IRs:
totalSupply(uint256) = totalSupply + _amount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _amount

IRs:
REF_50(uint256) -> balances[_to]
REF_50(-> balances) = REF_50 + _amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Mint(_to,_amount)

IRs:
Emit Mint(_to,_amount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(address(0),_to,_amount)

IRs:
TMP_57 = CONVERT 0 to address
Emit Transfer(TMP_57,_to,_amount)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()""];
7->1;
}
",0,1,0,0,"onlyOwner();totalSupply += _amount;balances[_to] += _amount;Mint(_to,_amount);Transfer(address(0),_to,_amount);true;canMint()"
./0xd54920cedf704b87342fa26d5773efabf9037a77_ext.sol,CryptoStars.buyStar,238,277,"REF_69(CryptoStars.Offer) -> starsOfferedForSale[starIndex],offer(CryptoStars.Offer) := REF_69(CryptoStars.Offer),REF_70(bool) -> offer.isForSale,TMP_53 = UnaryType.BANG REF_70 ,CONDITION TMP_53,REF_71(address) -> offer.onlySellTo,TMP_54(bool) = REF_71 != 0,REF_72(address) -> offer.onlySellTo,TMP_55(bool) = REF_72 != msg.sender,TMP_56(bool) = TMP_54 && TMP_55,CONDITION TMP_56,REF_73(uint256) -> offer.minValue,TMP_57(bool) = msg.value < REF_73,CONDITION TMP_57,REF_74(address) -> offer.seller,REF_75(address) -> starIndexToAddress[starIndex],TMP_58(bool) = REF_74 != REF_75,CONDITION TMP_58,REF_76(address) -> offer.seller,seller(address) := REF_76(address),REF_77(uint256) -> balanceOf[seller],TMP_59(uint256) := REF_77(uint256),REF_77(-> balanceOf) = REF_77 - 1,REF_78(uint256) -> balanceOf[msg.sender],TMP_60(uint256) := REF_78(uint256),REF_78(-> balanceOf) = REF_78 + 1,REF_79(string) -> starIndexToSTRZName[starIndex],REF_80(string) -> starIndexToSTRZMasterName[starIndex],Emit Assign(msg.sender,starIndex,REF_79,REF_80),Emit Transfer(seller,msg.sender,1),TMP_63(uint256) = msg.value * 97,TMP_64(uint256) = TMP_63 / 100,amountseller(uint256) := TMP_64(uint256),TMP_65(uint256) = msg.value * 3,TMP_66(uint256) = TMP_65 / 100,amountowner(uint256) := TMP_66(uint256),REF_81(uint256) -> pendingWithdrawals[owner],REF_81(-> pendingWithdrawals) = REF_81 + amountowner,REF_82(uint256) -> pendingWithdrawals[seller],REF_82(-> pendingWithdrawals) = REF_82 + amountseller,REF_83(address) -> starIndexToAddress[starIndex],REF_83(address) (->starIndexToAddress) := msg.sender(address),INTERNAL_CALL, CryptoStars.starNoLongerForSale(uint256)(starIndex),REF_84(string) -> starIndexToSTRZName[starIndex],STRZName(string) := REF_84(string),REF_85(string) -> starIndexToSTRZMasterName[starIndex],STRZMasterName(string) := REF_85(string),REF_86(address) -> offer.seller,Emit StarBought(starIndex,msg.value,REF_86,msg.sender,STRZName,STRZMasterName,MinStarIndexAvailable,MaxStarIndexAvailable),REF_87(CryptoStars.Bid) -> starBids[starIndex],bid(CryptoStars.Bid) := REF_87(CryptoStars.Bid),REF_88(address) -> bid.bidder,TMP_69(bool) = REF_88 == msg.sender,CONDITION TMP_69,REF_89(uint256) -> pendingWithdrawals[msg.sender],REF_90(uint256) -> bid.value,REF_89(-> pendingWithdrawals) = REF_89 + REF_90,REF_91(CryptoStars.Bid) -> starBids[starIndex],TMP_70(CryptoStars.Bid) = new Bid(False,starIndex,0,0),REF_91(CryptoStars.Bid) (->starBids) := TMP_70(CryptoStars.Bid),REF_92(uint256) -> bid.value,Emit StarBidWithdrawn(starIndex,REF_92,msg.sender)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
offer = starsOfferedForSale[starIndex]

IRs:
REF_69(CryptoStars.Offer) -> starsOfferedForSale[starIndex]
offer(CryptoStars.Offer) := REF_69(CryptoStars.Offer)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
! offer.isForSale

IRs:
REF_70(bool) -> offer.isForSale
TMP_53 = UnaryType.BANG REF_70 
CONDITION TMP_53""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: THROW 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
offer.onlySellTo != 0x0 && offer.onlySellTo != msg.sender

IRs:
REF_71(address) -> offer.onlySellTo
TMP_54(bool) = REF_71 != 0
REF_72(address) -> offer.onlySellTo
TMP_55(bool) = REF_72 != msg.sender
TMP_56(bool) = TMP_54 && TMP_55
CONDITION TMP_56""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: THROW 6
""];
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
msg.value < offer.minValue

IRs:
REF_73(uint256) -> offer.minValue
TMP_57(bool) = msg.value < REF_73
CONDITION TMP_57""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: THROW 9
""];
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
offer.seller != starIndexToAddress[starIndex]

IRs:
REF_74(address) -> offer.seller
REF_75(address) -> starIndexToAddress[starIndex]
TMP_58(bool) = REF_74 != REF_75
CONDITION TMP_58""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: THROW 12
""];
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: NEW VARIABLE 14

EXPRESSION:
seller = offer.seller

IRs:
REF_76(address) -> offer.seller
seller(address) := REF_76(address)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
balanceOf[seller] --

IRs:
REF_77(uint256) -> balanceOf[seller]
TMP_59(uint256) := REF_77(uint256)
REF_77(-> balanceOf) = REF_77 - 1""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
balanceOf[msg.sender] ++

IRs:
REF_78(uint256) -> balanceOf[msg.sender]
TMP_60(uint256) := REF_78(uint256)
REF_78(-> balanceOf) = REF_78 + 1""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
Assign(msg.sender,starIndex,starIndexToSTRZName[starIndex],starIndexToSTRZMasterName[starIndex])

IRs:
REF_79(string) -> starIndexToSTRZName[starIndex]
REF_80(string) -> starIndexToSTRZMasterName[starIndex]
Emit Assign(msg.sender,starIndex,REF_79,REF_80)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
Transfer(seller,msg.sender,1)

IRs:
Emit Transfer(seller,msg.sender,1)""];
18->19;
19[label=""Node Type: NEW VARIABLE 19

EXPRESSION:
amountseller = msg.value * 97 / 100

IRs:
TMP_63(uint256) = msg.value * 97
TMP_64(uint256) = TMP_63 / 100
amountseller(uint256) := TMP_64(uint256)""];
19->20;
20[label=""Node Type: NEW VARIABLE 20

EXPRESSION:
amountowner = msg.value * 3 / 100

IRs:
TMP_65(uint256) = msg.value * 3
TMP_66(uint256) = TMP_65 / 100
amountowner(uint256) := TMP_66(uint256)""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
pendingWithdrawals[owner] += amountowner

IRs:
REF_81(uint256) -> pendingWithdrawals[owner]
REF_81(-> pendingWithdrawals) = REF_81 + amountowner""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
pendingWithdrawals[seller] += amountseller

IRs:
REF_82(uint256) -> pendingWithdrawals[seller]
REF_82(-> pendingWithdrawals) = REF_82 + amountseller""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
starIndexToAddress[starIndex] = msg.sender

IRs:
REF_83(address) -> starIndexToAddress[starIndex]
REF_83(address) (->starIndexToAddress) := msg.sender(address)""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
starNoLongerForSale(starIndex)

IRs:
INTERNAL_CALL, CryptoStars.starNoLongerForSale(uint256)(starIndex)""];
24->25;
25[label=""Node Type: NEW VARIABLE 25

EXPRESSION:
STRZName = starIndexToSTRZName[starIndex]

IRs:
REF_84(string) -> starIndexToSTRZName[starIndex]
STRZName(string) := REF_84(string)""];
25->26;
26[label=""Node Type: NEW VARIABLE 26

EXPRESSION:
STRZMasterName = starIndexToSTRZMasterName[starIndex]

IRs:
REF_85(string) -> starIndexToSTRZMasterName[starIndex]
STRZMasterName(string) := REF_85(string)""];
26->27;
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
StarBought(starIndex,msg.value,offer.seller,msg.sender,STRZName,STRZMasterName,MinStarIndexAvailable,MaxStarIndexAvailable)

IRs:
REF_86(address) -> offer.seller
Emit StarBought(starIndex,msg.value,REF_86,msg.sender,STRZName,STRZMasterName,MinStarIndexAvailable,MaxStarIndexAvailable)""];
27->28;
28[label=""Node Type: NEW VARIABLE 28

EXPRESSION:
bid = starBids[starIndex]

IRs:
REF_87(CryptoStars.Bid) -> starBids[starIndex]
bid(CryptoStars.Bid) := REF_87(CryptoStars.Bid)""];
28->29;
29[label=""Node Type: IF 29

EXPRESSION:
bid.bidder == msg.sender

IRs:
REF_88(address) -> bid.bidder
TMP_69(bool) = REF_88 == msg.sender
CONDITION TMP_69""];
29->30[label=""True""];
29->33[label=""False""];
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
pendingWithdrawals[msg.sender] += bid.value

IRs:
REF_89(uint256) -> pendingWithdrawals[msg.sender]
REF_90(uint256) -> bid.value
REF_89(-> pendingWithdrawals) = REF_89 + REF_90""];
30->31;
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
starBids[starIndex] = Bid(false,starIndex,0x0,0)

IRs:
REF_91(CryptoStars.Bid) -> starBids[starIndex]
TMP_70(CryptoStars.Bid) = new Bid(False,starIndex,0,0)
REF_91(CryptoStars.Bid) (->starBids) := TMP_70(CryptoStars.Bid)""];
31->32;
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
StarBidWithdrawn(starIndex,bid.value,msg.sender)

IRs:
REF_92(uint256) -> bid.value
Emit StarBidWithdrawn(starIndex,REF_92,msg.sender)""];
32->33;
33[label=""Node Type: END_IF 33
""];
}
",0,1,0,0,"offer = starsOfferedForSale[starIndex];! offer.isForSale;;;offer.onlySellTo != 0x0 && offer.onlySellTo != msg.sender;;;msg.value < offer.minValue;;;offer.seller != starIndexToAddress[starIndex];;;seller = offer.seller;balanceOf[seller] --;balanceOf[msg.sender] ++;Assign(msg.sender,starIndex,starIndexToSTRZName[starIndex],starIndexToSTRZMasterName[starIndex]);Transfer(seller,msg.sender,1);amountseller = msg.value * 97 / 100;amountowner = msg.value * 3 / 100;pendingWithdrawals[owner] += amountowner;pendingWithdrawals[seller] += amountseller;starIndexToAddress[starIndex] = msg.sender;starNoLongerForSale(starIndex);STRZName = starIndexToSTRZName[starIndex];STRZMasterName = starIndexToSTRZMasterName[starIndex];StarBought(starIndex,msg.value,offer.seller,msg.sender,STRZName,STRZMasterName,MinStarIndexAvailable,MaxStarIndexAvailable);bid = starBids[starIndex];bid.bidder == msg.sender;pendingWithdrawals[msg.sender] += bid.value;;starBids[starIndex] = Bid(false,starIndex,0x0,0);StarBidWithdrawn(starIndex,bid.value,msg.sender)"
./0x341492c5f449ca8accae37d73aed8fcd21995ef9_ext.sol,WEIPAY.burn,109,115,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xef51ebde726a24d5f00c33c3e692d2ed83557172_ext.sol,GoldPoolPlan.transferFrom,58,68,"REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],allowance(uint256) := REF_5(uint256),REF_6(uint256) -> balances[_from],TMP_3(bool) = REF_6 >= _value,TMP_4(bool) = allowance >= _value,TMP_5(bool) = TMP_3 && TMP_4,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_7(uint256) -> balances[_to],REF_7(-> balances) = REF_7 + _value,REF_8(uint256) -> balances[_from],REF_8(-> balances) = REF_8 - _value,TMP_7(bool) = allowance < MAX_UINT256,CONDITION TMP_7,REF_9(mapping(address => uint256)) -> allowed[_from],REF_10(uint256) -> REF_9[msg.sender],REF_10(-> allowed) = REF_10 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
allowance = allowed[_from][msg.sender]

IRs:
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
allowance(uint256) := REF_5(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] >= _value && allowance >= _value)

IRs:
REF_6(uint256) -> balances[_from]
TMP_3(bool) = REF_6 >= _value
TMP_4(bool) = allowance >= _value
TMP_5(bool) = TMP_3 && TMP_4
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_7(uint256) -> balances[_to]
REF_7(-> balances) = REF_7 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] -= _value

IRs:
REF_8(uint256) -> balances[_from]
REF_8(-> balances) = REF_8 - _value""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
allowance < MAX_UINT256

IRs:
TMP_7(bool) = allowance < MAX_UINT256
CONDITION TMP_7""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_9(mapping(address => uint256)) -> allowed[_from]
REF_10(uint256) -> REF_9[msg.sender]
REF_10(-> allowed) = REF_10 - _value""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: RETURN 10

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowance = allowed[_from][msg.sender];require(bool)(balances[_from] >= _value && allowance >= _value);balances[_to] += _value;balances[_from] -= _value;allowance < MAX_UINT256;allowed[_from][msg.sender] -= _value;;Transfer(_from,_to,_value);true;success"
./0x31a5f35f32756fe35d39bafe85607d93185b23f2_ext.sol,GNNM._transfer,58,74,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xeca0415f309789ade195a51988d760b6d51f5de9_ext.sol,GreenMed.approveAndCall,134,141,"TMP_17 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_17(tokenRecipient),TMP_18(bool) = INTERNAL_CALL, GreenMed.approve(address,uint256)(_spender,_value),CONDITION TMP_18,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_17 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_17(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_18(bool) = INTERNAL_CALL, GreenMed.approve(address,uint256)(_spender,_value)
CONDITION TMP_18""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0xf4702b0918a8a89dfc38459ce42198834818f26b_ext.sol,multiowned.revoke,68,79,"TMP_8 = CONVERT msg.sender to uint256,REF_8(uint256) -> m_ownerIndex[TMP_8],ownerIndex(uint256) := REF_8(uint256),TMP_9(bool) = ownerIndex == 0,CONDITION TMP_9,TMP_10(uint256) = 2 ** ownerIndex,ownerIndexBit(uint256) := TMP_10(uint256),REF_9(multiowned.PendingState) -> m_pending[_operation],pending(multiowned.PendingState) := REF_9(multiowned.PendingState),REF_10(uint256) -> pending.ownersDone,TMP_11(uint256) = REF_10 & ownerIndexBit,TMP_12(bool) = TMP_11 > 0,CONDITION TMP_12,REF_11(uint256) -> pending.yetNeeded,TMP_13(uint256) := REF_11(uint256),REF_11(-> pending) = REF_11 + 1,REF_12(uint256) -> pending.ownersDone,REF_12(-> pending) = REF_12 - ownerIndexBit,Emit Revoke(msg.sender,_operation)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
ownerIndex = m_ownerIndex[uint256(msg.sender)]

IRs:
TMP_8 = CONVERT msg.sender to uint256
REF_8(uint256) -> m_ownerIndex[TMP_8]
ownerIndex(uint256) := REF_8(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
ownerIndex == 0

IRs:
TMP_9(bool) = ownerIndex == 0
CONDITION TMP_9""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
ownerIndexBit = 2 ** ownerIndex

IRs:
TMP_10(uint256) = 2 ** ownerIndex
ownerIndexBit(uint256) := TMP_10(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
pending = m_pending[_operation]

IRs:
REF_9(multiowned.PendingState) -> m_pending[_operation]
pending(multiowned.PendingState) := REF_9(multiowned.PendingState)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
pending.ownersDone & ownerIndexBit > 0

IRs:
REF_10(uint256) -> pending.ownersDone
TMP_11(uint256) = REF_10 & ownerIndexBit
TMP_12(bool) = TMP_11 > 0
CONDITION TMP_12""];
7->8[label=""True""];
7->11[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
pending.yetNeeded ++

IRs:
REF_11(uint256) -> pending.yetNeeded
TMP_13(uint256) := REF_11(uint256)
REF_11(-> pending) = REF_11 + 1""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
pending.ownersDone -= ownerIndexBit

IRs:
REF_12(uint256) -> pending.ownersDone
REF_12(-> pending) = REF_12 - ownerIndexBit""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Revoke(msg.sender,_operation)

IRs:
Emit Revoke(msg.sender,_operation)""];
10->11;
11[label=""Node Type: END_IF 11
""];
}
",0,1,0,0,"ownerIndex = m_ownerIndex[uint256(msg.sender)];ownerIndex == 0;;;ownerIndexBit = 2 ** ownerIndex;pending = m_pending[_operation];pending.ownersDone & ownerIndexBit > 0;pending.yetNeeded ++;;pending.ownersDone -= ownerIndexBit;Revoke(msg.sender,_operation)"
./0x87e960f996e789ca2c8415fc449e4720adbe0497_ext.sol,StandardToken.transferFrom,58,68,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0xed17658ad6b3fe87c7dc7323d0e77c4116a23626_ext.sol,Deploy.mintToken,142,147,"REF_89(uint256) -> balances[target],REF_89(-> balances) = REF_89 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances[target] += mintedAmount

IRs:
REF_89(uint256) -> balances[target]
REF_89(-> balances) = REF_89 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balances[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x05215fce25902366480696f38c3093e31dbce69a_ext.sol,REV1.dividendsOf,440,446,"REF_41(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_67(uint256) = profitPerShare_ * REF_41,TMP_68 = CONVERT TMP_67 to int256,REF_42(int256) -> payoutsTo_[_customerAddress],TMP_69(int256) = TMP_68 - REF_42,TMP_70 = CONVERT TMP_69 to uint256,TMP_71(uint256) = TMP_70 / magnitude,RETURN TMP_71","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_41(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_67(uint256) = profitPerShare_ * REF_41
TMP_68 = CONVERT TMP_67 to int256
REF_42(int256) -> payoutsTo_[_customerAddress]
TMP_69(int256) = TMP_68 - REF_42
TMP_70 = CONVERT TMP_69 to uint256
TMP_71(uint256) = TMP_70 / magnitude
RETURN TMP_71""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x8815df7e7e92b9b038658f0870e062548136e8cd_ext.sol,LDC.burn,87,93,"REF_19(uint256) -> balanceOf[msg.sender],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(uint256) -> balanceOf[msg.sender],REF_20(-> balanceOf) = REF_20 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_19(uint256) -> balanceOf[msg.sender]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_20(uint256) -> balanceOf[msg.sender]
REF_20(-> balanceOf) = REF_20 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xd4b36aadb0d90a32dbc15537db6e3054c52a3f62_ext.sol,WncToken.mintToken,207,212,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x036ba95116edf4f79d5c0da9639ed1f31b1ebcd9_ext.sol,StandardToken.transferFrom,56,66,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x84d5c939ddfdc3ea033f03e18213a6906f94e0c3_ext.sol,CryptoSagaDungeonProgress.incrementProgressOfAddressAndId,1430,1437,"REF_363(uint32[25]) -> addressToProgress[_address],_progressList(uint32[1]) = ['REF_363(uint32[25])'],REF_364(uint32) -> _progressList[_id],TMP_650(uint32) := REF_364(uint32),REF_364(-> _progressList) = REF_364 + 1,REF_365(uint32[25]) -> addressToProgress[_address],REF_365(uint32[25]) (->addressToProgress) := _progressList(uint32[1]),MODIFIER_CALL, AccessDeploy.onlyAccessDeploy()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_progressList = addressToProgress[_address]

IRs:
REF_363(uint32[25]) -> addressToProgress[_address]
_progressList(uint32[1]) = ['REF_363(uint32[25])']""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_progressList[_id] ++

IRs:
REF_364(uint32) -> _progressList[_id]
TMP_650(uint32) := REF_364(uint32)
REF_364(-> _progressList) = REF_364 + 1""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
addressToProgress[_address] = _progressList

IRs:
REF_365(uint32[25]) -> addressToProgress[_address]
REF_365(uint32[25]) (->addressToProgress) := _progressList(uint32[1])""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyAccessDeploy()

IRs:
MODIFIER_CALL, AccessDeploy.onlyAccessDeploy()()""];
4->1;
}
",0,1,0,0,onlyAccessDeploy();_progressList = addressToProgress[_address];_progressList[_id] ++;addressToProgress[_address] = _progressList
./0xf1e6b7f94bb0d70d8a19187f684e4270b0a0c989_ext.sol,ERC20TokenCPN.burn,136,147,"TMP_41(bool) = msg.sender == regulator,TMP_42(bool) = regulatorStatus == 1,TMP_43(bool) = regulatorStatus == 2,TMP_44(bool) = TMP_42 || TMP_43,TMP_45(bool) = TMP_41 && TMP_44,REF_18(ERC20TokenCPN.agent) -> agents[_to],REF_19(uint256) -> REF_18.balance,TMP_46(bool) = REF_19 >= _value,TMP_47(bool) = TMP_45 && TMP_46,CONDITION TMP_47,Emit Transfer(_to,msg.sender,_value),REF_20(ERC20TokenCPN.agent) -> agents[_to],REF_21(uint256) -> REF_20.balance,REF_21(-> agents) = REF_21 - _value,amount(uint256) = amount - _value,Emit Burn(msg.sender,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
(msg.sender == regulator) && (regulatorStatus == 1 || regulatorStatus == 2) && (agents[_to].balance >= _value)

IRs:
TMP_41(bool) = msg.sender == regulator
TMP_42(bool) = regulatorStatus == 1
TMP_43(bool) = regulatorStatus == 2
TMP_44(bool) = TMP_42 || TMP_43
TMP_45(bool) = TMP_41 && TMP_44
REF_18(ERC20TokenCPN.agent) -> agents[_to]
REF_19(uint256) -> REF_18.balance
TMP_46(bool) = REF_19 >= _value
TMP_47(bool) = TMP_45 && TMP_46
CONDITION TMP_47""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Transfer(_to,msg.sender,_value)

IRs:
Emit Transfer(_to,msg.sender,_value)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
agents[_to].balance -= _value

IRs:
REF_20(ERC20TokenCPN.agent) -> agents[_to]
REF_21(uint256) -> REF_20.balance
REF_21(-> agents) = REF_21 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
amount -= _value

IRs:
amount(uint256) = amount - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Burn(msg.sender,_to,_value)

IRs:
Emit Burn(msg.sender,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"(msg.sender == regulator) && (regulatorStatus == 1 || regulatorStatus == 2) && (agents[_to].balance >= _value);Transfer(_to,msg.sender,_value);;agents[_to].balance -= _value;amount -= _value;Burn(msg.sender,_to,_value);true;false;success"
./0x54d3ad23846643b93098915001ab274ea19e5622_ext.sol,Maths.plus,14,19,"TMP_0(uint256) = addendA + addendB,sum(uint256) := TMP_0(uint256),RETURN sum","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
sum = addendA + addendB

IRs:
TMP_0(uint256) = addendA + addendB
sum(uint256) := TMP_0(uint256)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
sum

IRs:
RETURN sum""];
}
",0,1,0,0,sum = addendA + addendB;sum
./0xd8d94cfa0dc8898d13e6f9a1618c490f68c160dd_ext.sol,MichaelCoin.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xf208f8cdf637e49b5e6219fa76b014d49287894f_ext.sol,Gainz.paymentDue,72,75,"REF_6(uint256) -> timestamp[userAddress],TMP_5(uint256) = block.number - REF_6,blockDelta(uint256) := TMP_5(uint256),REF_7(uint256) -> balances[userAddress],TMP_6(uint256) = REF_7 * 2,TMP_7(uint256) = TMP_6 / 100,TMP_8(uint256) = TMP_7 * blockDelta,TMP_9(uint256) = TMP_8 / 6000,RETURN TMP_9","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
blockDelta = block.number - timestamp[userAddress]

IRs:
REF_6(uint256) -> timestamp[userAddress]
TMP_5(uint256) = block.number - REF_6
blockDelta(uint256) := TMP_5(uint256)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
balances[userAddress] * 2 / 100 * (blockDelta) / 6000

IRs:
REF_7(uint256) -> balances[userAddress]
TMP_6(uint256) = REF_7 * 2
TMP_7(uint256) = TMP_6 / 100
TMP_8(uint256) = TMP_7 * blockDelta
TMP_9(uint256) = TMP_8 / 6000
RETURN TMP_9""];
}
",0,1,0,0,blockDelta = block.number - timestamp[userAddress];balances[userAddress] * 2 / 100 * (blockDelta) / 6000
./0x3ac96bbe8b60d715fd818b3fe242edf9def20571_ext.sol,MyBoToken.mintToken,139,144,"REF_52(uint256) -> balanceOf[target],REF_52(-> balanceOf) = REF_52 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_52(uint256) -> balanceOf[target]
REF_52(-> balanceOf) = REF_52 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x5abaff0b83f81dc061c590aadcba013c69237fd7_ext.sol,CryptoJade.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x6dee0a976370ee9f0f8c4619ab3386441a42ceb3_ext.sol,CoinifinexToken.burn,184,190,"REF_96(uint256) -> balanceOf[msg.sender],TMP_163(bool) = REF_96 >= _value,TMP_164(None) = SOLIDITY_CALL require(bool)(TMP_163),REF_97(uint256) -> balanceOf[msg.sender],REF_97(-> balanceOf) = REF_97 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_96(uint256) -> balanceOf[msg.sender]
TMP_163(bool) = REF_96 >= _value
TMP_164(None) = SOLIDITY_CALL require(bool)(TMP_163)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_97(uint256) -> balanceOf[msg.sender]
REF_97(-> balanceOf) = REF_97 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x7123027d76a5135e66b3a365efaba2b55de18a62_ext.sol,CrypteloERC20.burnFrom,160,168,"REF_22(uint256) -> balanceOf[_from],TMP_33(bool) = REF_22 >= _value,TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33),REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],TMP_35(bool) = _value <= REF_24,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),REF_25(uint256) -> balanceOf[_from],REF_25(-> balanceOf) = REF_25 - _value,REF_26(mapping(address => uint256)) -> allowance[_from],REF_27(uint256) -> REF_26[msg.sender],REF_27(-> allowance) = REF_27 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_22(uint256) -> balanceOf[_from]
TMP_33(bool) = REF_22 >= _value
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
TMP_35(bool) = _value <= REF_24
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_25(uint256) -> balanceOf[_from]
REF_25(-> balanceOf) = REF_25 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_26(mapping(address => uint256)) -> allowance[_from]
REF_27(uint256) -> REF_26[msg.sender]
REF_27(-> allowance) = REF_27 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xd0d916322b02b7a8095af4bb69bea0e9d93cf3b1_ext.sol,WTI_10_20210916.transferFrom,42,54,"REF_6(uint256) -> balanceOf[from],TMP_6(bool) = value <= REF_6,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_7(mapping(address => uint256)) -> allowance[from],REF_8(uint256) -> REF_7[msg.sender],TMP_8(bool) = value <= REF_8,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_9(uint256) -> balanceOf[from],REF_9(-> balanceOf) = REF_9 - value,REF_10(uint256) -> balanceOf[to],REF_10(-> balanceOf) = REF_10 + value,REF_11(mapping(address => uint256)) -> allowance[from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowance) = REF_12 - value,Emit Transfer(from,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(value <= balanceOf[from])

IRs:
REF_6(uint256) -> balanceOf[from]
TMP_6(bool) = value <= REF_6
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value <= allowance[from][msg.sender])

IRs:
REF_7(mapping(address => uint256)) -> allowance[from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_8(bool) = value <= REF_8
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[from] -= value

IRs:
REF_9(uint256) -> balanceOf[from]
REF_9(-> balanceOf) = REF_9 - value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[to] += value

IRs:
REF_10(uint256) -> balanceOf[to]
REF_10(-> balanceOf) = REF_10 + value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allowance[from][msg.sender] -= value

IRs:
REF_11(mapping(address => uint256)) -> allowance[from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowance) = REF_12 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(value <= balanceOf[from]);require(bool)(value <= allowance[from][msg.sender]);balanceOf[from] -= value;balanceOf[to] += value;allowance[from][msg.sender] -= value;Transfer(from,to,value);true;success"
./0xf079dd66fd50624d1ea26185ea3bf41ca4606187_ext.sol,StandardToken.transferFrom,58,68,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x5862ae475da22367076b89a6f782ea6711eb2949_ext.sol,ZToken.mintToken,208,213,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x39e568276531f17da3c76d54400cfd8300201652_ext.sol,CSC.transfer,38,53,"TMP_2(bool) = msg.sender == owner,TMP_3(bool) = icoLockUntil < now,TMP_4(bool) = TMP_2 || TMP_3,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),TMP_6 = CONVERT 0 to address,TMP_7(bool) = _to != TMP_6,CONDITION TMP_7,REF_10(uint256[2]) -> lockedBalances[msg.sender],REF_11(uint256) -> REF_10[1],TMP_8(bool) = REF_11 >= now,CONDITION TMP_8,REF_12(uint256) -> balances[msg.sender],REF_13(uint256[2]) -> lockedBalances[msg.sender],REF_14(uint256) -> REF_13[0],TMP_9(bool) = REF_12 > REF_14,REF_15(uint256) -> balances[msg.sender],REF_16(uint256[2]) -> lockedBalances[msg.sender],REF_17(uint256) -> REF_16[0],TMP_10(uint256) = REF_15 - REF_17,TMP_11(bool) = TMP_10 >= _value,TMP_12(bool) = TMP_9 && TMP_11,TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12),REF_18(uint256) -> balances[msg.sender],TMP_14(bool) = REF_18 >= _value,TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14),REF_19(uint256) -> balances[msg.sender],REF_19(-> balances) = REF_19 - _value,REF_20(uint256) -> balances[_to],REF_20(-> balances) = REF_20 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner || icoLockUntil < now)

IRs:
TMP_2(bool) = msg.sender == owner
TMP_3(bool) = icoLockUntil < now
TMP_4(bool) = TMP_2 || TMP_3
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
_to != address(0)

IRs:
TMP_6 = CONVERT 0 to address
TMP_7(bool) = _to != TMP_6
CONDITION TMP_7""];
2->3[label=""True""];
2->11[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
lockedBalances[msg.sender][1] >= now

IRs:
REF_10(uint256[2]) -> lockedBalances[msg.sender]
REF_11(uint256) -> REF_10[1]
TMP_8(bool) = REF_11 >= now
CONDITION TMP_8""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)((balances[msg.sender] > lockedBalances[msg.sender][0]) && (balances[msg.sender] - lockedBalances[msg.sender][0] >= _value))

IRs:
REF_12(uint256) -> balances[msg.sender]
REF_13(uint256[2]) -> lockedBalances[msg.sender]
REF_14(uint256) -> REF_13[0]
TMP_9(bool) = REF_12 > REF_14
REF_15(uint256) -> balances[msg.sender]
REF_16(uint256[2]) -> lockedBalances[msg.sender]
REF_17(uint256) -> REF_16[0]
TMP_10(uint256) = REF_15 - REF_17
TMP_11(bool) = TMP_10 >= _value
TMP_12(bool) = TMP_9 && TMP_11
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)""];
4->6;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_18(uint256) -> balances[msg.sender]
TMP_14(bool) = REF_18 >= _value
TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_19(uint256) -> balances[msg.sender]
REF_19(-> balances) = REF_19 - _value""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[_to] += _value

IRs:
REF_20(uint256) -> balances[_to]
REF_20(-> balances) = REF_20 + _value""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
9->10;
10[label=""Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True""];
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: RETURN 12

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(msg.sender == owner || icoLockUntil < now);_to != address(0);lockedBalances[msg.sender][1] >= now;;require(bool)((balances[msg.sender] > lockedBalances[msg.sender][0]) && (balances[msg.sender] - lockedBalances[msg.sender][0] >= _value));require(bool)(balances[msg.sender] >= _value);;balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0x1e4e36b3f011d862fd70006804da8fcefe89d3d8_ext.sol,VenusToken.burn,128,134,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x36cac7291719e907276d795c330dbc2fcf66df54_ext.sol,DogCash.totalSupply,134,136,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x52fe31c97e5c29ea63cbcfb045e1171427bb9248_ext.sol,NewRich.approveAndCall,200,205,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x40d6ab35c171cddc7fc81187e8a20d6711717ef0_ext.sol,ProofOfBible.dividendsOf,305,307,"REF_35(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_61(uint256) = profitPerShare_ * REF_35,TMP_62 = CONVERT TMP_61 to int256,REF_36(int256) -> payoutsTo_[_customerAddress],TMP_63(int256) = TMP_62 - REF_36,TMP_64 = CONVERT TMP_63 to uint256,TMP_65(uint256) = TMP_64 / magnitude,RETURN TMP_65","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_35(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_61(uint256) = profitPerShare_ * REF_35
TMP_62 = CONVERT TMP_61 to int256
REF_36(int256) -> payoutsTo_[_customerAddress]
TMP_63(int256) = TMP_62 - REF_36
TMP_64 = CONVERT TMP_63 to uint256
TMP_65(uint256) = TMP_64 / magnitude
RETURN TMP_65""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x02c60d28be3338014fef3fdf50a3218b946c0609_ext.sol,EasyInvest3.fallback,29,44,"REF_0(uint256) -> invested[msg.sender],TMP_0(bool) = REF_0 != 0,CONDITION TMP_0,REF_1(uint256) -> invested[msg.sender],TMP_1(uint256) = REF_1 * 3,TMP_2(uint256) = TMP_1 / 100,REF_2(uint256) -> atBlock[msg.sender],TMP_3(uint256) = block.number - REF_2,TMP_4(uint256) = TMP_2 * TMP_3,TMP_5(uint256) = TMP_4 / 5900,amount(uint256) := TMP_5(uint256),Transfer dest:msg.sender value:amount,REF_4(uint256) -> atBlock[msg.sender],REF_4(uint256) (->atBlock) := block.number(uint256),REF_5(uint256) -> invested[msg.sender],REF_5(-> invested) = REF_5 + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
invested[msg.sender] != 0

IRs:
REF_0(uint256) -> invested[msg.sender]
TMP_0(bool) = REF_0 != 0
CONDITION TMP_0""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = invested[msg.sender] * 3 / 100 * (block.number - atBlock[msg.sender]) / 5900

IRs:
REF_1(uint256) -> invested[msg.sender]
TMP_1(uint256) = REF_1 * 3
TMP_2(uint256) = TMP_1 / 100
REF_2(uint256) -> atBlock[msg.sender]
TMP_3(uint256) = block.number - REF_2
TMP_4(uint256) = TMP_2 * TMP_3
TMP_5(uint256) = TMP_4 / 5900
amount(uint256) := TMP_5(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
atBlock[msg.sender] = block.number

IRs:
REF_4(uint256) -> atBlock[msg.sender]
REF_4(uint256) (->atBlock) := block.number(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
invested[msg.sender] += msg.value

IRs:
REF_5(uint256) -> invested[msg.sender]
REF_5(-> invested) = REF_5 + msg.value""];
}
",0,1,0,0,invested[msg.sender] != 0;amount = invested[msg.sender] * 3 / 100 * (block.number - atBlock[msg.sender]) / 5900;;msg.sender.transfer(amount);atBlock[msg.sender] = block.number;invested[msg.sender] += msg.value
./0xd0d6b03cb90ec013c6a00ff60e30c3a350c1df94_ext.sol,NamiTrade._transfer,1332,1348,"TMP_462(bool) = _to != 0,TMP_463(None) = SOLIDITY_CALL require(bool)(TMP_462),REF_262(uint256) -> balanceOf[_from],TMP_464(bool) = REF_262 >= _value,TMP_465(None) = SOLIDITY_CALL require(bool)(TMP_464),REF_263(uint256) -> balanceOf[_to],TMP_466(uint256) = REF_263 + _value,REF_264(uint256) -> balanceOf[_to],TMP_467(bool) = TMP_466 >= REF_264,TMP_468(None) = SOLIDITY_CALL require(bool)(TMP_467),REF_265(uint256) -> balanceOf[_from],REF_266(uint256) -> balanceOf[_to],TMP_469(uint256) = REF_265 + REF_266,previousBalances(uint256) := TMP_469(uint256),REF_267(uint256) -> balanceOf[_from],REF_267(-> balanceOf) = REF_267 - _value,REF_268(uint256) -> balanceOf[_to],REF_268(-> balanceOf) = REF_268 + _value,Emit Transfer(_from,_to,_value),REF_269(uint256) -> balanceOf[_from],REF_270(uint256) -> balanceOf[_to],TMP_471(uint256) = REF_269 + REF_270,TMP_472(bool) = TMP_471 == previousBalances,TMP_473(None) = SOLIDITY_CALL assert(bool)(TMP_472)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_462(bool) = _to != 0
TMP_463(None) = SOLIDITY_CALL require(bool)(TMP_462)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_262(uint256) -> balanceOf[_from]
TMP_464(bool) = REF_262 >= _value
TMP_465(None) = SOLIDITY_CALL require(bool)(TMP_464)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_263(uint256) -> balanceOf[_to]
TMP_466(uint256) = REF_263 + _value
REF_264(uint256) -> balanceOf[_to]
TMP_467(bool) = TMP_466 >= REF_264
TMP_468(None) = SOLIDITY_CALL require(bool)(TMP_467)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_265(uint256) -> balanceOf[_from]
REF_266(uint256) -> balanceOf[_to]
TMP_469(uint256) = REF_265 + REF_266
previousBalances(uint256) := TMP_469(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_267(uint256) -> balanceOf[_from]
REF_267(-> balanceOf) = REF_267 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_268(uint256) -> balanceOf[_to]
REF_268(-> balanceOf) = REF_268 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_269(uint256) -> balanceOf[_from]
REF_270(uint256) -> balanceOf[_to]
TMP_471(uint256) = REF_269 + REF_270
TMP_472(bool) = TMP_471 == previousBalances
TMP_473(None) = SOLIDITY_CALL assert(bool)(TMP_472)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x00416b9d728069edb0ceb04bc2b203fa7336d1f1_ext.sol,SeedCrowdsaleContract.calculateMaxContribution,189,203,"REF_14(SeedCrowdsaleContract.state) -> state.priorityPass,TMP_52(bool) = crowdsaleState == REF_14,CONDITION TMP_52,TMP_53(uint256) = HIGH_LEVEL_CALL, dest:priorityPassContract(PriorityPassInterface), function:getAccountLimit, arguments:['_contributor']  ,REF_16(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor],REF_17(uint256) -> REF_16.contributionAmount,TMP_54(uint256) = TMP_53 - REF_17,maxContrib(uint256) := TMP_54(uint256),TMP_55(uint256) = maxP1Cap - ethRaised,TMP_56(bool) = maxContrib > TMP_55,CONDITION TMP_56,TMP_57(uint256) = maxP1Cap - ethRaised,maxContrib(uint256) := TMP_57(uint256),TMP_58(uint256) = maxCap - ethRaised,maxContrib(uint256) := TMP_58(uint256),RETURN maxContrib,RETURN maxContribution","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
crowdsaleState == state.priorityPass

IRs:
REF_14(SeedCrowdsaleContract.state) -> state.priorityPass
TMP_52(bool) = crowdsaleState == REF_14
CONDITION TMP_52""];
2->3[label=""True""];
2->7[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
maxContrib = priorityPassContract.getAccountLimit(_contributor) - contributorList[_contributor].contributionAmount

IRs:
TMP_53(uint256) = HIGH_LEVEL_CALL, dest:priorityPassContract(PriorityPassInterface), function:getAccountLimit, arguments:['_contributor']  
REF_16(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor]
REF_17(uint256) -> REF_16.contributionAmount
TMP_54(uint256) = TMP_53 - REF_17
maxContrib(uint256) := TMP_54(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
maxContrib > (maxP1Cap - ethRaised)

IRs:
TMP_55(uint256) = maxP1Cap - ethRaised
TMP_56(bool) = maxContrib > TMP_55
CONDITION TMP_56""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
maxContrib = maxP1Cap - ethRaised

IRs:
TMP_57(uint256) = maxP1Cap - ethRaised
maxContrib(uint256) := TMP_57(uint256)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
maxContrib = maxCap - ethRaised

IRs:
TMP_58(uint256) = maxCap - ethRaised
maxContrib(uint256) := TMP_58(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
maxContrib

IRs:
RETURN maxContrib""];
10[label=""Node Type: RETURN 10

EXPRESSION:
maxContribution

IRs:
RETURN maxContribution""];
}
",0,1,0,0,;crowdsaleState == state.priorityPass;maxContrib = priorityPassContract.getAccountLimit(_contributor) - contributorList[_contributor].contributionAmount;maxContrib = maxCap - ethRaised;maxContrib > (maxP1Cap - ethRaised);maxContrib = maxP1Cap - ethRaised;;;maxContrib;maxContribution
./0x33bd43ba9c71968c132f61246a79c18f9bdf0267_ext.sol,BouncyCoinSelfdrop.buyTokens,121,176,"TMP_8(bool) = msg.value >= MIN_CONTRIBUTION,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),TMP_10(bool) = now > oct_28,CONDITION TMP_10,base_multiplier(uint256) := third_round_base_multiplier(uint256),TMP_11(bool) = now > oct_24,CONDITION TMP_11,base_multiplier(uint256) := second_round_base_multiplier(uint256),TMP_12(bool) = now > oct_17,CONDITION TMP_12,base_multiplier(uint256) := first_round_base_multiplier(uint256),base_multiplier(uint256) := 0(uint256),TMP_13(bool) = msg.value >= 1000000000000000000,CONDITION TMP_13,TMP_14(uint256) = base_multiplier + 10,multiplier(uint256) := TMP_14(uint256),multiplier(uint256) := base_multiplier(uint256),amountRemaining(uint256) := msg.value(uint256),TMP_15(uint256) = MAX_TOKENS_SOLD - tokensSold,tokensAvailable(uint256) := TMP_15(uint256),TMP_16(uint256) = 10 ** 18,TMP_17(uint256) = amountRemaining * TMP_16,TMP_18(uint256) = TMP_17 / PRICE,baseTokens(uint256) := TMP_18(uint256),TMP_19(uint256) = baseTokens * multiplier,TMP_20(uint256) = TMP_19 / 100,TMP_21(uint256) = baseTokens + TMP_20,maxTokensByAmount(uint256) := TMP_21(uint256),tokensToReceive(uint256) := 0(uint256),TMP_22(bool) = maxTokensByAmount > tokensAvailable,CONDITION TMP_22,tokensToReceive(uint256) := tokensAvailable(uint256),TMP_23(uint256) = PRICE * tokensToReceive,TMP_24(uint256) = 10 ** 18,TMP_25(uint256) = TMP_23 / TMP_24,amountRemaining(uint256) = amountRemaining - TMP_25,tokensToReceive(uint256) := maxTokensByAmount(uint256),amountRemaining(uint256) := 0(uint256),tokensSold(uint256) = tokensSold + tokensToReceive,TMP_26(bool) = tokensToReceive > 0,TMP_27(None) = SOLIDITY_CALL assert(bool)(TMP_26),TMP_28(bool) = HIGH_LEVEL_CALL, dest:bouncyCoinToken(ERC20), function:transfer, arguments:['msg.sender', 'tokensToReceive']  ,TMP_29(None) = SOLIDITY_CALL assert(bool)(TMP_28),TMP_30(bool) = amountRemaining != 0,CONDITION TMP_30,Transfer dest:msg.sender value:amountRemaining,TMP_32(uint256) = msg.value - amountRemaining,amountAccepted(uint256) := TMP_32(uint256),Transfer dest:wallet value:amountAccepted,totalReceived(uint256) = totalReceived + amountAccepted,TMP_34(bool) = totalReceived <= HARD_CAP,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),TMP_36(bool) = tokensSold == MAX_TOKENS_SOLD,CONDITION TMP_36,INTERNAL_CALL, BouncyCoinSelfdrop.finalize()(),Emit TokensSold(msg.sender,tokensToReceive,amountAccepted),REF_5(BouncyCoinSelfdrop.Stages) -> Stages.Started,MODIFIER_CALL, BouncyCoinSelfdrop.atStage(BouncyCoinSelfdrop.Stages)(REF_5)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->43;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= MIN_CONTRIBUTION)

IRs:
TMP_8(bool) = msg.value >= MIN_CONTRIBUTION
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
now > oct_28

IRs:
TMP_10(bool) = now > oct_28
CONDITION TMP_10""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
base_multiplier = third_round_base_multiplier

IRs:
base_multiplier(uint256) := third_round_base_multiplier(uint256)""];
4->12;
5[label=""Node Type: IF 5

EXPRESSION:
now > oct_24

IRs:
TMP_11(bool) = now > oct_24
CONDITION TMP_11""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
base_multiplier = second_round_base_multiplier

IRs:
base_multiplier(uint256) := second_round_base_multiplier(uint256)""];
6->11;
7[label=""Node Type: IF 7

EXPRESSION:
now > oct_17

IRs:
TMP_12(bool) = now > oct_17
CONDITION TMP_12""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
base_multiplier = first_round_base_multiplier

IRs:
base_multiplier(uint256) := first_round_base_multiplier(uint256)""];
8->10;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
base_multiplier = 0

IRs:
base_multiplier(uint256) := 0(uint256)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: NEW VARIABLE 13
""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
msg.value >= 1000000000000000000

IRs:
TMP_13(bool) = msg.value >= 1000000000000000000
CONDITION TMP_13""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
multiplier = base_multiplier + 10

IRs:
TMP_14(uint256) = base_multiplier + 10
multiplier(uint256) := TMP_14(uint256)""];
15->17;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
multiplier = base_multiplier

IRs:
multiplier(uint256) := base_multiplier(uint256)""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: NEW VARIABLE 18

EXPRESSION:
amountRemaining = msg.value

IRs:
amountRemaining(uint256) := msg.value(uint256)""];
18->19;
19[label=""Node Type: NEW VARIABLE 19

EXPRESSION:
tokensAvailable = MAX_TOKENS_SOLD - tokensSold

IRs:
TMP_15(uint256) = MAX_TOKENS_SOLD - tokensSold
tokensAvailable(uint256) := TMP_15(uint256)""];
19->20;
20[label=""Node Type: NEW VARIABLE 20

EXPRESSION:
baseTokens = amountRemaining * 10 ** 18 / PRICE

IRs:
TMP_16(uint256) = 10 ** 18
TMP_17(uint256) = amountRemaining * TMP_16
TMP_18(uint256) = TMP_17 / PRICE
baseTokens(uint256) := TMP_18(uint256)""];
20->21;
21[label=""Node Type: NEW VARIABLE 21

EXPRESSION:
maxTokensByAmount = baseTokens + ((baseTokens * multiplier) / 100)

IRs:
TMP_19(uint256) = baseTokens * multiplier
TMP_20(uint256) = TMP_19 / 100
TMP_21(uint256) = baseTokens + TMP_20
maxTokensByAmount(uint256) := TMP_21(uint256)""];
21->22;
22[label=""Node Type: NEW VARIABLE 22

EXPRESSION:
tokensToReceive = 0

IRs:
tokensToReceive(uint256) := 0(uint256)""];
22->23;
23[label=""Node Type: IF 23

EXPRESSION:
maxTokensByAmount > tokensAvailable

IRs:
TMP_22(bool) = maxTokensByAmount > tokensAvailable
CONDITION TMP_22""];
23->24[label=""True""];
23->26[label=""False""];
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
tokensToReceive = tokensAvailable

IRs:
tokensToReceive(uint256) := tokensAvailable(uint256)""];
24->25;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
amountRemaining -= (PRICE * tokensToReceive) / 10 ** 18

IRs:
TMP_23(uint256) = PRICE * tokensToReceive
TMP_24(uint256) = 10 ** 18
TMP_25(uint256) = TMP_23 / TMP_24
amountRemaining(uint256) = amountRemaining - TMP_25""];
25->28;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
tokensToReceive = maxTokensByAmount

IRs:
tokensToReceive(uint256) := maxTokensByAmount(uint256)""];
26->27;
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
amountRemaining = 0

IRs:
amountRemaining(uint256) := 0(uint256)""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
tokensSold += tokensToReceive

IRs:
tokensSold(uint256) = tokensSold + tokensToReceive""];
29->30;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
assert(bool)(tokensToReceive > 0)

IRs:
TMP_26(bool) = tokensToReceive > 0
TMP_27(None) = SOLIDITY_CALL assert(bool)(TMP_26)""];
30->31;
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
assert(bool)(bouncyCoinToken.transfer(msg.sender,tokensToReceive))

IRs:
TMP_28(bool) = HIGH_LEVEL_CALL, dest:bouncyCoinToken(ERC20), function:transfer, arguments:['msg.sender', 'tokensToReceive']  
TMP_29(None) = SOLIDITY_CALL assert(bool)(TMP_28)""];
31->32;
32[label=""Node Type: IF 32

EXPRESSION:
amountRemaining != 0

IRs:
TMP_30(bool) = amountRemaining != 0
CONDITION TMP_30""];
32->33[label=""True""];
32->34[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
msg.sender.transfer(amountRemaining)

IRs:
Transfer dest:msg.sender value:amountRemaining""];
33->34;
34[label=""Node Type: END_IF 34
""];
34->35;
35[label=""Node Type: NEW VARIABLE 35

EXPRESSION:
amountAccepted = msg.value - amountRemaining

IRs:
TMP_32(uint256) = msg.value - amountRemaining
amountAccepted(uint256) := TMP_32(uint256)""];
35->36;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
wallet.transfer(amountAccepted)

IRs:
Transfer dest:wallet value:amountAccepted""];
36->37;
37[label=""Node Type: EXPRESSION 37

EXPRESSION:
totalReceived += amountAccepted

IRs:
totalReceived(uint256) = totalReceived + amountAccepted""];
37->38;
38[label=""Node Type: EXPRESSION 38

EXPRESSION:
require(bool)(totalReceived <= HARD_CAP)

IRs:
TMP_34(bool) = totalReceived <= HARD_CAP
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
38->39;
39[label=""Node Type: IF 39

EXPRESSION:
tokensSold == MAX_TOKENS_SOLD

IRs:
TMP_36(bool) = tokensSold == MAX_TOKENS_SOLD
CONDITION TMP_36""];
39->40[label=""True""];
39->41[label=""False""];
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
finalize()

IRs:
INTERNAL_CALL, BouncyCoinSelfdrop.finalize()()""];
40->41;
41[label=""Node Type: END_IF 41
""];
41->42;
42[label=""Node Type: EXPRESSION 42

EXPRESSION:
TokensSold(msg.sender,tokensToReceive,amountAccepted)

IRs:
Emit TokensSold(msg.sender,tokensToReceive,amountAccepted)""];
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
atStage(Stages.Started)

IRs:
REF_5(BouncyCoinSelfdrop.Stages) -> Stages.Started
MODIFIER_CALL, BouncyCoinSelfdrop.atStage(BouncyCoinSelfdrop.Stages)(REF_5)""];
43->1;
}
",0,1,0,0,"atStage(Stages.Started);require(bool)(msg.value >= MIN_CONTRIBUTION);;now > oct_28;base_multiplier = third_round_base_multiplier;now > oct_24;;base_multiplier = second_round_base_multiplier;now > oct_17;;base_multiplier = first_round_base_multiplier;base_multiplier = 0;;;msg.value >= 1000000000000000000;multiplier = base_multiplier + 10;multiplier = base_multiplier;;amountRemaining = msg.value;tokensAvailable = MAX_TOKENS_SOLD - tokensSold;baseTokens = amountRemaining * 10 ** 18 / PRICE;maxTokensByAmount = baseTokens + ((baseTokens * multiplier) / 100);tokensToReceive = 0;maxTokensByAmount > tokensAvailable;tokensToReceive = tokensAvailable;tokensToReceive = maxTokensByAmount;amountRemaining -= (PRICE * tokensToReceive) / 10 ** 18;;amountRemaining = 0;tokensSold += tokensToReceive;assert(bool)(tokensToReceive > 0);assert(bool)(bouncyCoinToken.transfer(msg.sender,tokensToReceive));amountRemaining != 0;msg.sender.transfer(amountRemaining);;amountAccepted = msg.value - amountRemaining;wallet.transfer(amountAccepted);totalReceived += amountAccepted;require(bool)(totalReceived <= HARD_CAP);tokensSold == MAX_TOKENS_SOLD;finalize();;TokensSold(msg.sender,tokensToReceive,amountAccepted)"
./0x44b1cdc06c3afa610e125a3cbcc9b8cce7c366dc_ext.sol,VOCC_I060_20181211.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x3fde21c4118a7ac77e113920f76f68edd4fc144d_ext.sol,BEBmining.querYrevenue,140,158,"REF_20(BEBmining.miner) -> miners[msg.sender],user(BEBmining.miner) := REF_20(BEBmining.miner),REF_21(uint256) -> user.mining,_amuont(uint256) := REF_21(uint256),REF_22(uint256) -> user.amountTotal,_amountTotal(uint256) := REF_22(uint256),TMP_65(bool) = _amuont == 0,CONDITION TMP_65,percentage(uint256) := 0(uint256),TMP_66(uint256) = _amountTotal * 100,TMP_67(uint256) = TMP_66 / _amuont,TMP_68(uint256) = TMP_67 * 100,TMP_69(uint256) = TMP_68 / 730,TMP_70(uint256) = 100 - TMP_69,percentage(uint256) := TMP_70(uint256),REF_23(uint256) -> user.lastDate,_lastDate(uint256) := REF_23(uint256),TMP_71(uint256) = _amuont / 100,dayzmount(uint256) := TMP_71(uint256),TMP_72(uint256) = now - _lastDate,TMP_73(uint256) = TMP_72 / depreciationTime,depreciation(uint256) := TMP_73(uint256),TMP_74(bool) = depreciation > 0,TMP_75(None) = SOLIDITY_CALL require(bool,string)(TMP_74,Less than 1 day of earnings),TMP_76(uint256) = _amuont * depreciation,TMP_77(uint256) = TMP_76 / 100,Bebday(uint256) := TMP_77(uint256),sumethbos(uint256) := Bebday(uint256),TMP_78(uint256) = sumethbos / ethExchuangeRate,profit(uint256) := TMP_78(uint256),TMP_79(uint256) = dayzmount / ethExchuangeRate,REF_24(uint256) -> user.amountTotal,TMP_80(uint256) = REF_24 / ethExchuangeRate,REF_25(uint256) -> user.lastDate,RETURN percentage,TMP_79,profit,TMP_80,REF_25","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
user = miners[msg.sender]

IRs:
REF_20(BEBmining.miner) -> miners[msg.sender]
user(BEBmining.miner) := REF_20(BEBmining.miner)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
_amuont = user.mining

IRs:
REF_21(uint256) -> user.mining
_amuont(uint256) := REF_21(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
_amountTotal = user.amountTotal

IRs:
REF_22(uint256) -> user.amountTotal
_amountTotal(uint256) := REF_22(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
_amuont == 0

IRs:
TMP_65(bool) = _amuont == 0
CONDITION TMP_65""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
percentage = 0

IRs:
percentage(uint256) := 0(uint256)""];
5->7;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
percentage = 100 - (_amountTotal * 100 / _amuont * 100 / 730)

IRs:
TMP_66(uint256) = _amountTotal * 100
TMP_67(uint256) = TMP_66 / _amuont
TMP_68(uint256) = TMP_67 * 100
TMP_69(uint256) = TMP_68 / 730
TMP_70(uint256) = 100 - TMP_69
percentage(uint256) := TMP_70(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
_lastDate = user.lastDate

IRs:
REF_23(uint256) -> user.lastDate
_lastDate(uint256) := REF_23(uint256)""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
dayzmount = _amuont / 100

IRs:
TMP_71(uint256) = _amuont / 100
dayzmount(uint256) := TMP_71(uint256)""];
9->10;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
depreciation = (now - _lastDate) / depreciationTime

IRs:
TMP_72(uint256) = now - _lastDate
TMP_73(uint256) = TMP_72 / depreciationTime
depreciation(uint256) := TMP_73(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
require(bool,string)(depreciation > 0,Less than 1 day of earnings)

IRs:
TMP_74(bool) = depreciation > 0
TMP_75(None) = SOLIDITY_CALL require(bool,string)(TMP_74,Less than 1 day of earnings)""];
11->12;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
Bebday = _amuont * depreciation / 100

IRs:
TMP_76(uint256) = _amuont * depreciation
TMP_77(uint256) = TMP_76 / 100
Bebday(uint256) := TMP_77(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
sumethbos = Bebday

IRs:
sumethbos(uint256) := Bebday(uint256)""];
13->14;
14[label=""Node Type: NEW VARIABLE 14

EXPRESSION:
profit = sumethbos / ethExchuangeRate

IRs:
TMP_78(uint256) = sumethbos / ethExchuangeRate
profit(uint256) := TMP_78(uint256)""];
14->15;
15[label=""Node Type: RETURN 15

EXPRESSION:
(percentage,dayzmount / ethExchuangeRate,profit,user.amountTotal / ethExchuangeRate,user.lastDate)

IRs:
TMP_79(uint256) = dayzmount / ethExchuangeRate
REF_24(uint256) -> user.amountTotal
TMP_80(uint256) = REF_24 / ethExchuangeRate
REF_25(uint256) -> user.lastDate
RETURN percentage,TMP_79,profit,TMP_80,REF_25""];
}
",0,1,0,0,"user = miners[msg.sender];_amuont = user.mining;_amountTotal = user.amountTotal;_amuont == 0;percentage = 0;percentage = 100 - (_amountTotal * 100 / _amuont * 100 / 730);;_lastDate = user.lastDate;dayzmount = _amuont / 100;depreciation = (now - _lastDate) / depreciationTime;require(bool,string)(depreciation > 0,Less than 1 day of earnings);Bebday = _amuont * depreciation / 100;sumethbos = Bebday;profit = sumethbos / ethExchuangeRate;(percentage,dayzmount / ethExchuangeRate,profit,user.amountTotal / ethExchuangeRate,user.lastDate)"
./0xf2a95300326adf582a43b63218742e4528f82b01_ext.sol,MultiSend.dropCoins,22,30,"TMP_1(bool) = msg.sender == _multiSendOwner,TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1),amount(uint256) := tokens(uint256),i(uint256) := 0(uint256),REF_0 -> LENGTH dests,TMP_3(bool) = i < REF_0,CONDITION TMP_3,REF_2(address) -> dests[i],TMP_4(bool) = HIGH_LEVEL_CALL, dest:_ERC20Contract(TokenERC20), function:transferFrom, arguments:['_multiSendOwner', 'REF_2', 'amount']  ,i(uint256) = i + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == _multiSendOwner)

IRs:
TMP_1(bool) = msg.sender == _multiSendOwner
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = tokens

IRs:
amount(uint256) := tokens(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: BEGIN_LOOP 4
""];
4->5;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < dests.length

IRs:
REF_0 -> LENGTH dests
TMP_3(bool) = i < REF_0
CONDITION TMP_3""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
_ERC20Contract.transferFrom(_multiSendOwner,dests[i],amount)

IRs:
REF_2(address) -> dests[i]
TMP_4(bool) = HIGH_LEVEL_CALL, dest:_ERC20Contract(TokenERC20), function:transferFrom, arguments:['_multiSendOwner', 'REF_2', 'amount']  ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
i += 1

IRs:
i(uint256) = i + 1""];
7->5;
8[label=""Node Type: END_LOOP 8
""];
}
",0,1,0,0,"require(bool)(msg.sender == _multiSendOwner);amount = tokens;i = 0;;i < dests.length;_ERC20Contract.transferFrom(_multiSendOwner,dests[i],amount);;i += 1"
./0x848bcb77c97d449312ece071cd999e5f0d30f849_ext.sol,TokenMCT.burnFrom,148,163,"REF_19(uint256) -> balanceOf[_from],TMP_41(bool) = REF_19 >= _value,TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_43(bool) = _value <= REF_21,TMP_44(None) = SOLIDITY_CALL require(bool)(TMP_43),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_41(bool) = REF_19 >= _value
TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_43(bool) = _value <= REF_21
TMP_44(None) = SOLIDITY_CALL require(bool)(TMP_43)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x26fa4ab937bf885d06cfb3eabb89eeef9af1978a_ext.sol,digithothToken.approveAndCall,206,211,"REF_18(mapping(address => uint256)) -> allowed[msg.sender],REF_19(uint256) -> REF_18[spender],REF_19(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_56 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_56(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_18(mapping(address => uint256)) -> allowed[msg.sender]
REF_19(uint256) -> REF_18[spender]
REF_19(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_56 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_56(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xaa6bf83784570ce6e114aec683b6b23ca30cf763_ext.sol,BasicToken.totalSupply,85,87,"TMP_12 = CONVERT 0 to address,REF_0(uint256) -> balances[TMP_12],TMP_13(uint256) = totalSupply_ - REF_0,RETURN TMP_13","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
totalSupply_ - balances[address(0)]

IRs:
TMP_12 = CONVERT 0 to address
REF_0(uint256) -> balances[TMP_12]
TMP_13(uint256) = totalSupply_ - REF_0
RETURN TMP_13""];
}
",0,1,0,0,totalSupply_ - balances[address(0)]
./0x57db9d1890eb580a5ba18926a7c76f7abaa1831d_ext.sol,BdpOwnershipStorage.decrementTokenIdsLength,504,506,"REF_123 -> LENGTH tokenIds,TMP_236(uint256) := REF_123(uint256),REF_123(-> tokenIds) = REF_123 - 1,MODIFIER_CALL, BdpBase.storageAccessControl()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
tokenIds.length --

IRs:
REF_123 -> LENGTH tokenIds
TMP_236(uint256) := REF_123(uint256)
REF_123(-> tokenIds) = REF_123 - 1""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
storageAccessControl()

IRs:
MODIFIER_CALL, BdpBase.storageAccessControl()()""];
2->1;
}
",0,1,0,0,storageAccessControl();tokenIds.length --
./0x17fd666fa0784885fa1afec8ac624d9b7e72b752_ext.sol,FLiK.internalIcoFinished,135,150,"TMP_48(bool) = time > icoTill,CONDITION TMP_48,REF_23(uint256) -> balanceOf[this],unsoldTokens(uint256) := REF_23(uint256),REF_24(uint256) -> balanceOf[owner],REF_24(-> balanceOf) = REF_24 + unsoldTokens,REF_25(uint256) -> balanceOf[this],REF_25(uint256) (->balanceOf) := 0(uint256),Emit Transfer(this,owner,unsoldTokens),Emit IcoFinished(),RETURN True,RETURN False","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
time > icoTill

IRs:
TMP_48(bool) = time > icoTill
CONDITION TMP_48""];
1->2[label=""True""];
1->8[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
unsoldTokens = balanceOf[this]

IRs:
REF_23(uint256) -> balanceOf[this]
unsoldTokens(uint256) := REF_23(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[owner] += unsoldTokens

IRs:
REF_24(uint256) -> balanceOf[owner]
REF_24(-> balanceOf) = REF_24 + unsoldTokens""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[this] = 0

IRs:
REF_25(uint256) -> balanceOf[this]
REF_25(uint256) (->balanceOf) := 0(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(this,owner,unsoldTokens)

IRs:
Emit Transfer(this,owner,unsoldTokens)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
IcoFinished()

IRs:
Emit IcoFinished()""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
false

IRs:
RETURN False""];
}
",0,1,0,0,"time > icoTill;unsoldTokens = balanceOf[this];;balanceOf[owner] += unsoldTokens;balanceOf[this] = 0;Transfer(this,owner,unsoldTokens);IcoFinished();true;false"
./0x53caa71f4a8a2617592fd55f0001a0948a16ec67_ext.sol,TOAB.approveAndCall,47,53,"TMP_16 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_16(tokenRecipient),TMP_17(bool) = INTERNAL_CALL, TOAB.approve(address,uint256)(_spender,_value),CONDITION TMP_17,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_16 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_16(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_17(bool) = INTERNAL_CALL, TOAB.approve(address,uint256)(_spender,_value)
CONDITION TMP_17""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0xbc4976ceaeae6c019f826a1e89a6d9cb1a2970bc_ext.sol,ERC20.transferFrom,48,58,"REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],allowance(uint256) := REF_5(uint256),REF_6(uint256) -> balances[_from],TMP_3(bool) = REF_6 >= _value,TMP_4(bool) = allowance >= _value,TMP_5(bool) = TMP_3 && TMP_4,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_7(uint256) -> balances[_to],REF_7(-> balances) = REF_7 + _value,REF_8(uint256) -> balances[_from],REF_8(-> balances) = REF_8 - _value,TMP_7(bool) = allowance < MAX_UINT256,CONDITION TMP_7,REF_9(mapping(address => uint256)) -> allowed[_from],REF_10(uint256) -> REF_9[msg.sender],REF_10(-> allowed) = REF_10 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
allowance = allowed[_from][msg.sender]

IRs:
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
allowance(uint256) := REF_5(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] >= _value && allowance >= _value)

IRs:
REF_6(uint256) -> balances[_from]
TMP_3(bool) = REF_6 >= _value
TMP_4(bool) = allowance >= _value
TMP_5(bool) = TMP_3 && TMP_4
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_7(uint256) -> balances[_to]
REF_7(-> balances) = REF_7 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] -= _value

IRs:
REF_8(uint256) -> balances[_from]
REF_8(-> balances) = REF_8 - _value""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
allowance < MAX_UINT256

IRs:
TMP_7(bool) = allowance < MAX_UINT256
CONDITION TMP_7""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_9(mapping(address => uint256)) -> allowed[_from]
REF_10(uint256) -> REF_9[msg.sender]
REF_10(-> allowed) = REF_10 - _value""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: RETURN 10

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowance = allowed[_from][msg.sender];require(bool)(balances[_from] >= _value && allowance >= _value);balances[_to] += _value;balances[_from] -= _value;allowance < MAX_UINT256;allowed[_from][msg.sender] -= _value;;Transfer(_from,_to,_value);true;success"
./0x37eba68380f5a549532f658244f82619ac733c03_ext.sol,VOCC_I042_20181211.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0xf47cd932ee150f60cd611c3cfdba51bd33b27ad1_ext.sol,BurnToken.burn,48,54,"REF_30(uint256) -> balanceOf[msg.sender],TMP_34(bool) = REF_30 >= _value,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),REF_31(uint256) -> balanceOf[msg.sender],REF_31(-> balanceOf) = REF_31 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_30(uint256) -> balanceOf[msg.sender]
TMP_34(bool) = REF_30 >= _value
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_31(uint256) -> balanceOf[msg.sender]
REF_31(-> balanceOf) = REF_31 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x5adf3e3ba4a8f3f4cf80f9c3bd0eea7cc562877e_ext.sol,StandardToken.transferFrom,58,68,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x52553a82adbc45eda6af687f9b5246fc51863b50_ext.sol,GlobalCashChain._transfer,45,61,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xf1657ae4204d6fc6166833f29447048d0c3ff7e8_ext.sol,LXB.transfer,28,34,"REF_1(uint256) -> balances[msg.sender],TMP_0(bool) = REF_1 >= _value,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_2(uint256) -> balances[msg.sender],REF_2(-> balances) = REF_2 - _value,REF_3(uint256) -> balances[_to],REF_3(-> balances) = REF_3 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_0(bool) = REF_1 >= _value
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_2(uint256) -> balances[msg.sender]
REF_2(-> balances) = REF_2 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_3(uint256) -> balances[_to]
REF_3(-> balances) = REF_3 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0x6d2e76213615925c5fc436565b5ee788ee0e86dc_ext.sol,AccessControl.removeSERAPHIM,38,43,"REF_2(bool) -> seraphims[_oldSeraphim],TMP_2(bool) = REF_2 == True,CONDITION TMP_2,REF_3(bool) -> seraphims[_oldSeraphim],REF_3(bool) (->seraphims) := False(bool),totalSeraphims(uint16) = totalSeraphims - 1,MODIFIER_CALL, AccessControl.onlyCREATOR()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
seraphims[_oldSeraphim] == true

IRs:
REF_2(bool) -> seraphims[_oldSeraphim]
TMP_2(bool) = REF_2 == True
CONDITION TMP_2""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
seraphims[_oldSeraphim] = false

IRs:
REF_3(bool) -> seraphims[_oldSeraphim]
REF_3(bool) (->seraphims) := False(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSeraphims -= 1

IRs:
totalSeraphims(uint16) = totalSeraphims - 1""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyCREATOR()

IRs:
MODIFIER_CALL, AccessControl.onlyCREATOR()()""];
5->1;
}
",0,1,0,0,onlyCREATOR();seraphims[_oldSeraphim] == true;seraphims[_oldSeraphim] = false;;totalSeraphims -= 1
./0xed19698c0abde8635413ae7ad7224df6ee30bf22_ext.sol,ImmortalToken.approveAndCall,91,95,"TMP_46(bool) = INTERNAL_CALL, ImmortalToken.approve(address,uint256)(_spender,_value),TMP_47 = UnaryType.BANG TMP_46 ,CONDITION TMP_47,RETURN False,TMP_48 = CONVERT _spender to TokenNotifier,HIGH_LEVEL_CALL, dest:TMP_48(TokenNotifier), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
! approve(_spender,_value)

IRs:
TMP_46(bool) = INTERNAL_CALL, ImmortalToken.approve(address,uint256)(_spender,_value)
TMP_47 = UnaryType.BANG TMP_46 
CONDITION TMP_47""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
TokenNotifier(_spender).receiveApproval(msg.sender,_value,this,_extraData)

IRs:
TMP_48 = CONVERT _spender to TokenNotifier
HIGH_LEVEL_CALL, dest:TMP_48(TokenNotifier), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"! approve(_spender,_value);false;;TokenNotifier(_spender).receiveApproval(msg.sender,_value,this,_extraData);true;success"
./0x8564e222115248d10593cf4a6719fa6d82194e62_ext.sol,ITube.approveAndCall,204,209,"REF_18(mapping(address => uint256)) -> allowed[msg.sender],REF_19(uint256) -> REF_18[spender],REF_19(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_18(mapping(address => uint256)) -> allowed[msg.sender]
REF_19(uint256) -> REF_18[spender]
REF_19(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xdb18bf96d5b00fe57dbfcd42b48e280624670f90_ext.sol,WillTestament.approveAndCall,195,200,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xd29decbfd29766d8aba8215587f915162c5bd8d8_ext.sol,TokenERC20.burn,154,160,"REF_17(uint256) -> balanceOf[msg.sender],TMP_28(bool) = REF_17 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_28(bool) = REF_17 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x3482665b52c01076ef4939a0089a9b62222fe824_ext.sol,BtcSweetCoin.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0xe1291032766b81488dc565479503a103489f78d7_ext.sol,x32323.initialize,58,77,"REF_2(bool) -> initialized[_address],TMP_5 = UnaryType.BANG REF_2 ,CONDITION TMP_5,REF_3(bool) -> initialized[_address],REF_3(bool) (->initialized) := True(bool),TMP_6(bool) = totalSupply < airdrop1,CONDITION TMP_6,REF_4(uint256) -> balanceOf[_address],REF_4(-> balanceOf) = REF_4 + 20,totalSupply(uint256) = totalSupply + 20,TMP_7(bool) = airdrop1 <= totalSupply,TMP_8(bool) = totalSupply < airdrop2,TMP_9(bool) = TMP_7 && TMP_8,CONDITION TMP_9,REF_5(uint256) -> balanceOf[_address],REF_5(-> balanceOf) = REF_5 + 8,totalSupply(uint256) = totalSupply + 8,TMP_10(bool) = airdrop2 <= totalSupply,TMP_11(uint256) = airdrop3 - 3,TMP_12(bool) = totalSupply <= TMP_11,TMP_13(bool) = TMP_10 && TMP_12,CONDITION TMP_13,REF_6(uint256) -> balanceOf[_address],REF_6(-> balanceOf) = REF_6 + 3,totalSupply(uint256) = totalSupply + 3,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
! initialized[_address]

IRs:
REF_2(bool) -> initialized[_address]
TMP_5 = UnaryType.BANG REF_2 
CONDITION TMP_5""];
1->2[label=""True""];
1->15[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
initialized[_address] = true

IRs:
REF_3(bool) -> initialized[_address]
REF_3(bool) (->initialized) := True(bool)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
totalSupply < airdrop1

IRs:
TMP_6(bool) = totalSupply < airdrop1
CONDITION TMP_6""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[_address] += 20

IRs:
REF_4(uint256) -> balanceOf[_address]
REF_4(-> balanceOf) = REF_4 + 20""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply += 20

IRs:
totalSupply(uint256) = totalSupply + 20""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
airdrop1 <= totalSupply && totalSupply < airdrop2

IRs:
TMP_7(bool) = airdrop1 <= totalSupply
TMP_8(bool) = totalSupply < airdrop2
TMP_9(bool) = TMP_7 && TMP_8
CONDITION TMP_9""];
7->8[label=""True""];
7->10[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balanceOf[_address] += 8

IRs:
REF_5(uint256) -> balanceOf[_address]
REF_5(-> balanceOf) = REF_5 + 8""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
totalSupply += 8

IRs:
totalSupply(uint256) = totalSupply + 8""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
airdrop2 <= totalSupply && totalSupply <= airdrop3 - 3

IRs:
TMP_10(bool) = airdrop2 <= totalSupply
TMP_11(uint256) = airdrop3 - 3
TMP_12(bool) = totalSupply <= TMP_11
TMP_13(bool) = TMP_10 && TMP_12
CONDITION TMP_13""];
11->12[label=""True""];
11->14[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
balanceOf[_address] += 3

IRs:
REF_6(uint256) -> balanceOf[_address]
REF_6(-> balanceOf) = REF_6 + 3""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
totalSupply += 3

IRs:
totalSupply(uint256) = totalSupply + 3""];
13->14;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: RETURN 16

EXPRESSION:
true

IRs:
RETURN True""];
17[label=""Node Type: RETURN 17

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,! initialized[_address];initialized[_address] = true;;totalSupply < airdrop1;balanceOf[_address] += 20;;totalSupply += 20;airdrop1 <= totalSupply && totalSupply < airdrop2;balanceOf[_address] += 8;;totalSupply += 8;airdrop2 <= totalSupply && totalSupply <= airdrop3 - 3;balanceOf[_address] += 3;;totalSupply += 3;true;success
./0x512b4e460fc59123e334c9c74344c4e94dc6389d_ext.sol,StandardToken.transfer,44,51,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x34570cf88db31d4c518dee6057ff78e895dd80f1_ext.sol,IDRT.mintToken,132,137,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x4cee97ddd88f0bec86dd4b4163ca499a9790c3df_ext.sol,Raven.approveAndCall,204,209,"REF_18(mapping(address => uint256)) -> allowed[msg.sender],REF_19(uint256) -> REF_18[spender],REF_19(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_18(mapping(address => uint256)) -> allowed[msg.sender]
REF_19(uint256) -> REF_18[spender]
REF_19(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x482f35aba9fb3dc1c4942dacb29b9a22cb648482_ext.sol,NAST._transfer,41,57,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x0f2a1a06024f6d2ceb2adf937732f9029ca97045_ext.sol,Capital.getInvestorDividendsAmount,109,112,"REF_32(Capital.Investor) -> investors[addr],REF_33(uint256) -> REF_32.deposit,REF_34(Capital.Investor) -> investors[addr],REF_35(uint256) -> REF_34.blockNumber,TMP_38(uint256) = block.number - REF_35,TMP_39(uint256) = TMP_38 * PER_BLOCK,TMP_40(uint256) = REF_33 * TMP_39,TMP_41(uint256) = TMP_40 / 10000000,amount(uint256) := TMP_41(uint256),RETURN amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
amount = ((investors[addr].deposit * ((block.number - investors[addr].blockNumber) * PER_BLOCK)) / 10000000)

IRs:
REF_32(Capital.Investor) -> investors[addr]
REF_33(uint256) -> REF_32.deposit
REF_34(Capital.Investor) -> investors[addr]
REF_35(uint256) -> REF_34.blockNumber
TMP_38(uint256) = block.number - REF_35
TMP_39(uint256) = TMP_38 * PER_BLOCK
TMP_40(uint256) = REF_33 * TMP_39
TMP_41(uint256) = TMP_40 / 10000000
amount(uint256) := TMP_41(uint256)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
amount

IRs:
RETURN amount""];
}
",0,1,0,0,amount = ((investors[addr].deposit * ((block.number - investors[addr].blockNumber) * PER_BLOCK)) / 10000000);amount
./0x0180ec945191fda23c52b1d05eec64a2e3f68781_ext.sol,BnsPresale.sendRefund,132,142,"REF_8(uint256) -> balances[msg.sender],REF_9(uint256) = SOLIDITY_CALL balance(address)(this),TMP_20([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E329ADC0>]) = REF_9 - msg.value,TMP_21(uint256) = INTERNAL_CALL, BnsPresale.min(uint256,uint256)(REF_8,TMP_20),amount_to_refund(uint256) := TMP_21(uint256),REF_10(uint256) -> balances[msg.sender],REF_10(-> balances) = REF_10 - amount_to_refund,total_refunded(uint256) = total_refunded + amount_to_refund,TMP_22(uint256) = amount_to_refund + msg.value,Transfer dest:msg.sender value:TMP_22,MODIFIER_CALL, BnsPresale.tokenHoldersOnly()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
amount_to_refund = min(balances[msg.sender],this.balance - msg.value)

IRs:
REF_8(uint256) -> balances[msg.sender]
REF_9(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_20([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E329ADC0>]) = REF_9 - msg.value
TMP_21(uint256) = INTERNAL_CALL, BnsPresale.min(uint256,uint256)(REF_8,TMP_20)
amount_to_refund(uint256) := TMP_21(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= amount_to_refund

IRs:
REF_10(uint256) -> balances[msg.sender]
REF_10(-> balances) = REF_10 - amount_to_refund""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
total_refunded += amount_to_refund

IRs:
total_refunded(uint256) = total_refunded + amount_to_refund""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(amount_to_refund + msg.value)

IRs:
TMP_22(uint256) = amount_to_refund + msg.value
Transfer dest:msg.sender value:TMP_22""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
tokenHoldersOnly()

IRs:
MODIFIER_CALL, BnsPresale.tokenHoldersOnly()()""];
5->1;
}
",0,1,1,0,"tokenHoldersOnly();amount_to_refund = min(balances[msg.sender],this.balance - msg.value);balances[msg.sender] -= amount_to_refund;total_refunded += amount_to_refund;msg.sender.transfer(amount_to_refund + msg.value)"
./0x7897ed74a2448c6d539b64c8b3c9b42fc19abc1f_ext.sol,Hourglass.dividendsOf,483,489,"REF_36(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_65(uint256) = profitPerShare_ * REF_36,TMP_66 = CONVERT TMP_65 to int256,REF_37(int256) -> payoutsTo_[_customerAddress],TMP_67(int256) = TMP_66 - REF_37,TMP_68 = CONVERT TMP_67 to uint256,TMP_69(uint256) = TMP_68 / magnitude,RETURN TMP_69","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_36(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_65(uint256) = profitPerShare_ * REF_36
TMP_66 = CONVERT TMP_65 to int256
REF_37(int256) -> payoutsTo_[_customerAddress]
TMP_67(int256) = TMP_66 - REF_37
TMP_68 = CONVERT TMP_67 to uint256
TMP_69(uint256) = TMP_68 / magnitude
RETURN TMP_69""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x880016750db7d4b040a0d9b15aad966fa47cfea4_ext.sol,CCD_KOHLE_7_20190411.transferFrom,42,54,"REF_6(uint256) -> balanceOf[from],TMP_6(bool) = value <= REF_6,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_7(mapping(address => uint256)) -> allowance[from],REF_8(uint256) -> REF_7[msg.sender],TMP_8(bool) = value <= REF_8,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_9(uint256) -> balanceOf[from],REF_9(-> balanceOf) = REF_9 - value,REF_10(uint256) -> balanceOf[to],REF_10(-> balanceOf) = REF_10 + value,REF_11(mapping(address => uint256)) -> allowance[from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowance) = REF_12 - value,Emit Transfer(from,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(value <= balanceOf[from])

IRs:
REF_6(uint256) -> balanceOf[from]
TMP_6(bool) = value <= REF_6
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value <= allowance[from][msg.sender])

IRs:
REF_7(mapping(address => uint256)) -> allowance[from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_8(bool) = value <= REF_8
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[from] -= value

IRs:
REF_9(uint256) -> balanceOf[from]
REF_9(-> balanceOf) = REF_9 - value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[to] += value

IRs:
REF_10(uint256) -> balanceOf[to]
REF_10(-> balanceOf) = REF_10 + value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allowance[from][msg.sender] -= value

IRs:
REF_11(mapping(address => uint256)) -> allowance[from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowance) = REF_12 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(value <= balanceOf[from]);require(bool)(value <= allowance[from][msg.sender]);balanceOf[from] -= value;balanceOf[to] += value;allowance[from][msg.sender] -= value;Transfer(from,to,value);true;success"
./0x74028170d74751878228cda221fd0ac42a830921_ext.sol,EncryptedToken.mintToken,135,140,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x29946bc47b8e8a64562816bd6c62e9aa023dfb92_ext.sol,GHANIANCIDIDIGITALTETHER.burn,74,80,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x887e1988f7d697df22aea1207a5e1831ad3065ef_ext.sol,TokenLayer.createToken,277,305,"TMP_113(bool) = _price > 0,TMP_114(None) = SOLIDITY_CALL require(bool)(TMP_113),TMP_115(bool) = INTERNAL_CALL, TokenLayer._addressNotNull(address)(_owner),TMP_116(None) = SOLIDITY_CALL require(bool)(TMP_115),TMP_117 = CONVERT _tokenId to uint32,TMP_118 = CONVERT TMP_117 to uint256,TMP_119(bool) = _tokenId == TMP_118,TMP_120(None) = SOLIDITY_CALL require(bool)(TMP_119),TMP_121(bool) = INTERNAL_CALL, TokenLayer.exists(uint256)(_tokenId),TMP_122 = UnaryType.BANG TMP_121 ,TMP_123(None) = SOLIDITY_CALL require(bool)(TMP_122),TMP_124(uint256) := totalTokens(uint256),totalTokens(uint256) = totalTokens + 1,TMP_125(TokenLayer.Token) = new Token(True,0,_owner,_metadata,_name,block.number,_parentId,_price),_token(TokenLayer.Token) := TMP_125(TokenLayer.Token),REF_33(TokenLayer.Token) -> tokenIndexToToken[_tokenId],REF_33(TokenLayer.Token) (->tokenIndexToToken) := _token(TokenLayer.Token),Emit TokenCreated(_tokenId,_name,_parentId,_owner),TMP_127 = CONVERT 0 to address,INTERNAL_CALL, TokenLayer._transfer(address,address,uint256)(TMP_127,_owner,_tokenId),MODIFIER_CALL, Manageable.onlyAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_price > 0)

IRs:
TMP_113(bool) = _price > 0
TMP_114(None) = SOLIDITY_CALL require(bool)(TMP_113)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_addressNotNull(_owner))

IRs:
TMP_115(bool) = INTERNAL_CALL, TokenLayer._addressNotNull(address)(_owner)
TMP_116(None) = SOLIDITY_CALL require(bool)(TMP_115)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_tokenId == uint256(uint32(_tokenId)))

IRs:
TMP_117 = CONVERT _tokenId to uint32
TMP_118 = CONVERT TMP_117 to uint256
TMP_119(bool) = _tokenId == TMP_118
TMP_120(None) = SOLIDITY_CALL require(bool)(TMP_119)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(! exists(_tokenId))

IRs:
TMP_121(bool) = INTERNAL_CALL, TokenLayer.exists(uint256)(_tokenId)
TMP_122 = UnaryType.BANG TMP_121 
TMP_123(None) = SOLIDITY_CALL require(bool)(TMP_122)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalTokens ++

IRs:
TMP_124(uint256) := totalTokens(uint256)
totalTokens(uint256) = totalTokens + 1""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
_token = Token({name:_name,parentId:_parentId,exists:true,price:_price,owner:_owner,approved:0,lastBlock:block.number,metadata:_metadata})

IRs:
TMP_125(TokenLayer.Token) = new Token(True,0,_owner,_metadata,_name,block.number,_parentId,_price)
_token(TokenLayer.Token) := TMP_125(TokenLayer.Token)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokenIndexToToken[_tokenId] = _token

IRs:
REF_33(TokenLayer.Token) -> tokenIndexToToken[_tokenId]
REF_33(TokenLayer.Token) (->tokenIndexToToken) := _token(TokenLayer.Token)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
TokenCreated(_tokenId,_name,_parentId,_owner)

IRs:
Emit TokenCreated(_tokenId,_name,_parentId,_owner)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
_transfer(address(0),_owner,_tokenId)

IRs:
TMP_127 = CONVERT 0 to address
INTERNAL_CALL, TokenLayer._transfer(address,address,uint256)(TMP_127,_owner,_tokenId)""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Manageable.onlyAdmin()()""];
10->1;
}
",0,1,0,0,"onlyAdmin();require(bool)(_price > 0);require(bool)(_addressNotNull(_owner));require(bool)(_tokenId == uint256(uint32(_tokenId)));require(bool)(! exists(_tokenId));totalTokens ++;_token = Token({name:_name,parentId:_parentId,exists:true,price:_price,owner:_owner,approved:0,lastBlock:block.number,metadata:_metadata});tokenIndexToToken[_tokenId] = _token;TokenCreated(_tokenId,_name,_parentId,_owner);_transfer(address(0),_owner,_tokenId)"
./0x37eb3cb268a0dd1bc2c383296fe34f58c5b5db8b_ext.sol,OpenAddressLottery.participate,39,55,"REF_0(bool) -> winner[msg.sender],TMP_3(bool) = REF_0 == False,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),TMP_5(uint256) = INTERNAL_CALL, OpenAddressLottery.luckyNumberOfAddress(address)(msg.sender),TMP_6(bool) = TMP_5 == LuckyNumber,CONDITION TMP_6,REF_1(bool) -> winner[msg.sender],REF_1(bool) (->winner) := True(bool),TMP_7(uint256) = msg.value * 7,win(uint256) := TMP_7(uint256),REF_2(uint256) = SOLIDITY_CALL balance(address)(this),TMP_8(bool) = win > REF_2,CONDITION TMP_8,REF_3(uint256) = SOLIDITY_CALL balance(address)(this),win(uint256) := REF_3([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B76B20D0>]),Transfer dest:msg.sender value:win,TMP_10(uint256) = block.number - lastReseed,TMP_11(bool) = TMP_10 > 1000,CONDITION TMP_11,TMP_12 = CONVERT block.coinbase to uint256,TMP_13(OpenAddressLottery.SeedComponents) = new SeedComponents(TMP_12,block.difficulty,block.gaslimit,block.timestamp),INTERNAL_CALL, OpenAddressLottery.reseed(OpenAddressLottery.SeedComponents)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(winner[msg.sender] == false)

IRs:
REF_0(bool) -> winner[msg.sender]
TMP_3(bool) = REF_0 == False
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
luckyNumberOfAddress(msg.sender) == LuckyNumber

IRs:
TMP_5(uint256) = INTERNAL_CALL, OpenAddressLottery.luckyNumberOfAddress(address)(msg.sender)
TMP_6(bool) = TMP_5 == LuckyNumber
CONDITION TMP_6""];
2->3[label=""True""];
2->9[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
winner[msg.sender] = true

IRs:
REF_1(bool) -> winner[msg.sender]
REF_1(bool) (->winner) := True(bool)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
win = msg.value * 7

IRs:
TMP_7(uint256) = msg.value * 7
win(uint256) := TMP_7(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
win > this.balance

IRs:
REF_2(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_8(bool) = win > REF_2
CONDITION TMP_8""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
win = this.balance

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
win(uint256) := REF_3([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B76B20D0>])""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
msg.sender.transfer(win)

IRs:
Transfer dest:msg.sender value:win""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
block.number - lastReseed > 1000

IRs:
TMP_10(uint256) = block.number - lastReseed
TMP_11(bool) = TMP_10 > 1000
CONDITION TMP_11""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
reseed(SeedComponents(uint256(block.coinbase),block.difficulty,block.gaslimit,block.timestamp))

IRs:
TMP_12 = CONVERT block.coinbase to uint256
TMP_13(OpenAddressLottery.SeedComponents) = new SeedComponents(TMP_12,block.difficulty,block.gaslimit,block.timestamp)
INTERNAL_CALL, OpenAddressLottery.reseed(OpenAddressLottery.SeedComponents)(TMP_13)""];
11->12;
12[label=""Node Type: END_IF 12
""];
}
",0,1,1,0,"require(bool)(winner[msg.sender] == false);luckyNumberOfAddress(msg.sender) == LuckyNumber;winner[msg.sender] = true;;win = msg.value * 7;win > this.balance;win = this.balance;;msg.sender.transfer(win);block.number - lastReseed > 1000;reseed(SeedComponents(uint256(block.coinbase),block.difficulty,block.gaslimit,block.timestamp));"
./0xf23fd8e6c2eda7e4d2a5638c8256bd516f7c6a73_ext.sol,XPortDigitals.distributeXPDS,71,80,"i(uint256) := 0(uint256),REF_1 -> LENGTH addresses,TMP_2(bool) = i < REF_1,CONDITION TMP_2,REF_2(address) -> addresses[i],TMP_3(uint256) = INTERNAL_CALL, XPortDigitals.getEthBalance(address)(REF_2),TMP_4(bool) = TMP_3 < _ethbal,CONDITION TMP_4,REF_3(uint256) -> balances[owner],REF_3(-> balances) = REF_3 - _value,REF_4(address) -> addresses[i],REF_5(uint256) -> balances[REF_4],REF_5(-> balances) = REF_5 + _value,REF_6(address) -> addresses[i],Emit Transfer(owner,REF_6,_value),TMP_6(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, XPortDigitals.onlyOwner()(),MODIFIER_CALL, XPortDigitals.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addresses.length

IRs:
REF_1 -> LENGTH addresses
TMP_2(bool) = i < REF_1
CONDITION TMP_2""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
getEthBalance(addresses[i]) < _ethbal

IRs:
REF_2(address) -> addresses[i]
TMP_3(uint256) = INTERNAL_CALL, XPortDigitals.getEthBalance(address)(REF_2)
TMP_4(bool) = TMP_3 < _ethbal
CONDITION TMP_4""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: CONTINUE 6
""];
6->11;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[owner] -= _value

IRs:
REF_3(uint256) -> balances[owner]
REF_3(-> balances) = REF_3 - _value""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
balances[addresses[i]] += _value

IRs:
REF_4(address) -> addresses[i]
REF_5(uint256) -> balances[REF_4]
REF_5(-> balances) = REF_5 + _value""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Transfer(owner,addresses[i],_value)

IRs:
REF_6(address) -> addresses[i]
Emit Transfer(owner,REF_6,_value)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_6(uint256) := i(uint256)
i(uint256) = i + 1""];
11->4;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, XPortDigitals.onlyOwner()()""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, XPortDigitals.canDistr()()""];
13->3;
}
",0,1,0,0,"onlyOwner();;i < addresses.length;;i = 0;getEthBalance(addresses[i]) < _ethbal;;;i ++;balances[owner] -= _value;balances[addresses[i]] += _value;Transfer(owner,addresses[i],_value);canDistr()"
./0xd2d6158683aee4cc838067727209a0aaf4359de3_ext.sol,AddressWhitelist.removeFromWhitelist,78,87,"i(uint256) := 0(uint256),REF_7 -> LENGTH addresses,TMP_17(bool) = i < REF_7,CONDITION TMP_17,REF_8(address) -> addresses[i],REF_9(bool) -> whitelisted[REF_8],CONDITION REF_9,REF_10(address) -> addresses[i],REF_11(bool) -> whitelisted[REF_10],REF_11(bool) (->whitelisted) := False(bool),REF_12(address) -> addresses[i],Emit LogWhitelistRemove(REF_12),TMP_19(uint256) := i(uint256),i(uint256) = i + 1,RETURN True,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
2->10;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addresses.length

IRs:
REF_7 -> LENGTH addresses
TMP_17(bool) = i < REF_7
CONDITION TMP_17""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
whitelisted[addresses[i]]

IRs:
REF_8(address) -> addresses[i]
REF_9(bool) -> whitelisted[REF_8]
CONDITION REF_9""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
whitelisted[addresses[i]] = false

IRs:
REF_10(address) -> addresses[i]
REF_11(bool) -> whitelisted[REF_10]
REF_11(bool) (->whitelisted) := False(bool)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
LogWhitelistRemove(addresses[i])

IRs:
REF_12(address) -> addresses[i]
Emit LogWhitelistRemove(REF_12)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_19(uint256) := i(uint256)
i(uint256) = i + 1""];
9->4;
10[label=""Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
11->3;
}
",0,1,0,0,onlyOwner();;i < addresses.length;;true;i = 0;whitelisted[addresses[i]];whitelisted[addresses[i]] = false;;LogWhitelistRemove(addresses[i]);i ++
./0x6d2cfe7c64087b1d6d2f7e77039de64dcd232ced_ext.sol,ERC777BaseToken.defaultOperators,316,316,RETURN mDefaultOperators,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
mDefaultOperators

IRs:
RETURN mDefaultOperators""];
}
",0,1,0,0,mDefaultOperators
./0x849919acec8627dde44da59e1a9737985d022b9d_ext.sol,TokenERC20.burn,145,151,"REF_17(uint256) -> balanceOf[msg.sender],TMP_25(bool) = REF_17 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_25(bool) = REF_17 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xf213d198b68b10654c63a9ed05a045e1d4a50f9f_ext.sol,FootballerBase._randMod,158,162,"TMP_45(uint256) := randNonce(uint256),randNonce(uint256) = randNonce + 1,TMP_46(uint256) = _max - _min,modulus(uint256) := TMP_46(uint256),TMP_47(bytes32) = SOLIDITY_CALL keccak256()(now,msg.sender,randNonce),TMP_48 = CONVERT TMP_47 to uint256,TMP_49(uint256) = TMP_48 % modulus,TMP_50(uint256) = TMP_49 + _min,RETURN TMP_50","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
randNonce ++

IRs:
TMP_45(uint256) := randNonce(uint256)
randNonce(uint256) = randNonce + 1""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
modulus = _max - _min

IRs:
TMP_46(uint256) = _max - _min
modulus(uint256) := TMP_46(uint256)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
uint256(keccak256()(now,msg.sender,randNonce)) % modulus + _min

IRs:
TMP_47(bytes32) = SOLIDITY_CALL keccak256()(now,msg.sender,randNonce)
TMP_48 = CONVERT TMP_47 to uint256
TMP_49(uint256) = TMP_48 % modulus
TMP_50(uint256) = TMP_49 + _min
RETURN TMP_50""];
}
",0,1,0,0,"randNonce ++;modulus = _max - _min;uint256(keccak256()(now,msg.sender,randNonce)) % modulus + _min"
./0x319fe5e87a37967a70c21598090c1f19ace5d1f2_ext.sol,BICKCOIN.burn,133,139,"REF_17(uint256) -> balanceOf[msg.sender],TMP_23(bool) = REF_17 >= _value,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_23(bool) = REF_17 >= _value
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x203616a35d987b144fa6727e4f878add71401e91_ext.sol,StandardToken.transferFrom,56,66,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x5acd19b9c91e596b1f062f18e3d02da7ed8d1e50_ext.sol,BTClite.drop,150,167,"TMP_71(uint256) = 10 ** 8,TMP_72(uint256) = amount * TMP_71,amt(uint256) := TMP_72(uint256),TMP_73(bool) = amt > 0,TMP_74(None) = SOLIDITY_CALL require(bool)(TMP_73),TMP_75(bool) = amt <= SUPPLY_CAP,TMP_76(None) = SOLIDITY_CALL require(bool)(TMP_75),REF_83 -> LENGTH addresses,Emit PerformingDrop(REF_83),REF_84 -> LENGTH addresses,TMP_78(bool) = REF_84 <= 1000,TMP_79(None) = SOLIDITY_CALL assert(bool)(TMP_78),REF_85(uint256) -> balances[owner],REF_86 -> LENGTH addresses,TMP_80(uint256) = amt * REF_86,TMP_81(bool) = REF_85 >= TMP_80,TMP_82(None) = SOLIDITY_CALL assert(bool)(TMP_81),i(uint256) := 0(uint256),REF_87 -> LENGTH addresses,TMP_83(bool) = i < REF_87,CONDITION TMP_83,REF_88(address) -> addresses[i],recipient(address) := REF_88(address),TMP_84(bool) = recipient != NULL_ADDRESS,CONDITION TMP_84,REF_89(uint256) -> balances[owner],REF_89(-> balances) = REF_89 - amt,REF_90(uint256) -> balances[recipient],REF_90(-> balances) = REF_90 + amt,Emit Transfer(owner,recipient,amt),TMP_86(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->18;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
amt = amount * 10 ** 8

IRs:
TMP_71(uint256) = 10 ** 8
TMP_72(uint256) = amount * TMP_71
amt(uint256) := TMP_72(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(amt > 0)

IRs:
TMP_73(bool) = amt > 0
TMP_74(None) = SOLIDITY_CALL require(bool)(TMP_73)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(amt <= SUPPLY_CAP)

IRs:
TMP_75(bool) = amt <= SUPPLY_CAP
TMP_76(None) = SOLIDITY_CALL require(bool)(TMP_75)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
PerformingDrop(addresses.length)

IRs:
REF_83 -> LENGTH addresses
Emit PerformingDrop(REF_83)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
assert(bool)(addresses.length <= 1000)

IRs:
REF_84 -> LENGTH addresses
TMP_78(bool) = REF_84 <= 1000
TMP_79(None) = SOLIDITY_CALL assert(bool)(TMP_78)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
assert(bool)(balances[owner] >= amt * addresses.length)

IRs:
REF_85(uint256) -> balances[owner]
REF_86 -> LENGTH addresses
TMP_80(uint256) = amt * REF_86
TMP_81(bool) = REF_85 >= TMP_80
TMP_82(None) = SOLIDITY_CALL assert(bool)(TMP_81)""];
6->9;
7[label=""Node Type: BEGIN_LOOP 7
""];
7->10;
8[label=""Node Type: END_LOOP 8
""];
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
9->7;
10[label=""Node Type: IF_LOOP 10

EXPRESSION:
i < addresses.length

IRs:
REF_87 -> LENGTH addresses
TMP_83(bool) = i < REF_87
CONDITION TMP_83""];
10->11[label=""True""];
10->8[label=""False""];
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
recipient = addresses[i]

IRs:
REF_88(address) -> addresses[i]
recipient(address) := REF_88(address)""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
recipient != NULL_ADDRESS

IRs:
TMP_84(bool) = recipient != NULL_ADDRESS
CONDITION TMP_84""];
12->13[label=""True""];
12->16[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
balances[owner] -= amt

IRs:
REF_89(uint256) -> balances[owner]
REF_89(-> balances) = REF_89 - amt""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
balances[recipient] += amt

IRs:
REF_90(uint256) -> balances[recipient]
REF_90(-> balances) = REF_90 + amt""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
Transfer(owner,recipient,amt)

IRs:
Emit Transfer(owner,recipient,amt)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
i ++

IRs:
TMP_86(uint256) := i(uint256)
i(uint256) = i + 1""];
17->10;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
18->1;
}
",0,1,0,0,"onlyOwner();amt = amount * 10 ** 8;require(bool)(amt > 0);require(bool)(amt <= SUPPLY_CAP);PerformingDrop(addresses.length);assert(bool)(addresses.length <= 1000);assert(bool)(balances[owner] >= amt * addresses.length);i = 0;;i < addresses.length;;recipient = addresses[i];recipient != NULL_ADDRESS;balances[owner] -= amt;;balances[recipient] += amt;Transfer(owner,recipient,amt);i ++"
./0x26fa4ab937bf885d06cfb3eabb89eeef9af1978a_ext.sol,digithothToken.approveAndCall,206,211,"REF_18(mapping(address => uint256)) -> allowed[msg.sender],REF_19(uint256) -> REF_18[spender],REF_19(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_56 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_56(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_18(mapping(address => uint256)) -> allowed[msg.sender]
REF_19(uint256) -> REF_18[spender]
REF_19(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_56 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_56(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x5129bdff6b065ce57cc7e7349ba681a0ac1d00cd_ext.sol,BNCXToken.burn,49,55,"REF_16(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_16 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_17(uint256) -> balanceOf[msg.sender],REF_17(-> balanceOf) = REF_17 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_16(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_16 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
REF_17(-> balanceOf) = REF_17 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x72a2384d0920b6c46f97ebe4c23c092acce485ac_ext.sol,RGEToken.burn,168,176,"TMP_66(bool) = _value > 0,TMP_67(None) = SOLIDITY_CALL require(bool)(TMP_66),REF_39(uint256) -> balances[msg.sender],TMP_68(bool) = REF_39 >= _value,TMP_69(None) = SOLIDITY_CALL require(bool)(TMP_68),REF_40(uint256) -> balances[msg.sender],REF_40(-> balances) = REF_40 - _value,totalSupply(uint256) = totalSupply - _value,TMP_70 = CONVERT 0 to address,Emit Transfer(msg.sender,TMP_70,_value),Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_66(bool) = _value > 0
TMP_67(None) = SOLIDITY_CALL require(bool)(TMP_66)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_39(uint256) -> balances[msg.sender]
TMP_68(bool) = REF_39 >= _value
TMP_69(None) = SOLIDITY_CALL require(bool)(TMP_68)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_40(uint256) -> balances[msg.sender]
REF_40(-> balances) = REF_40 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,address(0),_value)

IRs:
TMP_70 = CONVERT 0 to address
Emit Transfer(msg.sender,TMP_70,_value)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(_value > 0);require(bool)(balances[msg.sender] >= _value);balances[msg.sender] -= _value;totalSupply -= _value;Transfer(msg.sender,address(0),_value);Burn(msg.sender,_value);true;success"
./0x470142a1834438515b757118f322703aba6e1e05_ext.sol,PolicyPalNetworkAirdrop.airDropMultipleAmount,141,162,"i(uint256) := 0(uint256),REF_7 -> LENGTH _recipients,TMP_12(bool) = i < REF_7,CONDITION TMP_12,REF_8(address) -> _recipients[i],recipient(address) := REF_8(address),REF_9(uint256) -> _amounts[i],amount(uint256) := REF_9(uint256),REF_10(bool) -> airdrops[recipient],TMP_13 = UnaryType.BANG REF_10 ,CONDITION TMP_13,TMP_14(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', 'amount']  ,TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14),REF_12(bool) -> airdrops[recipient],REF_12(bool) (->airdrops) := True(bool),TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] ,numDrops(uint256) := TMP_16(uint256),TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', 'amount'] ,dropAmount(uint256) := TMP_17(uint256),Emit TokenDrop(recipient,amount,AIRDROP),TMP_19(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()(),MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalanceMultiple(address[],uint256[])(_recipients,_amounts)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->15;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _recipients.length

IRs:
REF_7 -> LENGTH _recipients
TMP_12(bool) = i < REF_7
CONDITION TMP_12""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
recipient = _recipients[i]

IRs:
REF_8(address) -> _recipients[i]
recipient(address) := REF_8(address)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
amount = _amounts[i]

IRs:
REF_9(uint256) -> _amounts[i]
amount(uint256) := REF_9(uint256)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
! airdrops[recipient]

IRs:
REF_10(bool) -> airdrops[recipient]
TMP_13 = UnaryType.BANG REF_10 
CONDITION TMP_13""];
7->8[label=""True""];
7->13[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(token.transfer(recipient,amount))

IRs:
TMP_14(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', 'amount']  
TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
airdrops[recipient] = true

IRs:
REF_12(bool) -> airdrops[recipient]
REF_12(bool) (->airdrops) := True(bool)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
numDrops = numDrops.add(1)

IRs:
TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] 
numDrops(uint256) := TMP_16(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
dropAmount = dropAmount.add(amount)

IRs:
TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', 'amount'] 
dropAmount(uint256) := TMP_17(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
TokenDrop(recipient,amount,AIRDROP)

IRs:
Emit TokenDrop(recipient,amount,AIRDROP)""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
i ++

IRs:
TMP_19(uint256) := i(uint256)
i(uint256) = i + 1""];
14->4;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()()""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
validBalanceMultiple(_recipients,_amounts)

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalanceMultiple(address[],uint256[])(_recipients,_amounts)""];
16->3;
}
",1,1,0,0,"onlyAdmin();;i < _recipients.length;;i = 0;recipient = _recipients[i];amount = _amounts[i];! airdrops[recipient];assert(bool)(token.transfer(recipient,amount));;airdrops[recipient] = true;numDrops = numDrops.add(1);dropAmount = dropAmount.add(amount);TokenDrop(recipient,amount,AIRDROP);i ++;validBalanceMultiple(_recipients,_amounts)"
./0xd4973b9a96e1030ed260781e36544756249045ce_ext.sol,ERC20Standard.transferFrom,35,41,"REF_4(uint256) -> balances[_from],TMP_7(bool) = REF_4 >= _value,REF_5(mapping(address => uint256)) -> allowed[_from],REF_6(uint256) -> REF_5[msg.sender],TMP_8(bool) = REF_6 >= _value,TMP_9(bool) = TMP_7 && TMP_8,TMP_10(bool) = _value > 0,TMP_11(bool) = TMP_9 && TMP_10,TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11),REF_7(uint256) -> balances[_to],REF_7(-> balances) = REF_7 + _value,REF_8(uint256) -> balances[_from],REF_8(-> balances) = REF_8 - _value,REF_9(mapping(address => uint256)) -> allowed[_from],REF_10(uint256) -> REF_9[msg.sender],REF_10(-> allowed) = REF_10 - _value,Emit Transfer(_from,_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0)

IRs:
REF_4(uint256) -> balances[_from]
TMP_7(bool) = REF_4 >= _value
REF_5(mapping(address => uint256)) -> allowed[_from]
REF_6(uint256) -> REF_5[msg.sender]
TMP_8(bool) = REF_6 >= _value
TMP_9(bool) = TMP_7 && TMP_8
TMP_10(bool) = _value > 0
TMP_11(bool) = TMP_9 && TMP_10
TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_7(uint256) -> balances[_to]
REF_7(-> balances) = REF_7 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_8(uint256) -> balances[_from]
REF_8(-> balances) = REF_8 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_9(mapping(address => uint256)) -> allowed[_from]
REF_10(uint256) -> REF_9[msg.sender]
REF_10(-> allowed) = REF_10 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
}
",0,1,0,0,"require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);balances[_to] += _value;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value)"
./0x2e061fdfbb2c63a43e4490465d3862094b38f394_ext.sol,AxaToken.totalSupply,126,128,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x5b566b473bb0ea8dc0fc6047dd623e5fa3b42307_ext.sol,Beneficial.setOfficialUrl,112,114,"officialUrl(string) := _newOfficialUrl(string),MODIFIER_CALL, Base.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
officialUrl = _newOfficialUrl

IRs:
officialUrl(string) := _newOfficialUrl(string)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Base.onlyOwner()()""];
2->1;
}
",0,1,0,0,onlyOwner();officialUrl = _newOfficialUrl
./0x7220e734c524e8938a1553ae18e3c68aec8bf955_ext.sol,SmsCertifier.get,76,76,"REF_15(SmsCertifier.Certification) -> certs[_who],REF_16(mapping(string => bytes32)) -> REF_15.meta,REF_17(bytes32) -> REF_16[_field],RETURN REF_17","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
certs[_who].meta[_field]

IRs:
REF_15(SmsCertifier.Certification) -> certs[_who]
REF_16(mapping(string => bytes32)) -> REF_15.meta
REF_17(bytes32) -> REF_16[_field]
RETURN REF_17""];
}
",0,1,0,0,certs[_who].meta[_field]
./0xed04927a3849fc9db3f3341a17b7d844a6c551a8_ext.sol,CrowdInvestment.getCap,27,29,"REF_1(uint256) -> perUserInvestments[investor],TMP_7(uint256) = limitPerInvestor - REF_1,REF_2(uint256) -> additionalCaps[investor],TMP_8(uint256) = TMP_7 + REF_2,RETURN TMP_8","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
limitPerInvestor - perUserInvestments[investor] + additionalCaps[investor]

IRs:
REF_1(uint256) -> perUserInvestments[investor]
TMP_7(uint256) = limitPerInvestor - REF_1
REF_2(uint256) -> additionalCaps[investor]
TMP_8(uint256) = TMP_7 + REF_2
RETURN TMP_8""];
}
",0,1,0,0,limitPerInvestor - perUserInvestments[investor] + additionalCaps[investor]
./0x4c4757b23526ba13876f8ef3efe973618266e3e8_ext.sol,UZMINI_KO.NewQuestion,42,49,"TMP_12(bool) = msg.sender == questionSender,TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12),question(string) := _question(string),responseHash(bytes32) := _responseHash(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_12(bool) = msg.sender == questionSender
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
responseHash = _responseHash

IRs:
responseHash(bytes32) := _responseHash(bytes32)""];
}
",0,1,0,0,require(bool)(msg.sender == questionSender);question = _question;responseHash = _responseHash
./0x01eacc3ae59ee7fbbc191d63e8e1ccfdac11628c_ext.sol,FairWin.getUserByinviteCode,350,358,"REF_182(address) -> addressMapping[inviteCode],userAddressCode(address) := REF_182(address),REF_183(FairWin.User) -> userMapping[userAddressCode],user(FairWin.User) := REF_183(FairWin.User),REF_184(bool) -> user.isVaild,CONDITION REF_184,RETURN True,RETURN False","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
userAddressCode = addressMapping[inviteCode]

IRs:
REF_182(address) -> addressMapping[inviteCode]
userAddressCode(address) := REF_182(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
user = userMapping[userAddressCode]

IRs:
REF_183(FairWin.User) -> userMapping[userAddressCode]
user(FairWin.User) := REF_183(FairWin.User)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
user.isVaild

IRs:
REF_184(bool) -> user.isVaild
CONDITION REF_184""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False""];
}
",0,1,0,0,userAddressCode = addressMapping[inviteCode];user = userMapping[userAddressCode];user.isVaild;true;;false
./0x56aca8618b2b4240d609104f31c87183682065e0_ext.sol,hkchain.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x6e3990c89bd13397f3c080500805863275cc85ec_ext.sol,POSV.dividendsOf,466,472,"REF_35(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_68(uint256) = profitPerShare_ * REF_35,TMP_69 = CONVERT TMP_68 to int256,REF_36(int256) -> payoutsTo_[_customerAddress],TMP_70(int256) = TMP_69 - REF_36,TMP_71 = CONVERT TMP_70 to uint256,TMP_72(uint256) = TMP_71 / magnitude,RETURN TMP_72","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_35(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_68(uint256) = profitPerShare_ * REF_35
TMP_69 = CONVERT TMP_68 to int256
REF_36(int256) -> payoutsTo_[_customerAddress]
TMP_70(int256) = TMP_69 - REF_36
TMP_71 = CONVERT TMP_70 to uint256
TMP_72(uint256) = TMP_71 / magnitude
RETURN TMP_72""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x411079f1b50ac2583a458a7cce1d1afdf4f8842e_ext.sol,MSToken.approveAndCall,197,202,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x29946bc47b8e8a64562816bd6c62e9aa023dfb92_ext.sol,GHANIANCIDIDIGITALTETHER._transfer,31,41,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x5833dbb0749887174b254ba4a5df747ff523a905_ext.sol,TokenERC20.burnFrom,137,148,"REF_22(uint256) -> balanceOf[_from],TMP_36(bool) = REF_22 >= _value,TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36),REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],TMP_38(bool) = _value <= REF_24,TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38),REF_25(uint256) -> balanceOf[_from],REF_25(-> balanceOf) = REF_25 - _value,REF_26(mapping(address => uint256)) -> allowance[_from],REF_27(uint256) -> REF_26[msg.sender],REF_27(-> allowance) = REF_27 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_22(uint256) -> balanceOf[_from]
TMP_36(bool) = REF_22 >= _value
TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
TMP_38(bool) = _value <= REF_24
TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_25(uint256) -> balanceOf[_from]
REF_25(-> balanceOf) = REF_25 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_26(mapping(address => uint256)) -> allowance[_from]
REF_27(uint256) -> REF_26[msg.sender]
REF_27(-> allowance) = REF_27 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x53ec8bca4d14737f7ea33415bfe392f32e331b35_ext.sol,SOLUSToken.approveAndCall,204,209,"REF_18(mapping(address => uint256)) -> allowed[msg.sender],REF_19(uint256) -> REF_18[spender],REF_19(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_18(mapping(address => uint256)) -> allowed[msg.sender]
REF_19(uint256) -> REF_18[spender]
REF_19(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x0033fb5561719b8b697b604466d6d39308c58191_ext.sol,EncryptedToken.mintToken,188,193,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x332eeaa966e0d7dcf2c5373b9b9c88f8be2eee15_ext.sol,EGFToken.burnFrom,155,165,"REF_52(uint256) -> balanceOf[_from],TMP_70(bool) = REF_52 >= _value,TMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70),REF_53(mapping(address => uint256)) -> allowed[_from],REF_54(uint256) -> REF_53[msg.sender],TMP_72(bool) = REF_54 >= _value,TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72),totalSupply(uint256) = totalSupply - _value,REF_55(uint256) -> balanceOf[msg.sender],REF_55(-> balanceOf) = REF_55 - _value,REF_56(mapping(address => uint256)) -> allowed[_from],REF_57(uint256) -> REF_56[msg.sender],REF_57(-> allowed) = REF_57 - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_52(uint256) -> balanceOf[_from]
TMP_70(bool) = REF_52 >= _value
TMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(allowed[_from][msg.sender] >= _value)

IRs:
REF_53(mapping(address => uint256)) -> allowed[_from]
REF_54(uint256) -> REF_53[msg.sender]
TMP_72(bool) = REF_54 >= _value
TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_55(uint256) -> balanceOf[msg.sender]
REF_55(-> balanceOf) = REF_55 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_56(mapping(address => uint256)) -> allowed[_from]
REF_57(uint256) -> REF_56[msg.sender]
REF_57(-> allowed) = REF_57 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(allowed[_from][msg.sender] >= _value);totalSupply -= _value;balanceOf[msg.sender] -= _value;allowed[_from][msg.sender] -= _value;Burn(msg.sender,_value);true;success"
./0x8432a5a61cf1cc5ca5bc5ab919d0665427fb513c_ext.sol,IcoToken.sell,315,325,"TMP_168(bool) = _value > 0,TMP_169(None) = SOLIDITY_CALL assert(bool)(TMP_168),TMP_170(bool) = msg.sender == icoContract,TMP_171(None) = SOLIDITY_CALL require(bool)(TMP_170),REF_35(uint256) -> balances[_recipient],REF_35(-> balances) = REF_35 + _value,totalSupply(uint256) = totalSupply + _value,Emit Transfer(0,owner,_value),Emit Transfer(owner,_recipient,_value),RETURN True,MODIFIER_CALL, Pausable.whenNotPaused()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(_value > 0)

IRs:
TMP_168(bool) = _value > 0
TMP_169(None) = SOLIDITY_CALL assert(bool)(TMP_168)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == icoContract)

IRs:
TMP_170(bool) = msg.sender == icoContract
TMP_171(None) = SOLIDITY_CALL require(bool)(TMP_170)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_recipient] += _value

IRs:
REF_35(uint256) -> balances[_recipient]
REF_35(-> balances) = REF_35 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
totalSupply += _value

IRs:
totalSupply(uint256) = totalSupply + _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(0x0,owner,_value)

IRs:
Emit Transfer(0,owner,_value)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(owner,_recipient,_value)

IRs:
Emit Transfer(owner,_recipient,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
8->1;
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"whenNotPaused();assert(bool)(_value > 0);require(bool)(msg.sender == icoContract);balances[_recipient] += _value;totalSupply += _value;Transfer(0x0,owner,_value);Transfer(owner,_recipient,_value);true;success"
./0x1fdedef5c2da1ed9db44d80003a9592dfa18163c_ext.sol,Syndicate.allocateShares,268,273,"TMP_83(bool) = allocation > availableBuyInShares,CONDITION TMP_83,TMP_84(None) = SOLIDITY_CALL revert()(),availableBuyInShares(uint256) = availableBuyInShares - allocation,INTERNAL_CALL, Syndicate.addMember(address)(stakeholderAddress),REF_78(Syndicate.member) -> members[stakeholderAddress],REF_79(uint256) -> REF_78.numShares,REF_79(-> members) = REF_79 + allocation,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: IF 1

EXPRESSION:
allocation > availableBuyInShares

IRs:
TMP_83(bool) = allocation > availableBuyInShares
CONDITION TMP_83""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_84(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
availableBuyInShares -= allocation

IRs:
availableBuyInShares(uint256) = availableBuyInShares - allocation""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
addMember(stakeholderAddress)

IRs:
INTERNAL_CALL, Syndicate.addMember(address)(stakeholderAddress)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
members[stakeholderAddress].numShares += allocation

IRs:
REF_78(Syndicate.member) -> members[stakeholderAddress]
REF_79(uint256) -> REF_78.numShares
REF_79(-> members) = REF_79 + allocation""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->1;
}
",0,1,0,0,onlyOwner();allocation > availableBuyInShares;revert()();;availableBuyInShares -= allocation;addMember(stakeholderAddress);members[stakeholderAddress].numShares += allocation
./0x55c4b50c93a5fa213078f96fbf0834cba17ebc43_ext.sol,Egypt.totalSupply,42,44,"TMP_2 = CONVERT 0 to address,REF_1(uint256) -> balanceOf[TMP_2],TMP_3(uint256) = totalSupply - REF_1,RETURN TMP_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
totalSupply - balanceOf[address(0)]

IRs:
TMP_2 = CONVERT 0 to address
REF_1(uint256) -> balanceOf[TMP_2]
TMP_3(uint256) = totalSupply - REF_1
RETURN TMP_3""];
}
",0,1,0,0,totalSupply - balanceOf[address(0)]
./0x5c591aaa5b18d6411b01c9e6862b155f0433a6c2_ext.sol,PiaoPiaoToken.setLoveUrl,43,46,"loveUrl(string) := _loveUrl(string),RETURN True,MODIFIER_CALL, Ownable.onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
loveUrl = _loveUrl

IRs:
loveUrl(string) := _loveUrl(string)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
3->1;
4[label=""Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,onlyOwner();loveUrl = _loveUrl;true;success
./0xd0059e9d822c471f394ae5974d783e86b2aa0853_ext.sol,StandardToken.transferFrom,75,85,"REF_3(uint256) -> balances[_from],TMP_4(bool) = REF_3 >= _value,REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],TMP_5(bool) = REF_5 >= _value,TMP_6(bool) = TMP_4 && TMP_5,TMP_7(bool) = _value > 0,TMP_8(bool) = TMP_6 && TMP_7,CONDITION TMP_8,REF_6(uint256) -> balances[_to],REF_6(-> balances) = REF_6 + _value,REF_7(uint256) -> balances[_from],REF_7(-> balances) = REF_7 - _value,REF_8(mapping(address => uint256)) -> allowed[_from],REF_9(uint256) -> REF_8[msg.sender],REF_9(-> allowed) = REF_9 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0

IRs:
REF_3(uint256) -> balances[_from]
TMP_4(bool) = REF_3 >= _value
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
TMP_5(bool) = REF_5 >= _value
TMP_6(bool) = TMP_4 && TMP_5
TMP_7(bool) = _value > 0
TMP_8(bool) = TMP_6 && TMP_7
CONDITION TMP_8""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_6(uint256) -> balances[_to]
REF_6(-> balances) = REF_6 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_7(uint256) -> balances[_from]
REF_7(-> balances) = REF_7 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_8(mapping(address => uint256)) -> allowed[_from]
REF_9(uint256) -> REF_8[msg.sender]
REF_9(-> allowed) = REF_9 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0;balances[_to] += _value;false;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true;success"
./0xd294fb1b8b1169dc634017f60d9ca36a5701bd7d_ext.sol,TokenBCCO.burn,128,134,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xc729c50c19d3b2f0049c9eec809b5cc175dbf489_ext.sol,PDGToken._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x039b5649a59967e3e936d7471f9c3700100ee1ab_ext.sol,MyToken.burn,56,62,"REF_6(uint256) -> balanceOf[msg.sender],TMP_9(bool) = REF_6 > _value,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_7(uint256) -> balanceOf[msg.sender],REF_7(-> balanceOf) = REF_7 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] > _value)

IRs:
REF_6(uint256) -> balanceOf[msg.sender]
TMP_9(bool) = REF_6 > _value
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_7(uint256) -> balanceOf[msg.sender]
REF_7(-> balanceOf) = REF_7 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] > _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x036a98e540599dae4a9778335ffabe6ca01ca705_ext.sol,cwallet.setup_key,23,28,"TMP_9(bool) = keyHash == 0,CONDITION TMP_9,TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10),keyHash(bytes32) := TMP_11(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
keyHash == 0x0

IRs:
TMP_9(bool) = keyHash == 0
CONDITION TMP_9""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
keyHash = keccak256()(abi.encodePacked(key))

IRs:
TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10)
keyHash(bytes32) := TMP_11(bytes32)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,1,0,0,keyHash == 0x0;keyHash = keccak256()(abi.encodePacked(key));
./0x02dbe2f315e059743376abcd22ab4908ea9fb02d_ext.sol,ContractReceiver.tokenFallback,65,80,"REF_0(address) -> tkn.sender,REF_0(address) (->tkn) := _from(address),REF_1(uint256) -> tkn.value,REF_1(uint256) (->tkn) := _value(uint256),REF_2(bytes) -> tkn.data,REF_2(bytes) (->tkn) := _data(bytes),REF_3(None) -> _data[3],TMP_12 = CONVERT REF_3 to uint32,REF_4(None) -> _data[2],TMP_13 = CONVERT REF_4 to uint32,TMP_14(uint32) = TMP_13 << 8,TMP_15(uint32) = TMP_12 + TMP_14,REF_5(None) -> _data[1],TMP_16 = CONVERT REF_5 to uint32,TMP_17(uint32) = TMP_16 << 16,TMP_18(uint32) = TMP_15 + TMP_17,REF_6(None) -> _data[0],TMP_19 = CONVERT REF_6 to uint32,TMP_20(uint32) = TMP_19 << 24,TMP_21(uint32) = TMP_18 + TMP_20,u(uint32) := TMP_21(uint32),REF_7(bytes4) -> tkn.sig,TMP_22 = CONVERT u to bytes4,REF_7(bytes4) (->tkn) := TMP_22(bytes4)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
tkn.sender = _from

IRs:
REF_0(address) -> tkn.sender
REF_0(address) (->tkn) := _from(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tkn.value = _value

IRs:
REF_1(uint256) -> tkn.value
REF_1(uint256) (->tkn) := _value(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
tkn.data = _data

IRs:
REF_2(bytes) -> tkn.data
REF_2(bytes) (->tkn) := _data(bytes)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24)

IRs:
REF_3(None) -> _data[3]
TMP_12 = CONVERT REF_3 to uint32
REF_4(None) -> _data[2]
TMP_13 = CONVERT REF_4 to uint32
TMP_14(uint32) = TMP_13 << 8
TMP_15(uint32) = TMP_12 + TMP_14
REF_5(None) -> _data[1]
TMP_16 = CONVERT REF_5 to uint32
TMP_17(uint32) = TMP_16 << 16
TMP_18(uint32) = TMP_15 + TMP_17
REF_6(None) -> _data[0]
TMP_19 = CONVERT REF_6 to uint32
TMP_20(uint32) = TMP_19 << 24
TMP_21(uint32) = TMP_18 + TMP_20
u(uint32) := TMP_21(uint32)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tkn.sig = bytes4(u)

IRs:
REF_7(bytes4) -> tkn.sig
TMP_22 = CONVERT u to bytes4
REF_7(bytes4) (->tkn) := TMP_22(bytes4)""];
}
",0,1,0,0,;tkn.sender = _from;tkn.value = _value;tkn.data = _data;u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);tkn.sig = bytes4(u)
./0xe8d5a2fc2ff2d5de90c98daa6aaed8b250d7965b_ext.sol,TokenERC20.burn,144,150,"REF_16(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_16 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_17(uint256) -> balanceOf[msg.sender],REF_17(-> balanceOf) = REF_17 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_16(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_16 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
REF_17(-> balanceOf) = REF_17 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xef68e7c694f40c8202821edf525de3782458639f_ext.sol,LoopringToken.computeTokenAmount,408,420,"TMP_80(uint256) = block.number - firstblock,TMP_81(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_80', 'BLOCKS_PER_PHASE'] ,phase(uint256) := TMP_81(uint256),REF_64 -> LENGTH bonusPercentages,TMP_82(bool) = phase >= REF_64,CONDITION TMP_82,REF_65 -> LENGTH bonusPercentages,TMP_83(uint256) = REF_65 - 1,phase(uint256) := TMP_83(uint256),TMP_84(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['ethAmount', 'BASE_RATE'] ,tokenBase(uint256) := TMP_84(uint256),REF_68(uint8) -> bonusPercentages[phase],TMP_85(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenBase', 'REF_68'] ,TMP_86(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_85', '100'] ,tokenBonus(uint256) := TMP_86(uint256),TMP_87(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokenBase', 'tokenBonus'] ,tokens(uint256) := TMP_87(uint256),RETURN tokens","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
phase = (block.number - firstblock).div(BLOCKS_PER_PHASE)

IRs:
TMP_80(uint256) = block.number - firstblock
TMP_81(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_80', 'BLOCKS_PER_PHASE'] 
phase(uint256) := TMP_81(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
phase >= bonusPercentages.length

IRs:
REF_64 -> LENGTH bonusPercentages
TMP_82(bool) = phase >= REF_64
CONDITION TMP_82""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
phase = bonusPercentages.length - 1

IRs:
REF_65 -> LENGTH bonusPercentages
TMP_83(uint256) = REF_65 - 1
phase(uint256) := TMP_83(uint256)""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
tokenBase = ethAmount.mul(BASE_RATE)

IRs:
TMP_84(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['ethAmount', 'BASE_RATE'] 
tokenBase(uint256) := TMP_84(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
tokenBonus = tokenBase.mul(bonusPercentages[phase]).div(100)

IRs:
REF_68(uint8) -> bonusPercentages[phase]
TMP_85(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenBase', 'REF_68'] 
TMP_86(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_85', '100'] 
tokenBonus(uint256) := TMP_86(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens = tokenBase.add(tokenBonus)

IRs:
TMP_87(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokenBase', 'tokenBonus'] 
tokens(uint256) := TMP_87(uint256)""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
tokens

IRs:
RETURN tokens""];
}
",0,1,0,0,phase = (block.number - firstblock).div(BLOCKS_PER_PHASE);phase >= bonusPercentages.length;phase = bonusPercentages.length - 1;;tokenBase = ethAmount.mul(BASE_RATE);tokenBonus = tokenBase.mul(bonusPercentages[phase]).div(100);tokens = tokenBase.add(tokenBonus);tokens
./0xf4609d26a58598d6b80b11f451a00477f61d8804_ext.sol,Tcthereum.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x128a0cdaf3bb00e4b5357e02ff0682933beb407f_ext.sol,ERC20Connect.fallback,120,133,"TMP_42(uint256) = totalEthInWei + msg.value,totalEthInWei(uint256) := TMP_42(uint256),TMP_43(uint256) = msg.value * unitsOneEthCanBuy,amount(uint256) := TMP_43(uint256),REF_24(uint256) -> balances[fundsWallet],TMP_44(bool) = REF_24 < amount,CONDITION TMP_44,REF_25(uint256) -> balances[fundsWallet],REF_26(uint256) -> balances[fundsWallet],TMP_45(uint256) = REF_26 - amount,REF_25(uint256) (->balances) := TMP_45(uint256),REF_27(uint256) -> balances[msg.sender],REF_28(uint256) -> balances[msg.sender],TMP_46(uint256) = REF_28 + amount,REF_27(uint256) (->balances) := TMP_46(uint256),Emit Transfer(fundsWallet,msg.sender,amount),Transfer dest:fundsWallet value:msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
totalEthInWei = totalEthInWei + msg.value

IRs:
TMP_42(uint256) = totalEthInWei + msg.value
totalEthInWei(uint256) := TMP_42(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = msg.value * unitsOneEthCanBuy

IRs:
TMP_43(uint256) = msg.value * unitsOneEthCanBuy
amount(uint256) := TMP_43(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
balances[fundsWallet] < amount

IRs:
REF_24(uint256) -> balances[fundsWallet]
TMP_44(bool) = REF_24 < amount
CONDITION TMP_44""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: RETURN 4
""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[fundsWallet] = balances[fundsWallet] - amount

IRs:
REF_25(uint256) -> balances[fundsWallet]
REF_26(uint256) -> balances[fundsWallet]
TMP_45(uint256) = REF_26 - amount
REF_25(uint256) (->balances) := TMP_45(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[msg.sender] = balances[msg.sender] + amount

IRs:
REF_27(uint256) -> balances[msg.sender]
REF_28(uint256) -> balances[msg.sender]
TMP_46(uint256) = REF_28 + amount
REF_27(uint256) (->balances) := TMP_46(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(fundsWallet,msg.sender,amount)

IRs:
Emit Transfer(fundsWallet,msg.sender,amount)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
fundsWallet.transfer(msg.value)

IRs:
Transfer dest:fundsWallet value:msg.value""];
}
",0,1,0,0,"totalEthInWei = totalEthInWei + msg.value;amount = msg.value * unitsOneEthCanBuy;balances[fundsWallet] < amount;;;balances[fundsWallet] = balances[fundsWallet] - amount;balances[msg.sender] = balances[msg.sender] + amount;Transfer(fundsWallet,msg.sender,amount);fundsWallet.transfer(msg.value)"
./0xd389c08bb987dd7daeb31f51fce1b5b73710b38e_ext.sol,token.burnFrom,117,125,"REF_15(uint256) -> balanceOf[_from],TMP_22(bool) = REF_15 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_16(mapping(address => uint256)) -> allowance[_from],REF_17(uint256) -> REF_16[msg.sender],TMP_24(bool) = _value <= REF_17,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_18(uint256) -> balanceOf[_from],REF_18(-> balanceOf) = REF_18 - _value,REF_19(mapping(address => uint256)) -> allowance[_from],REF_20(uint256) -> REF_19[msg.sender],REF_20(-> allowance) = REF_20 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_15(uint256) -> balanceOf[_from]
TMP_22(bool) = REF_15 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_16(mapping(address => uint256)) -> allowance[_from]
REF_17(uint256) -> REF_16[msg.sender]
TMP_24(bool) = _value <= REF_17
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_18(uint256) -> balanceOf[_from]
REF_18(-> balanceOf) = REF_18 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_19(mapping(address => uint256)) -> allowance[_from]
REF_20(uint256) -> REF_19[msg.sender]
REF_20(-> allowance) = REF_20 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x369d0db2c7d56b095d758379b75f64085953528a_ext.sol,TokenERC20.burn,148,154,"REF_17(uint256) -> balanceOf[msg.sender],TMP_24(bool) = REF_17 >= _value,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_24(bool) = REF_17 >= _value
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x332124f226e80c3afdbb59271f550881b20604a1_ext.sol,PlazaToken.mintToken,201,206,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0xbc4976ceaeae6c019f826a1e89a6d9cb1a2970bc_ext.sol,UbiatarPlay.burn,99,107,"TMP_24(bool) = _value > 0,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_32(uint256) -> balances[msg.sender],TMP_26(bool) = REF_32 >= _value,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_33(uint256) -> balances[msg.sender],REF_33(-> balances) = REF_33 - _value,totalSupply(uint256) = totalSupply - _value,TMP_28 = CONVERT 0 to address,Emit Transfer(msg.sender,TMP_28,_value),Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_24(bool) = _value > 0
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_32(uint256) -> balances[msg.sender]
TMP_26(bool) = REF_32 >= _value
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_33(uint256) -> balances[msg.sender]
REF_33(-> balances) = REF_33 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,address(0),_value)

IRs:
TMP_28 = CONVERT 0 to address
Emit Transfer(msg.sender,TMP_28,_value)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(_value > 0);require(bool)(balances[msg.sender] >= _value);balances[msg.sender] -= _value;totalSupply -= _value;Transfer(msg.sender,address(0),_value);Burn(msg.sender,_value);true;success"
./0xf29e2bcde0ed59252df2f4b4f3867599dd06b687_ext.sol,SenbitTokenSBIT.burnFrom,78,86,"REF_14(uint256) -> balanceOf[_from],TMP_20(bool) = REF_14 >= _value,TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20),REF_15(mapping(address => uint256)) -> allowance[_from],REF_16(uint256) -> REF_15[msg.sender],TMP_22(bool) = _value <= REF_16,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_17(uint256) -> balanceOf[_from],REF_17(-> balanceOf) = REF_17 - _value,REF_18(mapping(address => uint256)) -> allowance[_from],REF_19(uint256) -> REF_18[msg.sender],REF_19(-> allowance) = REF_19 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_14(uint256) -> balanceOf[_from]
TMP_20(bool) = REF_14 >= _value
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_15(mapping(address => uint256)) -> allowance[_from]
REF_16(uint256) -> REF_15[msg.sender]
TMP_22(bool) = _value <= REF_16
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_17(uint256) -> balanceOf[_from]
REF_17(-> balanceOf) = REF_17 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_18(mapping(address => uint256)) -> allowance[_from]
REF_19(uint256) -> REF_18[msg.sender]
REF_19(-> allowance) = REF_19 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x335c949c06fa1ba8744d98e3aa2c2a2deaa9255c_ext.sol,Exchanger.getPurchasePrice,202,216,"TMP_47(uint256) = HIGH_LEVEL_CALL, dest:tokenContract(ITradeableAsset), function:totalSupply, arguments:[]  ,TMP_48(uint256) = TMP_47 / multiplier,TMP_49(uint256) = HIGH_LEVEL_CALL, dest:tokenContract(ITradeableAsset), function:balanceOf, arguments:['this']  ,TMP_50(uint256) = TMP_48 - TMP_49,TMP_51 = CONVERT this to address,TMP_52(uint256) = SOLIDITY_CALL balance(address)(TMP_51),TMP_53(uint256) = HIGH_LEVEL_CALL, dest:formulaContract(IYeekFormula), function:calculatePurchaseReturn, arguments:['TMP_50', 'TMP_52', 'weight', 'amountInWei']  ,purchaseReturn(uint256) := TMP_53(uint256),TMP_54(uint32) = fee / 1000000,TMP_55(uint256) = purchaseReturn * TMP_54,TMP_56(uint256) = purchaseReturn - TMP_55,purchaseReturn(uint256) := TMP_56(uint256),TMP_57(uint256) = HIGH_LEVEL_CALL, dest:tokenContract(ITradeableAsset), function:balanceOf, arguments:['this']  ,TMP_58(bool) = purchaseReturn > TMP_57,CONDITION TMP_58,TMP_59(uint256) = HIGH_LEVEL_CALL, dest:tokenContract(ITradeableAsset), function:balanceOf, arguments:['this']  ,RETURN TMP_59,RETURN purchaseReturn","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
purchaseReturn = formulaContract.calculatePurchaseReturn((tokenContract.totalSupply() / multiplier) - tokenContract.balanceOf(this),address(this).balance,weight,amountInWei)

IRs:
TMP_47(uint256) = HIGH_LEVEL_CALL, dest:tokenContract(ITradeableAsset), function:totalSupply, arguments:[]  
TMP_48(uint256) = TMP_47 / multiplier
TMP_49(uint256) = HIGH_LEVEL_CALL, dest:tokenContract(ITradeableAsset), function:balanceOf, arguments:['this']  
TMP_50(uint256) = TMP_48 - TMP_49
TMP_51 = CONVERT this to address
TMP_52(uint256) = SOLIDITY_CALL balance(address)(TMP_51)
TMP_53(uint256) = HIGH_LEVEL_CALL, dest:formulaContract(IYeekFormula), function:calculatePurchaseReturn, arguments:['TMP_50', 'TMP_52', 'weight', 'amountInWei']  
purchaseReturn(uint256) := TMP_53(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
purchaseReturn = (purchaseReturn - (purchaseReturn * (fee / 1000000)))

IRs:
TMP_54(uint32) = fee / 1000000
TMP_55(uint256) = purchaseReturn * TMP_54
TMP_56(uint256) = purchaseReturn - TMP_55
purchaseReturn(uint256) := TMP_56(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
purchaseReturn > tokenContract.balanceOf(this)

IRs:
TMP_57(uint256) = HIGH_LEVEL_CALL, dest:tokenContract(ITradeableAsset), function:balanceOf, arguments:['this']  
TMP_58(bool) = purchaseReturn > TMP_57
CONDITION TMP_58""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: RETURN 4

EXPRESSION:
tokenContract.balanceOf(this)

IRs:
TMP_59(uint256) = HIGH_LEVEL_CALL, dest:tokenContract(ITradeableAsset), function:balanceOf, arguments:['this']  
RETURN TMP_59""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
purchaseReturn

IRs:
RETURN purchaseReturn""];
}
",0,1,0,0,"purchaseReturn = formulaContract.calculatePurchaseReturn((tokenContract.totalSupply() / multiplier) - tokenContract.balanceOf(this),address(this).balance,weight,amountInWei);purchaseReturn = (purchaseReturn - (purchaseReturn * (fee / 1000000)));purchaseReturn > tokenContract.balanceOf(this);tokenContract.balanceOf(this);;purchaseReturn"
./0x6d14421da39b403baab1cb0eac158ee658590798_ext.sol,Agencies.ownerOf,17,19,"REF_1(address) -> ownerOfAgency[_agency],RETURN REF_1,RETURN _owner","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
ownerOfAgency[_agency]

IRs:
REF_1(address) -> ownerOfAgency[_agency]
RETURN REF_1""];
2[label=""Node Type: RETURN 2

EXPRESSION:
_owner

IRs:
RETURN _owner""];
}
",0,1,0,0,ownerOfAgency[_agency];_owner
./0x2c82c73d5b34aa015989462b2948cd616a37641f_ext.sol,MiniMeTokenFactory.createCloneToken,663,683,"TMP_160(MiniMeToken) = new MiniMeToken(this,_parentToken,_snapshotBlock,_tokenName,_decimalUnits,_tokenSymbol,_transfersEnabled) ,newToken(MiniMeToken) := TMP_160(MiniMeToken),HIGH_LEVEL_CALL, dest:newToken(MiniMeToken), function:changeController, arguments:['msg.sender']  ,RETURN newToken","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
newToken = new MiniMeToken(this,_parentToken,_snapshotBlock,_tokenName,_decimalUnits,_tokenSymbol,_transfersEnabled)

IRs:
TMP_160(MiniMeToken) = new MiniMeToken(this,_parentToken,_snapshotBlock,_tokenName,_decimalUnits,_tokenSymbol,_transfersEnabled) 
newToken(MiniMeToken) := TMP_160(MiniMeToken)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
newToken.changeController(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:newToken(MiniMeToken), function:changeController, arguments:['msg.sender']  ""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
newToken

IRs:
RETURN newToken""];
}
",0,1,0,0,"newToken = new MiniMeToken(this,_parentToken,_snapshotBlock,_tokenName,_decimalUnits,_tokenSymbol,_transfersEnabled);newToken.changeController(msg.sender);newToken"
./0xf1e6b7f94bb0d70d8a19187f684e4270b0a0c989_ext.sol,ERC20TokenCPN.burn,136,147,"TMP_41(bool) = msg.sender == regulator,TMP_42(bool) = regulatorStatus == 1,TMP_43(bool) = regulatorStatus == 2,TMP_44(bool) = TMP_42 || TMP_43,TMP_45(bool) = TMP_41 && TMP_44,REF_18(ERC20TokenCPN.agent) -> agents[_to],REF_19(uint256) -> REF_18.balance,TMP_46(bool) = REF_19 >= _value,TMP_47(bool) = TMP_45 && TMP_46,CONDITION TMP_47,Emit Transfer(_to,msg.sender,_value),REF_20(ERC20TokenCPN.agent) -> agents[_to],REF_21(uint256) -> REF_20.balance,REF_21(-> agents) = REF_21 - _value,amount(uint256) = amount - _value,Emit Burn(msg.sender,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
(msg.sender == regulator) && (regulatorStatus == 1 || regulatorStatus == 2) && (agents[_to].balance >= _value)

IRs:
TMP_41(bool) = msg.sender == regulator
TMP_42(bool) = regulatorStatus == 1
TMP_43(bool) = regulatorStatus == 2
TMP_44(bool) = TMP_42 || TMP_43
TMP_45(bool) = TMP_41 && TMP_44
REF_18(ERC20TokenCPN.agent) -> agents[_to]
REF_19(uint256) -> REF_18.balance
TMP_46(bool) = REF_19 >= _value
TMP_47(bool) = TMP_45 && TMP_46
CONDITION TMP_47""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Transfer(_to,msg.sender,_value)

IRs:
Emit Transfer(_to,msg.sender,_value)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
agents[_to].balance -= _value

IRs:
REF_20(ERC20TokenCPN.agent) -> agents[_to]
REF_21(uint256) -> REF_20.balance
REF_21(-> agents) = REF_21 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
amount -= _value

IRs:
amount(uint256) = amount - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Burn(msg.sender,_to,_value)

IRs:
Emit Burn(msg.sender,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"(msg.sender == regulator) && (regulatorStatus == 1 || regulatorStatus == 2) && (agents[_to].balance >= _value);Transfer(_to,msg.sender,_value);;agents[_to].balance -= _value;amount -= _value;Burn(msg.sender,_to,_value);true;false;success"
./0x32a44d9d49a05f9049cd7f8eb0e3d19c90dd2421_ext.sol,DragonDistributions.withdrawDragons,80,115,"total(uint256) := 0(uint256),REF_7(bool) -> advisors[msg.sender],TMP_1(bool) = REF_7 == True,TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1),TMP_3 = CONVERT dragon to Dragon,drg(Dragon) := TMP_3(Dragon),REF_8(bool) -> distributionOne[msg.sender],TMP_4(bool) = REF_8 == False,CONDITION TMP_4,REF_9(bool) -> distributionOne[msg.sender],REF_9(bool) (->distributionOne) := True(bool),total(uint256) = total + 15000000000000,REF_10(uint256) -> balanceOf[msg.sender],REF_10(-> balanceOf) = REF_10 - 15000000000000,REF_11(bool) -> distributionTwo[msg.sender],TMP_5(bool) = REF_11 == False,TMP_6(uint256) = clock + 1900800,TMP_7(bool) = now > TMP_6,TMP_8(bool) = TMP_5 && TMP_7,CONDITION TMP_8,REF_12(bool) -> distributionTwo[msg.sender],REF_12(bool) (->distributionTwo) := True(bool),total(uint256) = total + 15000000000000,REF_13(uint256) -> balanceOf[msg.sender],REF_13(-> balanceOf) = REF_13 - 15000000000000,REF_14(bool) -> distributionThree[msg.sender],TMP_9(bool) = REF_14 == False,TMP_10(uint256) = clock + 33436800,TMP_11(bool) = now > TMP_10,TMP_12(bool) = TMP_9 && TMP_11,CONDITION TMP_12,REF_15(bool) -> distributionThree[msg.sender],REF_15(bool) (->distributionThree) := True(bool),total(uint256) = total + 15000000000000,REF_16(uint256) -> balanceOf[msg.sender],REF_16(-> balanceOf) = REF_16 - 15000000000000,TMP_13(bool) = HIGH_LEVEL_CALL, dest:drg(Dragon), function:transfer, arguments:['msg.sender', 'total']  ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
total = 0

IRs:
total(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(advisors[msg.sender] == true)

IRs:
REF_7(bool) -> advisors[msg.sender]
TMP_1(bool) = REF_7 == True
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
drg = Dragon(dragon)

IRs:
TMP_3 = CONVERT dragon to Dragon
drg(Dragon) := TMP_3(Dragon)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
distributionOne[msg.sender] == false

IRs:
REF_8(bool) -> distributionOne[msg.sender]
TMP_4(bool) = REF_8 == False
CONDITION TMP_4""];
4->5[label=""True""];
4->8[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
distributionOne[msg.sender] = true

IRs:
REF_9(bool) -> distributionOne[msg.sender]
REF_9(bool) (->distributionOne) := True(bool)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
total += 15000000000000

IRs:
total(uint256) = total + 15000000000000""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balanceOf[msg.sender] -= 15000000000000

IRs:
REF_10(uint256) -> balanceOf[msg.sender]
REF_10(-> balanceOf) = REF_10 - 15000000000000""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
distributionTwo[msg.sender] == false && now > clock + 1900800

IRs:
REF_11(bool) -> distributionTwo[msg.sender]
TMP_5(bool) = REF_11 == False
TMP_6(uint256) = clock + 1900800
TMP_7(bool) = now > TMP_6
TMP_8(bool) = TMP_5 && TMP_7
CONDITION TMP_8""];
9->10[label=""True""];
9->13[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
distributionTwo[msg.sender] = true

IRs:
REF_12(bool) -> distributionTwo[msg.sender]
REF_12(bool) (->distributionTwo) := True(bool)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
total += 15000000000000

IRs:
total(uint256) = total + 15000000000000""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
balanceOf[msg.sender] -= 15000000000000

IRs:
REF_13(uint256) -> balanceOf[msg.sender]
REF_13(-> balanceOf) = REF_13 - 15000000000000""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
distributionThree[msg.sender] == false && now > clock + 33436800

IRs:
REF_14(bool) -> distributionThree[msg.sender]
TMP_9(bool) = REF_14 == False
TMP_10(uint256) = clock + 33436800
TMP_11(bool) = now > TMP_10
TMP_12(bool) = TMP_9 && TMP_11
CONDITION TMP_12""];
14->15[label=""True""];
14->18[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
distributionThree[msg.sender] = true

IRs:
REF_15(bool) -> distributionThree[msg.sender]
REF_15(bool) (->distributionThree) := True(bool)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
total += 15000000000000

IRs:
total(uint256) = total + 15000000000000""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
balanceOf[msg.sender] -= 15000000000000

IRs:
REF_16(uint256) -> balanceOf[msg.sender]
REF_16(-> balanceOf) = REF_16 - 15000000000000""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
drg.transfer(msg.sender,total)

IRs:
TMP_13(bool) = HIGH_LEVEL_CALL, dest:drg(Dragon), function:transfer, arguments:['msg.sender', 'total']  ""];
}
",0,1,0,0,"total = 0;require(bool)(advisors[msg.sender] == true);drg = Dragon(dragon);distributionOne[msg.sender] == false;distributionOne[msg.sender] = true;;total += 15000000000000;balanceOf[msg.sender] -= 15000000000000;distributionTwo[msg.sender] == false && now > clock + 1900800;distributionTwo[msg.sender] = true;;total += 15000000000000;balanceOf[msg.sender] -= 15000000000000;distributionThree[msg.sender] == false && now > clock + 33436800;distributionThree[msg.sender] = true;;total += 15000000000000;balanceOf[msg.sender] -= 15000000000000;drg.transfer(msg.sender,total)"
./0x04874548a2c233f57ba13c4d4cdee73c29811322_ext.sol,StandardToken.transferFrom,58,68,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x0e21902d93573c18fd0acbadac4a5464e9732f54_ext.sol,TempleOfETH.entryFee,431,450,"TMP_109 = CONVERT this to address,TMP_110(uint256) = SOLIDITY_CALL balance(address)(TMP_109),TMP_111(uint256) = TMP_110 - msg.value,volume(uint256) := TMP_111(uint256),TMP_112(bool) = volume <= 10000000000000000000,CONDITION TMP_112,RETURN 40,TMP_113(bool) = volume <= 20000000000000000000,CONDITION TMP_113,RETURN 35,TMP_114(bool) = volume <= 50000000000000000000,CONDITION TMP_114,RETURN 30,TMP_115(bool) = volume <= 100000000000000000000,CONDITION TMP_115,RETURN 25,TMP_116(bool) = volume <= 250000000000000000000,CONDITION TMP_116,RETURN 20,RETURN 15","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
volume = address(this).balance - msg.value

IRs:
TMP_109 = CONVERT this to address
TMP_110(uint256) = SOLIDITY_CALL balance(address)(TMP_109)
TMP_111(uint256) = TMP_110 - msg.value
volume(uint256) := TMP_111(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
volume <= 10000000000000000000

IRs:
TMP_112(bool) = volume <= 10000000000000000000
CONDITION TMP_112""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3

EXPRESSION:
40

IRs:
RETURN 40""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
volume <= 20000000000000000000

IRs:
TMP_113(bool) = volume <= 20000000000000000000
CONDITION TMP_113""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: RETURN 6

EXPRESSION:
35

IRs:
RETURN 35""];
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
volume <= 50000000000000000000

IRs:
TMP_114(bool) = volume <= 50000000000000000000
CONDITION TMP_114""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
30

IRs:
RETURN 30""];
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
volume <= 100000000000000000000

IRs:
TMP_115(bool) = volume <= 100000000000000000000
CONDITION TMP_115""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: RETURN 12

EXPRESSION:
25

IRs:
RETURN 25""];
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
volume <= 250000000000000000000

IRs:
TMP_116(bool) = volume <= 250000000000000000000
CONDITION TMP_116""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: RETURN 15

EXPRESSION:
20

IRs:
RETURN 20""];
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: RETURN 17

EXPRESSION:
15

IRs:
RETURN 15""];
}
",0,1,0,0,volume = address(this).balance - msg.value;volume <= 10000000000000000000;40;;volume <= 20000000000000000000;35;;volume <= 50000000000000000000;30;;volume <= 100000000000000000000;25;;volume <= 250000000000000000000;20;;15
./0xf2f5d3bccf2c84dff7da4838c4d741abf3608ab8_ext.sol,KEDU._transfer,41,57,"TMP_3 = CONVERT 0 to address,TMP_4(bool) = _to != TMP_3,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_1(uint256) -> balanceOf[_from],TMP_6(bool) = REF_1 >= _value,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_2(uint256) -> balanceOf[_to],TMP_8(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_9(bool) = TMP_8 >= REF_3,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_11(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_11(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_13(uint256) = REF_8 + REF_9,TMP_14(bool) = TMP_13 == previousBalances,TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0x0))

IRs:
TMP_3 = CONVERT 0 to address
TMP_4(bool) = _to != TMP_3
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_6(bool) = REF_1 >= _value
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_8(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_9(bool) = TMP_8 >= REF_3
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_11(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_11(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_13(uint256) = REF_8 + REF_9
TMP_14(bool) = TMP_13 == previousBalances
TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)""];
}
",0,1,0,0,"require(bool)(_to != address(0x0));require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x3fab284a3cd0a6d88d18d0fda4bc1a76cdacd68a_ext.sol,qui_qz.NewQuestion,46,55,"TMP_12(bool) = msg.sender == questionSender,TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12),question(string) := _question(string),responseHash(bytes32) := _responseHash(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_12(bool) = msg.sender == questionSender
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
responseHash = _responseHash

IRs:
responseHash(bytes32) := _responseHash(bytes32)""];
}
",0,1,0,0,require(bool)(msg.sender == questionSender);question = _question;responseHash = _responseHash
./0x5b527c8cc72ea4b8681e44754be6248b107c5229_ext.sol,SmartHomeCoin.mintToken,205,210,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0xf211128cc6d925a3a328647cf78b322b51429c53_ext.sol,F2m.getTotalVolume,680,686,"TMP_219(uint256) = totalBuyVolume + totalSellVolume,RETURN TMP_219","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
totalBuyVolume + totalSellVolume

IRs:
TMP_219(uint256) = totalBuyVolume + totalSellVolume
RETURN TMP_219""];
}
",0,1,0,0,totalBuyVolume + totalSellVolume
./0x6be9ad54d8ad5510d61690a7bd3823d0790c71b6_ext.sol,IRAN_WINS.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0xef6da6e6e72e3381a1f97ea520d2844582d85edb_ext.sol,WinEthFree.calcInterest,87,118,"TMP_2(bool) = INTERNAL_CALL, WinEthFree.isInvestor(address)(addr),TMP_3 = UnaryType.BANG TMP_2 ,CONDITION TMP_3,RETURN 0,REF_4(WinEthFree.Investor) -> investors[addr],REF_5(uint256) -> REF_4.investment,investment(uint256) := REF_5(uint256),REF_6(WinEthFree.Investor) -> investors[addr],REF_7(uint256) -> REF_6.paidInterest,paidInterest(uint256) := REF_7(uint256),TMP_4(bool) = investment <= paidInterest,CONDITION TMP_4,INTERNAL_CALL, WinEthFree.resetInvestor(address)(addr),Emit LogInvestChange(addr,0,0,0),RETURN 0,REF_8(WinEthFree.Investor) -> investors[addr],REF_9(uint256) -> REF_8.payableInterest,payableInterest(uint256) := REF_9(uint256),REF_10(WinEthFree.Investor) -> investors[addr],REF_11(uint256) -> REF_10.payTime,payTime(uint256) := REF_11(uint256),TMP_7(uint256) = investment * ratePercent,TMP_8(uint256) = TMP_7 / 100,TMP_9(uint256) = now - payTime,TMP_10(uint256) = TMP_8 * TMP_9,TMP_11(uint256) = TMP_10 / ratePeriod,interest(uint256) := TMP_11(uint256),interest(uint256) = interest + payableInterest,TMP_12(uint256) = investment - paidInterest,restInterest(uint256) := TMP_12(uint256),TMP_13(bool) = interest > restInterest,CONDITION TMP_13,interest(uint256) := restInterest(uint256),RETURN interest","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
! isInvestor(addr)

IRs:
TMP_2(bool) = INTERNAL_CALL, WinEthFree.isInvestor(address)(addr)
TMP_3 = UnaryType.BANG TMP_2 
CONDITION TMP_3""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
0

IRs:
RETURN 0""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
investment = investors[addr].investment

IRs:
REF_4(WinEthFree.Investor) -> investors[addr]
REF_5(uint256) -> REF_4.investment
investment(uint256) := REF_5(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
paidInterest = investors[addr].paidInterest

IRs:
REF_6(WinEthFree.Investor) -> investors[addr]
REF_7(uint256) -> REF_6.paidInterest
paidInterest(uint256) := REF_7(uint256)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
investment <= paidInterest

IRs:
TMP_4(bool) = investment <= paidInterest
CONDITION TMP_4""];
6->7[label=""True""];
6->10[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
resetInvestor(addr)

IRs:
INTERNAL_CALL, WinEthFree.resetInvestor(address)(addr)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
LogInvestChange(addr,0,0,0)

IRs:
Emit LogInvestChange(addr,0,0,0)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
0

IRs:
RETURN 0""];
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
payableInterest = investors[addr].payableInterest

IRs:
REF_8(WinEthFree.Investor) -> investors[addr]
REF_9(uint256) -> REF_8.payableInterest
payableInterest(uint256) := REF_9(uint256)""];
11->12;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
payTime = investors[addr].payTime

IRs:
REF_10(WinEthFree.Investor) -> investors[addr]
REF_11(uint256) -> REF_10.payTime
payTime(uint256) := REF_11(uint256)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
interest = investment * ratePercent / 100 * (now - payTime) / ratePeriod

IRs:
TMP_7(uint256) = investment * ratePercent
TMP_8(uint256) = TMP_7 / 100
TMP_9(uint256) = now - payTime
TMP_10(uint256) = TMP_8 * TMP_9
TMP_11(uint256) = TMP_10 / ratePeriod
interest(uint256) := TMP_11(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
interest += payableInterest

IRs:
interest(uint256) = interest + payableInterest""];
14->15;
15[label=""Node Type: NEW VARIABLE 15

EXPRESSION:
restInterest = investment - paidInterest

IRs:
TMP_12(uint256) = investment - paidInterest
restInterest(uint256) := TMP_12(uint256)""];
15->16;
16[label=""Node Type: IF 16

EXPRESSION:
interest > restInterest

IRs:
TMP_13(bool) = interest > restInterest
CONDITION TMP_13""];
16->17[label=""True""];
16->18[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
interest = restInterest

IRs:
interest(uint256) := restInterest(uint256)""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: RETURN 19

EXPRESSION:
interest

IRs:
RETURN interest""];
}
",0,1,0,0,"! isInvestor(addr);0;;investment = investors[addr].investment;paidInterest = investors[addr].paidInterest;investment <= paidInterest;resetInvestor(addr);;LogInvestChange(addr,0,0,0);0;payableInterest = investors[addr].payableInterest;payTime = investors[addr].payTime;interest = investment * ratePercent / 100 * (now - payTime) / ratePeriod;interest += payableInterest;restInterest = investment - paidInterest;interest > restInterest;interest = restInterest;;interest"
./0x7703c35cffdc5cda8d27aa3df2f9ba6964544b6e_ext.sol,PylonToken.mintToken,208,213,"REF_12(uint256) -> balanceOf[target],REF_12(-> balanceOf) = REF_12 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,owner,mintedAmount),Emit Transfer(owner,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_12(uint256) -> balanceOf[target]
REF_12(-> balanceOf) = REF_12 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,owner,mintedAmount)

IRs:
Emit Transfer(0,owner,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(owner,target,mintedAmount)

IRs:
Emit Transfer(owner,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,owner,mintedAmount);Transfer(owner,target,mintedAmount)"
./0x36cac7291719e907276d795c330dbc2fcf66df54_ext.sol,DogCash.totalSupply,134,136,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0xd8cb4151fce62b3d08269343a79dbcd6f83d3405_ext.sol,you_can_do_it.start_quiz,23,35,"TMP_7(bool) = responseHash == 0,CONDITION TMP_7,TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response),responseHash(bytes32) := TMP_8(bytes32),question(string) := _question(string),questionSender(address) := msg.sender(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
responseHash == 0x0

IRs:
TMP_7(bool) = responseHash == 0
CONDITION TMP_7""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
responseHash = keccak256()(_response)

IRs:
TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response)
responseHash(bytes32) := TMP_8(bytes32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
questionSender = msg.sender

IRs:
questionSender(address) := msg.sender(address)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,1,0,0,responseHash == 0x0;responseHash = keccak256()(_response);;question = _question;questionSender = msg.sender
./0x5b72cae52d7d4cda632595574fcefdea3ae37143_ext.sol,fund_raising.setup_key,23,28,"TMP_9(bool) = keyHash == 0,CONDITION TMP_9,TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10),keyHash(bytes32) := TMP_11(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
keyHash == 0x0

IRs:
TMP_9(bool) = keyHash == 0
CONDITION TMP_9""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
keyHash = keccak256()(abi.encodePacked(key))

IRs:
TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10)
keyHash(bytes32) := TMP_11(bytes32)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,1,0,0,keyHash == 0x0;keyHash = keccak256()(abi.encodePacked(key));
./0x6567751ec2b2d2566456bea3fd3090045cb0c865_ext.sol,PPToken.burn,63,69,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xc7b62900c4860bc20f8561ee53d9a888b2ee411b_ext.sol,BinanceGold.transfer,21,28,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x017a5d8d82afaa22bc29d75013d6ff3656e90851_ext.sol,ScamStampToken.transfer,33,49,"TMP_0(bool) = _amount >= 0,CONDITION TMP_0,REF_1(uint256) -> balances[msg.sender],TMP_1(bool) = REF_1 >= _amount,CONDITION TMP_1,REF_2(uint256) -> balances[msg.sender],REF_2(-> balances) = REF_2 - _amount,REF_3(uint256) -> balances[_to],REF_3(-> balances) = REF_3 + _amount,Emit Transfer(msg.sender,_to,_amount),RETURN True,TMP_3(uint256) = _amount + _amount,totalSupply(uint256) = totalSupply + TMP_3,REF_4(uint256) -> balances[msg.sender],TMP_4(uint256) = _amount + _amount,REF_4(-> balances) = REF_4 + TMP_4,REF_5(uint256) -> balances[msg.sender],REF_5(-> balances) = REF_5 - _amount,REF_6(uint256) -> balances[_to],REF_6(-> balances) = REF_6 + _amount,Emit Transfer(msg.sender,_to,_amount),RETURN True,MODIFIER_CALL, ScamStampToken.onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->15;
1[label=""Node Type: IF 1

EXPRESSION:
_amount >= 0

IRs:
TMP_0(bool) = _amount >= 0
CONDITION TMP_0""];
1->2[label=""True""];
1->14[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
balances[msg.sender] >= _amount

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_1(bool) = REF_1 >= _amount
CONDITION TMP_1""];
2->3[label=""True""];
2->7[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] -= _amount

IRs:
REF_2(uint256) -> balances[msg.sender]
REF_2(-> balances) = REF_2 - _amount""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] += _amount

IRs:
REF_3(uint256) -> balances[_to]
REF_3(-> balances) = REF_3 + _amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_amount)

IRs:
Emit Transfer(msg.sender,_to,_amount)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
totalSupply += _amount + _amount

IRs:
TMP_3(uint256) = _amount + _amount
totalSupply(uint256) = totalSupply + TMP_3""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[msg.sender] += _amount + _amount

IRs:
REF_4(uint256) -> balances[msg.sender]
TMP_4(uint256) = _amount + _amount
REF_4(-> balances) = REF_4 + TMP_4""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
balances[msg.sender] -= _amount

IRs:
REF_5(uint256) -> balances[msg.sender]
REF_5(-> balances) = REF_5 - _amount""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
balances[_to] += _amount

IRs:
REF_6(uint256) -> balances[_to]
REF_6(-> balances) = REF_6 + _amount""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
Transfer(msg.sender,_to,_amount)

IRs:
Emit Transfer(msg.sender,_to,_amount)""];
11->12;
12[label=""Node Type: RETURN 12

EXPRESSION:
true

IRs:
RETURN True""];
14[label=""Node Type: END_IF 14
""];
14->16;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ScamStampToken.onlyOwner()()""];
15->1;
16[label=""Node Type: RETURN 16

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"onlyOwner();_amount >= 0;balances[msg.sender] >= _amount;;balances[msg.sender] -= _amount;totalSupply += _amount + _amount;balances[_to] += _amount;Transfer(msg.sender,_to,_amount);true;balances[msg.sender] += _amount + _amount;balances[msg.sender] -= _amount;balances[_to] += _amount;Transfer(msg.sender,_to,_amount);true;success"
./0x6d2cfe7c64087b1d6d2f7e77039de64dcd232ced_ext.sol,ERC777BaseToken.defaultOperators,316,316,RETURN mDefaultOperators,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
mDefaultOperators

IRs:
RETURN mDefaultOperators""];
}
",0,1,0,0,mDefaultOperators
./0x761341ca3b8186323e55c7e801ecbe9b5df41ad0_ext.sol,TokenERC20.approveAndCall,175,183,"TMP_70 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_70(tokenRecipient),TMP_71(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value),CONDITION TMP_71,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_70 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_70(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_71(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value)
CONDITION TMP_71""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x51f545a57a88d193227f506ff07911da0df2749c_ext.sol,MEXICO_WINS.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x126bba3aa97d9f6e98f56705f29ab02f7660b445_ext.sol,EducationTokens.symbol,98,100,"RETURN symbol,RETURN _symbol","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
symbol

IRs:
RETURN symbol""];
2[label=""Node Type: RETURN 2

EXPRESSION:
_symbol

IRs:
RETURN _symbol""];
}
",0,1,0,0,symbol;_symbol
./0xe319847f14624ad62a99c7eb5e6d738f61fcf185_ext.sol,EtherPaint.dividends,179,184,"TMP_66(bool) = colorid >= 16,CONDITION TMP_66,TMP_67(None) = SOLIDITY_CALL revert()(),REF_22(uint256) -> earningsPerToken[colorid],REF_23(uint256[16]) -> tokenBalance[_owner],REF_24(uint256) -> REF_23[colorid],TMP_68(uint256) = REF_22 * REF_24,TMP_69 = CONVERT TMP_68 to int256,REF_25(int256[16]) -> payouts[_owner],REF_26(int256) -> REF_25[colorid],TMP_70(int256) = TMP_69 - REF_26,TMP_71 = CONVERT TMP_70 to uint256,TMP_72(uint256) = TMP_71 / scaleFactor,RETURN TMP_72,RETURN amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
colorid >= 16

IRs:
TMP_66(bool) = colorid >= 16
CONDITION TMP_66""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_67(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
uint256(int256(earningsPerToken[colorid] * tokenBalance[_owner][colorid]) - payouts[_owner][colorid]) / scaleFactor

IRs:
REF_22(uint256) -> earningsPerToken[colorid]
REF_23(uint256[16]) -> tokenBalance[_owner]
REF_24(uint256) -> REF_23[colorid]
TMP_68(uint256) = REF_22 * REF_24
TMP_69 = CONVERT TMP_68 to int256
REF_25(int256[16]) -> payouts[_owner]
REF_26(int256) -> REF_25[colorid]
TMP_70(int256) = TMP_69 - REF_26
TMP_71 = CONVERT TMP_70 to uint256
TMP_72(uint256) = TMP_71 / scaleFactor
RETURN TMP_72""];
5[label=""Node Type: RETURN 5

EXPRESSION:
amount

IRs:
RETURN amount""];
}
",0,1,0,0,colorid >= 16;revert()();;uint256(int256(earningsPerToken[colorid] * tokenBalance[_owner][colorid]) - payouts[_owner][colorid]) / scaleFactor;amount
./0xf0eb75d7a2097a25796848c54e9eb862a93664ec_ext.sol,TKTToken.burn,49,55,"REF_16(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_16 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_17(uint256) -> balanceOf[msg.sender],REF_17(-> balanceOf) = REF_17 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_16(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_16 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
REF_17(-> balanceOf) = REF_17 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x5487939f38ad535223a6f5441edd43fac291da31_ext.sol,PeculiumOld.approveAndCall,445,451,"REF_214(mapping(address => uint256)) -> allowed[msg.sender],REF_215(uint256) -> REF_214[_spender],REF_215(uint256) (->allowed) := _value(uint256),Emit Approval(msg.sender,_spender,_value),TMP_213(bytes32) = SOLIDITY_CALL sha3()(receiveApproval(address,uint256,address,bytes)),TMP_214 = CONVERT TMP_213 to bytes32,TMP_215 = CONVERT TMP_214 to bytes4,TMP_216(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_215', 'msg.sender', '_value', 'this', '_extraData']  ,TMP_217(None) = SOLIDITY_CALL require(bool)(TMP_216),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_214(mapping(address => uint256)) -> allowed[msg.sender]
REF_215(uint256) -> REF_214[_spender]
REF_215(uint256) (->allowed) := _value(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_spender.call(bytes4(bytes32(sha3()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData))

IRs:
TMP_213(bytes32) = SOLIDITY_CALL sha3()(receiveApproval(address,uint256,address,bytes))
TMP_214 = CONVERT TMP_213 to bytes32
TMP_215 = CONVERT TMP_214 to bytes4
TMP_216(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_215', 'msg.sender', '_value', 'this', '_extraData']  
TMP_217(None) = SOLIDITY_CALL require(bool)(TMP_216)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][_spender] = _value;Approval(msg.sender,_spender,_value);require(bool)(_spender.call(bytes4(bytes32(sha3()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData));true;success"
./0xd5ec2aa0dda1b4c3b36fff24cb06318821dcd126_ext.sol,StandardToken.transferFrom,57,67,"REF_3(uint256) -> balances[_from],TMP_18(bool) = REF_3 >= _value,REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],TMP_19(bool) = REF_5 >= _value,TMP_20(bool) = TMP_18 && TMP_19,TMP_21(bool) = _value > 0,TMP_22(bool) = TMP_20 && TMP_21,CONDITION TMP_22,REF_6(uint256) -> balances[_to],REF_6(-> balances) = REF_6 + _value,REF_7(uint256) -> balances[_from],REF_7(-> balances) = REF_7 - _value,REF_8(mapping(address => uint256)) -> allowed[_from],REF_9(uint256) -> REF_8[msg.sender],REF_9(-> allowed) = REF_9 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0

IRs:
REF_3(uint256) -> balances[_from]
TMP_18(bool) = REF_3 >= _value
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
TMP_19(bool) = REF_5 >= _value
TMP_20(bool) = TMP_18 && TMP_19
TMP_21(bool) = _value > 0
TMP_22(bool) = TMP_20 && TMP_21
CONDITION TMP_22""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_6(uint256) -> balances[_to]
REF_6(-> balances) = REF_6 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_7(uint256) -> balances[_from]
REF_7(-> balances) = REF_7 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_8(mapping(address => uint256)) -> allowed[_from]
REF_9(uint256) -> REF_8[msg.sender]
REF_9(-> allowed) = REF_9 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0;balances[_to] += _value;false;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true;success"
./0xf1379777de65845ed323a08be31c086d0131ce23_ext.sol,StandardToken.transferFrom,44,54,"REF_3(uint256) -> balances[_from],TMP_3(bool) = REF_3 >= _value,REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],TMP_4(bool) = REF_5 >= _value,TMP_5(bool) = TMP_3 && TMP_4,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_6(uint256) -> balances[_to],REF_6(-> balances) = REF_6 + _value,REF_7(uint256) -> balances[_from],REF_7(-> balances) = REF_7 - _value,REF_8(mapping(address => uint256)) -> allowed[_from],REF_9(uint256) -> REF_8[msg.sender],REF_9(-> allowed) = REF_9 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value)

IRs:
REF_3(uint256) -> balances[_from]
TMP_3(bool) = REF_3 >= _value
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
TMP_4(bool) = REF_5 >= _value
TMP_5(bool) = TMP_3 && TMP_4
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_6(uint256) -> balances[_to]
REF_6(-> balances) = REF_6 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_7(uint256) -> balances[_from]
REF_7(-> balances) = REF_7 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_8(mapping(address => uint256)) -> allowed[_from]
REF_9(uint256) -> REF_8[msg.sender]
REF_9(-> allowed) = REF_9 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);balances[_to] += _value;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true;success"
./0x33a275b9cd129b34e5f0693d82d6d3db26b0c3a0_ext.sol,Owned.setMainYouCollectContractAddresses,146,156,"TMP_33 = CONVERT yccContract to InterfaceYCC,ycc(InterfaceYCC) := TMP_33(InterfaceYCC),TMP_34 = CONVERT yctContract to InterfaceContentCreatorUniverse,yct(InterfaceContentCreatorUniverse) := TMP_34(InterfaceContentCreatorUniverse),TMP_35 = CONVERT ycmContract to InterfaceMining,ycm(InterfaceMining) := TMP_35(InterfaceMining),REF_1(bool) -> youCollectContracts[yccContract],REF_1(bool) (->youCollectContracts) := True(bool),REF_2(bool) -> youCollectContracts[yctContract],REF_2(bool) (->youCollectContracts) := True(bool),REF_3(bool) -> youCollectContracts[ycmContract],REF_3(bool) (->youCollectContracts) := True(bool),index(uint16) := 0(uint256),REF_4 -> LENGTH otherContracts,TMP_36(bool) = index < REF_4,CONDITION TMP_36,REF_5(address) -> otherContracts[index],REF_6(bool) -> youCollectContracts[REF_5],REF_6(bool) (->youCollectContracts) := True(bool),TMP_37(uint16) := index(uint16),index(uint16) = index + 1,MODIFIER_CALL, Owned.onlyCOO()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->13;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ycc = InterfaceYCC(yccContract)

IRs:
TMP_33 = CONVERT yccContract to InterfaceYCC
ycc(InterfaceYCC) := TMP_33(InterfaceYCC)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
yct = InterfaceContentCreatorUniverse(yctContract)

IRs:
TMP_34 = CONVERT yctContract to InterfaceContentCreatorUniverse
yct(InterfaceContentCreatorUniverse) := TMP_34(InterfaceContentCreatorUniverse)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ycm = InterfaceMining(ycmContract)

IRs:
TMP_35 = CONVERT ycmContract to InterfaceMining
ycm(InterfaceMining) := TMP_35(InterfaceMining)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
youCollectContracts[yccContract] = true

IRs:
REF_1(bool) -> youCollectContracts[yccContract]
REF_1(bool) (->youCollectContracts) := True(bool)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
youCollectContracts[yctContract] = true

IRs:
REF_2(bool) -> youCollectContracts[yctContract]
REF_2(bool) (->youCollectContracts) := True(bool)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
youCollectContracts[ycmContract] = true

IRs:
REF_3(bool) -> youCollectContracts[ycmContract]
REF_3(bool) (->youCollectContracts) := True(bool)""];
6->9;
7[label=""Node Type: BEGIN_LOOP 7
""];
7->10;
8[label=""Node Type: END_LOOP 8
""];
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
index = 0

IRs:
index(uint16) := 0(uint256)""];
9->7;
10[label=""Node Type: IF_LOOP 10

EXPRESSION:
index < otherContracts.length

IRs:
REF_4 -> LENGTH otherContracts
TMP_36(bool) = index < REF_4
CONDITION TMP_36""];
10->11[label=""True""];
10->8[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
youCollectContracts[otherContracts[index]] = true

IRs:
REF_5(address) -> otherContracts[index]
REF_6(bool) -> youCollectContracts[REF_5]
REF_6(bool) (->youCollectContracts) := True(bool)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
index ++

IRs:
TMP_37(uint16) := index(uint16)
index(uint16) = index + 1""];
12->10;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
onlyCOO()

IRs:
MODIFIER_CALL, Owned.onlyCOO()()""];
13->1;
}
",0,1,0,0,onlyCOO();ycc = InterfaceYCC(yccContract);yct = InterfaceContentCreatorUniverse(yctContract);ycm = InterfaceMining(ycmContract);youCollectContracts[yccContract] = true;youCollectContracts[yctContract] = true;youCollectContracts[ycmContract] = true;index = 0;;index < otherContracts.length;;youCollectContracts[otherContracts[index]] = true;index ++
./0x4d0cdad789cf3f4b770c5b86dced6d198bf69eae_ext.sol,ERC827Token.increaseApproval,441,443,"REF_68(mapping(address => uint256)) -> allowed[msg.sender],REF_69(uint256) -> REF_68[_spender],REF_70(mapping(address => uint256)) -> allowed[msg.sender],REF_71(uint256) -> REF_70[_spender],TMP_57(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_71', '_addedValue'] ,REF_69(uint256) (->allowed) := TMP_57(uint256),REF_73(mapping(address => uint256)) -> allowed[msg.sender],REF_74(uint256) -> REF_73[_spender],Emit Approval(msg.sender,_spender,REF_74),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue)

IRs:
REF_68(mapping(address => uint256)) -> allowed[msg.sender]
REF_69(uint256) -> REF_68[_spender]
REF_70(mapping(address => uint256)) -> allowed[msg.sender]
REF_71(uint256) -> REF_70[_spender]
TMP_57(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_71', '_addedValue'] 
REF_69(uint256) (->allowed) := TMP_57(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,allowed[msg.sender][_spender])

IRs:
REF_73(mapping(address => uint256)) -> allowed[msg.sender]
REF_74(uint256) -> REF_73[_spender]
Emit Approval(msg.sender,_spender,REF_74)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);Approval(msg.sender,_spender,allowed[msg.sender][_spender]);true"
./0x01d9c3baeb4a7b22a8742e07e9158ff7ae10737c_ext.sol,StandardToken.transferFrom,55,65,"REF_3(uint256) -> balances[_from],TMP_18(bool) = REF_3 >= _value,REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],TMP_19(bool) = REF_5 >= _value,TMP_20(bool) = TMP_18 && TMP_19,TMP_21(bool) = _value > 0,TMP_22(bool) = TMP_20 && TMP_21,CONDITION TMP_22,REF_6(uint256) -> balances[_to],REF_6(-> balances) = REF_6 + _value,REF_7(uint256) -> balances[_from],REF_7(-> balances) = REF_7 - _value,REF_8(mapping(address => uint256)) -> allowed[_from],REF_9(uint256) -> REF_8[msg.sender],REF_9(-> allowed) = REF_9 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0

IRs:
REF_3(uint256) -> balances[_from]
TMP_18(bool) = REF_3 >= _value
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
TMP_19(bool) = REF_5 >= _value
TMP_20(bool) = TMP_18 && TMP_19
TMP_21(bool) = _value > 0
TMP_22(bool) = TMP_20 && TMP_21
CONDITION TMP_22""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_6(uint256) -> balances[_to]
REF_6(-> balances) = REF_6 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_7(uint256) -> balances[_from]
REF_7(-> balances) = REF_7 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_8(mapping(address => uint256)) -> allowed[_from]
REF_9(uint256) -> REF_8[msg.sender]
REF_9(-> allowed) = REF_9 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0;balances[_to] += _value;false;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true;success"
./0x213a22d873e02269ac45c094c0655a09eaa22c3a_ext.sol,TokenERC20.burnFrom,72,80,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x6cabf1b590ee8daa30a1c76ff5dd21284d8681d8_ext.sol,HCHToken.burn,131,137,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x0082f8addb9c0d6cc27783d41198300b4cd2e19b_ext.sol,CryptoCelebrity._transfer,411,426,"REF_50(uint256) -> ownershipTokenCount[_to],TMP_114(uint256) := REF_50(uint256),REF_50(-> ownershipTokenCount) = REF_50 + 1,REF_51(address) -> personIndexToOwner[_tokenId],REF_51(address) (->personIndexToOwner) := _to(address),TMP_115 = CONVERT 0 to address,TMP_116(bool) = _from != TMP_115,CONDITION TMP_116,REF_52(uint256) -> ownershipTokenCount[_from],TMP_117(uint256) := REF_52(uint256),REF_52(-> ownershipTokenCount) = REF_52 - 1,REF_53(address) -> personIndexToApproved[_tokenId],personIndexToApproved = delete REF_53 ,Emit Transfer(_from,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownershipTokenCount[_to] ++

IRs:
REF_50(uint256) -> ownershipTokenCount[_to]
TMP_114(uint256) := REF_50(uint256)
REF_50(-> ownershipTokenCount) = REF_50 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
personIndexToOwner[_tokenId] = _to

IRs:
REF_51(address) -> personIndexToOwner[_tokenId]
REF_51(address) (->personIndexToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_115 = CONVERT 0 to address
TMP_116(bool) = _from != TMP_115
CONDITION TMP_116""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownershipTokenCount[_from] --

IRs:
REF_52(uint256) -> ownershipTokenCount[_from]
TMP_117(uint256) := REF_52(uint256)
REF_52(-> ownershipTokenCount) = REF_52 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete personIndexToApproved[_tokenId]

IRs:
REF_53(address) -> personIndexToApproved[_tokenId]
personIndexToApproved = delete REF_53 ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
}
",0,1,0,0,"ownershipTokenCount[_to] ++;personIndexToOwner[_tokenId] = _to;_from != address(0);ownershipTokenCount[_from] --;;delete personIndexToApproved[_tokenId];Transfer(_from,_to,_tokenId)"
./0xee395235ac363725c6b895d8994706cb7050482f_ext.sol,TokenERC20.burn,145,151,"REF_17(uint256) -> balanceOf[msg.sender],TMP_25(bool) = REF_17 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_25(bool) = REF_17 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x40ef62929748b3e045fd2036322880ef486e4454_ext.sol,IQ_GAME.StartGame,22,32,"TMP_7(bool) = responseHash == 0,CONDITION TMP_7,TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response),responseHash(bytes32) := TMP_8(bytes32),question(string) := _question(string),questionSender(address) := msg.sender(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
responseHash == 0x0

IRs:
TMP_7(bool) = responseHash == 0
CONDITION TMP_7""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
responseHash = keccak256()(_response)

IRs:
TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response)
responseHash(bytes32) := TMP_8(bytes32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
questionSender = msg.sender

IRs:
questionSender(address) := msg.sender(address)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,1,0,0,responseHash == 0x0;responseHash = keccak256()(_response);;question = _question;questionSender = msg.sender
./0xd64f60148a99c12d18c9cec6140b772364814c83_ext.sol,MyToken.burnFrom,101,109,"REF_15(uint256) -> balanceOf[_from],TMP_18(bool) = REF_15 >= _value,TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18),REF_16(mapping(address => uint256)) -> allowance[_from],REF_17(uint256) -> REF_16[msg.sender],TMP_20(bool) = _value <= REF_17,TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20),REF_18(uint256) -> balanceOf[_from],REF_18(-> balanceOf) = REF_18 - _value,REF_19(mapping(address => uint256)) -> allowance[_from],REF_20(uint256) -> REF_19[msg.sender],REF_20(-> allowance) = REF_20 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_15(uint256) -> balanceOf[_from]
TMP_18(bool) = REF_15 >= _value
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_16(mapping(address => uint256)) -> allowance[_from]
REF_17(uint256) -> REF_16[msg.sender]
TMP_20(bool) = _value <= REF_17
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_18(uint256) -> balanceOf[_from]
REF_18(-> balanceOf) = REF_18 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_19(mapping(address => uint256)) -> allowance[_from]
REF_20(uint256) -> REF_19[msg.sender]
REF_20(-> allowance) = REF_20 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x00416b9d728069edb0ceb04bc2b203fa7336d1f1_ext.sol,SeedCrowdsaleContract.calculateMaxContribution,189,203,"REF_14(SeedCrowdsaleContract.state) -> state.priorityPass,TMP_52(bool) = crowdsaleState == REF_14,CONDITION TMP_52,TMP_53(uint256) = HIGH_LEVEL_CALL, dest:priorityPassContract(PriorityPassInterface), function:getAccountLimit, arguments:['_contributor']  ,REF_16(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor],REF_17(uint256) -> REF_16.contributionAmount,TMP_54(uint256) = TMP_53 - REF_17,maxContrib(uint256) := TMP_54(uint256),TMP_55(uint256) = maxP1Cap - ethRaised,TMP_56(bool) = maxContrib > TMP_55,CONDITION TMP_56,TMP_57(uint256) = maxP1Cap - ethRaised,maxContrib(uint256) := TMP_57(uint256),TMP_58(uint256) = maxCap - ethRaised,maxContrib(uint256) := TMP_58(uint256),RETURN maxContrib,RETURN maxContribution","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
crowdsaleState == state.priorityPass

IRs:
REF_14(SeedCrowdsaleContract.state) -> state.priorityPass
TMP_52(bool) = crowdsaleState == REF_14
CONDITION TMP_52""];
2->3[label=""True""];
2->7[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
maxContrib = priorityPassContract.getAccountLimit(_contributor) - contributorList[_contributor].contributionAmount

IRs:
TMP_53(uint256) = HIGH_LEVEL_CALL, dest:priorityPassContract(PriorityPassInterface), function:getAccountLimit, arguments:['_contributor']  
REF_16(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor]
REF_17(uint256) -> REF_16.contributionAmount
TMP_54(uint256) = TMP_53 - REF_17
maxContrib(uint256) := TMP_54(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
maxContrib > (maxP1Cap - ethRaised)

IRs:
TMP_55(uint256) = maxP1Cap - ethRaised
TMP_56(bool) = maxContrib > TMP_55
CONDITION TMP_56""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
maxContrib = maxP1Cap - ethRaised

IRs:
TMP_57(uint256) = maxP1Cap - ethRaised
maxContrib(uint256) := TMP_57(uint256)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
maxContrib = maxCap - ethRaised

IRs:
TMP_58(uint256) = maxCap - ethRaised
maxContrib(uint256) := TMP_58(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
maxContrib

IRs:
RETURN maxContrib""];
10[label=""Node Type: RETURN 10

EXPRESSION:
maxContribution

IRs:
RETURN maxContribution""];
}
",0,1,0,0,;crowdsaleState == state.priorityPass;maxContrib = priorityPassContract.getAccountLimit(_contributor) - contributorList[_contributor].contributionAmount;maxContrib = maxCap - ethRaised;maxContrib > (maxP1Cap - ethRaised);maxContrib = maxP1Cap - ethRaised;;;maxContrib;maxContribution
./0x05d379b48a8622ae4018309e116420db4a38a225_ext.sol,ELYTE.burn,128,134,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xef906c48b8fde48f5f2ceb448b1163bf964ef4ac_ext.sol,DAX_4000_20200618.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x01d706ed109e2038ae3261e30a1ed1af207a9d2c_ext.sol,ETHERECASHTOKEN.burn,128,134,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xa3c3134b360d8ccf17c4cd8709204e31a7365aa6_ext.sol,FortuneGodToken.changeNameAndSymbol,174,179,"TMP_76(bool) = msg.sender == owner,CONDITION TMP_76,name(string) := _name(string),symbol(string) := _symbol(string)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_76(bool) = msg.sender == owner
CONDITION TMP_76""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
name = _name

IRs:
name(string) := _name(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
symbol = _symbol

IRs:
symbol(string) := _symbol(string)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,msg.sender == owner;name = _name;;symbol = _symbol
./0x6f91e584f4c150951386b133e21aa769c8b7d060_ext.sol,BigbomToken.freezeAccount,359,379,"TMP_102 = UnaryType.BANG freeze ,CONDITION TMP_102,REF_79(uint256) -> frozenTime[target],frozenEndTime(uint256) := REF_79(uint256),TMP_103(bool) = now >= frozenEndTime,TMP_104(None) = SOLIDITY_CALL require(bool)(TMP_103),REF_80(bool) -> frozenAccount[target],REF_80(bool) (->frozenAccount) := freeze(bool),_seconds(uint256) := 0(uint256),REF_81(bool) -> frozenAccount[target],REF_81(bool) (->frozenAccount) := freeze(bool),REF_82(uint256) -> frozenTime[target],TMP_105(uint256) = now + _seconds,REF_82(uint256) (->frozenTime) := TMP_105(uint256),Emit FrozenFunds(target,freeze,_seconds),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: IF 1

EXPRESSION:
! freeze

IRs:
TMP_102 = UnaryType.BANG freeze 
CONDITION TMP_102""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
frozenEndTime = frozenTime[target]

IRs:
REF_79(uint256) -> frozenTime[target]
frozenEndTime(uint256) := REF_79(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(now >= frozenEndTime)

IRs:
TMP_103(bool) = now >= frozenEndTime
TMP_104(None) = SOLIDITY_CALL require(bool)(TMP_103)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
frozenAccount[target] = freeze

IRs:
REF_80(bool) -> frozenAccount[target]
REF_80(bool) (->frozenAccount) := freeze(bool)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_seconds = 0

IRs:
_seconds(uint256) := 0(uint256)""];
5->7;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
frozenAccount[target] = freeze

IRs:
REF_81(bool) -> frozenAccount[target]
REF_81(bool) (->frozenAccount) := freeze(bool)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
frozenTime[target] = now + _seconds

IRs:
REF_82(uint256) -> frozenTime[target]
TMP_105(uint256) = now + _seconds
REF_82(uint256) (->frozenTime) := TMP_105(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
FrozenFunds(target,freeze,_seconds)

IRs:
Emit FrozenFunds(target,freeze,_seconds)""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
10->1;
}
",0,1,0,0,"onlyOwner();! freeze;frozenEndTime = frozenTime[target];frozenAccount[target] = freeze;require(bool)(now >= frozenEndTime);frozenAccount[target] = freeze;_seconds = 0;;frozenTime[target] = now + _seconds;FrozenFunds(target,freeze,_seconds)"
./0x4bbbc57af270138ef2ff2c50dbfad684e9e0e604_ext.sol,TokenERC20.burnFrom,131,139,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x00685230359bdb9e16704e1d3918b553e9a015e2_ext.sol,DigitalPrintImage.createImage,1219,1269,"REF_264 -> LENGTH _potentialAssets,TMP_457(bool) = REF_264 <= 5,TMP_458(None) = SOLIDITY_CALL require(bool)(TMP_457),REF_265(address) -> usernameToAddress[_author],TMP_459(bool) = msg.sender == REF_265,REF_266(bool) -> usernameExists[_author],TMP_460 = UnaryType.BANG REF_266 ,TMP_461(bool) = TMP_459 || TMP_460,TMP_462(None) = SOLIDITY_CALL require(bool)(TMP_461),REF_267(bool) -> usernameExists[_author],TMP_463 = UnaryType.BANG REF_267 ,CONDITION TMP_463,TMP_464 = CONVERT 0 to bytes32,INTERNAL_CALL, UserManager.register(string,bytes32)(_author,TMP_464),TUPLE_1(uint256[],uint256) = INTERNAL_CALL, DigitalPrintImage.getPickedAssetsAndFinalSeed(bytes32[],uint256[],uint256,uint256)(_potentialAssets,_randomHashIds,_timestamp,_iterations),pickedAssets(uint256[])= UNPACK TUPLE_1 index: 0 ,finalSeed(uint256)= UNPACK TUPLE_1 index: 1 ,TMP_466(uint256[]) = HIGH_LEVEL_CALL, dest:assetManager(IAssetManager), function:pickUniquePacks, arguments:['pickedAssets']  ,pickedAssetPacks(uint256[]) = ['TMP_466(uint256[])'],finalPrice(uint256) := 0(uint256),i(uint256) := 0(uint256),REF_269 -> LENGTH pickedAssetPacks,TMP_467(bool) = i < REF_269,CONDITION TMP_467,REF_271(uint256) -> pickedAssetPacks[i],TMP_468(bool) = HIGH_LEVEL_CALL, dest:assetManager(IAssetManager), function:checkHasPermissionForPack, arguments:['msg.sender', 'REF_271']  ,TMP_469(bool) = TMP_468 == False,CONDITION TMP_469,REF_273(uint256) -> pickedAssetPacks[i],TMP_470(uint256) = HIGH_LEVEL_CALL, dest:assetManager(IAssetManager), function:getAssetPackPrice, arguments:['REF_273']  ,finalPrice(uint256) = finalPrice + TMP_470,REF_277(uint256) -> pickedAssetPacks[i],TMP_471(uint256) = HIGH_LEVEL_CALL, dest:assetManager(IAssetManager), function:getAssetPackPrice, arguments:['REF_277']  ,REF_278(uint256) -> pickedAssetPacks[i],HIGH_LEVEL_CALL, dest:assetManager(IAssetManager), function:buyAssetPack, arguments:['msg.sender', 'REF_278'] value:TMP_471 ,TMP_474(uint256) := i(uint256),i(uint256) = i + 1,TMP_475(bool) = msg.value >= finalPrice,TMP_476(None) = SOLIDITY_CALL require(bool)(TMP_475),TMP_477(uint256) = INTERNAL_CALL, ERC721Token.totalSupply()(),id(uint256) := TMP_477(uint256),INTERNAL_CALL, ERC721Token._mint(address,uint256)(msg.sender,id),REF_279(DigitalPrintImage.ImageMetadata) -> imageMetadata[id],TMP_479(DigitalPrintImage.ImageMetadata) = new ImageMetadata(finalSeed,_potentialAssets,_timestamp,msg.sender,_ipfsHash,_extraData),REF_279(DigitalPrintImage.ImageMetadata) (->imageMetadata) := TMP_479(DigitalPrintImage.ImageMetadata),REF_280(string) -> idToIpfsHash[id],REF_280(string) (->idToIpfsHash) := _ipfsHash(string),REF_281(bool) -> seedExists[finalSeed],REF_281(bool) (->seedExists) := True(bool),Emit ImageCreated(id,msg.sender)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_potentialAssets.length <= 5)

IRs:
REF_264 -> LENGTH _potentialAssets
TMP_457(bool) = REF_264 <= 5
TMP_458(None) = SOLIDITY_CALL require(bool)(TMP_457)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == usernameToAddress[_author] || ! usernameExists[_author])

IRs:
REF_265(address) -> usernameToAddress[_author]
TMP_459(bool) = msg.sender == REF_265
REF_266(bool) -> usernameExists[_author]
TMP_460 = UnaryType.BANG REF_266 
TMP_461(bool) = TMP_459 || TMP_460
TMP_462(None) = SOLIDITY_CALL require(bool)(TMP_461)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
! usernameExists[_author]

IRs:
REF_267(bool) -> usernameExists[_author]
TMP_463 = UnaryType.BANG REF_267 
CONDITION TMP_463""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
register(_author,bytes32(0))

IRs:
TMP_464 = CONVERT 0 to bytes32
INTERNAL_CALL, UserManager.register(string,bytes32)(_author,TMP_464)""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: NEW VARIABLE 6
""];
6->7;
7[label=""Node Type: NEW VARIABLE 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
(pickedAssets,finalSeed) = getPickedAssetsAndFinalSeed(_potentialAssets,_randomHashIds,_timestamp,_iterations)

IRs:
TUPLE_1(uint256[],uint256) = INTERNAL_CALL, DigitalPrintImage.getPickedAssetsAndFinalSeed(bytes32[],uint256[],uint256,uint256)(_potentialAssets,_randomHashIds,_timestamp,_iterations)
pickedAssets(uint256[])= UNPACK TUPLE_1 index: 0 
finalSeed(uint256)= UNPACK TUPLE_1 index: 1 ""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
pickedAssetPacks = assetManager.pickUniquePacks(pickedAssets)

IRs:
TMP_466(uint256[]) = HIGH_LEVEL_CALL, dest:assetManager(IAssetManager), function:pickUniquePacks, arguments:['pickedAssets']  
pickedAssetPacks(uint256[]) = ['TMP_466(uint256[])']""];
9->10;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
finalPrice = 0

IRs:
finalPrice(uint256) := 0(uint256)""];
10->13;
11[label=""Node Type: BEGIN_LOOP 11
""];
11->14;
12[label=""Node Type: END_LOOP 12
""];
12->20;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
13->11;
14[label=""Node Type: IF_LOOP 14

EXPRESSION:
i < pickedAssetPacks.length

IRs:
REF_269 -> LENGTH pickedAssetPacks
TMP_467(bool) = i < REF_269
CONDITION TMP_467""];
14->15[label=""True""];
14->12[label=""False""];
15[label=""Node Type: IF 15

EXPRESSION:
assetManager.checkHasPermissionForPack(msg.sender,pickedAssetPacks[i]) == false

IRs:
REF_271(uint256) -> pickedAssetPacks[i]
TMP_468(bool) = HIGH_LEVEL_CALL, dest:assetManager(IAssetManager), function:checkHasPermissionForPack, arguments:['msg.sender', 'REF_271']  
TMP_469(bool) = TMP_468 == False
CONDITION TMP_469""];
15->16[label=""True""];
15->18[label=""False""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
finalPrice += assetManager.getAssetPackPrice(pickedAssetPacks[i])

IRs:
REF_273(uint256) -> pickedAssetPacks[i]
TMP_470(uint256) = HIGH_LEVEL_CALL, dest:assetManager(IAssetManager), function:getAssetPackPrice, arguments:['REF_273']  
finalPrice(uint256) = finalPrice + TMP_470""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
assetManager.buyAssetPack.value(assetManager.getAssetPackPrice(pickedAssetPacks[i]))(msg.sender,pickedAssetPacks[i])

IRs:
REF_277(uint256) -> pickedAssetPacks[i]
TMP_471(uint256) = HIGH_LEVEL_CALL, dest:assetManager(IAssetManager), function:getAssetPackPrice, arguments:['REF_277']  
REF_278(uint256) -> pickedAssetPacks[i]
HIGH_LEVEL_CALL, dest:assetManager(IAssetManager), function:buyAssetPack, arguments:['msg.sender', 'REF_278'] value:TMP_471 ""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
i ++

IRs:
TMP_474(uint256) := i(uint256)
i(uint256) = i + 1""];
19->14;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
require(bool)(msg.value >= finalPrice)

IRs:
TMP_475(bool) = msg.value >= finalPrice
TMP_476(None) = SOLIDITY_CALL require(bool)(TMP_475)""];
20->21;
21[label=""Node Type: NEW VARIABLE 21

EXPRESSION:
id = totalSupply()

IRs:
TMP_477(uint256) = INTERNAL_CALL, ERC721Token.totalSupply()()
id(uint256) := TMP_477(uint256)""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
_mint(msg.sender,id)

IRs:
INTERNAL_CALL, ERC721Token._mint(address,uint256)(msg.sender,id)""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
imageMetadata[id] = ImageMetadata({finalSeed:finalSeed,potentialAssets:_potentialAssets,timestamp:_timestamp,creator:msg.sender,ipfsHash:_ipfsHash,extraData:_extraData})

IRs:
REF_279(DigitalPrintImage.ImageMetadata) -> imageMetadata[id]
TMP_479(DigitalPrintImage.ImageMetadata) = new ImageMetadata(finalSeed,_potentialAssets,_timestamp,msg.sender,_ipfsHash,_extraData)
REF_279(DigitalPrintImage.ImageMetadata) (->imageMetadata) := TMP_479(DigitalPrintImage.ImageMetadata)""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
idToIpfsHash[id] = _ipfsHash

IRs:
REF_280(string) -> idToIpfsHash[id]
REF_280(string) (->idToIpfsHash) := _ipfsHash(string)""];
24->25;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
seedExists[finalSeed] = true

IRs:
REF_281(bool) -> seedExists[finalSeed]
REF_281(bool) (->seedExists) := True(bool)""];
25->26;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
ImageCreated(id,msg.sender)

IRs:
Emit ImageCreated(id,msg.sender)""];
}
",0,1,0,0,"require(bool)(_potentialAssets.length <= 5);require(bool)(msg.sender == usernameToAddress[_author] || ! usernameExists[_author]);! usernameExists[_author];register(_author,bytes32(0));;;;(pickedAssets,finalSeed) = getPickedAssetsAndFinalSeed(_potentialAssets,_randomHashIds,_timestamp,_iterations);pickedAssetPacks = assetManager.pickUniquePacks(pickedAssets);finalPrice = 0;i = 0;;i < pickedAssetPacks.length;;require(bool)(msg.value >= finalPrice);assetManager.checkHasPermissionForPack(msg.sender,pickedAssetPacks[i]) == false;finalPrice += assetManager.getAssetPackPrice(pickedAssetPacks[i]);;assetManager.buyAssetPack.value(assetManager.getAssetPackPrice(pickedAssetPacks[i]))(msg.sender,pickedAssetPacks[i]);i ++;id = totalSupply();_mint(msg.sender,id);imageMetadata[id] = ImageMetadata({finalSeed:finalSeed,potentialAssets:_potentialAssets,timestamp:_timestamp,creator:msg.sender,ipfsHash:_ipfsHash,extraData:_extraData});idToIpfsHash[id] = _ipfsHash;seedExists[finalSeed] = true;ImageCreated(id,msg.sender)"
./0xd9ff8cc0433c995f3a9711f1400329cd6a40387f_ext.sol,EtherKnightGame.initRace,448,488,"TMP_62(uint256) := this_gRND(uint256),this_gRND(uint256) = this_gRND + 1,REF_34(EtherKnightGame.GameRoundData_s) -> GameRoundData[this_gRND],_GameRoundData(EtherKnightGame.GameRoundData_s) := REF_34(EtherKnightGame.GameRoundData_s),i(uint256) := 0(uint256),TMP_63(bool) = i < 4,CONDITION TMP_63,REF_35(uint8) -> this_Perso_Type[i],REF_36(uint8) -> p[i],REF_35(uint8) (->this_Perso_Type) := REF_36(uint8),REF_37(uint32[8]) -> _GameRoundData.persoData,REF_38(uint32) -> REF_37[i],REF_38(uint32) (->_GameRoundData) := 100(uint256),REF_39(uint32[8]) -> _GameRoundData.persoData,TMP_64(uint256) = 4 + i,REF_40(uint32) -> REF_39[TMP_64],REF_40(uint32) (->_GameRoundData) := 25(uint256),TMP_65(uint256) := i(uint256),i(uint256) = i + 1,REF_41(uint256) -> _GameRoundData.blockNumber,REF_41(uint256) (->_GameRoundData) := block.number(uint256),REF_42(uint256) -> _GameRoundData.blockNumberTimeout,TMP_66(uint256) = 360 * 10,TMP_67(uint256) = TMP_66 * 24,TMP_68(uint256) = TMP_67 * 3600,TMP_69(uint256) = block.number + TMP_68,REF_42(uint256) (->_GameRoundData) := TMP_69(uint256),_sharePrice(uint256) := 1000000000000000(uint256),REF_43(uint256) -> _GameRoundData.sharePrice,REF_43(uint256) (->_GameRoundData) := _sharePrice(uint256),TMP_70(uint256) = INTERNAL_CALL, EtherKnightGame.buyTreasureShares(EtherKnightGame.GameRoundData_s,uint256)(_GameRoundData,genTreasure),_nbshares(uint256) := TMP_70(uint256),TMP_71(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_nbshares', '_sharePrice'] ,TMP_72(uint256) = TMP_71 / magnitude,_nbshares(uint256) := TMP_72(uint256),REF_45(uint256) -> _GameRoundData.shareEthBalance,REF_45(uint256) (->_GameRoundData) := _nbshares(uint256),TMP_73(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['genTreasure', '_nbshares'] ,genTreasure(uint256) := TMP_73(uint256),Emit onNewRace(this_gRND,p,block.number),MODIFIER_CALL, EtherKnightGame.onlyOwner()(),MODIFIER_CALL, EtherKnightGame.isNotMaintenance()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->20;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
this_gRND ++

IRs:
TMP_62(uint256) := this_gRND(uint256)
this_gRND(uint256) = this_gRND + 1""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
_GameRoundData = GameRoundData[this_gRND]

IRs:
REF_34(EtherKnightGame.GameRoundData_s) -> GameRoundData[this_gRND]
_GameRoundData(EtherKnightGame.GameRoundData_s) := REF_34(EtherKnightGame.GameRoundData_s)""];
2->5;
3[label=""Node Type: BEGIN_LOOP 3
""];
3->6;
4[label=""Node Type: END_LOOP 4
""];
4->11;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
5->3;
6[label=""Node Type: IF_LOOP 6

EXPRESSION:
i < 4

IRs:
TMP_63(bool) = i < 4
CONDITION TMP_63""];
6->7[label=""True""];
6->4[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
this_Perso_Type[i] = p[i]

IRs:
REF_35(uint8) -> this_Perso_Type[i]
REF_36(uint8) -> p[i]
REF_35(uint8) (->this_Perso_Type) := REF_36(uint8)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
_GameRoundData.persoData[i] = 100

IRs:
REF_37(uint32[8]) -> _GameRoundData.persoData
REF_38(uint32) -> REF_37[i]
REF_38(uint32) (->_GameRoundData) := 100(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
_GameRoundData.persoData[4 + i] = 25

IRs:
REF_39(uint32[8]) -> _GameRoundData.persoData
TMP_64(uint256) = 4 + i
REF_40(uint32) -> REF_39[TMP_64]
REF_40(uint32) (->_GameRoundData) := 25(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
i ++

IRs:
TMP_65(uint256) := i(uint256)
i(uint256) = i + 1""];
10->6;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
_GameRoundData.blockNumber = block.number

IRs:
REF_41(uint256) -> _GameRoundData.blockNumber
REF_41(uint256) (->_GameRoundData) := block.number(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
_GameRoundData.blockNumberTimeout = block.number + (360 * 10 * 24 * 3600)

IRs:
REF_42(uint256) -> _GameRoundData.blockNumberTimeout
TMP_66(uint256) = 360 * 10
TMP_67(uint256) = TMP_66 * 24
TMP_68(uint256) = TMP_67 * 3600
TMP_69(uint256) = block.number + TMP_68
REF_42(uint256) (->_GameRoundData) := TMP_69(uint256)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
_sharePrice = 1000000000000000

IRs:
_sharePrice(uint256) := 1000000000000000(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
_GameRoundData.sharePrice = _sharePrice

IRs:
REF_43(uint256) -> _GameRoundData.sharePrice
REF_43(uint256) (->_GameRoundData) := _sharePrice(uint256)""];
14->15;
15[label=""Node Type: NEW VARIABLE 15

EXPRESSION:
_nbshares = buyTreasureShares(_GameRoundData,genTreasure)

IRs:
TMP_70(uint256) = INTERNAL_CALL, EtherKnightGame.buyTreasureShares(EtherKnightGame.GameRoundData_s,uint256)(_GameRoundData,genTreasure)
_nbshares(uint256) := TMP_70(uint256)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
_nbshares = _nbshares.mul(_sharePrice) / magnitude

IRs:
TMP_71(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_nbshares', '_sharePrice'] 
TMP_72(uint256) = TMP_71 / magnitude
_nbshares(uint256) := TMP_72(uint256)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
_GameRoundData.shareEthBalance = _nbshares

IRs:
REF_45(uint256) -> _GameRoundData.shareEthBalance
REF_45(uint256) (->_GameRoundData) := _nbshares(uint256)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
genTreasure = genTreasure.sub(_nbshares)

IRs:
TMP_73(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['genTreasure', '_nbshares'] 
genTreasure(uint256) := TMP_73(uint256)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
onNewRace(this_gRND,p,block.number)

IRs:
Emit onNewRace(this_gRND,p,block.number)""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, EtherKnightGame.onlyOwner()()""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
isNotMaintenance()

IRs:
MODIFIER_CALL, EtherKnightGame.isNotMaintenance()()""];
21->1;
}
",0,1,0,0,"onlyOwner();this_gRND ++;_GameRoundData = GameRoundData[this_gRND];i = 0;;i < 4;;_GameRoundData.blockNumber = block.number;this_Perso_Type[i] = p[i];_GameRoundData.persoData[i] = 100;_GameRoundData.persoData[4 + i] = 25;i ++;_GameRoundData.blockNumberTimeout = block.number + (360 * 10 * 24 * 3600);_sharePrice = 1000000000000000;_GameRoundData.sharePrice = _sharePrice;_nbshares = buyTreasureShares(_GameRoundData,genTreasure);_nbshares = _nbshares.mul(_sharePrice) / magnitude;_GameRoundData.shareEthBalance = _nbshares;genTreasure = genTreasure.sub(_nbshares);onNewRace(this_gRND,p,block.number);isNotMaintenance()"
./0xc094367b4c79564b6c8b4218f84dea835b2c2dd0_ext.sol,TikiMadness.priceOf,304,318,"REF_48(TikiMadness.TikiMask) -> tikiMasks[_tokenId],tiki(TikiMadness.TikiMask) := REF_48(TikiMadness.TikiMask),REF_49(uint256) -> tiki.saleTime,TMP_63(uint256) = now - REF_49,secondsPassed(uint256) := TMP_63(uint256),REF_50(uint256) -> tiki.fallDuration,TMP_64(bool) = secondsPassed >= REF_50,REF_51(uint256) -> tiki.highPrice,REF_52(uint256) -> tiki.basePrice,TMP_65(bool) = REF_51 == REF_52,TMP_66(bool) = TMP_64 || TMP_65,CONDITION TMP_66,REF_53(uint256) -> tiki.basePrice,RETURN REF_53,REF_54(uint256) -> tiki.highPrice,REF_55(uint256) -> tiki.basePrice,TMP_67(uint256) = REF_54 - REF_55,totalPriceChange(uint256) := TMP_67(uint256),TMP_68(uint256) = totalPriceChange * secondsPassed,REF_56(uint256) -> tiki.fallDuration,TMP_69(uint256) = TMP_68 / REF_56,currentPriceChange(uint256) := TMP_69(uint256),REF_57(uint256) -> tiki.highPrice,TMP_70(uint256) = REF_57 - currentPriceChange,currentPrice(uint256) := TMP_70(uint256),RETURN currentPrice,RETURN price","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tiki = tikiMasks[_tokenId]

IRs:
REF_48(TikiMadness.TikiMask) -> tikiMasks[_tokenId]
tiki(TikiMadness.TikiMask) := REF_48(TikiMadness.TikiMask)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
secondsPassed = now - tiki.saleTime

IRs:
REF_49(uint256) -> tiki.saleTime
TMP_63(uint256) = now - REF_49
secondsPassed(uint256) := TMP_63(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
secondsPassed >= tiki.fallDuration || tiki.highPrice == tiki.basePrice

IRs:
REF_50(uint256) -> tiki.fallDuration
TMP_64(bool) = secondsPassed >= REF_50
REF_51(uint256) -> tiki.highPrice
REF_52(uint256) -> tiki.basePrice
TMP_65(bool) = REF_51 == REF_52
TMP_66(bool) = TMP_64 || TMP_65
CONDITION TMP_66""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: RETURN 4

EXPRESSION:
tiki.basePrice

IRs:
REF_53(uint256) -> tiki.basePrice
RETURN REF_53""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
totalPriceChange = tiki.highPrice - tiki.basePrice

IRs:
REF_54(uint256) -> tiki.highPrice
REF_55(uint256) -> tiki.basePrice
TMP_67(uint256) = REF_54 - REF_55
totalPriceChange(uint256) := TMP_67(uint256)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
currentPriceChange = totalPriceChange * secondsPassed / tiki.fallDuration

IRs:
TMP_68(uint256) = totalPriceChange * secondsPassed
REF_56(uint256) -> tiki.fallDuration
TMP_69(uint256) = TMP_68 / REF_56
currentPriceChange(uint256) := TMP_69(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
currentPrice = tiki.highPrice - currentPriceChange

IRs:
REF_57(uint256) -> tiki.highPrice
TMP_70(uint256) = REF_57 - currentPriceChange
currentPrice(uint256) := TMP_70(uint256)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
currentPrice

IRs:
RETURN currentPrice""];
10[label=""Node Type: RETURN 10

EXPRESSION:
price

IRs:
RETURN price""];
}
",0,1,0,0,tiki = tikiMasks[_tokenId];secondsPassed = now - tiki.saleTime;secondsPassed >= tiki.fallDuration || tiki.highPrice == tiki.basePrice;tiki.basePrice;;totalPriceChange = tiki.highPrice - tiki.basePrice;currentPriceChange = totalPriceChange * secondsPassed / tiki.fallDuration;currentPrice = tiki.highPrice - currentPriceChange;currentPrice;price
./0xcd6f276334fd457d79fc04bca5f52393347c47a7_ext.sol,ChessClubLiveChessCoin.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x379f2596d4c4a417ef1023b81c8b9ff5419b13d4_ext.sol,EncryptedToken.mintToken,135,140,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x27223d03b1cbe352789c65024cbaf71ab5c90824_ext.sol,BUTT.transferFrom,39,45,"REF_5(uint256) -> balances[_from],TMP_9(bool) = REF_5 >= _value,REF_6(mapping(address => uint256)) -> allowed[_from],REF_7(uint256) -> REF_6[msg.sender],TMP_10(bool) = REF_7 >= _value,TMP_11(bool) = TMP_9 && TMP_10,TMP_12(bool) = _value > 0,TMP_13(bool) = TMP_11 && TMP_12,TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13),REF_8(uint256) -> balances[_to],REF_8(-> balances) = REF_8 + _value,REF_9(uint256) -> balances[_from],REF_9(-> balances) = REF_9 - _value,REF_10(mapping(address => uint256)) -> allowed[_from],REF_11(uint256) -> REF_10[msg.sender],REF_11(-> allowed) = REF_11 - _value,Emit Transfer(_from,_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0)

IRs:
REF_5(uint256) -> balances[_from]
TMP_9(bool) = REF_5 >= _value
REF_6(mapping(address => uint256)) -> allowed[_from]
REF_7(uint256) -> REF_6[msg.sender]
TMP_10(bool) = REF_7 >= _value
TMP_11(bool) = TMP_9 && TMP_10
TMP_12(bool) = _value > 0
TMP_13(bool) = TMP_11 && TMP_12
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_8(uint256) -> balances[_to]
REF_8(-> balances) = REF_8 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_9(uint256) -> balances[_from]
REF_9(-> balances) = REF_9 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_10(mapping(address => uint256)) -> allowed[_from]
REF_11(uint256) -> REF_10[msg.sender]
REF_11(-> allowed) = REF_11 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
}
",0,1,0,0,"require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);balances[_to] += _value;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value)"
./0x77e89cb283f39ed72f4383c6eec786bd7e7c12d5_ext.sol,eBitcoinCash.distributeeBitcoinCashMedium,50,59,"i(uint256) := 0(uint256),REF_7 -> LENGTH addresses,TMP_8(bool) = i < REF_7,CONDITION TMP_8,REF_8(uint256) -> balances[owner],REF_8(-> balances) = REF_8 - 491439832000,REF_9(uint256) -> balances[owner],TMP_9(bool) = REF_9 >= 0,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_10(address) -> addresses[i],REF_11(uint256) -> balances[REF_10],REF_11(-> balances) = REF_11 + 491439832000,REF_12(address) -> addresses[i],Emit Transfer(owner,REF_12,491439832000),TMP_12(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, eBitcoinCash.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addresses.length

IRs:
REF_7 -> LENGTH addresses
TMP_8(bool) = i < REF_7
CONDITION TMP_8""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[owner] -= 491439832000

IRs:
REF_8(uint256) -> balances[owner]
REF_8(-> balances) = REF_8 - 491439832000""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(balances[owner] >= 0)

IRs:
REF_9(uint256) -> balances[owner]
TMP_9(bool) = REF_9 >= 0
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[addresses[i]] += 491439832000

IRs:
REF_10(address) -> addresses[i]
REF_11(uint256) -> balances[REF_10]
REF_11(-> balances) = REF_11 + 491439832000""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(owner,addresses[i],491439832000)

IRs:
REF_12(address) -> addresses[i]
Emit Transfer(owner,REF_12,491439832000)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_12(uint256) := i(uint256)
i(uint256) = i + 1""];
9->4;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, eBitcoinCash.onlyOwner()()""];
10->3;
}
",0,1,0,0,"onlyOwner();;i < addresses.length;;i = 0;balances[owner] -= 491439832000;require(bool)(balances[owner] >= 0);balances[addresses[i]] += 491439832000;Transfer(owner,addresses[i],491439832000);i ++"
./0x1c307a39511c16f74783fcd0091a921ec29a0b51_ext.sol,EthVerifyCore.disApproveUsers,42,46,"i(uint256) := 0(uint256),REF_7 -> LENGTH addresses,TMP_7(bool) = i < REF_7,CONDITION TMP_7,REF_8(address) -> addresses[i],REF_9(bool) -> verifiedUsers[REF_8],REF_9(bool) (->verifiedUsers) := False(bool),TMP_8(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, EthVerifyCore.onlyAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addresses.length

IRs:
REF_7 -> LENGTH addresses
TMP_7(bool) = i < REF_7
CONDITION TMP_7""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
verifiedUsers[addresses[i]] = false

IRs:
REF_8(address) -> addresses[i]
REF_9(bool) -> verifiedUsers[REF_8]
REF_9(bool) (->verifiedUsers) := False(bool)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_8(uint256) := i(uint256)
i(uint256) = i + 1""];
6->4;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, EthVerifyCore.onlyAdmin()()""];
7->3;
}
",0,1,0,0,onlyAdmin();;i < addresses.length;;i = 0;verifiedUsers[addresses[i]] = false;i ++
./0x0868ce9bb32f4abedc83190ba5960a2863dc8646_ext.sol,TEHRAN_Portfolio_Ib_883.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0xaa57e849341a2899110ba676a49302c069251d19_ext.sol,PaintingStorage.decreaseOwnershipTokenCount,459,461,"REF_65(uint256) -> ownershipTokenCount[_address],TMP_223(uint256) := REF_65(uint256),REF_65(-> ownershipTokenCount) = REF_65 - 1,MODIFIER_CALL, BaseStorage.canWrite()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownershipTokenCount[_address] --

IRs:
REF_65(uint256) -> ownershipTokenCount[_address]
TMP_223(uint256) := REF_65(uint256)
REF_65(-> ownershipTokenCount) = REF_65 - 1""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
canWrite()

IRs:
MODIFIER_CALL, BaseStorage.canWrite()()""];
2->1;
}
",0,1,0,0,canWrite();ownershipTokenCount[_address] --
./0xcdb290f8a2315bb0c752eb16cab426eae7afb5c2_ext.sol,VOCC_I074_20181211.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.signupUserWhitelist,2,2,"REF_33 -> LENGTH _userlist,TMP_82(bool) = REF_33 > 0,TMP_83(None) = SOLIDITY_CALL require(bool)(TMP_82),REF_34 -> LENGTH _amount,TMP_84(bool) = REF_34 > 0,TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84),i(uint256) := 0(uint256),REF_35 -> LENGTH _userlist,TMP_86(bool) = i < REF_35,CONDITION TMP_86,REF_36(address) -> _userlist[i],baddr(address) := REF_36(address),REF_37(uint256) -> _amount[i],bval(uint256) := REF_37(uint256),TMP_87 = CONVERT 0 to address,TMP_88(bool) = baddr != TMP_87,TMP_89(bool) = userSignupCount <= maxSignup,TMP_90(bool) = TMP_88 && TMP_89,CONDITION TMP_90,REF_38(KahnDistributionCentre.User) -> bounties[baddr],REF_39(bool) -> REF_38.blacklisted,TMP_91 = UnaryType.BANG REF_39 ,REF_40(KahnDistributionCentre.User) -> bounties[baddr],REF_41(address) -> REF_40.user_address,TMP_92(bool) = REF_41 != baddr,TMP_93(bool) = TMP_91 && TMP_92,CONDITION TMP_93,REF_42(KahnDistributionCentre.User) -> bounties[baddr],TMP_94(KahnDistributionCentre.User) = new User(baddr,now,bval,False,0,0,True),REF_42(KahnDistributionCentre.User) (->bounties) := TMP_94(KahnDistributionCentre.User),REF_43(bool) -> signups[baddr],REF_43(bool) (->signups) := True(bool),REF_45 -> LENGTH bountyaddress,TMP_97(uint256) := REF_45(uint256),TMP_98(uint256) = TMP_97 + 1,REF_45(uint256) (->bountyaddress) := TMP_98(uint256),REF_46(address) -> bountyaddress[TMP_97],REF_46(address) (->bountyaddress) := baddr(address),TMP_96(None) = TMP_95 - 1,TMP_99(uint256) := userSignupCount(uint256),userSignupCount(uint256) = userSignupCount + 1,TMP_100(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, KahnDistributionCentre.onlyStaffs()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->18;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_userlist.length > 0)

IRs:
REF_33 -> LENGTH _userlist
TMP_82(bool) = REF_33 > 0
TMP_83(None) = SOLIDITY_CALL require(bool)(TMP_82)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amount.length > 0)

IRs:
REF_34 -> LENGTH _amount
TMP_84(bool) = REF_34 > 0
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)""];
2->5;
3[label=""Node Type: BEGIN_LOOP 3
""];
3->6;
4[label=""Node Type: END_LOOP 4
""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
5->3;
6[label=""Node Type: IF_LOOP 6

EXPRESSION:
i < _userlist.length

IRs:
REF_35 -> LENGTH _userlist
TMP_86(bool) = i < REF_35
CONDITION TMP_86""];
6->7[label=""True""];
6->4[label=""False""];
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
baddr = _userlist[i]

IRs:
REF_36(address) -> _userlist[i]
baddr(address) := REF_36(address)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
bval = _amount[i]

IRs:
REF_37(uint256) -> _amount[i]
bval(uint256) := REF_37(uint256)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
baddr != address(0) && userSignupCount <= maxSignup

IRs:
TMP_87 = CONVERT 0 to address
TMP_88(bool) = baddr != TMP_87
TMP_89(bool) = userSignupCount <= maxSignup
TMP_90(bool) = TMP_88 && TMP_89
CONDITION TMP_90""];
9->10[label=""True""];
9->16[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
! bounties[baddr].blacklisted && bounties[baddr].user_address != baddr

IRs:
REF_38(KahnDistributionCentre.User) -> bounties[baddr]
REF_39(bool) -> REF_38.blacklisted
TMP_91 = UnaryType.BANG REF_39 
REF_40(KahnDistributionCentre.User) -> bounties[baddr]
REF_41(address) -> REF_40.user_address
TMP_92(bool) = REF_41 != baddr
TMP_93(bool) = TMP_91 && TMP_92
CONDITION TMP_93""];
10->11[label=""True""];
10->15[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
bounties[baddr] = User(baddr,now,bval,false,0,0,true)

IRs:
REF_42(KahnDistributionCentre.User) -> bounties[baddr]
TMP_94(KahnDistributionCentre.User) = new User(baddr,now,bval,False,0,0,True)
REF_42(KahnDistributionCentre.User) (->bounties) := TMP_94(KahnDistributionCentre.User)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
signups[baddr] = true

IRs:
REF_43(bool) -> signups[baddr]
REF_43(bool) (->signups) := True(bool)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
bountyaddress.push(baddr) - 1

IRs:
REF_45 -> LENGTH bountyaddress
TMP_97(uint256) := REF_45(uint256)
TMP_98(uint256) = TMP_97 + 1
REF_45(uint256) (->bountyaddress) := TMP_98(uint256)
REF_46(address) -> bountyaddress[TMP_97]
REF_46(address) (->bountyaddress) := baddr(address)
TMP_96(None) = TMP_95 - 1""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
userSignupCount ++

IRs:
TMP_99(uint256) := userSignupCount(uint256)
userSignupCount(uint256) = userSignupCount + 1""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
i ++

IRs:
TMP_100(uint256) := i(uint256)
i(uint256) = i + 1""];
17->6;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
onlyStaffs()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyStaffs()()""];
18->1;
}
",0,1,1,0,"onlyStaffs();require(bool)(_userlist.length > 0);require(bool)(_amount.length > 0);i = 0;;i < _userlist.length;;baddr = _userlist[i];bval = _amount[i];baddr != address(0) && userSignupCount <= maxSignup;! bounties[baddr].blacklisted && bounties[baddr].user_address != baddr;;bounties[baddr] = User(baddr,now,bval,false,0,0,true);;signups[baddr] = true;bountyaddress.push(baddr) - 1;userSignupCount ++;i ++"
./0x0353813310f99e7f26cbee085917d0de5964d386_ext.sol,SIPToken.burn,49,55,"REF_16(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_16 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_17(uint256) -> balanceOf[msg.sender],REF_17(-> balanceOf) = REF_17 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_16(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_16 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
REF_17(-> balanceOf) = REF_17 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x6fa8b7532cae4e8feedadfb4a757a43ae5243165_ext.sol,BING.burn,94,99,"REF_17(uint256) -> balanceOf[msg.sender],TMP_34(bool) = REF_17 >= _value,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_34(bool) = REF_17 >= _value
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x17b4ae55a5b0b6c10b0f4bae2d75a4e83de41709_ext.sol,Util.add,20,25,"REF_0(mapping(address => Util.Object)) -> list.registry,REF_1(Util.Object) -> REF_0[_addr],REF_2(bool) -> REF_1.isObject,REF_2(bool) (->list) := True(bool),REF_3(mapping(address => Util.Object)) -> list.registry,REF_4(Util.Object) -> REF_3[_addr],REF_5(uint256) -> REF_4.index,REF_6(uint256) -> list.length,REF_5(uint256) (->list) := REF_6(uint256),REF_7(mapping(address => Util.Object)) -> list.registry,REF_8(Util.Object) -> REF_7[_addr],REF_9(bytes32) -> REF_8.badge,REF_9(bytes32) (->list) := _badge(bytes32),REF_10(uint256) -> list.length,TMP_0(uint256) := REF_10(uint256),REF_10(-> list) = REF_10 + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
list.registry[_addr].isObject = true

IRs:
REF_0(mapping(address => Util.Object)) -> list.registry
REF_1(Util.Object) -> REF_0[_addr]
REF_2(bool) -> REF_1.isObject
REF_2(bool) (->list) := True(bool)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
list.registry[_addr].index = list.length

IRs:
REF_3(mapping(address => Util.Object)) -> list.registry
REF_4(Util.Object) -> REF_3[_addr]
REF_5(uint256) -> REF_4.index
REF_6(uint256) -> list.length
REF_5(uint256) (->list) := REF_6(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
list.registry[_addr].badge = _badge

IRs:
REF_7(mapping(address => Util.Object)) -> list.registry
REF_8(Util.Object) -> REF_7[_addr]
REF_9(bytes32) -> REF_8.badge
REF_9(bytes32) (->list) := _badge(bytes32)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
list.length ++

IRs:
REF_10(uint256) -> list.length
TMP_0(uint256) := REF_10(uint256)
REF_10(-> list) = REF_10 + 1""];
}
",0,1,0,0,list.registry[_addr].isObject = true;list.registry[_addr].index = list.length;list.registry[_addr].badge = _badge;list.length ++
./0x02e492fc1ef9466260d91d087057de601b874b7d_ext.sol,Bitcoinpremier.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x29daf1dc4eb5c8b519b24d06812a0f92a5d973ae_ext.sol,TokenERC20._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x00285f9aad90013a782fb6c85584d97f120b54d8_ext.sol,TokenERC20.burnFrom,166,174,"REF_19(uint256) -> balanceOf[_from],TMP_29(bool) = REF_19 >= _value,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_31(bool) = _value <= REF_21,TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_29(bool) = REF_19 >= _value
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_31(bool) = _value <= REF_21
TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xc352add7ad8cac8baa839d8c88e7e9d7df9a219b_ext.sol,Fibonzi.getPoolOwners,246,252,"TMP_142(address[])  = new address[](poolCount),poolOwners(address[]) = ['TMP_142(address[])'],i(uint8) := 1(uint256),TMP_143(uint8) = poolCount + 1,TMP_144(bool) = i < TMP_143,CONDITION TMP_144,TMP_145(uint8) = i - 1,REF_97(address) -> poolOwners[TMP_145],REF_98(Fibonzi.Pool) -> pools[i],REF_99(address) -> REF_98.owner,REF_97(address) (->poolOwners) := REF_99(address),TMP_146(uint8) := i(uint8),i(uint8) = i + 1,RETURN poolOwners","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
poolOwners = new address[](poolCount)

IRs:
TMP_142(address[])  = new address[](poolCount)
poolOwners(address[]) = ['TMP_142(address[])']""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
3->8;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 1

IRs:
i(uint8) := 1(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < poolCount + 1

IRs:
TMP_143(uint8) = poolCount + 1
TMP_144(bool) = i < TMP_143
CONDITION TMP_144""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
poolOwners[i - 1] = pools[i].owner

IRs:
TMP_145(uint8) = i - 1
REF_97(address) -> poolOwners[TMP_145]
REF_98(Fibonzi.Pool) -> pools[i]
REF_99(address) -> REF_98.owner
REF_97(address) (->poolOwners) := REF_99(address)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_146(uint8) := i(uint8)
i(uint8) = i + 1""];
7->5;
8[label=""Node Type: RETURN 8

EXPRESSION:
poolOwners

IRs:
RETURN poolOwners""];
}
",0,1,0,0,poolOwners = new address[](poolCount);i = 1;;i < poolCount + 1;;poolOwners;poolOwners[i - 1] = pools[i].owner;i ++
./0x74e711f1179f559e1cd7817050cf198b67129269_ext.sol,BitcoinRed.totalSupply,134,136,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x2e8d19eebcd9ff385b8c00f206ddd32e883189c5_ext.sol,HeavenlyHoundCoin.burn,117,123,"REF_14(uint256) -> balanceOf[msg.sender],TMP_67(bool) = REF_14 >= _value,TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67),REF_15(uint256) -> balanceOf[msg.sender],REF_15(-> balanceOf) = REF_15 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,MODIFIER_CALL, HeavenlyHoundCoin.onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_14(uint256) -> balanceOf[msg.sender]
TMP_67(bool) = REF_14 >= _value
TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_15(uint256) -> balanceOf[msg.sender]
REF_15(-> balanceOf) = REF_15 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, HeavenlyHoundCoin.onlyOwner()()""];
6->1;
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"onlyOwner();require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xf4702b0918a8a89dfc38459ce42198834818f26b_ext.sol,multiowned.confirmAndCheck,150,185,"TMP_61 = CONVERT msg.sender to uint256,REF_27(uint256) -> m_ownerIndex[TMP_61],ownerIndex(uint256) := REF_27(uint256),TMP_62(bool) = ownerIndex == 0,CONDITION TMP_62,REF_28(multiowned.PendingState) -> m_pending[_operation],pending(multiowned.PendingState) := REF_28(multiowned.PendingState),REF_29(uint256) -> pending.yetNeeded,TMP_63(bool) = REF_29 == 0,CONDITION TMP_63,REF_30(uint256) -> pending.yetNeeded,REF_30(uint256) (->pending) := m_required(uint256),REF_31(uint256) -> pending.ownersDone,REF_31(uint256) (->pending) := 0(uint256),REF_32(uint256) -> pending.index,REF_33 -> LENGTH m_pendingIndex,TMP_64(uint256) := REF_33(uint256),REF_33(-> m_pendingIndex) = REF_33 + 1,REF_32(uint256) (->pending) := TMP_64(uint256),REF_34(uint256) -> pending.index,REF_35(bytes32) -> m_pendingIndex[REF_34],REF_35(bytes32) (->m_pendingIndex) := _operation(bytes32),TMP_65(uint256) = 2 ** ownerIndex,ownerIndexBit(uint256) := TMP_65(uint256),REF_36(uint256) -> pending.ownersDone,TMP_66(uint256) = REF_36 & ownerIndexBit,TMP_67(bool) = TMP_66 == 0,CONDITION TMP_67,Emit Confirmation(msg.sender,_operation),REF_37(uint256) -> pending.yetNeeded,TMP_69(bool) = REF_37 <= 1,CONDITION TMP_69,REF_38(multiowned.PendingState) -> m_pending[_operation],REF_39(uint256) -> REF_38.index,REF_40(bytes32) -> m_pendingIndex[REF_39],m_pendingIndex = delete REF_40 ,REF_41(multiowned.PendingState) -> m_pending[_operation],m_pending = delete REF_41 ,RETURN True,REF_42(uint256) -> pending.yetNeeded,TMP_70(uint256) := REF_42(uint256),REF_42(-> pending) = REF_42 - 1,REF_43(uint256) -> pending.ownersDone,REF_43(-> pending) = REF_43 | ownerIndexBit","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
ownerIndex = m_ownerIndex[uint256(msg.sender)]

IRs:
TMP_61 = CONVERT msg.sender to uint256
REF_27(uint256) -> m_ownerIndex[TMP_61]
ownerIndex(uint256) := REF_27(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
ownerIndex == 0

IRs:
TMP_62(bool) = ownerIndex == 0
CONDITION TMP_62""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
pending = m_pending[_operation]

IRs:
REF_28(multiowned.PendingState) -> m_pending[_operation]
pending(multiowned.PendingState) := REF_28(multiowned.PendingState)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
pending.yetNeeded == 0

IRs:
REF_29(uint256) -> pending.yetNeeded
TMP_63(bool) = REF_29 == 0
CONDITION TMP_63""];
6->7[label=""True""];
6->11[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
pending.yetNeeded = m_required

IRs:
REF_30(uint256) -> pending.yetNeeded
REF_30(uint256) (->pending) := m_required(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
pending.ownersDone = 0

IRs:
REF_31(uint256) -> pending.ownersDone
REF_31(uint256) (->pending) := 0(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
pending.index = m_pendingIndex.length ++

IRs:
REF_32(uint256) -> pending.index
REF_33 -> LENGTH m_pendingIndex
TMP_64(uint256) := REF_33(uint256)
REF_33(-> m_pendingIndex) = REF_33 + 1
REF_32(uint256) (->pending) := TMP_64(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
m_pendingIndex[pending.index] = _operation

IRs:
REF_34(uint256) -> pending.index
REF_35(bytes32) -> m_pendingIndex[REF_34]
REF_35(bytes32) (->m_pendingIndex) := _operation(bytes32)""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
ownerIndexBit = 2 ** ownerIndex

IRs:
TMP_65(uint256) = 2 ** ownerIndex
ownerIndexBit(uint256) := TMP_65(uint256)""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
pending.ownersDone & ownerIndexBit == 0

IRs:
REF_36(uint256) -> pending.ownersDone
TMP_66(uint256) = REF_36 & ownerIndexBit
TMP_67(bool) = TMP_66 == 0
CONDITION TMP_67""];
13->14[label=""True""];
13->22[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
Confirmation(msg.sender,_operation)

IRs:
Emit Confirmation(msg.sender,_operation)""];
14->15;
15[label=""Node Type: IF 15

EXPRESSION:
pending.yetNeeded <= 1

IRs:
REF_37(uint256) -> pending.yetNeeded
TMP_69(bool) = REF_37 <= 1
CONDITION TMP_69""];
15->16[label=""True""];
15->19[label=""False""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
delete m_pendingIndex[m_pending[_operation].index]

IRs:
REF_38(multiowned.PendingState) -> m_pending[_operation]
REF_39(uint256) -> REF_38.index
REF_40(bytes32) -> m_pendingIndex[REF_39]
m_pendingIndex = delete REF_40 ""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
delete m_pending[_operation]

IRs:
REF_41(multiowned.PendingState) -> m_pending[_operation]
m_pending = delete REF_41 ""];
17->18;
18[label=""Node Type: RETURN 18

EXPRESSION:
true

IRs:
RETURN True""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
pending.yetNeeded --

IRs:
REF_42(uint256) -> pending.yetNeeded
TMP_70(uint256) := REF_42(uint256)
REF_42(-> pending) = REF_42 - 1""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
pending.ownersDone |= ownerIndexBit

IRs:
REF_43(uint256) -> pending.ownersDone
REF_43(-> pending) = REF_43 | ownerIndexBit""];
20->21;
21[label=""Node Type: END_IF 21
""];
21->22;
22[label=""Node Type: END_IF 22
""];
}
",0,1,0,0,"ownerIndex = m_ownerIndex[uint256(msg.sender)];ownerIndex == 0;;;pending = m_pending[_operation];pending.yetNeeded == 0;pending.yetNeeded = m_required;;pending.ownersDone = 0;pending.index = m_pendingIndex.length ++;m_pendingIndex[pending.index] = _operation;ownerIndexBit = 2 ** ownerIndex;pending.ownersDone & ownerIndexBit == 0;Confirmation(msg.sender,_operation);;pending.yetNeeded <= 1;delete m_pendingIndex[m_pending[_operation].index];pending.yetNeeded --;delete m_pending[_operation];true;pending.ownersDone |= ownerIndexBit;"
./0x53e3a7ec57132173ce615debb9a303fd2cd86789_ext.sol,CityToken._transfer,383,398,"REF_38(uint256) -> ownershipTokenCount[_to],TMP_93(uint256) := REF_38(uint256),REF_38(-> ownershipTokenCount) = REF_38 + 1,REF_39(address) -> cityIndexToOwner[_tokenId],REF_39(address) (->cityIndexToOwner) := _to(address),TMP_94 = CONVERT 0 to address,TMP_95(bool) = _from != TMP_94,CONDITION TMP_95,REF_40(uint256) -> ownershipTokenCount[_from],TMP_96(uint256) := REF_40(uint256),REF_40(-> ownershipTokenCount) = REF_40 - 1,REF_41(address) -> cityIndexToApproved[_tokenId],cityIndexToApproved = delete REF_41 ,Emit Transfer(_from,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownershipTokenCount[_to] ++

IRs:
REF_38(uint256) -> ownershipTokenCount[_to]
TMP_93(uint256) := REF_38(uint256)
REF_38(-> ownershipTokenCount) = REF_38 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
cityIndexToOwner[_tokenId] = _to

IRs:
REF_39(address) -> cityIndexToOwner[_tokenId]
REF_39(address) (->cityIndexToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_94 = CONVERT 0 to address
TMP_95(bool) = _from != TMP_94
CONDITION TMP_95""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownershipTokenCount[_from] --

IRs:
REF_40(uint256) -> ownershipTokenCount[_from]
TMP_96(uint256) := REF_40(uint256)
REF_40(-> ownershipTokenCount) = REF_40 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete cityIndexToApproved[_tokenId]

IRs:
REF_41(address) -> cityIndexToApproved[_tokenId]
cityIndexToApproved = delete REF_41 ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
}
",0,1,0,0,"ownershipTokenCount[_to] ++;cityIndexToOwner[_tokenId] = _to;_from != address(0);ownershipTokenCount[_from] --;;delete cityIndexToApproved[_tokenId];Transfer(_from,_to,_tokenId)"
./0x6eedd095c335a7dae40db56832607093e1ae6311_ext.sol,TokenERC20.burnFrom,145,153,"REF_19(uint256) -> balanceOf[_from],TMP_27(bool) = REF_19 >= _value,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_29(bool) = _value <= REF_21,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_27(bool) = REF_19 >= _value
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_29(bool) = _value <= REF_21
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xec71870d02ba5c392ec8f64837e314b28afa4222_ext.sol,BillionRewardsToken.send_bounty_token,69,76,"TMP_19(bool) = Bounty_Supply >= reward,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_2(uint256) -> balanceOf[target],REF_2(-> balanceOf) = REF_2 + reward,totalSupply(uint256) = totalSupply + reward,Emit Transfer(0,this,reward),Emit Transfer(this,target,reward),Bounty_Supply(uint256) = Bounty_Supply - reward,MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(Bounty_Supply >= reward)

IRs:
TMP_19(bool) = Bounty_Supply >= reward
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[target] += reward

IRs:
REF_2(uint256) -> balanceOf[target]
REF_2(-> balanceOf) = REF_2 + reward""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply += reward

IRs:
totalSupply(uint256) = totalSupply + reward""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(0,this,reward)

IRs:
Emit Transfer(0,this,reward)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(this,target,reward)

IRs:
Emit Transfer(this,target,reward)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Bounty_Supply -= reward

IRs:
Bounty_Supply(uint256) = Bounty_Supply - reward""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
7->1;
}
",0,1,0,0,"onlyOwner();require(bool)(Bounty_Supply >= reward);balanceOf[target] += reward;totalSupply += reward;Transfer(0,this,reward);Transfer(this,target,reward);Bounty_Supply -= reward"
./0xf24c63438ae11cb3facb84006f4cfa75458126ed_ext.sol,ClockAuctionBase._computeCurrentPrice,1309,1344,"TMP_726(bool) = _secondsPassed >= _duration,CONDITION TMP_726,RETURN _endingPrice,TMP_727 = CONVERT _endingPrice to int256,TMP_728 = CONVERT _startingPrice to int256,TMP_729(int256) = TMP_727 - TMP_728,totalPriceChange(int256) := TMP_729(int256),TMP_730 = CONVERT _secondsPassed to int256,TMP_731(int256) = totalPriceChange * TMP_730,TMP_732 = CONVERT _duration to int256,TMP_733(int256) = TMP_731 / TMP_732,currentPriceChange(int256) := TMP_733(int256),TMP_734 = CONVERT _startingPrice to int256,TMP_735(int256) = TMP_734 + currentPriceChange,currentPrice(int256) := TMP_735(int256),TMP_736 = CONVERT currentPrice to uint256,RETURN TMP_736","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_secondsPassed >= _duration

IRs:
TMP_726(bool) = _secondsPassed >= _duration
CONDITION TMP_726""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
_endingPrice

IRs:
RETURN _endingPrice""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
totalPriceChange = int256(_endingPrice) - int256(_startingPrice)

IRs:
TMP_727 = CONVERT _endingPrice to int256
TMP_728 = CONVERT _startingPrice to int256
TMP_729(int256) = TMP_727 - TMP_728
totalPriceChange(int256) := TMP_729(int256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration)

IRs:
TMP_730 = CONVERT _secondsPassed to int256
TMP_731(int256) = totalPriceChange * TMP_730
TMP_732 = CONVERT _duration to int256
TMP_733(int256) = TMP_731 / TMP_732
currentPriceChange(int256) := TMP_733(int256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
currentPrice = int256(_startingPrice) + currentPriceChange

IRs:
TMP_734 = CONVERT _startingPrice to int256
TMP_735(int256) = TMP_734 + currentPriceChange
currentPrice(int256) := TMP_735(int256)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
uint256(currentPrice)

IRs:
TMP_736 = CONVERT currentPrice to uint256
RETURN TMP_736""];
}
",0,1,0,0,_secondsPassed >= _duration;_endingPrice;totalPriceChange = int256(_endingPrice) - int256(_startingPrice);currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);currentPrice = int256(_startingPrice) + currentPriceChange;uint256(currentPrice)
./0x6b0d7b8357bb851de9f1953199c39c7bc4675796_ext.sol,MyAdvancedToken.mintToken,208,213,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x5838f878000fe44b6f6c677bbf839e12f097c147_ext.sol,Q_GAME.NewQuestion,34,39,"TMP_12(bool) = msg.sender == questionSender,CONDITION TMP_12,question(string) := _question(string),responseHash(bytes32) := _responseHash(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == questionSender

IRs:
TMP_12(bool) = msg.sender == questionSender
CONDITION TMP_12""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
responseHash = _responseHash

IRs:
responseHash(bytes32) := _responseHash(bytes32)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,msg.sender == questionSender;question = _question;;responseHash = _responseHash
./0xdd89d6ab3aca67ed697492ba4de2f2763490224b_ext.sol,NFTYToken.transferFrom,34,48,"TMP_10 = CONVERT this to address,TMP_11(bool) = to != TMP_10,TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11),TMP_13(bool) = to != 0,TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13),REF_4(mapping(address => uint256)) -> allowance[from],REF_5(uint256) -> REF_4[msg.sender],allowanceMsgSender(uint256) := REF_5(uint256),TMP_15(bool) = allowanceMsgSender >= amount,TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15),TMP_17(bool) = allowanceMsgSender != MAX_UINT,CONDITION TMP_17,REF_6(mapping(address => uint256)) -> allowance[from],REF_7(uint256) -> REF_6[msg.sender],TMP_18(uint256) = allowanceMsgSender - amount,REF_7(uint256) (->allowance) := TMP_18(uint256),REF_8(uint256) -> balanceOf[from],balanceOfFrom(uint256) := REF_8(uint256),TMP_19(bool) = balanceOfFrom >= amount,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_9(uint256) -> balanceOf[from],TMP_21(uint256) = balanceOfFrom - amount,REF_9(uint256) (->balanceOf) := TMP_21(uint256),REF_10(uint256) -> balanceOf[to],REF_10(-> balanceOf) = REF_10 + amount,Emit Transfer(from,to,amount),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(to != address(this))

IRs:
TMP_10 = CONVERT this to address
TMP_11(bool) = to != TMP_10
TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(to != 0)

IRs:
TMP_13(bool) = to != 0
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
allowanceMsgSender = allowance[from][msg.sender]

IRs:
REF_4(mapping(address => uint256)) -> allowance[from]
REF_5(uint256) -> REF_4[msg.sender]
allowanceMsgSender(uint256) := REF_5(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(allowanceMsgSender >= amount)

IRs:
TMP_15(bool) = allowanceMsgSender >= amount
TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
allowanceMsgSender != MAX_UINT

IRs:
TMP_17(bool) = allowanceMsgSender != MAX_UINT
CONDITION TMP_17""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allowance[from][msg.sender] = allowanceMsgSender - amount

IRs:
REF_6(mapping(address => uint256)) -> allowance[from]
REF_7(uint256) -> REF_6[msg.sender]
TMP_18(uint256) = allowanceMsgSender - amount
REF_7(uint256) (->allowance) := TMP_18(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
balanceOfFrom = balanceOf[from]

IRs:
REF_8(uint256) -> balanceOf[from]
balanceOfFrom(uint256) := REF_8(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(balanceOfFrom >= amount)

IRs:
TMP_19(bool) = balanceOfFrom >= amount
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
balanceOf[from] = balanceOfFrom - amount

IRs:
REF_9(uint256) -> balanceOf[from]
TMP_21(uint256) = balanceOfFrom - amount
REF_9(uint256) (->balanceOf) := TMP_21(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
balanceOf[to] += amount

IRs:
REF_10(uint256) -> balanceOf[to]
REF_10(-> balanceOf) = REF_10 + amount""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
Transfer(from,to,amount)

IRs:
Emit Transfer(from,to,amount)""];
12->13;
13[label=""Node Type: RETURN 13

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(to != address(this));require(bool)(to != 0);allowanceMsgSender = allowance[from][msg.sender];require(bool)(allowanceMsgSender >= amount);allowanceMsgSender != MAX_UINT;allowance[from][msg.sender] = allowanceMsgSender - amount;;balanceOfFrom = balanceOf[from];require(bool)(balanceOfFrom >= amount);balanceOf[from] = balanceOfFrom - amount;balanceOf[to] += amount;Transfer(from,to,amount);true"
./0xa1506902f8ca82dace3176575e740c78aa29fc02_ext.sol,Storage.uploadData,7,18,"TMP_0(bool) = readOnly != True,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_0 -> LENGTH data,index(uint256) := REF_0(uint256),i(uint256) := 0(uint256),REF_1 -> LENGTH _data,TMP_2(uint256) = REF_1 / 32,TMP_3(bool) = i < TMP_2,CONDITION TMP_3,REF_2 -> LENGTH data,TMP_4(uint256) := REF_2(uint256),REF_2(-> data) = REF_2 + 1,TMP_5(uint256) = index + i,REF_3(bytes32) -> data[TMP_5],REF_3(bytes32) (->data) := word(bytes32),TMP_6(uint256) := i(uint256),i(uint256) = i + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(readOnly != true)

IRs:
TMP_0(bool) = readOnly != True
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
index = data.length

IRs:
REF_0 -> LENGTH data
index(uint256) := REF_0(uint256)""];
2->5;
3[label=""Node Type: BEGIN_LOOP 3
""];
3->6;
4[label=""Node Type: END_LOOP 4
""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
5->3;
6[label=""Node Type: IF_LOOP 6

EXPRESSION:
i < _data.length / 32

IRs:
REF_1 -> LENGTH _data
TMP_2(uint256) = REF_1 / 32
TMP_3(bool) = i < TMP_2
CONDITION TMP_3""];
6->7[label=""True""];
6->4[label=""False""];
7[label=""Node Type: NEW VARIABLE 7
""];
7->8;
8[label=""Node Type: INLINE ASM 8
""];
8->9;
9[label=""Node Type: END INLINE ASM 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
data.length ++

IRs:
REF_2 -> LENGTH data
TMP_4(uint256) := REF_2(uint256)
REF_2(-> data) = REF_2 + 1""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
data[index + i] = word

IRs:
TMP_5(uint256) = index + i
REF_3(bytes32) -> data[TMP_5]
REF_3(bytes32) (->data) := word(bytes32)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_6(uint256) := i(uint256)
i(uint256) = i + 1""];
12->6;
}
",0,1,0,0,require(bool)(readOnly != true);index = data.length;i = 0;;i < _data.length / 32;;;;;data.length ++;data[index + i] = word;i ++
./0xf4609d26a58598d6b80b11f451a00477f61d8804_ext.sol,Tcthereum.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xf208c7a5682d3835a58dadce8e249453ebd0ec0b_ext.sol,FOIN._transfer,44,60,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x4042ff0b0ff691a1549d67ede0479a1f0d12f6ba_ext.sol,Cosby.dividendsOf,466,472,"REF_38(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_65(uint256) = profitPerShare_ * REF_38,TMP_66 = CONVERT TMP_65 to int256,REF_39(int256) -> payoutsTo_[_customerAddress],TMP_67(int256) = TMP_66 - REF_39,TMP_68 = CONVERT TMP_67 to uint256,TMP_69(uint256) = TMP_68 / magnitude,RETURN TMP_69","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_38(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_65(uint256) = profitPerShare_ * REF_38
TMP_66 = CONVERT TMP_65 to int256
REF_39(int256) -> payoutsTo_[_customerAddress]
TMP_67(int256) = TMP_66 - REF_39
TMP_68 = CONVERT TMP_67 to uint256
TMP_69(uint256) = TMP_68 / magnitude
RETURN TMP_69""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x71a06988b97070a7091f81117b0a4bdee7a68357_ext.sol,BITWORKCOIN.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x006ff3494c04680cfbf39b0396054486f3f6ad32_ext.sol,PLAY_NOW.NewQuestion,34,39,"TMP_12(bool) = msg.sender == questionSender,CONDITION TMP_12,question(string) := _question(string),responseHash(bytes32) := _responseHash(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == questionSender

IRs:
TMP_12(bool) = msg.sender == questionSender
CONDITION TMP_12""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
responseHash = _responseHash

IRs:
responseHash(bytes32) := _responseHash(bytes32)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,msg.sender == questionSender;question = _question;;responseHash = _responseHash
./0x6f8e8e44e02963f11d494be759afbe24cf55cd39_ext.sol,DemocracyVote.transfer,21,28,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x55aa079e2fb0c8b68a0a08efbff3f1aa5472f1a2_ext.sol,WannabeSmartInvestor.fallback,22,24,"REF_4(uint256) -> incomeFrom[msg.sender],REF_5(uint256) -> incomeFrom[msg.sender],TMP_11(uint256) = REF_5 + msg.value,REF_4(uint256) (->incomeFrom) := TMP_11(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
incomeFrom[msg.sender] = incomeFrom[msg.sender] + msg.value

IRs:
REF_4(uint256) -> incomeFrom[msg.sender]
REF_5(uint256) -> incomeFrom[msg.sender]
TMP_11(uint256) = REF_5 + msg.value
REF_4(uint256) (->incomeFrom) := TMP_11(uint256)""];
}
",0,1,0,0,incomeFrom[msg.sender] = incomeFrom[msg.sender] + msg.value
./0x749f35ff65932e68267dd82f6cd85eea735d700e_ext.sol,CCLToken.totalSupply,90,92,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x87af260d1f637661dcecb6e4efcb4f74963c9539_ext.sol,VINCI_301201.transferFrom,42,54,"REF_6(uint256) -> balanceOf[from],TMP_6(bool) = value <= REF_6,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_7(mapping(address => uint256)) -> allowance[from],REF_8(uint256) -> REF_7[msg.sender],TMP_8(bool) = value <= REF_8,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_9(uint256) -> balanceOf[from],REF_9(-> balanceOf) = REF_9 - value,REF_10(uint256) -> balanceOf[to],REF_10(-> balanceOf) = REF_10 + value,REF_11(mapping(address => uint256)) -> allowance[from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowance) = REF_12 - value,Emit Transfer(from,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(value <= balanceOf[from])

IRs:
REF_6(uint256) -> balanceOf[from]
TMP_6(bool) = value <= REF_6
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value <= allowance[from][msg.sender])

IRs:
REF_7(mapping(address => uint256)) -> allowance[from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_8(bool) = value <= REF_8
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[from] -= value

IRs:
REF_9(uint256) -> balanceOf[from]
REF_9(-> balanceOf) = REF_9 - value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[to] += value

IRs:
REF_10(uint256) -> balanceOf[to]
REF_10(-> balanceOf) = REF_10 + value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allowance[from][msg.sender] -= value

IRs:
REF_11(mapping(address => uint256)) -> allowance[from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowance) = REF_12 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(value <= balanceOf[from]);require(bool)(value <= allowance[from][msg.sender]);balanceOf[from] -= value;balanceOf[to] += value;allowance[from][msg.sender] -= value;Transfer(from,to,value);true;success"
./0x3595279a9f0658eb2649976f155111bae1ae9de6_ext.sol,GGE.burnFrom,149,157,"REF_19(uint256) -> balanceOf[_from],TMP_26(bool) = REF_19 >= _value,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_28(bool) = _value <= REF_21,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_26(bool) = REF_19 >= _value
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_28(bool) = _value <= REF_21
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x46a0fb6c0f540e825889f4b82005afef43d2cd71_ext.sol,ArchiveCreation.signArchive,16,21,"TMP_0(bool) = owner_ == msg.sender,CONDITION TMP_0,REF_1 -> LENGTH records,TMP_2(uint256) := REF_1(uint256),TMP_3(uint256) = TMP_2 + 1,REF_1(uint256) (->records) := TMP_3(uint256),REF_2(bytes32) -> records[TMP_2],REF_2(bytes32) (->records) := hash(bytes32),REF_3(ArchiveCreation.Archive) -> registry[hash],TMP_4(ArchiveCreation.Archive) = new Archive(projectNameToken),REF_3(ArchiveCreation.Archive) (->registry) := TMP_4(ArchiveCreation.Archive)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
owner_ == msg.sender

IRs:
TMP_0(bool) = owner_ == msg.sender
CONDITION TMP_0""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
records.push(hash)

IRs:
REF_1 -> LENGTH records
TMP_2(uint256) := REF_1(uint256)
TMP_3(uint256) = TMP_2 + 1
REF_1(uint256) (->records) := TMP_3(uint256)
REF_2(bytes32) -> records[TMP_2]
REF_2(bytes32) (->records) := hash(bytes32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
registry[hash] = Archive(projectNameToken)

IRs:
REF_3(ArchiveCreation.Archive) -> registry[hash]
TMP_4(ArchiveCreation.Archive) = new Archive(projectNameToken)
REF_3(ArchiveCreation.Archive) (->registry) := TMP_4(ArchiveCreation.Archive)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,owner_ == msg.sender;records.push(hash);;registry[hash] = Archive(projectNameToken)
./0xf4be3da9df0c12e69115bb5614334786fbaf5ace_ext.sol,MiBoodleToken.setFundingStartTime,224,226,"TMP_76(uint256) = now + _start,start(uint256) := TMP_76(uint256),MODIFIER_CALL, Haltable.stopIfHalted()(),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
start = now + _start

IRs:
TMP_76(uint256) = now + _start
start(uint256) := TMP_76(uint256)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
stopIfHalted()

IRs:
MODIFIER_CALL, Haltable.stopIfHalted()()""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
3->1;
}
",0,1,0,0,stopIfHalted();start = now + _start;onlyOwner()
./0xc4581e49d306f4df9e672ac9b31a7b2da5fe1d5b_ext.sol,LowcarbonToken.mint,197,227,"TMP_46(bool) = last_mint == 0,CONDITION TMP_46,last_mint(uint256) := now(uint256),RETURN True,TMP_47(bool) = hourlyProduction < 1,CONDITION TMP_47,TMP_48(None) = SOLIDITY_CALL revert()(),TMP_49(uint256) = now - last_mint,TMP_50(uint256) = TMP_49 / 3600,diffHours(uint256) := TMP_50(uint256),TMP_51(bool) = diffHours == 0,CONDITION TMP_51,TMP_52(None) = SOLIDITY_CALL revert()(),TMP_53(uint256) = accumulatedHours + diffHours,TMP_54(bool) = TMP_53 > 8760,CONDITION TMP_54,TMP_55(uint256) = 8760 - accumulatedHours,TMP_56(uint256) = hourlyProduction * TMP_55,_amount(uint256) := TMP_56(uint256),TMP_57(uint256) = hourlyProduction * 9,TMP_58(uint256) = TMP_57 / 10,hourlyProduction(uint256) := TMP_58(uint256),TMP_59(uint256) = accumulatedHours + diffHours,TMP_60(uint256) = TMP_59 - 8760,accumulatedHours(uint256) := TMP_60(uint256),TMP_61(uint256) = hourlyProduction * accumulatedHours,_amount(uint256) = _amount + TMP_61,TMP_62(uint256) = hourlyProduction * diffHours,_amount(uint256) := TMP_62(uint256),accumulatedHours(uint256) = accumulatedHours + diffHours,TMP_63(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_totalSupply', '_amount'] ,_totalSupply(uint256) := TMP_63(uint256),REF_26(uint256) -> balances[owner],REF_27(uint256) -> balances[owner],TMP_64(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_27', '_amount'] ,REF_26(uint256) (->balances) := TMP_64(uint256),last_mint(uint256) := now(uint256),Emit Mint(owner,_amount),RETURN True,MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->26;
1[label=""Node Type: IF 1

EXPRESSION:
last_mint == 0

IRs:
TMP_46(bool) = last_mint == 0
CONDITION TMP_46""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
last_mint = now

IRs:
last_mint(uint256) := now(uint256)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
hourlyProduction < 1

IRs:
TMP_47(bool) = hourlyProduction < 1
CONDITION TMP_47""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
revert()()

IRs:
TMP_48(None) = SOLIDITY_CALL revert()()""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
diffHours = (now - last_mint) / 3600

IRs:
TMP_49(uint256) = now - last_mint
TMP_50(uint256) = TMP_49 / 3600
diffHours(uint256) := TMP_50(uint256)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
diffHours == 0

IRs:
TMP_51(bool) = diffHours == 0
CONDITION TMP_51""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
revert()()

IRs:
TMP_52(None) = SOLIDITY_CALL revert()()""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: NEW VARIABLE 12
""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
(accumulatedHours + diffHours) > 8760

IRs:
TMP_53(uint256) = accumulatedHours + diffHours
TMP_54(bool) = TMP_53 > 8760
CONDITION TMP_54""];
13->14[label=""True""];
13->18[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
_amount = hourlyProduction * (8760 - accumulatedHours)

IRs:
TMP_55(uint256) = 8760 - accumulatedHours
TMP_56(uint256) = hourlyProduction * TMP_55
_amount(uint256) := TMP_56(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
hourlyProduction = hourlyProduction * 9 / 10

IRs:
TMP_57(uint256) = hourlyProduction * 9
TMP_58(uint256) = TMP_57 / 10
hourlyProduction(uint256) := TMP_58(uint256)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
accumulatedHours = accumulatedHours + diffHours - 8760

IRs:
TMP_59(uint256) = accumulatedHours + diffHours
TMP_60(uint256) = TMP_59 - 8760
accumulatedHours(uint256) := TMP_60(uint256)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
_amount += hourlyProduction * accumulatedHours

IRs:
TMP_61(uint256) = hourlyProduction * accumulatedHours
_amount(uint256) = _amount + TMP_61""];
17->20;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
_amount = hourlyProduction * diffHours

IRs:
TMP_62(uint256) = hourlyProduction * diffHours
_amount(uint256) := TMP_62(uint256)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
accumulatedHours += diffHours

IRs:
accumulatedHours(uint256) = accumulatedHours + diffHours""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
_totalSupply = _totalSupply.add(_amount)

IRs:
TMP_63(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_totalSupply', '_amount'] 
_totalSupply(uint256) := TMP_63(uint256)""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
balances[owner] = balances[owner].add(_amount)

IRs:
REF_26(uint256) -> balances[owner]
REF_27(uint256) -> balances[owner]
TMP_64(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_27', '_amount'] 
REF_26(uint256) (->balances) := TMP_64(uint256)""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
last_mint = now

IRs:
last_mint(uint256) := now(uint256)""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
Mint(owner,_amount)

IRs:
Emit Mint(owner,_amount)""];
24->25;
25[label=""Node Type: RETURN 25

EXPRESSION:
true

IRs:
RETURN True""];
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
26->1;
}
",0,1,0,0,"onlyOwner();last_mint == 0;last_mint = now;;true;hourlyProduction < 1;revert()();;diffHours = (now - last_mint) / 3600;diffHours == 0;revert()();;;(accumulatedHours + diffHours) > 8760;_amount = hourlyProduction * (8760 - accumulatedHours);_amount = hourlyProduction * diffHours;hourlyProduction = hourlyProduction * 9 / 10;accumulatedHours = accumulatedHours + diffHours - 8760;_amount += hourlyProduction * accumulatedHours;;accumulatedHours += diffHours;_totalSupply = _totalSupply.add(_amount);balances[owner] = balances[owner].add(_amount);last_mint = now;Mint(owner,_amount);true"
./0x2f50ab197f950e0c2184cf5d804f4141502cd987_ext.sol,LoggedDividend.recycleDividend,328,342,"REF_110 -> LENGTH dividends,TMP_142(uint256) = REF_110 - 1,TMP_143(bool) = TMP_142 < dividendId,CONDITION TMP_143,RETURN False,REF_111(LoggedDividend.Dividend) -> dividends[dividendId],dividend(LoggedDividend.Dividend) := REF_111(LoggedDividend.Dividend),REF_112(bool) -> dividend.recycled,CONDITION REF_112,RETURN False,REF_113(bool) -> dividend.recycled,REF_113(bool) (->dividend) := True(bool),RETURN True,MODIFIER_CALL, Ownable.onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: IF 1

EXPRESSION:
dividends.length - 1 < dividendId

IRs:
REF_110 -> LENGTH dividends
TMP_142(uint256) = REF_110 - 1
TMP_143(bool) = TMP_142 < dividendId
CONDITION TMP_143""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
dividend = dividends[dividendId]

IRs:
REF_111(LoggedDividend.Dividend) -> dividends[dividendId]
dividend(LoggedDividend.Dividend) := REF_111(LoggedDividend.Dividend)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
dividend.recycled

IRs:
REF_112(bool) -> dividend.recycled
CONDITION REF_112""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False""];
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
dividend.recycled = true

IRs:
REF_113(bool) -> dividend.recycled
REF_113(bool) (->dividend) := True(bool)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
10->1;
11[label=""Node Type: RETURN 11

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,onlyOwner();dividends.length - 1 < dividendId;false;;dividend = dividends[dividendId];dividend.recycled;false;;dividend.recycled = true;true;success
./0x26998144da0e9e7a960ee1d6cdfd7bf8c6b496a2_ext.sol,AILiteCoin.transfer,99,109,"REF_1(uint256) -> balances[msg.sender],TMP_21(bool) = REF_1 >= _value,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),TMP_23(bool) = msg.sender == _to,REF_2(uint256) -> balances[_to],TMP_24(uint256) = MAX_UINT256 - _value,TMP_25(bool) = REF_2 <= TMP_24,TMP_26(bool) = TMP_23 || TMP_25,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_3(uint256) -> balances[msg.sender],REF_3(-> balances) = REF_3 - _value,REF_4(uint256) -> balances[_to],REF_4(-> balances) = REF_4 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_21(bool) = REF_1 >= _value
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == _to || balances[_to] <= MAX_UINT256 - _value)

IRs:
TMP_23(bool) = msg.sender == _to
REF_2(uint256) -> balances[_to]
TMP_24(uint256) = MAX_UINT256 - _value
TMP_25(bool) = REF_2 <= TMP_24
TMP_26(bool) = TMP_23 || TMP_25
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_3(uint256) -> balances[msg.sender]
REF_3(-> balances) = REF_3 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] += _value

IRs:
REF_4(uint256) -> balances[_to]
REF_4(-> balances) = REF_4 + _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);require(bool)(msg.sender == _to || balances[_to] <= MAX_UINT256 - _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true"
./0x27369e8f43f44c26853a46da7e6cb52d203b59ce_ext.sol,SafeMath.add,22,26,"TMP_10(uint256) = a + b,c(uint256) := TMP_10(uint256),TMP_11(bool) = c >= a,TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11),RETURN c","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_10(uint256) = a + b
c(uint256) := TMP_10(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_11(bool) = c >= a
TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c""];
}
",0,1,0,0,c = a + b;assert(bool)(c >= a);c
./0xe1dbbce4570b815b6ce3434bb3097dc9f453c565_ext.sol,MobiusRED.estimateReturns,245,261,"REF_2(MobiusRED.MobiusRound) -> rounds[roundID],rnd(MobiusRED.MobiusRound) := REF_2(MobiusRED.MobiusRound),REF_3 -> LENGTH rounds,TMP_105(bool) = REF_3 > 1,CONDITION TMP_105,TMP_106(uint256) = roundID - 1,TMP_107(bool) = INTERNAL_CALL, MobiusRED.hasReturns(address,uint256)(investor,TMP_106),CONDITION TMP_107,TMP_108(uint256) = roundID - 1,REF_4(MobiusRED.MobiusRound) -> rounds[TMP_108],prevRnd(MobiusRED.MobiusRound) := REF_4(MobiusRED.MobiusRound),TMP_109(uint256) = INTERNAL_CALL, MobiusRED._outstandingReturns(address,MobiusRED.MobiusRound)(investor,prevRnd),outstanding(uint256) := TMP_109(uint256),TMP_110(uint256) = INTERNAL_CALL, MobiusRED._outstandingReturns(address,MobiusRED.MobiusRound)(investor,rnd),outstanding(uint256) = outstanding + TMP_110,REF_5(MobiusRED.Vault) -> vaults[investor],REF_6(uint256) -> REF_5.totalReturns,TMP_111(uint256) = REF_6 + outstanding,totalReturns(uint256) := TMP_111(uint256),REF_7(MobiusRED.Vault) -> vaults[investor],REF_8(uint256) -> REF_7.refReturns,refReturns(uint256) := REF_8(uint256),RETURN totalReturns,refReturns","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
rnd = rounds[roundID]

IRs:
REF_2(MobiusRED.MobiusRound) -> rounds[roundID]
rnd(MobiusRED.MobiusRound) := REF_2(MobiusRED.MobiusRound)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
rounds.length > 1

IRs:
REF_3 -> LENGTH rounds
TMP_105(bool) = REF_3 > 1
CONDITION TMP_105""];
3->4[label=""True""];
3->8[label=""False""];
4[label=""Node Type: IF 4

EXPRESSION:
hasReturns(investor,roundID - 1)

IRs:
TMP_106(uint256) = roundID - 1
TMP_107(bool) = INTERNAL_CALL, MobiusRED.hasReturns(address,uint256)(investor,TMP_106)
CONDITION TMP_107""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
prevRnd = rounds[roundID - 1]

IRs:
TMP_108(uint256) = roundID - 1
REF_4(MobiusRED.MobiusRound) -> rounds[TMP_108]
prevRnd(MobiusRED.MobiusRound) := REF_4(MobiusRED.MobiusRound)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
outstanding = _outstandingReturns(investor,prevRnd)

IRs:
TMP_109(uint256) = INTERNAL_CALL, MobiusRED._outstandingReturns(address,MobiusRED.MobiusRound)(investor,prevRnd)
outstanding(uint256) := TMP_109(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
outstanding += _outstandingReturns(investor,rnd)

IRs:
TMP_110(uint256) = INTERNAL_CALL, MobiusRED._outstandingReturns(address,MobiusRED.MobiusRound)(investor,rnd)
outstanding(uint256) = outstanding + TMP_110""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
totalReturns = vaults[investor].totalReturns + outstanding

IRs:
REF_5(MobiusRED.Vault) -> vaults[investor]
REF_6(uint256) -> REF_5.totalReturns
TMP_111(uint256) = REF_6 + outstanding
totalReturns(uint256) := TMP_111(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
refReturns = vaults[investor].refReturns

IRs:
REF_7(MobiusRED.Vault) -> vaults[investor]
REF_8(uint256) -> REF_7.refReturns
refReturns(uint256) := REF_8(uint256)""];
11->12;
12[label=""Node Type: RETURN 12

EXPRESSION:
(totalReturns,refReturns)

IRs:
RETURN totalReturns,refReturns""];
}
",0,1,0,0,"rnd = rounds[roundID];;rounds.length > 1;hasReturns(investor,roundID - 1);;prevRnd = rounds[roundID - 1];;outstanding = _outstandingReturns(investor,prevRnd);outstanding += _outstandingReturns(investor,rnd);totalReturns = vaults[investor].totalReturns + outstanding;refReturns = vaults[investor].refReturns;(totalReturns,refReturns)"
./0x0d09b8d474e312eda0996cb420aa9f5c6b2c1993_ext.sol,ProfytPro.setUser,46,56,"REF_2(ProfytPro.User) -> users[_address],user(ProfytPro.User) := REF_2(ProfytPro.User),REF_3(string) -> user.username,REF_3(string) (->user) := _username(string),REF_4(uint256) -> user.balance,REF_4(uint256) (->user) := _balance(uint256),TMP_2(bool) = owner == _address,CONDITION TMP_2,REF_5(uint256) -> user.balance,REF_5(uint256) (->user) := totalSupply(uint256),REF_7 -> LENGTH userAccounts,TMP_5(uint256) := REF_7(uint256),TMP_6(uint256) = TMP_5 + 1,REF_7(uint256) (->userAccounts) := TMP_6(uint256),REF_8(address) -> userAccounts[TMP_5],REF_8(address) (->userAccounts) := _address(address),TMP_4(None) = TMP_3 - 1,Emit userInfo(_username,_balance)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
user = users[_address]

IRs:
REF_2(ProfytPro.User) -> users[_address]
user(ProfytPro.User) := REF_2(ProfytPro.User)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
user.username = _username

IRs:
REF_3(string) -> user.username
REF_3(string) (->user) := _username(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
user.balance = _balance

IRs:
REF_4(uint256) -> user.balance
REF_4(uint256) (->user) := _balance(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
owner == _address

IRs:
TMP_2(bool) = owner == _address
CONDITION TMP_2""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
user.balance = totalSupply

IRs:
REF_5(uint256) -> user.balance
REF_5(uint256) (->user) := totalSupply(uint256)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
userAccounts.push(_address) - 1

IRs:
REF_7 -> LENGTH userAccounts
TMP_5(uint256) := REF_7(uint256)
TMP_6(uint256) = TMP_5 + 1
REF_7(uint256) (->userAccounts) := TMP_6(uint256)
REF_8(address) -> userAccounts[TMP_5]
REF_8(address) (->userAccounts) := _address(address)
TMP_4(None) = TMP_3 - 1""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
userInfo(_username,_balance)

IRs:
Emit userInfo(_username,_balance)""];
}
",0,1,0,0,"user = users[_address];user.username = _username;user.balance = _balance;owner == _address;user.balance = totalSupply;;userAccounts.push(_address) - 1;userInfo(_username,_balance)"
./0x28f4ae3275f38015c6e6eeefd9288a2d7bc7d023_ext.sol,StandardToken.transferFrom,56,66,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x470142a1834438515b757118f322703aba6e1e05_ext.sol,PolicyPalNetworkAirdrop.twitterDropMultipleAmount,196,217,"i(uint256) := 0(uint256),REF_22 -> LENGTH _recipients,TMP_32(bool) = i < REF_22,CONDITION TMP_32,REF_23(address) -> _recipients[i],recipient(address) := REF_23(address),REF_24(uint256) -> _amounts[i],amount(uint256) := REF_24(uint256),REF_25(bool) -> twitterdrops[recipient],TMP_33 = UnaryType.BANG REF_25 ,CONDITION TMP_33,TMP_34(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', 'amount']  ,TMP_35(None) = SOLIDITY_CALL assert(bool)(TMP_34),REF_27(bool) -> twitterdrops[recipient],REF_27(bool) (->twitterdrops) := True(bool),TMP_36(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] ,numDrops(uint256) := TMP_36(uint256),TMP_37(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', 'amount'] ,dropAmount(uint256) := TMP_37(uint256),Emit TokenDrop(recipient,amount,TWITTER),TMP_39(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()(),MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalanceMultiple(address[],uint256[])(_recipients,_amounts)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->15;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _recipients.length

IRs:
REF_22 -> LENGTH _recipients
TMP_32(bool) = i < REF_22
CONDITION TMP_32""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
recipient = _recipients[i]

IRs:
REF_23(address) -> _recipients[i]
recipient(address) := REF_23(address)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
amount = _amounts[i]

IRs:
REF_24(uint256) -> _amounts[i]
amount(uint256) := REF_24(uint256)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
! twitterdrops[recipient]

IRs:
REF_25(bool) -> twitterdrops[recipient]
TMP_33 = UnaryType.BANG REF_25 
CONDITION TMP_33""];
7->8[label=""True""];
7->13[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(token.transfer(recipient,amount))

IRs:
TMP_34(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', 'amount']  
TMP_35(None) = SOLIDITY_CALL assert(bool)(TMP_34)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
twitterdrops[recipient] = true

IRs:
REF_27(bool) -> twitterdrops[recipient]
REF_27(bool) (->twitterdrops) := True(bool)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
numDrops = numDrops.add(1)

IRs:
TMP_36(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] 
numDrops(uint256) := TMP_36(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
dropAmount = dropAmount.add(amount)

IRs:
TMP_37(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', 'amount'] 
dropAmount(uint256) := TMP_37(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
TokenDrop(recipient,amount,TWITTER)

IRs:
Emit TokenDrop(recipient,amount,TWITTER)""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
i ++

IRs:
TMP_39(uint256) := i(uint256)
i(uint256) = i + 1""];
14->4;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()()""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
validBalanceMultiple(_recipients,_amounts)

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalanceMultiple(address[],uint256[])(_recipients,_amounts)""];
16->3;
}
",1,1,0,0,"onlyAdmin();;i < _recipients.length;;i = 0;recipient = _recipients[i];amount = _amounts[i];! twitterdrops[recipient];assert(bool)(token.transfer(recipient,amount));;twitterdrops[recipient] = true;numDrops = numDrops.add(1);dropAmount = dropAmount.add(amount);TokenDrop(recipient,amount,TWITTER);i ++;validBalanceMultiple(_recipients,_amounts)"
./0x2118840b16aaf95a0f0027b7ac32f5986925d935_ext.sol,TokenERC20.burn,104,110,"REF_21(uint256) -> balanceOf[msg.sender],TMP_35(bool) = REF_21 >= _value,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),REF_22(uint256) -> balanceOf[msg.sender],REF_22(-> balanceOf) = REF_22 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_21(uint256) -> balanceOf[msg.sender]
TMP_35(bool) = REF_21 >= _value
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_22(uint256) -> balanceOf[msg.sender]
REF_22(-> balanceOf) = REF_22 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x6fdbcd375f348325d4b8c1fac374753ec1b07c92_ext.sol,WSKYToken.approveAndCall,190,195,"REF_24(mapping(address => uint256)) -> allowed[msg.sender],REF_25(uint256) -> REF_24[spender],REF_25(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_43 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_43(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_24(mapping(address => uint256)) -> allowed[msg.sender]
REF_25(uint256) -> REF_24[spender]
REF_25(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_43 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_43(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xef47dd38cc0c2856a27fb1964b066ec33426e979_ext.sol,DBXCContract._transfer,90,106,"TMP_15 = CONVERT 0 to address,TMP_16(bool) = _to != TMP_15,TMP_17(None) = SOLIDITY_CALL require(bool)(TMP_16),REF_1(uint256) -> balanceOf[_from],TMP_18(bool) = REF_1 >= _value,TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18),REF_2(uint256) -> balanceOf[_to],TMP_20(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_21(bool) = TMP_20 >= REF_3,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_23(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_23(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_25(uint256) = REF_8 + REF_9,TMP_26(bool) = TMP_25 == previousBalances,TMP_27(None) = SOLIDITY_CALL assert(bool)(TMP_26)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0x0))

IRs:
TMP_15 = CONVERT 0 to address
TMP_16(bool) = _to != TMP_15
TMP_17(None) = SOLIDITY_CALL require(bool)(TMP_16)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_18(bool) = REF_1 >= _value
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_20(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_21(bool) = TMP_20 >= REF_3
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_23(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_23(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_25(uint256) = REF_8 + REF_9
TMP_26(bool) = TMP_25 == previousBalances
TMP_27(None) = SOLIDITY_CALL assert(bool)(TMP_26)""];
}
",0,1,0,0,"require(bool)(_to != address(0x0));require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xbc5e7120e1e917c6ba34e94b3a29016f64bbd2c1_ext.sol,RocketCash.availableDividends,133,136,"REF_27(uint256) -> collected[investor],TMP_37(uint256) = INTERNAL_CALL, RocketCash.dailyDividends(address)(investor),REF_28(uint256) -> lastInvestmentTime[investor],TMP_38(uint256) = now - REF_28,TMP_39(uint256) = TMP_37 * TMP_38,TMP_40(uint256) = TMP_39 / 86400,TMP_41(uint256) = REF_27 + TMP_40,RETURN TMP_41","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
collected[investor] + dailyDividends(investor) * (now - lastInvestmentTime[investor]) / 86400

IRs:
REF_27(uint256) -> collected[investor]
TMP_37(uint256) = INTERNAL_CALL, RocketCash.dailyDividends(address)(investor)
REF_28(uint256) -> lastInvestmentTime[investor]
TMP_38(uint256) = now - REF_28
TMP_39(uint256) = TMP_37 * TMP_38
TMP_40(uint256) = TMP_39 / 86400
TMP_41(uint256) = REF_27 + TMP_40
RETURN TMP_41""];
}
",0,1,0,0,collected[investor] + dailyDividends(investor) * (now - lastInvestmentTime[investor]) / 86400
./0x6f8544edb3f513845135b0efa907f4b6b9c2c92e_ext.sol,BW.updateUser,678,682,"TMP_337(bool) = HIGH_LEVEL_CALL, dest:bwData(BWData), function:hasUser, arguments:['msg.sender']  ,TMP_338(None) = SOLIDITY_CALL require(bool)(TMP_337),Emit UserUpdated(msg.sender,_name,_imageUrl,_tag,_homeUrl,block.timestamp),MODIFIER_CALL, BW.isNotPaused()(),MODIFIER_CALL, BW.isNotContractCaller()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(bwData.hasUser(msg.sender))

IRs:
TMP_337(bool) = HIGH_LEVEL_CALL, dest:bwData(BWData), function:hasUser, arguments:['msg.sender']  
TMP_338(None) = SOLIDITY_CALL require(bool)(TMP_337)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
UserUpdated(msg.sender,_name,_imageUrl,_tag,_homeUrl,block.timestamp)

IRs:
Emit UserUpdated(msg.sender,_name,_imageUrl,_tag,_homeUrl,block.timestamp)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
isNotPaused()

IRs:
MODIFIER_CALL, BW.isNotPaused()()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
isNotContractCaller()

IRs:
MODIFIER_CALL, BW.isNotContractCaller()()""];
4->1;
}
",1,1,0,0,"isNotPaused();require(bool)(bwData.hasUser(msg.sender));UserUpdated(msg.sender,_name,_imageUrl,_tag,_homeUrl,block.timestamp);isNotContractCaller()"
./0x0ce6d5a093d4166237c7a9ff8e0553b0293214a1_ext.sol,InfoBurnableToken.burnPassportToken,323,330,"REF_122(uint256) -> balances[_from],TMP_118(bool) = _value <= REF_122,CONDITION TMP_118,INTERNAL_CALL, BurnableToken._burn(address,uint256)(_from,_value),RETURN True,Emit NoFunds(_from,message),RETURN False,MODIFIER_CALL, InfoBurnableToken.onlyManager()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: IF 1

EXPRESSION:
_value <= balances[_from]

IRs:
REF_122(uint256) -> balances[_from]
TMP_118(bool) = _value <= REF_122
CONDITION TMP_118""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_burn(_from,_value)

IRs:
INTERNAL_CALL, BurnableToken._burn(address,uint256)(_from,_value)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
NoFunds(_from,message)

IRs:
Emit NoFunds(_from,message)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyManager()

IRs:
MODIFIER_CALL, InfoBurnableToken.onlyManager()()""];
7->1;
}
",0,1,0,0,"onlyManager();_value <= balances[_from];_burn(_from,_value);;true;NoFunds(_from,message);false"
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.adminUpdMinSign,2,2,"CONDITION paidversion,mineth(uint256) := _min_eth(uint256),minsignupeth(uint256) := _minsignupeth(uint256),MODIFIER_CALL, KahnDistributionCentre.onlyAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
paidversion

IRs:
CONDITION paidversion""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
mineth = _min_eth

IRs:
mineth(uint256) := _min_eth(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
minsignupeth = _minsignupeth

IRs:
minsignupeth(uint256) := _minsignupeth(uint256)""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyAdmin()()""];
5->1;
}
",0,1,1,0,onlyAdmin();paidversion;mineth = _min_eth;;minsignupeth = _minsignupeth
./0x1fab9d2996767db0ca6af12fd92c1f2aab2675a0_ext.sol,ZethrSlots.getSpinOutput,2886,2930,"TMP_776(uint256[])  = new uint256[](_numSpins),output(uint256[]) = ['TMP_776(uint256[])'],TMP_777(uint256) = block.number - _blockNumber,TMP_778(bool) = TMP_777 > 255,CONDITION TMP_778,TMP_779(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '_numSpins'] ,TMP_780(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_779', '99'] ,TMP_781(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_780', '100'] ,lossAmount(uint256) := TMP_781(uint256),TMP_782(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '_numSpins'] ,TMP_783(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_782', '100'] ,jackpotAmount(uint256) := TMP_783(uint256),i(uint256) := 0(uint256),TMP_784(bool) = i < _numSpins,CONDITION TMP_784,REF_373(uint256) -> output[i],TMP_785(uint256) = INTERNAL_CALL, ZethrSlots.random(uint256,uint256,address,uint256)(1000000,_blockNumber,_target,i),TMP_786(uint256) = TMP_785 + 1,REF_373(uint256) (->output) := TMP_786(uint256),REF_374(uint256) -> output[i],TMP_787(bool) = REF_374 < 2,CONDITION TMP_787,TMP_788(uint256) := jackpotWins(uint256),jackpotWins(uint256) = jackpotWins + 1,lossAmount(uint256) = lossAmount + _tokenValue,REF_375(uint256) -> output[i],TMP_789(bool) = REF_375 > 506856,CONDITION TMP_789,TMP_790(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '99'] ,TMP_791(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_790', '100'] ,lossAmount(uint256) = lossAmount + TMP_791,TMP_792(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_tokenValue', '100'] ,jackpotAmount(uint256) = jackpotAmount + TMP_792,index(uint256) := 0(uint256),REF_379 -> LENGTH MULTIPLIER_BOUNDARIES,TMP_793(bool) = index < REF_379,CONDITION TMP_793,REF_380(uint256) -> output[i],REF_381(uint256) -> MULTIPLIER_BOUNDARIES[index],TMP_794(bool) = REF_380 < REF_381,CONDITION TMP_794,TMP_795(uint256) := index(uint256),index(uint256) = index + 1,REF_383(uint256) -> MULTIPLIERS[index],TMP_796(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', 'REF_383'] ,TMP_797(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_796', '100'] ,winAmount(uint256) = winAmount + TMP_797,TMP_798(uint256) := i(uint256),i(uint256) = i + 1,Emit SlotsResult(_blockNumber,_target,_numSpins,_tokenValue,winAmount,lossAmount,output),RETURN winAmount,lossAmount,jackpotAmount,jackpotWins,output,RETURN winAmount,lossAmount,jackpotAmount,jackpotWins,output","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
output = new uint256[](_numSpins)

IRs:
TMP_776(uint256[])  = new uint256[](_numSpins)
output(uint256[]) = ['TMP_776(uint256[])']""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
block.number - _blockNumber > 255

IRs:
TMP_777(uint256) = block.number - _blockNumber
TMP_778(bool) = TMP_777 > 255
CONDITION TMP_778""];
2->3[label=""True""];
2->7[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
lossAmount = (_tokenValue.mul(_numSpins).mul(99)).div(100)

IRs:
TMP_779(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '_numSpins'] 
TMP_780(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_779', '99'] 
TMP_781(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_780', '100'] 
lossAmount(uint256) := TMP_781(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
jackpotAmount = _tokenValue.mul(_numSpins).div(100)

IRs:
TMP_782(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '_numSpins'] 
TMP_783(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_782', '100'] 
jackpotAmount(uint256) := TMP_783(uint256)""];
4->29;
5[label=""Node Type: BEGIN_LOOP 5
""];
5->8;
6[label=""Node Type: END_LOOP 6
""];
6->29;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
7->5;
8[label=""Node Type: IF_LOOP 8

EXPRESSION:
i < _numSpins

IRs:
TMP_784(bool) = i < _numSpins
CONDITION TMP_784""];
8->9[label=""True""];
8->6[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
output[i] = random(1000000,_blockNumber,_target,i) + 1

IRs:
REF_373(uint256) -> output[i]
TMP_785(uint256) = INTERNAL_CALL, ZethrSlots.random(uint256,uint256,address,uint256)(1000000,_blockNumber,_target,i)
TMP_786(uint256) = TMP_785 + 1
REF_373(uint256) (->output) := TMP_786(uint256)""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
output[i] < 2

IRs:
REF_374(uint256) -> output[i]
TMP_787(bool) = REF_374 < 2
CONDITION TMP_787""];
10->11[label=""True""];
10->13[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
jackpotWins ++

IRs:
TMP_788(uint256) := jackpotWins(uint256)
jackpotWins(uint256) = jackpotWins + 1""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
lossAmount += _tokenValue

IRs:
lossAmount(uint256) = lossAmount + _tokenValue""];
12->27;
13[label=""Node Type: IF 13

EXPRESSION:
output[i] > 506856

IRs:
REF_375(uint256) -> output[i]
TMP_789(bool) = REF_375 > 506856
CONDITION TMP_789""];
13->14[label=""True""];
13->16[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
lossAmount += (_tokenValue.mul(99)).div(100)

IRs:
TMP_790(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '99'] 
TMP_791(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_790', '100'] 
lossAmount(uint256) = lossAmount + TMP_791""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
jackpotAmount += _tokenValue.div(100)

IRs:
TMP_792(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_tokenValue', '100'] 
jackpotAmount(uint256) = jackpotAmount + TMP_792""];
15->26;
16[label=""Node Type: NEW VARIABLE 16
""];
16->19;
17[label=""Node Type: BEGIN_LOOP 17
""];
17->20;
18[label=""Node Type: END_LOOP 18
""];
18->25;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
index = 0

IRs:
index(uint256) := 0(uint256)""];
19->17;
20[label=""Node Type: IF_LOOP 20

EXPRESSION:
index < MULTIPLIER_BOUNDARIES.length

IRs:
REF_379 -> LENGTH MULTIPLIER_BOUNDARIES
TMP_793(bool) = index < REF_379
CONDITION TMP_793""];
20->21[label=""True""];
20->18[label=""False""];
21[label=""Node Type: IF 21

EXPRESSION:
output[i] < MULTIPLIER_BOUNDARIES[index]

IRs:
REF_380(uint256) -> output[i]
REF_381(uint256) -> MULTIPLIER_BOUNDARIES[index]
TMP_794(bool) = REF_380 < REF_381
CONDITION TMP_794""];
21->22[label=""True""];
21->23[label=""False""];
22[label=""Node Type: BREAK 22
""];
22->18;
23[label=""Node Type: END_IF 23
""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
index ++

IRs:
TMP_795(uint256) := index(uint256)
index(uint256) = index + 1""];
24->20;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
winAmount += _tokenValue.mul(MULTIPLIERS[index]).div(100)

IRs:
REF_383(uint256) -> MULTIPLIERS[index]
TMP_796(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', 'REF_383'] 
TMP_797(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_796', '100'] 
winAmount(uint256) = winAmount + TMP_797""];
25->26;
26[label=""Node Type: END_IF 26
""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
i ++

IRs:
TMP_798(uint256) := i(uint256)
i(uint256) = i + 1""];
28->8;
29[label=""Node Type: END_IF 29
""];
29->30;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
SlotsResult(_blockNumber,_target,_numSpins,_tokenValue,winAmount,lossAmount,output)

IRs:
Emit SlotsResult(_blockNumber,_target,_numSpins,_tokenValue,winAmount,lossAmount,output)""];
30->31;
31[label=""Node Type: RETURN 31

EXPRESSION:
(winAmount,lossAmount,jackpotAmount,jackpotWins,output)

IRs:
RETURN winAmount,lossAmount,jackpotAmount,jackpotWins,output""];
32[label=""Node Type: RETURN 32

EXPRESSION:
(winAmount,lossAmount,jackpotAmount,jackpotWins,output)

IRs:
RETURN winAmount,lossAmount,jackpotAmount,jackpotWins,output""];
}
",0,1,0,0,"output = new uint256[](_numSpins);block.number - _blockNumber > 255;lossAmount = (_tokenValue.mul(_numSpins).mul(99)).div(100);i = 0;jackpotAmount = _tokenValue.mul(_numSpins).div(100);;;i < _numSpins;;output[i] = random(1000000,_blockNumber,_target,i) + 1;output[i] < 2;jackpotWins ++;output[i] > 506856;lossAmount += _tokenValue;;lossAmount += (_tokenValue.mul(99)).div(100);;jackpotAmount += _tokenValue.div(100);;index = 0;;index < MULTIPLIER_BOUNDARIES.length;;winAmount += _tokenValue.mul(MULTIPLIERS[index]).div(100);output[i] < MULTIPLIER_BOUNDARIES[index];;;index ++;i ++;SlotsResult(_blockNumber,_target,_numSpins,_tokenValue,winAmount,lossAmount,output);(winAmount,lossAmount,jackpotAmount,jackpotWins,output);(winAmount,lossAmount,jackpotAmount,jackpotWins,output)"
./0x5064ec168fac380a866e8061b422d75b73470ad9_ext.sol,ElectricCoin.burn,77,83,"REF_21(uint256) -> balances[msg.sender],TMP_15(bool) = REF_21 < _value,CONDITION TMP_15,RETURN False,REF_22(uint256) -> balances[msg.sender],REF_22(-> balances) = REF_22 - _value,_totalSupply(uint256) = _totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[msg.sender] < _value

IRs:
REF_21(uint256) -> balances[msg.sender]
TMP_15(bool) = REF_21 < _value
CONDITION TMP_15""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_22(uint256) -> balances[msg.sender]
REF_22(-> balances) = REF_22 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_totalSupply -= _value

IRs:
_totalSupply(uint256) = _totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[msg.sender] < _value;false;;balances[msg.sender] -= _value;_totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x6d54549975e0fef50cd954491a6abee84c6f4e61_ext.sol,QuizTest.start_quiz_game,20,27,"TMP_7(bool) = responseHash == 0,CONDITION TMP_7,TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response),responseHash(bytes32) := TMP_8(bytes32),question(string) := _question(string),questionSender(address) := msg.sender(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
responseHash == 0x0

IRs:
TMP_7(bool) = responseHash == 0
CONDITION TMP_7""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
responseHash = keccak256()(_response)

IRs:
TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response)
responseHash(bytes32) := TMP_8(bytes32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
questionSender = msg.sender

IRs:
questionSender(address) := msg.sender(address)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,1,0,0,responseHash == 0x0;responseHash = keccak256()(_response);;question = _question;questionSender = msg.sender
./0xf3dac8e171a13066f8964f74a7c87fd518e4e162_ext.sol,safe.withdraw,13,21,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2),TMP_4(bool) = keyHash == TMP_3,CONDITION TMP_4,TMP_5(bool) = msg.value > 400000000000000000,CONDITION TMP_5,TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),Transfer dest:msg.sender value:TMP_7","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
keyHash == keccak256()(abi.encodePacked(key))

IRs:
TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2)
TMP_4(bool) = keyHash == TMP_3
CONDITION TMP_4""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
msg.value > 400000000000000000

IRs:
TMP_5(bool) = msg.value > 400000000000000000
CONDITION TMP_5""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
Transfer dest:msg.sender value:TMP_7""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,1,0,0,require(bool)(msg.sender == tx.origin);keyHash == keccak256()(abi.encodePacked(key));msg.value > 400000000000000000;;msg.sender.transfer(address(this).balance);
./0xb417fa71a03a9badbf962589f2478353fd5693e2_ext.sol,CoinDisplayNetwork.approveAndCall,197,202,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x6bff83c6d87b1adff6679c75abac82fe7c38d7cf_ext.sol,EasyInvestTurbo.fallback,29,44,"REF_0(uint256) -> invested[msg.sender],TMP_0(bool) = REF_0 != 0,CONDITION TMP_0,REF_1(uint256) -> invested[msg.sender],TMP_1(uint256) = REF_1 * 12,TMP_2(uint256) = TMP_1 / 100,REF_2(uint256) -> atBlock[msg.sender],TMP_3(uint256) = block.number - REF_2,TMP_4(uint256) = TMP_2 * TMP_3,TMP_5(uint256) = TMP_4 / 5900,amount(uint256) := TMP_5(uint256),Transfer dest:msg.sender value:amount,REF_4(uint256) -> atBlock[msg.sender],REF_4(uint256) (->atBlock) := block.number(uint256),REF_5(uint256) -> invested[msg.sender],REF_5(-> invested) = REF_5 + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
invested[msg.sender] != 0

IRs:
REF_0(uint256) -> invested[msg.sender]
TMP_0(bool) = REF_0 != 0
CONDITION TMP_0""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = invested[msg.sender] * 12 / 100 * (block.number - atBlock[msg.sender]) / 5900

IRs:
REF_1(uint256) -> invested[msg.sender]
TMP_1(uint256) = REF_1 * 12
TMP_2(uint256) = TMP_1 / 100
REF_2(uint256) -> atBlock[msg.sender]
TMP_3(uint256) = block.number - REF_2
TMP_4(uint256) = TMP_2 * TMP_3
TMP_5(uint256) = TMP_4 / 5900
amount(uint256) := TMP_5(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
atBlock[msg.sender] = block.number

IRs:
REF_4(uint256) -> atBlock[msg.sender]
REF_4(uint256) (->atBlock) := block.number(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
invested[msg.sender] += msg.value

IRs:
REF_5(uint256) -> invested[msg.sender]
REF_5(-> invested) = REF_5 + msg.value""];
}
",0,1,0,0,invested[msg.sender] != 0;amount = invested[msg.sender] * 12 / 100 * (block.number - atBlock[msg.sender]) / 5900;;msg.sender.transfer(amount);atBlock[msg.sender] = block.number;invested[msg.sender] += msg.value
./0x411be588940376ae23e58274ad4fe175f85e5ca1_ext.sol,FLICoin.approveAndCall,139,144,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_61 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_61(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_61 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_61(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xc3a684140448995f6abeb361c56110207da04d57_ext.sol,SignalsSociety.deposit,79,84,"REF_7(uint256) -> balances[account],REF_7(-> balances) = REF_7 + amount,REF_8(uint256) -> balances[account],Emit Deposited(account,amount,REF_8,now)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances[account] += amount

IRs:
REF_7(uint256) -> balances[account]
REF_7(-> balances) = REF_7 + amount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Deposited(account,amount,balances[account],now)

IRs:
REF_8(uint256) -> balances[account]
Emit Deposited(account,amount,REF_8,now)""];
}
",0,1,0,0,"balances[account] += amount;Deposited(account,amount,balances[account],now)"
./0x207c92740ccbe446ac2e2f43fe1da52651cd8d3c_ext.sol,TJK.transfer,32,37,"REF_2(uint256) -> balances[msg.sender],TMP_2(bool) = REF_2 >= _value,TMP_3(bool) = _value > 0,TMP_4(bool) = TMP_2 && TMP_3,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_3(uint256) -> balances[msg.sender],REF_3(-> balances) = REF_3 - _value,REF_4(uint256) -> balances[_recipient],REF_4(-> balances) = REF_4 + _value,Emit Transfer(msg.sender,_recipient,_value),TMP_7(uint256) = 2 * 32,MODIFIER_CALL, TJK.onlyPayloadSize(uint256)(TMP_7)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value && _value > 0)

IRs:
REF_2(uint256) -> balances[msg.sender]
TMP_2(bool) = REF_2 >= _value
TMP_3(bool) = _value > 0
TMP_4(bool) = TMP_2 && TMP_3
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_3(uint256) -> balances[msg.sender]
REF_3(-> balances) = REF_3 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_recipient] += _value

IRs:
REF_4(uint256) -> balances[_recipient]
REF_4(-> balances) = REF_4 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_recipient,_value)

IRs:
Emit Transfer(msg.sender,_recipient,_value)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyPayloadSize(2 * 32)

IRs:
TMP_7(uint256) = 2 * 32
MODIFIER_CALL, TJK.onlyPayloadSize(uint256)(TMP_7)""];
5->1;
}
",0,1,0,0,"onlyPayloadSize(2 * 32);require(bool)(balances[msg.sender] >= _value && _value > 0);balances[msg.sender] -= _value;balances[_recipient] += _value;Transfer(msg.sender,_recipient,_value)"
./0x36ebdbe660c0b988b83c257a779b908697d41615_ext.sol,ArteufToken.burn,110,115,"REF_19(uint256) -> balanceOf[msg.sender],TMP_41(bool) = REF_19 >= _value,TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41),REF_20(uint256) -> balanceOf[msg.sender],REF_20(-> balanceOf) = REF_20 - _value,REF_21(uint256) -> balanceOf[0],REF_21(-> balanceOf) = REF_21 + _value,Emit Transfer(msg.sender,0,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_19(uint256) -> balanceOf[msg.sender]
TMP_41(bool) = REF_19 >= _value
TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_20(uint256) -> balanceOf[msg.sender]
REF_20(-> balanceOf) = REF_20 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[0x0] += _value

IRs:
REF_21(uint256) -> balanceOf[0]
REF_21(-> balanceOf) = REF_21 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,0x0,_value)

IRs:
Emit Transfer(msg.sender,0,_value)""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;balanceOf[0x0] += _value;Transfer(msg.sender,0x0,_value)"
./0x6c72582241de57e6fd501a99d85c650924039a50_ext.sol,WHC.burnFrom,142,150,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x4d5ed54e732cc6cd3ebcce015e3d80c6dc181b06_ext.sol,TokenTWL.burn,133,139,"REF_17(uint256) -> balanceOf[msg.sender],TMP_23(bool) = REF_17 >= _value,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_23(bool) = REF_17 >= _value
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xf40eb2f57db872e57b86ba36d4bc86a38a16e4d5_ext.sol,ERC20token.transferFrom,33,40,"REF_6(uint256) -> balances[_from],TMP_11(bool) = REF_6 >= _value,REF_7(mapping(address => uint256)) -> allowed[_from],REF_8(uint256) -> REF_7[msg.sender],TMP_12(bool) = REF_8 >= _value,TMP_13(bool) = TMP_11 && TMP_12,TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13),REF_9(uint256) -> balances[_to],REF_9(-> balances) = REF_9 + _value,REF_10(uint256) -> balances[_from],REF_10(-> balances) = REF_10 - _value,REF_11(mapping(address => uint256)) -> allowed[_from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowed) = REF_12 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value)

IRs:
REF_6(uint256) -> balances[_from]
TMP_11(bool) = REF_6 >= _value
REF_7(mapping(address => uint256)) -> allowed[_from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_12(bool) = REF_8 >= _value
TMP_13(bool) = TMP_11 && TMP_12
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_9(uint256) -> balances[_to]
REF_9(-> balances) = REF_9 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_10(uint256) -> balances[_from]
REF_10(-> balances) = REF_10 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_11(mapping(address => uint256)) -> allowed[_from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowed) = REF_12 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);balances[_to] += _value;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true;success"
./0x54a9ed327f2614316914c3f3a782a77d0aa47aee_ext.sol,CONNECT.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x33116db6c6942903653e74d9580f0f7c7abe1cbe_ext.sol,VanityLib.isValidBicoinAddressPrefix,319,338,"REF_45 -> LENGTH prefixArg,TMP_153(bool) = REF_45 < 5,CONDITION TMP_153,RETURN False,REF_46(None) -> prefixArg[0],TMP_154(bool) = REF_46 != 1,REF_47(None) -> prefixArg[0],TMP_155(bool) = REF_47 != 3,TMP_156(bool) = TMP_154 && TMP_155,CONDITION TMP_156,RETURN False,i(uint256) := 0(uint256),REF_48 -> LENGTH prefixArg,TMP_157(bool) = i < REF_48,CONDITION TMP_157,REF_49(None) -> prefixArg[i],ch(bytes1) := REF_49(None),TMP_158(bool) = ch == 0,TMP_159(bool) = ch == O,TMP_160(bool) = TMP_158 || TMP_159,TMP_161(bool) = ch == I,TMP_162(bool) = TMP_160 || TMP_161,TMP_163(bool) = ch == l,TMP_164(bool) = TMP_162 || TMP_163,CONDITION TMP_164,RETURN False,TMP_165(bool) = ch >= 1,TMP_166(bool) = ch <= 9,TMP_167(bool) = TMP_165 && TMP_166,TMP_168(bool) = ch >= a,TMP_169(bool) = ch <= z,TMP_170(bool) = TMP_168 && TMP_169,TMP_171(bool) = TMP_167 || TMP_170,TMP_172(bool) = ch >= A,TMP_173(bool) = ch <= Z,TMP_174(bool) = TMP_172 && TMP_173,TMP_175(bool) = TMP_171 || TMP_174,TMP_176 = UnaryType.BANG TMP_175 ,CONDITION TMP_176,RETURN False,TMP_177(uint256) := i(uint256),i(uint256) = i + 1,RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
prefixArg.length < 5

IRs:
REF_45 -> LENGTH prefixArg
TMP_153(bool) = REF_45 < 5
CONDITION TMP_153""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
prefixArg[0] != 1 && prefixArg[0] != 3

IRs:
REF_46(None) -> prefixArg[0]
TMP_154(bool) = REF_46 != 1
REF_47(None) -> prefixArg[0]
TMP_155(bool) = REF_47 != 3
TMP_156(bool) = TMP_154 && TMP_155
CONDITION TMP_156""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: RETURN 5

EXPRESSION:
false

IRs:
RETURN False""];
6[label=""Node Type: END_IF 6
""];
6->9;
7[label=""Node Type: BEGIN_LOOP 7
""];
7->10;
8[label=""Node Type: END_LOOP 8
""];
8->19;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
9->7;
10[label=""Node Type: IF_LOOP 10

EXPRESSION:
i < prefixArg.length

IRs:
REF_48 -> LENGTH prefixArg
TMP_157(bool) = i < REF_48
CONDITION TMP_157""];
10->11[label=""True""];
10->8[label=""False""];
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
ch = prefixArg[i]

IRs:
REF_49(None) -> prefixArg[i]
ch(bytes1) := REF_49(None)""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
ch == 0 || ch == O || ch == I || ch == l

IRs:
TMP_158(bool) = ch == 0
TMP_159(bool) = ch == O
TMP_160(bool) = TMP_158 || TMP_159
TMP_161(bool) = ch == I
TMP_162(bool) = TMP_160 || TMP_161
TMP_163(bool) = ch == l
TMP_164(bool) = TMP_162 || TMP_163
CONDITION TMP_164""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: RETURN 13

EXPRESSION:
false

IRs:
RETURN False""];
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: IF 15

EXPRESSION:
! ((ch >= 1 && ch <= 9) || (ch >= a && ch <= z) || (ch >= A && ch <= Z))

IRs:
TMP_165(bool) = ch >= 1
TMP_166(bool) = ch <= 9
TMP_167(bool) = TMP_165 && TMP_166
TMP_168(bool) = ch >= a
TMP_169(bool) = ch <= z
TMP_170(bool) = TMP_168 && TMP_169
TMP_171(bool) = TMP_167 || TMP_170
TMP_172(bool) = ch >= A
TMP_173(bool) = ch <= Z
TMP_174(bool) = TMP_172 && TMP_173
TMP_175(bool) = TMP_171 || TMP_174
TMP_176 = UnaryType.BANG TMP_175 
CONDITION TMP_176""];
15->16[label=""True""];
15->17[label=""False""];
16[label=""Node Type: RETURN 16

EXPRESSION:
false

IRs:
RETURN False""];
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
i ++

IRs:
TMP_177(uint256) := i(uint256)
i(uint256) = i + 1""];
18->10;
19[label=""Node Type: RETURN 19

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,prefixArg.length < 5;false;;prefixArg[0] != 1 && prefixArg[0] != 3;false;;i = 0;;i < prefixArg.length;;true;ch = prefixArg[i];ch == 0 || ch == O || ch == I || ch == l;false;;! ((ch >= 1 && ch <= 9) || (ch >= a && ch <= z) || (ch >= A && ch <= Z));false;;i ++
./0x0e8d6b471e332f140e7d9dbb99e5e3822f728da6_ext.sol,MultiOwnable.setOwners,32,36,"TMP_0(bool) = msg.sender == manager,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),INTERNAL_CALL, MultiOwnable._setOwners(address[])(_owners)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == manager)

IRs:
TMP_0(bool) = msg.sender == manager
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_setOwners(_owners)

IRs:
INTERNAL_CALL, MultiOwnable._setOwners(address[])(_owners)""];
}
",0,1,0,0,require(bool)(msg.sender == manager);_setOwners(_owners)
./0xf3dce610acbfbcbb4efc12c4c2e3be063128baad_ext.sol,NumbersToken2.reserve,156,159,"TMP_45(uint256) = INTERNAL_CALL, NumbersToken2.balance()(),TMP_46(uint256) = earningsPerShare * totalSupply,TMP_47 = CONVERT TMP_46 to int256,TMP_48(int256) = TMP_47 - totalPayouts,TMP_49 = CONVERT TMP_48 to uint256,TMP_50(uint256) = TMP_49 / PRECISION,TMP_51(uint256) = TMP_45 - TMP_50,TMP_52(uint256) = TMP_51 - 1,RETURN TMP_52,RETURN amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
balance() - (uint256(int256(earningsPerShare * totalSupply) - totalPayouts) / PRECISION) - 1

IRs:
TMP_45(uint256) = INTERNAL_CALL, NumbersToken2.balance()()
TMP_46(uint256) = earningsPerShare * totalSupply
TMP_47 = CONVERT TMP_46 to int256
TMP_48(int256) = TMP_47 - totalPayouts
TMP_49 = CONVERT TMP_48 to uint256
TMP_50(uint256) = TMP_49 / PRECISION
TMP_51(uint256) = TMP_45 - TMP_50
TMP_52(uint256) = TMP_51 - 1
RETURN TMP_52""];
2[label=""Node Type: RETURN 2

EXPRESSION:
amount

IRs:
RETURN amount""];
}
",0,1,0,0,balance() - (uint256(int256(earningsPerShare * totalSupply) - totalPayouts) / PRECISION) - 1;amount
./0x1b27c2c096ae7e408eef72731fa5ea7e753054de_ext.sol,SUSIToken.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x742a56a727dac07e0889920b8887d482325f659b_ext.sol,InfiniCoin.approveAndCall,131,136,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x37d9033151eaf64cea6b7531ee0e4fd6f6f9d6d0_ext.sol,EthCrystal._currentPlayerAmountUnclaimed,308,319,"TMP_122(bool) = _RoundID == 0,CONDITION TMP_122,REF_258(EthCrystal.TowersInfoList) -> GameRounds[_TowerType],REF_259(uint256) -> REF_258.currentRoundID,_RoundID(uint256) := REF_259(uint256),REF_260(EthCrystal.PlayerInfo) -> players[_playerAddress],REF_261(mapping(uint256 => EthCrystal.TowersRoundInfo)) -> REF_260.TowersList,REF_262(EthCrystal.TowersRoundInfo) -> REF_261[_TowerType],REF_263(mapping(uint256 => EthCrystal.PlayerRoundInfo)) -> REF_262.RoundList,REF_264(EthCrystal.PlayerRoundInfo) -> REF_263[_RoundID],REF_265(uint256) -> REF_264.warriors,_warriors(uint256) := REF_265(uint256),REF_266(EthCrystal.TowersInfoList) -> GameRounds[_TowerType],REF_267(mapping(uint256 => EthCrystal.TowersInfo)) -> REF_266.RoundList,REF_268(EthCrystal.TowersInfo) -> REF_267[_RoundID],REF_269(uint256) -> REF_268.towerBalance,TMP_123(uint256) = _warriors * REF_269,REF_270(EthCrystal.TowersInfoList) -> GameRounds[_TowerType],REF_271(uint256) -> REF_270.dividendShare,TMP_124(uint256) = TMP_123 * REF_271,REF_272(EthCrystal.TowersInfoList) -> GameRounds[_TowerType],REF_273(mapping(uint256 => EthCrystal.TowersInfo)) -> REF_272.RoundList,REF_274(EthCrystal.TowersInfo) -> REF_273[_RoundID],REF_275(uint256) -> REF_274.totalWarriors,TMP_125(uint256) = TMP_124 / REF_275,TMP_126(uint256) = TMP_125 / 100,_totalForCashOut(uint256) := TMP_126(uint256),REF_276(EthCrystal.PlayerInfo) -> players[_playerAddress],REF_277(mapping(uint256 => EthCrystal.TowersRoundInfo)) -> REF_276.TowersList,REF_278(EthCrystal.TowersRoundInfo) -> REF_277[_TowerType],REF_279(mapping(uint256 => EthCrystal.PlayerRoundInfo)) -> REF_278.RoundList,REF_280(EthCrystal.PlayerRoundInfo) -> REF_279[_RoundID],REF_281(uint256) -> REF_280.cashedOut,TMP_127(uint256) = _totalForCashOut - REF_281,_unclaimedAmount(uint256) := TMP_127(uint256),RETURN _unclaimedAmount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_RoundID == 0

IRs:
TMP_122(bool) = _RoundID == 0
CONDITION TMP_122""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_RoundID = GameRounds[_TowerType].currentRoundID

IRs:
REF_258(EthCrystal.TowersInfoList) -> GameRounds[_TowerType]
REF_259(uint256) -> REF_258.currentRoundID
_RoundID(uint256) := REF_259(uint256)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
_warriors = players[_playerAddress].TowersList[_TowerType].RoundList[_RoundID].warriors

IRs:
REF_260(EthCrystal.PlayerInfo) -> players[_playerAddress]
REF_261(mapping(uint256 => EthCrystal.TowersRoundInfo)) -> REF_260.TowersList
REF_262(EthCrystal.TowersRoundInfo) -> REF_261[_TowerType]
REF_263(mapping(uint256 => EthCrystal.PlayerRoundInfo)) -> REF_262.RoundList
REF_264(EthCrystal.PlayerRoundInfo) -> REF_263[_RoundID]
REF_265(uint256) -> REF_264.warriors
_warriors(uint256) := REF_265(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
_totalForCashOut = (_warriors * GameRounds[_TowerType].RoundList[_RoundID].towerBalance * GameRounds[_TowerType].dividendShare / GameRounds[_TowerType].RoundList[_RoundID].totalWarriors / 100)

IRs:
REF_266(EthCrystal.TowersInfoList) -> GameRounds[_TowerType]
REF_267(mapping(uint256 => EthCrystal.TowersInfo)) -> REF_266.RoundList
REF_268(EthCrystal.TowersInfo) -> REF_267[_RoundID]
REF_269(uint256) -> REF_268.towerBalance
TMP_123(uint256) = _warriors * REF_269
REF_270(EthCrystal.TowersInfoList) -> GameRounds[_TowerType]
REF_271(uint256) -> REF_270.dividendShare
TMP_124(uint256) = TMP_123 * REF_271
REF_272(EthCrystal.TowersInfoList) -> GameRounds[_TowerType]
REF_273(mapping(uint256 => EthCrystal.TowersInfo)) -> REF_272.RoundList
REF_274(EthCrystal.TowersInfo) -> REF_273[_RoundID]
REF_275(uint256) -> REF_274.totalWarriors
TMP_125(uint256) = TMP_124 / REF_275
TMP_126(uint256) = TMP_125 / 100
_totalForCashOut(uint256) := TMP_126(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
_unclaimedAmount = _totalForCashOut - players[_playerAddress].TowersList[_TowerType].RoundList[_RoundID].cashedOut

IRs:
REF_276(EthCrystal.PlayerInfo) -> players[_playerAddress]
REF_277(mapping(uint256 => EthCrystal.TowersRoundInfo)) -> REF_276.TowersList
REF_278(EthCrystal.TowersRoundInfo) -> REF_277[_TowerType]
REF_279(mapping(uint256 => EthCrystal.PlayerRoundInfo)) -> REF_278.RoundList
REF_280(EthCrystal.PlayerRoundInfo) -> REF_279[_RoundID]
REF_281(uint256) -> REF_280.cashedOut
TMP_127(uint256) = _totalForCashOut - REF_281
_unclaimedAmount(uint256) := TMP_127(uint256)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
(_unclaimedAmount)

IRs:
RETURN _unclaimedAmount""];
}
",0,1,0,0,_RoundID == 0;_RoundID = GameRounds[_TowerType].currentRoundID;;_warriors = players[_playerAddress].TowersList[_TowerType].RoundList[_RoundID].warriors;_totalForCashOut = (_warriors * GameRounds[_TowerType].RoundList[_RoundID].towerBalance * GameRounds[_TowerType].dividendShare / GameRounds[_TowerType].RoundList[_RoundID].totalWarriors / 100);_unclaimedAmount = _totalForCashOut - players[_playerAddress].TowersList[_TowerType].RoundList[_RoundID].cashedOut;(_unclaimedAmount)
./0x4c29be83d5dc0bb45faffa6af3f35a7b5862ff54_ext.sol,BurnToken.burn,48,54,"REF_30(uint256) -> balanceOf[msg.sender],TMP_34(bool) = REF_30 >= _value,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),REF_31(uint256) -> balanceOf[msg.sender],REF_31(-> balanceOf) = REF_31 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_30(uint256) -> balanceOf[msg.sender]
TMP_34(bool) = REF_30 >= _value
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_31(uint256) -> balanceOf[msg.sender]
REF_31(-> balanceOf) = REF_31 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x454a5244556e044ad6ecfcf3f59290fae47484e8_ext.sol,BasicToken.transfer,73,82,"TMP_9 = CONVERT 0 to address,TMP_10(bool) = _to != TMP_9,TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10),REF_0(uint256) -> balances[msg.sender],TMP_12(bool) = _value <= REF_0,TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12),REF_1(uint256) -> balances[msg.sender],REF_2(uint256) -> balances[msg.sender],TMP_14(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] ,REF_1(uint256) (->balances) := TMP_14(uint256),REF_4(uint256) -> balances[_to],REF_4(-> balances) = REF_4 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_9 = CONVERT 0 to address
TMP_10(bool) = _to != TMP_9
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_12(bool) = _value <= REF_0
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_2(uint256) -> balances[msg.sender]
TMP_14(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] 
REF_1(uint256) (->balances) := TMP_14(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] += _value

IRs:
REF_4(uint256) -> balances[_to]
REF_4(-> balances) = REF_4 + _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(_to != address(0));require(bool)(_value <= balances[msg.sender]);balances[msg.sender] = balances[msg.sender].sub(_value);balances[_to] += _value;Transfer(msg.sender,_to,_value);true"
./0x35ae44bc4e3186ca732efa09a459cf93fa491a47_ext.sol,XMLYToken.ifFreeze,252,260,"REF_48(bool) -> freezed[user],check(bool) := REF_48(bool),REF_49(uint256) -> freezeAmount[user],amount(uint256) := REF_49(uint256),REF_50(uint256) -> unlockTime[user],TMP_88 = CONVERT now to uint256,TMP_89(uint256) = REF_50 - TMP_88,timeLeft(uint256) := TMP_89(uint256),RETURN check,amount,timeLeft","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
check = freezed[user]

IRs:
REF_48(bool) -> freezed[user]
check(bool) := REF_48(bool)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
amount = freezeAmount[user]

IRs:
REF_49(uint256) -> freezeAmount[user]
amount(uint256) := REF_49(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
timeLeft = unlockTime[user] - uint256(now)

IRs:
REF_50(uint256) -> unlockTime[user]
TMP_88 = CONVERT now to uint256
TMP_89(uint256) = REF_50 - TMP_88
timeLeft(uint256) := TMP_89(uint256)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
(check,amount,timeLeft)

IRs:
RETURN check,amount,timeLeft""];
}
",0,1,0,0,"check = freezed[user];amount = freezeAmount[user];timeLeft = unlockTime[user] - uint256(now);(check,amount,timeLeft)"
./0xf02904cbf8e5134aeaf45626e96b782ed233fe04_ext.sol,BWCToken.mint,119,135,"TMP_33 = CONVERT 0 to address,TMP_34(bool) = _to != TMP_33,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),TMP_36(uint256) = _value + totalSupply,TMP_37(bool) = TMP_36 <= hardcap,CONDITION TMP_37,TMP_38(uint256) = totalSupply + _value,totalSupply(uint256) := TMP_38(uint256),TMP_39(bool) = totalSupply >= _value,TMP_40(None) = SOLIDITY_CALL assert(bool)(TMP_39),REF_21(uint256) -> balances[msg.sender],REF_22(uint256) -> balances[msg.sender],TMP_41(uint256) = REF_22 + _value,REF_21(uint256) (->balances) := TMP_41(uint256),REF_23(uint256) -> balances[msg.sender],TMP_42(bool) = REF_23 >= _value,TMP_43(None) = SOLIDITY_CALL assert(bool)(TMP_42),Emit Mint(msg.sender,_value),TMP_45(bool) = INTERNAL_CALL, BWCToken.transfer(address,uint256)(_to,_value),RETURN True,MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, BWCToken.saleIsOn()(),MODIFIER_CALL, BWCToken.canMint()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_33 = CONVERT 0 to address
TMP_34(bool) = _to != TMP_33
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
_value + totalSupply <= hardcap

IRs:
TMP_36(uint256) = _value + totalSupply
TMP_37(bool) = TMP_36 <= hardcap
CONDITION TMP_37""];
2->3[label=""True""];
2->9[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply = totalSupply + _value

IRs:
TMP_38(uint256) = totalSupply + _value
totalSupply(uint256) := TMP_38(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
assert(bool)(totalSupply >= _value)

IRs:
TMP_39(bool) = totalSupply >= _value
TMP_40(None) = SOLIDITY_CALL assert(bool)(TMP_39)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[msg.sender] = balances[msg.sender] + _value

IRs:
REF_21(uint256) -> balances[msg.sender]
REF_22(uint256) -> balances[msg.sender]
TMP_41(uint256) = REF_22 + _value
REF_21(uint256) (->balances) := TMP_41(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
assert(bool)(balances[msg.sender] >= _value)

IRs:
REF_23(uint256) -> balances[msg.sender]
TMP_42(bool) = REF_23 >= _value
TMP_43(None) = SOLIDITY_CALL assert(bool)(TMP_42)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Mint(msg.sender,_value)

IRs:
Emit Mint(msg.sender,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
transfer(_to,_value)

IRs:
TMP_45(bool) = INTERNAL_CALL, BWCToken.transfer(address,uint256)(_to,_value)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
saleIsOn()

IRs:
MODIFIER_CALL, BWCToken.saleIsOn()()""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, BWCToken.canMint()()""];
13->1;
}
",0,1,0,0,"onlyOwner();require(bool)(_to != address(0));_value + totalSupply <= hardcap;totalSupply = totalSupply + _value;;assert(bool)(totalSupply >= _value);balances[msg.sender] = balances[msg.sender] + _value;assert(bool)(balances[msg.sender] >= _value);Mint(msg.sender,_value);transfer(_to,_value);true;saleIsOn();canMint()"
./0xf165c0df0b759e93e6166aecb667c7ec2a300525_ext.sol,StandarTokentokenGAT.transfer,34,43,"REF_3 -> LENGTH msg.data,TMP_0(uint256) = 2 * 32,TMP_1(uint256) = TMP_0 + 4,TMP_2(bool) = REF_3 < TMP_1,CONDITION TMP_2,TMP_3(None) = SOLIDITY_CALL revert()(),REF_4(uint256) -> balances[msg.sender],TMP_4(bool) = REF_4 >= _value,TMP_5(bool) = _value >= 0,TMP_6(bool) = TMP_4 && TMP_5,CONDITION TMP_6,REF_5(uint256) -> balances[msg.sender],REF_5(-> balances) = REF_5 - _value,REF_6(uint256) -> balances[_to],REF_6(-> balances) = REF_6 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.data.length < (2 * 32) + 4

IRs:
REF_3 -> LENGTH msg.data
TMP_0(uint256) = 2 * 32
TMP_1(uint256) = TMP_0 + 4
TMP_2(bool) = REF_3 < TMP_1
CONDITION TMP_2""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_3(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
balances[msg.sender] >= _value && _value >= 0

IRs:
REF_4(uint256) -> balances[msg.sender]
TMP_4(bool) = REF_4 >= _value
TMP_5(bool) = _value >= 0
TMP_6(bool) = TMP_4 && TMP_5
CONDITION TMP_6""];
4->5[label=""True""];
4->9[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_5(uint256) -> balances[msg.sender]
REF_5(-> balances) = REF_5 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[_to] += _value

IRs:
REF_6(uint256) -> balances[_to]
REF_6(-> balances) = REF_6 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True""];
9[label=""Node Type: RETURN 9

EXPRESSION:
false

IRs:
RETURN False""];
11[label=""Node Type: RETURN 11

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"msg.data.length < (2 * 32) + 4;revert()();;balances[msg.sender] >= _value && _value >= 0;balances[msg.sender] -= _value;false;balances[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0x587be3718e68f144f6dade2e50f28af95dd4be7e_ext.sol,Fast20.fallback,8,19,"sender(address) := msg.sender(address),REF_0(uint256) -> invests[sender],TMP_0(bool) = REF_0 != 0,CONDITION TMP_0,REF_1(uint256) -> invests[sender],TMP_1(uint256) = REF_1 / 100,TMP_2(uint256) = TMP_1 * 20,REF_2(uint256) -> dates[sender],TMP_3(uint256) = now - REF_2,TMP_4(uint256) = TMP_2 * TMP_3,TMP_5(uint256) = TMP_4 / 86400,payout(uint256) := TMP_5(uint256),TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),TMP_8(bool) = payout > TMP_7,CONDITION TMP_8,TMP_9 = CONVERT this to address,TMP_10(uint256) = SOLIDITY_CALL balance(address)(TMP_9),payout(uint256) := TMP_10(uint256),Transfer dest:sender value:payout,REF_4(uint256) -> dates[sender],REF_4(uint256) (->dates) := now(uint256),REF_5(uint256) -> invests[sender],REF_5(-> invests) = REF_5 + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
sender = msg.sender

IRs:
sender(address) := msg.sender(address)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
invests[sender] != 0

IRs:
REF_0(uint256) -> invests[sender]
TMP_0(bool) = REF_0 != 0
CONDITION TMP_0""];
2->3[label=""True""];
2->8[label=""False""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
payout = invests[sender] / 100 * 20 * (now - dates[sender]) / 86400

IRs:
REF_1(uint256) -> invests[sender]
TMP_1(uint256) = REF_1 / 100
TMP_2(uint256) = TMP_1 * 20
REF_2(uint256) -> dates[sender]
TMP_3(uint256) = now - REF_2
TMP_4(uint256) = TMP_2 * TMP_3
TMP_5(uint256) = TMP_4 / 86400
payout(uint256) := TMP_5(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
payout > address(this).balance

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
TMP_8(bool) = payout > TMP_7
CONDITION TMP_8""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
payout = address(this).balance

IRs:
TMP_9 = CONVERT this to address
TMP_10(uint256) = SOLIDITY_CALL balance(address)(TMP_9)
payout(uint256) := TMP_10(uint256)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
sender.transfer(payout)

IRs:
Transfer dest:sender value:payout""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
dates[sender] = now

IRs:
REF_4(uint256) -> dates[sender]
REF_4(uint256) (->dates) := now(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
invests[sender] += msg.value

IRs:
REF_5(uint256) -> invests[sender]
REF_5(-> invests) = REF_5 + msg.value""];
}
",0,1,0,0,sender = msg.sender;invests[sender] != 0;payout = invests[sender] / 100 * 20 * (now - dates[sender]) / 86400;;payout > address(this).balance;payout = address(this).balance;;sender.transfer(payout);dates[sender] = now;invests[sender] += msg.value
./0x5a82601f0fd69ed6eb496e258fde8ca1b7b77696_ext.sol,VOCC_I003_20181211.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x266fe968ce45fa3373726329ce6104b9ca4a9c66_ext.sol,LinkedList.removeItem,120,145,"REF_5(uint256) -> elementLocation[_item],TMP_27(bool) = REF_5 == 0,CONDITION TMP_27,RETURN False,REF_6(uint256) -> elementLocation[_item],key(uint256) := REF_6(uint256),TMP_28(bool) = size == 1,CONDITION TMP_28,tail(uint256) := 0(uint256),head(uint256) := 0(uint256),TMP_29(bool) = key == head,CONDITION TMP_29,REF_7(LinkedList.Element) -> elements[head],REF_8(uint256) -> REF_7.next,head(uint256) := REF_8(uint256),TMP_30(bool) = key == tail,CONDITION TMP_30,REF_9(LinkedList.Element) -> elements[tail],REF_10(uint256) -> REF_9.previous,tail(uint256) := REF_10(uint256),REF_11(LinkedList.Element) -> elements[tail],REF_12(uint256) -> REF_11.next,REF_12(uint256) (->elements) := 0(uint256),TMP_31(uint256) = key - 1,REF_13(LinkedList.Element) -> elements[TMP_31],REF_14(uint256) -> REF_13.next,REF_15(LinkedList.Element) -> elements[key],REF_16(uint256) -> REF_15.next,REF_14(uint256) (->elements) := REF_16(uint256),TMP_32(uint256) = key + 1,REF_17(LinkedList.Element) -> elements[TMP_32],REF_18(uint256) -> REF_17.previous,REF_19(LinkedList.Element) -> elements[key],REF_20(uint256) -> REF_19.previous,REF_18(uint256) (->elements) := REF_20(uint256),TMP_33(uint256) := size(uint256),size(uint256) = size - 1,REF_21(LinkedList.Element) -> elements[key],elements = delete REF_21 ,REF_22(uint256) -> elementLocation[_item],REF_22(uint256) (->elementLocation) := 0(uint256),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
elementLocation[_item] == 0

IRs:
REF_5(uint256) -> elementLocation[_item]
TMP_27(bool) = REF_5 == 0
CONDITION TMP_27""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3

EXPRESSION:
false

IRs:
RETURN False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
key = elementLocation[_item]

IRs:
REF_6(uint256) -> elementLocation[_item]
key(uint256) := REF_6(uint256)""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
size == 1

IRs:
TMP_28(bool) = size == 1
CONDITION TMP_28""];
6->7[label=""True""];
6->9[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tail = 0

IRs:
tail(uint256) := 0(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
head = 0

IRs:
head(uint256) := 0(uint256)""];
8->18;
9[label=""Node Type: IF 9

EXPRESSION:
key == head

IRs:
TMP_29(bool) = key == head
CONDITION TMP_29""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
head = elements[head].next

IRs:
REF_7(LinkedList.Element) -> elements[head]
REF_8(uint256) -> REF_7.next
head(uint256) := REF_8(uint256)""];
10->17;
11[label=""Node Type: IF 11

EXPRESSION:
key == tail

IRs:
TMP_30(bool) = key == tail
CONDITION TMP_30""];
11->12[label=""True""];
11->14[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
tail = elements[tail].previous

IRs:
REF_9(LinkedList.Element) -> elements[tail]
REF_10(uint256) -> REF_9.previous
tail(uint256) := REF_10(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
elements[tail].next = 0

IRs:
REF_11(LinkedList.Element) -> elements[tail]
REF_12(uint256) -> REF_11.next
REF_12(uint256) (->elements) := 0(uint256)""];
13->16;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
elements[key - 1].next = elements[key].next

IRs:
TMP_31(uint256) = key - 1
REF_13(LinkedList.Element) -> elements[TMP_31]
REF_14(uint256) -> REF_13.next
REF_15(LinkedList.Element) -> elements[key]
REF_16(uint256) -> REF_15.next
REF_14(uint256) (->elements) := REF_16(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
elements[key + 1].previous = elements[key].previous

IRs:
TMP_32(uint256) = key + 1
REF_17(LinkedList.Element) -> elements[TMP_32]
REF_18(uint256) -> REF_17.previous
REF_19(LinkedList.Element) -> elements[key]
REF_20(uint256) -> REF_19.previous
REF_18(uint256) (->elements) := REF_20(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
size --

IRs:
TMP_33(uint256) := size(uint256)
size(uint256) = size - 1""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
delete elements[key]

IRs:
REF_21(LinkedList.Element) -> elements[key]
elements = delete REF_21 ""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
elementLocation[_item] = 0

IRs:
REF_22(uint256) -> elementLocation[_item]
REF_22(uint256) (->elementLocation) := 0(uint256)""];
21->22;
22[label=""Node Type: RETURN 22

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,;elementLocation[_item] == 0;false;key = elementLocation[_item];;size == 1;tail = 0;key == head;head = 0;;head = elements[head].next;key == tail;;tail = elements[tail].previous;elements[key - 1].next = elements[key].next;elements[tail].next = 0;;elements[key + 1].previous = elements[key].previous;size --;delete elements[key];elementLocation[_item] = 0;true
./0xf46f049967ed63b864a7f6cdf91d6dac9ea23b2c_ext.sol,WhaleKiller.fallback,16,47,"sender(address) := msg.sender(address),REF_0(uint256) -> invested[sender],TMP_0(bool) = REF_0 != 0,CONDITION TMP_0,REF_1(uint256) -> invested[sender],TMP_1(uint256) = REF_1 * interest,TMP_2(uint256) = TMP_1 / 100,REF_2(uint256) -> timeInvest[sender],TMP_3(uint256) = now - REF_2,TMP_4(uint256) = TMP_2 * TMP_3,TMP_5(uint256) = TMP_4 / 86400,amount(uint256) := TMP_5(uint256),TMP_6(bool) = msg.value == 0,CONDITION TMP_6,TMP_7 = CONVERT this to address,TMP_8(uint256) = SOLIDITY_CALL balance(address)(TMP_7),TMP_9(bool) = amount >= TMP_8,CONDITION TMP_9,TMP_10 = CONVERT this to address,TMP_11(uint256) = SOLIDITY_CALL balance(address)(TMP_10),amount(uint256) := TMP_11(uint256),REF_3(uint256) -> rewards[sender],TMP_12(uint256) = REF_3 + amount,REF_4(uint256) -> invested[sender],TMP_13(uint256) = REF_4 * maxRoi,TMP_14(uint256) = TMP_13 / 100,TMP_15(bool) = TMP_12 > TMP_14,CONDITION TMP_15,REF_5(uint256) -> invested[sender],TMP_16(uint256) = REF_5 * maxRoi,TMP_17(uint256) = TMP_16 / 100,REF_6(uint256) -> rewards[sender],TMP_18(uint256) = TMP_17 - REF_6,amount(uint256) := TMP_18(uint256),REF_7(uint256) -> invested[sender],REF_7(uint256) (->invested) := 0(uint256),REF_8(uint256) -> rewards[sender],REF_8(uint256) (->rewards) := 0(uint256),Transfer dest:sender value:amount,Transfer dest:sender value:amount,REF_11(uint256) -> rewards[sender],REF_11(-> rewards) = REF_11 + amount,amount(uint256) := 0(uint256),REF_12(uint256) -> timeInvest[sender],REF_12(uint256) (->timeInvest) := now(uint256),REF_13(uint256) -> invested[sender],TMP_21(uint256) = msg.value + amount,REF_13(-> invested) = REF_13 + TMP_21,TMP_22(bool) = msg.value != 0,CONDITION TMP_22,TMP_23(uint256) = msg.value * whalefee,TMP_24(uint256) = TMP_23 / 100,Transfer dest:WhaleAddr value:TMP_24,REF_15(uint256) -> invested[sender],REF_16(uint256) -> invested[WhaleAddr],TMP_26(bool) = REF_15 > REF_16,CONDITION TMP_26,WhaleAddr(address) := sender(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
sender = msg.sender

IRs:
sender(address) := msg.sender(address)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
invested[sender] != 0

IRs:
REF_0(uint256) -> invested[sender]
TMP_0(bool) = REF_0 != 0
CONDITION TMP_0""];
2->3[label=""True""];
2->19[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
amount = invested[sender] * interest / 100 * (now - timeInvest[sender]) / 86400

IRs:
REF_1(uint256) -> invested[sender]
TMP_1(uint256) = REF_1 * interest
TMP_2(uint256) = TMP_1 / 100
REF_2(uint256) -> timeInvest[sender]
TMP_3(uint256) = now - REF_2
TMP_4(uint256) = TMP_2 * TMP_3
TMP_5(uint256) = TMP_4 / 86400
amount(uint256) := TMP_5(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
msg.value == 0

IRs:
TMP_6(bool) = msg.value == 0
CONDITION TMP_6""];
4->5[label=""True""];
4->18[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
amount >= address(this).balance

IRs:
TMP_7 = CONVERT this to address
TMP_8(uint256) = SOLIDITY_CALL balance(address)(TMP_7)
TMP_9(bool) = amount >= TMP_8
CONDITION TMP_9""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
amount = (address(this).balance)

IRs:
TMP_10 = CONVERT this to address
TMP_11(uint256) = SOLIDITY_CALL balance(address)(TMP_10)
amount(uint256) := TMP_11(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
(rewards[sender] + amount) > invested[sender] * maxRoi / 100

IRs:
REF_3(uint256) -> rewards[sender]
TMP_12(uint256) = REF_3 + amount
REF_4(uint256) -> invested[sender]
TMP_13(uint256) = REF_4 * maxRoi
TMP_14(uint256) = TMP_13 / 100
TMP_15(bool) = TMP_12 > TMP_14
CONDITION TMP_15""];
8->9[label=""True""];
8->14[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
amount = invested[sender] * maxRoi / 100 - rewards[sender]

IRs:
REF_5(uint256) -> invested[sender]
TMP_16(uint256) = REF_5 * maxRoi
TMP_17(uint256) = TMP_16 / 100
REF_6(uint256) -> rewards[sender]
TMP_18(uint256) = TMP_17 - REF_6
amount(uint256) := TMP_18(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
invested[sender] = 0

IRs:
REF_7(uint256) -> invested[sender]
REF_7(uint256) (->invested) := 0(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
rewards[sender] = 0

IRs:
REF_8(uint256) -> rewards[sender]
REF_8(uint256) (->rewards) := 0(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
sender.transfer(amount)

IRs:
Transfer dest:sender value:amount""];
12->13;
13[label=""Node Type: RETURN 13
""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
sender.transfer(amount)

IRs:
Transfer dest:sender value:amount""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
rewards[sender] += amount

IRs:
REF_11(uint256) -> rewards[sender]
REF_11(-> rewards) = REF_11 + amount""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
amount = 0

IRs:
amount(uint256) := 0(uint256)""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
timeInvest[sender] = now

IRs:
REF_12(uint256) -> timeInvest[sender]
REF_12(uint256) (->timeInvest) := now(uint256)""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
invested[sender] += (msg.value + amount)

IRs:
REF_13(uint256) -> invested[sender]
TMP_21(uint256) = msg.value + amount
REF_13(-> invested) = REF_13 + TMP_21""];
21->22;
22[label=""Node Type: IF 22

EXPRESSION:
msg.value != 0

IRs:
TMP_22(bool) = msg.value != 0
CONDITION TMP_22""];
22->23[label=""True""];
22->27[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
WhaleAddr.transfer(msg.value * whalefee / 100)

IRs:
TMP_23(uint256) = msg.value * whalefee
TMP_24(uint256) = TMP_23 / 100
Transfer dest:WhaleAddr value:TMP_24""];
23->24;
24[label=""Node Type: IF 24

EXPRESSION:
invested[sender] > invested[WhaleAddr]

IRs:
REF_15(uint256) -> invested[sender]
REF_16(uint256) -> invested[WhaleAddr]
TMP_26(bool) = REF_15 > REF_16
CONDITION TMP_26""];
24->25[label=""True""];
24->26[label=""False""];
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
WhaleAddr = sender

IRs:
WhaleAddr(address) := sender(address)""];
25->26;
26[label=""Node Type: END_IF 26
""];
26->27;
27[label=""Node Type: END_IF 27
""];
}
",0,1,0,0,sender = msg.sender;invested[sender] != 0;amount = invested[sender] * interest / 100 * (now - timeInvest[sender]) / 86400;;msg.value == 0;amount >= address(this).balance;;amount = (address(this).balance);;(rewards[sender] + amount) > invested[sender] * maxRoi / 100;amount = invested[sender] * maxRoi / 100 - rewards[sender];sender.transfer(amount);invested[sender] = 0;rewards[sender] = 0;sender.transfer(amount);;rewards[sender] += amount;amount = 0;;timeInvest[sender] = now;invested[sender] += (msg.value + amount);msg.value != 0;WhaleAddr.transfer(msg.value * whalefee / 100);;invested[sender] > invested[WhaleAddr];WhaleAddr = sender;
./0x48ee772b8c8927d8d32afc8961fbc177fb723637_ext.sol,Contribution.buy,241,250,"TMP_161(bool) = day >= CRAWDSALE_START_DAY,TMP_162(bool) = day <= CRAWDSALE_END_DAY,TMP_163(bool) = TMP_161 && TMP_162,TMP_164(None) = SOLIDITY_CALL require(bool)(TMP_163),REF_1(mapping(address => uint256)) -> userBuys[day],REF_2(uint256) -> REF_1[_addr],REF_2(-> userBuys) = REF_2 + _amount,REF_3(uint256) -> dailyTotals[day],REF_3(-> dailyTotals) = REF_3 + _amount,totalContributedETH(uint256) = totalContributedETH + _amount,Emit LogBuy(day,_addr,_amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(day >= CRAWDSALE_START_DAY && day <= CRAWDSALE_END_DAY)

IRs:
TMP_161(bool) = day >= CRAWDSALE_START_DAY
TMP_162(bool) = day <= CRAWDSALE_END_DAY
TMP_163(bool) = TMP_161 && TMP_162
TMP_164(None) = SOLIDITY_CALL require(bool)(TMP_163)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
userBuys[day][_addr] += _amount

IRs:
REF_1(mapping(address => uint256)) -> userBuys[day]
REF_2(uint256) -> REF_1[_addr]
REF_2(-> userBuys) = REF_2 + _amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
dailyTotals[day] += _amount

IRs:
REF_3(uint256) -> dailyTotals[day]
REF_3(-> dailyTotals) = REF_3 + _amount""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
totalContributedETH += _amount

IRs:
totalContributedETH(uint256) = totalContributedETH + _amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
LogBuy(day,_addr,_amount)

IRs:
Emit LogBuy(day,_addr,_amount)""];
}
",0,1,0,0,"require(bool)(day >= CRAWDSALE_START_DAY && day <= CRAWDSALE_END_DAY);userBuys[day][_addr] += _amount;dailyTotals[day] += _amount;totalContributedETH += _amount;LogBuy(day,_addr,_amount)"
./0x1edcb0dcc0ee685bbea86f5a31a776029f02c7d3_ext.sol,TokenDistribute.multipleTokenDistribute,51,57,"i(uint256) := 0(uint256),REF_0 -> LENGTH _addresses,TMP_16(bool) = i < REF_0,CONDITION TMP_16,TMP_17 = CONVERT _token to Token,REF_2(address) -> _addresses[i],REF_3(uint256) -> _values[i],TMP_18(uint256) = REF_3 * E18,TMP_19(bool) = HIGH_LEVEL_CALL, dest:TMP_17(Token), function:transfer, arguments:['REF_2', 'TMP_18']  ,TMP_20(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, OwnerHelper.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _addresses.length

IRs:
REF_0 -> LENGTH _addresses
TMP_16(bool) = i < REF_0
CONDITION TMP_16""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Token(_token).transfer(_addresses[i],_values[i] * E18)

IRs:
TMP_17 = CONVERT _token to Token
REF_2(address) -> _addresses[i]
REF_3(uint256) -> _values[i]
TMP_18(uint256) = REF_3 * E18
TMP_19(bool) = HIGH_LEVEL_CALL, dest:TMP_17(Token), function:transfer, arguments:['REF_2', 'TMP_18']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_20(uint256) := i(uint256)
i(uint256) = i + 1""];
6->4;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, OwnerHelper.onlyOwner()()""];
7->3;
}
",0,1,0,0,"onlyOwner();;i < _addresses.length;;i = 0;Token(_token).transfer(_addresses[i],_values[i] * E18);i ++"
./0x268ec2ff9bb1c27b744f465ff25be9d578096c1e_ext.sol,ASBTToken.BurnToken,194,203,"TMP_45(bool) = owner == msg.sender,TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45),REF_28(uint256) -> balances[_from],TMP_47(bool) = REF_28 > 0,TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47),REF_29(uint256) -> balances[_from],_value(uint256) := REF_29(uint256),REF_30(uint256) -> balances[_from],REF_30(-> balances) = REF_30 - _value,_totalSupply(uint256) = _totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(owner == msg.sender)

IRs:
TMP_45(bool) = owner == msg.sender
TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] > 0)

IRs:
REF_28(uint256) -> balances[_from]
TMP_47(bool) = REF_28 > 0
TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
_value = balances[_from]

IRs:
REF_29(uint256) -> balances[_from]
_value(uint256) := REF_29(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] -= _value

IRs:
REF_30(uint256) -> balances[_from]
REF_30(-> balances) = REF_30 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_totalSupply -= _value

IRs:
_totalSupply(uint256) = _totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(owner == msg.sender);require(bool)(balances[_from] > 0);_value = balances[_from];balances[_from] -= _value;_totalSupply -= _value;Burn(_from,_value);true;success"
./0x6ce17d826a1c50e97678810954943c83ebd10066_ext.sol,StandardToken.transferFrom,66,78,"REF_3(mapping(address => uint256)) -> allowed[_from],REF_4(uint256) -> REF_3[msg.sender],allowance(uint256) := REF_4(uint256),REF_5(uint256) -> balances[_from],TMP_3(bool) = REF_5 >= _value,TMP_4(bool) = allowance >= _value,TMP_5(bool) = TMP_3 && TMP_4,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_6(uint256) -> balances[_to],REF_6(-> balances) = REF_6 + _value,REF_7(uint256) -> balances[_from],REF_7(-> balances) = REF_7 - _value,TMP_7(bool) = allowance < MAX_UINT256,CONDITION TMP_7,REF_8(mapping(address => uint256)) -> allowed[_from],REF_9(uint256) -> REF_8[msg.sender],REF_9(-> allowed) = REF_9 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
allowance = allowed[_from][msg.sender]

IRs:
REF_3(mapping(address => uint256)) -> allowed[_from]
REF_4(uint256) -> REF_3[msg.sender]
allowance(uint256) := REF_4(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] >= _value && allowance >= _value)

IRs:
REF_5(uint256) -> balances[_from]
TMP_3(bool) = REF_5 >= _value
TMP_4(bool) = allowance >= _value
TMP_5(bool) = TMP_3 && TMP_4
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_6(uint256) -> balances[_to]
REF_6(-> balances) = REF_6 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] -= _value

IRs:
REF_7(uint256) -> balances[_from]
REF_7(-> balances) = REF_7 - _value""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
allowance < MAX_UINT256

IRs:
TMP_7(bool) = allowance < MAX_UINT256
CONDITION TMP_7""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_8(mapping(address => uint256)) -> allowed[_from]
REF_9(uint256) -> REF_8[msg.sender]
REF_9(-> allowed) = REF_9 - _value""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: RETURN 10

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowance = allowed[_from][msg.sender];require(bool)(balances[_from] >= _value && allowance >= _value);balances[_to] += _value;balances[_from] -= _value;allowance < MAX_UINT256;allowed[_from][msg.sender] -= _value;;Transfer(_from,_to,_value);true;success"
./0x5258e585f8efe5d7ecca0a9232fc26fd8ca02436_ext.sol,KCOIN.burn,128,134,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x1dcadad44aa14154e2393d83edf6c7c6f83cb795_ext.sol,DoggyEthPics._transfer,346,359,"REF_57(uint256) -> ownershipTokenCount[_to],TMP_151(uint256) := REF_57(uint256),REF_57(-> ownershipTokenCount) = REF_57 + 1,REF_58(address) -> doggyIdToOwner[_tokenId],REF_58(address) (->doggyIdToOwner) := _to(address),TMP_152 = CONVERT 0 to address,TMP_153(bool) = _from != TMP_152,CONDITION TMP_153,REF_59(uint256) -> ownershipTokenCount[_from],TMP_154(uint256) := REF_59(uint256),REF_59(-> ownershipTokenCount) = REF_59 - 1,REF_60(address) -> doggyIdToApproved[_tokenId],doggyIdToApproved = delete REF_60 ,Emit Transfer(_from,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownershipTokenCount[_to] ++

IRs:
REF_57(uint256) -> ownershipTokenCount[_to]
TMP_151(uint256) := REF_57(uint256)
REF_57(-> ownershipTokenCount) = REF_57 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
doggyIdToOwner[_tokenId] = _to

IRs:
REF_58(address) -> doggyIdToOwner[_tokenId]
REF_58(address) (->doggyIdToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_152 = CONVERT 0 to address
TMP_153(bool) = _from != TMP_152
CONDITION TMP_153""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownershipTokenCount[_from] --

IRs:
REF_59(uint256) -> ownershipTokenCount[_from]
TMP_154(uint256) := REF_59(uint256)
REF_59(-> ownershipTokenCount) = REF_59 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete doggyIdToApproved[_tokenId]

IRs:
REF_60(address) -> doggyIdToApproved[_tokenId]
doggyIdToApproved = delete REF_60 ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
}
",0,1,0,0,"ownershipTokenCount[_to] ++;doggyIdToOwner[_tokenId] = _to;_from != address(0);ownershipTokenCount[_from] --;;delete doggyIdToApproved[_tokenId];Transfer(_from,_to,_tokenId)"
./0x267398927b5886df921b235afe9dbbe47fbcc37d_ext.sol,NobarToken._transfer,30,39,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 > REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value > balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 > REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value > balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xc398fb8a6c71a7b130043bf5a3f05d9d51c2cac8_ext.sol,CHAD.totalSupply,120,122,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0xb44a823579aa618b96d6f20a3330901e85f96f73_ext.sol,ClockAuctionBase._computeCurrentPrice,268,303,"TMP_40(bool) = _secondsPassed >= _duration,CONDITION TMP_40,RETURN _endingPrice,TMP_41 = CONVERT _endingPrice to int256,TMP_42 = CONVERT _startingPrice to int256,TMP_43(int256) = TMP_41 - TMP_42,totalPriceChange(int256) := TMP_43(int256),TMP_44 = CONVERT _secondsPassed to int256,TMP_45(int256) = totalPriceChange * TMP_44,TMP_46 = CONVERT _duration to int256,TMP_47(int256) = TMP_45 / TMP_46,currentPriceChange(int256) := TMP_47(int256),TMP_48 = CONVERT _startingPrice to int256,TMP_49(int256) = TMP_48 + currentPriceChange,currentPrice(int256) := TMP_49(int256),TMP_50 = CONVERT currentPrice to uint256,RETURN TMP_50","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_secondsPassed >= _duration

IRs:
TMP_40(bool) = _secondsPassed >= _duration
CONDITION TMP_40""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
_endingPrice

IRs:
RETURN _endingPrice""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
totalPriceChange = int256(_endingPrice) - int256(_startingPrice)

IRs:
TMP_41 = CONVERT _endingPrice to int256
TMP_42 = CONVERT _startingPrice to int256
TMP_43(int256) = TMP_41 - TMP_42
totalPriceChange(int256) := TMP_43(int256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration)

IRs:
TMP_44 = CONVERT _secondsPassed to int256
TMP_45(int256) = totalPriceChange * TMP_44
TMP_46 = CONVERT _duration to int256
TMP_47(int256) = TMP_45 / TMP_46
currentPriceChange(int256) := TMP_47(int256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
currentPrice = int256(_startingPrice) + currentPriceChange

IRs:
TMP_48 = CONVERT _startingPrice to int256
TMP_49(int256) = TMP_48 + currentPriceChange
currentPrice(int256) := TMP_49(int256)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
uint256(currentPrice)

IRs:
TMP_50 = CONVERT currentPrice to uint256
RETURN TMP_50""];
}
",0,1,0,0,_secondsPassed >= _duration;_endingPrice;totalPriceChange = int256(_endingPrice) - int256(_startingPrice);currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);currentPrice = int256(_startingPrice) + currentPriceChange;uint256(currentPrice)
./0x5292eb1d4f669e697ad14e55d151013969485711_ext.sol,WorkValley.burnFrom,90,98,"REF_19(uint256) -> balanceOf[_from],TMP_24(bool) = REF_19 >= _value,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_26(bool) = _value <= REF_21,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_24(bool) = REF_19 >= _value
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_26(bool) = _value <= REF_21
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x34737a1ed7508ca6bda6747825c901831f3cd8c0_ext.sol,Weko.claim,126,143,"REF_10(bool) -> buried[msg.sender],TMP_59(None) = SOLIDITY_CALL require(bool)(REF_10),TMP_60(bool) = _payout != _fee,TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60),TMP_62(bool) = msg.sender != _payout,TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62),TMP_64(bool) = msg.sender != _fee,TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64),REF_11(uint256) -> claimed[msg.sender],TMP_66(bool) = REF_11 == 1,REF_12(uint256) -> claimed[msg.sender],TMP_67(uint256) = block.timestamp - REF_12,TMP_68(bool) = TMP_67 >= epoch,TMP_69(bool) = TMP_66 || TMP_68,TMP_70(None) = SOLIDITY_CALL require(bool)(TMP_69),REF_13(uint256) -> balances[msg.sender],TMP_71(bool) = REF_13 >= claimAmount,TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71),REF_14(uint256) -> claimed[msg.sender],REF_14(uint256) (->claimed) := block.timestamp(uint256),REF_15(uint256) -> balances[msg.sender],REF_16(uint256) -> balances[_payout],TMP_73(uint256) = REF_15 + REF_16,REF_17(uint256) -> balances[_fee],TMP_74(uint256) = TMP_73 + REF_17,previousBalances(uint256) := TMP_74(uint256),REF_18(uint256) -> balances[msg.sender],REF_18(-> balances) = REF_18 - claimAmount,REF_19(uint256) -> balances[_payout],REF_19(-> balances) = REF_19 + payAmount,REF_20(uint256) -> balances[_fee],REF_20(-> balances) = REF_20 + feeAmount,Emit Claim(msg.sender,_payout,_fee),Emit Transfer(msg.sender,_payout,payAmount),Emit Transfer(msg.sender,_fee,feeAmount),REF_21(uint256) -> balances[msg.sender],REF_22(uint256) -> balances[_payout],TMP_78(uint256) = REF_21 + REF_22,REF_23(uint256) -> balances[_fee],TMP_79(uint256) = TMP_78 + REF_23,TMP_80(bool) = TMP_79 == previousBalances,TMP_81(None) = SOLIDITY_CALL assert(bool)(TMP_80),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(buried[msg.sender])

IRs:
REF_10(bool) -> buried[msg.sender]
TMP_59(None) = SOLIDITY_CALL require(bool)(REF_10)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_payout != _fee)

IRs:
TMP_60(bool) = _payout != _fee
TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(msg.sender != _payout)

IRs:
TMP_62(bool) = msg.sender != _payout
TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(msg.sender != _fee)

IRs:
TMP_64(bool) = msg.sender != _fee
TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(claimed[msg.sender] == 1 || (block.timestamp - claimed[msg.sender]) >= epoch)

IRs:
REF_11(uint256) -> claimed[msg.sender]
TMP_66(bool) = REF_11 == 1
REF_12(uint256) -> claimed[msg.sender]
TMP_67(uint256) = block.timestamp - REF_12
TMP_68(bool) = TMP_67 >= epoch
TMP_69(bool) = TMP_66 || TMP_68
TMP_70(None) = SOLIDITY_CALL require(bool)(TMP_69)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(balances[msg.sender] >= claimAmount)

IRs:
REF_13(uint256) -> balances[msg.sender]
TMP_71(bool) = REF_13 >= claimAmount
TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
claimed[msg.sender] = block.timestamp

IRs:
REF_14(uint256) -> claimed[msg.sender]
REF_14(uint256) (->claimed) := block.timestamp(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
previousBalances = balances[msg.sender] + balances[_payout] + balances[_fee]

IRs:
REF_15(uint256) -> balances[msg.sender]
REF_16(uint256) -> balances[_payout]
TMP_73(uint256) = REF_15 + REF_16
REF_17(uint256) -> balances[_fee]
TMP_74(uint256) = TMP_73 + REF_17
previousBalances(uint256) := TMP_74(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
balances[msg.sender] -= claimAmount

IRs:
REF_18(uint256) -> balances[msg.sender]
REF_18(-> balances) = REF_18 - claimAmount""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
balances[_payout] += payAmount

IRs:
REF_19(uint256) -> balances[_payout]
REF_19(-> balances) = REF_19 + payAmount""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
balances[_fee] += feeAmount

IRs:
REF_20(uint256) -> balances[_fee]
REF_20(-> balances) = REF_20 + feeAmount""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
Claim(msg.sender,_payout,_fee)

IRs:
Emit Claim(msg.sender,_payout,_fee)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
Transfer(msg.sender,_payout,payAmount)

IRs:
Emit Transfer(msg.sender,_payout,payAmount)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
Transfer(msg.sender,_fee,feeAmount)

IRs:
Emit Transfer(msg.sender,_fee,feeAmount)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
assert(bool)(balances[msg.sender] + balances[_payout] + balances[_fee] == previousBalances)

IRs:
REF_21(uint256) -> balances[msg.sender]
REF_22(uint256) -> balances[_payout]
TMP_78(uint256) = REF_21 + REF_22
REF_23(uint256) -> balances[_fee]
TMP_79(uint256) = TMP_78 + REF_23
TMP_80(bool) = TMP_79 == previousBalances
TMP_81(None) = SOLIDITY_CALL assert(bool)(TMP_80)""];
15->16;
16[label=""Node Type: RETURN 16

EXPRESSION:
true

IRs:
RETURN True""];
17[label=""Node Type: RETURN 17

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(buried[msg.sender]);require(bool)(_payout != _fee);require(bool)(msg.sender != _payout);require(bool)(msg.sender != _fee);require(bool)(claimed[msg.sender] == 1 || (block.timestamp - claimed[msg.sender]) >= epoch);require(bool)(balances[msg.sender] >= claimAmount);claimed[msg.sender] = block.timestamp;previousBalances = balances[msg.sender] + balances[_payout] + balances[_fee];balances[msg.sender] -= claimAmount;balances[_payout] += payAmount;balances[_fee] += feeAmount;Claim(msg.sender,_payout,_fee);Transfer(msg.sender,_payout,payAmount);Transfer(msg.sender,_fee,feeAmount);assert(bool)(balances[msg.sender] + balances[_payout] + balances[_fee] == previousBalances);true;success"
./0x40b5ccf92f9c980fbc6f2f0c0af7a4afff0f7c48_ext.sol,TokenERC20.burn,132,138,"REF_17(uint256) -> balanceOf[msg.sender],TMP_24(bool) = REF_17 >= _value,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_24(bool) = REF_17 >= _value
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xbe4411737170e852ea275d235145ceab77e0fe73_ext.sol,VouchCoin.approveAndCall,106,111,"TMP_33(bool) = INTERNAL_CALL, VouchCoin.approve(address,uint256)(_spender,_value),Emit Approval(msg.sender,_spender,_value),TMP_35 = CONVERT _spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_35(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_33(bool) = INTERNAL_CALL, VouchCoin.approve(address,uint256)(_spender,_value)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(_spender).receiveApproval(msg.sender,_value,this,_data)

IRs:
TMP_35 = CONVERT _spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_35(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"approve(_spender,_value);Approval(msg.sender,_spender,_value);ApproveAndCallFallBack(_spender).receiveApproval(msg.sender,_value,this,_data);true;success"
./0x5bd7b9cd17cee4d2fae01d9695e83098cf409488_ext.sol,Queue.getQueueLength,220,222,"REF_25 -> LENGTH queue,TMP_45(uint256) = REF_25 - currentReceiverIndex,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
queue.length - currentReceiverIndex

IRs:
REF_25 -> LENGTH queue
TMP_45(uint256) = REF_25 - currentReceiverIndex
RETURN TMP_45""];
}
",0,1,0,0,queue.length - currentReceiverIndex
./0x28f01187b61d799f6d90a7c8c5325a9de95f025d_ext.sol,Sender.batch,61,65,"i(uint256) := 0(uint256),REF_0 -> LENGTH _data,TMP_14(bool) = i < REF_0,CONDITION TMP_14,REF_2(address) -> _data[i],TMP_15(bool) = HIGH_LEVEL_CALL, dest:DEEM(token), function:transfer, arguments:['REF_2', '_amount']  ,TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15),TMP_17(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, admined.onlyAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _data.length

IRs:
REF_0 -> LENGTH _data
TMP_14(bool) = i < REF_0
CONDITION TMP_14""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(DEEM.transfer(_data[i],_amount))

IRs:
REF_2(address) -> _data[i]
TMP_15(bool) = HIGH_LEVEL_CALL, dest:DEEM(token), function:transfer, arguments:['REF_2', '_amount']  
TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_17(uint256) := i(uint256)
i(uint256) = i + 1""];
6->4;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, admined.onlyAdmin()()""];
7->3;
}
",0,1,0,0,"onlyAdmin();;i < _data.length;;i = 0;require(bool)(DEEM.transfer(_data[i],_amount));i ++"
./0x0dfb14c2db6c9824d3210ed7e2689e1a51a8e954_ext.sol,PriceGet.deposit,27,30,"TMP_1(bool) = msg.value > 1000000000000000,TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1),REF_0(uint256) -> locked[msg.sender],REF_0(-> locked) = REF_0 + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value > 1000000000000000)

IRs:
TMP_1(bool) = msg.value > 1000000000000000
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
locked[msg.sender] += msg.value

IRs:
REF_0(uint256) -> locked[msg.sender]
REF_0(-> locked) = REF_0 + msg.value""];
}
",0,1,0,0,require(bool)(msg.value > 1000000000000000);locked[msg.sender] += msg.value
./0x1ea9fa167fdc4ae4c13e9e904d26aadf010d097b_ext.sol,Token.burn,244,254,"TMP_105(None) = SOLIDITY_CALL require(bool)(isBurnable),TMP_106 = UnaryType.BANG canAnyoneBurn ,TMP_107(bool) = msg.sender != owner,TMP_108(bool) = TMP_106 && TMP_107,CONDITION TMP_108,RETURN False,REF_28(uint256) -> balances[msg.sender],REF_29(uint256) -> balances[msg.sender],TMP_109(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_29,value),REF_28(uint256) (->balances) := TMP_109(uint256),TMP_110(uint256) = totalSupply - value,totalSupply(uint256) := TMP_110(uint256),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isBurnable)

IRs:
TMP_105(None) = SOLIDITY_CALL require(bool)(isBurnable)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
! canAnyoneBurn && msg.sender != owner

IRs:
TMP_106 = UnaryType.BANG canAnyoneBurn 
TMP_107(bool) = msg.sender != owner
TMP_108(bool) = TMP_106 && TMP_107
CONDITION TMP_108""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3

EXPRESSION:
false

IRs:
RETURN False""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[msg.sender] = safeSub(balances[msg.sender],value)

IRs:
REF_28(uint256) -> balances[msg.sender]
REF_29(uint256) -> balances[msg.sender]
TMP_109(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(REF_29,value)
REF_28(uint256) (->balances) := TMP_109(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
totalSupply = totalSupply - value

IRs:
TMP_110(uint256) = totalSupply - value
totalSupply(uint256) := TMP_110(uint256)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(isBurnable);! canAnyoneBurn && msg.sender != owner;false;;balances[msg.sender] = safeSub(balances[msg.sender],value);totalSupply = totalSupply - value;true;success"
./0x28cb4e001f87dacd8e97250e1312008668bd78a8_ext.sol,multi_user_wallet.setup_key,23,28,"TMP_9(bool) = keyHash == 0,CONDITION TMP_9,TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10),keyHash(bytes32) := TMP_11(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
keyHash == 0x0

IRs:
TMP_9(bool) = keyHash == 0
CONDITION TMP_9""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
keyHash = keccak256()(abi.encodePacked(key))

IRs:
TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10)
keyHash(bytes32) := TMP_11(bytes32)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,1,0,0,keyHash == 0x0;keyHash = keccak256()(abi.encodePacked(key));
./0xee522a9bbe2507546aec572cea7be0f250cba0cb_ext.sol,CentaToken.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0xec193241dc1ca3bbe3165de6d37a793585b4504e_ext.sol,MyAdvancedToken.mintToken,393,403,"REF_56(uint256) -> balanceOf[target],REF_56(-> balanceOf) = REF_56 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_56(uint256) -> balanceOf[target]
REF_56(-> balanceOf) = REF_56 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x32cff49cd98e8af9dd2ba3ac370949fb06f6a412_ext.sol,TokenERC20.burnFrom,162,170,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x70409a44060fbc75a9e44170d025c049c929059e_ext.sol,StandardToken.transferFrom,58,68,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0xc801e2ca666fdfcb43cf29b972d7f3731436e4a1_ext.sol,TokenERC20.burnFrom,161,169,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x6ced978feaa31ad4c2acdd5eae4e034f2ac3919b_ext.sol,SlowMoon.dividendsOf,487,493,"REF_35(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_79(uint256) = profitPerShare_ * REF_35,TMP_80 = CONVERT TMP_79 to int256,REF_36(int256) -> payoutsTo_[_customerAddress],TMP_81(int256) = TMP_80 - REF_36,TMP_82 = CONVERT TMP_81 to uint256,TMP_83(uint256) = TMP_82 / magnitude,RETURN TMP_83","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_35(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_79(uint256) = profitPerShare_ * REF_35
TMP_80 = CONVERT TMP_79 to int256
REF_36(int256) -> payoutsTo_[_customerAddress]
TMP_81(int256) = TMP_80 - REF_36
TMP_82 = CONVERT TMP_81 to uint256
TMP_83(uint256) = TMP_82 / magnitude
RETURN TMP_83""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x1c4d21d3534010ca07b5f2a9aded27ac9abb64cc_ext.sol,COTY.burn,135,141,"REF_17(uint256) -> balanceOf[msg.sender],TMP_25(bool) = REF_17 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_25(bool) = REF_17 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x5c6d8bb345f4299c76f24fc771ef04dd160c4d36_ext.sol,EthCrystal._currentPlayerAmountUnclaimed,277,288,"TMP_124(bool) = _RoundID == 0,CONDITION TMP_124,REF_279(EthCrystal.TowersInfoList) -> GameRounds[_TowerType],REF_280(uint256) -> REF_279.currentRoundID,_RoundID(uint256) := REF_280(uint256),REF_281(EthCrystal.PlayerInfo) -> players[_playerAddress],REF_282(mapping(uint256 => EthCrystal.TowersRoundInfo)) -> REF_281.TowersList,REF_283(EthCrystal.TowersRoundInfo) -> REF_282[_TowerType],REF_284(mapping(uint256 => EthCrystal.PlayerRoundInfo)) -> REF_283.RoundList,REF_285(EthCrystal.PlayerRoundInfo) -> REF_284[_RoundID],REF_286(uint256) -> REF_285.warriors,_warriors(uint256) := REF_286(uint256),REF_287(EthCrystal.TowersInfoList) -> GameRounds[_TowerType],REF_288(mapping(uint256 => EthCrystal.TowersInfo)) -> REF_287.RoundList,REF_289(EthCrystal.TowersInfo) -> REF_288[_RoundID],REF_290(uint256) -> REF_289.towerBalance,TMP_125(uint256) = _warriors * REF_290,REF_291(EthCrystal.TowersInfoList) -> GameRounds[_RoundID],REF_292(uint256) -> REF_291.dividendShare,TMP_126(uint256) = TMP_125 * REF_292,REF_293(EthCrystal.TowersInfoList) -> GameRounds[_TowerType],REF_294(mapping(uint256 => EthCrystal.TowersInfo)) -> REF_293.RoundList,REF_295(EthCrystal.TowersInfo) -> REF_294[_RoundID],REF_296(uint256) -> REF_295.totalWarriors,TMP_127(uint256) = TMP_126 / REF_296,TMP_128(uint256) = TMP_127 / 100,_totalForCashOut(uint256) := TMP_128(uint256),REF_297(EthCrystal.PlayerInfo) -> players[_playerAddress],REF_298(mapping(uint256 => EthCrystal.TowersRoundInfo)) -> REF_297.TowersList,REF_299(EthCrystal.TowersRoundInfo) -> REF_298[_TowerType],REF_300(mapping(uint256 => EthCrystal.PlayerRoundInfo)) -> REF_299.RoundList,REF_301(EthCrystal.PlayerRoundInfo) -> REF_300[_RoundID],REF_302(uint256) -> REF_301.cashedOut,TMP_129(uint256) = _totalForCashOut - REF_302,_unclaimedAmount(uint256) := TMP_129(uint256),RETURN _unclaimedAmount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_RoundID == 0

IRs:
TMP_124(bool) = _RoundID == 0
CONDITION TMP_124""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_RoundID = GameRounds[_TowerType].currentRoundID

IRs:
REF_279(EthCrystal.TowersInfoList) -> GameRounds[_TowerType]
REF_280(uint256) -> REF_279.currentRoundID
_RoundID(uint256) := REF_280(uint256)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
_warriors = players[_playerAddress].TowersList[_TowerType].RoundList[_RoundID].warriors

IRs:
REF_281(EthCrystal.PlayerInfo) -> players[_playerAddress]
REF_282(mapping(uint256 => EthCrystal.TowersRoundInfo)) -> REF_281.TowersList
REF_283(EthCrystal.TowersRoundInfo) -> REF_282[_TowerType]
REF_284(mapping(uint256 => EthCrystal.PlayerRoundInfo)) -> REF_283.RoundList
REF_285(EthCrystal.PlayerRoundInfo) -> REF_284[_RoundID]
REF_286(uint256) -> REF_285.warriors
_warriors(uint256) := REF_286(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
_totalForCashOut = (_warriors * GameRounds[_TowerType].RoundList[_RoundID].towerBalance * GameRounds[_RoundID].dividendShare / GameRounds[_TowerType].RoundList[_RoundID].totalWarriors / 100)

IRs:
REF_287(EthCrystal.TowersInfoList) -> GameRounds[_TowerType]
REF_288(mapping(uint256 => EthCrystal.TowersInfo)) -> REF_287.RoundList
REF_289(EthCrystal.TowersInfo) -> REF_288[_RoundID]
REF_290(uint256) -> REF_289.towerBalance
TMP_125(uint256) = _warriors * REF_290
REF_291(EthCrystal.TowersInfoList) -> GameRounds[_RoundID]
REF_292(uint256) -> REF_291.dividendShare
TMP_126(uint256) = TMP_125 * REF_292
REF_293(EthCrystal.TowersInfoList) -> GameRounds[_TowerType]
REF_294(mapping(uint256 => EthCrystal.TowersInfo)) -> REF_293.RoundList
REF_295(EthCrystal.TowersInfo) -> REF_294[_RoundID]
REF_296(uint256) -> REF_295.totalWarriors
TMP_127(uint256) = TMP_126 / REF_296
TMP_128(uint256) = TMP_127 / 100
_totalForCashOut(uint256) := TMP_128(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
_unclaimedAmount = _totalForCashOut - players[_playerAddress].TowersList[_TowerType].RoundList[_RoundID].cashedOut

IRs:
REF_297(EthCrystal.PlayerInfo) -> players[_playerAddress]
REF_298(mapping(uint256 => EthCrystal.TowersRoundInfo)) -> REF_297.TowersList
REF_299(EthCrystal.TowersRoundInfo) -> REF_298[_TowerType]
REF_300(mapping(uint256 => EthCrystal.PlayerRoundInfo)) -> REF_299.RoundList
REF_301(EthCrystal.PlayerRoundInfo) -> REF_300[_RoundID]
REF_302(uint256) -> REF_301.cashedOut
TMP_129(uint256) = _totalForCashOut - REF_302
_unclaimedAmount(uint256) := TMP_129(uint256)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
(_unclaimedAmount)

IRs:
RETURN _unclaimedAmount""];
}
",0,1,0,0,_RoundID == 0;_RoundID = GameRounds[_TowerType].currentRoundID;;_warriors = players[_playerAddress].TowersList[_TowerType].RoundList[_RoundID].warriors;_totalForCashOut = (_warriors * GameRounds[_TowerType].RoundList[_RoundID].towerBalance * GameRounds[_RoundID].dividendShare / GameRounds[_TowerType].RoundList[_RoundID].totalWarriors / 100);_unclaimedAmount = _totalForCashOut - players[_playerAddress].TowersList[_TowerType].RoundList[_RoundID].cashedOut;(_unclaimedAmount)
./0x92972bbc89708127016046c150e3a223431a31e0_ext.sol,GMQToken.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x1c242bc9af8aa768a54222ed47bb756f1a1a757b_ext.sol,LockableFreezableBurnablePausableERC20Token.refreshLockStatus,619,650,"REF_324(LockableFreezableBurnablePausableERC20Token.LockAtt) -> lockAtts[_account],REF_325(uint256) -> REF_324.lockAmount,TMP_398(bool) = REF_325 <= 0,CONDITION TMP_398,RETURN False,REF_326(LockableFreezableBurnablePausableERC20Token.LockAtt) -> lockAtts[_account],REF_327(uint256) -> REF_326.interval,TMP_399(bool) = REF_327 > 0,TMP_400(None) = SOLIDITY_CALL require(bool,string)(TMP_399,Interval error),REF_328(LockableFreezableBurnablePausableERC20Token.LockAtt) -> lockAtts[_account],REF_329(uint256) -> REF_328.initLockAmount,initlockamount(uint256) := REF_329(uint256),REF_330(LockableFreezableBurnablePausableERC20Token.LockAtt) -> lockAtts[_account],REF_331(uint256) -> REF_330.startLockTime,startlocktime(uint256) := REF_331(uint256),REF_332(LockableFreezableBurnablePausableERC20Token.LockAtt) -> lockAtts[_account],REF_333(uint256) -> REF_332.cliff,cliff(uint256) := REF_333(uint256),REF_334(LockableFreezableBurnablePausableERC20Token.LockAtt) -> lockAtts[_account],REF_335(uint256) -> REF_334.interval,interval(uint256) := REF_335(uint256),REF_336(LockableFreezableBurnablePausableERC20Token.LockAtt) -> lockAtts[_account],REF_337(uint256) -> REF_336.releaseCount,releasecount(uint256) := REF_337(uint256),releaseamount(uint256) := 0(uint256),TMP_401(uint256) = startlocktime + cliff,TMP_402(bool) = block.timestamp < TMP_401,CONDITION TMP_402,RETURN False,TMP_403(uint256) = block.timestamp - startlocktime,TMP_404(uint256) = TMP_403 - cliff,exceedtime(uint256) := TMP_404(uint256),TMP_405(bool) = exceedtime >= 0,CONDITION TMP_405,TMP_406(uint256) = exceedtime / interval,TMP_407(uint256) = TMP_406 + 1,TMP_408(uint256) = TMP_407 * initlockamount,TMP_409(uint256) = TMP_408 / releasecount,releaseamount(uint256) := TMP_409(uint256),TMP_410(uint256) = initlockamount - releaseamount,lockamount(uint256) := TMP_410(uint256),TMP_411(bool) = lockamount < 0,CONDITION TMP_411,lockamount(uint256) := 0(uint256),TMP_412(bool) = lockamount > initlockamount,CONDITION TMP_412,lockamount(uint256) := initlockamount(uint256),REF_338(LockableFreezableBurnablePausableERC20Token.LockAtt) -> lockAtts[_account],REF_339(uint256) -> REF_338.lockAmount,REF_339(uint256) (->lockAtts) := lockamount(uint256),Emit RefreshedLockStatus(_account),RETURN True,MODIFIER_CALL, Pausable.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->28;
1[label=""Node Type: IF 1

EXPRESSION:
lockAtts[_account].lockAmount <= 0

IRs:
REF_324(LockableFreezableBurnablePausableERC20Token.LockAtt) -> lockAtts[_account]
REF_325(uint256) -> REF_324.lockAmount
TMP_398(bool) = REF_325 <= 0
CONDITION TMP_398""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool,string)(lockAtts[_account].interval > 0,Interval error)

IRs:
REF_326(LockableFreezableBurnablePausableERC20Token.LockAtt) -> lockAtts[_account]
REF_327(uint256) -> REF_326.interval
TMP_399(bool) = REF_327 > 0
TMP_400(None) = SOLIDITY_CALL require(bool,string)(TMP_399,Interval error)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
initlockamount = lockAtts[_account].initLockAmount

IRs:
REF_328(LockableFreezableBurnablePausableERC20Token.LockAtt) -> lockAtts[_account]
REF_329(uint256) -> REF_328.initLockAmount
initlockamount(uint256) := REF_329(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
startlocktime = lockAtts[_account].startLockTime

IRs:
REF_330(LockableFreezableBurnablePausableERC20Token.LockAtt) -> lockAtts[_account]
REF_331(uint256) -> REF_330.startLockTime
startlocktime(uint256) := REF_331(uint256)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
cliff = lockAtts[_account].cliff

IRs:
REF_332(LockableFreezableBurnablePausableERC20Token.LockAtt) -> lockAtts[_account]
REF_333(uint256) -> REF_332.cliff
cliff(uint256) := REF_333(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
interval = lockAtts[_account].interval

IRs:
REF_334(LockableFreezableBurnablePausableERC20Token.LockAtt) -> lockAtts[_account]
REF_335(uint256) -> REF_334.interval
interval(uint256) := REF_335(uint256)""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
releasecount = lockAtts[_account].releaseCount

IRs:
REF_336(LockableFreezableBurnablePausableERC20Token.LockAtt) -> lockAtts[_account]
REF_337(uint256) -> REF_336.releaseCount
releasecount(uint256) := REF_337(uint256)""];
9->10;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
releaseamount = 0

IRs:
releaseamount(uint256) := 0(uint256)""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
block.timestamp < startlocktime + cliff

IRs:
TMP_401(uint256) = startlocktime + cliff
TMP_402(bool) = block.timestamp < TMP_401
CONDITION TMP_402""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: RETURN 12

EXPRESSION:
false

IRs:
RETURN False""];
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: NEW VARIABLE 14

EXPRESSION:
exceedtime = block.timestamp - startlocktime - cliff

IRs:
TMP_403(uint256) = block.timestamp - startlocktime
TMP_404(uint256) = TMP_403 - cliff
exceedtime(uint256) := TMP_404(uint256)""];
14->15;
15[label=""Node Type: IF 15

EXPRESSION:
exceedtime >= 0

IRs:
TMP_405(bool) = exceedtime >= 0
CONDITION TMP_405""];
15->16[label=""True""];
15->25[label=""False""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
releaseamount = (exceedtime / interval + 1) * initlockamount / releasecount

IRs:
TMP_406(uint256) = exceedtime / interval
TMP_407(uint256) = TMP_406 + 1
TMP_408(uint256) = TMP_407 * initlockamount
TMP_409(uint256) = TMP_408 / releasecount
releaseamount(uint256) := TMP_409(uint256)""];
16->17;
17[label=""Node Type: NEW VARIABLE 17

EXPRESSION:
lockamount = initlockamount - releaseamount

IRs:
TMP_410(uint256) = initlockamount - releaseamount
lockamount(uint256) := TMP_410(uint256)""];
17->18;
18[label=""Node Type: IF 18

EXPRESSION:
lockamount < 0

IRs:
TMP_411(bool) = lockamount < 0
CONDITION TMP_411""];
18->19[label=""True""];
18->20[label=""False""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
lockamount = 0

IRs:
lockamount(uint256) := 0(uint256)""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: IF 21

EXPRESSION:
lockamount > initlockamount

IRs:
TMP_412(bool) = lockamount > initlockamount
CONDITION TMP_412""];
21->22[label=""True""];
21->23[label=""False""];
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
lockamount = initlockamount

IRs:
lockamount(uint256) := initlockamount(uint256)""];
22->23;
23[label=""Node Type: END_IF 23
""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
lockAtts[_account].lockAmount = lockamount

IRs:
REF_338(LockableFreezableBurnablePausableERC20Token.LockAtt) -> lockAtts[_account]
REF_339(uint256) -> REF_338.lockAmount
REF_339(uint256) (->lockAtts) := lockamount(uint256)""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->26;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
RefreshedLockStatus(_account)

IRs:
Emit RefreshedLockStatus(_account)""];
26->27;
27[label=""Node Type: RETURN 27

EXPRESSION:
true

IRs:
RETURN True""];
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
28->1;
}
",0,1,0,0,"whenNotPaused();lockAtts[_account].lockAmount <= 0;false;;require(bool,string)(lockAtts[_account].interval > 0,Interval error);initlockamount = lockAtts[_account].initLockAmount;startlocktime = lockAtts[_account].startLockTime;cliff = lockAtts[_account].cliff;interval = lockAtts[_account].interval;releasecount = lockAtts[_account].releaseCount;releaseamount = 0;block.timestamp < startlocktime + cliff;false;;exceedtime = block.timestamp - startlocktime - cliff;exceedtime >= 0;releaseamount = (exceedtime / interval + 1) * initlockamount / releasecount;;lockamount = initlockamount - releaseamount;lockamount < 0;lockamount = 0;;lockamount > initlockamount;lockamount = initlockamount;;lockAtts[_account].lockAmount = lockamount;RefreshedLockStatus(_account);true"
./0xbf2000b42c1ba2eb9e5163a0b7e2fe987ed124b4_ext.sol,SeedCrowdsaleContract.processTransaction,211,239,"TMP_59(uint256) = INTERNAL_CALL, SeedCrowdsaleContract.calculateMaxContribution(address)(_contributor),maxContribution(uint256) := TMP_59(uint256),contributionAmount(uint256) := _amount(uint256),returnAmount(uint256) := 0(uint256),TMP_60(bool) = maxContribution < _amount,CONDITION TMP_60,contributionAmount(uint256) := maxContribution(uint256),TMP_61(uint256) = _amount - maxContribution,returnAmount(uint256) := TMP_61(uint256),TMP_62(uint256) = ethRaised + contributionAmount,TMP_63(bool) = TMP_62 >= minCap,TMP_64(bool) = minCap > ethRaised,TMP_65(bool) = TMP_63 && TMP_64,CONDITION TMP_65,Emit MinCapReached(block.timestamp),REF_18(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor],REF_19(uint256) -> REF_18.contributionAmount,TMP_67(bool) = REF_19 == 0,CONDITION TMP_67,REF_20(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor],REF_21(uint256) -> REF_20.contributionAmount,REF_21(uint256) (->contributorList) := contributionAmount(uint256),REF_22(address) -> contributorIndexes[nextContributorIndex],REF_22(address) (->contributorIndexes) := _contributor(address),TMP_68(uint256) := nextContributorIndex(uint256),nextContributorIndex(uint256) = nextContributorIndex + 1,REF_23(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor],REF_24(uint256) -> REF_23.contributionAmount,REF_24(-> contributorList) = REF_24 + contributionAmount,ethRaised(uint256) = ethRaised + contributionAmount,Emit ContributionMade(msg.sender,contributionAmount),TMP_70(bool) = returnAmount != 0,CONDITION TMP_70,Transfer dest:_contributor value:returnAmount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
maxContribution = calculateMaxContribution(_contributor)

IRs:
TMP_59(uint256) = INTERNAL_CALL, SeedCrowdsaleContract.calculateMaxContribution(address)(_contributor)
maxContribution(uint256) := TMP_59(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
contributionAmount = _amount

IRs:
contributionAmount(uint256) := _amount(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
returnAmount = 0

IRs:
returnAmount(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
maxContribution < _amount

IRs:
TMP_60(bool) = maxContribution < _amount
CONDITION TMP_60""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
contributionAmount = maxContribution

IRs:
contributionAmount(uint256) := maxContribution(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
returnAmount = _amount - maxContribution

IRs:
TMP_61(uint256) = _amount - maxContribution
returnAmount(uint256) := TMP_61(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
ethRaised + contributionAmount >= minCap && minCap > ethRaised

IRs:
TMP_62(uint256) = ethRaised + contributionAmount
TMP_63(bool) = TMP_62 >= minCap
TMP_64(bool) = minCap > ethRaised
TMP_65(bool) = TMP_63 && TMP_64
CONDITION TMP_65""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
MinCapReached(block.timestamp)

IRs:
Emit MinCapReached(block.timestamp)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
contributorList[_contributor].contributionAmount == 0

IRs:
REF_18(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor]
REF_19(uint256) -> REF_18.contributionAmount
TMP_67(bool) = REF_19 == 0
CONDITION TMP_67""];
11->12[label=""True""];
11->15[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
contributorList[_contributor].contributionAmount = contributionAmount

IRs:
REF_20(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor]
REF_21(uint256) -> REF_20.contributionAmount
REF_21(uint256) (->contributorList) := contributionAmount(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
contributorIndexes[nextContributorIndex] = _contributor

IRs:
REF_22(address) -> contributorIndexes[nextContributorIndex]
REF_22(address) (->contributorIndexes) := _contributor(address)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
nextContributorIndex ++

IRs:
TMP_68(uint256) := nextContributorIndex(uint256)
nextContributorIndex(uint256) = nextContributorIndex + 1""];
14->16;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
contributorList[_contributor].contributionAmount += contributionAmount

IRs:
REF_23(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor]
REF_24(uint256) -> REF_23.contributionAmount
REF_24(-> contributorList) = REF_24 + contributionAmount""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
ethRaised += contributionAmount

IRs:
ethRaised(uint256) = ethRaised + contributionAmount""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
ContributionMade(msg.sender,contributionAmount)

IRs:
Emit ContributionMade(msg.sender,contributionAmount)""];
18->19;
19[label=""Node Type: IF 19

EXPRESSION:
returnAmount != 0

IRs:
TMP_70(bool) = returnAmount != 0
CONDITION TMP_70""];
19->20[label=""True""];
19->21[label=""False""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
_contributor.transfer(returnAmount)

IRs:
Transfer dest:_contributor value:returnAmount""];
20->21;
21[label=""Node Type: END_IF 21
""];
}
",0,1,1,0,"maxContribution = calculateMaxContribution(_contributor);contributionAmount = _amount;returnAmount = 0;maxContribution < _amount;contributionAmount = maxContribution;;returnAmount = _amount - maxContribution;ethRaised + contributionAmount >= minCap && minCap > ethRaised;MinCapReached(block.timestamp);;contributorList[_contributor].contributionAmount == 0;contributorList[_contributor].contributionAmount = contributionAmount;contributorList[_contributor].contributionAmount += contributionAmount;contributorIndexes[nextContributorIndex] = _contributor;nextContributorIndex ++;;ethRaised += contributionAmount;ContributionMade(msg.sender,contributionAmount);returnAmount != 0;_contributor.transfer(returnAmount);"
./0xf4dc44f1c618a5e4b6f372347e033ac5e77971a5_ext.sol,CONTINENTAL_AG.transferFrom,42,54,"REF_6(uint256) -> balanceOf[from],TMP_6(bool) = value <= REF_6,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_7(mapping(address => uint256)) -> allowance[from],REF_8(uint256) -> REF_7[msg.sender],TMP_8(bool) = value <= REF_8,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_9(uint256) -> balanceOf[from],REF_9(-> balanceOf) = REF_9 - value,REF_10(uint256) -> balanceOf[to],REF_10(-> balanceOf) = REF_10 + value,REF_11(mapping(address => uint256)) -> allowance[from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowance) = REF_12 - value,Emit Transfer(from,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(value <= balanceOf[from])

IRs:
REF_6(uint256) -> balanceOf[from]
TMP_6(bool) = value <= REF_6
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value <= allowance[from][msg.sender])

IRs:
REF_7(mapping(address => uint256)) -> allowance[from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_8(bool) = value <= REF_8
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[from] -= value

IRs:
REF_9(uint256) -> balanceOf[from]
REF_9(-> balanceOf) = REF_9 - value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[to] += value

IRs:
REF_10(uint256) -> balanceOf[to]
REF_10(-> balanceOf) = REF_10 + value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allowance[from][msg.sender] -= value

IRs:
REF_11(mapping(address => uint256)) -> allowance[from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowance) = REF_12 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(value <= balanceOf[from]);require(bool)(value <= allowance[from][msg.sender]);balanceOf[from] -= value;balanceOf[to] += value;allowance[from][msg.sender] -= value;Transfer(from,to,value);true;success"
./0x1b413506fc42e2f04a4e8c57710f850b234d6653_ext.sol,EpiphanyCoin.mintToken,208,213,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x446f174bc64cbca8b9fe81087798a156cfb863b7_ext.sol,Voting2018.setHashes,46,56,"REF_0 -> LENGTH files,TMP_2(bool) = fileId < REF_0,CONDITION TMP_2,REF_1(Voting2018.File) -> files[fileId],REF_2(string) -> REF_1.hashTime,TMP_3 = CONVERT REF_2 to bytes,hashTimeEmptyTest(bytes) := TMP_3(bytes),REF_3 -> LENGTH hashTimeEmptyTest,TMP_4(bool) = REF_3 == 0,CONDITION TMP_4,REF_4(Voting2018.File) -> files[fileId],REF_5(string) -> REF_4.md5,REF_5(string) (->files) := _md5(string),REF_6(Voting2018.File) -> files[fileId],REF_7(string) -> REF_6.sha256,REF_7(string) (->files) := _sha256(string),REF_8(Voting2018.File) -> files[fileId],REF_9(string) -> REF_8.sha1,REF_9(string) (->files) := _sha1(string),REF_10(Voting2018.File) -> files[fileId],REF_11(string) -> REF_10.hashTime,REF_11(string) (->files) := _time(string),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: IF 1

EXPRESSION:
fileId < files.length

IRs:
REF_0 -> LENGTH files
TMP_2(bool) = fileId < REF_0
CONDITION TMP_2""];
1->2[label=""True""];
1->9[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
hashTimeEmptyTest = bytes(files[fileId].hashTime)

IRs:
REF_1(Voting2018.File) -> files[fileId]
REF_2(string) -> REF_1.hashTime
TMP_3 = CONVERT REF_2 to bytes
hashTimeEmptyTest(bytes) := TMP_3(bytes)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
hashTimeEmptyTest.length == 0

IRs:
REF_3 -> LENGTH hashTimeEmptyTest
TMP_4(bool) = REF_3 == 0
CONDITION TMP_4""];
3->4[label=""True""];
3->8[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
files[fileId].md5 = _md5

IRs:
REF_4(Voting2018.File) -> files[fileId]
REF_5(string) -> REF_4.md5
REF_5(string) (->files) := _md5(string)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
files[fileId].sha256 = _sha256

IRs:
REF_6(Voting2018.File) -> files[fileId]
REF_7(string) -> REF_6.sha256
REF_7(string) (->files) := _sha256(string)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
files[fileId].sha1 = _sha1

IRs:
REF_8(Voting2018.File) -> files[fileId]
REF_9(string) -> REF_8.sha1
REF_9(string) (->files) := _sha1(string)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
files[fileId].hashTime = _time

IRs:
REF_10(Voting2018.File) -> files[fileId]
REF_11(string) -> REF_10.hashTime
REF_11(string) (->files) := _time(string)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
10->1;
}
",0,1,0,0,onlyOwner();fileId < files.length;hashTimeEmptyTest = bytes(files[fileId].hashTime);;hashTimeEmptyTest.length == 0;files[fileId].md5 = _md5;;files[fileId].sha256 = _sha256;files[fileId].sha1 = _sha1;files[fileId].hashTime = _time
./0x30dc851be3c09af90c0c8a9dfdd7db85b9d8b304_ext.sol,Fpgcchain.burn,126,132,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x1d8ed4b0a3147ed17ea09582b46e0c9635396720_ext.sol,TokenERC20.burnFrom,155,163,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x70bf9df6967dc96156e76cc43b928a7ef02e159a_ext.sol,X_GAME.StartGame,22,32,"TMP_7(bool) = responseHash == 0,CONDITION TMP_7,TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response),responseHash(bytes32) := TMP_8(bytes32),question(string) := _question(string),questionSender(address) := msg.sender(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
responseHash == 0x0

IRs:
TMP_7(bool) = responseHash == 0
CONDITION TMP_7""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
responseHash = keccak256()(_response)

IRs:
TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response)
responseHash(bytes32) := TMP_8(bytes32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
questionSender = msg.sender

IRs:
questionSender(address) := msg.sender(address)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,1,0,0,responseHash == 0x0;responseHash = keccak256()(_response);;question = _question;questionSender = msg.sender
./0x656038e97cee7c095673f7b9fad695b323a6f098_ext.sol,WheelOf0xBitcoin._finishSpin,421,480,"REF_39(WheelOf0xBitcoin.playerSpin) -> playerSpins[_customerAddress],spin(WheelOf0xBitcoin.playerSpin) := REF_39(WheelOf0xBitcoin.playerSpin),REF_40(uint48) -> spin.blockNum,TMP_144(bool) = block.number != REF_40,TMP_145(None) = SOLIDITY_CALL require(bool)(TMP_144),REF_41(uint48) -> spin.blockNum,TMP_146(uint256) = block.number - REF_41,TMP_147(bool) = TMP_146 > 255,CONDITION TMP_147,resultNum(uint256) := 80(uint256),result(uint256) := 9(uint256),RETURN resultNum,REF_42(uint48) -> spin.blockNum,TMP_148(uint256) = INTERNAL_CALL, WheelOf0xBitcoin.random(uint256,uint256,address)(80,REF_42,_customerAddress),resultNum(uint256) := TMP_148(uint256),TMP_149(uint256) = INTERNAL_CALL, WheelOf0xBitcoin.determinePrize(uint256)(resultNum),result(uint256) := TMP_149(uint256),REF_43(uint256) -> spin.betAmount,betAmount(uint256) := REF_43(uint256),TMP_150(bool) = result < 5,CONDITION TMP_150,TMP_151(bool) = result == 0,CONDITION TMP_151,TMP_152(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['betAmount', '9'] ,TMP_153(uint256) = TMP_152 / 10,wonAmount(uint256) := TMP_153(uint256),TMP_154(bool) = result == 1,CONDITION TMP_154,TMP_155(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['betAmount', '8'] ,TMP_156(uint256) = TMP_155 / 10,wonAmount(uint256) := TMP_156(uint256),TMP_157(bool) = result == 2,CONDITION TMP_157,TMP_158(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['betAmount', '7'] ,TMP_159(uint256) = TMP_158 / 10,wonAmount(uint256) := TMP_159(uint256),TMP_160(bool) = result == 3,CONDITION TMP_160,TMP_161(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['betAmount', '6'] ,TMP_162(uint256) = TMP_161 / 10,wonAmount(uint256) := TMP_162(uint256),TMP_163(bool) = result == 4,CONDITION TMP_163,TMP_164(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['betAmount', '3'] ,TMP_165(uint256) = TMP_164 / 10,wonAmount(uint256) := TMP_165(uint256),TMP_166(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['betAmount', 'wonAmount'] ,returnedAmount(uint256) := TMP_166(uint256),TMP_167(bool) = result == 5,CONDITION TMP_167,returnedAmount(uint256) := betAmount(uint256),TMP_168(bool) = result == 6,CONDITION TMP_168,TMP_169(uint256) = betAmount / 10,lostAmount(uint256) := TMP_169(uint256),TMP_170(bool) = result == 7,CONDITION TMP_170,TMP_171(uint256) = betAmount / 4,lostAmount(uint256) := TMP_171(uint256),TMP_172(bool) = result == 8,CONDITION TMP_172,TMP_173(uint256) = betAmount / 2,lostAmount(uint256) := TMP_173(uint256),TMP_174(bool) = result == 9,CONDITION TMP_174,lostAmount(uint256) := betAmount(uint256),TMP_175(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['betAmount', 'lostAmount'] ,returnedAmount(uint256) := TMP_175(uint256),TMP_176(bool) = returnedAmount > 0,CONDITION TMP_176,INTERNAL_CALL, WheelOf0xBitcoin.win(address,uint256)(_customerAddress,returnedAmount),TMP_178(uint256) = INTERNAL_CALL, WheelOf0xBitcoin.tokenBalanceOf(address)(_customerAddress),newBal(uint256) := TMP_178(uint256),Emit spinResult(_customerAddress,resultNum,result,betAmount,returnedAmount,newBal,now),REF_51(WheelOf0xBitcoin.playerSpin) -> playerSpins[_customerAddress],TMP_180 = CONVERT 0 to uint256,TMP_181 = CONVERT 0 to uint48,TMP_182(WheelOf0xBitcoin.playerSpin) = new playerSpin(TMP_180,TMP_181),REF_51(WheelOf0xBitcoin.playerSpin) (->playerSpins) := TMP_182(WheelOf0xBitcoin.playerSpin),RETURN resultNum,RETURN resultNum","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spin = playerSpins[_customerAddress]

IRs:
REF_39(WheelOf0xBitcoin.playerSpin) -> playerSpins[_customerAddress]
spin(WheelOf0xBitcoin.playerSpin) := REF_39(WheelOf0xBitcoin.playerSpin)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(block.number != spin.blockNum)

IRs:
REF_40(uint48) -> spin.blockNum
TMP_144(bool) = block.number != REF_40
TMP_145(None) = SOLIDITY_CALL require(bool)(TMP_144)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
block.number - spin.blockNum > 255

IRs:
REF_41(uint48) -> spin.blockNum
TMP_146(uint256) = block.number - REF_41
TMP_147(bool) = TMP_146 > 255
CONDITION TMP_147""];
4->5[label=""True""];
4->8[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
resultNum = 80

IRs:
resultNum(uint256) := 80(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
result = 9

IRs:
result(uint256) := 9(uint256)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
resultNum

IRs:
RETURN resultNum""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
resultNum = random(80,spin.blockNum,_customerAddress)

IRs:
REF_42(uint48) -> spin.blockNum
TMP_148(uint256) = INTERNAL_CALL, WheelOf0xBitcoin.random(uint256,uint256,address)(80,REF_42,_customerAddress)
resultNum(uint256) := TMP_148(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
result = determinePrize(resultNum)

IRs:
TMP_149(uint256) = INTERNAL_CALL, WheelOf0xBitcoin.determinePrize(uint256)(resultNum)
result(uint256) := TMP_149(uint256)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
betAmount = spin.betAmount

IRs:
REF_43(uint256) -> spin.betAmount
betAmount(uint256) := REF_43(uint256)""];
11->12;
12[label=""Node Type: NEW VARIABLE 12
""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
result < 5

IRs:
TMP_150(bool) = result < 5
CONDITION TMP_150""];
13->14[label=""True""];
13->31[label=""False""];
14[label=""Node Type: NEW VARIABLE 14
""];
14->15;
15[label=""Node Type: IF 15

EXPRESSION:
result == 0

IRs:
TMP_151(bool) = result == 0
CONDITION TMP_151""];
15->16[label=""True""];
15->17[label=""False""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
wonAmount = betAmount.mul(9) / 10

IRs:
TMP_152(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['betAmount', '9'] 
TMP_153(uint256) = TMP_152 / 10
wonAmount(uint256) := TMP_153(uint256)""];
16->29;
17[label=""Node Type: IF 17

EXPRESSION:
result == 1

IRs:
TMP_154(bool) = result == 1
CONDITION TMP_154""];
17->18[label=""True""];
17->19[label=""False""];
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
wonAmount = betAmount.mul(8) / 10

IRs:
TMP_155(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['betAmount', '8'] 
TMP_156(uint256) = TMP_155 / 10
wonAmount(uint256) := TMP_156(uint256)""];
18->28;
19[label=""Node Type: IF 19

EXPRESSION:
result == 2

IRs:
TMP_157(bool) = result == 2
CONDITION TMP_157""];
19->20[label=""True""];
19->21[label=""False""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
wonAmount = betAmount.mul(7) / 10

IRs:
TMP_158(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['betAmount', '7'] 
TMP_159(uint256) = TMP_158 / 10
wonAmount(uint256) := TMP_159(uint256)""];
20->27;
21[label=""Node Type: IF 21

EXPRESSION:
result == 3

IRs:
TMP_160(bool) = result == 3
CONDITION TMP_160""];
21->22[label=""True""];
21->23[label=""False""];
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
wonAmount = betAmount.mul(6) / 10

IRs:
TMP_161(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['betAmount', '6'] 
TMP_162(uint256) = TMP_161 / 10
wonAmount(uint256) := TMP_162(uint256)""];
22->26;
23[label=""Node Type: IF 23

EXPRESSION:
result == 4

IRs:
TMP_163(bool) = result == 4
CONDITION TMP_163""];
23->24[label=""True""];
23->25[label=""False""];
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
wonAmount = betAmount.mul(3) / 10

IRs:
TMP_164(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['betAmount', '3'] 
TMP_165(uint256) = TMP_164 / 10
wonAmount(uint256) := TMP_165(uint256)""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->26;
26[label=""Node Type: END_IF 26
""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: END_IF 29
""];
29->30;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
returnedAmount = betAmount.add(wonAmount)

IRs:
TMP_166(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['betAmount', 'wonAmount'] 
returnedAmount(uint256) := TMP_166(uint256)""];
30->48;
31[label=""Node Type: IF 31

EXPRESSION:
result == 5

IRs:
TMP_167(bool) = result == 5
CONDITION TMP_167""];
31->32[label=""True""];
31->33[label=""False""];
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
returnedAmount = betAmount

IRs:
returnedAmount(uint256) := betAmount(uint256)""];
32->47;
33[label=""Node Type: NEW VARIABLE 33
""];
33->34;
34[label=""Node Type: IF 34

EXPRESSION:
result == 6

IRs:
TMP_168(bool) = result == 6
CONDITION TMP_168""];
34->35[label=""True""];
34->36[label=""False""];
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
lostAmount = betAmount / 10

IRs:
TMP_169(uint256) = betAmount / 10
lostAmount(uint256) := TMP_169(uint256)""];
35->45;
36[label=""Node Type: IF 36

EXPRESSION:
result == 7

IRs:
TMP_170(bool) = result == 7
CONDITION TMP_170""];
36->37[label=""True""];
36->38[label=""False""];
37[label=""Node Type: EXPRESSION 37

EXPRESSION:
lostAmount = betAmount / 4

IRs:
TMP_171(uint256) = betAmount / 4
lostAmount(uint256) := TMP_171(uint256)""];
37->44;
38[label=""Node Type: IF 38

EXPRESSION:
result == 8

IRs:
TMP_172(bool) = result == 8
CONDITION TMP_172""];
38->39[label=""True""];
38->40[label=""False""];
39[label=""Node Type: EXPRESSION 39

EXPRESSION:
lostAmount = betAmount / 2

IRs:
TMP_173(uint256) = betAmount / 2
lostAmount(uint256) := TMP_173(uint256)""];
39->43;
40[label=""Node Type: IF 40

EXPRESSION:
result == 9

IRs:
TMP_174(bool) = result == 9
CONDITION TMP_174""];
40->41[label=""True""];
40->42[label=""False""];
41[label=""Node Type: EXPRESSION 41

EXPRESSION:
lostAmount = betAmount

IRs:
lostAmount(uint256) := betAmount(uint256)""];
41->42;
42[label=""Node Type: END_IF 42
""];
42->43;
43[label=""Node Type: END_IF 43
""];
43->44;
44[label=""Node Type: END_IF 44
""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->46;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
returnedAmount = betAmount.sub(lostAmount)

IRs:
TMP_175(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['betAmount', 'lostAmount'] 
returnedAmount(uint256) := TMP_175(uint256)""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: IF 49

EXPRESSION:
returnedAmount > 0

IRs:
TMP_176(bool) = returnedAmount > 0
CONDITION TMP_176""];
49->50[label=""True""];
49->51[label=""False""];
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
win(_customerAddress,returnedAmount)

IRs:
INTERNAL_CALL, WheelOf0xBitcoin.win(address,uint256)(_customerAddress,returnedAmount)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: NEW VARIABLE 52

EXPRESSION:
newBal = tokenBalanceOf(_customerAddress)

IRs:
TMP_178(uint256) = INTERNAL_CALL, WheelOf0xBitcoin.tokenBalanceOf(address)(_customerAddress)
newBal(uint256) := TMP_178(uint256)""];
52->53;
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
spinResult(_customerAddress,resultNum,result,betAmount,returnedAmount,newBal,now)

IRs:
Emit spinResult(_customerAddress,resultNum,result,betAmount,returnedAmount,newBal,now)""];
53->54;
54[label=""Node Type: EXPRESSION 54

EXPRESSION:
playerSpins[_customerAddress] = playerSpin(uint256(0),uint48(0))

IRs:
REF_51(WheelOf0xBitcoin.playerSpin) -> playerSpins[_customerAddress]
TMP_180 = CONVERT 0 to uint256
TMP_181 = CONVERT 0 to uint48
TMP_182(WheelOf0xBitcoin.playerSpin) = new playerSpin(TMP_180,TMP_181)
REF_51(WheelOf0xBitcoin.playerSpin) (->playerSpins) := TMP_182(WheelOf0xBitcoin.playerSpin)""];
54->55;
55[label=""Node Type: RETURN 55

EXPRESSION:
resultNum

IRs:
RETURN resultNum""];
56[label=""Node Type: RETURN 56

EXPRESSION:
resultNum

IRs:
RETURN resultNum""];
}
",0,1,0,0,"spin = playerSpins[_customerAddress];require(bool)(block.number != spin.blockNum);;block.number - spin.blockNum > 255;resultNum = 80;resultNum = random(80,spin.blockNum,_customerAddress);result = 9;resultNum;result = determinePrize(resultNum);;betAmount = spin.betAmount;;result < 5;;result == 5;result == 0;wonAmount = betAmount.mul(9) / 10;result == 1;;wonAmount = betAmount.mul(8) / 10;result == 2;;wonAmount = betAmount.mul(7) / 10;result == 3;;wonAmount = betAmount.mul(6) / 10;result == 4;;wonAmount = betAmount.mul(3) / 10;;returnedAmount = betAmount.add(wonAmount);;returnedAmount = betAmount;;;result == 6;lostAmount = betAmount / 10;result == 7;;lostAmount = betAmount / 4;result == 8;;lostAmount = betAmount / 2;result == 9;;lostAmount = betAmount;;returnedAmount = betAmount.sub(lostAmount);returnedAmount > 0;win(_customerAddress,returnedAmount);;newBal = tokenBalanceOf(_customerAddress);spinResult(_customerAddress,resultNum,result,betAmount,returnedAmount,newBal,now);playerSpins[_customerAddress] = playerSpin(uint256(0),uint48(0));resultNum;resultNum"
./0x295b52907435bfa10e6edaa7d11d976e6e97ca1e_ext.sol,LiteCoinW_Plus.distributeLCWP,74,80,"i(uint256) := 0(uint256),REF_1 -> LENGTH addresses,TMP_2(bool) = i < REF_1,CONDITION TMP_2,REF_2(uint256) -> balances[owner],REF_2(-> balances) = REF_2 - _value,REF_3(address) -> addresses[i],REF_4(uint256) -> balances[REF_3],REF_4(-> balances) = REF_4 + _value,REF_5(address) -> addresses[i],Emit Transfer(owner,REF_5,_value),TMP_4(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, LiteCoinW_Plus.onlyOwner()(),MODIFIER_CALL, LiteCoinW_Plus.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addresses.length

IRs:
REF_1 -> LENGTH addresses
TMP_2(bool) = i < REF_1
CONDITION TMP_2""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[owner] -= _value

IRs:
REF_2(uint256) -> balances[owner]
REF_2(-> balances) = REF_2 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[addresses[i]] += _value

IRs:
REF_3(address) -> addresses[i]
REF_4(uint256) -> balances[REF_3]
REF_4(-> balances) = REF_4 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(owner,addresses[i],_value)

IRs:
REF_5(address) -> addresses[i]
Emit Transfer(owner,REF_5,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_4(uint256) := i(uint256)
i(uint256) = i + 1""];
8->4;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, LiteCoinW_Plus.onlyOwner()()""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, LiteCoinW_Plus.canDistr()()""];
10->3;
}
",0,1,0,0,"onlyOwner();;i < addresses.length;;i = 0;balances[owner] -= _value;balances[addresses[i]] += _value;Transfer(owner,addresses[i],_value);i ++;canDistr()"
./0x4b57471c5cf63b747e111bf9bd6f79e8aa6996f8_ext.sol,COSHATokenHKD.burnFrom,146,154,"REF_19(uint256) -> balanceOf[_from],TMP_27(bool) = REF_19 >= _value,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_29(bool) = _value <= REF_21,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_27(bool) = REF_19 >= _value
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_29(bool) = _value <= REF_21
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x4afea0f1252335e5e6be870139de87725e16560b_ext.sol,NatminToken.symbol,132,134,RETURN _symbol,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_symbol

IRs:
RETURN _symbol""];
}
",0,1,0,0,_symbol
./0x41e50bb0dfd21cd201b16a3d2f945920675a4408_ext.sol,ERC20Impl.batchTransfer,431,453,"REF_60 -> LENGTH _tos,REF_61 -> LENGTH _values,TMP_186(bool) = REF_60 == REF_61,TMP_187(None) = SOLIDITY_CALL require(bool)(TMP_186),REF_62 -> LENGTH _tos,numTransfers(uint256) := REF_62(uint256),TMP_188(uint256) = HIGH_LEVEL_CALL, dest:erc20Store(ERC20Store), function:balances, arguments:['msg.sender']  ,senderBalance(uint256) := TMP_188(uint256),i(uint256) := 0(uint256),TMP_189(bool) = i < numTransfers,CONDITION TMP_189,REF_64(address) -> _tos[i],to(address) := REF_64(address),TMP_190 = CONVERT 0 to address,TMP_191(bool) = to != TMP_190,TMP_192(None) = SOLIDITY_CALL require(bool)(TMP_191),REF_65(uint256) -> _values[i],v(uint256) := REF_65(uint256),TMP_193(bool) = senderBalance >= v,TMP_194(None) = SOLIDITY_CALL require(bool)(TMP_193),TMP_195(bool) = msg.sender != to,CONDITION TMP_195,senderBalance(uint256) = senderBalance - v,HIGH_LEVEL_CALL, dest:erc20Store(ERC20Store), function:addBalance, arguments:['to', 'v']  ,HIGH_LEVEL_CALL, dest:erc20Proxy(ERC20Proxy), function:emitTransfer, arguments:['msg.sender', 'to', 'v']  ,TMP_198(uint256) := i(uint256),i(uint256) = i + 1,HIGH_LEVEL_CALL, dest:erc20Store(ERC20Store), function:setBalance, arguments:['msg.sender', 'senderBalance']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_tos.length == _values.length)

IRs:
REF_60 -> LENGTH _tos
REF_61 -> LENGTH _values
TMP_186(bool) = REF_60 == REF_61
TMP_187(None) = SOLIDITY_CALL require(bool)(TMP_186)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
numTransfers = _tos.length

IRs:
REF_62 -> LENGTH _tos
numTransfers(uint256) := REF_62(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
senderBalance = erc20Store.balances(msg.sender)

IRs:
TMP_188(uint256) = HIGH_LEVEL_CALL, dest:erc20Store(ERC20Store), function:balances, arguments:['msg.sender']  
senderBalance(uint256) := TMP_188(uint256)""];
3->6;
4[label=""Node Type: BEGIN_LOOP 4
""];
4->7;
5[label=""Node Type: END_LOOP 5
""];
5->18;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
6->4;
7[label=""Node Type: IF_LOOP 7

EXPRESSION:
i < numTransfers

IRs:
TMP_189(bool) = i < numTransfers
CONDITION TMP_189""];
7->8[label=""True""];
7->5[label=""False""];
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
to = _tos[i]

IRs:
REF_64(address) -> _tos[i]
to(address) := REF_64(address)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(to != address(0))

IRs:
TMP_190 = CONVERT 0 to address
TMP_191(bool) = to != TMP_190
TMP_192(None) = SOLIDITY_CALL require(bool)(TMP_191)""];
9->10;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
v = _values[i]

IRs:
REF_65(uint256) -> _values[i]
v(uint256) := REF_65(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
require(bool)(senderBalance >= v)

IRs:
TMP_193(bool) = senderBalance >= v
TMP_194(None) = SOLIDITY_CALL require(bool)(TMP_193)""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
msg.sender != to

IRs:
TMP_195(bool) = msg.sender != to
CONDITION TMP_195""];
12->13[label=""True""];
12->15[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
senderBalance -= v

IRs:
senderBalance(uint256) = senderBalance - v""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
erc20Store.addBalance(to,v)

IRs:
HIGH_LEVEL_CALL, dest:erc20Store(ERC20Store), function:addBalance, arguments:['to', 'v']  ""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
erc20Proxy.emitTransfer(msg.sender,to,v)

IRs:
HIGH_LEVEL_CALL, dest:erc20Proxy(ERC20Proxy), function:emitTransfer, arguments:['msg.sender', 'to', 'v']  ""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
i ++

IRs:
TMP_198(uint256) := i(uint256)
i(uint256) = i + 1""];
17->7;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
erc20Store.setBalance(msg.sender,senderBalance)

IRs:
HIGH_LEVEL_CALL, dest:erc20Store(ERC20Store), function:setBalance, arguments:['msg.sender', 'senderBalance']  ""];
18->19;
19[label=""Node Type: RETURN 19

EXPRESSION:
true

IRs:
RETURN True""];
20[label=""Node Type: RETURN 20

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(_tos.length == _values.length);numTransfers = _tos.length;senderBalance = erc20Store.balances(msg.sender);i = 0;;i < numTransfers;;erc20Store.setBalance(msg.sender,senderBalance);to = _tos[i];require(bool)(to != address(0));v = _values[i];require(bool)(senderBalance >= v);msg.sender != to;senderBalance -= v;;erc20Store.addBalance(to,v);erc20Proxy.emitTransfer(msg.sender,to,v);i ++;true;success"
./0x3693c8bf129116bf3b3244404e9b8f0e26b40749_ext.sol,StandardToken.transferFrom,56,66,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x1dc8c35fa368f6ec96e9b95d8c47834e20576cd6_ext.sol,HECFinalToken.burnFrom,135,143,"REF_21(uint256) -> balanceOf[_from],TMP_87(bool) = REF_21 >= _value,TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87),REF_22(mapping(address => uint256)) -> allowance[_from],REF_23(uint256) -> REF_22[msg.sender],TMP_89(bool) = _value <= REF_23,TMP_90(None) = SOLIDITY_CALL require(bool)(TMP_89),REF_24(uint256) -> balanceOf[_from],REF_24(-> balanceOf) = REF_24 - _value,REF_25(mapping(address => uint256)) -> allowance[_from],REF_26(uint256) -> REF_25[msg.sender],REF_26(-> allowance) = REF_26 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_21(uint256) -> balanceOf[_from]
TMP_87(bool) = REF_21 >= _value
TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_22(mapping(address => uint256)) -> allowance[_from]
REF_23(uint256) -> REF_22[msg.sender]
TMP_89(bool) = _value <= REF_23
TMP_90(None) = SOLIDITY_CALL require(bool)(TMP_89)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_24(uint256) -> balanceOf[_from]
REF_24(-> balanceOf) = REF_24 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_25(mapping(address => uint256)) -> allowance[_from]
REF_26(uint256) -> REF_25[msg.sender]
REF_26(-> allowance) = REF_26 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xb462d45329f4f3b4c670790ac355fb26eace41c8_ext.sol,TerraformReserve.lockMana,120,128,"TMP_25(None) = SOLIDITY_CALL require(bool)(acceptingDeposits),TMP_26(uint256) = 1000 * 1000000000000000000,TMP_27(bool) = mana >= TMP_26,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),TMP_29(bool) = HIGH_LEVEL_CALL, dest:manaToken(ERC20), function:transferFrom, arguments:['_from', 'this', 'mana']  ,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),REF_2(uint256) -> lockedBalance[_from],REF_2(-> lockedBalance) = REF_2 + mana,totalLocked(uint256) = totalLocked + mana,Emit LockedBalance(_from,mana)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(acceptingDeposits)

IRs:
TMP_25(None) = SOLIDITY_CALL require(bool)(acceptingDeposits)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(mana >= 1000 * 1e18)

IRs:
TMP_26(uint256) = 1000 * 1000000000000000000
TMP_27(bool) = mana >= TMP_26
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(manaToken.transferFrom(_from,this,mana))

IRs:
TMP_29(bool) = HIGH_LEVEL_CALL, dest:manaToken(ERC20), function:transferFrom, arguments:['_from', 'this', 'mana']  
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
lockedBalance[_from] += mana

IRs:
REF_2(uint256) -> lockedBalance[_from]
REF_2(-> lockedBalance) = REF_2 + mana""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalLocked += mana

IRs:
totalLocked(uint256) = totalLocked + mana""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
LockedBalance(_from,mana)

IRs:
Emit LockedBalance(_from,mana)""];
}
",1,1,0,0,"require(bool)(acceptingDeposits);require(bool)(mana >= 1000 * 1e18);require(bool)(manaToken.transferFrom(_from,this,mana));lockedBalance[_from] += mana;totalLocked += mana;LockedBalance(_from,mana)"
./0x88496dd0bb932b060e9c7c4ddc8e1b72b1e39451_ext.sol,tokenTrust.fallback,14,17,"REF_0(uint256) -> hodlers[msg.sender],REF_0(-> hodlers) = REF_0 + msg.value,Emit Hodl(msg.sender,msg.value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
hodlers[msg.sender] += msg.value

IRs:
REF_0(uint256) -> hodlers[msg.sender]
REF_0(-> hodlers) = REF_0 + msg.value""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Hodl(msg.sender,msg.value)

IRs:
Emit Hodl(msg.sender,msg.value)""];
}
",0,1,0,0,"hodlers[msg.sender] += msg.value;Hodl(msg.sender,msg.value)"
./0x6c3d74c06f5b41ee0427504a4c9abb78db7e1ef6_ext.sol,TokenERC20.burn,146,152,"REF_17(uint256) -> balanceOf[msg.sender],TMP_25(bool) = REF_17 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_25(bool) = REF_17 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xc0ffeee61948d8993864a73a099c0e38d887d3f4_ext.sol,MultiSigTokenWallet.setTokenList,172,176,"tokens(address[]) := _tokenList(address[]),MODIFIER_CALL, MultiSigTokenWallet.onlyWallet()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
tokens = _tokenList

IRs:
tokens(address[]) := _tokenList(address[])""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyWallet()

IRs:
MODIFIER_CALL, MultiSigTokenWallet.onlyWallet()()""];
2->1;
}
",0,1,0,0,onlyWallet();tokens = _tokenList
./0x78af82f8924f99cec0afef357105382b8a44708f_ext.sol,EraTokens.BurnToken,194,203,"TMP_45(bool) = owner == msg.sender,TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45),REF_28(uint256) -> balances[_from],TMP_47(bool) = REF_28 > 0,TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47),REF_29(uint256) -> balances[_from],_value(uint256) := REF_29(uint256),REF_30(uint256) -> balances[_from],REF_30(-> balances) = REF_30 - _value,_totalSupply(uint256) = _totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(owner == msg.sender)

IRs:
TMP_45(bool) = owner == msg.sender
TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] > 0)

IRs:
REF_28(uint256) -> balances[_from]
TMP_47(bool) = REF_28 > 0
TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
_value = balances[_from]

IRs:
REF_29(uint256) -> balances[_from]
_value(uint256) := REF_29(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] -= _value

IRs:
REF_30(uint256) -> balances[_from]
REF_30(-> balances) = REF_30 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_totalSupply -= _value

IRs:
_totalSupply(uint256) = _totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(owner == msg.sender);require(bool)(balances[_from] > 0);_value = balances[_from];balances[_from] -= _value;_totalSupply -= _value;Burn(_from,_value);true;success"
./0x1c040c4ab9acce984d0d4c135576598013950e52_ext.sol,HurricaneNetwork.burnFrom,142,150,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x1c040c4ab9acce984d0d4c135576598013950e52_ext.sol,HurricaneNetwork.burnFrom,142,150,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xf4ada683181837c150cd0c33881dd874230eb5ae_ext.sol,BaseToken._transfer,15,24,"TMP_0(bool) = _to != 0,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_0(uint256) -> balanceOf[_from],TMP_2(bool) = REF_0 >= _value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_1(uint256) -> balanceOf[_to],TMP_4(uint256) = REF_1 + _value,REF_2(uint256) -> balanceOf[_to],TMP_5(bool) = TMP_4 > REF_2,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_3(uint256) -> balanceOf[_from],REF_4(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_3 + REF_4,previousBalances(uint256) := TMP_7(uint256),REF_5(uint256) -> balanceOf[_from],REF_5(-> balanceOf) = REF_5 - _value,REF_6(uint256) -> balanceOf[_to],REF_6(-> balanceOf) = REF_6 + _value,REF_7(uint256) -> balanceOf[_from],REF_8(uint256) -> balanceOf[_to],TMP_8(uint256) = REF_7 + REF_8,TMP_9(bool) = TMP_8 == previousBalances,TMP_10(None) = SOLIDITY_CALL assert(bool)(TMP_9),Emit Transfer(_from,_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_0(bool) = _to != 0
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_0(uint256) -> balanceOf[_from]
TMP_2(bool) = REF_0 >= _value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value > balanceOf[_to])

IRs:
REF_1(uint256) -> balanceOf[_to]
TMP_4(uint256) = REF_1 + _value
REF_2(uint256) -> balanceOf[_to]
TMP_5(bool) = TMP_4 > REF_2
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_3(uint256) -> balanceOf[_from]
REF_4(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_3 + REF_4
previousBalances(uint256) := TMP_7(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_5(uint256) -> balanceOf[_from]
REF_5(-> balanceOf) = REF_5 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_6(uint256) -> balanceOf[_to]
REF_6(-> balanceOf) = REF_6 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_7(uint256) -> balanceOf[_from]
REF_8(uint256) -> balanceOf[_to]
TMP_8(uint256) = REF_7 + REF_8
TMP_9(bool) = TMP_8 == previousBalances
TMP_10(None) = SOLIDITY_CALL assert(bool)(TMP_9)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value > balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances);Transfer(_from,_to,_value)"
./0xef906c48b8fde48f5f2ceb448b1163bf964ef4ac_ext.sol,DAX_4000_20200618.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x0704d3952dc50e8a36a8cb53f84d8c39895cd5cf_ext.sol,MagicCube.burn,117,123,"REF_14(uint256) -> balanceOf[msg.sender],TMP_67(bool) = REF_14 >= _value,TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67),REF_15(uint256) -> balanceOf[msg.sender],REF_15(-> balanceOf) = REF_15 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,MODIFIER_CALL, MagicCube.onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_14(uint256) -> balanceOf[msg.sender]
TMP_67(bool) = REF_14 >= _value
TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_15(uint256) -> balanceOf[msg.sender]
REF_15(-> balanceOf) = REF_15 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MagicCube.onlyOwner()()""];
6->1;
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"onlyOwner();require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xa3fa17c51a77a79808f3c21948de3ea70391ce6a_ext.sol,CryptoAllStars._transfer,358,373,"REF_41(uint256) -> ownershipTokenCount[_to],TMP_95(uint256) := REF_41(uint256),REF_41(-> ownershipTokenCount) = REF_41 + 1,REF_42(address) -> personIndexToOwner[_tokenId],REF_42(address) (->personIndexToOwner) := _to(address),TMP_96 = CONVERT 0 to address,TMP_97(bool) = _from != TMP_96,CONDITION TMP_97,REF_43(uint256) -> ownershipTokenCount[_from],TMP_98(uint256) := REF_43(uint256),REF_43(-> ownershipTokenCount) = REF_43 - 1,REF_44(address) -> personIndexToApproved[_tokenId],personIndexToApproved = delete REF_44 ,Emit Transfer(_from,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownershipTokenCount[_to] ++

IRs:
REF_41(uint256) -> ownershipTokenCount[_to]
TMP_95(uint256) := REF_41(uint256)
REF_41(-> ownershipTokenCount) = REF_41 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
personIndexToOwner[_tokenId] = _to

IRs:
REF_42(address) -> personIndexToOwner[_tokenId]
REF_42(address) (->personIndexToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_96 = CONVERT 0 to address
TMP_97(bool) = _from != TMP_96
CONDITION TMP_97""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownershipTokenCount[_from] --

IRs:
REF_43(uint256) -> ownershipTokenCount[_from]
TMP_98(uint256) := REF_43(uint256)
REF_43(-> ownershipTokenCount) = REF_43 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete personIndexToApproved[_tokenId]

IRs:
REF_44(address) -> personIndexToApproved[_tokenId]
personIndexToApproved = delete REF_44 ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
}
",0,1,0,0,"ownershipTokenCount[_to] ++;personIndexToOwner[_tokenId] = _to;_from != address(0);ownershipTokenCount[_from] --;;delete personIndexToApproved[_tokenId];Transfer(_from,_to,_tokenId)"
./0x0747af71e2034bc2d2fcad388a264f5ccdff505c_ext.sol,BlockVentureCoin.appendTokenHolders,187,203,"REF_3(uint256) -> balanceOf[tokenHolder],TMP_1(bool) = REF_3 == 0,CONDITION TMP_1,REF_4(address) -> accountIndex[accountCount],REF_4(address) (->accountIndex) := tokenHolder(address),TMP_2(uint256) := accountCount(uint256),accountCount(uint256) = accountCount + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balanceOf[tokenHolder] == 0

IRs:
REF_3(uint256) -> balanceOf[tokenHolder]
TMP_1(bool) = REF_3 == 0
CONDITION TMP_1""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
accountIndex[accountCount] = tokenHolder

IRs:
REF_4(address) -> accountIndex[accountCount]
REF_4(address) (->accountIndex) := tokenHolder(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
accountCount ++

IRs:
TMP_2(uint256) := accountCount(uint256)
accountCount(uint256) = accountCount + 1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,balanceOf[tokenHolder] == 0;accountIndex[accountCount] = tokenHolder;;accountCount ++
./0xebb060f9d0029082a04f78d84b9fb9d3d26f9a93_ext.sol,Data.subtrReferralDeposit,495,497,"REF_206(uint256) -> referralDeposits[_addr],REF_206(-> referralDeposits) = REF_206 - amount,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
referralDeposits[_addr] -= amount

IRs:
REF_206(uint256) -> referralDeposits[_addr]
REF_206(-> referralDeposits) = REF_206 - amount""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,1,0,0,onlyOwner();referralDeposits[_addr] -= amount
./0xc378bb8f3e155e5e561eb4caa337c4a35c34c2ba_ext.sol,TokenERC20.burn,146,152,"REF_17(uint256) -> balanceOf[msg.sender],TMP_25(bool) = REF_17 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_25(bool) = REF_17 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x6d3543d4b11683847697f5b9a3a9d116cf13dedd_ext.sol,Ledger.subtract,183,207,"TMP_42 = CONVERT 0 to address,TMP_43(bool) = _address == TMP_42,TMP_44(bool) = _amt == 0,TMP_45(bool) = TMP_43 || TMP_44,CONDITION TMP_45,REF_18(Ledger.Entry) -> entries[_address],entry(Ledger.Entry) := REF_18(Ledger.Entry),REF_19(uint256) -> entry.balance,_maxAmt(uint256) := REF_19(uint256),TMP_46(bool) = _maxAmt == 0,CONDITION TMP_46,TMP_47(bool) = _amt >= _maxAmt,CONDITION TMP_47,total(uint256) = total - _maxAmt,REF_20(address) -> entry.prev,REF_21(Ledger.Entry) -> entries[REF_20],REF_22(address) -> REF_21.next,REF_23(address) -> entry.next,REF_22(address) (->entries) := REF_23(address),REF_24(address) -> entry.next,REF_25(Ledger.Entry) -> entries[REF_24],REF_26(address) -> REF_25.prev,REF_27(address) -> entry.prev,REF_26(address) (->entries) := REF_27(address),REF_28(Ledger.Entry) -> entries[_address],entries = delete REF_28 ,RETURN _maxAmt,total(uint256) = total - _amt,REF_29(uint256) -> entry.balance,REF_29(-> entry) = REF_29 - _amt,RETURN _amt,MODIFIER_CALL, Ledger.fromOwner()(),RETURN _amtRemoved","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->19;
1[label=""Node Type: IF 1

EXPRESSION:
_address == address(0) || _amt == 0

IRs:
TMP_42 = CONVERT 0 to address
TMP_43(bool) = _address == TMP_42
TMP_44(bool) = _amt == 0
TMP_45(bool) = TMP_43 || TMP_44
CONDITION TMP_45""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
entry = entries[_address]

IRs:
REF_18(Ledger.Entry) -> entries[_address]
entry(Ledger.Entry) := REF_18(Ledger.Entry)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
_maxAmt = entry.balance

IRs:
REF_19(uint256) -> entry.balance
_maxAmt(uint256) := REF_19(uint256)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
_maxAmt == 0

IRs:
TMP_46(bool) = _maxAmt == 0
CONDITION TMP_46""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: RETURN 7
""];
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
_amt >= _maxAmt

IRs:
TMP_47(bool) = _amt >= _maxAmt
CONDITION TMP_47""];
9->10[label=""True""];
9->15[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
total -= _maxAmt

IRs:
total(uint256) = total - _maxAmt""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
entries[entry.prev].next = entry.next

IRs:
REF_20(address) -> entry.prev
REF_21(Ledger.Entry) -> entries[REF_20]
REF_22(address) -> REF_21.next
REF_23(address) -> entry.next
REF_22(address) (->entries) := REF_23(address)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
entries[entry.next].prev = entry.prev

IRs:
REF_24(address) -> entry.next
REF_25(Ledger.Entry) -> entries[REF_24]
REF_26(address) -> REF_25.prev
REF_27(address) -> entry.prev
REF_26(address) (->entries) := REF_27(address)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
delete entries[_address]

IRs:
REF_28(Ledger.Entry) -> entries[_address]
entries = delete REF_28 ""];
13->14;
14[label=""Node Type: RETURN 14

EXPRESSION:
_maxAmt

IRs:
RETURN _maxAmt""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
total -= _amt

IRs:
total(uint256) = total - _amt""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
entry.balance -= _amt

IRs:
REF_29(uint256) -> entry.balance
REF_29(-> entry) = REF_29 - _amt""];
16->17;
17[label=""Node Type: RETURN 17

EXPRESSION:
_amt

IRs:
RETURN _amt""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
fromOwner()

IRs:
MODIFIER_CALL, Ledger.fromOwner()()""];
19->1;
20[label=""Node Type: RETURN 20

EXPRESSION:
_amtRemoved

IRs:
RETURN _amtRemoved""];
}
",0,1,0,0,fromOwner();_address == address(0) || _amt == 0;;;entry = entries[_address];_maxAmt = entry.balance;_maxAmt == 0;;;_amt >= _maxAmt;total -= _maxAmt;total -= _amt;entries[entry.prev].next = entry.next;entries[entry.next].prev = entry.prev;delete entries[_address];_maxAmt;entry.balance -= _amt;_amt;_amtRemoved
./0x33bb55835499b4013686e39de293ee4d832bbca4_ext.sol,LockBalance.lockTypeInfoGroup,325,328,"TMP_170 = CONVERT _type to uint256,key(uint256) := TMP_170(uint256),REF_175(LockBalance.sGroupLockDate) -> groupLockDate[key],REF_176(uint256[]) -> REF_175.lockTime,REF_177(LockBalance.sGroupLockDate) -> groupLockDate[key],REF_178(uint256[]) -> REF_177.lockPercent,RETURN REF_176,REF_178","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
key = uint256(_type)

IRs:
TMP_170 = CONVERT _type to uint256
key(uint256) := TMP_170(uint256)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
(groupLockDate[key].lockTime,groupLockDate[key].lockPercent)

IRs:
REF_175(LockBalance.sGroupLockDate) -> groupLockDate[key]
REF_176(uint256[]) -> REF_175.lockTime
REF_177(LockBalance.sGroupLockDate) -> groupLockDate[key]
REF_178(uint256[]) -> REF_177.lockPercent
RETURN REF_176,REF_178""];
}
",0,1,0,0,"key = uint256(_type);(groupLockDate[key].lockTime,groupLockDate[key].lockPercent)"
./0x0704d3952dc50e8a36a8cb53f84d8c39895cd5cf_ext.sol,MagicCube.burn,117,123,"REF_14(uint256) -> balanceOf[msg.sender],TMP_67(bool) = REF_14 >= _value,TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67),REF_15(uint256) -> balanceOf[msg.sender],REF_15(-> balanceOf) = REF_15 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,MODIFIER_CALL, MagicCube.onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_14(uint256) -> balanceOf[msg.sender]
TMP_67(bool) = REF_14 >= _value
TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_15(uint256) -> balanceOf[msg.sender]
REF_15(-> balanceOf) = REF_15 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MagicCube.onlyOwner()()""];
6->1;
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"onlyOwner();require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x01d706ed109e2038ae3261e30a1ed1af207a9d2c_ext.sol,ETHERECASHTOKEN._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x6cb816569ab4665bdc2ba78a64aff87201608bc6_ext.sol,Bitmos.transferFrom,93,103,"REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],allowance(uint256) := REF_5(uint256),REF_6(uint256) -> balances[_from],TMP_3(bool) = REF_6 >= _value,TMP_4(bool) = allowance >= _value,TMP_5(bool) = TMP_3 && TMP_4,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_7(uint256) -> balances[_to],REF_7(-> balances) = REF_7 + _value,REF_8(uint256) -> balances[_from],REF_8(-> balances) = REF_8 - _value,TMP_7(bool) = allowance < MAX_UINT256,CONDITION TMP_7,REF_9(mapping(address => uint256)) -> allowed[_from],REF_10(uint256) -> REF_9[msg.sender],REF_10(-> allowed) = REF_10 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
allowance = allowed[_from][msg.sender]

IRs:
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
allowance(uint256) := REF_5(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] >= _value && allowance >= _value)

IRs:
REF_6(uint256) -> balances[_from]
TMP_3(bool) = REF_6 >= _value
TMP_4(bool) = allowance >= _value
TMP_5(bool) = TMP_3 && TMP_4
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_7(uint256) -> balances[_to]
REF_7(-> balances) = REF_7 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] -= _value

IRs:
REF_8(uint256) -> balances[_from]
REF_8(-> balances) = REF_8 - _value""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
allowance < MAX_UINT256

IRs:
TMP_7(bool) = allowance < MAX_UINT256
CONDITION TMP_7""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_9(mapping(address => uint256)) -> allowed[_from]
REF_10(uint256) -> REF_9[msg.sender]
REF_10(-> allowed) = REF_10 - _value""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: RETURN 10

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowance = allowed[_from][msg.sender];require(bool)(balances[_from] >= _value && allowance >= _value);balances[_to] += _value;balances[_from] -= _value;allowance < MAX_UINT256;allowed[_from][msg.sender] -= _value;;Transfer(_from,_to,_value);true;success"
./0xf208f8cdf637e49b5e6219fa76b014d49287894f_ext.sol,Gainz.paymentDue,72,75,"REF_6(uint256) -> timestamp[userAddress],TMP_5(uint256) = block.number - REF_6,blockDelta(uint256) := TMP_5(uint256),REF_7(uint256) -> balances[userAddress],TMP_6(uint256) = REF_7 * 2,TMP_7(uint256) = TMP_6 / 100,TMP_8(uint256) = TMP_7 * blockDelta,TMP_9(uint256) = TMP_8 / 6000,RETURN TMP_9","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
blockDelta = block.number - timestamp[userAddress]

IRs:
REF_6(uint256) -> timestamp[userAddress]
TMP_5(uint256) = block.number - REF_6
blockDelta(uint256) := TMP_5(uint256)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
balances[userAddress] * 2 / 100 * (blockDelta) / 6000

IRs:
REF_7(uint256) -> balances[userAddress]
TMP_6(uint256) = REF_7 * 2
TMP_7(uint256) = TMP_6 / 100
TMP_8(uint256) = TMP_7 * blockDelta
TMP_9(uint256) = TMP_8 / 6000
RETURN TMP_9""];
}
",0,1,0,0,blockDelta = block.number - timestamp[userAddress];balances[userAddress] * 2 / 100 * (blockDelta) / 6000
./0x5064ef946f91e8d94f845cf9a403acb1b9739eb2_ext.sol,TheGame.StartTheGame,20,27,"TMP_7(bool) = responseHash == 0,CONDITION TMP_7,TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response),responseHash(bytes32) := TMP_8(bytes32),question(string) := _question(string),questionSender(address) := msg.sender(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
responseHash == 0x0

IRs:
TMP_7(bool) = responseHash == 0
CONDITION TMP_7""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
responseHash = keccak256()(_response)

IRs:
TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response)
responseHash(bytes32) := TMP_8(bytes32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
questionSender = msg.sender

IRs:
questionSender(address) := msg.sender(address)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,1,0,0,responseHash == 0x0;responseHash = keccak256()(_response);;question = _question;questionSender = msg.sender
./0x77e89cb283f39ed72f4383c6eec786bd7e7c12d5_ext.sol,eBitcoinCash.distributeeBitcoinCashLarge,39,48,"i(uint256) := 0(uint256),REF_1 -> LENGTH addresses,TMP_2(bool) = i < REF_1,CONDITION TMP_2,REF_2(uint256) -> balances[owner],REF_2(-> balances) = REF_2 - 982879664000,REF_3(uint256) -> balances[owner],TMP_3(bool) = REF_3 >= 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_4(address) -> addresses[i],REF_5(uint256) -> balances[REF_4],REF_5(-> balances) = REF_5 + 982879664000,REF_6(address) -> addresses[i],Emit Transfer(owner,REF_6,982879664000),TMP_6(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, eBitcoinCash.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addresses.length

IRs:
REF_1 -> LENGTH addresses
TMP_2(bool) = i < REF_1
CONDITION TMP_2""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[owner] -= 982879664000

IRs:
REF_2(uint256) -> balances[owner]
REF_2(-> balances) = REF_2 - 982879664000""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(balances[owner] >= 0)

IRs:
REF_3(uint256) -> balances[owner]
TMP_3(bool) = REF_3 >= 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[addresses[i]] += 982879664000

IRs:
REF_4(address) -> addresses[i]
REF_5(uint256) -> balances[REF_4]
REF_5(-> balances) = REF_5 + 982879664000""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(owner,addresses[i],982879664000)

IRs:
REF_6(address) -> addresses[i]
Emit Transfer(owner,REF_6,982879664000)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_6(uint256) := i(uint256)
i(uint256) = i + 1""];
9->4;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, eBitcoinCash.onlyOwner()()""];
10->3;
}
",0,1,0,0,"onlyOwner();;i < addresses.length;;i = 0;balances[owner] -= 982879664000;require(bool)(balances[owner] >= 0);balances[addresses[i]] += 982879664000;Transfer(owner,addresses[i],982879664000);i ++"
./0x126bba3aa97d9f6e98f56705f29ab02f7660b445_ext.sol,EducationTokens.balanceOf,127,129,"REF_8(uint256) -> balances[_owner],REF_9(uint256) -> userLockedTokens[_owner],TMP_42(uint256) = REF_8 - REF_9,RETURN TMP_42,RETURN balance","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
balances[_owner] - userLockedTokens[_owner]

IRs:
REF_8(uint256) -> balances[_owner]
REF_9(uint256) -> userLockedTokens[_owner]
TMP_42(uint256) = REF_8 - REF_9
RETURN TMP_42""];
2[label=""Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance""];
}
",0,1,0,0,balances[_owner] - userLockedTokens[_owner];balance
./0xeb907a50921e052cbee233811beaf0839d2a98fd_ext.sol,Advertisement.getTotalCampaignsByCountry,227,232,"TMP_59 = CONVERT country to bytes,countryInBytes(bytes) := TMP_59(bytes),REF_58(bytes32[]) -> campaignsByCountry[countryInBytes],REF_59 -> LENGTH REF_58,RETURN REF_59","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
countryInBytes = bytes(country)

IRs:
TMP_59 = CONVERT country to bytes
countryInBytes(bytes) := TMP_59(bytes)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
campaignsByCountry[countryInBytes].length

IRs:
REF_58(bytes32[]) -> campaignsByCountry[countryInBytes]
REF_59 -> LENGTH REF_58
RETURN REF_59""];
}
",0,1,0,0,countryInBytes = bytes(country);campaignsByCountry[countryInBytes].length
./0x71a982a028c9d4b0566041a78df12b810462e155_ext.sol,TokenERC20.burnFrom,126,134,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xf12bc22c88c4c770b1e116853cc0500bb70a81ca_ext.sol,GLADLIVEToken._burn,128,131,"REF_17(uint256) -> balanceOf[_from],REF_17(-> balanceOf) = REF_17 - _value,totalSupply(uint256) = totalSupply - _value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_17(uint256) -> balanceOf[_from]
REF_17(-> balanceOf) = REF_17 - _value""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
}
",0,1,0,0,balanceOf[_from] -= _value;totalSupply -= _value
./0xaacfbd1f81351a7e748f4a4a43c31d892a33f27d_ext.sol,StandardToken.transferFrom,61,71,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x53a30b07bea5b8e9b5f710e038867a1531b0b5dc_ext.sol,Multiplexer.sendEth,13,31,"REF_0 -> LENGTH _to,REF_1 -> LENGTH _value,TMP_0(bool) = REF_0 == REF_1,TMP_1(None) = SOLIDITY_CALL assert(bool)(TMP_0),REF_2 -> LENGTH _to,TMP_2(bool) = REF_2 <= 255,TMP_3(None) = SOLIDITY_CALL assert(bool)(TMP_2),beforeValue(uint256) := msg.value(uint256),afterValue(uint256) := 0(uint256),i(uint8) := 0(uint256),REF_3 -> LENGTH _to,TMP_4(bool) = i < REF_3,CONDITION TMP_4,REF_4(uint256) -> _value[i],TMP_5(uint256) = afterValue + REF_4,afterValue(uint256) := TMP_5(uint256),REF_5(address) -> _to[i],REF_7(uint256) -> _value[i],TMP_6 = SEND dest:REF_5 value:REF_7,TMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6),TMP_8(uint8) := i(uint8),i(uint8) = i + 1,TMP_9(uint256) = beforeValue - afterValue,remainingValue(uint256) := TMP_9(uint256),TMP_10(bool) = remainingValue > 0,CONDITION TMP_10,TMP_11 = SEND dest:msg.sender value:remainingValue,TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11),RETURN True,RETURN _success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(_to.length == _value.length)

IRs:
REF_0 -> LENGTH _to
REF_1 -> LENGTH _value
TMP_0(bool) = REF_0 == REF_1
TMP_1(None) = SOLIDITY_CALL assert(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(_to.length <= 255)

IRs:
REF_2 -> LENGTH _to
TMP_2(bool) = REF_2 <= 255
TMP_3(None) = SOLIDITY_CALL assert(bool)(TMP_2)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
beforeValue = msg.value

IRs:
beforeValue(uint256) := msg.value(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
afterValue = 0

IRs:
afterValue(uint256) := 0(uint256)""];
4->7;
5[label=""Node Type: BEGIN_LOOP 5
""];
5->8;
6[label=""Node Type: END_LOOP 6
""];
6->12;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)""];
7->5;
8[label=""Node Type: IF_LOOP 8

EXPRESSION:
i < _to.length

IRs:
REF_3 -> LENGTH _to
TMP_4(bool) = i < REF_3
CONDITION TMP_4""];
8->9[label=""True""];
8->6[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
afterValue = afterValue + _value[i]

IRs:
REF_4(uint256) -> _value[i]
TMP_5(uint256) = afterValue + REF_4
afterValue(uint256) := TMP_5(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
assert(bool)(_to[i].send(_value[i]))

IRs:
REF_5(address) -> _to[i]
REF_7(uint256) -> _value[i]
TMP_6 = SEND dest:REF_5 value:REF_7
TMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_8(uint8) := i(uint8)
i(uint8) = i + 1""];
11->8;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
remainingValue = beforeValue - afterValue

IRs:
TMP_9(uint256) = beforeValue - afterValue
remainingValue(uint256) := TMP_9(uint256)""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
remainingValue > 0

IRs:
TMP_10(bool) = remainingValue > 0
CONDITION TMP_10""];
13->14[label=""True""];
13->15[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
assert(bool)(msg.sender.send(remainingValue))

IRs:
TMP_11 = SEND dest:msg.sender value:remainingValue
TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: RETURN 16

EXPRESSION:
true

IRs:
RETURN True""];
17[label=""Node Type: RETURN 17

EXPRESSION:
_success

IRs:
RETURN _success""];
}
",0,1,0,0,assert(bool)(_to.length == _value.length);assert(bool)(_to.length <= 255);beforeValue = msg.value;afterValue = 0;i = 0;;i < _to.length;;remainingValue = beforeValue - afterValue;afterValue = afterValue + _value[i];assert(bool)(_to[i].send(_value[i]));i ++;remainingValue > 0;assert(bool)(msg.sender.send(remainingValue));;true;_success
./0x0374b22e0727302e0d8db783726c7ec4989f88ad_ext.sol,GINI.approveAndCall,180,187,"TMP_90(bool) = INTERNAL_CALL, GINI.isContract(address)(_spender),TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),TMP_92 = CONVERT _spender to TokenRecipient,spender(TokenRecipient) := TMP_92(TokenRecipient),TMP_93(bool) = INTERNAL_CALL, GINI.approve(address,uint256)(_spender,_value),CONDITION TMP_93,HIGH_LEVEL_CALL, dest:spender(TokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isContract(_spender))

IRs:
TMP_90(bool) = INTERNAL_CALL, GINI.isContract(address)(_spender)
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
spender = TokenRecipient(_spender)

IRs:
TMP_92 = CONVERT _spender to TokenRecipient
spender(TokenRecipient) := TMP_92(TokenRecipient)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_93(bool) = INTERNAL_CALL, GINI.approve(address,uint256)(_spender,_value)
CONDITION TMP_93""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(TokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(isContract(_spender));spender = TokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x05dab93a76f33fdb225e0a05cafbdd41612b88b6_ext.sol,TeikhosBounty.commit,48,52,"REF_0(TeikhosBounty.Commit) -> commitment[msg.sender],REF_1(uint256) -> REF_0.timestamp,TMP_0(bool) = REF_1 == 0,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_2(TeikhosBounty.Commit) -> commitment[msg.sender],REF_3(bytes) -> REF_2.signature,REF_3(bytes) (->commitment) := _signature(bytes),REF_4(TeikhosBounty.Commit) -> commitment[msg.sender],REF_5(uint256) -> REF_4.timestamp,REF_5(uint256) (->commitment) := now(uint256),REF_6(TeikhosBounty.State) -> State.Commit,MODIFIER_CALL, TeikhosBounty.inState(TeikhosBounty.State)(REF_6)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(commitment[msg.sender].timestamp == 0)

IRs:
REF_0(TeikhosBounty.Commit) -> commitment[msg.sender]
REF_1(uint256) -> REF_0.timestamp
TMP_0(bool) = REF_1 == 0
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
commitment[msg.sender].signature = _signature

IRs:
REF_2(TeikhosBounty.Commit) -> commitment[msg.sender]
REF_3(bytes) -> REF_2.signature
REF_3(bytes) (->commitment) := _signature(bytes)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
commitment[msg.sender].timestamp = now

IRs:
REF_4(TeikhosBounty.Commit) -> commitment[msg.sender]
REF_5(uint256) -> REF_4.timestamp
REF_5(uint256) (->commitment) := now(uint256)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
inState(State.Commit)

IRs:
REF_6(TeikhosBounty.State) -> State.Commit
MODIFIER_CALL, TeikhosBounty.inState(TeikhosBounty.State)(REF_6)""];
4->1;
}
",0,1,0,0,inState(State.Commit);require(bool)(commitment[msg.sender].timestamp == 0);commitment[msg.sender].signature = _signature;commitment[msg.sender].timestamp = now
./0x69ceaea78e28d62bc1ac68491d77f6a761edce01_ext.sol,StandardToken.transferFrom,56,66,"REF_3(uint256) -> balances[_from],TMP_18(bool) = REF_3 >= _value,REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],TMP_19(bool) = REF_5 >= _value,TMP_20(bool) = TMP_18 && TMP_19,TMP_21(bool) = _value > 0,TMP_22(bool) = TMP_20 && TMP_21,CONDITION TMP_22,REF_6(uint256) -> balances[_to],REF_6(-> balances) = REF_6 + _value,REF_7(uint256) -> balances[_from],REF_7(-> balances) = REF_7 - _value,REF_8(mapping(address => uint256)) -> allowed[_from],REF_9(uint256) -> REF_8[msg.sender],REF_9(-> allowed) = REF_9 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0

IRs:
REF_3(uint256) -> balances[_from]
TMP_18(bool) = REF_3 >= _value
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
TMP_19(bool) = REF_5 >= _value
TMP_20(bool) = TMP_18 && TMP_19
TMP_21(bool) = _value > 0
TMP_22(bool) = TMP_20 && TMP_21
CONDITION TMP_22""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_6(uint256) -> balances[_to]
REF_6(-> balances) = REF_6 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_7(uint256) -> balances[_from]
REF_7(-> balances) = REF_7 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_8(mapping(address => uint256)) -> allowed[_from]
REF_9(uint256) -> REF_8[msg.sender]
REF_9(-> allowed) = REF_9 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0;balances[_to] += _value;false;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true;success"
./0x7541b76cb60f4c60af330c208b0623b7f54bf615_ext.sol,Log.AddMessage,69,77,"REF_13(address) -> LastMsg.Sender,REF_13(address) (->LastMsg) := _adr(address),REF_14(uint256) -> LastMsg.Time,REF_14(uint256) (->LastMsg) := now(uint256),REF_15(uint256) -> LastMsg.Val,REF_15(uint256) (->LastMsg) := _val(uint256),REF_16(string) -> LastMsg.Data,REF_16(string) (->LastMsg) := _data(string),REF_18 -> LENGTH History,TMP_13(uint256) := REF_18(uint256),TMP_14(uint256) = TMP_13 + 1,REF_18(uint256) (->History) := TMP_14(uint256),REF_19(Log.Message) -> History[TMP_13],REF_19(Log.Message) (->History) := LastMsg(Log.Message)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
LastMsg.Sender = _adr

IRs:
REF_13(address) -> LastMsg.Sender
REF_13(address) (->LastMsg) := _adr(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
LastMsg.Time = now

IRs:
REF_14(uint256) -> LastMsg.Time
REF_14(uint256) (->LastMsg) := now(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
LastMsg.Val = _val

IRs:
REF_15(uint256) -> LastMsg.Val
REF_15(uint256) (->LastMsg) := _val(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
LastMsg.Data = _data

IRs:
REF_16(string) -> LastMsg.Data
REF_16(string) (->LastMsg) := _data(string)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
History.push(LastMsg)

IRs:
REF_18 -> LENGTH History
TMP_13(uint256) := REF_18(uint256)
TMP_14(uint256) = TMP_13 + 1
REF_18(uint256) (->History) := TMP_14(uint256)
REF_19(Log.Message) -> History[TMP_13]
REF_19(Log.Message) (->History) := LastMsg(Log.Message)""];
}
",0,1,0,0,LastMsg.Sender = _adr;LastMsg.Time = now;LastMsg.Val = _val;LastMsg.Data = _data;History.push(LastMsg)
./0x1848df8d1728a8ce654c7faf833b2d7296744fe4_ext.sol,WorldToken.burn,81,86,"REF_19(uint256) -> balanceOf[msg.sender],TMP_29(bool) = REF_19 >= _value,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),REF_20(uint256) -> balanceOf[msg.sender],REF_20(-> balanceOf) = REF_20 - _value,REF_21(uint256) -> balanceOf[0],REF_21(-> balanceOf) = REF_21 + _value,Emit Transfer(msg.sender,0,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_19(uint256) -> balanceOf[msg.sender]
TMP_29(bool) = REF_19 >= _value
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_20(uint256) -> balanceOf[msg.sender]
REF_20(-> balanceOf) = REF_20 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[0x0] += _value

IRs:
REF_21(uint256) -> balanceOf[0]
REF_21(-> balanceOf) = REF_21 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,0x0,_value)

IRs:
Emit Transfer(msg.sender,0,_value)""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;balanceOf[0x0] += _value;Transfer(msg.sender,0x0,_value)"
./0xed04927a3849fc9db3f3341a17b7d844a6c551a8_ext.sol,CrowdInvestment.addPersonalCaps,40,45,"TMP_11(bool) = msg.sender == creator,TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11),i(uint16) := 0(uint256),REF_4 -> LENGTH investors,TMP_13(bool) = i < REF_4,CONDITION TMP_13,REF_5(address) -> investors[i],REF_6(uint256) -> additionalCaps[REF_5],REF_6(-> additionalCaps) = REF_6 + additionalCap,TMP_14(uint16) := i(uint16),i(uint16) = i + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == creator)

IRs:
TMP_11(bool) = msg.sender == creator
TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint16) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < investors.length

IRs:
REF_4 -> LENGTH investors
TMP_13(bool) = i < REF_4
CONDITION TMP_13""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
additionalCaps[investors[i]] += additionalCap

IRs:
REF_5(address) -> investors[i]
REF_6(uint256) -> additionalCaps[REF_5]
REF_6(-> additionalCaps) = REF_6 + additionalCap""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_14(uint16) := i(uint16)
i(uint16) = i + 1""];
7->5;
}
",0,1,0,0,require(bool)(msg.sender == creator);i = 0;;i < investors.length;;additionalCaps[investors[i]] += additionalCap;i ++
./0x3798b1c6e7bad3f0720c0e9ddcdb018857e13a4c_ext.sol,RareCards.totalSupply,416,418,"REF_69 -> LENGTH rareArray,TMP_105(uint256) = REF_69 - 1,RETURN TMP_105","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
rareArray.length - 1

IRs:
REF_69 -> LENGTH rareArray
TMP_105(uint256) = REF_69 - 1
RETURN TMP_105""];
}
",0,1,0,0,rareArray.length - 1
./0xced350d7ef320c38cc5090c89e7475dfd2e0fff4_ext.sol,BimuyuCoin.approveAndCall,115,120,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x899850f5b7f34d213a01802c727e7a59a88487a1_ext.sol,MessageToken.approveAndCall,49,56,"TMP_7 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_7(tokenRecipient),TMP_8(bool) = INTERNAL_CALL, MessageToken.approve(address,uint256)(_spender,_value),CONDITION TMP_8,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_7 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_7(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_8(bool) = INTERNAL_CALL, MessageToken.approve(address,uint256)(_spender,_value)
CONDITION TMP_8""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x05d2b0239e6646765865abe47a72202916caf559_ext.sol,Ethernext.burnFrom,138,146,"REF_19(uint256) -> balanceOf[_from],TMP_22(bool) = REF_19 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_24(bool) = _value <= REF_21,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_22(bool) = REF_19 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_24(bool) = _value <= REF_21
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xf04605be6f8cbf23d66533da283c816534686f80_ext.sol,StandardToken.transferFrom,56,66,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x6c91c0104677d08cded353b1459b68415f278c38_ext.sol,FastEth.getQueueLength,223,225,"REF_25 -> LENGTH queue,TMP_45(uint256) = REF_25 - currentReceiverIndex,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
queue.length - currentReceiverIndex

IRs:
REF_25 -> LENGTH queue
TMP_45(uint256) = REF_25 - currentReceiverIndex
RETURN TMP_45""];
}
",0,1,0,0,queue.length - currentReceiverIndex
./0xecfbc0c5bc5cf4a266c1a90db0a4fe79c82bcd93_ext.sol,HYIPToken.mint,370,377,"TMP_295(uint256) = totalSupply + amount,totalSupply(uint256) := TMP_295(uint256),REF_163(uint256) -> balances[receiver],REF_164(uint256) -> balances[receiver],TMP_296(uint256) = REF_164 + amount,REF_163(uint256) (->balances) := TMP_296(uint256),Emit Transfer(0,receiver,amount),MODIFIER_CALL, HYIPToken.onlyMintAgent()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
totalSupply = totalSupply + amount

IRs:
TMP_295(uint256) = totalSupply + amount
totalSupply(uint256) := TMP_295(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[receiver] = balances[receiver] + amount

IRs:
REF_163(uint256) -> balances[receiver]
REF_164(uint256) -> balances[receiver]
TMP_296(uint256) = REF_164 + amount
REF_163(uint256) (->balances) := TMP_296(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,receiver,amount)

IRs:
Emit Transfer(0,receiver,amount)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyMintAgent()

IRs:
MODIFIER_CALL, HYIPToken.onlyMintAgent()()""];
4->1;
}
",0,1,0,0,"onlyMintAgent();totalSupply = totalSupply + amount;balances[receiver] = balances[receiver] + amount;Transfer(0,receiver,amount)"
./0x55fe4eaae4c2636d1f0ae63542617564c3832edf_ext.sol,FoMo3DFast.endRound,454,505,"_rID(uint256) := rID_(uint256),_winAddress(address) := keyMaxAddress_(address),REF_52(uint256) -> pIDxAddr_[_winAddress],_winPID(uint256) := REF_52(uint256),REF_53(F3Ddatasets.BigPot) -> bigPot_[_rID],REF_54(uint256) -> REF_53.pot,_win(uint256) := REF_54(uint256),REF_55(F3Ddatasets.PlayerVault) -> plyr_[_winPID],REF_56(uint256) -> REF_55.winBigPot,REF_58(F3Ddatasets.PlayerVault) -> plyr_[_winPID],REF_59(uint256) -> REF_58.winBigPot,TMP_73(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_win', 'REF_59'] ,REF_56(uint256) (->plyr_) := TMP_73(uint256),REF_60(uint256) -> smallPot_.keys,REF_60(uint256) (->smallPot_) := 0(uint256),REF_61(uint256) -> smallPot_.eth,REF_61(uint256) (->smallPot_) := 0(uint256),REF_62(uint256) -> smallPot_.pot,REF_62(uint256) (->smallPot_) := 0(uint256),REF_63(uint256) -> smallPot_.plyr,REF_63(uint256) (->smallPot_) := 0(uint256),REF_64(bool) -> smallPot_.on,TMP_74(bool) = REF_64 == True,CONDITION TMP_74,REF_65(uint256) -> smallPot_.eth,_currentPot(uint256) := REF_65(uint256),REF_66(uint256) -> smallPot_.pot,_winSmallPot(uint256) := REF_66(uint256),TMP_75(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_currentPot', '_winSmallPot'] ,_surplus(uint256) := TMP_75(uint256),REF_68(bool) -> smallPot_.on,REF_68(bool) (->smallPot_) := False(bool),REF_69(F3Ddatasets.PlayerVault) -> plyr_[_winPID],REF_70(uint256) -> REF_69.winSmallPot,REF_72(F3Ddatasets.PlayerVault) -> plyr_[_winPID],REF_73(uint256) -> REF_72.winSmallPot,TMP_76(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_winSmallPot', 'REF_73'] ,REF_70(uint256) (->plyr_) := TMP_76(uint256),TMP_77(bool) = _surplus > 0,CONDITION TMP_77,REF_74(F3Ddatasets.PlayerVault) -> plyr_[1],REF_75(uint256) -> REF_74.winSmallPot,REF_77(F3Ddatasets.PlayerVault) -> plyr_[1],REF_78(uint256) -> REF_77.winSmallPot,TMP_78(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_surplus', 'REF_78'] ,REF_75(uint256) (->plyr_) := TMP_78(uint256),REF_79(uint256) -> smallPot_.pot,_currentPot1(uint256) := REF_79(uint256),TMP_79(bool) = _currentPot1 > 0,CONDITION TMP_79,REF_80(F3Ddatasets.PlayerVault) -> plyr_[1],REF_81(uint256) -> REF_80.winSmallPot,REF_83(F3Ddatasets.PlayerVault) -> plyr_[1],REF_84(uint256) -> REF_83.winSmallPot,TMP_80(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_currentPot1', 'REF_84'] ,REF_81(uint256) (->plyr_) := TMP_80(uint256),TMP_81(uint256) := rID_(uint256),rID_(uint256) = rID_ + 1,TMP_82(uint256) := _rID(uint256),_rID(uint256) = _rID + 1,_now(uint256) := now(uint256),REF_85(F3Ddatasets.BigPot) -> bigPot_[_rID],REF_86(uint256) -> REF_85.strt,REF_86(uint256) (->bigPot_) := _now(uint256),REF_87(F3Ddatasets.BigPot) -> bigPot_[_rID],REF_88(uint256) -> REF_87.end,TMP_83(uint256) = _now + rndMax_,REF_88(uint256) (->bigPot_) := TMP_83(uint256),keyMax_(uint256) := 0(uint256),TMP_84 = CONVERT 0 to address,keyMaxAddress_(address) := TMP_84(address),affKeyMax_(uint256) := 0(uint256),affKeyMaxPlayId_(uint256) := 0(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_rID = rID_

IRs:
_rID(uint256) := rID_(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
_winAddress = keyMaxAddress_

IRs:
_winAddress(address) := keyMaxAddress_(address)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
_winPID = pIDxAddr_[_winAddress]

IRs:
REF_52(uint256) -> pIDxAddr_[_winAddress]
_winPID(uint256) := REF_52(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
_win = bigPot_[_rID].pot

IRs:
REF_53(F3Ddatasets.BigPot) -> bigPot_[_rID]
REF_54(uint256) -> REF_53.pot
_win(uint256) := REF_54(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
plyr_[_winPID].winBigPot = _win.add(plyr_[_winPID].winBigPot)

IRs:
REF_55(F3Ddatasets.PlayerVault) -> plyr_[_winPID]
REF_56(uint256) -> REF_55.winBigPot
REF_58(F3Ddatasets.PlayerVault) -> plyr_[_winPID]
REF_59(uint256) -> REF_58.winBigPot
TMP_73(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_win', 'REF_59'] 
REF_56(uint256) (->plyr_) := TMP_73(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
smallPot_.keys = 0

IRs:
REF_60(uint256) -> smallPot_.keys
REF_60(uint256) (->smallPot_) := 0(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
smallPot_.eth = 0

IRs:
REF_61(uint256) -> smallPot_.eth
REF_61(uint256) (->smallPot_) := 0(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
smallPot_.pot = 0

IRs:
REF_62(uint256) -> smallPot_.pot
REF_62(uint256) (->smallPot_) := 0(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
smallPot_.plyr = 0

IRs:
REF_63(uint256) -> smallPot_.plyr
REF_63(uint256) (->smallPot_) := 0(uint256)""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
smallPot_.on == true

IRs:
REF_64(bool) -> smallPot_.on
TMP_74(bool) = REF_64 == True
CONDITION TMP_74""];
10->11[label=""True""];
10->19[label=""False""];
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
_currentPot = smallPot_.eth

IRs:
REF_65(uint256) -> smallPot_.eth
_currentPot(uint256) := REF_65(uint256)""];
11->12;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
_winSmallPot = smallPot_.pot

IRs:
REF_66(uint256) -> smallPot_.pot
_winSmallPot(uint256) := REF_66(uint256)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
_surplus = _currentPot.sub(_winSmallPot)

IRs:
TMP_75(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_currentPot', '_winSmallPot'] 
_surplus(uint256) := TMP_75(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
smallPot_.on = false

IRs:
REF_68(bool) -> smallPot_.on
REF_68(bool) (->smallPot_) := False(bool)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
plyr_[_winPID].winSmallPot = _winSmallPot.add(plyr_[_winPID].winSmallPot)

IRs:
REF_69(F3Ddatasets.PlayerVault) -> plyr_[_winPID]
REF_70(uint256) -> REF_69.winSmallPot
REF_72(F3Ddatasets.PlayerVault) -> plyr_[_winPID]
REF_73(uint256) -> REF_72.winSmallPot
TMP_76(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_winSmallPot', 'REF_73'] 
REF_70(uint256) (->plyr_) := TMP_76(uint256)""];
15->16;
16[label=""Node Type: IF 16

EXPRESSION:
_surplus > 0

IRs:
TMP_77(bool) = _surplus > 0
CONDITION TMP_77""];
16->17[label=""True""];
16->18[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
plyr_[1].winSmallPot = _surplus.add(plyr_[1].winSmallPot)

IRs:
REF_74(F3Ddatasets.PlayerVault) -> plyr_[1]
REF_75(uint256) -> REF_74.winSmallPot
REF_77(F3Ddatasets.PlayerVault) -> plyr_[1]
REF_78(uint256) -> REF_77.winSmallPot
TMP_78(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_surplus', 'REF_78'] 
REF_75(uint256) (->plyr_) := TMP_78(uint256)""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->23;
19[label=""Node Type: NEW VARIABLE 19

EXPRESSION:
_currentPot1 = smallPot_.pot

IRs:
REF_79(uint256) -> smallPot_.pot
_currentPot1(uint256) := REF_79(uint256)""];
19->20;
20[label=""Node Type: IF 20

EXPRESSION:
_currentPot1 > 0

IRs:
TMP_79(bool) = _currentPot1 > 0
CONDITION TMP_79""];
20->21[label=""True""];
20->22[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
plyr_[1].winSmallPot = _currentPot1.add(plyr_[1].winSmallPot)

IRs:
REF_80(F3Ddatasets.PlayerVault) -> plyr_[1]
REF_81(uint256) -> REF_80.winSmallPot
REF_83(F3Ddatasets.PlayerVault) -> plyr_[1]
REF_84(uint256) -> REF_83.winSmallPot
TMP_80(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_currentPot1', 'REF_84'] 
REF_81(uint256) (->plyr_) := TMP_80(uint256)""];
21->22;
22[label=""Node Type: END_IF 22
""];
22->23;
23[label=""Node Type: END_IF 23
""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
rID_ ++

IRs:
TMP_81(uint256) := rID_(uint256)
rID_(uint256) = rID_ + 1""];
24->25;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
_rID ++

IRs:
TMP_82(uint256) := _rID(uint256)
_rID(uint256) = _rID + 1""];
25->26;
26[label=""Node Type: NEW VARIABLE 26

EXPRESSION:
_now = now

IRs:
_now(uint256) := now(uint256)""];
26->27;
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
bigPot_[_rID].strt = _now

IRs:
REF_85(F3Ddatasets.BigPot) -> bigPot_[_rID]
REF_86(uint256) -> REF_85.strt
REF_86(uint256) (->bigPot_) := _now(uint256)""];
27->28;
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
bigPot_[_rID].end = _now + rndMax_

IRs:
REF_87(F3Ddatasets.BigPot) -> bigPot_[_rID]
REF_88(uint256) -> REF_87.end
TMP_83(uint256) = _now + rndMax_
REF_88(uint256) (->bigPot_) := TMP_83(uint256)""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
keyMax_ = 0

IRs:
keyMax_(uint256) := 0(uint256)""];
29->30;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
keyMaxAddress_ = address(0)

IRs:
TMP_84 = CONVERT 0 to address
keyMaxAddress_(address) := TMP_84(address)""];
30->31;
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
affKeyMax_ = 0

IRs:
affKeyMax_(uint256) := 0(uint256)""];
31->32;
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
affKeyMaxPlayId_ = 0

IRs:
affKeyMaxPlayId_(uint256) := 0(uint256)""];
}
",0,1,0,0,_rID = rID_;_winAddress = keyMaxAddress_;_winPID = pIDxAddr_[_winAddress];_win = bigPot_[_rID].pot;plyr_[_winPID].winBigPot = _win.add(plyr_[_winPID].winBigPot);smallPot_.keys = 0;smallPot_.eth = 0;smallPot_.pot = 0;smallPot_.plyr = 0;smallPot_.on == true;_currentPot = smallPot_.eth;_currentPot1 = smallPot_.pot;_winSmallPot = smallPot_.pot;_surplus = _currentPot.sub(_winSmallPot);smallPot_.on = false;plyr_[_winPID].winSmallPot = _winSmallPot.add(plyr_[_winPID].winSmallPot);_surplus > 0;plyr_[1].winSmallPot = _surplus.add(plyr_[1].winSmallPot);;;_currentPot1 > 0;plyr_[1].winSmallPot = _currentPot1.add(plyr_[1].winSmallPot);;rID_ ++;_rID ++;_now = now;bigPot_[_rID].strt = _now;bigPot_[_rID].end = _now + rndMax_;keyMax_ = 0;keyMaxAddress_ = address(0);affKeyMax_ = 0;affKeyMaxPlayId_ = 0
./0xd86f790b2bfca7b224165662ae5bb21663a999a1_ext.sol,GCRTokenERC20.burn,100,106,"REF_17(uint256) -> balanceOf[msg.sender],TMP_25(bool) = REF_17 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_25(bool) = REF_17 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888_ext.sol,Log.AddMessage,88,96,"REF_13(address) -> LastMsg.Sender,REF_13(address) (->LastMsg) := _adr(address),REF_14(uint256) -> LastMsg.Time,REF_14(uint256) (->LastMsg) := now(uint256),REF_15(uint256) -> LastMsg.Val,REF_15(uint256) (->LastMsg) := _val(uint256),REF_16(string) -> LastMsg.Data,REF_16(string) (->LastMsg) := _data(string),REF_18 -> LENGTH History,TMP_15(uint256) := REF_18(uint256),TMP_16(uint256) = TMP_15 + 1,REF_18(uint256) (->History) := TMP_16(uint256),REF_19(Log.Message) -> History[TMP_15],REF_19(Log.Message) (->History) := LastMsg(Log.Message)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
LastMsg.Sender = _adr

IRs:
REF_13(address) -> LastMsg.Sender
REF_13(address) (->LastMsg) := _adr(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
LastMsg.Time = now

IRs:
REF_14(uint256) -> LastMsg.Time
REF_14(uint256) (->LastMsg) := now(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
LastMsg.Val = _val

IRs:
REF_15(uint256) -> LastMsg.Val
REF_15(uint256) (->LastMsg) := _val(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
LastMsg.Data = _data

IRs:
REF_16(string) -> LastMsg.Data
REF_16(string) (->LastMsg) := _data(string)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
History.push(LastMsg)

IRs:
REF_18 -> LENGTH History
TMP_15(uint256) := REF_18(uint256)
TMP_16(uint256) = TMP_15 + 1
REF_18(uint256) (->History) := TMP_16(uint256)
REF_19(Log.Message) -> History[TMP_15]
REF_19(Log.Message) (->History) := LastMsg(Log.Message)""];
}
",0,1,0,0,LastMsg.Sender = _adr;LastMsg.Time = now;LastMsg.Val = _val;LastMsg.Data = _data;History.push(LastMsg)
./0xcfd2047eb61412e9b8de511dc2087e07003829ee_ext.sol,FifteenPlus.fallback,14,31,"REF_0(uint256) -> prtime[owner],TMP_0(uint256) = now - REF_0,TMP_1(bool) = TMP_0 >= 86400,CONDITION TMP_1,TMP_2(uint256) = SOLIDITY_CALL balance(address)(ths),TMP_3(uint256) = TMP_2 / 100,Transfer dest:owner value:TMP_3,REF_2(uint256) -> prtime[owner],REF_2(uint256) (->prtime) := now(uint256),REF_3(uint256) -> balance[msg.sender],TMP_5(bool) = REF_3 != 0,CONDITION TMP_5,REF_4(uint256) -> balance[msg.sender],REF_5(uint16) -> rate[msg.sender],TMP_6(uint256) = REF_4 * REF_5,TMP_7(uint256) = TMP_6 / 1000,REF_6(uint256) -> timestamp[msg.sender],TMP_8(uint256) = now - REF_6,TMP_9(uint256) = TMP_7 * TMP_8,TMP_10(uint256) = TMP_9 / 86400,paymentAmount(uint256) := TMP_10(uint256),Transfer dest:msg.sender value:paymentAmount,REF_8(uint256) -> overallPayment[msg.sender],REF_8(-> overallPayment) = REF_8 + paymentAmount,REF_9(uint256) -> timestamp[msg.sender],REF_9(uint256) (->timestamp) := now(uint256),REF_10(uint256) -> balance[msg.sender],REF_10(-> balance) = REF_10 + msg.value,REF_11(uint256) -> balance[msg.sender],REF_12(uint256) -> overallPayment[msg.sender],TMP_12(bool) = REF_11 > REF_12,CONDITION TMP_12,REF_13(uint16) -> rate[msg.sender],REF_13(uint16) (->rate) := 150(uint256),REF_14(uint16) -> rate[msg.sender],REF_14(uint16) (->rate) := 15(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
(now - prtime[owner]) >= 86400

IRs:
REF_0(uint256) -> prtime[owner]
TMP_0(uint256) = now - REF_0
TMP_1(bool) = TMP_0 >= 86400
CONDITION TMP_1""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(ths.balance / 100)

IRs:
TMP_2(uint256) = SOLIDITY_CALL balance(address)(ths)
TMP_3(uint256) = TMP_2 / 100
Transfer dest:owner value:TMP_3""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
prtime[owner] = now

IRs:
REF_2(uint256) -> prtime[owner]
REF_2(uint256) (->prtime) := now(uint256)""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
balance[msg.sender] != 0

IRs:
REF_3(uint256) -> balance[msg.sender]
TMP_5(bool) = REF_3 != 0
CONDITION TMP_5""];
5->6[label=""True""];
5->9[label=""False""];
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
paymentAmount = balance[msg.sender] * rate[msg.sender] / 1000 * (now - timestamp[msg.sender]) / 86400

IRs:
REF_4(uint256) -> balance[msg.sender]
REF_5(uint16) -> rate[msg.sender]
TMP_6(uint256) = REF_4 * REF_5
TMP_7(uint256) = TMP_6 / 1000
REF_6(uint256) -> timestamp[msg.sender]
TMP_8(uint256) = now - REF_6
TMP_9(uint256) = TMP_7 * TMP_8
TMP_10(uint256) = TMP_9 / 86400
paymentAmount(uint256) := TMP_10(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
msg.sender.transfer(paymentAmount)

IRs:
Transfer dest:msg.sender value:paymentAmount""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
overallPayment[msg.sender] += paymentAmount

IRs:
REF_8(uint256) -> overallPayment[msg.sender]
REF_8(-> overallPayment) = REF_8 + paymentAmount""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
timestamp[msg.sender] = now

IRs:
REF_9(uint256) -> timestamp[msg.sender]
REF_9(uint256) (->timestamp) := now(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
balance[msg.sender] += msg.value

IRs:
REF_10(uint256) -> balance[msg.sender]
REF_10(-> balance) = REF_10 + msg.value""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
balance[msg.sender] > overallPayment[msg.sender]

IRs:
REF_11(uint256) -> balance[msg.sender]
REF_12(uint256) -> overallPayment[msg.sender]
TMP_12(bool) = REF_11 > REF_12
CONDITION TMP_12""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
rate[msg.sender] = 150

IRs:
REF_13(uint16) -> rate[msg.sender]
REF_13(uint16) (->rate) := 150(uint256)""];
13->15;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
rate[msg.sender] = 15

IRs:
REF_14(uint16) -> rate[msg.sender]
REF_14(uint16) (->rate) := 15(uint256)""];
14->15;
15[label=""Node Type: END_IF 15
""];
}
",0,1,0,0,(now - prtime[owner]) >= 86400;owner.transfer(ths.balance / 100);;prtime[owner] = now;balance[msg.sender] != 0;paymentAmount = balance[msg.sender] * rate[msg.sender] / 1000 * (now - timestamp[msg.sender]) / 86400;;msg.sender.transfer(paymentAmount);overallPayment[msg.sender] += paymentAmount;timestamp[msg.sender] = now;balance[msg.sender] += msg.value;balance[msg.sender] > overallPayment[msg.sender];rate[msg.sender] = 150;rate[msg.sender] = 15;
./0x3f922acba2ee567a93933fa4392c2690e4706d42_ext.sol,TokenERC20._transfer,27,36,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 > REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value > balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 > REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value > balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xd083713e4d9bc1e4c923795f9f6ce2a97646c116_ext.sol,ItemList.keys,120,123,"REF_42(uint32[]) -> self.m_List,RETURN REF_42","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
self.m_List

IRs:
REF_42(uint32[]) -> self.m_List
RETURN REF_42""];
}
",0,1,0,0,self.m_List
./0x267398927b5886df921b235afe9dbbe47fbcc37d_ext.sol,NobarToken.burn,71,77,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x6b87999be87358065bbde41e8a0fe0b7b1cd2514_ext.sol,TeslaWatt.approveAndCall,189,194,"REF_24(mapping(address => uint256)) -> allowed[msg.sender],REF_25(uint256) -> REF_24[spender],REF_25(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_43 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_43(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_24(mapping(address => uint256)) -> allowed[msg.sender]
REF_25(uint256) -> REF_24[spender]
REF_25(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_43 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_43(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x4200942093f5c8c2ce865e17b3fdec9148de8c49_ext.sol,TokenERC20.burn,145,151,"REF_17(uint256) -> balanceOf[msg.sender],TMP_25(bool) = REF_17 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_25(bool) = REF_17 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x5b6696ed1e4e74c2a73a3f27186ab315f4fa55d8_ext.sol,TkoWhitelist.addManyToWhitelist,155,159,"i(uint256) := 0(uint256),REF_2 -> LENGTH _beneficiaries,TMP_34(bool) = i < REF_2,CONDITION TMP_34,REF_3(address) -> _beneficiaries[i],REF_4(bool) -> whitelist[REF_3],REF_4(bool) (->whitelist) := True(bool),TMP_35(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, TkoWhitelist.onlyOwnerOrAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _beneficiaries.length

IRs:
REF_2 -> LENGTH _beneficiaries
TMP_34(bool) = i < REF_2
CONDITION TMP_34""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
whitelist[_beneficiaries[i]] = true

IRs:
REF_3(address) -> _beneficiaries[i]
REF_4(bool) -> whitelist[REF_3]
REF_4(bool) (->whitelist) := True(bool)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_35(uint256) := i(uint256)
i(uint256) = i + 1""];
6->4;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwnerOrAdmin()

IRs:
MODIFIER_CALL, TkoWhitelist.onlyOwnerOrAdmin()()""];
7->3;
}
",0,1,0,0,onlyOwnerOrAdmin();;i < _beneficiaries.length;;i = 0;whitelist[_beneficiaries[i]] = true;i ++
./0x291fe087234eaa19f8b16b5d341b4e4540c220aa_ext.sol,TokenERC20.burn,157,163,"REF_17(uint256) -> balanceOf[msg.sender],TMP_34(bool) = REF_17 >= _value,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_34(bool) = REF_17 >= _value
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x7747aeb32d89e527e5ebbf646871ca79805989ad_ext.sol,LitecoinCash.distributeLCASH,72,81,"i(uint256) := 0(uint256),REF_1 -> LENGTH addresses,TMP_2(bool) = i < REF_1,CONDITION TMP_2,REF_2(address) -> addresses[i],TMP_3(uint256) = INTERNAL_CALL, LitecoinCash.getEthBalance(address)(REF_2),TMP_4(bool) = TMP_3 < _ethbal,CONDITION TMP_4,REF_3(uint256) -> balances[owner],REF_3(-> balances) = REF_3 - _value,REF_4(address) -> addresses[i],REF_5(uint256) -> balances[REF_4],REF_5(-> balances) = REF_5 + _value,REF_6(address) -> addresses[i],Emit Transfer(owner,REF_6,_value),TMP_6(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, LitecoinCash.onlyOwner()(),MODIFIER_CALL, LitecoinCash.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addresses.length

IRs:
REF_1 -> LENGTH addresses
TMP_2(bool) = i < REF_1
CONDITION TMP_2""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
getEthBalance(addresses[i]) < _ethbal

IRs:
REF_2(address) -> addresses[i]
TMP_3(uint256) = INTERNAL_CALL, LitecoinCash.getEthBalance(address)(REF_2)
TMP_4(bool) = TMP_3 < _ethbal
CONDITION TMP_4""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: CONTINUE 6
""];
6->11;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[owner] -= _value

IRs:
REF_3(uint256) -> balances[owner]
REF_3(-> balances) = REF_3 - _value""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
balances[addresses[i]] += _value

IRs:
REF_4(address) -> addresses[i]
REF_5(uint256) -> balances[REF_4]
REF_5(-> balances) = REF_5 + _value""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Transfer(owner,addresses[i],_value)

IRs:
REF_6(address) -> addresses[i]
Emit Transfer(owner,REF_6,_value)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_6(uint256) := i(uint256)
i(uint256) = i + 1""];
11->4;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, LitecoinCash.onlyOwner()()""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, LitecoinCash.canDistr()()""];
13->3;
}
",0,1,0,0,"onlyOwner();;i < addresses.length;;i = 0;getEthBalance(addresses[i]) < _ethbal;;;i ++;balances[owner] -= _value;balances[addresses[i]] += _value;Transfer(owner,addresses[i],_value);canDistr()"
./0x65244ee745288952f347d82ba69690fa9a9843c0_ext.sol,BEX.sendByOwner,108,130,"TMP_18(bool) = msg.sender != owner,TMP_19(bool) = msg.sender != operater,TMP_20(bool) = TMP_18 && TMP_19,CONDITION TMP_20,TMP_21(None) = SOLIDITY_CALL revert()(),TMP_22(bool) = _to == 0,CONDITION TMP_22,TMP_23(None) = SOLIDITY_CALL revert()(),TMP_24(bool) = _value > _totalBalance,CONDITION TMP_24,TMP_25(None) = SOLIDITY_CALL revert()(),_totalBalance(uint256) = _totalBalance - _value,REF_19(uint256) -> balances[_to],REF_19(-> balances) = REF_19 + _value,INTERNAL_CALL, BEX.safeToNextIdx()(),Emit SendTo(sendToIdx,1,0,_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender != owner && msg.sender != operater

IRs:
TMP_18(bool) = msg.sender != owner
TMP_19(bool) = msg.sender != operater
TMP_20(bool) = TMP_18 && TMP_19
CONDITION TMP_20""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_21(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
_to == 0x0

IRs:
TMP_22(bool) = _to == 0
CONDITION TMP_22""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
revert()()

IRs:
TMP_23(None) = SOLIDITY_CALL revert()()""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
_value > _totalBalance

IRs:
TMP_24(bool) = _value > _totalBalance
CONDITION TMP_24""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
revert()()

IRs:
TMP_25(None) = SOLIDITY_CALL revert()()""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
_totalBalance -= _value

IRs:
_totalBalance(uint256) = _totalBalance - _value""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
balances[_to] += _value

IRs:
REF_19(uint256) -> balances[_to]
REF_19(-> balances) = REF_19 + _value""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
safeToNextIdx()

IRs:
INTERNAL_CALL, BEX.safeToNextIdx()()""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
SendTo(sendToIdx,1,0x0,_to,_value)

IRs:
Emit SendTo(sendToIdx,1,0,_to,_value)""];
}
",0,1,0,0,"msg.sender != owner && msg.sender != operater;revert()();;_to == 0x0;revert()();;_value > _totalBalance;revert()();;_totalBalance -= _value;balances[_to] += _value;safeToNextIdx();SendTo(sendToIdx,1,0x0,_to,_value)"
./0xf4be3da9df0c12e69115bb5614334786fbaf5ace_ext.sol,MiBoodleToken.setFundingStartTime,224,226,"TMP_76(uint256) = now + _start,start(uint256) := TMP_76(uint256),MODIFIER_CALL, Haltable.stopIfHalted()(),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
start = now + _start

IRs:
TMP_76(uint256) = now + _start
start(uint256) := TMP_76(uint256)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
stopIfHalted()

IRs:
MODIFIER_CALL, Haltable.stopIfHalted()()""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
3->1;
}
",0,1,0,0,stopIfHalted();start = now + _start;onlyOwner()
./0x3ac96bbe8b60d715fd818b3fe242edf9def20571_ext.sol,token.approveAndCall,67,74,"TMP_6 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_6(tokenRecipient),TMP_7(bool) = INTERNAL_CALL, token.approve(address,uint256)(_spender,_value),CONDITION TMP_7,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_6 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_6(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_7(bool) = INTERNAL_CALL, token.approve(address,uint256)(_spender,_value)
CONDITION TMP_7""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x2793a23341012e0970cf478bab08606b56504c3e_ext.sol,EternalStorage.setBytes,301,303,"REF_45(mapping(bytes32 => bytes)) -> s._bytes,REF_46(bytes) -> REF_45[h],REF_46(bytes) (->s) := v(bytes),MODIFIER_CALL, Administratable.onlyAdmins()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
s._bytes[h] = v

IRs:
REF_45(mapping(bytes32 => bytes)) -> s._bytes
REF_46(bytes) -> REF_45[h]
REF_46(bytes) (->s) := v(bytes)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyAdmins()

IRs:
MODIFIER_CALL, Administratable.onlyAdmins()()""];
2->1;
}
",0,1,0,0,onlyAdmins();s._bytes[h] = v
./0x88d4f99341de4afdd94cfb7c1c67c885b79ba6bc_ext.sol,Deed.closeDeed,708,713,"active(bool) := False(bool),TMP_225(uint256) = 1000 - refundRatio,REF_91(uint256) = SOLIDITY_CALL balance(address)(this),TMP_226(uint256) = TMP_225 * REF_91,TMP_227(uint256) = TMP_226 / 1000,TMP_228 = SEND dest:burn value:TMP_227,TMP_229(None) = SOLIDITY_CALL require(bool)(TMP_228),Emit DeedClosed(),INTERNAL_CALL, Deed.destroyDeed()(),MODIFIER_CALL, Deed.onlyRegistrar()(),MODIFIER_CALL, Deed.onlyActive()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
active = false

IRs:
active(bool) := False(bool)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(burn.send(((1000 - refundRatio) * this.balance) / 1000))

IRs:
TMP_225(uint256) = 1000 - refundRatio
REF_91(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_226(uint256) = TMP_225 * REF_91
TMP_227(uint256) = TMP_226 / 1000
TMP_228 = SEND dest:burn value:TMP_227
TMP_229(None) = SOLIDITY_CALL require(bool)(TMP_228)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
DeedClosed()

IRs:
Emit DeedClosed()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
destroyDeed()

IRs:
INTERNAL_CALL, Deed.destroyDeed()()""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyRegistrar()

IRs:
MODIFIER_CALL, Deed.onlyRegistrar()()""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyActive()

IRs:
MODIFIER_CALL, Deed.onlyActive()()""];
6->1;
}
",0,1,0,0,onlyRegistrar();active = false;require(bool)(burn.send(((1000 - refundRatio) * this.balance) / 1000));DeedClosed();destroyDeed();onlyActive()
./0xf0344800bd3ffa687e4d780357961b28995a5f46_ext.sol,QUIZ_GAME.StartGame,22,32,"TMP_7(bool) = responseHash == 0,CONDITION TMP_7,TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response),responseHash(bytes32) := TMP_8(bytes32),question(string) := _question(string),questionSender(address) := msg.sender(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
responseHash == 0x0

IRs:
TMP_7(bool) = responseHash == 0
CONDITION TMP_7""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
responseHash = keccak256()(_response)

IRs:
TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response)
responseHash(bytes32) := TMP_8(bytes32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
questionSender = msg.sender

IRs:
questionSender(address) := msg.sender(address)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,1,0,0,responseHash == 0x0;responseHash = keccak256()(_response);;question = _question;questionSender = msg.sender
./0x4902c062f1384654bd075b719c6a26a83ef7aaf0_ext.sol,TokenERC20.burn,179,185,"REF_17(uint256) -> balanceOf[msg.sender],TMP_36(bool) = REF_17 >= _value,TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_36(bool) = REF_17 >= _value
TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x586927ff87bf40aada74afbff5e2409b865be023_ext.sol,HashBet.resolveBet,24,39,"REF_5(HashBet.Bet) -> bets[msg.sender],bet(HashBet.Bet) := REF_5(HashBet.Bet),REF_6(uint256) -> bet.height,TMP_4(uint256) = block.number - REF_6,dist(uint256) := TMP_4(uint256),TMP_5(bool) = dist < 255,TMP_6(bool) = dist > 3,TMP_7(bool) = TMP_5 && TMP_6,TMP_8(None) = SOLIDITY_CALL require(bool)(TMP_7),REF_7(uint256) -> bet.height,TMP_9(uint256) = SOLIDITY_CALL blockhash(uint256)(REF_7),h1(bytes32) := TMP_9(uint256),REF_8(uint256) -> bet.height,TMP_10(uint256) = REF_8 + 3,TMP_11(uint256) = SOLIDITY_CALL blockhash(uint256)(TMP_10),h2(bytes32) := TMP_11(uint256),TMP_12(bytes32) = SOLIDITY_CALL keccak256()(h1,h2),TMP_13 = CONVERT TMP_12 to uint256,hashVal(uint256) := TMP_13(uint256),FACTOR(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129640(uint256),TMP_14(uint256) = hashVal / FACTOR,TMP_15 = CONVERT TMP_14 to uint16,TMP_16(uint16) = TMP_15 % 1000,result(uint16) := TMP_16(uint16),REF_9(uint256) -> bet.height,REF_9(uint256) (->bet) := 0(uint256),TMP_17(bool) = result <= 495,CONDITION TMP_17,TMP_18 = CONVERT this to address,TMP_19(uint256) = SOLIDITY_CALL balance(address)(TMP_18),Transfer dest:msg.sender value:TMP_19,Emit Result(hashVal,result)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
bet = bets[msg.sender]

IRs:
REF_5(HashBet.Bet) -> bets[msg.sender]
bet(HashBet.Bet) := REF_5(HashBet.Bet)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
dist = block.number - bet.height

IRs:
REF_6(uint256) -> bet.height
TMP_4(uint256) = block.number - REF_6
dist(uint256) := TMP_4(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(dist < 255 && dist > 3)

IRs:
TMP_5(bool) = dist < 255
TMP_6(bool) = dist > 3
TMP_7(bool) = TMP_5 && TMP_6
TMP_8(None) = SOLIDITY_CALL require(bool)(TMP_7)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
h1 = block.blockhash(bet.height)

IRs:
REF_7(uint256) -> bet.height
TMP_9(uint256) = SOLIDITY_CALL blockhash(uint256)(REF_7)
h1(bytes32) := TMP_9(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
h2 = block.blockhash(bet.height + 3)

IRs:
REF_8(uint256) -> bet.height
TMP_10(uint256) = REF_8 + 3
TMP_11(uint256) = SOLIDITY_CALL blockhash(uint256)(TMP_10)
h2(bytes32) := TMP_11(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
hashVal = uint256(keccak256()(h1,h2))

IRs:
TMP_12(bytes32) = SOLIDITY_CALL keccak256()(h1,h2)
TMP_13 = CONVERT TMP_12 to uint256
hashVal(uint256) := TMP_13(uint256)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
FACTOR = 115792089237316195423570985008687907853269984665640564039457584007913129640

IRs:
FACTOR(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129640(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
result = uint16((hashVal / FACTOR)) % 1000

IRs:
TMP_14(uint256) = hashVal / FACTOR
TMP_15 = CONVERT TMP_14 to uint16
TMP_16(uint16) = TMP_15 % 1000
result(uint16) := TMP_16(uint16)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
bet.height = 0

IRs:
REF_9(uint256) -> bet.height
REF_9(uint256) (->bet) := 0(uint256)""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
result <= 495

IRs:
TMP_17(bool) = result <= 495
CONDITION TMP_17""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_18 = CONVERT this to address
TMP_19(uint256) = SOLIDITY_CALL balance(address)(TMP_18)
Transfer dest:msg.sender value:TMP_19""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
Result(hashVal,result)

IRs:
Emit Result(hashVal,result)""];
}
",0,1,0,0,"bet = bets[msg.sender];dist = block.number - bet.height;require(bool)(dist < 255 && dist > 3);h1 = block.blockhash(bet.height);h2 = block.blockhash(bet.height + 3);hashVal = uint256(keccak256()(h1,h2));FACTOR = 115792089237316195423570985008687907853269984665640564039457584007913129640;result = uint16((hashVal / FACTOR)) % 1000;bet.height = 0;result <= 495;msg.sender.transfer(address(this).balance);;Result(hashVal,result)"
./0x313c54eb9f08f1be0f18e8ad505135fa7041a52f_ext.sol,CHEXToken.price,160,167,"REF_46(CHEXToken.TokenSaleState) -> TokenSaleState.Initial,TMP_106(bool) = _saleState == REF_46,CONDITION TMP_106,RETURN 6001,REF_47(CHEXToken.TokenSaleState) -> TokenSaleState.Presale,TMP_107(bool) = _saleState == REF_47,CONDITION TMP_107,TMP_108(uint256) = endBlock - block.number,TMP_109(uint256) = endBlock - startBlock,TMP_110(uint256) = INTERNAL_CALL, SafeMath.pct(uint256,uint256,uint256)(TMP_108,TMP_109,3),percentRemaining(uint256) := TMP_110(uint256),TMP_111(uint256) = 3 * percentRemaining,TMP_112(uint256) = 3000 + TMP_111,RETURN TMP_112,RETURN 3000","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_saleState == TokenSaleState.Initial

IRs:
REF_46(CHEXToken.TokenSaleState) -> TokenSaleState.Initial
TMP_106(bool) = _saleState == REF_46
CONDITION TMP_106""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
6001

IRs:
RETURN 6001""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
_saleState == TokenSaleState.Presale

IRs:
REF_47(CHEXToken.TokenSaleState) -> TokenSaleState.Presale
TMP_107(bool) = _saleState == REF_47
CONDITION TMP_107""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
percentRemaining = pct((endBlock - block.number),(endBlock - startBlock),3)

IRs:
TMP_108(uint256) = endBlock - block.number
TMP_109(uint256) = endBlock - startBlock
TMP_110(uint256) = INTERNAL_CALL, SafeMath.pct(uint256,uint256,uint256)(TMP_108,TMP_109,3)
percentRemaining(uint256) := TMP_110(uint256)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
3000 + 3 * percentRemaining

IRs:
TMP_111(uint256) = 3 * percentRemaining
TMP_112(uint256) = 3000 + TMP_111
RETURN TMP_112""];
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
3000

IRs:
RETURN 3000""];
}
",0,1,0,0,"_saleState == TokenSaleState.Initial;6001;;_saleState == TokenSaleState.Presale;percentRemaining = pct((endBlock - block.number),(endBlock - startBlock),3);;3000 + 3 * percentRemaining;3000"
./0x4bc53ead2ae82e0c723ee8e3d7bacfb1fafea1ce_ext.sol,GUESS_AND_GET_A_PRIZE.StartGame,22,32,"TMP_7(bool) = responseHash == 0,CONDITION TMP_7,TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response),responseHash(bytes32) := TMP_8(bytes32),question(string) := _question(string),questionSender(address) := msg.sender(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
responseHash == 0x0

IRs:
TMP_7(bool) = responseHash == 0
CONDITION TMP_7""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
responseHash = keccak256()(_response)

IRs:
TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response)
responseHash(bytes32) := TMP_8(bytes32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
questionSender = msg.sender

IRs:
questionSender(address) := msg.sender(address)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,1,0,0,responseHash == 0x0;responseHash = keccak256()(_response);;question = _question;questionSender = msg.sender
./0x1ba4780b57d6efe3a1170edfa66091e7c769db7d_ext.sol,Clen.transfer,83,89,"REF_1(uint256) -> balances[msg.sender],TMP_0(bool) = REF_1 >= _value,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_2(uint256) -> balances[msg.sender],REF_2(-> balances) = REF_2 - _value,REF_3(uint256) -> balances[_to],REF_3(-> balances) = REF_3 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_0(bool) = REF_1 >= _value
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_2(uint256) -> balances[msg.sender]
REF_2(-> balances) = REF_2 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_3(uint256) -> balances[_to]
REF_3(-> balances) = REF_3 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0xb3a0dc0daa5ce33fc14a142c0fd4a1586c4e8c82_ext.sol,Bitstraq_Token.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x1e188cfea3ea8fb4f5daa71ce90899cbe3806e6d_ext.sol,WisdomWorldStandardToken.approveAndCall,95,103,"REF_31(mapping(address => uint256)) -> allowed[msg.sender],REF_32(uint256) -> REF_31[_spender],REF_32(uint256) (->allowed) := _value(uint256),Emit Approval(msg.sender,_spender,_value),TMP_19(bytes32) = SOLIDITY_CALL sha3()(receiveApproval(address,uint256,address,bytes)),TMP_20 = CONVERT TMP_19 to bytes32,TMP_21 = CONVERT TMP_20 to bytes4,TMP_22(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_21', 'msg.sender', '_value', 'this', '_extraData']  ,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_31(mapping(address => uint256)) -> allowed[msg.sender]
REF_32(uint256) -> REF_31[_spender]
REF_32(uint256) (->allowed) := _value(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_spender.call(bytes4(bytes32(sha3()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData))

IRs:
TMP_19(bytes32) = SOLIDITY_CALL sha3()(receiveApproval(address,uint256,address,bytes))
TMP_20 = CONVERT TMP_19 to bytes32
TMP_21 = CONVERT TMP_20 to bytes4
TMP_22(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_21', 'msg.sender', '_value', 'this', '_extraData']  
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][_spender] = _value;Approval(msg.sender,_spender,_value);require(bool)(_spender.call(bytes4(bytes32(sha3()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData));true;success"
./0x28f272fb35039753be682dc9a0f416c487c0bc89_ext.sol,continuousBacking.defineReward,75,80,"host(address) := msg.sender(address),TMP_12(continuousBacking.Reward) = new Reward(title,host,creator,0,numAvailable,minBacking),newReward(continuousBacking.Reward) := TMP_12(continuousBacking.Reward),REF_1 -> LENGTH rewards,TMP_14(uint256) := REF_1(uint256),TMP_15(uint256) = TMP_14 + 1,REF_1(uint256) (->rewards) := TMP_15(uint256),REF_2(continuousBacking.Reward) -> rewards[TMP_14],REF_2(continuousBacking.Reward) (->rewards) := newReward(continuousBacking.Reward),REF_3 -> LENGTH rewards,TMP_16(uint256) = REF_3 - 1,Emit CreatedReward(TMP_16,numAvailable)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
host = msg.sender

IRs:
host(address) := msg.sender(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
newReward = Reward(title,host,creator,0,numAvailable,minBacking)

IRs:
TMP_12(continuousBacking.Reward) = new Reward(title,host,creator,0,numAvailable,minBacking)
newReward(continuousBacking.Reward) := TMP_12(continuousBacking.Reward)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
rewards.push(newReward)

IRs:
REF_1 -> LENGTH rewards
TMP_14(uint256) := REF_1(uint256)
TMP_15(uint256) = TMP_14 + 1
REF_1(uint256) (->rewards) := TMP_15(uint256)
REF_2(continuousBacking.Reward) -> rewards[TMP_14]
REF_2(continuousBacking.Reward) (->rewards) := newReward(continuousBacking.Reward)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
CreatedReward(rewards.length - 1,numAvailable)

IRs:
REF_3 -> LENGTH rewards
TMP_16(uint256) = REF_3 - 1
Emit CreatedReward(TMP_16,numAvailable)""];
}
",0,1,0,0,"host = msg.sender;newReward = Reward(title,host,creator,0,numAvailable,minBacking);rewards.push(newReward);CreatedReward(rewards.length - 1,numAvailable)"
./0x2c110867ca90e43d372c1c2e92990b00ea32818b_ext.sol,FiatDex_protocol_v1.closeSwap,144,180,"REF_25(FiatDex_protocol_v1.Swap) -> swaps[_tradeID],swap(FiatDex_protocol_v1.Swap) := REF_25(FiatDex_protocol_v1.Swap),REF_26(address) -> swap.ethTrader,TMP_24(bool) = msg.sender == REF_26,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_27(FiatDex_protocol_v1.States) -> swap.swapState,REF_28(FiatDex_protocol_v1.States) -> States.CLOSED,REF_27(FiatDex_protocol_v1.States) (->swap) := REF_28(FiatDex_protocol_v1.States),feeAmount(uint256) := 0(uint256),currentTime(uint256) := now(uint256),REF_29(uint256) -> swap.openTime,TMP_26(uint256) = 86400 * feeDelay,TMP_27(uint256) = REF_29 + TMP_26,TMP_28(bool) = TMP_27 < currentTime,CONDITION TMP_28,REF_30(uint256) -> swap.openTime,TMP_29(uint256) = 86400 * feeDelay,TMP_30(uint256) = REF_30 + TMP_29,TMP_31(uint256) = currentTime - TMP_30,seconds_over(uint256) := TMP_31(uint256),TMP_32(uint256) = dailyFeeIncrease * seconds_over,TMP_33(uint256) = TMP_32 / 86400,feePercent(uint256) := TMP_33(uint256),TMP_34(bool) = feePercent > 0,CONDITION TMP_34,TMP_35(bool) = feePercent > 99000,CONDITION TMP_35,feePercent(uint256) := 99000(uint256),REF_31(uint256) -> swap.ethTraderCollateral,TMP_36(uint256) = REF_31 * feePercent,TMP_37(uint256) = TMP_36 / 100000,feeAmount(uint256) := TMP_37(uint256),TMP_38(bool) = feeAmount > 0,CONDITION TMP_38,REF_32(uint256) -> swap.feeAmount,REF_32(uint256) (->swap) := feeAmount(uint256),TMP_39(uint256) = feeAmount * 2,Transfer dest:owner value:TMP_39,REF_34(address) -> swap.ethTrader,REF_36(uint256) -> swap.ethTraderCollateral,TMP_41(uint256) = REF_36 - feeAmount,Transfer dest:REF_34 value:TMP_41,REF_37(address) -> swap.fiatTrader,REF_39(uint256) -> swap.sendAmount,REF_40(uint256) -> swap.fiatTraderCollateral,TMP_43(uint256) = REF_39 + REF_40,TMP_44(uint256) = TMP_43 - feeAmount,Transfer dest:REF_37 value:TMP_44,Emit Close(_tradeID,feeAmount),MODIFIER_CALL, FiatDex_protocol_v1.onlyActiveSwaps(bytes32)(_tradeID)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->23;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
swap = swaps[_tradeID]

IRs:
REF_25(FiatDex_protocol_v1.Swap) -> swaps[_tradeID]
swap(FiatDex_protocol_v1.Swap) := REF_25(FiatDex_protocol_v1.Swap)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == swap.ethTrader)

IRs:
REF_26(address) -> swap.ethTrader
TMP_24(bool) = msg.sender == REF_26
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
swap.swapState = States.CLOSED

IRs:
REF_27(FiatDex_protocol_v1.States) -> swap.swapState
REF_28(FiatDex_protocol_v1.States) -> States.CLOSED
REF_27(FiatDex_protocol_v1.States) (->swap) := REF_28(FiatDex_protocol_v1.States)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
feeAmount = 0

IRs:
feeAmount(uint256) := 0(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
currentTime = now

IRs:
currentTime(uint256) := now(uint256)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
swap.openTime + 86400 * feeDelay < currentTime

IRs:
REF_29(uint256) -> swap.openTime
TMP_26(uint256) = 86400 * feeDelay
TMP_27(uint256) = REF_29 + TMP_26
TMP_28(bool) = TMP_27 < currentTime
CONDITION TMP_28""];
6->7[label=""True""];
6->15[label=""False""];
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
seconds_over = currentTime - (swap.openTime + 86400 * feeDelay)

IRs:
REF_30(uint256) -> swap.openTime
TMP_29(uint256) = 86400 * feeDelay
TMP_30(uint256) = REF_30 + TMP_29
TMP_31(uint256) = currentTime - TMP_30
seconds_over(uint256) := TMP_31(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
feePercent = (dailyFeeIncrease * seconds_over) / 86400

IRs:
TMP_32(uint256) = dailyFeeIncrease * seconds_over
TMP_33(uint256) = TMP_32 / 86400
feePercent(uint256) := TMP_33(uint256)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
feePercent > 0

IRs:
TMP_34(bool) = feePercent > 0
CONDITION TMP_34""];
9->10[label=""True""];
9->14[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
feePercent > 99000

IRs:
TMP_35(bool) = feePercent > 99000
CONDITION TMP_35""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
feePercent = 99000

IRs:
feePercent(uint256) := 99000(uint256)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
feeAmount = (swap.ethTraderCollateral * feePercent) / 100000

IRs:
REF_31(uint256) -> swap.ethTraderCollateral
TMP_36(uint256) = REF_31 * feePercent
TMP_37(uint256) = TMP_36 / 100000
feeAmount(uint256) := TMP_37(uint256)""];
13->14;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: IF 16

EXPRESSION:
feeAmount > 0

IRs:
TMP_38(bool) = feeAmount > 0
CONDITION TMP_38""];
16->17[label=""True""];
16->19[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
swap.feeAmount = feeAmount

IRs:
REF_32(uint256) -> swap.feeAmount
REF_32(uint256) (->swap) := feeAmount(uint256)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
owner.transfer(feeAmount * 2)

IRs:
TMP_39(uint256) = feeAmount * 2
Transfer dest:owner value:TMP_39""];
18->19;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
swap.ethTrader.transfer(swap.ethTraderCollateral - feeAmount)

IRs:
REF_34(address) -> swap.ethTrader
REF_36(uint256) -> swap.ethTraderCollateral
TMP_41(uint256) = REF_36 - feeAmount
Transfer dest:REF_34 value:TMP_41""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
swap.fiatTrader.transfer(swap.sendAmount + swap.fiatTraderCollateral - feeAmount)

IRs:
REF_37(address) -> swap.fiatTrader
REF_39(uint256) -> swap.sendAmount
REF_40(uint256) -> swap.fiatTraderCollateral
TMP_43(uint256) = REF_39 + REF_40
TMP_44(uint256) = TMP_43 - feeAmount
Transfer dest:REF_37 value:TMP_44""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
Close(_tradeID,feeAmount)

IRs:
Emit Close(_tradeID,feeAmount)""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
onlyActiveSwaps(_tradeID)

IRs:
MODIFIER_CALL, FiatDex_protocol_v1.onlyActiveSwaps(bytes32)(_tradeID)""];
23->1;
}
",0,1,0,0,"onlyActiveSwaps(_tradeID);swap = swaps[_tradeID];require(bool)(msg.sender == swap.ethTrader);swap.swapState = States.CLOSED;feeAmount = 0;currentTime = now;swap.openTime + 86400 * feeDelay < currentTime;seconds_over = currentTime - (swap.openTime + 86400 * feeDelay);;feePercent = (dailyFeeIncrease * seconds_over) / 86400;feePercent > 0;feePercent > 99000;;feePercent = 99000;;feeAmount = (swap.ethTraderCollateral * feePercent) / 100000;feeAmount > 0;swap.feeAmount = feeAmount;;owner.transfer(feeAmount * 2);swap.ethTrader.transfer(swap.ethTraderCollateral - feeAmount);swap.fiatTrader.transfer(swap.sendAmount + swap.fiatTraderCollateral - feeAmount);Close(_tradeID,feeAmount)"
./0xec1bfc5a4a5655db224a6c591959865a837f53ba_ext.sol,FandBToken.transfer,67,77,"TMP_0(bool) = _value > 0,REF_2(uint256) -> _balanceOf[msg.sender],TMP_1(bool) = _value <= REF_2,TMP_2(bool) = TMP_0 && TMP_1,TMP_3(bool) = INTERNAL_CALL, FandBToken.isContract(address)(_to),TMP_4 = UnaryType.BANG TMP_3 ,TMP_5(bool) = TMP_2 && TMP_4,CONDITION TMP_5,REF_3(uint256) -> _balanceOf[msg.sender],REF_3(-> _balanceOf) = REF_3 - _value,REF_4(uint256) -> _balanceOf[_to],REF_4(-> _balanceOf) = REF_4 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN False","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_value > 0 && _value <= _balanceOf[msg.sender] && ! isContract(_to)

IRs:
TMP_0(bool) = _value > 0
REF_2(uint256) -> _balanceOf[msg.sender]
TMP_1(bool) = _value <= REF_2
TMP_2(bool) = TMP_0 && TMP_1
TMP_3(bool) = INTERNAL_CALL, FandBToken.isContract(address)(_to)
TMP_4 = UnaryType.BANG TMP_3 
TMP_5(bool) = TMP_2 && TMP_4
CONDITION TMP_5""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_balanceOf[msg.sender] -= _value

IRs:
REF_3(uint256) -> _balanceOf[msg.sender]
REF_3(-> _balanceOf) = REF_3 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_balanceOf[_to] += _value

IRs:
REF_4(uint256) -> _balanceOf[_to]
REF_4(-> _balanceOf) = REF_4 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
}
",1,1,0,0,"_value > 0 && _value <= _balanceOf[msg.sender] && ! isContract(_to);_balanceOf[msg.sender] -= _value;;_balanceOf[_to] += _value;Transfer(msg.sender,_to,_value);true;false"
./0x791af7fccfee46330bb02dac1e2585dc6f49c996_ext.sol,ReddCoin.approveAndCall,55,63,"TMP_19 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_19(tokenRecipient),TMP_20(bool) = INTERNAL_CALL, ReddCoin.approve(address,uint256)(_spender,_value),CONDITION TMP_20,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_19 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_19(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_20(bool) = INTERNAL_CALL, ReddCoin.approve(address,uint256)(_spender,_value)
CONDITION TMP_20""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0xcdf6895b98ddb93fd95ae5fb9a5cd0b54b52aa1a_ext.sol,StandardToken.transferFrom,56,66,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0xda7c27c04f66842faf20644814b644e25e1766ea_ext.sol,OptionsCalculator.calculateOptionsComponents,1016,1061,"TMP_421(ESOPTypes.Employee) = INTERNAL_CALL, ESOPTypes.deserializeEmployee(uint256[9])(employee),emp(ESOPTypes.Employee) := TMP_421(ESOPTypes.Employee),REF_224(ESOPTypes.EmployeeState) -> emp.state,REF_225(ESOPTypes.EmployeeState) -> EmployeeState.OptionsExercised,TMP_422(bool) = REF_224 == REF_225,REF_226(ESOPTypes.EmployeeState) -> emp.state,REF_227(ESOPTypes.EmployeeState) -> EmployeeState.WaitingForSignature,TMP_423(bool) = REF_226 == REF_227,TMP_424(bool) = TMP_422 || TMP_423,CONDITION TMP_424,RETURN 0,0,0,TMP_425(bool) = conversionOfferedAt > 0,TMP_426(bool) = calcAtTime >= conversionOfferedAt,TMP_427(bool) = TMP_425 && TMP_426,isESOPConverted(bool) := TMP_427(bool),REF_228(uint32) -> emp.poolOptions,REF_229(uint32) -> emp.extraOptions,TMP_428(uint32) = REF_228 + REF_229,issuedOptions(uint256) := TMP_428(uint32),TMP_429(bool) = issuedOptions == 0,CONDITION TMP_429,RETURN 0,0,0,REF_230(uint32) -> emp.terminatedAt,TMP_430(bool) = calcAtTime < REF_230,REF_231(uint32) -> emp.terminatedAt,TMP_431(bool) = REF_231 > 0,TMP_432(bool) = TMP_430 && TMP_431,CONDITION TMP_432,REF_232(ESOPTypes.EmployeeState) -> emp.state,REF_233(ESOPTypes.EmployeeState) -> EmployeeState.Employed,REF_232(ESOPTypes.EmployeeState) (->emp) := REF_233(ESOPTypes.EmployeeState),vestedOptions(uint256) := issuedOptions(uint256),REF_234(ESOPTypes.EmployeeState) -> emp.state,REF_235(ESOPTypes.EmployeeState) -> EmployeeState.Employed,TMP_433(bool) = REF_234 == REF_235,TMP_434(bool) = isESOPConverted && TMP_433,TMP_435 = UnaryType.BANG disableAcceleratedVesting ,TMP_436(bool) = TMP_434 && TMP_435,accelerateVesting(bool) := TMP_436(bool),TMP_437 = UnaryType.BANG accelerateVesting ,CONDITION TMP_437,REF_236(uint32) -> emp.issueDate,TMP_438(uint256) = INTERNAL_CALL, OptionsCalculator.calculateVestedOptions(uint256,uint256,uint256)(calcVestingAt,REF_236,issuedOptions),vestedOptions(uint256) := TMP_438(uint256),REF_237(ESOPTypes.EmployeeState) -> emp.state,REF_238(ESOPTypes.EmployeeState) -> EmployeeState.Terminated,TMP_439(bool) = REF_237 == REF_238,CONDITION TMP_439,REF_239(uint32) -> emp.poolOptions,REF_240(uint32) -> emp.extraOptions,TUPLE_3(uint256,uint256) = INTERNAL_CALL, OptionsCalculator.extractVestedOptionsComponents(uint256,uint256,uint256)(REF_239,REF_240,vestedOptions),vestedPoolOptions(uint256)= UNPACK TUPLE_3 index: 0 ,vestedExtraOptions(uint256)= UNPACK TUPLE_3 index: 1 ,REF_241(ESOPTypes.EmployeeState) -> emp.state,REF_242(ESOPTypes.EmployeeState) -> EmployeeState.Terminated,TMP_440(bool) = REF_241 == REF_242,CONDITION TMP_440,REF_243(uint32) -> emp.terminatedAt,calcVestingAt(uint32) := REF_243(uint32),CONDITION isESOPConverted,REF_244(uint32) -> emp.issueDate,REF_245(uint32) -> emp.terminatedAt,TMP_441(uint256) = INTERNAL_CALL, OptionsCalculator.applyFadeoutToOptions(uint32,uint32,uint32,uint256,uint256)(conversionOfferedAt,REF_244,REF_245,issuedOptions,vestedOptions),vestedOptions(uint256) := TMP_441(uint256),REF_246(uint32) -> emp.issueDate,REF_247(uint32) -> emp.terminatedAt,TMP_442(uint256) = INTERNAL_CALL, OptionsCalculator.applyFadeoutToOptions(uint32,uint32,uint32,uint256,uint256)(calcAtTime,REF_246,REF_247,issuedOptions,vestedOptions),vestedOptions(uint256) := TMP_442(uint256),CONDITION accelerateVesting,TMP_443(uint256) = vestedPoolOptions * bonusOptionsPromille,TMP_444(uint256) = INTERNAL_CALL, Math.divRound(uint256,uint256)(TMP_443,FP_SCALE),RETURN vestedPoolOptions,vestedExtraOptions,TMP_444,RETURN vestedPoolOptions,vestedExtraOptions,0,REF_248(uint32) -> emp.suspendedAt,TMP_445(bool) = REF_248 > 0,REF_249(uint32) -> emp.suspendedAt,TMP_446(bool) = REF_249 < calcAtTime,TMP_447(bool) = TMP_445 && TMP_446,CONDITION TMP_447,REF_250(uint32) -> emp.suspendedAt,calcVestingAt(uint32) := REF_250(uint32),TMP_448(bool) = conversionOfferedAt > 0,CONDITION TMP_448,calcVestingAt(uint32) := conversionOfferedAt(uint32),calcVestingAt(uint32) := calcAtTime(uint32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
emp = deserializeEmployee(employee)

IRs:
TMP_421(ESOPTypes.Employee) = INTERNAL_CALL, ESOPTypes.deserializeEmployee(uint256[9])(employee)
emp(ESOPTypes.Employee) := TMP_421(ESOPTypes.Employee)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
emp.state == EmployeeState.OptionsExercised || emp.state == EmployeeState.WaitingForSignature

IRs:
REF_224(ESOPTypes.EmployeeState) -> emp.state
REF_225(ESOPTypes.EmployeeState) -> EmployeeState.OptionsExercised
TMP_422(bool) = REF_224 == REF_225
REF_226(ESOPTypes.EmployeeState) -> emp.state
REF_227(ESOPTypes.EmployeeState) -> EmployeeState.WaitingForSignature
TMP_423(bool) = REF_226 == REF_227
TMP_424(bool) = TMP_422 || TMP_423
CONDITION TMP_424""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3

EXPRESSION:
(0,0,0)

IRs:
RETURN 0,0,0""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
isESOPConverted = conversionOfferedAt > 0 && calcAtTime >= conversionOfferedAt

IRs:
TMP_425(bool) = conversionOfferedAt > 0
TMP_426(bool) = calcAtTime >= conversionOfferedAt
TMP_427(bool) = TMP_425 && TMP_426
isESOPConverted(bool) := TMP_427(bool)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
issuedOptions = emp.poolOptions + emp.extraOptions

IRs:
REF_228(uint32) -> emp.poolOptions
REF_229(uint32) -> emp.extraOptions
TMP_428(uint32) = REF_228 + REF_229
issuedOptions(uint256) := TMP_428(uint32)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
issuedOptions == 0

IRs:
TMP_429(bool) = issuedOptions == 0
CONDITION TMP_429""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: RETURN 8

EXPRESSION:
(0,0,0)

IRs:
RETURN 0,0,0""];
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
calcAtTime < emp.terminatedAt && emp.terminatedAt > 0

IRs:
REF_230(uint32) -> emp.terminatedAt
TMP_430(bool) = calcAtTime < REF_230
REF_231(uint32) -> emp.terminatedAt
TMP_431(bool) = REF_231 > 0
TMP_432(bool) = TMP_430 && TMP_431
CONDITION TMP_432""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
emp.state = EmployeeState.Employed

IRs:
REF_232(ESOPTypes.EmployeeState) -> emp.state
REF_233(ESOPTypes.EmployeeState) -> EmployeeState.Employed
REF_232(ESOPTypes.EmployeeState) (->emp) := REF_233(ESOPTypes.EmployeeState)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
vestedOptions = issuedOptions

IRs:
vestedOptions(uint256) := issuedOptions(uint256)""];
13->14;
14[label=""Node Type: NEW VARIABLE 14

EXPRESSION:
accelerateVesting = isESOPConverted && emp.state == EmployeeState.Employed && ! disableAcceleratedVesting

IRs:
REF_234(ESOPTypes.EmployeeState) -> emp.state
REF_235(ESOPTypes.EmployeeState) -> EmployeeState.Employed
TMP_433(bool) = REF_234 == REF_235
TMP_434(bool) = isESOPConverted && TMP_433
TMP_435 = UnaryType.BANG disableAcceleratedVesting 
TMP_436(bool) = TMP_434 && TMP_435
accelerateVesting(bool) := TMP_436(bool)""];
14->15;
15[label=""Node Type: IF 15

EXPRESSION:
! accelerateVesting

IRs:
TMP_437 = UnaryType.BANG accelerateVesting 
CONDITION TMP_437""];
15->26[label=""True""];
15->18[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
vestedOptions = calculateVestedOptions(calcVestingAt,emp.issueDate,issuedOptions)

IRs:
REF_236(uint32) -> emp.issueDate
TMP_438(uint256) = INTERNAL_CALL, OptionsCalculator.calculateVestedOptions(uint256,uint256,uint256)(calcVestingAt,REF_236,issuedOptions)
vestedOptions(uint256) := TMP_438(uint256)""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: IF 19

EXPRESSION:
emp.state == EmployeeState.Terminated

IRs:
REF_237(ESOPTypes.EmployeeState) -> emp.state
REF_238(ESOPTypes.EmployeeState) -> EmployeeState.Terminated
TMP_439(bool) = REF_237 == REF_238
CONDITION TMP_439""];
19->30[label=""True""];
19->21[label=""False""];
21[label=""Node Type: END_IF 21
""];
21->22;
22[label=""Node Type: NEW VARIABLE 22
""];
22->23;
23[label=""Node Type: NEW VARIABLE 23
""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
(vestedPoolOptions,vestedExtraOptions) = extractVestedOptionsComponents(emp.poolOptions,emp.extraOptions,vestedOptions)

IRs:
REF_239(uint32) -> emp.poolOptions
REF_240(uint32) -> emp.extraOptions
TUPLE_3(uint256,uint256) = INTERNAL_CALL, OptionsCalculator.extractVestedOptionsComponents(uint256,uint256,uint256)(REF_239,REF_240,vestedOptions)
vestedPoolOptions(uint256)= UNPACK TUPLE_3 index: 0 
vestedExtraOptions(uint256)= UNPACK TUPLE_3 index: 1 ""];
24->34;
26[label=""Node Type: IF 26

EXPRESSION:
emp.state == EmployeeState.Terminated

IRs:
REF_241(ESOPTypes.EmployeeState) -> emp.state
REF_242(ESOPTypes.EmployeeState) -> EmployeeState.Terminated
TMP_440(bool) = REF_241 == REF_242
CONDITION TMP_440""];
26->27[label=""True""];
26->38[label=""False""];
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
calcVestingAt = emp.terminatedAt

IRs:
REF_243(uint32) -> emp.terminatedAt
calcVestingAt(uint32) := REF_243(uint32)""];
27->29;
29[label=""Node Type: END_IF 29
""];
29->17;
30[label=""Node Type: IF 30

EXPRESSION:
isESOPConverted

IRs:
CONDITION isESOPConverted""];
30->31[label=""True""];
30->32[label=""False""];
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
vestedOptions = applyFadeoutToOptions(conversionOfferedAt,emp.issueDate,emp.terminatedAt,issuedOptions,vestedOptions)

IRs:
REF_244(uint32) -> emp.issueDate
REF_245(uint32) -> emp.terminatedAt
TMP_441(uint256) = INTERNAL_CALL, OptionsCalculator.applyFadeoutToOptions(uint32,uint32,uint32,uint256,uint256)(conversionOfferedAt,REF_244,REF_245,issuedOptions,vestedOptions)
vestedOptions(uint256) := TMP_441(uint256)""];
31->33;
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
vestedOptions = applyFadeoutToOptions(calcAtTime,emp.issueDate,emp.terminatedAt,issuedOptions,vestedOptions)

IRs:
REF_246(uint32) -> emp.issueDate
REF_247(uint32) -> emp.terminatedAt
TMP_442(uint256) = INTERNAL_CALL, OptionsCalculator.applyFadeoutToOptions(uint32,uint32,uint32,uint256,uint256)(calcAtTime,REF_246,REF_247,issuedOptions,vestedOptions)
vestedOptions(uint256) := TMP_442(uint256)""];
32->33;
33[label=""Node Type: END_IF 33
""];
33->21;
34[label=""Node Type: IF 34

EXPRESSION:
accelerateVesting

IRs:
CONDITION accelerateVesting""];
34->35[label=""True""];
34->36[label=""False""];
35[label=""Node Type: RETURN 35

EXPRESSION:
(vestedPoolOptions,vestedExtraOptions,divRound(vestedPoolOptions * bonusOptionsPromille,FP_SCALE))

IRs:
TMP_443(uint256) = vestedPoolOptions * bonusOptionsPromille
TMP_444(uint256) = INTERNAL_CALL, Math.divRound(uint256,uint256)(TMP_443,FP_SCALE)
RETURN vestedPoolOptions,vestedExtraOptions,TMP_444""];
36[label=""Node Type: RETURN 36

EXPRESSION:
(vestedPoolOptions,vestedExtraOptions,0)

IRs:
RETURN vestedPoolOptions,vestedExtraOptions,0""];
38[label=""Node Type: IF 38

EXPRESSION:
emp.suspendedAt > 0 && emp.suspendedAt < calcAtTime

IRs:
REF_248(uint32) -> emp.suspendedAt
TMP_445(bool) = REF_248 > 0
REF_249(uint32) -> emp.suspendedAt
TMP_446(bool) = REF_249 < calcAtTime
TMP_447(bool) = TMP_445 && TMP_446
CONDITION TMP_447""];
38->39[label=""True""];
38->42[label=""False""];
39[label=""Node Type: EXPRESSION 39

EXPRESSION:
calcVestingAt = emp.suspendedAt

IRs:
REF_250(uint32) -> emp.suspendedAt
calcVestingAt(uint32) := REF_250(uint32)""];
39->41;
41[label=""Node Type: END_IF 41
""];
41->29;
42[label=""Node Type: IF 42

EXPRESSION:
conversionOfferedAt > 0

IRs:
TMP_448(bool) = conversionOfferedAt > 0
CONDITION TMP_448""];
42->43[label=""True""];
42->44[label=""False""];
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
calcVestingAt = conversionOfferedAt

IRs:
calcVestingAt(uint32) := conversionOfferedAt(uint32)""];
43->45;
44[label=""Node Type: EXPRESSION 44

EXPRESSION:
calcVestingAt = calcAtTime

IRs:
calcVestingAt(uint32) := calcAtTime(uint32)""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->41;
}
",0,1,0,0,"emp = deserializeEmployee(employee);emp.state == EmployeeState.OptionsExercised || emp.state == EmployeeState.WaitingForSignature;(0,0,0);;isESOPConverted = conversionOfferedAt > 0 && calcAtTime >= conversionOfferedAt;issuedOptions = emp.poolOptions + emp.extraOptions;issuedOptions == 0;(0,0,0);;calcAtTime < emp.terminatedAt && emp.terminatedAt > 0;emp.state = EmployeeState.Employed;;vestedOptions = issuedOptions;accelerateVesting = isESOPConverted && emp.state == EmployeeState.Employed && ! disableAcceleratedVesting;! accelerateVesting;emp.state == EmployeeState.Terminated;;vestedOptions = calculateVestedOptions(calcVestingAt,emp.issueDate,issuedOptions);emp.state == EmployeeState.Terminated;isESOPConverted;;;;(vestedPoolOptions,vestedExtraOptions) = extractVestedOptionsComponents(emp.poolOptions,emp.extraOptions,vestedOptions);accelerateVesting;calcVestingAt = emp.terminatedAt;emp.suspendedAt > 0 && emp.suspendedAt < calcAtTime;;vestedOptions = applyFadeoutToOptions(conversionOfferedAt,emp.issueDate,emp.terminatedAt,issuedOptions,vestedOptions);vestedOptions = applyFadeoutToOptions(calcAtTime,emp.issueDate,emp.terminatedAt,issuedOptions,vestedOptions);;(vestedPoolOptions,vestedExtraOptions,divRound(vestedPoolOptions * bonusOptionsPromille,FP_SCALE));(vestedPoolOptions,vestedExtraOptions,0);calcVestingAt = emp.suspendedAt;conversionOfferedAt > 0;;calcVestingAt = conversionOfferedAt;calcVestingAt = calcAtTime;"
./0xbfaacfdecfbbcc7ea8c17e19c8f4f84c523267de_ext.sol,NokuConsumptionPlan.addService,323,332,"TMP_96(bool) = INTERNAL_CALL, NokuConsumptionPlan.isService(bytes32)(_serviceName),TMP_97 = UnaryType.BANG TMP_96 ,TMP_98(None) = SOLIDITY_CALL require(bool,string)(TMP_97,_serviceName already present),REF_11(NokuConsumptionPlan.NokuService) -> services[_serviceName],REF_12(uint256) -> REF_11.serviceFee,REF_12(uint256) (->services) := _serviceFee(uint256),REF_13(NokuConsumptionPlan.NokuService) -> services[_serviceName],REF_14(uint256) -> REF_13.index,REF_16 -> LENGTH serviceIndex,TMP_101(uint256) := REF_16(uint256),TMP_102(uint256) = TMP_101 + 1,REF_16(uint256) (->serviceIndex) := TMP_102(uint256),REF_17(bytes32) -> serviceIndex[TMP_101],REF_17(bytes32) (->serviceIndex) := _serviceName(bytes32),TMP_100(None) = TMP_99 - 1,REF_14(uint256) (->services) := TMP_100(None),REF_18 -> LENGTH serviceIndex,TMP_103(uint256) = REF_18 - 1,Emit LogServiceAdded(_serviceName,TMP_103,_serviceFee),REF_19 -> LENGTH serviceIndex,TMP_105(uint256) = REF_19 - 1,RETURN TMP_105,MODIFIER_CALL, Ownable.onlyOwner()(),RETURN index","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(! isService(_serviceName),_serviceName already present)

IRs:
TMP_96(bool) = INTERNAL_CALL, NokuConsumptionPlan.isService(bytes32)(_serviceName)
TMP_97 = UnaryType.BANG TMP_96 
TMP_98(None) = SOLIDITY_CALL require(bool,string)(TMP_97,_serviceName already present)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
services[_serviceName].serviceFee = _serviceFee

IRs:
REF_11(NokuConsumptionPlan.NokuService) -> services[_serviceName]
REF_12(uint256) -> REF_11.serviceFee
REF_12(uint256) (->services) := _serviceFee(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
services[_serviceName].index = serviceIndex.push(_serviceName) - 1

IRs:
REF_13(NokuConsumptionPlan.NokuService) -> services[_serviceName]
REF_14(uint256) -> REF_13.index
REF_16 -> LENGTH serviceIndex
TMP_101(uint256) := REF_16(uint256)
TMP_102(uint256) = TMP_101 + 1
REF_16(uint256) (->serviceIndex) := TMP_102(uint256)
REF_17(bytes32) -> serviceIndex[TMP_101]
REF_17(bytes32) (->serviceIndex) := _serviceName(bytes32)
TMP_100(None) = TMP_99 - 1
REF_14(uint256) (->services) := TMP_100(None)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
LogServiceAdded(_serviceName,serviceIndex.length - 1,_serviceFee)

IRs:
REF_18 -> LENGTH serviceIndex
TMP_103(uint256) = REF_18 - 1
Emit LogServiceAdded(_serviceName,TMP_103,_serviceFee)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
serviceIndex.length - 1

IRs:
REF_19 -> LENGTH serviceIndex
TMP_105(uint256) = REF_19 - 1
RETURN TMP_105""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
7[label=""Node Type: RETURN 7

EXPRESSION:
index

IRs:
RETURN index""];
}
",0,1,0,0,"onlyOwner();require(bool,string)(! isService(_serviceName),_serviceName already present);services[_serviceName].serviceFee = _serviceFee;services[_serviceName].index = serviceIndex.push(_serviceName) - 1;LogServiceAdded(_serviceName,serviceIndex.length - 1,_serviceFee);serviceIndex.length - 1;index"
./0x190e2028060fa49adefa5e1f47c8d7be0cbe5063_ext.sol,TRONIXGOLD.approveAndCall,204,209,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x00fee04ea211711aaeb18a562be88c140cff4c24_ext.sol,OpayToken.transferFrom,111,127,"REF_5(mapping(address => uint256)) -> allowed[_from],REF_6(uint256) -> REF_5[msg.sender],allowance(uint256) := REF_6(uint256),REF_7(uint256) -> balances[_from],TMP_29(bool) = REF_7 >= _value,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),TMP_31(bool) = _from == _to,REF_8(uint256) -> balances[_to],TMP_32(uint256) = MAX_UINT256 - _value,TMP_33(bool) = REF_8 <= TMP_32,TMP_34(bool) = TMP_31 || TMP_33,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),TMP_36(bool) = allowance >= _value,TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36),REF_9(uint256) -> balances[_from],REF_9(-> balances) = REF_9 - _value,REF_10(uint256) -> balances[_to],REF_10(-> balances) = REF_10 + _value,TMP_38(bool) = allowance < MAX_UINT256,CONDITION TMP_38,REF_11(mapping(address => uint256)) -> allowed[_from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowed) = REF_12 - _value,Emit Transfer(_from,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
allowance = allowed[_from][msg.sender]

IRs:
REF_5(mapping(address => uint256)) -> allowed[_from]
REF_6(uint256) -> REF_5[msg.sender]
allowance(uint256) := REF_6(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] >= _value)

IRs:
REF_7(uint256) -> balances[_from]
TMP_29(bool) = REF_7 >= _value
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_from == _to || balances[_to] <= MAX_UINT256 - _value)

IRs:
TMP_31(bool) = _from == _to
REF_8(uint256) -> balances[_to]
TMP_32(uint256) = MAX_UINT256 - _value
TMP_33(bool) = REF_8 <= TMP_32
TMP_34(bool) = TMP_31 || TMP_33
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(allowance >= _value)

IRs:
TMP_36(bool) = allowance >= _value
TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[_from] -= _value

IRs:
REF_9(uint256) -> balances[_from]
REF_9(-> balances) = REF_9 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[_to] += _value

IRs:
REF_10(uint256) -> balances[_to]
REF_10(-> balances) = REF_10 + _value""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
allowance < MAX_UINT256

IRs:
TMP_38(bool) = allowance < MAX_UINT256
CONDITION TMP_38""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_11(mapping(address => uint256)) -> allowed[_from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowed) = REF_12 - _value""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
10->11;
11[label=""Node Type: RETURN 11

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"allowance = allowed[_from][msg.sender];require(bool)(balances[_from] >= _value);require(bool)(_from == _to || balances[_to] <= MAX_UINT256 - _value);require(bool)(allowance >= _value);balances[_from] -= _value;balances[_to] += _value;allowance < MAX_UINT256;allowed[_from][msg.sender] -= _value;;Transfer(_from,_to,_value);true"
./0xb3939627b9775c3b76c05138d281c7f92e251aab_ext.sol,LespNetWork.transfer,96,106,"REF_1(uint256) -> balances[msg.sender],TMP_21(bool) = REF_1 >= _value,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),TMP_23(bool) = msg.sender == _to,REF_2(uint256) -> balances[_to],TMP_24(uint256) = MAX_UINT256 - _value,TMP_25(bool) = REF_2 <= TMP_24,TMP_26(bool) = TMP_23 || TMP_25,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_3(uint256) -> balances[msg.sender],REF_3(-> balances) = REF_3 - _value,REF_4(uint256) -> balances[_to],REF_4(-> balances) = REF_4 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_21(bool) = REF_1 >= _value
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == _to || balances[_to] <= MAX_UINT256 - _value)

IRs:
TMP_23(bool) = msg.sender == _to
REF_2(uint256) -> balances[_to]
TMP_24(uint256) = MAX_UINT256 - _value
TMP_25(bool) = REF_2 <= TMP_24
TMP_26(bool) = TMP_23 || TMP_25
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_3(uint256) -> balances[msg.sender]
REF_3(-> balances) = REF_3 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] += _value

IRs:
REF_4(uint256) -> balances[_to]
REF_4(-> balances) = REF_4 + _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);require(bool)(msg.sender == _to || balances[_to] <= MAX_UINT256 - _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true"
./0x26bf81f017a7149576dc5d82323172fcae9fd469_ext.sol,PhxGo.mutiSendETHWithDifferentValue,340,342,"INTERNAL_CALL, PhxGo.ethSendDifferentValue(address[],uint256[])(_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ethSendDifferentValue(_to,_value)

IRs:
INTERNAL_CALL, PhxGo.ethSendDifferentValue(address[],uint256[])(_to,_value)""];
}
",0,1,0,0,"ethSendDifferentValue(_to,_value)"
./0x00685230359bdb9e16704e1d3918b553e9a015e2_ext.sol,DigitalPrintImage.createImage,1219,1269,"REF_264 -> LENGTH _potentialAssets,TMP_457(bool) = REF_264 <= 5,TMP_458(None) = SOLIDITY_CALL require(bool)(TMP_457),REF_265(address) -> usernameToAddress[_author],TMP_459(bool) = msg.sender == REF_265,REF_266(bool) -> usernameExists[_author],TMP_460 = UnaryType.BANG REF_266 ,TMP_461(bool) = TMP_459 || TMP_460,TMP_462(None) = SOLIDITY_CALL require(bool)(TMP_461),REF_267(bool) -> usernameExists[_author],TMP_463 = UnaryType.BANG REF_267 ,CONDITION TMP_463,TMP_464 = CONVERT 0 to bytes32,INTERNAL_CALL, UserManager.register(string,bytes32)(_author,TMP_464),TUPLE_1(uint256[],uint256) = INTERNAL_CALL, DigitalPrintImage.getPickedAssetsAndFinalSeed(bytes32[],uint256[],uint256,uint256)(_potentialAssets,_randomHashIds,_timestamp,_iterations),pickedAssets(uint256[])= UNPACK TUPLE_1 index: 0 ,finalSeed(uint256)= UNPACK TUPLE_1 index: 1 ,TMP_466(uint256[]) = HIGH_LEVEL_CALL, dest:assetManager(IAssetManager), function:pickUniquePacks, arguments:['pickedAssets']  ,pickedAssetPacks(uint256[]) = ['TMP_466(uint256[])'],finalPrice(uint256) := 0(uint256),i(uint256) := 0(uint256),REF_269 -> LENGTH pickedAssetPacks,TMP_467(bool) = i < REF_269,CONDITION TMP_467,REF_271(uint256) -> pickedAssetPacks[i],TMP_468(bool) = HIGH_LEVEL_CALL, dest:assetManager(IAssetManager), function:checkHasPermissionForPack, arguments:['msg.sender', 'REF_271']  ,TMP_469(bool) = TMP_468 == False,CONDITION TMP_469,REF_273(uint256) -> pickedAssetPacks[i],TMP_470(uint256) = HIGH_LEVEL_CALL, dest:assetManager(IAssetManager), function:getAssetPackPrice, arguments:['REF_273']  ,finalPrice(uint256) = finalPrice + TMP_470,REF_277(uint256) -> pickedAssetPacks[i],TMP_471(uint256) = HIGH_LEVEL_CALL, dest:assetManager(IAssetManager), function:getAssetPackPrice, arguments:['REF_277']  ,REF_278(uint256) -> pickedAssetPacks[i],HIGH_LEVEL_CALL, dest:assetManager(IAssetManager), function:buyAssetPack, arguments:['msg.sender', 'REF_278'] value:TMP_471 ,TMP_474(uint256) := i(uint256),i(uint256) = i + 1,TMP_475(bool) = msg.value >= finalPrice,TMP_476(None) = SOLIDITY_CALL require(bool)(TMP_475),TMP_477(uint256) = INTERNAL_CALL, ERC721Token.totalSupply()(),id(uint256) := TMP_477(uint256),INTERNAL_CALL, ERC721Token._mint(address,uint256)(msg.sender,id),REF_279(DigitalPrintImage.ImageMetadata) -> imageMetadata[id],TMP_479(DigitalPrintImage.ImageMetadata) = new ImageMetadata(finalSeed,_potentialAssets,_timestamp,msg.sender,_ipfsHash,_extraData),REF_279(DigitalPrintImage.ImageMetadata) (->imageMetadata) := TMP_479(DigitalPrintImage.ImageMetadata),REF_280(string) -> idToIpfsHash[id],REF_280(string) (->idToIpfsHash) := _ipfsHash(string),REF_281(bool) -> seedExists[finalSeed],REF_281(bool) (->seedExists) := True(bool),Emit ImageCreated(id,msg.sender)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_potentialAssets.length <= 5)

IRs:
REF_264 -> LENGTH _potentialAssets
TMP_457(bool) = REF_264 <= 5
TMP_458(None) = SOLIDITY_CALL require(bool)(TMP_457)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == usernameToAddress[_author] || ! usernameExists[_author])

IRs:
REF_265(address) -> usernameToAddress[_author]
TMP_459(bool) = msg.sender == REF_265
REF_266(bool) -> usernameExists[_author]
TMP_460 = UnaryType.BANG REF_266 
TMP_461(bool) = TMP_459 || TMP_460
TMP_462(None) = SOLIDITY_CALL require(bool)(TMP_461)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
! usernameExists[_author]

IRs:
REF_267(bool) -> usernameExists[_author]
TMP_463 = UnaryType.BANG REF_267 
CONDITION TMP_463""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
register(_author,bytes32(0))

IRs:
TMP_464 = CONVERT 0 to bytes32
INTERNAL_CALL, UserManager.register(string,bytes32)(_author,TMP_464)""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: NEW VARIABLE 6
""];
6->7;
7[label=""Node Type: NEW VARIABLE 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
(pickedAssets,finalSeed) = getPickedAssetsAndFinalSeed(_potentialAssets,_randomHashIds,_timestamp,_iterations)

IRs:
TUPLE_1(uint256[],uint256) = INTERNAL_CALL, DigitalPrintImage.getPickedAssetsAndFinalSeed(bytes32[],uint256[],uint256,uint256)(_potentialAssets,_randomHashIds,_timestamp,_iterations)
pickedAssets(uint256[])= UNPACK TUPLE_1 index: 0 
finalSeed(uint256)= UNPACK TUPLE_1 index: 1 ""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
pickedAssetPacks = assetManager.pickUniquePacks(pickedAssets)

IRs:
TMP_466(uint256[]) = HIGH_LEVEL_CALL, dest:assetManager(IAssetManager), function:pickUniquePacks, arguments:['pickedAssets']  
pickedAssetPacks(uint256[]) = ['TMP_466(uint256[])']""];
9->10;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
finalPrice = 0

IRs:
finalPrice(uint256) := 0(uint256)""];
10->13;
11[label=""Node Type: BEGIN_LOOP 11
""];
11->14;
12[label=""Node Type: END_LOOP 12
""];
12->20;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
13->11;
14[label=""Node Type: IF_LOOP 14

EXPRESSION:
i < pickedAssetPacks.length

IRs:
REF_269 -> LENGTH pickedAssetPacks
TMP_467(bool) = i < REF_269
CONDITION TMP_467""];
14->15[label=""True""];
14->12[label=""False""];
15[label=""Node Type: IF 15

EXPRESSION:
assetManager.checkHasPermissionForPack(msg.sender,pickedAssetPacks[i]) == false

IRs:
REF_271(uint256) -> pickedAssetPacks[i]
TMP_468(bool) = HIGH_LEVEL_CALL, dest:assetManager(IAssetManager), function:checkHasPermissionForPack, arguments:['msg.sender', 'REF_271']  
TMP_469(bool) = TMP_468 == False
CONDITION TMP_469""];
15->16[label=""True""];
15->18[label=""False""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
finalPrice += assetManager.getAssetPackPrice(pickedAssetPacks[i])

IRs:
REF_273(uint256) -> pickedAssetPacks[i]
TMP_470(uint256) = HIGH_LEVEL_CALL, dest:assetManager(IAssetManager), function:getAssetPackPrice, arguments:['REF_273']  
finalPrice(uint256) = finalPrice + TMP_470""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
assetManager.buyAssetPack.value(assetManager.getAssetPackPrice(pickedAssetPacks[i]))(msg.sender,pickedAssetPacks[i])

IRs:
REF_277(uint256) -> pickedAssetPacks[i]
TMP_471(uint256) = HIGH_LEVEL_CALL, dest:assetManager(IAssetManager), function:getAssetPackPrice, arguments:['REF_277']  
REF_278(uint256) -> pickedAssetPacks[i]
HIGH_LEVEL_CALL, dest:assetManager(IAssetManager), function:buyAssetPack, arguments:['msg.sender', 'REF_278'] value:TMP_471 ""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
i ++

IRs:
TMP_474(uint256) := i(uint256)
i(uint256) = i + 1""];
19->14;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
require(bool)(msg.value >= finalPrice)

IRs:
TMP_475(bool) = msg.value >= finalPrice
TMP_476(None) = SOLIDITY_CALL require(bool)(TMP_475)""];
20->21;
21[label=""Node Type: NEW VARIABLE 21

EXPRESSION:
id = totalSupply()

IRs:
TMP_477(uint256) = INTERNAL_CALL, ERC721Token.totalSupply()()
id(uint256) := TMP_477(uint256)""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
_mint(msg.sender,id)

IRs:
INTERNAL_CALL, ERC721Token._mint(address,uint256)(msg.sender,id)""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
imageMetadata[id] = ImageMetadata({finalSeed:finalSeed,potentialAssets:_potentialAssets,timestamp:_timestamp,creator:msg.sender,ipfsHash:_ipfsHash,extraData:_extraData})

IRs:
REF_279(DigitalPrintImage.ImageMetadata) -> imageMetadata[id]
TMP_479(DigitalPrintImage.ImageMetadata) = new ImageMetadata(finalSeed,_potentialAssets,_timestamp,msg.sender,_ipfsHash,_extraData)
REF_279(DigitalPrintImage.ImageMetadata) (->imageMetadata) := TMP_479(DigitalPrintImage.ImageMetadata)""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
idToIpfsHash[id] = _ipfsHash

IRs:
REF_280(string) -> idToIpfsHash[id]
REF_280(string) (->idToIpfsHash) := _ipfsHash(string)""];
24->25;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
seedExists[finalSeed] = true

IRs:
REF_281(bool) -> seedExists[finalSeed]
REF_281(bool) (->seedExists) := True(bool)""];
25->26;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
ImageCreated(id,msg.sender)

IRs:
Emit ImageCreated(id,msg.sender)""];
}
",0,1,0,0,"require(bool)(_potentialAssets.length <= 5);require(bool)(msg.sender == usernameToAddress[_author] || ! usernameExists[_author]);! usernameExists[_author];register(_author,bytes32(0));;;;(pickedAssets,finalSeed) = getPickedAssetsAndFinalSeed(_potentialAssets,_randomHashIds,_timestamp,_iterations);pickedAssetPacks = assetManager.pickUniquePacks(pickedAssets);finalPrice = 0;i = 0;;i < pickedAssetPacks.length;;require(bool)(msg.value >= finalPrice);assetManager.checkHasPermissionForPack(msg.sender,pickedAssetPacks[i]) == false;finalPrice += assetManager.getAssetPackPrice(pickedAssetPacks[i]);;assetManager.buyAssetPack.value(assetManager.getAssetPackPrice(pickedAssetPacks[i]))(msg.sender,pickedAssetPacks[i]);i ++;id = totalSupply();_mint(msg.sender,id);imageMetadata[id] = ImageMetadata({finalSeed:finalSeed,potentialAssets:_potentialAssets,timestamp:_timestamp,creator:msg.sender,ipfsHash:_ipfsHash,extraData:_extraData});idToIpfsHash[id] = _ipfsHash;seedExists[finalSeed] = true;ImageCreated(id,msg.sender)"
./0x8c211128f8d232935afd80543e442f894a4355b7_ext.sol,SNcoin_Token.limitOfTeam,129,131,"REF_3(uint8) -> limits[limitTeamIdx],TMP_15(uint256) = 100 - REF_3,RETURN TMP_15,RETURN limit","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
100 - limits[limitTeamIdx]

IRs:
REF_3(uint8) -> limits[limitTeamIdx]
TMP_15(uint256) = 100 - REF_3
RETURN TMP_15""];
2[label=""Node Type: RETURN 2

EXPRESSION:
limit

IRs:
RETURN limit""];
}
",0,1,0,0,100 - limits[limitTeamIdx];limit
./0x207c92740ccbe446ac2e2f43fe1da52651cd8d3c_ext.sol,TJK.transfer,32,37,"REF_2(uint256) -> balances[msg.sender],TMP_2(bool) = REF_2 >= _value,TMP_3(bool) = _value > 0,TMP_4(bool) = TMP_2 && TMP_3,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_3(uint256) -> balances[msg.sender],REF_3(-> balances) = REF_3 - _value,REF_4(uint256) -> balances[_recipient],REF_4(-> balances) = REF_4 + _value,Emit Transfer(msg.sender,_recipient,_value),TMP_7(uint256) = 2 * 32,MODIFIER_CALL, TJK.onlyPayloadSize(uint256)(TMP_7)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value && _value > 0)

IRs:
REF_2(uint256) -> balances[msg.sender]
TMP_2(bool) = REF_2 >= _value
TMP_3(bool) = _value > 0
TMP_4(bool) = TMP_2 && TMP_3
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_3(uint256) -> balances[msg.sender]
REF_3(-> balances) = REF_3 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_recipient] += _value

IRs:
REF_4(uint256) -> balances[_recipient]
REF_4(-> balances) = REF_4 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_recipient,_value)

IRs:
Emit Transfer(msg.sender,_recipient,_value)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyPayloadSize(2 * 32)

IRs:
TMP_7(uint256) = 2 * 32
MODIFIER_CALL, TJK.onlyPayloadSize(uint256)(TMP_7)""];
5->1;
}
",0,1,0,0,"onlyPayloadSize(2 * 32);require(bool)(balances[msg.sender] >= _value && _value > 0);balances[msg.sender] -= _value;balances[_recipient] += _value;Transfer(msg.sender,_recipient,_value)"
./0xa5a15631eb0aa1d178cf2d2c6bec7732a80eab03_ext.sol,TokenERC20.burnFrom,164,172,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x4c0fbe1bb46612915e7967d2c3213cd4d87257ad_ext.sol,WhiteList.addWhiteBackersByList,620,624,"backerIndex(uint256) := 0(uint256),REF_132 -> LENGTH _backers,TMP_175(bool) = backerIndex < REF_132,CONDITION TMP_175,REF_133(address) -> _backers[backerIndex],INTERNAL_CALL, WhiteList.setWhiteBacker(address,bool)(REF_133,True),TMP_177(uint256) := backerIndex(uint256),backerIndex(uint256) = backerIndex + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
backerIndex = 0

IRs:
backerIndex(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
backerIndex < _backers.length

IRs:
REF_132 -> LENGTH _backers
TMP_175(bool) = backerIndex < REF_132
CONDITION TMP_175""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
setWhiteBacker(_backers[backerIndex],true)

IRs:
REF_133(address) -> _backers[backerIndex]
INTERNAL_CALL, WhiteList.setWhiteBacker(address,bool)(REF_133,True)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
backerIndex ++

IRs:
TMP_177(uint256) := backerIndex(uint256)
backerIndex(uint256) = backerIndex + 1""];
6->4;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->3;
}
",0,1,0,0,"onlyOwner();;backerIndex < _backers.length;;backerIndex = 0;setWhiteBacker(_backers[backerIndex],true);backerIndex ++"
./0xef7e7984a6e9a77a32eaf6153135526f09f3c794_ext.sol,TokenERC20.burn,146,152,"REF_17(uint256) -> balanceOf[msg.sender],TMP_26(bool) = REF_17 >= _value,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_26(bool) = REF_17 >= _value
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x1eebb0f896a8995aa95954a0870dc520eedc891f_ext.sol,CNYTokenPlus.burn,279,285,"REF_90(uint256) -> balances[msg.sender],TMP_71(bool) = REF_90 < _value,CONDITION TMP_71,REF_91(uint256) -> balances[msg.sender],REF_91(-> balances) = REF_91 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[msg.sender] < _value

IRs:
REF_90(uint256) -> balances[msg.sender]
TMP_71(bool) = REF_90 < _value
CONDITION TMP_71""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_91(uint256) -> balances[msg.sender]
REF_91(-> balances) = REF_91 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[msg.sender] < _value;;;balances[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x6b5ae67ee604f10e6429d74533ac15a57fa14572_ext.sol,LUCK.present,40,44,"bebdsds(address[]) := nanee(address[]),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
bebdsds = nanee

IRs:
bebdsds(address[]) := nanee(address[])""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,1,0,0,onlyOwner();bebdsds = nanee
./0xf064c38e3f5fa73981ee98372d32a16d032769cc_ext.sol,Studio.appendTokenHolders,89,96,"REF_3(uint256) -> balanceOf[tokenHolder],TMP_1(bool) = REF_3 == 0,CONDITION TMP_1,REF_4(address) -> accountIndex[accountCount],REF_4(address) (->accountIndex) := tokenHolder(address),TMP_2(uint256) := accountCount(uint256),accountCount(uint256) = accountCount + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balanceOf[tokenHolder] == 0

IRs:
REF_3(uint256) -> balanceOf[tokenHolder]
TMP_1(bool) = REF_3 == 0
CONDITION TMP_1""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
accountIndex[accountCount] = tokenHolder

IRs:
REF_4(address) -> accountIndex[accountCount]
REF_4(address) (->accountIndex) := tokenHolder(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
accountCount ++

IRs:
TMP_2(uint256) := accountCount(uint256)
accountCount(uint256) = accountCount + 1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,balanceOf[tokenHolder] == 0;accountIndex[accountCount] = tokenHolder;;accountCount ++
./0xdcedcc689487b3c767e37cd2f198d40566294b20_ext.sol,TianqibaoTokenERC20.burn,128,134,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x5862ae475da22367076b89a6f782ea6711eb2949_ext.sol,ZToken.mintToken,208,213,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x367125be15fc3a0d78321dafa75be6c8e0941921_ext.sol,LanxangCash.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x71583506d41a604bc4bf178472ef1a495131cd45_ext.sol,GMQToken.burn,133,139,"REF_17(uint256) -> balanceOf[msg.sender],TMP_23(bool) = REF_17 >= _value,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_23(bool) = REF_17 >= _value
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x539bff788404c395117dd2dfdcc3d5e00a72d3b7_ext.sol,EdenwToken.mintToken,213,218,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x47df2f172d2f387a602a85adff876a8ef535cf62_ext.sol,TicketsCoin.transfer,21,28,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x6d4032d39350a4359b03495c08ef3aee8fcc1d3c_ext.sol,BitSteveCoin.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x5059601b10af5faf69633692abe1d6a877d2be87_ext.sol,CryptoyatToken.approveAndCall,147,152,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xb487d45f2d2a93b84e8f8c5074e256896bbf7d9c_ext.sol,ERC721._transfer,210,223,"REF_18(uint256) -> ownershipTokenCount[_to],TMP_57(uint256) := REF_18(uint256),REF_18(-> ownershipTokenCount) = REF_18 + 1,REF_19(address) -> tokenIndexToOwner[_tokenId],REF_19(address) (->tokenIndexToOwner) := _to(address),TMP_58 = CONVERT 0 to address,TMP_59(bool) = _from != TMP_58,CONDITION TMP_59,Emit Transfer(_from,_to,_tokenId),REF_20(uint256) -> ownershipTokenCount[_from],TMP_61(uint256) := REF_20(uint256),REF_20(-> ownershipTokenCount) = REF_20 - 1,REF_21(address) -> tokenIndexToApproved[_tokenId],tokenIndexToApproved = delete REF_21 ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownershipTokenCount[_to] ++

IRs:
REF_18(uint256) -> ownershipTokenCount[_to]
TMP_57(uint256) := REF_18(uint256)
REF_18(-> ownershipTokenCount) = REF_18 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
tokenIndexToOwner[_tokenId] = _to

IRs:
REF_19(address) -> tokenIndexToOwner[_tokenId]
REF_19(address) (->tokenIndexToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_58 = CONVERT 0 to address
TMP_59(bool) = _from != TMP_58
CONDITION TMP_59""];
3->4[label=""True""];
3->7[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
ownershipTokenCount[_from] --

IRs:
REF_20(uint256) -> ownershipTokenCount[_from]
TMP_61(uint256) := REF_20(uint256)
REF_20(-> ownershipTokenCount) = REF_20 - 1""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
delete tokenIndexToApproved[_tokenId]

IRs:
REF_21(address) -> tokenIndexToApproved[_tokenId]
tokenIndexToApproved = delete REF_21 ""];
6->7;
7[label=""Node Type: END_IF 7
""];
}
",0,1,0,0,"ownershipTokenCount[_to] ++;tokenIndexToOwner[_tokenId] = _to;_from != address(0);Transfer(_from,_to,_tokenId);;ownershipTokenCount[_from] --;delete tokenIndexToApproved[_tokenId]"
./0x9249dd4b12af8d8a0490fe1923bada3e5cc83c07_ext.sol,MintableToken.mint,178,184,"totalSupply(uint256) = totalSupply + _amount,REF_50(uint256) -> balances[_to],REF_50(-> balances) = REF_50 + _amount,Emit Mint(_to,_amount),TMP_57 = CONVERT 0 to address,Emit Transfer(TMP_57,_to,_amount),RETURN True,MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, MintableToken.canMint()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
totalSupply += _amount

IRs:
totalSupply(uint256) = totalSupply + _amount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _amount

IRs:
REF_50(uint256) -> balances[_to]
REF_50(-> balances) = REF_50 + _amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Mint(_to,_amount)

IRs:
Emit Mint(_to,_amount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(address(0),_to,_amount)

IRs:
TMP_57 = CONVERT 0 to address
Emit Transfer(TMP_57,_to,_amount)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
canMint()

IRs:
MODIFIER_CALL, MintableToken.canMint()()""];
7->1;
}
",0,1,0,0,"onlyOwner();totalSupply += _amount;balances[_to] += _amount;Mint(_to,_amount);Transfer(address(0),_to,_amount);true;canMint()"
./0x17d32b5d528979bfa60897ba8716b7c96f9e8ea7_ext.sol,MyToken._transfer,22,31,"TMP_4(bool) = _to != 0,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_1(uint256) -> balanceOf[_from],TMP_6(bool) = REF_1 >= _value,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_2(uint256) -> balanceOf[_to],TMP_8(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_9(bool) = TMP_8 > REF_3,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_11(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_11(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_13(uint256) = REF_8 + REF_9,TMP_14(bool) = TMP_13 == previousBalances,TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_4(bool) = _to != 0
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_6(bool) = REF_1 >= _value
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value > balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_8(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_9(bool) = TMP_8 > REF_3
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_11(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_11(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_13(uint256) = REF_8 + REF_9
TMP_14(bool) = TMP_13 == previousBalances
TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value > balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x6de8f49a47f4cdcf7cb69cafb1b6a74a4f38d113_ext.sol,TokenDrop.multiTransfer,34,40,"i(uint256) := 0(uint256),REF_0 -> LENGTH _to,TMP_1(bool) = i < REF_0,CONDITION TMP_1,REF_2(address) -> _to[i],TMP_2(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['REF_2', '_value']  ,TMP_3(uint256) := i(uint256),i(uint256) = i + 1,RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
2->7;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _to.length

IRs:
REF_0 -> LENGTH _to
TMP_1(bool) = i < REF_0
CONDITION TMP_1""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
token.transfer(_to[i],_value)

IRs:
REF_2(address) -> _to[i]
TMP_2(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['REF_2', '_value']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_3(uint256) := i(uint256)
i(uint256) = i + 1""];
6->4;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"i = 0;;i < _to.length;;true;token.transfer(_to[i],_value);i ++"
./0x036a98e540599dae4a9778335ffabe6ca01ca705_ext.sol,cwallet.withdraw,13,21,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2),TMP_4(bool) = keyHash == TMP_3,CONDITION TMP_4,TMP_5(bool) = msg.value > 400000000000000000,CONDITION TMP_5,TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),Transfer dest:msg.sender value:TMP_7","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
keyHash == keccak256()(abi.encodePacked(key))

IRs:
TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2)
TMP_4(bool) = keyHash == TMP_3
CONDITION TMP_4""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
msg.value > 400000000000000000

IRs:
TMP_5(bool) = msg.value > 400000000000000000
CONDITION TMP_5""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
Transfer dest:msg.sender value:TMP_7""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,1,0,0,require(bool)(msg.sender == tx.origin);keyHash == keccak256()(abi.encodePacked(key));msg.value > 400000000000000000;;msg.sender.transfer(address(this).balance);
./0x5bb5fbae51b4db016abc94fbb1bfff5a67f123e7_ext.sol,GodsOfOlympus.entryFee,418,437,"TMP_109 = CONVERT this to address,TMP_110(uint256) = SOLIDITY_CALL balance(address)(TMP_109),TMP_111(uint256) = TMP_110 - msg.value,volume(uint256) := TMP_111(uint256),TMP_112(bool) = volume <= 10000000000000000000,CONDITION TMP_112,RETURN 40,TMP_113(bool) = volume <= 20000000000000000000,CONDITION TMP_113,RETURN 35,TMP_114(bool) = volume <= 50000000000000000000,CONDITION TMP_114,RETURN 30,TMP_115(bool) = volume <= 100000000000000000000,CONDITION TMP_115,RETURN 25,TMP_116(bool) = volume <= 250000000000000000000,CONDITION TMP_116,RETURN 20,RETURN 15","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
volume = address(this).balance - msg.value

IRs:
TMP_109 = CONVERT this to address
TMP_110(uint256) = SOLIDITY_CALL balance(address)(TMP_109)
TMP_111(uint256) = TMP_110 - msg.value
volume(uint256) := TMP_111(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
volume <= 10000000000000000000

IRs:
TMP_112(bool) = volume <= 10000000000000000000
CONDITION TMP_112""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3

EXPRESSION:
40

IRs:
RETURN 40""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
volume <= 20000000000000000000

IRs:
TMP_113(bool) = volume <= 20000000000000000000
CONDITION TMP_113""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: RETURN 6

EXPRESSION:
35

IRs:
RETURN 35""];
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
volume <= 50000000000000000000

IRs:
TMP_114(bool) = volume <= 50000000000000000000
CONDITION TMP_114""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
30

IRs:
RETURN 30""];
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
volume <= 100000000000000000000

IRs:
TMP_115(bool) = volume <= 100000000000000000000
CONDITION TMP_115""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: RETURN 12

EXPRESSION:
25

IRs:
RETURN 25""];
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
volume <= 250000000000000000000

IRs:
TMP_116(bool) = volume <= 250000000000000000000
CONDITION TMP_116""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: RETURN 15

EXPRESSION:
20

IRs:
RETURN 20""];
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: RETURN 17

EXPRESSION:
15

IRs:
RETURN 15""];
}
",0,1,0,0,volume = address(this).balance - msg.value;volume <= 10000000000000000000;40;;volume <= 20000000000000000000;35;;volume <= 50000000000000000000;30;;volume <= 100000000000000000000;25;;volume <= 250000000000000000000;20;;15
./0x6f5ac8fda08c00c38380777f00e265d4951b6f59_ext.sol,QUIZ.NewQuestion,34,39,"TMP_12(bool) = msg.sender == questionSender,CONDITION TMP_12,question(string) := _question(string),responseHash(bytes32) := _responseHash(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == questionSender

IRs:
TMP_12(bool) = msg.sender == questionSender
CONDITION TMP_12""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
responseHash = _responseHash

IRs:
responseHash(bytes32) := _responseHash(bytes32)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,msg.sender == questionSender;question = _question;;responseHash = _responseHash
./0xdfb9e87ff81cb089484ef8150a21be80f6cdd401_ext.sol,CRYPTOPOKER._transfer,41,57,"TMP_6(bool) = _to != 0,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_1(uint256) -> balanceOf[_from],TMP_8(bool) = REF_1 >= _value,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_2(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_11(bool) = TMP_10 >= REF_3,TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_13(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_13(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_15(uint256) = REF_8 + REF_9,TMP_16(bool) = TMP_15 == previousBalances,TMP_17(None) = SOLIDITY_CALL assert(bool)(TMP_16)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_6(bool) = _to != 0
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_8(bool) = REF_1 >= _value
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_11(bool) = TMP_10 >= REF_3
TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_13(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_13(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_15(uint256) = REF_8 + REF_9
TMP_16(bool) = TMP_15 == previousBalances
TMP_17(None) = SOLIDITY_CALL assert(bool)(TMP_16)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x184c8624d79f41eff9b3a702737ee86eeef80e67_ext.sol,EthMonsters.buyMonster,109,126,"TMP_27(bool) = _type < typesNumber,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),TMP_29(bool) = _type >= 0,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),REF_34(EthMonsters.monsterType) -> types[_type],REF_35(uint256) -> REF_34.currentPrice,TMP_31(bool) = msg.value < REF_35,CONDITION TMP_31,REF_36(uint256) -> userBalance[msg.sender],REF_36(-> userBalance) = REF_36 + msg.value,Emit BuyMonsterEvent(0),REF_37(uint256) -> userBalance[msg.sender],REF_38(EthMonsters.monsterType) -> types[_type],REF_39(uint256) -> REF_38.currentPrice,TMP_33(uint256) = msg.value - REF_39,REF_37(-> userBalance) = REF_37 + TMP_33,INTERNAL_CALL, EthMonsters.sendEarnings(uint256)(_type),TMP_35(uint256) = INTERNAL_CALL, EthMonsters.random(uint256,uint256)(1,3),numberOfEggs(uint256) := TMP_35(uint256),_i(uint256) := 0(uint256),TMP_36(bool) = _i < numberOfEggs,CONDITION TMP_36,INTERNAL_CALL, EthMonsters.createMonster(string,uint256,uint256,address,uint256,uint256,uint256)(_name,_type,1,msg.sender,100,0,1),TMP_38(uint256) := _i(uint256),_i(uint256) = _i + 1,REF_40(EthMonsters.monsterType) -> types[_type],REF_41(uint256) -> REF_40.maxPower,REF_42(EthMonsters.monsterType) -> types[_type],REF_43(uint256) -> REF_42.currentPrice,INTERNAL_CALL, EthMonsters.createMonster(string,uint256,uint256,address,uint256,uint256,uint256)(_name,_type,0,msg.sender,REF_41,REF_43,0),REF_44(EthMonsters.monsterType) -> types[_type],REF_45(uint256) -> REF_44.currentPrice,Emit BuyMonsterEvent(REF_45),REF_46(EthMonsters.monsterType) -> types[_type],REF_47(uint256) -> REF_46.currentPrice,REF_48(EthMonsters.monsterType) -> types[_type],REF_49(uint256) -> REF_48.basePrice,REF_47(-> types) = REF_47 + REF_49,REF_50(EthMonsters.monsterType) -> types[_type],REF_51(uint256) -> REF_50.sales,TMP_41(uint256) := REF_51(uint256),REF_51(-> types) = REF_51 + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_type < typesNumber)

IRs:
TMP_27(bool) = _type < typesNumber
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_type >= 0)

IRs:
TMP_29(bool) = _type >= 0
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
msg.value < types[_type].currentPrice

IRs:
REF_34(EthMonsters.monsterType) -> types[_type]
REF_35(uint256) -> REF_34.currentPrice
TMP_31(bool) = msg.value < REF_35
CONDITION TMP_31""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
userBalance[msg.sender] += msg.value

IRs:
REF_36(uint256) -> userBalance[msg.sender]
REF_36(-> userBalance) = REF_36 + msg.value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
BuyMonsterEvent(0)

IRs:
Emit BuyMonsterEvent(0)""];
5->18;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
userBalance[msg.sender] += (msg.value - types[_type].currentPrice)

IRs:
REF_37(uint256) -> userBalance[msg.sender]
REF_38(EthMonsters.monsterType) -> types[_type]
REF_39(uint256) -> REF_38.currentPrice
TMP_33(uint256) = msg.value - REF_39
REF_37(-> userBalance) = REF_37 + TMP_33""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
sendEarnings(_type)

IRs:
INTERNAL_CALL, EthMonsters.sendEarnings(uint256)(_type)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
numberOfEggs = random(1,3)

IRs:
TMP_35(uint256) = INTERNAL_CALL, EthMonsters.random(uint256,uint256)(1,3)
numberOfEggs(uint256) := TMP_35(uint256)""];
8->11;
9[label=""Node Type: BEGIN_LOOP 9
""];
9->12;
10[label=""Node Type: END_LOOP 10
""];
10->15;
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
_i = 0

IRs:
_i(uint256) := 0(uint256)""];
11->9;
12[label=""Node Type: IF_LOOP 12

EXPRESSION:
_i < numberOfEggs

IRs:
TMP_36(bool) = _i < numberOfEggs
CONDITION TMP_36""];
12->13[label=""True""];
12->10[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
createMonster(_name,_type,1,msg.sender,100,0,1)

IRs:
INTERNAL_CALL, EthMonsters.createMonster(string,uint256,uint256,address,uint256,uint256,uint256)(_name,_type,1,msg.sender,100,0,1)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
_i ++

IRs:
TMP_38(uint256) := _i(uint256)
_i(uint256) = _i + 1""];
14->12;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
createMonster(_name,_type,0,msg.sender,types[_type].maxPower,types[_type].currentPrice,0)

IRs:
REF_40(EthMonsters.monsterType) -> types[_type]
REF_41(uint256) -> REF_40.maxPower
REF_42(EthMonsters.monsterType) -> types[_type]
REF_43(uint256) -> REF_42.currentPrice
INTERNAL_CALL, EthMonsters.createMonster(string,uint256,uint256,address,uint256,uint256,uint256)(_name,_type,0,msg.sender,REF_41,REF_43,0)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
BuyMonsterEvent(types[_type].currentPrice)

IRs:
REF_44(EthMonsters.monsterType) -> types[_type]
REF_45(uint256) -> REF_44.currentPrice
Emit BuyMonsterEvent(REF_45)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
types[_type].currentPrice += types[_type].basePrice

IRs:
REF_46(EthMonsters.monsterType) -> types[_type]
REF_47(uint256) -> REF_46.currentPrice
REF_48(EthMonsters.monsterType) -> types[_type]
REF_49(uint256) -> REF_48.basePrice
REF_47(-> types) = REF_47 + REF_49""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
types[_type].sales ++

IRs:
REF_50(EthMonsters.monsterType) -> types[_type]
REF_51(uint256) -> REF_50.sales
TMP_41(uint256) := REF_51(uint256)
REF_51(-> types) = REF_51 + 1""];
}
",0,1,0,0,"require(bool)(_type < typesNumber);require(bool)(_type >= 0);msg.value < types[_type].currentPrice;userBalance[msg.sender] += msg.value;userBalance[msg.sender] += (msg.value - types[_type].currentPrice);BuyMonsterEvent(0);;sendEarnings(_type);numberOfEggs = random(1,3);_i = 0;;_i < numberOfEggs;;createMonster(_name,_type,0,msg.sender,types[_type].maxPower,types[_type].currentPrice,0);createMonster(_name,_type,1,msg.sender,100,0,1);_i ++;BuyMonsterEvent(types[_type].currentPrice);types[_type].currentPrice += types[_type].basePrice;types[_type].sales ++"
./0x4c1547be2c6f77c514840041b5a53d32f69e2c64_ext.sol,Escrow.deposit,22,29,"REF_0(uint256) -> balances[msg.sender],REF_0(-> balances) = REF_0 + tokens,TMP_0 = CONVERT dai_0x_address to ERC20,TMP_1 = CONVERT this to address,TMP_2(bool) = HIGH_LEVEL_CALL, dest:TMP_0(ERC20), function:transferFrom, arguments:['msg.sender', 'TMP_1', 'tokens']  ,Emit Deposit(tokens),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances[msg.sender] += tokens

IRs:
REF_0(uint256) -> balances[msg.sender]
REF_0(-> balances) = REF_0 + tokens""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ERC20(dai_0x_address).transferFrom(msg.sender,address(this),tokens)

IRs:
TMP_0 = CONVERT dai_0x_address to ERC20
TMP_1 = CONVERT this to address
TMP_2(bool) = HIGH_LEVEL_CALL, dest:TMP_0(ERC20), function:transferFrom, arguments:['msg.sender', 'TMP_1', 'tokens']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Deposit(tokens)

IRs:
Emit Deposit(tokens)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[msg.sender] += tokens;ERC20(dai_0x_address).transferFrom(msg.sender,address(this),tokens);Deposit(tokens);true;success"
./0x6bff83c6d87b1adff6679c75abac82fe7c38d7cf_ext.sol,EasyInvestTurbo.fallback,29,44,"REF_0(uint256) -> invested[msg.sender],TMP_0(bool) = REF_0 != 0,CONDITION TMP_0,REF_1(uint256) -> invested[msg.sender],TMP_1(uint256) = REF_1 * 12,TMP_2(uint256) = TMP_1 / 100,REF_2(uint256) -> atBlock[msg.sender],TMP_3(uint256) = block.number - REF_2,TMP_4(uint256) = TMP_2 * TMP_3,TMP_5(uint256) = TMP_4 / 5900,amount(uint256) := TMP_5(uint256),Transfer dest:msg.sender value:amount,REF_4(uint256) -> atBlock[msg.sender],REF_4(uint256) (->atBlock) := block.number(uint256),REF_5(uint256) -> invested[msg.sender],REF_5(-> invested) = REF_5 + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
invested[msg.sender] != 0

IRs:
REF_0(uint256) -> invested[msg.sender]
TMP_0(bool) = REF_0 != 0
CONDITION TMP_0""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = invested[msg.sender] * 12 / 100 * (block.number - atBlock[msg.sender]) / 5900

IRs:
REF_1(uint256) -> invested[msg.sender]
TMP_1(uint256) = REF_1 * 12
TMP_2(uint256) = TMP_1 / 100
REF_2(uint256) -> atBlock[msg.sender]
TMP_3(uint256) = block.number - REF_2
TMP_4(uint256) = TMP_2 * TMP_3
TMP_5(uint256) = TMP_4 / 5900
amount(uint256) := TMP_5(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
atBlock[msg.sender] = block.number

IRs:
REF_4(uint256) -> atBlock[msg.sender]
REF_4(uint256) (->atBlock) := block.number(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
invested[msg.sender] += msg.value

IRs:
REF_5(uint256) -> invested[msg.sender]
REF_5(-> invested) = REF_5 + msg.value""];
}
",0,1,0,0,invested[msg.sender] != 0;amount = invested[msg.sender] * 12 / 100 * (block.number - atBlock[msg.sender]) / 5900;;msg.sender.transfer(amount);atBlock[msg.sender] = block.number;invested[msg.sender] += msg.value
./0xb4b330972e302081ebacd054f4305a3af4103f0f_ext.sol,CryptoTradeToken.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x6c2fa6691b237c9e453926d8d484d4c5ab635db5_ext.sol,ContractReceiver.tokenFallback,14,29,"REF_0(address) -> tkn.sender,REF_0(address) (->tkn) := _from(address),REF_1(uint256) -> tkn.value,REF_1(uint256) (->tkn) := _value(uint256),REF_2(bytes) -> tkn.data,REF_2(bytes) (->tkn) := _data(bytes),REF_3(None) -> _data[3],TMP_0 = CONVERT REF_3 to uint32,REF_4(None) -> _data[2],TMP_1 = CONVERT REF_4 to uint32,TMP_2(uint32) = TMP_1 << 8,TMP_3(uint32) = TMP_0 + TMP_2,REF_5(None) -> _data[1],TMP_4 = CONVERT REF_5 to uint32,TMP_5(uint32) = TMP_4 << 16,TMP_6(uint32) = TMP_3 + TMP_5,REF_6(None) -> _data[0],TMP_7 = CONVERT REF_6 to uint32,TMP_8(uint32) = TMP_7 << 24,TMP_9(uint32) = TMP_6 + TMP_8,u(uint32) := TMP_9(uint32),REF_7(bytes4) -> tkn.sig,TMP_10 = CONVERT u to bytes4,REF_7(bytes4) (->tkn) := TMP_10(bytes4)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
tkn.sender = _from

IRs:
REF_0(address) -> tkn.sender
REF_0(address) (->tkn) := _from(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tkn.value = _value

IRs:
REF_1(uint256) -> tkn.value
REF_1(uint256) (->tkn) := _value(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
tkn.data = _data

IRs:
REF_2(bytes) -> tkn.data
REF_2(bytes) (->tkn) := _data(bytes)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24)

IRs:
REF_3(None) -> _data[3]
TMP_0 = CONVERT REF_3 to uint32
REF_4(None) -> _data[2]
TMP_1 = CONVERT REF_4 to uint32
TMP_2(uint32) = TMP_1 << 8
TMP_3(uint32) = TMP_0 + TMP_2
REF_5(None) -> _data[1]
TMP_4 = CONVERT REF_5 to uint32
TMP_5(uint32) = TMP_4 << 16
TMP_6(uint32) = TMP_3 + TMP_5
REF_6(None) -> _data[0]
TMP_7 = CONVERT REF_6 to uint32
TMP_8(uint32) = TMP_7 << 24
TMP_9(uint32) = TMP_6 + TMP_8
u(uint32) := TMP_9(uint32)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tkn.sig = bytes4(u)

IRs:
REF_7(bytes4) -> tkn.sig
TMP_10 = CONVERT u to bytes4
REF_7(bytes4) (->tkn) := TMP_10(bytes4)""];
}
",0,1,0,0,;tkn.sender = _from;tkn.value = _value;tkn.data = _data;u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);tkn.sig = bytes4(u)
./0xd3ac627abdc1ce6c27c04b37c86e368f754f2995_ext.sol,GradualPro.getQueueLength,178,180,"REF_33 -> LENGTH queue,TMP_50(uint256) = REF_33 - currentReceiverIndex,RETURN TMP_50","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
queue.length - currentReceiverIndex

IRs:
REF_33 -> LENGTH queue
TMP_50(uint256) = REF_33 - currentReceiverIndex
RETURN TMP_50""];
}
",0,1,0,0,queue.length - currentReceiverIndex
./0x922e2b947cfd0fa0a2e8b5279e02dc861cbc5c09_ext.sol,TokenERC20.burnFrom,166,174,"REF_19(uint256) -> balanceOf[_from],TMP_31(bool) = REF_19 >= _value,TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_33(bool) = _value <= REF_21,TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_31(bool) = REF_19 >= _value
TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_33(bool) = _value <= REF_21
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x85924fdcccb75c47c3d2155ae0a519018164cac0_ext.sol,StandardToken.transfer,36,43,"TMP_0(None) = SOLIDITY_CALL require(bool)(allowTransfer),REF_0(uint256) -> balances[msg.sender],TMP_1(bool) = REF_0 >= _value,TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1),REF_1(uint256) -> balances[msg.sender],REF_1(-> balances) = REF_1 - _value,REF_2(uint256) -> balances[_to],REF_2(-> balances) = REF_2 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(allowTransfer)

IRs:
TMP_0(None) = SOLIDITY_CALL require(bool)(allowTransfer)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_1(bool) = REF_0 >= _value
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_1(-> balances) = REF_1 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] += _value

IRs:
REF_2(uint256) -> balances[_to]
REF_2(-> balances) = REF_2 + _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(allowTransfer);require(bool)(balances[msg.sender] >= _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0x52c2d09acf0ef12c487ae0c20a92d4f9a4abbfd1_ext.sol,MyNewBank.deposit,29,34,"TMP_2(bool) = msg.value >= 100000000000000000,CONDITION TMP_2,REF_0(uint256) -> deposits[msg.sender],REF_0(-> deposits) = REF_0 + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value >= 100000000000000000

IRs:
TMP_2(bool) = msg.value >= 100000000000000000
CONDITION TMP_2""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
deposits[msg.sender] += msg.value

IRs:
REF_0(uint256) -> deposits[msg.sender]
REF_0(-> deposits) = REF_0 + msg.value""];
2->4;
3[label=""Node Type: THROW 3
""];
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,msg.value >= 100000000000000000;deposits[msg.sender] += msg.value;;
./0xbd0706f616b8d465d87583b727df8478ed1496fd_ext.sol,WHOIS.mintToken,218,223,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0xf23dfaba45a9fb74dd18a22fd381befcbfd31b71_ext.sol,CRYPTOBUX.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x4221eb87b28de194e916f2b09274471fb0b01b1c_ext.sol,SafeMath.add,42,46,"TMP_9(uint256) = a + b,c(uint256) := TMP_9(uint256),TMP_10(bool) = c >= a,TMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10),RETURN c,RETURN c","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
c = a + b

IRs:
TMP_9(uint256) = a + b
c(uint256) := TMP_9(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_10(bool) = c >= a
TMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c""];
4[label=""Node Type: RETURN 4

EXPRESSION:
c

IRs:
RETURN c""];
}
",0,1,0,0,c = a + b;assert(bool)(c >= a);c;c
./0x6be5744e45292144d6814ffbedcb6aad1bb287e4_ext.sol,CikkaCoin.mintToken,174,179,"REF_25(uint256) -> balanceOf[target],REF_25(-> balanceOf) = REF_25 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_25(uint256) -> balanceOf[target]
REF_25(-> balanceOf) = REF_25 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x6c61f6343b7420e142fb05f8b86afed3179eb0f0_ext.sol,StandardToken.transferFrom,66,76,"REF_3(uint256) -> balances[_from],TMP_19(bool) = REF_3 >= _value,REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],TMP_20(bool) = REF_5 >= _value,TMP_21(bool) = TMP_19 && TMP_20,TMP_22(bool) = _value > 0,TMP_23(bool) = TMP_21 && TMP_22,CONDITION TMP_23,REF_6(uint256) -> balances[_to],REF_6(-> balances) = REF_6 + _value,REF_7(uint256) -> balances[_from],REF_7(-> balances) = REF_7 - _value,REF_8(mapping(address => uint256)) -> allowed[_from],REF_9(uint256) -> REF_8[msg.sender],REF_9(-> allowed) = REF_9 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0

IRs:
REF_3(uint256) -> balances[_from]
TMP_19(bool) = REF_3 >= _value
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
TMP_20(bool) = REF_5 >= _value
TMP_21(bool) = TMP_19 && TMP_20
TMP_22(bool) = _value > 0
TMP_23(bool) = TMP_21 && TMP_22
CONDITION TMP_23""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_6(uint256) -> balances[_to]
REF_6(-> balances) = REF_6 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_7(uint256) -> balances[_from]
REF_7(-> balances) = REF_7 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_8(mapping(address => uint256)) -> allowed[_from]
REF_9(uint256) -> REF_8[msg.sender]
REF_9(-> allowed) = REF_9 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0;balances[_to] += _value;false;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true;success"
./0xe0090146f0eb3193a8a12380e3ec14732589e41f_ext.sol,TokenERC20.burn,64,70,"REF_10(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_10 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_11(uint256) -> balanceOf[msg.sender],REF_11(-> balanceOf) = REF_11 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_10(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_10 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_11(uint256) -> balanceOf[msg.sender]
REF_11(-> balanceOf) = REF_11 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x1c0f4c64821d6f8fa96975e20d5bb3ea79eb1071_ext.sol,vault.withdraw,13,21,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2),TMP_4(bool) = keyHash == TMP_3,CONDITION TMP_4,TMP_5(bool) = msg.value > 400000000000000000,CONDITION TMP_5,TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),Transfer dest:msg.sender value:TMP_7","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
keyHash == keccak256()(abi.encodePacked(key))

IRs:
TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2)
TMP_4(bool) = keyHash == TMP_3
CONDITION TMP_4""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
msg.value > 400000000000000000

IRs:
TMP_5(bool) = msg.value > 400000000000000000
CONDITION TMP_5""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
Transfer dest:msg.sender value:TMP_7""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,1,0,0,require(bool)(msg.sender == tx.origin);keyHash == keccak256()(abi.encodePacked(key));msg.value > 400000000000000000;;msg.sender.transfer(address(this).balance);
./0x6b293d3e843d68da3400b3f39aa3e59274feeb73_ext.sol,NIMFUNToken.burnFrom,149,157,"REF_19(uint256) -> balanceOf[_from],TMP_26(bool) = REF_19 >= _value,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_28(bool) = _value <= REF_21,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_26(bool) = REF_19 >= _value
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_28(bool) = _value <= REF_21
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x5c227eb319c24249df66d0c5879515aa59787471_ext.sol,BitAlpha.BitAlphaAirdrop,39,45,"i(uint256) := 0(uint256),REF_1 -> LENGTH addresses,TMP_2(bool) = i < REF_1,CONDITION TMP_2,REF_2(uint256) -> balances[owner],TMP_3(uint256) = 10 ** 8,TMP_4(uint256) = 1500 * TMP_3,REF_2(-> balances) = REF_2 - TMP_4,REF_3(address) -> addresses[i],REF_4(uint256) -> balances[REF_3],TMP_5(uint256) = 10 ** 8,TMP_6(uint256) = 1500 * TMP_5,REF_4(-> balances) = REF_4 + TMP_6,REF_5(address) -> addresses[i],TMP_7(uint256) = 10 ** 8,TMP_8(uint256) = 1500 * TMP_7,Emit Transfer(owner,REF_5,TMP_8),TMP_10(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, BitAlpha.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addresses.length

IRs:
REF_1 -> LENGTH addresses
TMP_2(bool) = i < REF_1
CONDITION TMP_2""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[owner] -= 1500 * 10 ** 8

IRs:
REF_2(uint256) -> balances[owner]
TMP_3(uint256) = 10 ** 8
TMP_4(uint256) = 1500 * TMP_3
REF_2(-> balances) = REF_2 - TMP_4""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[addresses[i]] += 1500 * 10 ** 8

IRs:
REF_3(address) -> addresses[i]
REF_4(uint256) -> balances[REF_3]
TMP_5(uint256) = 10 ** 8
TMP_6(uint256) = 1500 * TMP_5
REF_4(-> balances) = REF_4 + TMP_6""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(owner,addresses[i],1500 * 10 ** 8)

IRs:
REF_5(address) -> addresses[i]
TMP_7(uint256) = 10 ** 8
TMP_8(uint256) = 1500 * TMP_7
Emit Transfer(owner,REF_5,TMP_8)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_10(uint256) := i(uint256)
i(uint256) = i + 1""];
8->4;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, BitAlpha.onlyOwner()()""];
9->3;
}
",0,1,0,0,"onlyOwner();;i < addresses.length;;i = 0;balances[owner] -= 1500 * 10 ** 8;balances[addresses[i]] += 1500 * 10 ** 8;Transfer(owner,addresses[i],1500 * 10 ** 8);i ++"
./0x791af7fccfee46330bb02dac1e2585dc6f49c996_ext.sol,ReddCoin.burn,65,71,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x549ace5ff0c3a1881682fa06813c06884f7ee2e0_ext.sol,EarlyTokenSale.fallback,233,251,"TMP_84(bool) = isFunding == True,TMP_85(bool) = amountRaised < fundingGoal,TMP_86(bool) = TMP_84 && TMP_85,TMP_87(None) = SOLIDITY_CALL require(bool)(TMP_86),amount(uint256) := msg.value(uint256),TMP_88(bool) = amount >= 1000000000000000000,TMP_89(None) = SOLIDITY_CALL require(bool)(TMP_88),REF_2(uint256) -> accredited[msg.sender],TMP_90(uint256) = REF_2 - amount,TMP_91(bool) = TMP_90 >= 0,TMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91),Transfer dest:multiSigWallet value:amount,REF_4(uint256) -> balanceOf[msg.sender],REF_4(-> balanceOf) = REF_4 + amount,REF_5(uint256) -> accredited[msg.sender],REF_5(-> accredited) = REF_5 - amount,amountRaised(uint256) = amountRaised + amount,Emit FundTransfer(msg.sender,amount),TMP_95(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['amount', 'tokensPerEther'] ,value(uint256) := TMP_95(uint256),TMP_96(bool) = HIGH_LEVEL_CALL, dest:tokenReward(Token), function:mintToken, arguments:['msg.sender', 'value']  ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isFunding == true && amountRaised < fundingGoal)

IRs:
TMP_84(bool) = isFunding == True
TMP_85(bool) = amountRaised < fundingGoal
TMP_86(bool) = TMP_84 && TMP_85
TMP_87(None) = SOLIDITY_CALL require(bool)(TMP_86)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = msg.value

IRs:
amount(uint256) := msg.value(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(amount >= 1000000000000000000)

IRs:
TMP_88(bool) = amount >= 1000000000000000000
TMP_89(None) = SOLIDITY_CALL require(bool)(TMP_88)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(accredited[msg.sender] - amount >= 0)

IRs:
REF_2(uint256) -> accredited[msg.sender]
TMP_90(uint256) = REF_2 - amount
TMP_91(bool) = TMP_90 >= 0
TMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
multiSigWallet.transfer(amount)

IRs:
Transfer dest:multiSigWallet value:amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[msg.sender] += amount

IRs:
REF_4(uint256) -> balanceOf[msg.sender]
REF_4(-> balanceOf) = REF_4 + amount""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
accredited[msg.sender] -= amount

IRs:
REF_5(uint256) -> accredited[msg.sender]
REF_5(-> accredited) = REF_5 - amount""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
amountRaised += amount

IRs:
amountRaised(uint256) = amountRaised + amount""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
FundTransfer(msg.sender,amount)

IRs:
Emit FundTransfer(msg.sender,amount)""];
9->10;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
value = amount.mul(tokensPerEther)

IRs:
TMP_95(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['amount', 'tokensPerEther'] 
value(uint256) := TMP_95(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
tokenReward.mintToken(msg.sender,value)

IRs:
TMP_96(bool) = HIGH_LEVEL_CALL, dest:tokenReward(Token), function:mintToken, arguments:['msg.sender', 'value']  ""];
}
",0,1,0,0,"require(bool)(isFunding == true && amountRaised < fundingGoal);amount = msg.value;require(bool)(amount >= 1000000000000000000);require(bool)(accredited[msg.sender] - amount >= 0);multiSigWallet.transfer(amount);balanceOf[msg.sender] += amount;accredited[msg.sender] -= amount;amountRaised += amount;FundTransfer(msg.sender,amount);value = amount.mul(tokensPerEther);tokenReward.mintToken(msg.sender,value)"
./0xed04927a3849fc9db3f3341a17b7d844a6c551a8_ext.sol,CrowdInvestment.getCap,27,29,"REF_1(uint256) -> perUserInvestments[investor],TMP_7(uint256) = limitPerInvestor - REF_1,REF_2(uint256) -> additionalCaps[investor],TMP_8(uint256) = TMP_7 + REF_2,RETURN TMP_8","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
limitPerInvestor - perUserInvestments[investor] + additionalCaps[investor]

IRs:
REF_1(uint256) -> perUserInvestments[investor]
TMP_7(uint256) = limitPerInvestor - REF_1
REF_2(uint256) -> additionalCaps[investor]
TMP_8(uint256) = TMP_7 + REF_2
RETURN TMP_8""];
}
",0,1,0,0,limitPerInvestor - perUserInvestments[investor] + additionalCaps[investor]
./0xda6bae24e98db8ec03151d5edcf9ade67e442b6d_ext.sol,MyAdvancedToken.mintToken,181,187,"REF_41(uint256) -> balanceOf[target],REF_41(-> balanceOf) = REF_41 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),RETURN True,MODIFIER_CALL, owned.onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_41(uint256) -> balanceOf[target]
REF_41(-> balanceOf) = REF_41 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
6->1;
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount);true;success"
./0x32c62c965db5fdac0f94e6276d6884070068d4be_ext.sol,MyAdvancedToken.burn,77,81,"REF_17(uint256) -> balances_[who],REF_17(-> balances_) = REF_17 - val,totalSupply_(uint256) = totalSupply_ - val,Emit Transfer(who,0,val),MODIFIER_CALL, MyAdvancedToken.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances_[who] -= val

IRs:
REF_17(uint256) -> balances_[who]
REF_17(-> balances_) = REF_17 - val""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply_ -= val

IRs:
totalSupply_(uint256) = totalSupply_ - val""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(who,0,val)

IRs:
Emit Transfer(who,0,val)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, MyAdvancedToken.whenNotPaused()()""];
4->1;
}
",1,1,0,0,"whenNotPaused();balances_[who] -= val;totalSupply_ -= val;Transfer(who,0,val)"
./0x18373e7b8bd24ecb0af8e9c95548360ef787b781_ext.sol,ShareToken.lockRewardTokenMany,371,377,"i(uint256) := 0(uint256),REF_90 -> LENGTH addrList,TMP_185(bool) = i < REF_90,CONDITION TMP_185,REF_91(address) -> addrList[i],INTERNAL_CALL, ShareToken.lockRewardToken(address)(REF_91),TMP_187(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addrList.length

IRs:
REF_90 -> LENGTH addrList
TMP_185(bool) = i < REF_90
CONDITION TMP_185""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
lockRewardToken(addrList[i])

IRs:
REF_91(address) -> addrList[i]
INTERNAL_CALL, ShareToken.lockRewardToken(address)(REF_91)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_187(uint256) := i(uint256)
i(uint256) = i + 1""];
6->4;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->3;
}
",0,1,0,0,onlyOwner();;i < addrList.length;;i = 0;lockRewardToken(addrList[i]);i ++
./0xc7db6a0e78efb4d64bb06359faf83420f04cfb52_ext.sol,play_IQUIZ.Start,28,33,"TMP_7(bool) = responseHash == 0,CONDITION TMP_7,TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response),responseHash(bytes32) := TMP_8(bytes32),question(string) := _question(string),MODIFIER_CALL, play_IQUIZ.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
responseHash == 0x0

IRs:
TMP_7(bool) = responseHash == 0
CONDITION TMP_7""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
responseHash = keccak256()(_response)

IRs:
TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response)
responseHash(bytes32) := TMP_8(bytes32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, play_IQUIZ.isAdmin()()""];
5->1;
}
",0,1,0,0,isAdmin();responseHash == 0x0;responseHash = keccak256()(_response);;question = _question
./0x4cd6e70a33092e2e3aac431c39b3de364042f9f0_ext.sol,TokenERC20.burn,132,138,"REF_17(uint256) -> balanceOf[msg.sender],TMP_23(bool) = REF_17 >= _value,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_23(bool) = REF_17 >= _value
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x45e4390e6387b896268661ed4e2066df40a95a29_ext.sol,VOCC_I032_20181211.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0xa29d3d850d169eca564e71a02c13b7d76bc0eff4_ext.sol,Scorpio.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x1d5854e7f4dd81d9d4c09097d3cc736c7771f234_ext.sol,vualt.setup_key,23,28,"TMP_9(bool) = keyHash == 0,CONDITION TMP_9,TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10),keyHash(bytes32) := TMP_11(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
keyHash == 0x0

IRs:
TMP_9(bool) = keyHash == 0
CONDITION TMP_9""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
keyHash = keccak256()(abi.encodePacked(key))

IRs:
TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10)
keyHash(bytes32) := TMP_11(bytes32)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,1,0,0,keyHash == 0x0;keyHash = keccak256()(abi.encodePacked(key));
./0x419b8ed155180a8c9c64145e76dad49c0a4efb97_ext.sol,ApproveAndCallToken.approveAndCall,195,202,"TMP_70 = CONVERT _spender to TokenRecipient,spender(TokenRecipient) := TMP_70(TokenRecipient),TMP_71(bool) = INTERNAL_CALL, StandardToken.approve(address,uint256)(_spender,_value),CONDITION TMP_71,HIGH_LEVEL_CALL, dest:spender(TokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_data']  ,RETURN True,RETURN False","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = TokenRecipient(_spender)

IRs:
TMP_70 = CONVERT _spender to TokenRecipient
spender(TokenRecipient) := TMP_70(TokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_71(bool) = INTERNAL_CALL, StandardToken.approve(address,uint256)(_spender,_value)
CONDITION TMP_71""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_data)

IRs:
HIGH_LEVEL_CALL, dest:spender(TokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False""];
}
",0,1,0,0,"spender = TokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_data);;true;false"
./0x7329e152d805dec79c67e45d4e04f3b6ce545b7c_ext.sol,HmcDistributor.distribute,77,85,"TMP_9 = CONVERT 0 to address,TMP_10(bool) = hmcAddress != TMP_9,TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10),REF_5(HmcDistributor.member) -> whitelist[_addr],REF_6(uint256) -> REF_5.unlockTime,TMP_12(bool) = REF_6 == 0,TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12),REF_7(HmcDistributor.member) -> whitelist[_addr],REF_8(uint256) -> REF_7.unlockTime,TMP_14(uint256) = now + lockDuration,REF_8(uint256) (->whitelist) := TMP_14(uint256),TMP_15(uint256) := joinCount(uint256),joinCount(uint256) = joinCount + 1,MODIFIER_CALL, HmcDistributor.onlyDistributor()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(hmcAddress != address(0))

IRs:
TMP_9 = CONVERT 0 to address
TMP_10(bool) = hmcAddress != TMP_9
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(whitelist[_addr].unlockTime == 0)

IRs:
REF_5(HmcDistributor.member) -> whitelist[_addr]
REF_6(uint256) -> REF_5.unlockTime
TMP_12(bool) = REF_6 == 0
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
whitelist[_addr].unlockTime = now + lockDuration

IRs:
REF_7(HmcDistributor.member) -> whitelist[_addr]
REF_8(uint256) -> REF_7.unlockTime
TMP_14(uint256) = now + lockDuration
REF_8(uint256) (->whitelist) := TMP_14(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
joinCount ++

IRs:
TMP_15(uint256) := joinCount(uint256)
joinCount(uint256) = joinCount + 1""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyDistributor()

IRs:
MODIFIER_CALL, HmcDistributor.onlyDistributor()()""];
5->1;
}
",0,1,0,0,onlyDistributor();require(bool)(hmcAddress != address(0));require(bool)(whitelist[_addr].unlockTime == 0);whitelist[_addr].unlockTime = now + lockDuration;joinCount ++
./0x6b6d1a8858893c3e228f335726e1417a35832f76_ext.sol,Carbon.burnSupply,56,60,"REF_19(uint256) -> balanceOf[owner],REF_19(-> balanceOf) = REF_19 - _amount,Emit SupplyBurn(_amount),MODIFIER_CALL, Carbon.isOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[owner] -= _amount

IRs:
REF_19(uint256) -> balanceOf[owner]
REF_19(-> balanceOf) = REF_19 - _amount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
SupplyBurn(_amount)

IRs:
Emit SupplyBurn(_amount)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
isOwner()

IRs:
MODIFIER_CALL, Carbon.isOwner()()""];
3->1;
}
",0,1,0,0,isOwner();balanceOf[owner] -= _amount;SupplyBurn(_amount)
./0x6dee0a976370ee9f0f8c4619ab3386441a42ceb3_ext.sol,CoinifinexToken.burn,184,190,"REF_96(uint256) -> balanceOf[msg.sender],TMP_163(bool) = REF_96 >= _value,TMP_164(None) = SOLIDITY_CALL require(bool)(TMP_163),REF_97(uint256) -> balanceOf[msg.sender],REF_97(-> balanceOf) = REF_97 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_96(uint256) -> balanceOf[msg.sender]
TMP_163(bool) = REF_96 >= _value
TMP_164(None) = SOLIDITY_CALL require(bool)(TMP_163)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_97(uint256) -> balanceOf[msg.sender]
REF_97(-> balanceOf) = REF_97 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x414b23b9deb0da531384c5db2ac5a99ee2e07a57_ext.sol,TPCToken.burn,49,55,"REF_16(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_16 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_17(uint256) -> balanceOf[msg.sender],REF_17(-> balanceOf) = REF_17 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_16(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_16 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
REF_17(-> balanceOf) = REF_17 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x53a30b07bea5b8e9b5f710e038867a1531b0b5dc_ext.sol,Multiplexer.sendEth,13,31,"REF_0 -> LENGTH _to,REF_1 -> LENGTH _value,TMP_0(bool) = REF_0 == REF_1,TMP_1(None) = SOLIDITY_CALL assert(bool)(TMP_0),REF_2 -> LENGTH _to,TMP_2(bool) = REF_2 <= 255,TMP_3(None) = SOLIDITY_CALL assert(bool)(TMP_2),beforeValue(uint256) := msg.value(uint256),afterValue(uint256) := 0(uint256),i(uint8) := 0(uint256),REF_3 -> LENGTH _to,TMP_4(bool) = i < REF_3,CONDITION TMP_4,REF_4(uint256) -> _value[i],TMP_5(uint256) = afterValue + REF_4,afterValue(uint256) := TMP_5(uint256),REF_5(address) -> _to[i],REF_7(uint256) -> _value[i],TMP_6 = SEND dest:REF_5 value:REF_7,TMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6),TMP_8(uint8) := i(uint8),i(uint8) = i + 1,TMP_9(uint256) = beforeValue - afterValue,remainingValue(uint256) := TMP_9(uint256),TMP_10(bool) = remainingValue > 0,CONDITION TMP_10,TMP_11 = SEND dest:msg.sender value:remainingValue,TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11),RETURN True,RETURN _success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(_to.length == _value.length)

IRs:
REF_0 -> LENGTH _to
REF_1 -> LENGTH _value
TMP_0(bool) = REF_0 == REF_1
TMP_1(None) = SOLIDITY_CALL assert(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(_to.length <= 255)

IRs:
REF_2 -> LENGTH _to
TMP_2(bool) = REF_2 <= 255
TMP_3(None) = SOLIDITY_CALL assert(bool)(TMP_2)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
beforeValue = msg.value

IRs:
beforeValue(uint256) := msg.value(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
afterValue = 0

IRs:
afterValue(uint256) := 0(uint256)""];
4->7;
5[label=""Node Type: BEGIN_LOOP 5
""];
5->8;
6[label=""Node Type: END_LOOP 6
""];
6->12;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)""];
7->5;
8[label=""Node Type: IF_LOOP 8

EXPRESSION:
i < _to.length

IRs:
REF_3 -> LENGTH _to
TMP_4(bool) = i < REF_3
CONDITION TMP_4""];
8->9[label=""True""];
8->6[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
afterValue = afterValue + _value[i]

IRs:
REF_4(uint256) -> _value[i]
TMP_5(uint256) = afterValue + REF_4
afterValue(uint256) := TMP_5(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
assert(bool)(_to[i].send(_value[i]))

IRs:
REF_5(address) -> _to[i]
REF_7(uint256) -> _value[i]
TMP_6 = SEND dest:REF_5 value:REF_7
TMP_7(None) = SOLIDITY_CALL assert(bool)(TMP_6)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_8(uint8) := i(uint8)
i(uint8) = i + 1""];
11->8;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
remainingValue = beforeValue - afterValue

IRs:
TMP_9(uint256) = beforeValue - afterValue
remainingValue(uint256) := TMP_9(uint256)""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
remainingValue > 0

IRs:
TMP_10(bool) = remainingValue > 0
CONDITION TMP_10""];
13->14[label=""True""];
13->15[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
assert(bool)(msg.sender.send(remainingValue))

IRs:
TMP_11 = SEND dest:msg.sender value:remainingValue
TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: RETURN 16

EXPRESSION:
true

IRs:
RETURN True""];
17[label=""Node Type: RETURN 17

EXPRESSION:
_success

IRs:
RETURN _success""];
}
",0,1,0,0,assert(bool)(_to.length == _value.length);assert(bool)(_to.length <= 255);beforeValue = msg.value;afterValue = 0;i = 0;;i < _to.length;;remainingValue = beforeValue - afterValue;afterValue = afterValue + _value[i];assert(bool)(_to[i].send(_value[i]));i ++;remainingValue > 0;assert(bool)(msg.sender.send(remainingValue));;true;_success
./0x1e834560e79def1479555bf5d9a35e8bc3dbe70a_ext.sol,MyAdvancedToken.mintToken,213,218,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x92972bbc89708127016046c150e3a223431a31e0_ext.sol,GMQToken._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x4ce795fa7bb1adf6d5ad7dc234d7d8dae14596ef_ext.sol,LylToken.mintToken,207,212,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x2019763bd984cce011cd9b55b0e700abe42fa6c7_ext.sol,ClassSize.voteNo,23,26,"votesNo(uint16) = votesNo + 1,Emit VoteNo(note)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
votesNo += 1

IRs:
votesNo(uint16) = votesNo + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
VoteNo(note)

IRs:
Emit VoteNo(note)""];
}
",0,1,0,0,votesNo += 1;VoteNo(note)
./0xda0e0303f4bf08cff92e88e13c0e743b14fea0d5_ext.sol,StandardToken.transferFrom,58,68,"REF_3(uint256) -> balances[_from],TMP_18(bool) = REF_3 >= _value,REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],TMP_19(bool) = REF_5 >= _value,TMP_20(bool) = TMP_18 && TMP_19,TMP_21(bool) = _value > 0,TMP_22(bool) = TMP_20 && TMP_21,CONDITION TMP_22,REF_6(uint256) -> balances[_to],REF_6(-> balances) = REF_6 + _value,REF_7(uint256) -> balances[_from],REF_7(-> balances) = REF_7 - _value,REF_8(mapping(address => uint256)) -> allowed[_from],REF_9(uint256) -> REF_8[msg.sender],REF_9(-> allowed) = REF_9 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0

IRs:
REF_3(uint256) -> balances[_from]
TMP_18(bool) = REF_3 >= _value
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
TMP_19(bool) = REF_5 >= _value
TMP_20(bool) = TMP_18 && TMP_19
TMP_21(bool) = _value > 0
TMP_22(bool) = TMP_20 && TMP_21
CONDITION TMP_22""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_6(uint256) -> balances[_to]
REF_6(-> balances) = REF_6 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_7(uint256) -> balances[_from]
REF_7(-> balances) = REF_7 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_8(mapping(address => uint256)) -> allowed[_from]
REF_9(uint256) -> REF_8[msg.sender]
REF_9(-> allowed) = REF_9 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0;balances[_to] += _value;false;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true;success"
./0x2feecd120111e5aab7b3a22fe1177a392cfe0f4e_ext.sol,AG.totalSupply,93,95,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x03684715e3a614ec80d1b31b62987e0b25925999_ext.sol,GWGFPLUS._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x5c227eb319c24249df66d0c5879515aa59787471_ext.sol,BitAlpha.BitAlphaAirdrop,39,45,"i(uint256) := 0(uint256),REF_1 -> LENGTH addresses,TMP_2(bool) = i < REF_1,CONDITION TMP_2,REF_2(uint256) -> balances[owner],TMP_3(uint256) = 10 ** 8,TMP_4(uint256) = 1500 * TMP_3,REF_2(-> balances) = REF_2 - TMP_4,REF_3(address) -> addresses[i],REF_4(uint256) -> balances[REF_3],TMP_5(uint256) = 10 ** 8,TMP_6(uint256) = 1500 * TMP_5,REF_4(-> balances) = REF_4 + TMP_6,REF_5(address) -> addresses[i],TMP_7(uint256) = 10 ** 8,TMP_8(uint256) = 1500 * TMP_7,Emit Transfer(owner,REF_5,TMP_8),TMP_10(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, BitAlpha.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addresses.length

IRs:
REF_1 -> LENGTH addresses
TMP_2(bool) = i < REF_1
CONDITION TMP_2""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[owner] -= 1500 * 10 ** 8

IRs:
REF_2(uint256) -> balances[owner]
TMP_3(uint256) = 10 ** 8
TMP_4(uint256) = 1500 * TMP_3
REF_2(-> balances) = REF_2 - TMP_4""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[addresses[i]] += 1500 * 10 ** 8

IRs:
REF_3(address) -> addresses[i]
REF_4(uint256) -> balances[REF_3]
TMP_5(uint256) = 10 ** 8
TMP_6(uint256) = 1500 * TMP_5
REF_4(-> balances) = REF_4 + TMP_6""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(owner,addresses[i],1500 * 10 ** 8)

IRs:
REF_5(address) -> addresses[i]
TMP_7(uint256) = 10 ** 8
TMP_8(uint256) = 1500 * TMP_7
Emit Transfer(owner,REF_5,TMP_8)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_10(uint256) := i(uint256)
i(uint256) = i + 1""];
8->4;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, BitAlpha.onlyOwner()()""];
9->3;
}
",0,1,0,0,"onlyOwner();;i < addresses.length;;i = 0;balances[owner] -= 1500 * 10 ** 8;balances[addresses[i]] += 1500 * 10 ** 8;Transfer(owner,addresses[i],1500 * 10 ** 8);i ++"
./0x18f1117186ea252e54a2fdd200f6fa48f9e5e979_ext.sol,LegionToken.burnFrom,79,87,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x70528e8cc624f437fd01ab5a5215d8bb092b73ff_ext.sol,ERC20.burn,242,248,"REF_21(uint256) -> balanceOf[msg.sender],TMP_44(bool) = REF_21 >= _value,TMP_45(None) = SOLIDITY_CALL require(bool)(TMP_44),REF_22(uint256) -> balanceOf[msg.sender],REF_22(-> balanceOf) = REF_22 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_21(uint256) -> balanceOf[msg.sender]
TMP_44(bool) = REF_21 >= _value
TMP_45(None) = SOLIDITY_CALL require(bool)(TMP_44)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_22(uint256) -> balanceOf[msg.sender]
REF_22(-> balanceOf) = REF_22 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x30f7411efcd4acc98c41d5ae6fe3cdd35aa1b68a_ext.sol,RegularToken.transferFrom,90,109,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0xa24f50fa560d2ec57956955f929273e899994bca_ext.sol,XZEN.createTokens,213,227,"TMP_84(uint256) = 10 ** decimals,multiplier(uint256) := TMP_84(uint256),TMP_85(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', 'multiplier'] ,TMP_86(uint256) = TMP_85 / oneTokenInWei,tokens(uint256) := TMP_86(uint256),TMP_87(uint256) = startDate + 86400,TMP_88(bool) = now <= TMP_87,CONDITION TMP_88,TMP_89(uint256) = tokens / 100,TMP_90(uint256) = TMP_89 * 5,tokens(uint256) = tokens + TMP_90,REF_89(uint256) -> balances[teamWallet],TMP_91(bool) = REF_89 < tokens,CONDITION TMP_91,TMP_92(None) = SOLIDITY_CALL revert()(),REF_90(uint256) -> balances[teamWallet],REF_90(-> balances) = REF_90 - tokens,REF_91(uint256) -> balances[msg.sender],REF_91(-> balances) = REF_91 + tokens,Transfer dest:multiSigWallet value:msg.value,Emit Transfer(teamWallet,msg.sender,tokens)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
multiplier = 10 ** decimals

IRs:
TMP_84(uint256) = 10 ** decimals
multiplier(uint256) := TMP_84(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
tokens = (msg.value.mul(multiplier) / oneTokenInWei)

IRs:
TMP_85(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', 'multiplier'] 
TMP_86(uint256) = TMP_85 / oneTokenInWei
tokens(uint256) := TMP_86(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
now <= startDate + 86400

IRs:
TMP_87(uint256) = startDate + 86400
TMP_88(bool) = now <= TMP_87
CONDITION TMP_88""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
tokens += tokens / 100 * 5

IRs:
TMP_89(uint256) = tokens / 100
TMP_90(uint256) = TMP_89 * 5
tokens(uint256) = tokens + TMP_90""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
balances[teamWallet] < tokens

IRs:
REF_89(uint256) -> balances[teamWallet]
TMP_91(bool) = REF_89 < tokens
CONDITION TMP_91""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
revert()()

IRs:
TMP_92(None) = SOLIDITY_CALL revert()()""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
balances[teamWallet] -= tokens

IRs:
REF_90(uint256) -> balances[teamWallet]
REF_90(-> balances) = REF_90 - tokens""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
balances[msg.sender] += tokens

IRs:
REF_91(uint256) -> balances[msg.sender]
REF_91(-> balances) = REF_91 + tokens""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
multiSigWallet.transfer(msg.value)

IRs:
Transfer dest:multiSigWallet value:msg.value""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
Transfer(teamWallet,msg.sender,tokens)

IRs:
Emit Transfer(teamWallet,msg.sender,tokens)""];
}
",0,1,0,0,"multiplier = 10 ** decimals;tokens = (msg.value.mul(multiplier) / oneTokenInWei);now <= startDate + 86400;tokens += tokens / 100 * 5;;balances[teamWallet] < tokens;revert()();;balances[teamWallet] -= tokens;balances[msg.sender] += tokens;multiSigWallet.transfer(msg.value);Transfer(teamWallet,msg.sender,tokens)"
./0x64d5e7be2e92d4436ba9c4a630491cb268764103_ext.sol,funds.withdraw,13,21,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2),TMP_4(bool) = keyHash == TMP_3,CONDITION TMP_4,TMP_5(bool) = msg.value > 400000000000000000,CONDITION TMP_5,TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),Transfer dest:msg.sender value:TMP_7","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
keyHash == keccak256()(abi.encodePacked(key))

IRs:
TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2)
TMP_4(bool) = keyHash == TMP_3
CONDITION TMP_4""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
msg.value > 400000000000000000

IRs:
TMP_5(bool) = msg.value > 400000000000000000
CONDITION TMP_5""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
Transfer dest:msg.sender value:TMP_7""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,1,0,0,require(bool)(msg.sender == tx.origin);keyHash == keccak256()(abi.encodePacked(key));msg.value > 400000000000000000;;msg.sender.transfer(address(this).balance);
./0x1cdb4710dfbf63c4d9b39c8ee37b084ecb2bd932_ext.sol,Data.addBalance,270,272,"REF_82(uint256) -> balances[_addr],REF_82(-> balances) = REF_82 + amount,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances[_addr] += amount

IRs:
REF_82(uint256) -> balances[_addr]
REF_82(-> balances) = REF_82 + amount""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,1,0,0,onlyOwner();balances[_addr] += amount
./0x036d80f9abe266b7c6ec0a9bd078fac3a90d4239_ext.sol,TruffleCoin.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x6eab644deba95ca78e4ca636c366f19b75290d65_ext.sol,PFG.transferFrom,66,72,"REF_5(uint256) -> balances[_from],TMP_9(bool) = REF_5 >= _value,REF_6(mapping(address => uint256)) -> allowed[_from],REF_7(uint256) -> REF_6[msg.sender],TMP_10(bool) = REF_7 >= _value,TMP_11(bool) = TMP_9 && TMP_10,TMP_12(bool) = _value > 0,TMP_13(bool) = TMP_11 && TMP_12,TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13),REF_8(uint256) -> balances[_to],REF_8(-> balances) = REF_8 + _value,REF_9(uint256) -> balances[_from],REF_9(-> balances) = REF_9 - _value,REF_10(mapping(address => uint256)) -> allowed[_from],REF_11(uint256) -> REF_10[msg.sender],REF_11(-> allowed) = REF_11 - _value,Emit Transfer(_from,_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0)

IRs:
REF_5(uint256) -> balances[_from]
TMP_9(bool) = REF_5 >= _value
REF_6(mapping(address => uint256)) -> allowed[_from]
REF_7(uint256) -> REF_6[msg.sender]
TMP_10(bool) = REF_7 >= _value
TMP_11(bool) = TMP_9 && TMP_10
TMP_12(bool) = _value > 0
TMP_13(bool) = TMP_11 && TMP_12
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_8(uint256) -> balances[_to]
REF_8(-> balances) = REF_8 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_9(uint256) -> balances[_from]
REF_9(-> balances) = REF_9 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_10(mapping(address => uint256)) -> allowed[_from]
REF_11(uint256) -> REF_10[msg.sender]
REF_11(-> allowed) = REF_11 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
}
",0,1,0,0,"require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);balances[_to] += _value;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value)"
./0x2791528f5617e187a6d73c30034ac211b2f47042_ext.sol,CardsRaffle.getPlayersTickets,280,294,"REF_64(CardsRaffle.TicketPurchases) -> ticketsBoughtByPlayer[player],playersTickets(CardsRaffle.TicketPurchases) := REF_64(CardsRaffle.TicketPurchases),REF_65(uint256) -> playersTickets.raffleRareId,TMP_120(bool) = REF_65 == raffleRareId,CONDITION TMP_120,REF_66(uint256) -> playersTickets.numPurchases,TMP_122(uint256[])  = new uint256[](REF_66),startIds(uint256[]) = ['TMP_122(uint256[])'],REF_67(uint256) -> playersTickets.numPurchases,TMP_124(uint256[])  = new uint256[](REF_67),endIds(uint256[]) = ['TMP_124(uint256[])'],i(uint256) := 0(uint256),REF_68(uint256) -> playersTickets.numPurchases,TMP_125(bool) = i < REF_68,CONDITION TMP_125,REF_69(uint256) -> startIds[i],REF_70(CardsRaffle.TicketPurchase[]) -> playersTickets.ticketsBought,REF_71(CardsRaffle.TicketPurchase) -> REF_70[i],REF_72(uint256) -> REF_71.startId,REF_69(uint256) (->startIds) := REF_72(uint256),REF_73(uint256) -> endIds[i],REF_74(CardsRaffle.TicketPurchase[]) -> playersTickets.ticketsBought,REF_75(CardsRaffle.TicketPurchase) -> REF_74[i],REF_76(uint256) -> REF_75.endId,REF_73(uint256) (->endIds) := REF_76(uint256),TMP_126(uint256) := i(uint256),i(uint256) = i + 1,RETURN startIds,endIds","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
playersTickets = ticketsBoughtByPlayer[player]

IRs:
REF_64(CardsRaffle.TicketPurchases) -> ticketsBoughtByPlayer[player]
playersTickets(CardsRaffle.TicketPurchases) := REF_64(CardsRaffle.TicketPurchases)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
playersTickets.raffleRareId == raffleRareId

IRs:
REF_65(uint256) -> playersTickets.raffleRareId
TMP_120(bool) = REF_65 == raffleRareId
CONDITION TMP_120""];
2->3[label=""True""];
2->12[label=""False""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
startIds = new uint256[](playersTickets.numPurchases)

IRs:
REF_66(uint256) -> playersTickets.numPurchases
TMP_122(uint256[])  = new uint256[](REF_66)
startIds(uint256[]) = ['TMP_122(uint256[])']""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
endIds = new uint256[](playersTickets.numPurchases)

IRs:
REF_67(uint256) -> playersTickets.numPurchases
TMP_124(uint256[])  = new uint256[](REF_67)
endIds(uint256[]) = ['TMP_124(uint256[])']""];
4->7;
5[label=""Node Type: BEGIN_LOOP 5
""];
5->8;
6[label=""Node Type: END_LOOP 6
""];
6->12;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
7->5;
8[label=""Node Type: IF_LOOP 8

EXPRESSION:
i < playersTickets.numPurchases

IRs:
REF_68(uint256) -> playersTickets.numPurchases
TMP_125(bool) = i < REF_68
CONDITION TMP_125""];
8->9[label=""True""];
8->6[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
startIds[i] = playersTickets.ticketsBought[i].startId

IRs:
REF_69(uint256) -> startIds[i]
REF_70(CardsRaffle.TicketPurchase[]) -> playersTickets.ticketsBought
REF_71(CardsRaffle.TicketPurchase) -> REF_70[i]
REF_72(uint256) -> REF_71.startId
REF_69(uint256) (->startIds) := REF_72(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
endIds[i] = playersTickets.ticketsBought[i].endId

IRs:
REF_73(uint256) -> endIds[i]
REF_74(CardsRaffle.TicketPurchase[]) -> playersTickets.ticketsBought
REF_75(CardsRaffle.TicketPurchase) -> REF_74[i]
REF_76(uint256) -> REF_75.endId
REF_73(uint256) (->endIds) := REF_76(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_126(uint256) := i(uint256)
i(uint256) = i + 1""];
11->8;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: RETURN 13

EXPRESSION:
(startIds,endIds)

IRs:
RETURN startIds,endIds""];
}
",0,1,0,0,"playersTickets = ticketsBoughtByPlayer[player];playersTickets.raffleRareId == raffleRareId;startIds = new uint256[](playersTickets.numPurchases);;endIds = new uint256[](playersTickets.numPurchases);i = 0;;i < playersTickets.numPurchases;;startIds[i] = playersTickets.ticketsBought[i].startId;endIds[i] = playersTickets.ticketsBought[i].endId;i ++;(startIds,endIds)"
./0x4bbbc57af270138ef2ff2c50dbfad684e9e0e604_ext.sol,TokenERC20.approveAndCall,112,120,"TMP_22 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_22(tokenRecipient),TMP_23(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value),CONDITION TMP_23,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_22 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_22(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_23(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value)
CONDITION TMP_23""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x53ef8e6cb3a7c96d7aecf39b2d4d09c166269c34_ext.sol,AUX1418.totalSupply,127,129,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x4c5e9c0c0bf644cd265c9500e1aad0bae0977b78_ext.sol,TASOHATOKEN.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xda36819cfa6167ab5d7932aa8a7852b377a15ab9_ext.sol,DOJC.burnFrom,140,148,"REF_19(uint256) -> balanceOf[_from],TMP_22(bool) = REF_19 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_24(bool) = _value <= REF_21,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_22(bool) = REF_19 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_24(bool) = _value <= REF_21
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x0d74fb34583d4e14bf9634bfd1887e86d3c1f139_ext.sol,YOUR_CHANCE.set_game,20,27,"TMP_7(bool) = responseHash == 0,CONDITION TMP_7,TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response),responseHash(bytes32) := TMP_8(bytes32),question(string) := _question(string),questionSender(address) := msg.sender(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
responseHash == 0x0

IRs:
TMP_7(bool) = responseHash == 0
CONDITION TMP_7""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
responseHash = keccak256()(_response)

IRs:
TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response)
responseHash(bytes32) := TMP_8(bytes32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
questionSender = msg.sender

IRs:
questionSender(address) := msg.sender(address)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,1,0,0,responseHash == 0x0;responseHash = keccak256()(_response);;question = _question;questionSender = msg.sender
./0x5be7d692a8adc3dff8296f5f316a736b02dcef24_ext.sol,ECTCOIN.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_22(bool) = REF_19 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_24(bool) = _value <= REF_21,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_22(bool) = REF_19 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_24(bool) = _value <= REF_21
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x8a63a921b5d678b4a27dc81e44321923e297b4cf_ext.sol,Doves.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x484637c005c96e9308525c2019430f6846157157_ext.sol,Subscribers.subscribe,45,60,"REF_0(Subscribers.Subscriber) -> subs[_email],REF_1(uint256) -> REF_0.expires,from(uint256) := REF_1(uint256),TMP_5(bool) = from == 0,CONDITION TMP_5,from(uint256) := now(uint256),TMP_6(bool) = msg.value >= requiredPrice,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_2(Subscribers.Subscriber) -> subs[_email],TMP_8(uint256) = from + requiredDuration,TMP_9(Subscribers.Subscriber) = new Subscriber(TMP_8,_subscriber),REF_2(Subscribers.Subscriber) (->subs) := TMP_9(Subscribers.Subscriber),Emit Subscribed(_email,_monthOrYear,_subscriber),TMP_11(bool) = _monthOrYear == 1,CONDITION TMP_11,requiredPrice(uint256) := monthlyPrice(uint256),requiredPrice(uint256) := annualPrice(uint256),TMP_12(bool) = _monthOrYear == 1,CONDITION TMP_12,requiredDuration(uint256) := 2629746(uint256),requiredDuration(uint256) := 31556952(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
from = subs[_email].expires

IRs:
REF_0(Subscribers.Subscriber) -> subs[_email]
REF_1(uint256) -> REF_0.expires
from(uint256) := REF_1(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
from == 0

IRs:
TMP_5(bool) = from == 0
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
from = now

IRs:
from(uint256) := now(uint256)""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->10;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(msg.value >= requiredPrice)

IRs:
TMP_6(bool) = msg.value >= requiredPrice
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
6->14;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
subs[_email] = Subscriber(from + requiredDuration,_subscriber)

IRs:
REF_2(Subscribers.Subscriber) -> subs[_email]
TMP_8(uint256) = from + requiredDuration
TMP_9(Subscribers.Subscriber) = new Subscriber(TMP_8,_subscriber)
REF_2(Subscribers.Subscriber) (->subs) := TMP_9(Subscribers.Subscriber)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
Subscribed(_email,_monthOrYear,_subscriber)

IRs:
Emit Subscribed(_email,_monthOrYear,_subscriber)""];
10[label=""Node Type: IF 10

EXPRESSION:
(_monthOrYear == 1)

IRs:
TMP_11(bool) = _monthOrYear == 1
CONDITION TMP_11""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
requiredPrice = monthlyPrice

IRs:
requiredPrice(uint256) := monthlyPrice(uint256)""];
11->13;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
requiredPrice = annualPrice

IRs:
requiredPrice(uint256) := annualPrice(uint256)""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->6;
14[label=""Node Type: IF 14

EXPRESSION:
(_monthOrYear == 1)

IRs:
TMP_12(bool) = _monthOrYear == 1
CONDITION TMP_12""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
requiredDuration = 2629746

IRs:
requiredDuration(uint256) := 2629746(uint256)""];
15->17;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
requiredDuration = 31556952

IRs:
requiredDuration(uint256) := 31556952(uint256)""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->8;
}
",0,1,0,0,"from = subs[_email].expires;from == 0;from = now;;(_monthOrYear == 1);require(bool)(msg.value >= requiredPrice);(_monthOrYear == 1);subs[_email] = Subscriber(from + requiredDuration,_subscriber);Subscribed(_email,_monthOrYear,_subscriber);requiredPrice = monthlyPrice;requiredPrice = annualPrice;;requiredDuration = 2629746;requiredDuration = 31556952;"
./0x69875fbeb23cfd52e7e7c23929c4f50a4fc377c3_ext.sol,ThinSkinLarry.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x836f95d2a2f5150200c76f45a0b0679542ab6bbd_ext.sol,BANK_IV_PFII_883.transferFrom,42,54,"REF_6(uint256) -> balanceOf[from],TMP_6(bool) = value <= REF_6,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_7(mapping(address => uint256)) -> allowance[from],REF_8(uint256) -> REF_7[msg.sender],TMP_8(bool) = value <= REF_8,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_9(uint256) -> balanceOf[from],REF_9(-> balanceOf) = REF_9 - value,REF_10(uint256) -> balanceOf[to],REF_10(-> balanceOf) = REF_10 + value,REF_11(mapping(address => uint256)) -> allowance[from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowance) = REF_12 - value,Emit Transfer(from,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(value <= balanceOf[from])

IRs:
REF_6(uint256) -> balanceOf[from]
TMP_6(bool) = value <= REF_6
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value <= allowance[from][msg.sender])

IRs:
REF_7(mapping(address => uint256)) -> allowance[from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_8(bool) = value <= REF_8
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[from] -= value

IRs:
REF_9(uint256) -> balanceOf[from]
REF_9(-> balanceOf) = REF_9 - value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[to] += value

IRs:
REF_10(uint256) -> balanceOf[to]
REF_10(-> balanceOf) = REF_10 + value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allowance[from][msg.sender] -= value

IRs:
REF_11(mapping(address => uint256)) -> allowance[from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowance) = REF_12 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(value <= balanceOf[from]);require(bool)(value <= allowance[from][msg.sender]);balanceOf[from] -= value;balanceOf[to] += value;allowance[from][msg.sender] -= value;Transfer(from,to,value);true;success"
./0x5b463c4e19358b4eaf010cf24244bf140541a63e_ext.sol,TokenERC20.approveAndCall,77,83,"TMP_26 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_26(tokenRecipient),TMP_27(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value),CONDITION TMP_27,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_26 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_26(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_27(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value)
CONDITION TMP_27""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x6cd36a328523701f09804a2559fe2581eae0aacc_ext.sol,MyToken.burn,76,82,"REF_18(uint256) -> balanceOf[msg.sender],TMP_14(bool) = REF_18 < _value,CONDITION TMP_14,REF_19(uint256) -> balanceOf[msg.sender],REF_19(-> balanceOf) = REF_19 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balanceOf[msg.sender] < _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
TMP_14(bool) = REF_18 < _value
CONDITION TMP_14""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_19(uint256) -> balanceOf[msg.sender]
REF_19(-> balanceOf) = REF_19 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balanceOf[msg.sender] < _value;;;balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xd216c12e89ac892e944edf6c947c860681ef18da_ext.sol,Knightium.burnFrom,139,147,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xdbcd6bd6ecaa36c8a6c554d70b7f39d6c0fd7ad2_ext.sol,BFBtoken._transfer,45,61,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x3fab284a3cd0a6d88d18d0fda4bc1a76cdacd68a_ext.sol,qui_qz.NewQuestion,46,55,"TMP_12(bool) = msg.sender == questionSender,TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12),question(string) := _question(string),responseHash(bytes32) := _responseHash(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_12(bool) = msg.sender == questionSender
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
responseHash = _responseHash

IRs:
responseHash(bytes32) := _responseHash(bytes32)""];
}
",0,1,0,0,require(bool)(msg.sender == questionSender);question = _question;responseHash = _responseHash
./0x065313f29dc4a4b8b5fc4915059d122065519957_ext.sol,Future1Exchange.safeSub,35,39,"TMP_1(uint256) = crtbal - depbal,totalbal(uint256) := TMP_1(uint256),RETURN totalbal","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
totalbal = crtbal - depbal

IRs:
TMP_1(uint256) = crtbal - depbal
totalbal(uint256) := TMP_1(uint256)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
totalbal

IRs:
RETURN totalbal""];
}
",0,1,0,0,totalbal = crtbal - depbal;totalbal
./0x753e7389ecc2566264587522a3e96e12d7a442c9_ext.sol,BKKToken.burnFrom,138,146,"REF_19(uint256) -> balanceOf[_from],TMP_22(bool) = REF_19 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_24(bool) = _value <= REF_21,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_22(bool) = REF_19 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_24(bool) = _value <= REF_21
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x77d4447a3f042d3c88fae21b28d52b905d6c3dfc_ext.sol,SafeMath.getRandomNumber,78,81,"TMP_26(uint256) = block.number - 1,TMP_27(uint256) = SOLIDITY_CALL blockhash(uint256)(TMP_26),TMP_28 = CONVERT TMP_27 to uint256,TMP_29 = CONVERT privateAddress to uint256,TMP_30(uint256) = TMP_28 + TMP_29,genNum(uint256) := TMP_30(uint256),TMP_31(uint16) = maxRandom - min,TMP_32(uint16) = TMP_31 + 1,TMP_33(uint256) = genNum % TMP_32,TMP_34(uint256) = TMP_33 + min,TMP_35 = CONVERT TMP_34 to uint8,RETURN TMP_35","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
genNum = uint256(block.blockhash(block.number - 1)) + uint256(privateAddress)

IRs:
TMP_26(uint256) = block.number - 1
TMP_27(uint256) = SOLIDITY_CALL blockhash(uint256)(TMP_26)
TMP_28 = CONVERT TMP_27 to uint256
TMP_29 = CONVERT privateAddress to uint256
TMP_30(uint256) = TMP_28 + TMP_29
genNum(uint256) := TMP_30(uint256)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
uint8(genNum % (maxRandom - min + 1) + min)

IRs:
TMP_31(uint16) = maxRandom - min
TMP_32(uint16) = TMP_31 + 1
TMP_33(uint256) = genNum % TMP_32
TMP_34(uint256) = TMP_33 + min
TMP_35 = CONVERT TMP_34 to uint8
RETURN TMP_35""];
}
",0,1,0,0,genNum = uint256(block.blockhash(block.number - 1)) + uint256(privateAddress);uint8(genNum % (maxRandom - min + 1) + min)
./0x3fc191537bdf7b87f5210220a878dd751444bccf_ext.sol,WELFARECOIN.burnFrom,149,157,"REF_19(uint256) -> balanceOf[_from],TMP_26(bool) = REF_19 >= _value,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_28(bool) = _value <= REF_21,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_26(bool) = REF_19 >= _value
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_28(bool) = _value <= REF_21
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x586927ff87bf40aada74afbff5e2409b865be023_ext.sol,HashBet.resolveBet,24,39,"REF_5(HashBet.Bet) -> bets[msg.sender],bet(HashBet.Bet) := REF_5(HashBet.Bet),REF_6(uint256) -> bet.height,TMP_4(uint256) = block.number - REF_6,dist(uint256) := TMP_4(uint256),TMP_5(bool) = dist < 255,TMP_6(bool) = dist > 3,TMP_7(bool) = TMP_5 && TMP_6,TMP_8(None) = SOLIDITY_CALL require(bool)(TMP_7),REF_7(uint256) -> bet.height,TMP_9(uint256) = SOLIDITY_CALL blockhash(uint256)(REF_7),h1(bytes32) := TMP_9(uint256),REF_8(uint256) -> bet.height,TMP_10(uint256) = REF_8 + 3,TMP_11(uint256) = SOLIDITY_CALL blockhash(uint256)(TMP_10),h2(bytes32) := TMP_11(uint256),TMP_12(bytes32) = SOLIDITY_CALL keccak256()(h1,h2),TMP_13 = CONVERT TMP_12 to uint256,hashVal(uint256) := TMP_13(uint256),FACTOR(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129640(uint256),TMP_14(uint256) = hashVal / FACTOR,TMP_15 = CONVERT TMP_14 to uint16,TMP_16(uint16) = TMP_15 % 1000,result(uint16) := TMP_16(uint16),REF_9(uint256) -> bet.height,REF_9(uint256) (->bet) := 0(uint256),TMP_17(bool) = result <= 495,CONDITION TMP_17,TMP_18 = CONVERT this to address,TMP_19(uint256) = SOLIDITY_CALL balance(address)(TMP_18),Transfer dest:msg.sender value:TMP_19,Emit Result(hashVal,result)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
bet = bets[msg.sender]

IRs:
REF_5(HashBet.Bet) -> bets[msg.sender]
bet(HashBet.Bet) := REF_5(HashBet.Bet)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
dist = block.number - bet.height

IRs:
REF_6(uint256) -> bet.height
TMP_4(uint256) = block.number - REF_6
dist(uint256) := TMP_4(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(dist < 255 && dist > 3)

IRs:
TMP_5(bool) = dist < 255
TMP_6(bool) = dist > 3
TMP_7(bool) = TMP_5 && TMP_6
TMP_8(None) = SOLIDITY_CALL require(bool)(TMP_7)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
h1 = block.blockhash(bet.height)

IRs:
REF_7(uint256) -> bet.height
TMP_9(uint256) = SOLIDITY_CALL blockhash(uint256)(REF_7)
h1(bytes32) := TMP_9(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
h2 = block.blockhash(bet.height + 3)

IRs:
REF_8(uint256) -> bet.height
TMP_10(uint256) = REF_8 + 3
TMP_11(uint256) = SOLIDITY_CALL blockhash(uint256)(TMP_10)
h2(bytes32) := TMP_11(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
hashVal = uint256(keccak256()(h1,h2))

IRs:
TMP_12(bytes32) = SOLIDITY_CALL keccak256()(h1,h2)
TMP_13 = CONVERT TMP_12 to uint256
hashVal(uint256) := TMP_13(uint256)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
FACTOR = 115792089237316195423570985008687907853269984665640564039457584007913129640

IRs:
FACTOR(uint256) := 115792089237316195423570985008687907853269984665640564039457584007913129640(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
result = uint16((hashVal / FACTOR)) % 1000

IRs:
TMP_14(uint256) = hashVal / FACTOR
TMP_15 = CONVERT TMP_14 to uint16
TMP_16(uint16) = TMP_15 % 1000
result(uint16) := TMP_16(uint16)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
bet.height = 0

IRs:
REF_9(uint256) -> bet.height
REF_9(uint256) (->bet) := 0(uint256)""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
result <= 495

IRs:
TMP_17(bool) = result <= 495
CONDITION TMP_17""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_18 = CONVERT this to address
TMP_19(uint256) = SOLIDITY_CALL balance(address)(TMP_18)
Transfer dest:msg.sender value:TMP_19""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
Result(hashVal,result)

IRs:
Emit Result(hashVal,result)""];
}
",0,1,0,0,"bet = bets[msg.sender];dist = block.number - bet.height;require(bool)(dist < 255 && dist > 3);h1 = block.blockhash(bet.height);h2 = block.blockhash(bet.height + 3);hashVal = uint256(keccak256()(h1,h2));FACTOR = 115792089237316195423570985008687907853269984665640564039457584007913129640;result = uint16((hashVal / FACTOR)) % 1000;bet.height = 0;result <= 495;msg.sender.transfer(address(this).balance);;Result(hashVal,result)"
./0xf272fb519aed5e92a06a90426336f378423718e5_ext.sol,TokenERC20.burnFrom,138,146,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x92891fb5abe9049e181ca49ce04a9872c0c1ca44_ext.sol,SimplyBank.fallback,31,64,"TMP_0(bool) = msg.value == 1120000000000,CONDITION TMP_0,REF_0(uint256) -> invests[sender],TMP_1(uint256) = REF_0 * 10,TMP_2(uint256) = TMP_1 / 100,techSupportPercent(uint256) := TMP_2(uint256),Transfer dest:TECH_SUPPORT value:techSupportPercent,REF_2(uint256) -> invests[sender],TMP_4(uint256) = REF_2 - techSupportPercent,withdrawalAmount(uint256) := TMP_4(uint256),Transfer dest:sender value:withdrawalAmount,REF_4(uint256) -> dates[sender],REF_4(uint256) (->dates) := 0(uint256),REF_5(uint256) -> invests[sender],REF_5(uint256) (->invests) := 0(uint256),sender(address) := msg.sender(address),REF_6(uint256) -> invests[sender],TMP_6(bool) = REF_6 != 0,CONDITION TMP_6,REF_7(uint256) -> invests[sender],TMP_7(uint256) = REF_7 / 100,REF_8(uint256) -> dates[sender],TMP_8(uint256) = now - REF_8,TMP_9(uint256) = TMP_7 * TMP_8,TMP_10(uint256) = TMP_9 / 86400,payout(uint256) := TMP_10(uint256),TMP_11 = CONVERT this to address,TMP_12(uint256) = SOLIDITY_CALL balance(address)(TMP_11),TMP_13(bool) = payout > TMP_12,CONDITION TMP_13,TMP_14 = CONVERT this to address,TMP_15(uint256) = SOLIDITY_CALL balance(address)(TMP_14),payout(uint256) := TMP_15(uint256),Transfer dest:sender value:payout,REF_10(uint256) -> dates[sender],REF_10(uint256) (->dates) := now(uint256),REF_11(uint256) -> invests[sender],REF_11(-> invests) = REF_11 + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value == 1120000000000

IRs:
TMP_0(bool) = msg.value == 1120000000000
CONDITION TMP_0""];
1->2[label=""True""];
1->8[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
techSupportPercent = invests[sender] * 10 / 100

IRs:
REF_0(uint256) -> invests[sender]
TMP_1(uint256) = REF_0 * 10
TMP_2(uint256) = TMP_1 / 100
techSupportPercent(uint256) := TMP_2(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
TECH_SUPPORT.transfer(techSupportPercent)

IRs:
Transfer dest:TECH_SUPPORT value:techSupportPercent""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
withdrawalAmount = invests[sender] - techSupportPercent

IRs:
REF_2(uint256) -> invests[sender]
TMP_4(uint256) = REF_2 - techSupportPercent
withdrawalAmount(uint256) := TMP_4(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
sender.transfer(withdrawalAmount)

IRs:
Transfer dest:sender value:withdrawalAmount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
dates[sender] = 0

IRs:
REF_4(uint256) -> dates[sender]
REF_4(uint256) (->dates) := 0(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
invests[sender] = 0

IRs:
REF_5(uint256) -> invests[sender]
REF_5(uint256) (->invests) := 0(uint256)""];
7->18;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
sender = msg.sender

IRs:
sender(address) := msg.sender(address)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
invests[sender] != 0

IRs:
REF_6(uint256) -> invests[sender]
TMP_6(bool) = REF_6 != 0
CONDITION TMP_6""];
9->10[label=""True""];
9->15[label=""False""];
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
payout = invests[sender] / 100 * (now - dates[sender]) / 86400

IRs:
REF_7(uint256) -> invests[sender]
TMP_7(uint256) = REF_7 / 100
REF_8(uint256) -> dates[sender]
TMP_8(uint256) = now - REF_8
TMP_9(uint256) = TMP_7 * TMP_8
TMP_10(uint256) = TMP_9 / 86400
payout(uint256) := TMP_10(uint256)""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
payout > address(this).balance

IRs:
TMP_11 = CONVERT this to address
TMP_12(uint256) = SOLIDITY_CALL balance(address)(TMP_11)
TMP_13(bool) = payout > TMP_12
CONDITION TMP_13""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
payout = address(this).balance

IRs:
TMP_14 = CONVERT this to address
TMP_15(uint256) = SOLIDITY_CALL balance(address)(TMP_14)
payout(uint256) := TMP_15(uint256)""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
sender.transfer(payout)

IRs:
Transfer dest:sender value:payout""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
dates[sender] = now

IRs:
REF_10(uint256) -> dates[sender]
REF_10(uint256) (->dates) := now(uint256)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
invests[sender] += msg.value

IRs:
REF_11(uint256) -> invests[sender]
REF_11(-> invests) = REF_11 + msg.value""];
17->18;
18[label=""Node Type: END_IF 18
""];
}
",0,1,0,0,msg.value == 1120000000000;techSupportPercent = invests[sender] * 10 / 100;sender = msg.sender;TECH_SUPPORT.transfer(techSupportPercent);withdrawalAmount = invests[sender] - techSupportPercent;sender.transfer(withdrawalAmount);dates[sender] = 0;invests[sender] = 0;;invests[sender] != 0;payout = invests[sender] / 100 * (now - dates[sender]) / 86400;;payout > address(this).balance;payout = address(this).balance;;sender.transfer(payout);dates[sender] = now;invests[sender] += msg.value
./0xcd74d15b488ed7ef7874819e8cb6daa75a759dc3_ext.sol,OPTPRG_EURRUB_20190423_1.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x51f545a57a88d193227f506ff07911da0df2749c_ext.sol,MEXICO_WINS.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x2fdd5095ecf5f563a80826bd4b381532e7d43c9e_ext.sol,DHANACOIN.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x4c30afe476e90b3a1e094a6ed6c17c0369a6d4ef_ext.sol,EBCoin.MintToken,167,171,"currentSupply(uint256) = currentSupply + amt,REF_8(uint256) -> balances[this],REF_8(-> balances) = REF_8 + amt,TMP_64 = CONVERT 0 to address,Emit Transfer(TMP_64,this,amt),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
currentSupply += amt

IRs:
currentSupply(uint256) = currentSupply + amt""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[this] += amt

IRs:
REF_8(uint256) -> balances[this]
REF_8(-> balances) = REF_8 + amt""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(address(0),this,amt)

IRs:
TMP_64 = CONVERT 0 to address
Emit Transfer(TMP_64,this,amt)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
4->1;
}
",0,1,0,0,"onlyOwner();currentSupply += amt;balances[this] += amt;Transfer(address(0),this,amt)"
./0x0dcc6e4f98e734048689a63b824e89b8a58ed591_ext.sol,MDGame.StartNewGame,65,72,"REF_0(MDGame.turnInfos) -> TurnInfo[theTurn],REF_1(uint256) -> REF_0.endTime,TMP_12(bool) = REF_1 < now,TMP_13(bool) = theTurn == 0,TMP_14(bool) = TMP_12 || TMP_13,TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14),TMP_16(uint256) := theTurn(uint256),theTurn(uint256) = theTurn + 1,REF_2(MDGame.turnInfos) -> TurnInfo[theTurn],REF_3(string) -> REF_2.question,REF_3(string) (->TurnInfo) := question(string),REF_4(MDGame.turnInfos) -> TurnInfo[theTurn],REF_5(string) -> REF_4.option1name,REF_5(string) (->TurnInfo) := option1name(string),REF_6(MDGame.turnInfos) -> TurnInfo[theTurn],REF_7(string) -> REF_6.option2name,REF_7(string) (->TurnInfo) := option2name(string),REF_8(MDGame.turnInfos) -> TurnInfo[theTurn],REF_9(uint256) -> REF_8.endTime,TMP_17(uint256) = turnLast * 60,TMP_18(uint256) = now + TMP_17,REF_9(uint256) (->TurnInfo) := TMP_18(uint256),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(TurnInfo[theTurn].endTime < now || theTurn == 0)

IRs:
REF_0(MDGame.turnInfos) -> TurnInfo[theTurn]
REF_1(uint256) -> REF_0.endTime
TMP_12(bool) = REF_1 < now
TMP_13(bool) = theTurn == 0
TMP_14(bool) = TMP_12 || TMP_13
TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
theTurn ++

IRs:
TMP_16(uint256) := theTurn(uint256)
theTurn(uint256) = theTurn + 1""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
TurnInfo[theTurn].question = question

IRs:
REF_2(MDGame.turnInfos) -> TurnInfo[theTurn]
REF_3(string) -> REF_2.question
REF_3(string) (->TurnInfo) := question(string)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
TurnInfo[theTurn].option1name = option1name

IRs:
REF_4(MDGame.turnInfos) -> TurnInfo[theTurn]
REF_5(string) -> REF_4.option1name
REF_5(string) (->TurnInfo) := option1name(string)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
TurnInfo[theTurn].option2name = option2name

IRs:
REF_6(MDGame.turnInfos) -> TurnInfo[theTurn]
REF_7(string) -> REF_6.option2name
REF_7(string) (->TurnInfo) := option2name(string)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
TurnInfo[theTurn].endTime = now + turnLast * 60

IRs:
REF_8(MDGame.turnInfos) -> TurnInfo[theTurn]
REF_9(uint256) -> REF_8.endTime
TMP_17(uint256) = turnLast * 60
TMP_18(uint256) = now + TMP_17
REF_9(uint256) (->TurnInfo) := TMP_18(uint256)""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
7->1;
}
",0,1,0,0,onlyOwner();require(bool)(TurnInfo[theTurn].endTime < now || theTurn == 0);theTurn ++;TurnInfo[theTurn].question = question;TurnInfo[theTurn].option1name = option1name;TurnInfo[theTurn].option2name = option2name;TurnInfo[theTurn].endTime = now + turnLast * 60
./0x41451e8e7fd5b9a4f8176ccf1a0db2b68abc77fb_ext.sol,FART.dividendsOf,403,408,"REF_30(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_60(uint256) = profitPerShare_ * REF_30,TMP_61 = CONVERT TMP_60 to int256,REF_31(int256) -> payoutsTo_[_customerAddress],TMP_62(int256) = TMP_61 - REF_31,TMP_63 = CONVERT TMP_62 to uint256,TMP_64(uint256) = TMP_63 / magnitude,RETURN TMP_64","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_30(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_60(uint256) = profitPerShare_ * REF_30
TMP_61 = CONVERT TMP_60 to int256
REF_31(int256) -> payoutsTo_[_customerAddress]
TMP_62(int256) = TMP_61 - REF_31
TMP_63 = CONVERT TMP_62 to uint256
TMP_64(uint256) = TMP_63 / magnitude
RETURN TMP_64""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x6d8811059eb8f0509acec06648ea95b3ae01be72_ext.sol,TokenERC20._transfer,47,63,"TMP_3 = CONVERT 0 to address,TMP_4(bool) = _to != TMP_3,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_1(uint256) -> balanceOf[_from],TMP_6(bool) = REF_1 >= _value,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_2(uint256) -> balanceOf[_to],TMP_8(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_9(bool) = TMP_8 >= REF_3,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_11(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_11(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_13(uint256) = REF_8 + REF_9,TMP_14(bool) = TMP_13 == previousBalances,TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0x0))

IRs:
TMP_3 = CONVERT 0 to address
TMP_4(bool) = _to != TMP_3
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_6(bool) = REF_1 >= _value
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_8(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_9(bool) = TMP_8 >= REF_3
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_11(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_11(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_13(uint256) = REF_8 + REF_9
TMP_14(bool) = TMP_13 == previousBalances
TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)""];
}
",0,1,0,0,"require(bool)(_to != address(0x0));require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x190e569be071f40c704e15825f285481cb74b6cc_ext.sol,ERC20Standard.transferFrom,38,44,"REF_4(uint256) -> balances[_from],TMP_7(bool) = REF_4 >= _value,REF_5(mapping(address => uint256)) -> allowed[_from],REF_6(uint256) -> REF_5[msg.sender],TMP_8(bool) = REF_6 >= _value,TMP_9(bool) = TMP_7 && TMP_8,TMP_10(bool) = _value > 0,TMP_11(bool) = TMP_9 && TMP_10,TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11),REF_7(uint256) -> balances[_to],REF_7(-> balances) = REF_7 + _value,REF_8(uint256) -> balances[_from],REF_8(-> balances) = REF_8 - _value,REF_9(mapping(address => uint256)) -> allowed[_from],REF_10(uint256) -> REF_9[msg.sender],REF_10(-> allowed) = REF_10 - _value,Emit Transfer(_from,_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0)

IRs:
REF_4(uint256) -> balances[_from]
TMP_7(bool) = REF_4 >= _value
REF_5(mapping(address => uint256)) -> allowed[_from]
REF_6(uint256) -> REF_5[msg.sender]
TMP_8(bool) = REF_6 >= _value
TMP_9(bool) = TMP_7 && TMP_8
TMP_10(bool) = _value > 0
TMP_11(bool) = TMP_9 && TMP_10
TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_7(uint256) -> balances[_to]
REF_7(-> balances) = REF_7 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_8(uint256) -> balances[_from]
REF_8(-> balances) = REF_8 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_9(mapping(address => uint256)) -> allowed[_from]
REF_10(uint256) -> REF_9[msg.sender]
REF_10(-> allowed) = REF_10 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
}
",0,1,0,0,"require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);balances[_to] += _value;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value)"
./0x6dd2c2a82234d280e2b397db17b923fab49695e6_ext.sol,DHSCToken.changeNameAndSymbol,173,178,"TMP_71(bool) = msg.sender == owner,CONDITION TMP_71,name(string) := _name(string),symbol(string) := _symbol(string)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_71(bool) = msg.sender == owner
CONDITION TMP_71""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
name = _name

IRs:
name(string) := _name(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
symbol = _symbol

IRs:
symbol(string) := _symbol(string)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,msg.sender == owner;name = _name;;symbol = _symbol
./0x873467738b5053f155639208b7495318fced5262_ext.sol,StreamNetworkToken.approveAndCall,200,205,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x417866263b96ea8fb86e1f332018dda49820c85a_ext.sol,ERC1003Caller.makeCall,523,526,"TMP_118(bool) = LOW_LEVEL_CALL, dest:target, function:call, arguments:['data'] value:msg.value ,RETURN TMP_118,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: RETURN 1

EXPRESSION:
target.call.value(msg.value)(data)

IRs:
TMP_118(bool) = LOW_LEVEL_CALL, dest:target, function:call, arguments:['data'] value:msg.value 
RETURN TMP_118""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,1,0,0,onlyOwner();target.call.value(msg.value)(data)
./0x51a1a60ae2310e34295a18b559cac9e4140303d7_ext.sol,MainCard.GetExistsCardList,322,325,"REF_68(uint32[]) -> g_CardLib.m_List,RETURN REF_68","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
g_CardLib.m_List

IRs:
REF_68(uint32[]) -> g_CardLib.m_List
RETURN REF_68""];
}
",0,1,0,0,g_CardLib.m_List
./0xec8f9a0de90487e7aa172fe5291fd19ad7163aa1_ext.sol,BDSMAirdrop.multiSend,25,35,"i(uint256) := 0(uint256),REF_0 -> LENGTH _dests,TMP_1(bool) = i < REF_0,CONDITION TMP_1,REF_2(address) -> _dests[i],HIGH_LEVEL_CALL, dest:sharesTokenAddress(token), function:transfer, arguments:['REF_2', 'defValue']  ,i(uint256) = i + 1,TMP_3(uint256) = HIGH_LEVEL_CALL, dest:sharesTokenAddress(token), function:balanceOf, arguments:['this']  ,tokenFree(uint256) := TMP_3(uint256),MODIFIER_CALL, BDSMAirdrop.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->3;
3[label=""Node Type: IF_LOOP 3

EXPRESSION:
i < _dests.length

IRs:
REF_0 -> LENGTH _dests
TMP_1(bool) = i < REF_0
CONDITION TMP_1""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
sharesTokenAddress.transfer(_dests[i],defValue)

IRs:
REF_2(address) -> _dests[i]
HIGH_LEVEL_CALL, dest:sharesTokenAddress(token), function:transfer, arguments:['REF_2', 'defValue']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
i += 1

IRs:
i(uint256) = i + 1""];
5->3;
6[label=""Node Type: END_LOOP 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokenFree = sharesTokenAddress.balanceOf(this)

IRs:
TMP_3(uint256) = HIGH_LEVEL_CALL, dest:sharesTokenAddress(token), function:balanceOf, arguments:['this']  
tokenFree(uint256) := TMP_3(uint256)""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, BDSMAirdrop.onlyOwner()()""];
8->1;
}
",0,1,0,0,"onlyOwner();i = 0;;i < _dests.length;sharesTokenAddress.transfer(_dests[i],defValue);;i += 1;tokenFree = sharesTokenAddress.balanceOf(this)"
./0x5c976e71bb27538bddb0ed399be1722c6745bcb6_ext.sol,ProofOfKennyCoin.dividendsOf,466,472,"REF_35(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_65(uint256) = profitPerShare_ * REF_35,TMP_66 = CONVERT TMP_65 to int256,REF_36(int256) -> payoutsTo_[_customerAddress],TMP_67(int256) = TMP_66 - REF_36,TMP_68 = CONVERT TMP_67 to uint256,TMP_69(uint256) = TMP_68 / magnitude,RETURN TMP_69","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_35(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_65(uint256) = profitPerShare_ * REF_35
TMP_66 = CONVERT TMP_65 to int256
REF_36(int256) -> payoutsTo_[_customerAddress]
TMP_67(int256) = TMP_66 - REF_36
TMP_68 = CONVERT TMP_67 to uint256
TMP_69(uint256) = TMP_68 / magnitude
RETURN TMP_69""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x3ac96bbe8b60d715fd818b3fe242edf9def20571_ext.sol,MyBoToken.burn,175,181,"REF_61(uint256) -> balanceOf[msg.sender],TMP_51(bool) = REF_61 < amount,CONDITION TMP_51,REF_62(uint256) -> balanceOf[msg.sender],REF_62(-> balanceOf) = REF_62 - amount,totalSupply(uint256) = totalSupply - amount,Emit Burn(msg.sender,amount),RETURN True,MODIFIER_CALL, owned.onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: IF 1

EXPRESSION:
balanceOf[msg.sender] < amount

IRs:
REF_61(uint256) -> balanceOf[msg.sender]
TMP_51(bool) = REF_61 < amount
CONDITION TMP_51""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[msg.sender] -= amount

IRs:
REF_62(uint256) -> balanceOf[msg.sender]
REF_62(-> balanceOf) = REF_62 - amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= amount

IRs:
totalSupply(uint256) = totalSupply - amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(msg.sender,amount)

IRs:
Emit Burn(msg.sender,amount)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
8->1;
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"onlyOwner();balanceOf[msg.sender] < amount;;;balanceOf[msg.sender] -= amount;totalSupply -= amount;Burn(msg.sender,amount);true;success"
./0x5bc6a25063a8641ba95546ddbac3180791fc3ba0_ext.sol,TokenTeks.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xcdb290f8a2315bb0c752eb16cab426eae7afb5c2_ext.sol,VOCC_I074_20181211.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x2a0937dedadf8fe3f16a779c56524739ef77f149_ext.sol,TEL_AVIV_Portfolio_I_883.transferFrom,42,54,"REF_6(uint256) -> balanceOf[from],TMP_6(bool) = value <= REF_6,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_7(mapping(address => uint256)) -> allowance[from],REF_8(uint256) -> REF_7[msg.sender],TMP_8(bool) = value <= REF_8,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_9(uint256) -> balanceOf[from],REF_9(-> balanceOf) = REF_9 - value,REF_10(uint256) -> balanceOf[to],REF_10(-> balanceOf) = REF_10 + value,REF_11(mapping(address => uint256)) -> allowance[from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowance) = REF_12 - value,Emit Transfer(from,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(value <= balanceOf[from])

IRs:
REF_6(uint256) -> balanceOf[from]
TMP_6(bool) = value <= REF_6
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value <= allowance[from][msg.sender])

IRs:
REF_7(mapping(address => uint256)) -> allowance[from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_8(bool) = value <= REF_8
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[from] -= value

IRs:
REF_9(uint256) -> balanceOf[from]
REF_9(-> balanceOf) = REF_9 - value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[to] += value

IRs:
REF_10(uint256) -> balanceOf[to]
REF_10(-> balanceOf) = REF_10 + value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allowance[from][msg.sender] -= value

IRs:
REF_11(mapping(address => uint256)) -> allowance[from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowance) = REF_12 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(value <= balanceOf[from]);require(bool)(value <= allowance[from][msg.sender]);balanceOf[from] -= value;balanceOf[to] += value;allowance[from][msg.sender] -= value;Transfer(from,to,value);true;success"
./0x0eb152d2bba8af722d7e296a1f223d819c3bbb1f_ext.sol,CarbonExchangeCoinToken.mintToken,220,225,"REF_58(uint256) -> balanceOf[target],REF_58(-> balanceOf) = REF_58 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_58(uint256) -> balanceOf[target]
REF_58(-> balanceOf) = REF_58 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x18911e747108241e4afe4feeecc742e90c5177bd_ext.sol,VistaToken.approveAndCall,202,207,"REF_24(mapping(address => uint256)) -> allowed[msg.sender],REF_25(uint256) -> REF_24[spender],REF_25(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_43 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_43(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_24(mapping(address => uint256)) -> allowed[msg.sender]
REF_25(uint256) -> REF_24[spender]
REF_25(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_43 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_43(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x32f1ee166437b15b7716f51f2cbb53a57475bc76_ext.sol,BLITZ_GAME.NewQuestion,34,39,"TMP_12(bool) = msg.sender == questionSender,CONDITION TMP_12,question(string) := _question(string),responseHash(bytes32) := _responseHash(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == questionSender

IRs:
TMP_12(bool) = msg.sender == questionSender
CONDITION TMP_12""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
responseHash = _responseHash

IRs:
responseHash(bytes32) := _responseHash(bytes32)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,msg.sender == questionSender;question = _question;;responseHash = _responseHash
./0x50fd51b624ca86be3dbc640515ebc407a163cd6c_ext.sol,Versionable.getVersionByte,6,8,"TMP_0 = CONVERT versionCode to bytes,REF_0(None) -> TMP_0[index],RETURN REF_0","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
bytes(versionCode)[index]

IRs:
TMP_0 = CONVERT versionCode to bytes
REF_0(None) -> TMP_0[index]
RETURN REF_0""];
}
",0,1,0,0,bytes(versionCode)[index]
./0x6f08e38a24b18cf5edbd0e38bc88db5247b7eff8_ext.sol,TokenERC20.burnFrom,161,169,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x504d917d0e941550e9f89df195b969e7430118ee_ext.sol,SRDToken.burn,128,134,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x42095468d0af5976caa589ad6db91a1b8913be4e_ext.sol,RichToken._transfer,292,307,"REF_33(uint256) -> ownershipTokenCount[_to],TMP_70(uint256) := REF_33(uint256),REF_33(-> ownershipTokenCount) = REF_33 + 1,REF_34(address) -> richtokenIndexToOwner[_tokenId],REF_34(address) (->richtokenIndexToOwner) := _to(address),TMP_71 = CONVERT 0 to address,TMP_72(bool) = _from != TMP_71,CONDITION TMP_72,REF_35(uint256) -> ownershipTokenCount[_from],TMP_73(uint256) := REF_35(uint256),REF_35(-> ownershipTokenCount) = REF_35 - 1,REF_36(address) -> richtokenIndexToApproved[_tokenId],richtokenIndexToApproved = delete REF_36 ,Emit Transfer(_from,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownershipTokenCount[_to] ++

IRs:
REF_33(uint256) -> ownershipTokenCount[_to]
TMP_70(uint256) := REF_33(uint256)
REF_33(-> ownershipTokenCount) = REF_33 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
richtokenIndexToOwner[_tokenId] = _to

IRs:
REF_34(address) -> richtokenIndexToOwner[_tokenId]
REF_34(address) (->richtokenIndexToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_71 = CONVERT 0 to address
TMP_72(bool) = _from != TMP_71
CONDITION TMP_72""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownershipTokenCount[_from] --

IRs:
REF_35(uint256) -> ownershipTokenCount[_from]
TMP_73(uint256) := REF_35(uint256)
REF_35(-> ownershipTokenCount) = REF_35 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete richtokenIndexToApproved[_tokenId]

IRs:
REF_36(address) -> richtokenIndexToApproved[_tokenId]
richtokenIndexToApproved = delete REF_36 ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
}
",0,1,0,0,"ownershipTokenCount[_to] ++;richtokenIndexToOwner[_tokenId] = _to;_from != address(0);ownershipTokenCount[_from] --;;delete richtokenIndexToApproved[_tokenId];Transfer(_from,_to,_tokenId)"
./0x036d80f9abe266b7c6ec0a9bd078fac3a90d4239_ext.sol,TruffleCoin.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x4c0fbe1bb46612915e7967d2c3213cd4d87257ad_ext.sol,WhiteList.addWhiteBackersByList,620,624,"backerIndex(uint256) := 0(uint256),REF_132 -> LENGTH _backers,TMP_175(bool) = backerIndex < REF_132,CONDITION TMP_175,REF_133(address) -> _backers[backerIndex],INTERNAL_CALL, WhiteList.setWhiteBacker(address,bool)(REF_133,True),TMP_177(uint256) := backerIndex(uint256),backerIndex(uint256) = backerIndex + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
backerIndex = 0

IRs:
backerIndex(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
backerIndex < _backers.length

IRs:
REF_132 -> LENGTH _backers
TMP_175(bool) = backerIndex < REF_132
CONDITION TMP_175""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
setWhiteBacker(_backers[backerIndex],true)

IRs:
REF_133(address) -> _backers[backerIndex]
INTERNAL_CALL, WhiteList.setWhiteBacker(address,bool)(REF_133,True)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
backerIndex ++

IRs:
TMP_177(uint256) := backerIndex(uint256)
backerIndex(uint256) = backerIndex + 1""];
6->4;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->3;
}
",0,1,0,0,"onlyOwner();;backerIndex < _backers.length;;backerIndex = 0;setWhiteBacker(_backers[backerIndex],true);backerIndex ++"
./0x207b893467904d076add0a44f94ac8c8d92d2e0c_ext.sol,CARAT.totalSupply,123,125,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0xdafe38c5f5e40f7b11f28344154e78e57537bd66_ext.sol,CREXToken.transferFrom,88,99,"TMP_19 = CONVERT 0 to address,TMP_20(bool) = _to != TMP_19,TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20),REF_6(uint256) -> balances[_from],TMP_22(bool) = _value <= REF_6,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_7(mapping(address => uint256)) -> allowed[_from],REF_8(uint256) -> REF_7[msg.sender],TMP_24(bool) = _value <= REF_8,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_9(uint256) -> balances[_from],REF_10(uint256) -> balances[_from],TMP_26(uint256) = REF_10 - _value,REF_9(uint256) (->balances) := TMP_26(uint256),REF_11(uint256) -> balances[_to],REF_12(uint256) -> balances[_to],TMP_27(uint256) = REF_12 + _value,REF_11(uint256) (->balances) := TMP_27(uint256),REF_13(mapping(address => uint256)) -> allowed[_from],REF_14(uint256) -> REF_13[msg.sender],REF_15(mapping(address => uint256)) -> allowed[_from],REF_16(uint256) -> REF_15[msg.sender],TMP_28(uint256) = REF_16 - _value,REF_14(uint256) (->allowed) := TMP_28(uint256),Emit Transfer(_from,_to,_value),RETURN True,MODIFIER_CALL, CREXToken.whenTransferAllowed()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_19 = CONVERT 0 to address
TMP_20(bool) = _to != TMP_19
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_6(uint256) -> balances[_from]
TMP_22(bool) = _value <= REF_6
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_7(mapping(address => uint256)) -> allowed[_from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_24(bool) = _value <= REF_8
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] = balances[_from] - _value

IRs:
REF_9(uint256) -> balances[_from]
REF_10(uint256) -> balances[_from]
TMP_26(uint256) = REF_10 - _value
REF_9(uint256) (->balances) := TMP_26(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to] + _value

IRs:
REF_11(uint256) -> balances[_to]
REF_12(uint256) -> balances[_to]
TMP_27(uint256) = REF_12 + _value
REF_11(uint256) (->balances) := TMP_27(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value

IRs:
REF_13(mapping(address => uint256)) -> allowed[_from]
REF_14(uint256) -> REF_13[msg.sender]
REF_15(mapping(address => uint256)) -> allowed[_from]
REF_16(uint256) -> REF_15[msg.sender]
TMP_28(uint256) = REF_16 - _value
REF_14(uint256) (->allowed) := TMP_28(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
whenTransferAllowed()

IRs:
MODIFIER_CALL, CREXToken.whenTransferAllowed()()""];
9->1;
}
",0,1,0,0,"whenTransferAllowed();require(bool)(_to != address(0));require(bool)(_value <= balances[_from]);require(bool)(_value <= allowed[_from][msg.sender]);balances[_from] = balances[_from] - _value;balances[_to] = balances[_to] + _value;allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;Transfer(_from,_to,_value);true"
./0x518e5a711cf84666b98dddb00a0d4a0a6c59955e_ext.sol,PoolOwners.distributeTokens,369,387,"TMP_116 = UnaryType.BANG distributionActive ,TMP_117(None) = SOLIDITY_CALL require(bool,string)(TMP_116,Distribution is already active),distributionActive(bool) := True(bool),TMP_118 = CONVERT _token to ERC677,erc677(ERC677) := TMP_118(ERC677),TMP_119(uint256) = HIGH_LEVEL_CALL, dest:erc677(ERC677), function:balanceOf, arguments:['this']  ,REF_98(uint256) -> tokenBalance[_token],TMP_120(uint256) = TMP_119 - REF_98,currentBalance(uint256) := TMP_120(uint256),TMP_121(bool) = currentBalance > distributionMinimum,TMP_122(None) = SOLIDITY_CALL require(bool,string)(TMP_121,Amount in the contract isn't above the minimum distribution limit),TMP_123(uint256) := totalDistributions(uint256),totalDistributions(uint256) = totalDistributions + 1,REF_99(PoolOwners.Distribution) -> distributions[totalDistributions],d(PoolOwners.Distribution) := REF_99(PoolOwners.Distribution),REF_100(uint256) -> d.owners,TMP_124(uint256) = LIBRARY_CALL, dest:itmap, function:itmap.size(itmap.itmap), arguments:['ownerMap'] ,REF_100(uint256) (->d) := TMP_124(uint256),REF_102(uint256) -> d.amount,REF_102(uint256) (->d) := currentBalance(uint256),REF_103(address) -> d.token,REF_103(address) (->d) := _token(address),REF_104(uint256) -> d.claimed,REF_104(uint256) (->d) := 0(uint256),REF_105(uint256) -> totalReturned[_token],REF_105(-> totalReturned) = REF_105 + currentBalance,REF_106(uint256) -> d.owners,Emit TokenDistributionActive(_token,currentBalance,totalDistributions,REF_106),MODIFIER_CALL, PoolOwners.onlyWhitelisted()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(! distributionActive,Distribution is already active)

IRs:
TMP_116 = UnaryType.BANG distributionActive 
TMP_117(None) = SOLIDITY_CALL require(bool,string)(TMP_116,Distribution is already active)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
distributionActive = true

IRs:
distributionActive(bool) := True(bool)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
erc677 = ERC677(_token)

IRs:
TMP_118 = CONVERT _token to ERC677
erc677(ERC677) := TMP_118(ERC677)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
currentBalance = erc677.balanceOf(this) - tokenBalance[_token]

IRs:
TMP_119(uint256) = HIGH_LEVEL_CALL, dest:erc677(ERC677), function:balanceOf, arguments:['this']  
REF_98(uint256) -> tokenBalance[_token]
TMP_120(uint256) = TMP_119 - REF_98
currentBalance(uint256) := TMP_120(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool,string)(currentBalance > distributionMinimum,Amount in the contract isn't above the minimum distribution limit)

IRs:
TMP_121(bool) = currentBalance > distributionMinimum
TMP_122(None) = SOLIDITY_CALL require(bool,string)(TMP_121,Amount in the contract isn't above the minimum distribution limit)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
totalDistributions ++

IRs:
TMP_123(uint256) := totalDistributions(uint256)
totalDistributions(uint256) = totalDistributions + 1""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
d = distributions[totalDistributions]

IRs:
REF_99(PoolOwners.Distribution) -> distributions[totalDistributions]
d(PoolOwners.Distribution) := REF_99(PoolOwners.Distribution)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
d.owners = ownerMap.size()

IRs:
REF_100(uint256) -> d.owners
TMP_124(uint256) = LIBRARY_CALL, dest:itmap, function:itmap.size(itmap.itmap), arguments:['ownerMap'] 
REF_100(uint256) (->d) := TMP_124(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
d.amount = currentBalance

IRs:
REF_102(uint256) -> d.amount
REF_102(uint256) (->d) := currentBalance(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
d.token = _token

IRs:
REF_103(address) -> d.token
REF_103(address) (->d) := _token(address)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
d.claimed = 0

IRs:
REF_104(uint256) -> d.claimed
REF_104(uint256) (->d) := 0(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
totalReturned[_token] += currentBalance

IRs:
REF_105(uint256) -> totalReturned[_token]
REF_105(-> totalReturned) = REF_105 + currentBalance""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
TokenDistributionActive(_token,currentBalance,totalDistributions,d.owners)

IRs:
REF_106(uint256) -> d.owners
Emit TokenDistributionActive(_token,currentBalance,totalDistributions,REF_106)""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
onlyWhitelisted()

IRs:
MODIFIER_CALL, PoolOwners.onlyWhitelisted()()""];
14->1;
}
",0,1,0,0,"onlyWhitelisted();require(bool,string)(! distributionActive,Distribution is already active);distributionActive = true;erc677 = ERC677(_token);currentBalance = erc677.balanceOf(this) - tokenBalance[_token];require(bool,string)(currentBalance > distributionMinimum,Amount in the contract isn't above the minimum distribution limit);totalDistributions ++;d = distributions[totalDistributions];d.owners = ownerMap.size();d.amount = currentBalance;d.token = _token;d.claimed = 0;totalReturned[_token] += currentBalance;TokenDistributionActive(_token,currentBalance,totalDistributions,d.owners)"
./0xa5bd843ea5fbf56e1579f7d99fb68efe4e07185f_ext.sol,TokenERC20.burn,97,103,"REF_33(uint256) -> balanceOf[msg.sender],TMP_29(bool) = REF_33 >= _value,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),REF_34(uint256) -> balanceOf[msg.sender],REF_34(-> balanceOf) = REF_34 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_33(uint256) -> balanceOf[msg.sender]
TMP_29(bool) = REF_33 >= _value
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_34(uint256) -> balanceOf[msg.sender]
REF_34(-> balanceOf) = REF_34 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x18bbc8d1ec4ee0414e24eceed8b6a0e1b509b5c4_ext.sol,MetToken.list_history_of_token_transfer,904,923,"REF_162 -> LENGTH history_token_transfer,len(uint256) := REF_162(uint256),n(uint256) := len(uint256),TMP_296(bool) = _max_num_of_items_to_display == 0,CONDITION TMP_296,_max_num_of_items_to_display(uint256) := 1(uint256),TMP_297(bool) = _max_num_of_items_to_display < n,CONDITION TMP_297,n(uint256) := _max_num_of_items_to_display(uint256),TMP_299(address[])  = new address[](n),_senders(address[]) = ['TMP_299(address[])'],TMP_301(address[])  = new address[](n),_receivers(address[]) = ['TMP_301(address[])'],TMP_303(uint256[])  = new uint256[](n),_tokens(uint256[]) = ['TMP_303(uint256[])'],TMP_305(uint256[])  = new uint256[](n),_whens(uint256[]) = ['TMP_305(uint256[])'],_num(uint256) := 0(uint256),TMP_306(uint256) = len - 1,j(uint256) := TMP_306(uint256),TMP_307(bool) = j >= 0,TMP_308(bool) = n > _num,TMP_309(bool) = TMP_307 && TMP_308,CONDITION TMP_309,REF_163(MetToken.history_token_transfer_obj) -> history_token_transfer[j],obj(MetToken.history_token_transfer_obj) := REF_163(MetToken.history_token_transfer_obj),REF_164(address) -> _senders[_num],REF_165(address) -> obj._from,REF_164(address) (->_senders) := REF_165(address),REF_166(address) -> _receivers[_num],REF_167(address) -> obj._to,REF_166(address) (->_receivers) := REF_167(address),REF_168(uint256) -> _tokens[_num],REF_169(uint256) -> obj._token_value,REF_168(uint256) (->_tokens) := REF_169(uint256),REF_170(uint256) -> _whens[_num],REF_171(uint256) -> obj._when,REF_170(uint256) (->_whens) := REF_171(uint256),TMP_310(uint256) := _num(uint256),_num(uint256) = _num + 1,TMP_311(uint256) := j(uint256),j(uint256) = j - 1,RETURN _num,_senders,_receivers,_tokens,_whens","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
len = history_token_transfer.length

IRs:
REF_162 -> LENGTH history_token_transfer
len(uint256) := REF_162(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
n = len

IRs:
n(uint256) := len(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_max_num_of_items_to_display == 0

IRs:
TMP_296(bool) = _max_num_of_items_to_display == 0
CONDITION TMP_296""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
_max_num_of_items_to_display = 1

IRs:
_max_num_of_items_to_display(uint256) := 1(uint256)""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
_max_num_of_items_to_display < n

IRs:
TMP_297(bool) = _max_num_of_items_to_display < n
CONDITION TMP_297""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
n = _max_num_of_items_to_display

IRs:
n(uint256) := _max_num_of_items_to_display(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
_senders = new address[](n)

IRs:
TMP_299(address[])  = new address[](n)
_senders(address[]) = ['TMP_299(address[])']""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
_receivers = new address[](n)

IRs:
TMP_301(address[])  = new address[](n)
_receivers(address[]) = ['TMP_301(address[])']""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
_tokens = new uint256[](n)

IRs:
TMP_303(uint256[])  = new uint256[](n)
_tokens(uint256[]) = ['TMP_303(uint256[])']""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
_whens = new uint256[](n)

IRs:
TMP_305(uint256[])  = new uint256[](n)
_whens(uint256[]) = ['TMP_305(uint256[])']""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
_num = 0

IRs:
_num(uint256) := 0(uint256)""];
13->16;
14[label=""Node Type: BEGIN_LOOP 14
""];
14->17;
15[label=""Node Type: END_LOOP 15
""];
15->25;
16[label=""Node Type: NEW VARIABLE 16

EXPRESSION:
j = len - 1

IRs:
TMP_306(uint256) = len - 1
j(uint256) := TMP_306(uint256)""];
16->14;
17[label=""Node Type: IF_LOOP 17

EXPRESSION:
j >= 0 && n > _num

IRs:
TMP_307(bool) = j >= 0
TMP_308(bool) = n > _num
TMP_309(bool) = TMP_307 && TMP_308
CONDITION TMP_309""];
17->18[label=""True""];
17->15[label=""False""];
18[label=""Node Type: NEW VARIABLE 18

EXPRESSION:
obj = history_token_transfer[j]

IRs:
REF_163(MetToken.history_token_transfer_obj) -> history_token_transfer[j]
obj(MetToken.history_token_transfer_obj) := REF_163(MetToken.history_token_transfer_obj)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
_senders[_num] = obj._from

IRs:
REF_164(address) -> _senders[_num]
REF_165(address) -> obj._from
REF_164(address) (->_senders) := REF_165(address)""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
_receivers[_num] = obj._to

IRs:
REF_166(address) -> _receivers[_num]
REF_167(address) -> obj._to
REF_166(address) (->_receivers) := REF_167(address)""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
_tokens[_num] = obj._token_value

IRs:
REF_168(uint256) -> _tokens[_num]
REF_169(uint256) -> obj._token_value
REF_168(uint256) (->_tokens) := REF_169(uint256)""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
_whens[_num] = obj._when

IRs:
REF_170(uint256) -> _whens[_num]
REF_171(uint256) -> obj._when
REF_170(uint256) (->_whens) := REF_171(uint256)""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
_num ++

IRs:
TMP_310(uint256) := _num(uint256)
_num(uint256) = _num + 1""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
j --

IRs:
TMP_311(uint256) := j(uint256)
j(uint256) = j - 1""];
24->17;
25[label=""Node Type: RETURN 25

EXPRESSION:
(_num,_senders,_receivers,_tokens,_whens)

IRs:
RETURN _num,_senders,_receivers,_tokens,_whens""];
}
",0,1,0,0,"len = history_token_transfer.length;n = len;_max_num_of_items_to_display == 0;_max_num_of_items_to_display = 1;;_max_num_of_items_to_display < n;n = _max_num_of_items_to_display;;_senders = new address[](n);_receivers = new address[](n);_tokens = new uint256[](n);_whens = new uint256[](n);_num = 0;j = len - 1;;j >= 0 && n > _num;;(_num,_senders,_receivers,_tokens,_whens);obj = history_token_transfer[j];_senders[_num] = obj._from;_receivers[_num] = obj._to;_tokens[_num] = obj._token_value;_whens[_num] = obj._when;_num ++;j --"
./0x35e44051799bd7cea091c4fad2cba9b37e364c5b_ext.sol,myPreICO.fallback,47,52,"TMP_14(bool) = msg.value > 0,TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14),REF_5 -> LENGTH holders,TMP_17(uint256) := REF_5(uint256),TMP_18(uint256) = TMP_17 + 1,REF_5(uint256) (->holders) := TMP_18(uint256),REF_6(address) -> holders[TMP_17],REF_6(address) (->holders) := msg.sender(address),REF_7(uint256) -> holder_balance[msg.sender],REF_7(-> holder_balance) = REF_7 + msg.value,ETHRaised(uint256) = ETHRaised + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value > 0)

IRs:
TMP_14(bool) = msg.value > 0
TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
holders.push(msg.sender)

IRs:
REF_5 -> LENGTH holders
TMP_17(uint256) := REF_5(uint256)
TMP_18(uint256) = TMP_17 + 1
REF_5(uint256) (->holders) := TMP_18(uint256)
REF_6(address) -> holders[TMP_17]
REF_6(address) (->holders) := msg.sender(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
holder_balance[msg.sender] += msg.value

IRs:
REF_7(uint256) -> holder_balance[msg.sender]
REF_7(-> holder_balance) = REF_7 + msg.value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ETHRaised += msg.value

IRs:
ETHRaised(uint256) = ETHRaised + msg.value""];
}
",0,1,0,0,require(bool)(msg.value > 0);holders.push(msg.sender);holder_balance[msg.sender] += msg.value;ETHRaised += msg.value
./0xaacfbd1f81351a7e748f4a4a43c31d892a33f27d_ext.sol,Gallery_MuYi_No2.approveAndCall,124,133,"REF_31(mapping(address => uint256)) -> allowed[msg.sender],REF_32(uint256) -> REF_31[_spender],REF_32(uint256) (->allowed) := _value(uint256),Emit Approval(msg.sender,_spender,_value),TMP_23(bytes32) = SOLIDITY_CALL sha3()(receiveApproval(address,uint256,address,bytes)),TMP_24 = CONVERT TMP_23 to bytes32,TMP_25 = CONVERT TMP_24 to bytes4,TMP_26(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_25', 'msg.sender', '_value', 'this', '_extraData']  ,TMP_27 = UnaryType.BANG TMP_26 ,CONDITION TMP_27,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_31(mapping(address => uint256)) -> allowed[msg.sender]
REF_32(uint256) -> REF_31[_spender]
REF_32(uint256) (->allowed) := _value(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
! _spender.call(bytes4(bytes32(sha3()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData)

IRs:
TMP_23(bytes32) = SOLIDITY_CALL sha3()(receiveApproval(address,uint256,address,bytes))
TMP_24 = CONVERT TMP_23 to bytes32
TMP_25 = CONVERT TMP_24 to bytes4
TMP_26(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_25', 'msg.sender', '_value', 'this', '_extraData']  
TMP_27 = UnaryType.BANG TMP_26 
CONDITION TMP_27""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: THROW 4
""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][_spender] = _value;Approval(msg.sender,_spender,_value);! _spender.call(bytes4(bytes32(sha3()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData);;;true;success"
./0x41d9384dc97470bd2afa06db0c1be4f872519eec_ext.sol,FollowCoin._transfer,154,167,"TMP_24(bool) = _to != 0,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),TMP_26(uint256) = INTERNAL_CALL, FollowCoin.balanceOf(address)(_from),TMP_27(bool) = TMP_26 >= _value,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),TMP_29(uint256) = INTERNAL_CALL, FollowCoin.balanceOf(address)(_to),TMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_29', '_value'] ,TMP_31(uint256) = INTERNAL_CALL, FollowCoin.balanceOf(address)(_to),TMP_32(bool) = TMP_30 > TMP_31,TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32),REF_6(uint256) -> balances[_from],TMP_34(uint256) = INTERNAL_CALL, FollowCoin.balanceOf(address)(_from),TMP_35(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_34', '_value'] ,REF_6(uint256) (->balances) := TMP_35(uint256),REF_8(uint256) -> balances[_to],TMP_36(uint256) = INTERNAL_CALL, FollowCoin.balanceOf(address)(_to),TMP_37(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_36', '_value'] ,REF_8(uint256) (->balances) := TMP_37(uint256),REF_10(bool) -> isHolder[_to],TMP_38(bool) = REF_10 != True,CONDITION TMP_38,REF_11 -> LENGTH holders,TMP_39(uint256) := REF_11(uint256),REF_11(-> holders) = REF_11 + 1,REF_12(address) -> holders[TMP_39],REF_12(address) (->holders) := _to(address),REF_13(bool) -> isHolder[_to],REF_13(bool) (->isHolder) := True(bool),Emit Transfer(_from,_to,_value),MODIFIER_CALL, FollowCoin.coinsLocked()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_24(bool) = _to != 0
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf(_from) >= _value)

IRs:
TMP_26(uint256) = INTERNAL_CALL, FollowCoin.balanceOf(address)(_from)
TMP_27(bool) = TMP_26 >= _value
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf(_to).add(_value) > balanceOf(_to))

IRs:
TMP_29(uint256) = INTERNAL_CALL, FollowCoin.balanceOf(address)(_to)
TMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_29', '_value'] 
TMP_31(uint256) = INTERNAL_CALL, FollowCoin.balanceOf(address)(_to)
TMP_32(bool) = TMP_30 > TMP_31
TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] = balanceOf(_from).sub(_value)

IRs:
REF_6(uint256) -> balances[_from]
TMP_34(uint256) = INTERNAL_CALL, FollowCoin.balanceOf(address)(_from)
TMP_35(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_34', '_value'] 
REF_6(uint256) (->balances) := TMP_35(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balanceOf(_to).add(_value)

IRs:
REF_8(uint256) -> balances[_to]
TMP_36(uint256) = INTERNAL_CALL, FollowCoin.balanceOf(address)(_to)
TMP_37(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['TMP_36', '_value'] 
REF_8(uint256) (->balances) := TMP_37(uint256)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
isHolder[_to] != true

IRs:
REF_10(bool) -> isHolder[_to]
TMP_38(bool) = REF_10 != True
CONDITION TMP_38""];
6->7[label=""True""];
6->9[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
holders[holders.length ++] = _to

IRs:
REF_11 -> LENGTH holders
TMP_39(uint256) := REF_11(uint256)
REF_11(-> holders) = REF_11 + 1
REF_12(address) -> holders[TMP_39]
REF_12(address) (->holders) := _to(address)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
isHolder[_to] = true

IRs:
REF_13(bool) -> isHolder[_to]
REF_13(bool) (->isHolder) := True(bool)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
coinsLocked()

IRs:
MODIFIER_CALL, FollowCoin.coinsLocked()()""];
11->1;
}
",0,1,0,0,"coinsLocked();require(bool)(_to != 0x0);require(bool)(balanceOf(_from) >= _value);require(bool)(balanceOf(_to).add(_value) > balanceOf(_to));balances[_from] = balanceOf(_from).sub(_value);balances[_to] = balanceOf(_to).add(_value);isHolder[_to] != true;holders[holders.length ++] = _to;;isHolder[_to] = true;Transfer(_from,_to,_value)"
./0x48c8efdbf925a8028abf1d4bacb7baa59ff2948b_ext.sol,FTWCoin.fallback,117,131,"TMP_22(uint256) = totalEthInWei + msg.value,totalEthInWei(uint256) := TMP_22(uint256),TMP_23(uint256) = msg.value * unitsOneEthCanBuy,amount(uint256) := TMP_23(uint256),REF_31(uint256) -> balances[fundsWallet],TMP_24(bool) = REF_31 < amount,CONDITION TMP_24,REF_32(uint256) -> balances[fundsWallet],REF_33(uint256) -> balances[fundsWallet],TMP_25(uint256) = REF_33 - amount,REF_32(uint256) (->balances) := TMP_25(uint256),REF_34(uint256) -> balances[msg.sender],REF_35(uint256) -> balances[msg.sender],TMP_26(uint256) = REF_35 + amount,REF_34(uint256) (->balances) := TMP_26(uint256),Emit Transfer(fundsWallet,msg.sender,amount),Transfer dest:fundsWallet value:msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
totalEthInWei = totalEthInWei + msg.value

IRs:
TMP_22(uint256) = totalEthInWei + msg.value
totalEthInWei(uint256) := TMP_22(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = msg.value * unitsOneEthCanBuy

IRs:
TMP_23(uint256) = msg.value * unitsOneEthCanBuy
amount(uint256) := TMP_23(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
balances[fundsWallet] < amount

IRs:
REF_31(uint256) -> balances[fundsWallet]
TMP_24(bool) = REF_31 < amount
CONDITION TMP_24""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: RETURN 4
""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[fundsWallet] = balances[fundsWallet] - amount

IRs:
REF_32(uint256) -> balances[fundsWallet]
REF_33(uint256) -> balances[fundsWallet]
TMP_25(uint256) = REF_33 - amount
REF_32(uint256) (->balances) := TMP_25(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[msg.sender] = balances[msg.sender] + amount

IRs:
REF_34(uint256) -> balances[msg.sender]
REF_35(uint256) -> balances[msg.sender]
TMP_26(uint256) = REF_35 + amount
REF_34(uint256) (->balances) := TMP_26(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(fundsWallet,msg.sender,amount)

IRs:
Emit Transfer(fundsWallet,msg.sender,amount)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
fundsWallet.transfer(msg.value)

IRs:
Transfer dest:fundsWallet value:msg.value""];
}
",0,1,0,0,"totalEthInWei = totalEthInWei + msg.value;amount = msg.value * unitsOneEthCanBuy;balances[fundsWallet] < amount;;;balances[fundsWallet] = balances[fundsWallet] - amount;balances[msg.sender] = balances[msg.sender] + amount;Transfer(fundsWallet,msg.sender,amount);fundsWallet.transfer(msg.value)"
./0x361f5a02be315ed1241d8c2997d1fc35aaa27596_ext.sol,DinarETHCrypto.changeNameSymbol,227,230,"name(string) := _name(string),symbol(string) := _symbol(string),MODIFIER_CALL, DinarETHCrypto.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
name = _name

IRs:
name(string) := _name(string)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
symbol = _symbol

IRs:
symbol(string) := _symbol(string)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, DinarETHCrypto.onlyOwner()()""];
3->1;
}
",0,1,0,0,onlyOwner();name = _name;symbol = _symbol
./0x00430f32b8e77a456d0ab7e6f1dc1b84f4ae62e0_ext.sol,MyToken.mintToken,166,171,"REF_21(uint256) -> balanceOf[target],REF_21(-> balanceOf) = REF_21 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,owner,mintedAmount),Emit Transfer(owner,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_21(uint256) -> balanceOf[target]
REF_21(-> balanceOf) = REF_21 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,owner,mintedAmount)

IRs:
Emit Transfer(0,owner,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(owner,target,mintedAmount)

IRs:
Emit Transfer(owner,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,owner,mintedAmount);Transfer(owner,target,mintedAmount)"
./0x0513ce8013f27a47a0088ffaac94fbb0fe6309d8_ext.sol,SmartBlockchainPro.fallback,35,56,"REF_0(uint256) -> invested[msg.sender],TMP_0(bool) = REF_0 != 0,CONDITION TMP_0,REF_1(uint256) -> invested[msg.sender],TMP_1(uint256) = REF_1 * 1,TMP_2(uint256) = TMP_1 / 100,REF_2(uint256) -> atBlock[msg.sender],TMP_3(uint256) = block.number - REF_2,TMP_4(uint256) = TMP_2 * TMP_3,TMP_5(uint256) = TMP_4 / 5900,amount(uint256) := TMP_5(uint256),sender(address) := msg.sender(address),TMP_6 = SEND dest:sender value:amount,TMP_7(bool) = msg.value != 0,CONDITION TMP_7,TMP_8(uint256) = msg.value * 15,TMP_9(uint256) = TMP_8 / 100,TMP_10 = SEND dest:marketingAddr value:TMP_9,REF_5(uint256) -> atBlock[msg.sender],REF_5(uint256) (->atBlock) := block.number(uint256),REF_6(uint256) -> invested[msg.sender],REF_6(-> invested) = REF_6 + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
invested[msg.sender] != 0

IRs:
REF_0(uint256) -> invested[msg.sender]
TMP_0(bool) = REF_0 != 0
CONDITION TMP_0""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = invested[msg.sender] * 1 / 100 * (block.number - atBlock[msg.sender]) / 5900

IRs:
REF_1(uint256) -> invested[msg.sender]
TMP_1(uint256) = REF_1 * 1
TMP_2(uint256) = TMP_1 / 100
REF_2(uint256) -> atBlock[msg.sender]
TMP_3(uint256) = block.number - REF_2
TMP_4(uint256) = TMP_2 * TMP_3
TMP_5(uint256) = TMP_4 / 5900
amount(uint256) := TMP_5(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
sender = msg.sender

IRs:
sender(address) := msg.sender(address)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
sender.send(amount)

IRs:
TMP_6 = SEND dest:sender value:amount""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
msg.value != 0

IRs:
TMP_7(bool) = msg.value != 0
CONDITION TMP_7""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
marketingAddr.send(msg.value * 15 / 100)

IRs:
TMP_8(uint256) = msg.value * 15
TMP_9(uint256) = TMP_8 / 100
TMP_10 = SEND dest:marketingAddr value:TMP_9""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
atBlock[msg.sender] = block.number

IRs:
REF_5(uint256) -> atBlock[msg.sender]
REF_5(uint256) (->atBlock) := block.number(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
invested[msg.sender] += msg.value

IRs:
REF_6(uint256) -> invested[msg.sender]
REF_6(-> invested) = REF_6 + msg.value""];
}
",0,1,0,0,invested[msg.sender] != 0;amount = invested[msg.sender] * 1 / 100 * (block.number - atBlock[msg.sender]) / 5900;;sender = msg.sender;sender.send(amount);msg.value != 0;marketingAddr.send(msg.value * 15 / 100);;atBlock[msg.sender] = block.number;invested[msg.sender] += msg.value
./0x70aedc0621a686067fdba7fb4fdb209ea185fe73_ext.sol,TokenERC20._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x26b5962250b779ab0f33970738a46fcfb00a70b9_ext.sol,NewLottery.AddTicket,90,107,"TMP_19(bool) = msg.value == ticketPrice,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),TMP_21(bool) = numtickets < maxTickets,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),lastTicketTime(uint256) := now(uint256),totalBounty(uint256) = totalBounty + ticketPrice,TMP_23(bool) = numtickets == maxTickets,success(bool) := TMP_23(bool),Emit NewTicket(msg.sender,success),CONDITION success,INTERNAL_CALL, NewLottery.PayWinner(address)(msg.sender)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value == ticketPrice)

IRs:
TMP_19(bool) = msg.value == ticketPrice
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(numtickets < maxTickets)

IRs:
TMP_21(bool) = numtickets < maxTickets
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
lastTicketTime = now

IRs:
lastTicketTime(uint256) := now(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
totalBounty += ticketPrice

IRs:
totalBounty(uint256) = totalBounty + ticketPrice""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
success = numtickets == maxTickets

IRs:
TMP_23(bool) = numtickets == maxTickets
success(bool) := TMP_23(bool)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
NewTicket(msg.sender,success)

IRs:
Emit NewTicket(msg.sender,success)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
success

IRs:
CONDITION success""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
PayWinner(msg.sender)

IRs:
INTERNAL_CALL, NewLottery.PayWinner(address)(msg.sender)""];
8->9;
9[label=""Node Type: END_IF 9
""];
}
",0,1,0,0,"require(bool)(msg.value == ticketPrice);require(bool)(numtickets < maxTickets);lastTicketTime = now;totalBounty += ticketPrice;success = numtickets == maxTickets;NewTicket(msg.sender,success);success;PayWinner(msg.sender);"
./0x421a0ee46dbfee7f65076c7e0c32fa86918bf62d_ext.sol,BBX.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x1c934a503fe39721591b97b8c56f013bf78a8d19_ext.sol,StandardToken.transferFrom,58,68,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x1b413506fc42e2f04a4e8c57710f850b234d6653_ext.sol,EpiphanyCoin.mintToken,208,213,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0xbb558c3fdb17ff0394ece6967c56c08207d0b4bc_ext.sol,DAAS.burn,126,132,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x4cf286da8dec355bb8d51a3f8ff509e2b594e6ff_ext.sol,BTYCEC.mint,619,685,"user(address) := msg.sender(address),REF_190(bool) -> frozenAccount[user],TMP_195 = UnaryType.BANG REF_190 ,TMP_196(None) = SOLIDITY_CALL require(bool)(TMP_195),TMP_197(bool) = actived == True,TMP_198(None) = SOLIDITY_CALL require(bool)(TMP_197),REF_191(uint256) -> crontime[user],TMP_199(bool) = REF_191 > 1,TMP_200(None) = SOLIDITY_CALL require(bool)(TMP_199),REF_192(uint256) -> crontime[user],TMP_201(bool) = now > REF_192,TMP_202(None) = SOLIDITY_CALL require(bool)(TMP_201),REF_193(uint256) -> myeth[user],TMP_203(bool) = REF_193 > 1,CONDITION TMP_203,REF_194(uint256) -> myeth[user],TMP_204(uint256) = REF_194 * sysPer,TMP_205(uint256) = TMP_204 / 1000,usmoney(uint256) := TMP_205(uint256),REF_195(uint256) -> froeth[user],TMP_206(bool) = REF_195 >= sysPrice1,REF_196(uint256) -> mintnum[user],TMP_207(bool) = REF_196 > 1,TMP_208(bool) = TMP_206 && TMP_207,CONDITION TMP_208,REF_197(uint256) -> froeth[user],TMP_209(uint256) = REF_197 * sysPer1,TMP_210(uint256) = TMP_209 / 1000,mintmoney(uint256) := TMP_210(uint256),REF_198(uint256) -> froeth[user],TMP_211(bool) = REF_198 >= sysPrice2,CONDITION TMP_211,REF_199(uint256) -> froeth[user],TMP_212(uint256) = REF_199 * sysPer2,TMP_213(uint256) = TMP_212 / 1000,mintmoney(uint256) := TMP_213(uint256),TMP_214(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['usmoney', 'mintmoney'] ,amount(uint256) := TMP_214(uint256),REF_201(uint256) -> balances[this],TMP_215(bool) = REF_201 > amount,TMP_216(None) = SOLIDITY_CALL require(bool)(TMP_215),TMP_217(bool) = sysoutmoney > amount,TMP_218(None) = SOLIDITY_CALL require(bool)(TMP_217),REF_202(uint256) -> balances[user],REF_203(uint256) -> balances[user],TMP_219(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_203', 'amount'] ,REF_202(uint256) (->balances) := TMP_219(uint256),REF_205(uint256) -> balances[this],REF_206(uint256) -> balances[this],TMP_220(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_206', 'amount'] ,REF_205(uint256) (->balances) := TMP_220(uint256),TMP_221(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['sysoutmoney', 'amount'] ,sysoutmoney(uint256) := TMP_221(uint256),TMP_222(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['sysusermoney', 'amount'] ,sysusermoney(uint256) := TMP_222(uint256),REF_210(uint256) -> crontime[user],TMP_223(uint256) = now + onceAddTime,REF_210(uint256) (->crontime) := TMP_223(uint256),TMP_224(bool) = usmoney > 0,CONDITION TMP_224,Emit Transfer(this,user,usmoney),TMP_226(bool) = mintmoney > 0,CONDITION TMP_226,Emit Transfer(this,user,mintmoney),REF_211(uint256) -> mintnum[user],TMP_228(uint256) := REF_211(uint256),REF_211(-> mintnum) = REF_211 - 1,REF_212(uint256) -> mintnum[user],TMP_229(bool) = REF_212 < 2,CONDITION TMP_229,REF_213(uint256) -> balances[user],REF_214(uint256) -> balances[user],REF_216(uint256) -> froeth[user],TMP_230(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_214', 'REF_216'] ,REF_213(uint256) (->balances) := TMP_230(uint256),REF_217(uint256) -> myeth[user],REF_218(uint256) -> myeth[user],REF_220(uint256) -> froeth[user],TMP_231(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_218', 'REF_220'] ,REF_217(uint256) (->myeth) := TMP_231(uint256),REF_222(uint256) -> froeth[user],TMP_232(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['sysminteth', 'REF_222'] ,sysminteth(uint256) := TMP_232(uint256),REF_223(uint256) -> froeth[user],Emit Transfer(this,user,REF_223),REF_224(uint256) -> froeth[user],REF_224(uint256) (->froeth) := 1(uint256),REF_225(address) -> fromaddr[user],top1(address) := REF_225(address),TMP_234 = CONVERT 0 to address,TMP_235(bool) = top1 != TMP_234,TMP_236(bool) = top1 != user,TMP_237(bool) = TMP_235 && TMP_236,CONDITION TMP_237,TMP_238(uint256) = amount * upper1,TMP_239(uint256) = TMP_238 / 100,upmoney1(uint256) := TMP_239(uint256),REF_226(uint256) -> balances[top1],REF_227(uint256) -> balances[top1],TMP_240(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_227', 'upmoney1'] ,REF_226(uint256) (->balances) := TMP_240(uint256),REF_229(uint256) -> balances[this],REF_230(uint256) -> balances[this],TMP_241(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_230', 'upmoney1'] ,REF_229(uint256) (->balances) := TMP_241(uint256),TMP_242(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['sysoutmoney', 'upmoney1'] ,sysoutmoney(uint256) := TMP_242(uint256),TMP_243(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['sysusermoney', 'upmoney1'] ,sysusermoney(uint256) := TMP_243(uint256),Emit Transfer(this,top1,upmoney1),TMP_245(bool) = INTERNAL_CALL, BTYCEC.setteam(address,uint256)(top1,upmoney1),REF_234(address) -> fromaddr[top1],top2(address) := REF_234(address),TMP_246 = CONVERT 0 to address,TMP_247(bool) = top2 != TMP_246,TMP_248(bool) = top2 != user,TMP_249(bool) = TMP_247 && TMP_248,CONDITION TMP_249,TMP_250(uint256) = amount * upper2,TMP_251(uint256) = TMP_250 / 100,upmoney2(uint256) := TMP_251(uint256),REF_235(uint256) -> balances[top2],REF_236(uint256) -> balances[top2],TMP_252(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_236', 'upmoney2'] ,REF_235(uint256) (->balances) := TMP_252(uint256),REF_238(uint256) -> balances[this],REF_239(uint256) -> balances[this],TMP_253(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_239', 'upmoney2'] ,REF_238(uint256) (->balances) := TMP_253(uint256),TMP_254(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['sysoutmoney', 'upmoney2'] ,sysoutmoney(uint256) := TMP_254(uint256),TMP_255(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['sysusermoney', 'upmoney2'] ,sysusermoney(uint256) := TMP_255(uint256),Emit Transfer(this,top2,upmoney2),TMP_257(bool) = INTERNAL_CALL, BTYCEC.setteam(address,uint256)(top2,upmoney2)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
user = msg.sender

IRs:
user(address) := msg.sender(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! frozenAccount[user])

IRs:
REF_190(bool) -> frozenAccount[user]
TMP_195 = UnaryType.BANG REF_190 
TMP_196(None) = SOLIDITY_CALL require(bool)(TMP_195)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(actived == true)

IRs:
TMP_197(bool) = actived == True
TMP_198(None) = SOLIDITY_CALL require(bool)(TMP_197)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(crontime[user] > 1)

IRs:
REF_191(uint256) -> crontime[user]
TMP_199(bool) = REF_191 > 1
TMP_200(None) = SOLIDITY_CALL require(bool)(TMP_199)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(now > crontime[user])

IRs:
REF_192(uint256) -> crontime[user]
TMP_201(bool) = now > REF_192
TMP_202(None) = SOLIDITY_CALL require(bool)(TMP_201)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6
""];
6->7;
7[label=""Node Type: NEW VARIABLE 7
""];
7->8;
8[label=""Node Type: NEW VARIABLE 8
""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
myeth[user] > 1

IRs:
REF_193(uint256) -> myeth[user]
TMP_203(bool) = REF_193 > 1
CONDITION TMP_203""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
usmoney = myeth[user] * sysPer / 1000

IRs:
REF_194(uint256) -> myeth[user]
TMP_204(uint256) = REF_194 * sysPer
TMP_205(uint256) = TMP_204 / 1000
usmoney(uint256) := TMP_205(uint256)""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
froeth[user] >= sysPrice1 && mintnum[user] > 1

IRs:
REF_195(uint256) -> froeth[user]
TMP_206(bool) = REF_195 >= sysPrice1
REF_196(uint256) -> mintnum[user]
TMP_207(bool) = REF_196 > 1
TMP_208(bool) = TMP_206 && TMP_207
CONDITION TMP_208""];
12->13[label=""True""];
12->17[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
mintmoney = froeth[user] * sysPer1 / 1000

IRs:
REF_197(uint256) -> froeth[user]
TMP_209(uint256) = REF_197 * sysPer1
TMP_210(uint256) = TMP_209 / 1000
mintmoney(uint256) := TMP_210(uint256)""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
froeth[user] >= sysPrice2

IRs:
REF_198(uint256) -> froeth[user]
TMP_211(bool) = REF_198 >= sysPrice2
CONDITION TMP_211""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
mintmoney = froeth[user] * sysPer2 / 1000

IRs:
REF_199(uint256) -> froeth[user]
TMP_212(uint256) = REF_199 * sysPer2
TMP_213(uint256) = TMP_212 / 1000
mintmoney(uint256) := TMP_213(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
amount = usmoney.add(mintmoney)

IRs:
TMP_214(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['usmoney', 'mintmoney'] 
amount(uint256) := TMP_214(uint256)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
require(bool)(balances[this] > amount)

IRs:
REF_201(uint256) -> balances[this]
TMP_215(bool) = REF_201 > amount
TMP_216(None) = SOLIDITY_CALL require(bool)(TMP_215)""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
require(bool)(sysoutmoney > amount)

IRs:
TMP_217(bool) = sysoutmoney > amount
TMP_218(None) = SOLIDITY_CALL require(bool)(TMP_217)""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
balances[user] = balances[user].add(amount)

IRs:
REF_202(uint256) -> balances[user]
REF_203(uint256) -> balances[user]
TMP_219(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_203', 'amount'] 
REF_202(uint256) (->balances) := TMP_219(uint256)""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
balances[this] = balances[this].sub(amount)

IRs:
REF_205(uint256) -> balances[this]
REF_206(uint256) -> balances[this]
TMP_220(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_206', 'amount'] 
REF_205(uint256) (->balances) := TMP_220(uint256)""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
sysoutmoney = sysoutmoney.sub(amount)

IRs:
TMP_221(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['sysoutmoney', 'amount'] 
sysoutmoney(uint256) := TMP_221(uint256)""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
sysusermoney = sysusermoney.add(amount)

IRs:
TMP_222(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['sysusermoney', 'amount'] 
sysusermoney(uint256) := TMP_222(uint256)""];
24->25;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
crontime[user] = now + onceAddTime

IRs:
REF_210(uint256) -> crontime[user]
TMP_223(uint256) = now + onceAddTime
REF_210(uint256) (->crontime) := TMP_223(uint256)""];
25->26;
26[label=""Node Type: IF 26

EXPRESSION:
usmoney > 0

IRs:
TMP_224(bool) = usmoney > 0
CONDITION TMP_224""];
26->27[label=""True""];
26->28[label=""False""];
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
Transfer(this,user,usmoney)

IRs:
Emit Transfer(this,user,usmoney)""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: IF 29

EXPRESSION:
mintmoney > 0

IRs:
TMP_226(bool) = mintmoney > 0
CONDITION TMP_226""];
29->30[label=""True""];
29->39[label=""False""];
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
Transfer(this,user,mintmoney)

IRs:
Emit Transfer(this,user,mintmoney)""];
30->31;
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
mintnum[user] --

IRs:
REF_211(uint256) -> mintnum[user]
TMP_228(uint256) := REF_211(uint256)
REF_211(-> mintnum) = REF_211 - 1""];
31->32;
32[label=""Node Type: IF 32

EXPRESSION:
mintnum[user] < 2

IRs:
REF_212(uint256) -> mintnum[user]
TMP_229(bool) = REF_212 < 2
CONDITION TMP_229""];
32->33[label=""True""];
32->38[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
balances[user] = balances[user].add(froeth[user])

IRs:
REF_213(uint256) -> balances[user]
REF_214(uint256) -> balances[user]
REF_216(uint256) -> froeth[user]
TMP_230(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_214', 'REF_216'] 
REF_213(uint256) (->balances) := TMP_230(uint256)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
myeth[user] = myeth[user].add(froeth[user])

IRs:
REF_217(uint256) -> myeth[user]
REF_218(uint256) -> myeth[user]
REF_220(uint256) -> froeth[user]
TMP_231(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_218', 'REF_220'] 
REF_217(uint256) (->myeth) := TMP_231(uint256)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
sysminteth = sysminteth.sub(froeth[user])

IRs:
REF_222(uint256) -> froeth[user]
TMP_232(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['sysminteth', 'REF_222'] 
sysminteth(uint256) := TMP_232(uint256)""];
35->36;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
Transfer(this,user,froeth[user])

IRs:
REF_223(uint256) -> froeth[user]
Emit Transfer(this,user,REF_223)""];
36->37;
37[label=""Node Type: EXPRESSION 37

EXPRESSION:
froeth[user] = 1

IRs:
REF_224(uint256) -> froeth[user]
REF_224(uint256) (->froeth) := 1(uint256)""];
37->38;
38[label=""Node Type: END_IF 38
""];
38->39;
39[label=""Node Type: END_IF 39
""];
39->40;
40[label=""Node Type: NEW VARIABLE 40

EXPRESSION:
top1 = fromaddr[user]

IRs:
REF_225(address) -> fromaddr[user]
top1(address) := REF_225(address)""];
40->41;
41[label=""Node Type: IF 41

EXPRESSION:
top1 != address(0) && top1 != user

IRs:
TMP_234 = CONVERT 0 to address
TMP_235(bool) = top1 != TMP_234
TMP_236(bool) = top1 != user
TMP_237(bool) = TMP_235 && TMP_236
CONDITION TMP_237""];
41->42[label=""True""];
41->59[label=""False""];
42[label=""Node Type: NEW VARIABLE 42

EXPRESSION:
upmoney1 = amount * upper1 / 100

IRs:
TMP_238(uint256) = amount * upper1
TMP_239(uint256) = TMP_238 / 100
upmoney1(uint256) := TMP_239(uint256)""];
42->43;
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
balances[top1] = balances[top1].add(upmoney1)

IRs:
REF_226(uint256) -> balances[top1]
REF_227(uint256) -> balances[top1]
TMP_240(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_227', 'upmoney1'] 
REF_226(uint256) (->balances) := TMP_240(uint256)""];
43->44;
44[label=""Node Type: EXPRESSION 44

EXPRESSION:
balances[this] = balances[this].sub(upmoney1)

IRs:
REF_229(uint256) -> balances[this]
REF_230(uint256) -> balances[this]
TMP_241(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_230', 'upmoney1'] 
REF_229(uint256) (->balances) := TMP_241(uint256)""];
44->45;
45[label=""Node Type: EXPRESSION 45

EXPRESSION:
sysoutmoney = sysoutmoney.sub(upmoney1)

IRs:
TMP_242(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['sysoutmoney', 'upmoney1'] 
sysoutmoney(uint256) := TMP_242(uint256)""];
45->46;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
sysusermoney = sysusermoney.add(upmoney1)

IRs:
TMP_243(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['sysusermoney', 'upmoney1'] 
sysusermoney(uint256) := TMP_243(uint256)""];
46->47;
47[label=""Node Type: EXPRESSION 47

EXPRESSION:
Transfer(this,top1,upmoney1)

IRs:
Emit Transfer(this,top1,upmoney1)""];
47->48;
48[label=""Node Type: EXPRESSION 48

EXPRESSION:
setteam(top1,upmoney1)

IRs:
TMP_245(bool) = INTERNAL_CALL, BTYCEC.setteam(address,uint256)(top1,upmoney1)""];
48->49;
49[label=""Node Type: NEW VARIABLE 49

EXPRESSION:
top2 = fromaddr[top1]

IRs:
REF_234(address) -> fromaddr[top1]
top2(address) := REF_234(address)""];
49->50;
50[label=""Node Type: IF 50

EXPRESSION:
top2 != address(0) && top2 != user

IRs:
TMP_246 = CONVERT 0 to address
TMP_247(bool) = top2 != TMP_246
TMP_248(bool) = top2 != user
TMP_249(bool) = TMP_247 && TMP_248
CONDITION TMP_249""];
50->51[label=""True""];
50->58[label=""False""];
51[label=""Node Type: NEW VARIABLE 51

EXPRESSION:
upmoney2 = amount * upper2 / 100

IRs:
TMP_250(uint256) = amount * upper2
TMP_251(uint256) = TMP_250 / 100
upmoney2(uint256) := TMP_251(uint256)""];
51->52;
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
balances[top2] = balances[top2].add(upmoney2)

IRs:
REF_235(uint256) -> balances[top2]
REF_236(uint256) -> balances[top2]
TMP_252(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_236', 'upmoney2'] 
REF_235(uint256) (->balances) := TMP_252(uint256)""];
52->53;
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
balances[this] = balances[this].sub(upmoney2)

IRs:
REF_238(uint256) -> balances[this]
REF_239(uint256) -> balances[this]
TMP_253(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_239', 'upmoney2'] 
REF_238(uint256) (->balances) := TMP_253(uint256)""];
53->54;
54[label=""Node Type: EXPRESSION 54

EXPRESSION:
sysoutmoney = sysoutmoney.sub(upmoney2)

IRs:
TMP_254(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['sysoutmoney', 'upmoney2'] 
sysoutmoney(uint256) := TMP_254(uint256)""];
54->55;
55[label=""Node Type: EXPRESSION 55

EXPRESSION:
sysusermoney = sysusermoney.add(upmoney2)

IRs:
TMP_255(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['sysusermoney', 'upmoney2'] 
sysusermoney(uint256) := TMP_255(uint256)""];
55->56;
56[label=""Node Type: EXPRESSION 56

EXPRESSION:
Transfer(this,top2,upmoney2)

IRs:
Emit Transfer(this,top2,upmoney2)""];
56->57;
57[label=""Node Type: EXPRESSION 57

EXPRESSION:
setteam(top2,upmoney2)

IRs:
TMP_257(bool) = INTERNAL_CALL, BTYCEC.setteam(address,uint256)(top2,upmoney2)""];
57->58;
58[label=""Node Type: END_IF 58
""];
58->59;
59[label=""Node Type: END_IF 59
""];
}
",0,1,0,0,"user = msg.sender;require(bool)(! frozenAccount[user]);require(bool)(actived == true);require(bool)(crontime[user] > 1);require(bool)(now > crontime[user]);;;;myeth[user] > 1;usmoney = myeth[user] * sysPer / 1000;;froeth[user] >= sysPrice1 && mintnum[user] > 1;mintmoney = froeth[user] * sysPer1 / 1000;;froeth[user] >= sysPrice2;mintmoney = froeth[user] * sysPer2 / 1000;;amount = usmoney.add(mintmoney);require(bool)(balances[this] > amount);require(bool)(sysoutmoney > amount);balances[user] = balances[user].add(amount);balances[this] = balances[this].sub(amount);sysoutmoney = sysoutmoney.sub(amount);sysusermoney = sysusermoney.add(amount);crontime[user] = now + onceAddTime;usmoney > 0;Transfer(this,user,usmoney);;mintmoney > 0;Transfer(this,user,mintmoney);;mintnum[user] --;mintnum[user] < 2;balances[user] = balances[user].add(froeth[user]);;myeth[user] = myeth[user].add(froeth[user]);sysminteth = sysminteth.sub(froeth[user]);Transfer(this,user,froeth[user]);froeth[user] = 1;top1 = fromaddr[user];top1 != address(0) && top1 != user;upmoney1 = amount * upper1 / 100;;balances[top1] = balances[top1].add(upmoney1);balances[this] = balances[this].sub(upmoney1);sysoutmoney = sysoutmoney.sub(upmoney1);sysusermoney = sysusermoney.add(upmoney1);Transfer(this,top1,upmoney1);setteam(top1,upmoney1);top2 = fromaddr[top1];top2 != address(0) && top2 != user;upmoney2 = amount * upper2 / 100;;balances[top2] = balances[top2].add(upmoney2);balances[this] = balances[this].sub(upmoney2);sysoutmoney = sysoutmoney.sub(upmoney2);sysusermoney = sysusermoney.add(upmoney2);Transfer(this,top2,upmoney2);setteam(top2,upmoney2)"
./0x6edea3515749cef9986d05f08104ffd976217bb7_ext.sol,BestMultiplierV3.getQueueLength,224,226,"REF_20 -> LENGTH queue,TMP_37(uint256) = REF_20 - currentReceiverIndex,RETURN TMP_37","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
queue.length - currentReceiverIndex

IRs:
REF_20 -> LENGTH queue
TMP_37(uint256) = REF_20 - currentReceiverIndex
RETURN TMP_37""];
}
",0,1,0,0,queue.length - currentReceiverIndex
./0x402288b27f39223d8a8131b53b35b9976d2c46d7_ext.sol,TokenERC20._transfer,26,39,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 > REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value > balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 > REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value > balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x6bb7a864a695ff718c9d8330c7d2ed9293949169_ext.sol,ColorStarToken.transferFrom,111,127,"REF_5(mapping(address => uint256)) -> allowed[_from],REF_6(uint256) -> REF_5[msg.sender],allowance(uint256) := REF_6(uint256),REF_7(uint256) -> balances[_from],TMP_29(bool) = REF_7 >= _value,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),TMP_31(bool) = _from == _to,REF_8(uint256) -> balances[_to],TMP_32(uint256) = MAX_UINT256 - _value,TMP_33(bool) = REF_8 <= TMP_32,TMP_34(bool) = TMP_31 || TMP_33,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),TMP_36(bool) = allowance >= _value,TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36),REF_9(uint256) -> balances[_from],REF_9(-> balances) = REF_9 - _value,REF_10(uint256) -> balances[_to],REF_10(-> balances) = REF_10 + _value,TMP_38(bool) = allowance < MAX_UINT256,CONDITION TMP_38,REF_11(mapping(address => uint256)) -> allowed[_from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowed) = REF_12 - _value,Emit Transfer(_from,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
allowance = allowed[_from][msg.sender]

IRs:
REF_5(mapping(address => uint256)) -> allowed[_from]
REF_6(uint256) -> REF_5[msg.sender]
allowance(uint256) := REF_6(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] >= _value)

IRs:
REF_7(uint256) -> balances[_from]
TMP_29(bool) = REF_7 >= _value
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_from == _to || balances[_to] <= MAX_UINT256 - _value)

IRs:
TMP_31(bool) = _from == _to
REF_8(uint256) -> balances[_to]
TMP_32(uint256) = MAX_UINT256 - _value
TMP_33(bool) = REF_8 <= TMP_32
TMP_34(bool) = TMP_31 || TMP_33
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(allowance >= _value)

IRs:
TMP_36(bool) = allowance >= _value
TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[_from] -= _value

IRs:
REF_9(uint256) -> balances[_from]
REF_9(-> balances) = REF_9 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[_to] += _value

IRs:
REF_10(uint256) -> balances[_to]
REF_10(-> balances) = REF_10 + _value""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
allowance < MAX_UINT256

IRs:
TMP_38(bool) = allowance < MAX_UINT256
CONDITION TMP_38""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_11(mapping(address => uint256)) -> allowed[_from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowed) = REF_12 - _value""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
10->11;
11[label=""Node Type: RETURN 11

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"allowance = allowed[_from][msg.sender];require(bool)(balances[_from] >= _value);require(bool)(_from == _to || balances[_to] <= MAX_UINT256 - _value);require(bool)(allowance >= _value);balances[_from] -= _value;balances[_to] += _value;allowance < MAX_UINT256;allowed[_from][msg.sender] -= _value;;Transfer(_from,_to,_value);true"
./0x281d30bf8b045e90578895619498ef5d6fd6584c_ext.sol,OracleContractAdapter.addOracles,180,193,"_idx(uint256) := 0(uint256),REF_8 -> LENGTH _whitelist,TMP_48(bool) = _idx < REF_8,CONDITION TMP_48,REF_9(address) -> _whitelist[_idx],_oracle(address) := REF_9(address),TMP_49(bool) = _oracle != 0,REF_10(bool) -> oracles[_oracle],TMP_50 = UnaryType.BANG REF_10 ,TMP_51(bool) = TMP_49 && TMP_50,CONDITION TMP_51,REF_11(bool) -> oracles[_oracle],REF_11(bool) (->oracles) := True(bool),INTERNAL_CALL, OracleContractAdapter._emitOracleAdded(address)(_oracle),_idx(uint256) = _idx + 1,RETURN OK,MODIFIER_CALL, Owned.onlyContractOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
2->11;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
_idx = 0

IRs:
_idx(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
_idx < _whitelist.length

IRs:
REF_8 -> LENGTH _whitelist
TMP_48(bool) = _idx < REF_8
CONDITION TMP_48""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
_oracle = _whitelist[_idx]

IRs:
REF_9(address) -> _whitelist[_idx]
_oracle(address) := REF_9(address)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
_oracle != 0x0 && ! oracles[_oracle]

IRs:
TMP_49(bool) = _oracle != 0
REF_10(bool) -> oracles[_oracle]
TMP_50 = UnaryType.BANG REF_10 
TMP_51(bool) = TMP_49 && TMP_50
CONDITION TMP_51""];
6->7[label=""True""];
6->9[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
oracles[_oracle] = true

IRs:
REF_11(bool) -> oracles[_oracle]
REF_11(bool) (->oracles) := True(bool)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
_emitOracleAdded(_oracle)

IRs:
INTERNAL_CALL, OracleContractAdapter._emitOracleAdded(address)(_oracle)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
++ _idx

IRs:
_idx(uint256) = _idx + 1""];
10->4;
11[label=""Node Type: RETURN 11

EXPRESSION:
OK

IRs:
RETURN OK""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyContractOwner()

IRs:
MODIFIER_CALL, Owned.onlyContractOwner()()""];
12->3;
}
",0,1,0,0,onlyContractOwner();;_idx < _whitelist.length;;OK;_idx = 0;_oracle = _whitelist[_idx];_oracle != 0x0 && ! oracles[_oracle];oracles[_oracle] = true;;_emitOracleAdded(_oracle);++ _idx
./0x4b7ca2ac56e69b9687b94b41b61a57cad3017ee4_ext.sol,TokenERC20.approveAndCall,75,83,"TMP_22 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_22(tokenRecipient),TMP_23(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value),CONDITION TMP_23,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_22 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_22(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_23(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value)
CONDITION TMP_23""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x2f50ab197f950e0c2184cf5d804f4141502cd987_ext.sol,LoggedDividend.recycleDividend,328,342,"REF_110 -> LENGTH dividends,TMP_142(uint256) = REF_110 - 1,TMP_143(bool) = TMP_142 < dividendId,CONDITION TMP_143,RETURN False,REF_111(LoggedDividend.Dividend) -> dividends[dividendId],dividend(LoggedDividend.Dividend) := REF_111(LoggedDividend.Dividend),REF_112(bool) -> dividend.recycled,CONDITION REF_112,RETURN False,REF_113(bool) -> dividend.recycled,REF_113(bool) (->dividend) := True(bool),RETURN True,MODIFIER_CALL, Ownable.onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: IF 1

EXPRESSION:
dividends.length - 1 < dividendId

IRs:
REF_110 -> LENGTH dividends
TMP_142(uint256) = REF_110 - 1
TMP_143(bool) = TMP_142 < dividendId
CONDITION TMP_143""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
dividend = dividends[dividendId]

IRs:
REF_111(LoggedDividend.Dividend) -> dividends[dividendId]
dividend(LoggedDividend.Dividend) := REF_111(LoggedDividend.Dividend)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
dividend.recycled

IRs:
REF_112(bool) -> dividend.recycled
CONDITION REF_112""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False""];
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
dividend.recycled = true

IRs:
REF_113(bool) -> dividend.recycled
REF_113(bool) (->dividend) := True(bool)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
10->1;
11[label=""Node Type: RETURN 11

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,onlyOwner();dividends.length - 1 < dividendId;false;;dividend = dividends[dividendId];dividend.recycled;false;;dividend.recycled = true;true;success
./0x45ca8d5458d7f3f7d2f47daae253924cafc2f331_ext.sol,EmiratesCoin.burn,123,129,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x6c79b4ed1cfe6ae97e6a8f117138cb583638954f_ext.sol,ERC20Token.burn,118,129,"REF_17(uint256) -> balanceOf[msg.sender],TMP_27(bool) = REF_17 >= _value,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_27(bool) = REF_17 >= _value
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x346b7ac48f05e505dd7c1c9e861577f7e793cf17_ext.sol,Template.description,238,240,"REF_7(string) -> descriptionOfLocale[_locale],RETURN REF_7","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
descriptionOfLocale[_locale]

IRs:
REF_7(string) -> descriptionOfLocale[_locale]
RETURN REF_7""];
}
",0,1,0,0,descriptionOfLocale[_locale]
./0x18035ee31125a9934de44b0105cd31691cce95d5_ext.sol,BigBoobsToken.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x25b16c95f3ebb1d8583a1c173f81257bc916a9be_ext.sol,SignalsCrowdsale.howMany,1091,1094,"TMP_555(uint256) = 1000000 - discount,TMP_556(uint256) = PRICE * TMP_555,TMP_557(uint256) = TMP_556 / 1000000,actualPrice(uint256) := TMP_557(uint256),TMP_558(uint256) = value / actualPrice,RETURN TMP_558","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
actualPrice = PRICE * (1000000 - discount) / 1000000

IRs:
TMP_555(uint256) = 1000000 - discount
TMP_556(uint256) = PRICE * TMP_555
TMP_557(uint256) = TMP_556 / 1000000
actualPrice(uint256) := TMP_557(uint256)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
value / actualPrice

IRs:
TMP_558(uint256) = value / actualPrice
RETURN TMP_558""];
}
",0,1,0,0,actualPrice = PRICE * (1000000 - discount) / 1000000;value / actualPrice
./0x8766ac6304e0198c876dd55bf400f3e035431574_ext.sol,KVCoin.mint,99,108,"TMP_29(bool) = msg.sender == saleAgent,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),tokenTotalSupply(uint256) = tokenTotalSupply + _amount,REF_12(uint256) -> balances[_to],REF_12(-> balances) = REF_12 + _amount,Emit Mint(_to,_amount),TMP_32 = CONVERT this to address,TMP_33(bool) = _to == TMP_32,CONDITION TMP_33,TMP_34(bool) = INTERNAL_CALL, KVCoin.burn()(),RETURN TMP_34,RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == saleAgent)

IRs:
TMP_29(bool) = msg.sender == saleAgent
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
tokenTotalSupply += _amount

IRs:
tokenTotalSupply(uint256) = tokenTotalSupply + _amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _amount

IRs:
REF_12(uint256) -> balances[_to]
REF_12(-> balances) = REF_12 + _amount""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Mint(_to,_amount)

IRs:
Emit Mint(_to,_amount)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
_to == address(this)

IRs:
TMP_32 = CONVERT this to address
TMP_33(bool) = _to == TMP_32
CONDITION TMP_33""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: RETURN 6

EXPRESSION:
burn()

IRs:
TMP_34(bool) = INTERNAL_CALL, KVCoin.burn()()
RETURN TMP_34""];
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(msg.sender == saleAgent);tokenTotalSupply += _amount;balances[_to] += _amount;Mint(_to,_amount);_to == address(this);burn();;true"
./0x1e867d04fbb7434093071237813df00b3df6ee77_ext.sol,GridcubePlatformToken.approveAndCall,244,249,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_59 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_59(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_59 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_59(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x517be460e08a7ecce448f54b41658c0bfb0d8674_ext.sol,StringYokes.zint_convert,45,50,"TMP_24 = CONVERT key to bytes,REF_3 -> LENGTH TMP_24,TMP_25(bool) = REF_3 > 32,CONDITION TMP_25,TMP_26(None) = SOLIDITY_CALL revert()(),RETURN ret","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
bytes(key).length > 32

IRs:
TMP_24 = CONVERT key to bytes
REF_3 -> LENGTH TMP_24
TMP_25(bool) = REF_3 > 32
CONDITION TMP_25""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_26(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: INLINE ASM 4
""];
4->5;
5[label=""Node Type: END INLINE ASM 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
ret

IRs:
RETURN ret""];
}
",0,1,0,0,bytes(key).length > 32;revert()();;;;ret
./0x540cf76f7efaffdeef8eec75b07807353667cef7_ext.sol,StandardToken.transferFrom,58,68,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0xb3ed21d5475817134c8f086d46dd1b5f6c49de0a_ext.sol,ZethrDice.getRollResults,988,1011,"TMP_254(uint256) = block.number - _blockNumber,TMP_255(bool) = TMP_254 > 255,CONDITION TMP_255,TMP_256(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '_numRolls'] ,lossAmount(uint256) := TMP_256(uint256),TMP_257(uint256) = INTERNAL_CALL, ZethrDice.calculateProfit(uint256,uint256)(_tokenValue,_rollUnder),profit(uint256) := TMP_257(uint256),i(uint256) := 0(uint256),TMP_258(bool) = i < _numRolls,CONDITION TMP_258,TMP_259(uint256) = INTERNAL_CALL, ZethrGame.random(uint256,uint256,address,uint256)(100,_blockNumber,_target,i),TMP_260(uint256) = TMP_259 + 1,output(uint256) := TMP_260(uint256),TMP_261(bool) = output < _rollUnder,CONDITION TMP_261,TMP_262(uint256) = profit + _tokenValue,winAmount(uint256) = winAmount + TMP_262,lossAmount(uint256) = lossAmount + _tokenValue,TMP_263(uint256) := i(uint256),i(uint256) = i + 1,RETURN winAmount,lossAmount,RETURN winAmount,lossAmount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
block.number - _blockNumber > 255

IRs:
TMP_254(uint256) = block.number - _blockNumber
TMP_255(bool) = TMP_254 > 255
CONDITION TMP_255""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
lossAmount = _tokenValue.mul(_numRolls)

IRs:
TMP_256(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '_numRolls'] 
lossAmount(uint256) := TMP_256(uint256)""];
2->14;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
profit = calculateProfit(_tokenValue,_rollUnder)

IRs:
TMP_257(uint256) = INTERNAL_CALL, ZethrDice.calculateProfit(uint256,uint256)(_tokenValue,_rollUnder)
profit(uint256) := TMP_257(uint256)""];
3->6;
4[label=""Node Type: BEGIN_LOOP 4
""];
4->7;
5[label=""Node Type: END_LOOP 5
""];
5->14;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
6->4;
7[label=""Node Type: IF_LOOP 7

EXPRESSION:
i < _numRolls

IRs:
TMP_258(bool) = i < _numRolls
CONDITION TMP_258""];
7->8[label=""True""];
7->5[label=""False""];
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
output = random(100,_blockNumber,_target,i) + 1

IRs:
TMP_259(uint256) = INTERNAL_CALL, ZethrGame.random(uint256,uint256,address,uint256)(100,_blockNumber,_target,i)
TMP_260(uint256) = TMP_259 + 1
output(uint256) := TMP_260(uint256)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
output < _rollUnder

IRs:
TMP_261(bool) = output < _rollUnder
CONDITION TMP_261""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
winAmount += profit + _tokenValue

IRs:
TMP_262(uint256) = profit + _tokenValue
winAmount(uint256) = winAmount + TMP_262""];
10->12;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
lossAmount += _tokenValue

IRs:
lossAmount(uint256) = lossAmount + _tokenValue""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
i ++

IRs:
TMP_263(uint256) := i(uint256)
i(uint256) = i + 1""];
13->7;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: RETURN 15

EXPRESSION:
(winAmount,lossAmount)

IRs:
RETURN winAmount,lossAmount""];
16[label=""Node Type: RETURN 16

EXPRESSION:
(winAmount,lossAmount)

IRs:
RETURN winAmount,lossAmount""];
}
",0,1,0,0,"block.number - _blockNumber > 255;lossAmount = _tokenValue.mul(_numRolls);profit = calculateProfit(_tokenValue,_rollUnder);;i = 0;;i < _numRolls;;output = random(100,_blockNumber,_target,i) + 1;output < _rollUnder;winAmount += profit + _tokenValue;lossAmount += _tokenValue;;i ++;(winAmount,lossAmount);(winAmount,lossAmount)"
./0xedcbfdf37c11aa36daaa6944386e494ae00e2d42_ext.sol,TokenERC20.burn,154,160,"REF_15(uint256) -> balanceOf[msg.sender],TMP_26(bool) = REF_15 >= _value,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_16(uint256) -> balanceOf[msg.sender],REF_16(-> balanceOf) = REF_16 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_15(uint256) -> balanceOf[msg.sender]
TMP_26(bool) = REF_15 >= _value
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_16(uint256) -> balanceOf[msg.sender]
REF_16(-> balanceOf) = REF_16 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x1dd72a0d3357901d51e791ba65476e101cb2c6a5_ext.sol,TokenERC20.approveAndCall,112,119,"TMP_58(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value),CONDITION TMP_58,TMP_59 = CONVERT _spender to TokenRecipient,spender(TokenRecipient) := TMP_59(TokenRecipient),HIGH_LEVEL_CALL, dest:spender(TokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN False","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_58(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value)
CONDITION TMP_58""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
spender = TokenRecipient(_spender)

IRs:
TMP_59 = CONVERT _spender to TokenRecipient
spender(TokenRecipient) := TMP_59(TokenRecipient)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(TokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False""];
}
",0,1,0,0,"approve(_spender,_value);spender = TokenRecipient(_spender);;spender.receiveApproval(msg.sender,_value,this,_extraData);true;false"
./0x0d3264ab9ee29bec9534f0f210ca8db3ac4794a8_ext.sol,LeifengMedals.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x377748ddc51b3075b84500a6ed95d260a102d85f_ext.sol,TuneToken.approveAndCall,62,70,"TMP_19 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_19(tokenRecipient),TMP_20(bool) = INTERNAL_CALL, TuneToken.approve(address,uint256)(_spender,_value),CONDITION TMP_20,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_19 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_19(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_20(bool) = INTERNAL_CALL, TuneToken.approve(address,uint256)(_spender,_value)
CONDITION TMP_20""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x5b463c4e19358b4eaf010cf24244bf140541a63e_ext.sol,TokenERC20.approveAndCall,77,83,"TMP_26 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_26(tokenRecipient),TMP_27(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value),CONDITION TMP_27,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_26 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_26(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_27(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value)
CONDITION TMP_27""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0xea8c9db193996bbc3f6a9afbdbea2b3b62c11253_ext.sol,RAcoinToken.mintTokens,425,433,"TMP_193(bool) = _mintedAmount <= unmintedTokens,TMP_194(None) = SOLIDITY_CALL require(bool)(TMP_193),REF_50(uint256) -> balances[_target],REF_50(-> balances) = REF_50 + _mintedAmount,unmintedTokens(uint256) = unmintedTokens - _mintedAmount,_totalSupply(uint256) = _totalSupply + _mintedAmount,Emit Transfer(1,_target,_mintedAmount),RETURN True,MODIFIER_CALL, Ownable.onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_mintedAmount <= unmintedTokens)

IRs:
TMP_193(bool) = _mintedAmount <= unmintedTokens
TMP_194(None) = SOLIDITY_CALL require(bool)(TMP_193)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_target] += _mintedAmount

IRs:
REF_50(uint256) -> balances[_target]
REF_50(-> balances) = REF_50 + _mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
unmintedTokens -= _mintedAmount

IRs:
unmintedTokens(uint256) = unmintedTokens - _mintedAmount""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
_totalSupply += _mintedAmount

IRs:
_totalSupply(uint256) = _totalSupply + _mintedAmount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(1,_target,_mintedAmount)

IRs:
Emit Transfer(1,_target,_mintedAmount)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->1;
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"onlyOwner();require(bool)(_mintedAmount <= unmintedTokens);balances[_target] += _mintedAmount;unmintedTokens -= _mintedAmount;_totalSupply += _mintedAmount;Transfer(1,_target,_mintedAmount);true;success"
./0x6e14ccec454b12ab03ef1ca2cf0ef67d6bfd8a26_ext.sol,Admin.admin_tokenBurn,138,145,"REF_12(uint256) -> balanceOf[msg.sender],TMP_72(bool) = REF_12 >= _value,TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72),REF_13(uint256) -> balanceOf[msg.sender],REF_13(-> balanceOf) = REF_13 - _value,totalSupply(uint256) = totalSupply - _value,Emit TokenBurn(msg.sender,_value),RETURN True,MODIFIER_CALL, Modifiers.isOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_12(uint256) -> balanceOf[msg.sender]
TMP_72(bool) = REF_12 >= _value
TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_13(uint256) -> balanceOf[msg.sender]
REF_13(-> balanceOf) = REF_13 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
TokenBurn(msg.sender,_value)

IRs:
Emit TokenBurn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
isOwner()

IRs:
MODIFIER_CALL, Modifiers.isOwner()()""];
6->1;
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"isOwner();require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;TokenBurn(msg.sender,_value);true;success"
./0xd82f9939aa0ba1bf5d5bbade54b5f2f61d2cfdbe_ext.sol,NEWT.transferFrom,36,46,"REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],allowance(uint256) := REF_5(uint256),REF_6(uint256) -> balances[_from],TMP_3(bool) = REF_6 >= _value,TMP_4(bool) = allowance >= _value,TMP_5(bool) = TMP_3 && TMP_4,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_7(uint256) -> balances[_to],REF_7(-> balances) = REF_7 + _value,REF_8(uint256) -> balances[_from],REF_8(-> balances) = REF_8 - _value,TMP_7(bool) = allowance < MAX_UINT256,CONDITION TMP_7,REF_9(mapping(address => uint256)) -> allowed[_from],REF_10(uint256) -> REF_9[msg.sender],REF_10(-> allowed) = REF_10 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
allowance = allowed[_from][msg.sender]

IRs:
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
allowance(uint256) := REF_5(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] >= _value && allowance >= _value)

IRs:
REF_6(uint256) -> balances[_from]
TMP_3(bool) = REF_6 >= _value
TMP_4(bool) = allowance >= _value
TMP_5(bool) = TMP_3 && TMP_4
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_7(uint256) -> balances[_to]
REF_7(-> balances) = REF_7 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] -= _value

IRs:
REF_8(uint256) -> balances[_from]
REF_8(-> balances) = REF_8 - _value""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
allowance < MAX_UINT256

IRs:
TMP_7(bool) = allowance < MAX_UINT256
CONDITION TMP_7""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_9(mapping(address => uint256)) -> allowed[_from]
REF_10(uint256) -> REF_9[msg.sender]
REF_10(-> allowed) = REF_10 - _value""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: RETURN 10

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowance = allowed[_from][msg.sender];require(bool)(balances[_from] >= _value && allowance >= _value);balances[_to] += _value;balances[_from] -= _value;allowance < MAX_UINT256;allowed[_from][msg.sender] -= _value;;Transfer(_from,_to,_value);true;success"
./0xecff8fc2a19f83fc855618704f38725756dbcae3_ext.sol,OK3D.receivePlayerInfo,1142,1158,"TMP_267 = CONVERT PlayerBook to address,TMP_268(bool) = msg.sender == TMP_267,TMP_269(None) = SOLIDITY_CALL require(bool,string)(TMP_268,your not playerNames contract... hmmm..),REF_453(uint256) -> pIDxAddr_[_addr],TMP_270(bool) = REF_453 != _pID,CONDITION TMP_270,REF_454(uint256) -> pIDxAddr_[_addr],REF_454(uint256) (->pIDxAddr_) := _pID(uint256),REF_455(uint256) -> pIDxName_[_name],TMP_271(bool) = REF_455 != _pID,CONDITION TMP_271,REF_456(uint256) -> pIDxName_[_name],REF_456(uint256) (->pIDxName_) := _pID(uint256),REF_457(F3Ddatasets.Player) -> plyr_[_pID],REF_458(address) -> REF_457.addr,TMP_272(bool) = REF_458 != _addr,CONDITION TMP_272,REF_459(F3Ddatasets.Player) -> plyr_[_pID],REF_460(address) -> REF_459.addr,REF_460(address) (->plyr_) := _addr(address),REF_461(F3Ddatasets.Player) -> plyr_[_pID],REF_462(bytes32) -> REF_461.name,TMP_273(bool) = REF_462 != _name,CONDITION TMP_273,REF_463(F3Ddatasets.Player) -> plyr_[_pID],REF_464(bytes32) -> REF_463.name,REF_464(bytes32) (->plyr_) := _name(bytes32),REF_465(F3Ddatasets.Player) -> plyr_[_pID],REF_466(uint256) -> REF_465.laff,TMP_274(bool) = REF_466 != _laff,CONDITION TMP_274,REF_467(F3Ddatasets.Player) -> plyr_[_pID],REF_468(uint256) -> REF_467.laff,REF_468(uint256) (->plyr_) := _laff(uint256),REF_469(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_470(bool) -> REF_469[_name],TMP_275(bool) = REF_470 == False,CONDITION TMP_275,REF_471(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_472(bool) -> REF_471[_name],REF_472(bool) (->plyrNames_) := True(bool)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(msg.sender == address(PlayerBook),your not playerNames contract... hmmm..)

IRs:
TMP_267 = CONVERT PlayerBook to address
TMP_268(bool) = msg.sender == TMP_267
TMP_269(None) = SOLIDITY_CALL require(bool,string)(TMP_268,your not playerNames contract... hmmm..)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
pIDxAddr_[_addr] != _pID

IRs:
REF_453(uint256) -> pIDxAddr_[_addr]
TMP_270(bool) = REF_453 != _pID
CONDITION TMP_270""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
pIDxAddr_[_addr] = _pID

IRs:
REF_454(uint256) -> pIDxAddr_[_addr]
REF_454(uint256) (->pIDxAddr_) := _pID(uint256)""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
pIDxName_[_name] != _pID

IRs:
REF_455(uint256) -> pIDxName_[_name]
TMP_271(bool) = REF_455 != _pID
CONDITION TMP_271""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
pIDxName_[_name] = _pID

IRs:
REF_456(uint256) -> pIDxName_[_name]
REF_456(uint256) (->pIDxName_) := _pID(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
plyr_[_pID].addr != _addr

IRs:
REF_457(F3Ddatasets.Player) -> plyr_[_pID]
REF_458(address) -> REF_457.addr
TMP_272(bool) = REF_458 != _addr
CONDITION TMP_272""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
plyr_[_pID].addr = _addr

IRs:
REF_459(F3Ddatasets.Player) -> plyr_[_pID]
REF_460(address) -> REF_459.addr
REF_460(address) (->plyr_) := _addr(address)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
plyr_[_pID].name != _name

IRs:
REF_461(F3Ddatasets.Player) -> plyr_[_pID]
REF_462(bytes32) -> REF_461.name
TMP_273(bool) = REF_462 != _name
CONDITION TMP_273""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
plyr_[_pID].name = _name

IRs:
REF_463(F3Ddatasets.Player) -> plyr_[_pID]
REF_464(bytes32) -> REF_463.name
REF_464(bytes32) (->plyr_) := _name(bytes32)""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
plyr_[_pID].laff != _laff

IRs:
REF_465(F3Ddatasets.Player) -> plyr_[_pID]
REF_466(uint256) -> REF_465.laff
TMP_274(bool) = REF_466 != _laff
CONDITION TMP_274""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
plyr_[_pID].laff = _laff

IRs:
REF_467(F3Ddatasets.Player) -> plyr_[_pID]
REF_468(uint256) -> REF_467.laff
REF_468(uint256) (->plyr_) := _laff(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: IF 17

EXPRESSION:
plyrNames_[_pID][_name] == false

IRs:
REF_469(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_470(bool) -> REF_469[_name]
TMP_275(bool) = REF_470 == False
CONDITION TMP_275""];
17->18[label=""True""];
17->19[label=""False""];
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
plyrNames_[_pID][_name] = true

IRs:
REF_471(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_472(bool) -> REF_471[_name]
REF_472(bool) (->plyrNames_) := True(bool)""];
18->19;
19[label=""Node Type: END_IF 19
""];
}
",0,1,0,0,"require(bool,string)(msg.sender == address(PlayerBook),your not playerNames contract... hmmm..);pIDxAddr_[_addr] != _pID;pIDxAddr_[_addr] = _pID;;pIDxName_[_name] != _pID;pIDxName_[_name] = _pID;;plyr_[_pID].addr != _addr;plyr_[_pID].addr = _addr;;plyr_[_pID].name != _name;plyr_[_pID].name = _name;;plyr_[_pID].laff != _laff;plyr_[_pID].laff = _laff;;plyrNames_[_pID][_name] == false;plyrNames_[_pID][_name] = true;"
./0xed98b38f4fc2fcc633465b699f6d983d96e1fe8c_ext.sol,x32323.reward,70,77,"TMP_10(bool) = totalSupply < maxSupply,CONDITION TMP_10,REF_6(uint256) -> balanceOf[_address],REF_6(-> balanceOf) = REF_6 + bonis,totalSupply(uint256) = totalSupply + bonis,RETURN True,Emit Airdrop(_address,bonis),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
totalSupply < maxSupply

IRs:
TMP_10(bool) = totalSupply < maxSupply
CONDITION TMP_10""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[_address] += bonis

IRs:
REF_6(uint256) -> balanceOf[_address]
REF_6(-> balanceOf) = REF_6 + bonis""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply += bonis

IRs:
totalSupply(uint256) = totalSupply + bonis""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Airdrop(_address,bonis)

IRs:
Emit Airdrop(_address,bonis)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"totalSupply < maxSupply;balanceOf[_address] += bonis;;totalSupply += bonis;true;Airdrop(_address,bonis);success"
./0x6b3f9f54e2a684ea28365af5f3dd6d714df4328b_ext.sol,TokenERC20._transfer,33,49,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xef4bbb338e2d21ffcbde49ea2b94befe2bba05f1_ext.sol,StandardToken.transferFrom,44,54,"REF_3(uint256) -> balances[_from],TMP_3(bool) = REF_3 >= _value,REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],TMP_4(bool) = REF_5 >= _value,TMP_5(bool) = TMP_3 && TMP_4,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_6(uint256) -> balances[_to],REF_6(-> balances) = REF_6 + _value,REF_7(uint256) -> balances[_from],REF_7(-> balances) = REF_7 - _value,REF_8(mapping(address => uint256)) -> allowed[_from],REF_9(uint256) -> REF_8[msg.sender],REF_9(-> allowed) = REF_9 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value)

IRs:
REF_3(uint256) -> balances[_from]
TMP_3(bool) = REF_3 >= _value
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
TMP_4(bool) = REF_5 >= _value
TMP_5(bool) = TMP_3 && TMP_4
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_6(uint256) -> balances[_to]
REF_6(-> balances) = REF_6 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_7(uint256) -> balances[_from]
REF_7(-> balances) = REF_7 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_8(mapping(address => uint256)) -> allowed[_from]
REF_9(uint256) -> REF_8[msg.sender]
REF_9(-> allowed) = REF_9 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);balances[_to] += _value;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true;success"
./0x651a824c225e60c1901ec6018a685aa38d82f23c_ext.sol,PimmelToken.burn,84,90,"REF_13(uint256) -> balanceOf[msg.sender],TMP_15(bool) = REF_13 > _value,TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15),REF_14(uint256) -> balanceOf[msg.sender],REF_14(-> balanceOf) = REF_14 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] > _value)

IRs:
REF_13(uint256) -> balanceOf[msg.sender]
TMP_15(bool) = REF_13 > _value
TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_14(uint256) -> balanceOf[msg.sender]
REF_14(-> balanceOf) = REF_14 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] > _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x77e00640a6343152a35542027ba76407bdde0bb6_ext.sol,quiz_please.start_qz_game,20,27,"TMP_7(bool) = responseHash == 0,CONDITION TMP_7,TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response),responseHash(bytes32) := TMP_8(bytes32),question(string) := _question(string),questionSender(address) := msg.sender(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
responseHash == 0x0

IRs:
TMP_7(bool) = responseHash == 0
CONDITION TMP_7""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
responseHash = keccak256()(_response)

IRs:
TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response)
responseHash(bytes32) := TMP_8(bytes32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
questionSender = msg.sender

IRs:
questionSender(address) := msg.sender(address)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,1,0,0,responseHash == 0x0;responseHash = keccak256()(_response);;question = _question;questionSender = msg.sender
./0x4d50c99294daa84d8de9b2a5b9b6a6d9a8d88aa3_ext.sol,SERBIA_WINS.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x6b193e107a773967bd821bcf8218f3548cfa2503_ext.sol,PossContract.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x70673d36178f17ac064747c7bdd026240be194b5_ext.sol,UNIQ.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x20d2f8fdd0951f2f5249c86b3cdc2be7656f2c01_ext.sol,MyTokenEVC.burn,162,168,"REF_20(uint256) -> _balanceOf[msg.sender],TMP_30(bool) = REF_20 >= _value,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_21(uint256) -> _balanceOf[msg.sender],REF_21(-> _balanceOf) = REF_21 - _value,_totalSupply(uint256) = _totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,MODIFIER_CALL, owned.onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_balanceOf[msg.sender] >= _value)

IRs:
REF_20(uint256) -> _balanceOf[msg.sender]
TMP_30(bool) = REF_20 >= _value
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_balanceOf[msg.sender] -= _value

IRs:
REF_21(uint256) -> _balanceOf[msg.sender]
REF_21(-> _balanceOf) = REF_21 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_totalSupply -= _value

IRs:
_totalSupply(uint256) = _totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
6->1;
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"onlyOwner();require(bool)(_balanceOf[msg.sender] >= _value);_balanceOf[msg.sender] -= _value;_totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x8993db1795b9a7b317b98ebfa4c971f225bf1248_ext.sol,ENKToken.burn,159,164,"REF_10(uint256) -> balances[msg.sender],TMP_47(bool) = REF_10 >= _value,TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47),REF_11(uint256) -> balances[msg.sender],REF_12(uint256) -> balances[msg.sender],TMP_49(uint256) = LIBRARY_CALL, dest:SafeMathLib, function:SafeMathLib.minus(uint256,uint256), arguments:['REF_12', '_value'] ,REF_11(uint256) (->balances) := TMP_49(uint256),burntTokens(uint256) = burntTokens + _value,Emit BurnToken(msg.sender,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_10(uint256) -> balances[msg.sender]
TMP_47(bool) = REF_10 >= _value
TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] = balances[msg.sender].minus(_value)

IRs:
REF_11(uint256) -> balances[msg.sender]
REF_12(uint256) -> balances[msg.sender]
TMP_49(uint256) = LIBRARY_CALL, dest:SafeMathLib, function:SafeMathLib.minus(uint256,uint256), arguments:['REF_12', '_value'] 
REF_11(uint256) (->balances) := TMP_49(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
burntTokens += _value

IRs:
burntTokens(uint256) = burntTokens + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
BurnToken(msg.sender,_value)

IRs:
Emit BurnToken(msg.sender,_value)""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);balances[msg.sender] = balances[msg.sender].minus(_value);burntTokens += _value;BurnToken(msg.sender,_value)"
./0x7125df83a5d3945728036d3c5e48e2c9e38d1607_ext.sol,Smartolution.fallback,47,89,"TMP_0(bool) = msg.value == 11110000000000,TMP_1(bool) = msg.value >= 10000000000000000,TMP_2(bool) = msg.value <= 5000000000000000000,TMP_3(bool) = TMP_1 && TMP_2,TMP_4(bool) = TMP_0 || TMP_3,TMP_5(None) = SOLIDITY_CALL require(bool,string)(TMP_4,Min: 0.01 ether, Max: 5 ether, Exit: 0.00001111 eth),REF_0(Smartolution.User) -> users[msg.sender],user(Smartolution.User) := REF_0(Smartolution.User),TMP_6(bool) = msg.value != 11110000000000,CONDITION TMP_6,total(uint256) = total + msg.value,TMP_7(uint256) = msg.value / 30,advertisement(uint256) = advertisement + TMP_7,TMP_8(uint256) = msg.value / 200,team(uint256) = team + TMP_8,REF_1(uint256) -> user.value,TMP_9(bool) = REF_1 == 0,CONDITION TMP_9,REF_2(uint256) -> user.value,REF_2(uint256) (->user) := msg.value(uint256),REF_3(uint256) -> user.atBlock,REF_3(uint256) (->user) := block.number(uint256),REF_4(uint256) -> user.index,REF_4(uint256) (->user) := 1(uint256),REF_5(uint256) -> user.atBlock,TMP_10(uint256) = block.number - REF_5,TMP_11(bool) = TMP_10 >= 5900,TMP_12(None) = SOLIDITY_CALL require(bool,string)(TMP_11,Too soon, try again later),REF_6(uint256) -> user.index,REF_6(-> user) = REF_6 + 1,idx(uint256) := REF_6(uint256),TMP_13(bool) = idx == 45,CONDITION TMP_13,REF_7(uint256) -> user.value,REF_7(uint256) (->user) := 0(uint256),REF_8(uint256) -> user.atBlock,TMP_14(uint256) = block.number - REF_8,TMP_15(uint256) = TMP_14 - 5900,TMP_16(bool) = TMP_15 < 984,CONDITION TMP_16,REF_9(uint256) -> user.atBlock,REF_9(-> user) = REF_9 + 5900,REF_10(uint256) -> user.atBlock,TMP_17(uint256) = block.number - 984,REF_10(uint256) (->user) := TMP_17(uint256),TMP_18(uint256) = amount * idx,TMP_19(uint256) = TMP_18 * idx,TMP_20(uint256) = 500 * amount,TMP_21(uint256) = TMP_20 / 1000000000000000000,TMP_22(uint256) = 24400 - TMP_21,TMP_23(uint256) = TMP_19 * TMP_22,TMP_24(uint256) = TMP_23 / 10000000,Transfer dest:msg.sender value:TMP_24,REF_12(uint256) -> user.index,TMP_26(bool) = REF_12 <= 10,TMP_27(None) = SOLIDITY_CALL require(bool,string)(TMP_26,It's too late to request a refund at this point),REF_14(uint256) -> user.index,REF_15(uint256) -> user.value,TMP_28(uint256) = REF_14 * REF_15,TMP_29(uint256) = TMP_28 * 70,TMP_30(uint256) = TMP_29 / 100,Transfer dest:msg.sender value:TMP_30,REF_16(uint256) -> user.value,REF_16(uint256) (->user) := 0(uint256),REF_17(uint256) -> user.value,TMP_32(bool) = msg.value > REF_17,CONDITION TMP_32,REF_18(uint256) -> user.value,amount(uint256) := REF_18(uint256),amount(uint256) := msg.value(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(msg.value == 11110000000000 || (msg.value >= 10000000000000000 && msg.value <= 5000000000000000000),Min: 0.01 ether, Max: 5 ether, Exit: 0.00001111 eth)

IRs:
TMP_0(bool) = msg.value == 11110000000000
TMP_1(bool) = msg.value >= 10000000000000000
TMP_2(bool) = msg.value <= 5000000000000000000
TMP_3(bool) = TMP_1 && TMP_2
TMP_4(bool) = TMP_0 || TMP_3
TMP_5(None) = SOLIDITY_CALL require(bool,string)(TMP_4,Min: 0.01 ether, Max: 5 ether, Exit: 0.00001111 eth)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
user = users[msg.sender]

IRs:
REF_0(Smartolution.User) -> users[msg.sender]
user(Smartolution.User) := REF_0(Smartolution.User)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
msg.value != 11110000000000

IRs:
TMP_6(bool) = msg.value != 11110000000000
CONDITION TMP_6""];
3->4[label=""True""];
3->23[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
total += msg.value

IRs:
total(uint256) = total + msg.value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
advertisement += msg.value / 30

IRs:
TMP_7(uint256) = msg.value / 30
advertisement(uint256) = advertisement + TMP_7""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
team += msg.value / 200

IRs:
TMP_8(uint256) = msg.value / 200
team(uint256) = team + TMP_8""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
user.value == 0

IRs:
REF_1(uint256) -> user.value
TMP_9(bool) = REF_1 == 0
CONDITION TMP_9""];
7->8[label=""True""];
7->11[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
user.value = msg.value

IRs:
REF_2(uint256) -> user.value
REF_2(uint256) (->user) := msg.value(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
user.atBlock = block.number

IRs:
REF_3(uint256) -> user.atBlock
REF_3(uint256) (->user) := block.number(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
user.index = 1

IRs:
REF_4(uint256) -> user.index
REF_4(uint256) (->user) := 1(uint256)""];
10->22;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
require(bool,string)(block.number - user.atBlock >= 5900,Too soon, try again later)

IRs:
REF_5(uint256) -> user.atBlock
TMP_10(uint256) = block.number - REF_5
TMP_11(bool) = TMP_10 >= 5900
TMP_12(None) = SOLIDITY_CALL require(bool,string)(TMP_11,Too soon, try again later)""];
11->12;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
idx = ++ user.index

IRs:
REF_6(uint256) -> user.index
REF_6(-> user) = REF_6 + 1
idx(uint256) := REF_6(uint256)""];
12->27;
14[label=""Node Type: IF 14

EXPRESSION:
idx == 45

IRs:
TMP_13(bool) = idx == 45
CONDITION TMP_13""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
user.value = 0

IRs:
REF_7(uint256) -> user.value
REF_7(uint256) (->user) := 0(uint256)""];
15->20;
16[label=""Node Type: IF 16

EXPRESSION:
block.number - user.atBlock - 5900 < 984

IRs:
REF_8(uint256) -> user.atBlock
TMP_14(uint256) = block.number - REF_8
TMP_15(uint256) = TMP_14 - 5900
TMP_16(bool) = TMP_15 < 984
CONDITION TMP_16""];
16->17[label=""True""];
16->18[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
user.atBlock += 5900

IRs:
REF_9(uint256) -> user.atBlock
REF_9(-> user) = REF_9 + 5900""];
17->19;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
user.atBlock = block.number - 984

IRs:
REF_10(uint256) -> user.atBlock
TMP_17(uint256) = block.number - 984
REF_10(uint256) (->user) := TMP_17(uint256)""];
18->19;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
msg.sender.transfer(amount * idx * idx * (24400 - 500 * amount / 1000000000000000000) / 10000000)

IRs:
TMP_18(uint256) = amount * idx
TMP_19(uint256) = TMP_18 * idx
TMP_20(uint256) = 500 * amount
TMP_21(uint256) = TMP_20 / 1000000000000000000
TMP_22(uint256) = 24400 - TMP_21
TMP_23(uint256) = TMP_19 * TMP_22
TMP_24(uint256) = TMP_23 / 10000000
Transfer dest:msg.sender value:TMP_24""];
21->22;
22[label=""Node Type: END_IF 22
""];
22->26;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
require(bool,string)(user.index <= 10,It's too late to request a refund at this point)

IRs:
REF_12(uint256) -> user.index
TMP_26(bool) = REF_12 <= 10
TMP_27(None) = SOLIDITY_CALL require(bool,string)(TMP_26,It's too late to request a refund at this point)""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
msg.sender.transfer(user.index * user.value * 70 / 100)

IRs:
REF_14(uint256) -> user.index
REF_15(uint256) -> user.value
TMP_28(uint256) = REF_14 * REF_15
TMP_29(uint256) = TMP_28 * 70
TMP_30(uint256) = TMP_29 / 100
Transfer dest:msg.sender value:TMP_30""];
24->25;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
user.value = 0

IRs:
REF_16(uint256) -> user.value
REF_16(uint256) (->user) := 0(uint256)""];
25->26;
26[label=""Node Type: END_IF 26
""];
27[label=""Node Type: IF 27

EXPRESSION:
msg.value > user.value

IRs:
REF_17(uint256) -> user.value
TMP_32(bool) = msg.value > REF_17
CONDITION TMP_32""];
27->28[label=""True""];
27->29[label=""False""];
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
amount = user.value

IRs:
REF_18(uint256) -> user.value
amount(uint256) := REF_18(uint256)""];
28->30;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
amount = msg.value

IRs:
amount(uint256) := msg.value(uint256)""];
29->30;
30[label=""Node Type: END_IF 30
""];
30->14;
}
",0,1,0,0,"require(bool,string)(msg.value == 11110000000000 || (msg.value >= 10000000000000000 && msg.value <= 5000000000000000000),Min: 0.01 ether, Max: 5 ether, Exit: 0.00001111 eth);user = users[msg.sender];msg.value != 11110000000000;total += msg.value;require(bool,string)(user.index <= 10,It's too late to request a refund at this point);advertisement += msg.value / 30;team += msg.value / 200;user.value == 0;user.value = msg.value;require(bool,string)(block.number - user.atBlock >= 5900,Too soon, try again later);user.atBlock = block.number;user.index = 1;;idx = ++ user.index;msg.value > user.value;idx == 45;user.value = 0;block.number - user.atBlock - 5900 < 984;;user.atBlock += 5900;user.atBlock = block.number - 984;;msg.sender.transfer(amount * idx * idx * (24400 - 500 * amount / 1000000000000000000) / 10000000);;msg.sender.transfer(user.index * user.value * 70 / 100);user.value = 0;amount = user.value;amount = msg.value;"
./0x6cb816569ab4665bdc2ba78a64aff87201608bc6_ext.sol,Bitmos.transferFrom,93,103,"REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],allowance(uint256) := REF_5(uint256),REF_6(uint256) -> balances[_from],TMP_3(bool) = REF_6 >= _value,TMP_4(bool) = allowance >= _value,TMP_5(bool) = TMP_3 && TMP_4,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_7(uint256) -> balances[_to],REF_7(-> balances) = REF_7 + _value,REF_8(uint256) -> balances[_from],REF_8(-> balances) = REF_8 - _value,TMP_7(bool) = allowance < MAX_UINT256,CONDITION TMP_7,REF_9(mapping(address => uint256)) -> allowed[_from],REF_10(uint256) -> REF_9[msg.sender],REF_10(-> allowed) = REF_10 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
allowance = allowed[_from][msg.sender]

IRs:
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
allowance(uint256) := REF_5(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] >= _value && allowance >= _value)

IRs:
REF_6(uint256) -> balances[_from]
TMP_3(bool) = REF_6 >= _value
TMP_4(bool) = allowance >= _value
TMP_5(bool) = TMP_3 && TMP_4
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_7(uint256) -> balances[_to]
REF_7(-> balances) = REF_7 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] -= _value

IRs:
REF_8(uint256) -> balances[_from]
REF_8(-> balances) = REF_8 - _value""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
allowance < MAX_UINT256

IRs:
TMP_7(bool) = allowance < MAX_UINT256
CONDITION TMP_7""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_9(mapping(address => uint256)) -> allowed[_from]
REF_10(uint256) -> REF_9[msg.sender]
REF_10(-> allowed) = REF_10 - _value""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: RETURN 10

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowance = allowed[_from][msg.sender];require(bool)(balances[_from] >= _value && allowance >= _value);balances[_to] += _value;balances[_from] -= _value;allowance < MAX_UINT256;allowed[_from][msg.sender] -= _value;;Transfer(_from,_to,_value);true;success"
./0x6abf810730a342add1374e11f3e97500ee774d1f_ext.sol,BCFAuction.calculateCurrentPrice,580,594,"TMP_350(bool) = secondsElapsed >= duration,CONDITION TMP_350,RETURN endPrice,TMP_351 = CONVERT endPrice to int256,TMP_352 = CONVERT startPrice to int256,TMP_353(int256) = TMP_351 - TMP_352,totalPriceChange(int256) := TMP_353(int256),TMP_354 = CONVERT secondsElapsed to int256,TMP_355(int256) = totalPriceChange * TMP_354,TMP_356 = CONVERT duration to int256,TMP_357(int256) = TMP_355 / TMP_356,currentPriceChange(int256) := TMP_357(int256),TMP_358 = CONVERT startPrice to int256,TMP_359(int256) = TMP_358 + currentPriceChange,_currentPrice(int256) := TMP_359(int256),TMP_360 = CONVERT _currentPrice to uint256,RETURN TMP_360","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
secondsElapsed >= duration

IRs:
TMP_350(bool) = secondsElapsed >= duration
CONDITION TMP_350""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
endPrice

IRs:
RETURN endPrice""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
totalPriceChange = int256(endPrice) - int256(startPrice)

IRs:
TMP_351 = CONVERT endPrice to int256
TMP_352 = CONVERT startPrice to int256
TMP_353(int256) = TMP_351 - TMP_352
totalPriceChange(int256) := TMP_353(int256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
currentPriceChange = totalPriceChange * int256(secondsElapsed) / int256(duration)

IRs:
TMP_354 = CONVERT secondsElapsed to int256
TMP_355(int256) = totalPriceChange * TMP_354
TMP_356 = CONVERT duration to int256
TMP_357(int256) = TMP_355 / TMP_356
currentPriceChange(int256) := TMP_357(int256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
_currentPrice = int256(startPrice) + currentPriceChange

IRs:
TMP_358 = CONVERT startPrice to int256
TMP_359(int256) = TMP_358 + currentPriceChange
_currentPrice(int256) := TMP_359(int256)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
uint256(_currentPrice)

IRs:
TMP_360 = CONVERT _currentPrice to uint256
RETURN TMP_360""];
}
",0,1,0,0,secondsElapsed >= duration;endPrice;;totalPriceChange = int256(endPrice) - int256(startPrice);currentPriceChange = totalPriceChange * int256(secondsElapsed) / int256(duration);_currentPrice = int256(startPrice) + currentPriceChange;uint256(_currentPrice)
./0x5c8d8245e52f893de53c716c969b1526a0075070_ext.sol,ENXAirDrop.airDrop,29,38,"i(uint256) := 0(uint256),REF_0 -> LENGTH airDropDesinationAddress,TMP_8(bool) = i < REF_0,CONDITION TMP_8,TMP_9 = CONVERT contractObj to ERC20Interface,REF_2(address) -> airDropDesinationAddress[i],REF_3(uint256) -> amounts[i],TMP_10(bool) = HIGH_LEVEL_CALL, dest:TMP_9(ERC20Interface), function:transferFrom, arguments:['tokenRepo', 'REF_2', 'REF_3']  ,TMP_11(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < airDropDesinationAddress.length

IRs:
REF_0 -> LENGTH airDropDesinationAddress
TMP_8(bool) = i < REF_0
CONDITION TMP_8""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
ERC20Interface(contractObj).transferFrom(tokenRepo,airDropDesinationAddress[i],amounts[i])

IRs:
TMP_9 = CONVERT contractObj to ERC20Interface
REF_2(address) -> airDropDesinationAddress[i]
REF_3(uint256) -> amounts[i]
TMP_10(bool) = HIGH_LEVEL_CALL, dest:TMP_9(ERC20Interface), function:transferFrom, arguments:['tokenRepo', 'REF_2', 'REF_3']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_11(uint256) := i(uint256)
i(uint256) = i + 1""];
6->4;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->3;
}
",0,1,0,0,"onlyOwner();;i < airDropDesinationAddress.length;;i = 0;ERC20Interface(contractObj).transferFrom(tokenRepo,airDropDesinationAddress[i],amounts[i]);i ++"
./0x1dc5b8ccbe7a3669ed59dcd3b3d5afa0fed4ee57_ext.sol,ERC23Token.transferToAddress,99,105,"REF_0(uint256) -> balances[msg.sender],REF_0(-> balances) = REF_0 - _value,REF_1(uint256) -> balances[_to],REF_1(-> balances) = REF_1 + _value,Emit Transfer(msg.sender,_to,_value),Emit Transfer(msg.sender,_to,_value,_data),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_0(uint256) -> balances[msg.sender]
REF_0(-> balances) = REF_0 - _value""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_1(uint256) -> balances[_to]
REF_1(-> balances) = REF_1 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value,_data)

IRs:
Emit Transfer(msg.sender,_to,_value,_data)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);Transfer(msg.sender,_to,_value,_data);true;success"
./0x17c94b2203cd76d1e28509cece13e35744b9555c_ext.sol,ERC20MIST._transfer,42,58,"TMP_3(bool) = _to != 835244991326125719751498960578711751906703458572,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x924DAE462424428eBC8EA034B280e7D4e10C410c)

IRs:
TMP_3(bool) = _to != 835244991326125719751498960578711751906703458572
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x924DAE462424428eBC8EA034B280e7D4e10C410c);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x07ce333ec45618d838c32e60cee5cb1ce389e06e_ext.sol,BancorChanger.updateReserve,471,484,"REF_34(BancorChanger.Reserve) -> reserves[_reserveToken],reserve(BancorChanger.Reserve) := REF_34(BancorChanger.Reserve),REF_35(uint8) -> reserve.ratio,TMP_147(uint8) = totalReserveRatio - REF_35,TMP_148(uint8) = TMP_147 + _ratio,TMP_149(bool) = TMP_148 <= 100,TMP_150(None) = SOLIDITY_CALL require(bool)(TMP_149),REF_36(uint8) -> reserve.ratio,TMP_151(uint8) = totalReserveRatio - REF_36,TMP_152(uint8) = TMP_151 + _ratio,totalReserveRatio(uint8) := TMP_152(uint8),REF_37(uint8) -> reserve.ratio,REF_37(uint8) (->reserve) := _ratio(uint8),REF_38(bool) -> reserve.isVirtualBalanceEnabled,REF_38(bool) (->reserve) := _enableVirtualBalance(bool),REF_39(uint256) -> reserve.virtualBalance,REF_39(uint256) (->reserve) := _virtualBalance(uint256),MODIFIER_CALL, Owned.ownerOnly()(),MODIFIER_CALL, BancorChanger.validReserve(address)(_reserveToken),MODIFIER_CALL, BancorChanger.validReserveRatio(uint8)(_ratio)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
reserve = reserves[_reserveToken]

IRs:
REF_34(BancorChanger.Reserve) -> reserves[_reserveToken]
reserve(BancorChanger.Reserve) := REF_34(BancorChanger.Reserve)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(totalReserveRatio - reserve.ratio + _ratio <= 100)

IRs:
REF_35(uint8) -> reserve.ratio
TMP_147(uint8) = totalReserveRatio - REF_35
TMP_148(uint8) = TMP_147 + _ratio
TMP_149(bool) = TMP_148 <= 100
TMP_150(None) = SOLIDITY_CALL require(bool)(TMP_149)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalReserveRatio = totalReserveRatio - reserve.ratio + _ratio

IRs:
REF_36(uint8) -> reserve.ratio
TMP_151(uint8) = totalReserveRatio - REF_36
TMP_152(uint8) = TMP_151 + _ratio
totalReserveRatio(uint8) := TMP_152(uint8)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
reserve.ratio = _ratio

IRs:
REF_37(uint8) -> reserve.ratio
REF_37(uint8) (->reserve) := _ratio(uint8)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
reserve.isVirtualBalanceEnabled = _enableVirtualBalance

IRs:
REF_38(bool) -> reserve.isVirtualBalanceEnabled
REF_38(bool) (->reserve) := _enableVirtualBalance(bool)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
reserve.virtualBalance = _virtualBalance

IRs:
REF_39(uint256) -> reserve.virtualBalance
REF_39(uint256) (->reserve) := _virtualBalance(uint256)""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
ownerOnly()

IRs:
MODIFIER_CALL, Owned.ownerOnly()()""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
validReserve(_reserveToken)

IRs:
MODIFIER_CALL, BancorChanger.validReserve(address)(_reserveToken)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
validReserveRatio(_ratio)

IRs:
MODIFIER_CALL, BancorChanger.validReserveRatio(uint8)(_ratio)""];
9->1;
}
",0,1,0,0,ownerOnly();reserve = reserves[_reserveToken];require(bool)(totalReserveRatio - reserve.ratio + _ratio <= 100);totalReserveRatio = totalReserveRatio - reserve.ratio + _ratio;reserve.ratio = _ratio;reserve.isVirtualBalanceEnabled = _enableVirtualBalance;reserve.virtualBalance = _virtualBalance;validReserve(_reserveToken);validReserveRatio(_ratio)
./0x022882d9fcf023e57926e4e01d1b137aabd93416_ext.sol,StandardToken.transferFrom,26,36,"REF_3(uint256) -> balances[_from],TMP_4(bool) = REF_3 >= _value,REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],TMP_5(bool) = REF_5 >= _value,TMP_6(bool) = TMP_4 && TMP_5,TMP_7(bool) = _value > 0,TMP_8(bool) = TMP_6 && TMP_7,CONDITION TMP_8,REF_6(uint256) -> balances[_to],REF_6(-> balances) = REF_6 + _value,REF_7(uint256) -> balances[_from],REF_7(-> balances) = REF_7 - _value,REF_8(mapping(address => uint256)) -> allowed[_from],REF_9(uint256) -> REF_8[msg.sender],REF_9(-> allowed) = REF_9 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0

IRs:
REF_3(uint256) -> balances[_from]
TMP_4(bool) = REF_3 >= _value
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
TMP_5(bool) = REF_5 >= _value
TMP_6(bool) = TMP_4 && TMP_5
TMP_7(bool) = _value > 0
TMP_8(bool) = TMP_6 && TMP_7
CONDITION TMP_8""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_6(uint256) -> balances[_to]
REF_6(-> balances) = REF_6 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_7(uint256) -> balances[_from]
REF_7(-> balances) = REF_7 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_8(mapping(address => uint256)) -> allowed[_from]
REF_9(uint256) -> REF_8[msg.sender]
REF_9(-> allowed) = REF_9 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0;balances[_to] += _value;false;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true;success"
./0xd07d571e0a45306350c005f5ed858783ae725d71_ext.sol,Members.pushStatus,57,64,"TMP_6(Members.MemberStatus) = new MemberStatus(_name,_times,_sum,_rate),REF_1 -> LENGTH status,TMP_8(uint256) := REF_1(uint256),TMP_9(uint256) = TMP_8 + 1,REF_1(uint256) (->status) := TMP_9(uint256),REF_2(Members.MemberStatus) -> status[TMP_8],REF_2(Members.MemberStatus) (->status) := TMP_6(Members.MemberStatus),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
status.push(MemberStatus({name:_name,times:_times,sum:_sum,rate:_rate}))

IRs:
TMP_6(Members.MemberStatus) = new MemberStatus(_name,_times,_sum,_rate)
REF_1 -> LENGTH status
TMP_8(uint256) := REF_1(uint256)
TMP_9(uint256) = TMP_8 + 1
REF_1(uint256) (->status) := TMP_9(uint256)
REF_2(Members.MemberStatus) -> status[TMP_8]
REF_2(Members.MemberStatus) (->status) := TMP_6(Members.MemberStatus)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
2->1;
}
",0,1,0,0,"onlyOwner();status.push(MemberStatus({name:_name,times:_times,sum:_sum,rate:_rate}))"
./0xeaaa3585ffdcc973a22929d09179dc06d517b84d_ext.sol,TokenERC20.approveAndCall,105,113,"TMP_22 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_22(tokenRecipient),TMP_23(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value),TMP_24 = UnaryType.BANG TMP_23 ,CONDITION TMP_24,RETURN False,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_22 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_22(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
! approve(_spender,_value)

IRs:
TMP_23(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value)
TMP_24 = UnaryType.BANG TMP_23 
CONDITION TMP_24""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3

EXPRESSION:
false

IRs:
RETURN False""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);! approve(_spender,_value);false;;spender.receiveApproval(msg.sender,_value,this,_extraData);true;success"
./0xbd35aefa375b57a801ddc87615aef1e9f353df28_ext.sol,ToTheMoon.burn,125,131,"REF_17(uint256) -> balanceOf[msg.sender],TMP_21(bool) = REF_17 >= _value,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_21(bool) = REF_17 >= _value
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x508404d6f5342b4a11a08e8be3f9bb2ddbdc189f_ext.sol,EtherItem23._transfer,443,467,"REF_55(uint256) -> ownershipTokenCount[_to],TMP_139(uint256) := REF_55(uint256),REF_55(-> ownershipTokenCount) = REF_55 + 1,REF_56(address) -> item23IndexToOwner[_tokenId],REF_56(address) (->item23IndexToOwner) := _to(address),TMP_140 = CONVERT 0 to address,TMP_141(bool) = _from != TMP_140,CONDITION TMP_141,REF_57(uint256) -> ownershipTokenCount[_from],TMP_142(uint256) := REF_57(uint256),REF_57(-> ownershipTokenCount) = REF_57 - 1,REF_58(address) -> item23IndexToApproved[_tokenId],item23IndexToApproved = delete REF_58 ,REF_59(address[5]) -> item23IndexToPreviousOwners[_tokenId],REF_60(address) -> REF_59[4],REF_61(address[5]) -> item23IndexToPreviousOwners[_tokenId],REF_62(address) -> REF_61[3],REF_60(address) (->item23IndexToPreviousOwners) := REF_62(address),REF_63(address[5]) -> item23IndexToPreviousOwners[_tokenId],REF_64(address) -> REF_63[3],REF_65(address[5]) -> item23IndexToPreviousOwners[_tokenId],REF_66(address) -> REF_65[2],REF_64(address) (->item23IndexToPreviousOwners) := REF_66(address),REF_67(address[5]) -> item23IndexToPreviousOwners[_tokenId],REF_68(address) -> REF_67[2],REF_69(address[5]) -> item23IndexToPreviousOwners[_tokenId],REF_70(address) -> REF_69[1],REF_68(address) (->item23IndexToPreviousOwners) := REF_70(address),REF_71(address[5]) -> item23IndexToPreviousOwners[_tokenId],REF_72(address) -> REF_71[1],REF_73(address[5]) -> item23IndexToPreviousOwners[_tokenId],REF_74(address) -> REF_73[0],REF_72(address) (->item23IndexToPreviousOwners) := REF_74(address),TMP_143 = CONVERT 0 to address,TMP_144(bool) = _from != TMP_143,CONDITION TMP_144,REF_75(address[5]) -> item23IndexToPreviousOwners[_tokenId],REF_76(address) -> REF_75[0],REF_76(address) (->item23IndexToPreviousOwners) := _from(address),REF_77(address[5]) -> item23IndexToPreviousOwners[_tokenId],REF_78(address) -> REF_77[0],TMP_145 = CONVERT this to address,REF_78(address) (->item23IndexToPreviousOwners) := TMP_145(address),Emit Transfer(_from,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownershipTokenCount[_to] ++

IRs:
REF_55(uint256) -> ownershipTokenCount[_to]
TMP_139(uint256) := REF_55(uint256)
REF_55(-> ownershipTokenCount) = REF_55 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
item23IndexToOwner[_tokenId] = _to

IRs:
REF_56(address) -> item23IndexToOwner[_tokenId]
REF_56(address) (->item23IndexToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_140 = CONVERT 0 to address
TMP_141(bool) = _from != TMP_140
CONDITION TMP_141""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownershipTokenCount[_from] --

IRs:
REF_57(uint256) -> ownershipTokenCount[_from]
TMP_142(uint256) := REF_57(uint256)
REF_57(-> ownershipTokenCount) = REF_57 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete item23IndexToApproved[_tokenId]

IRs:
REF_58(address) -> item23IndexToApproved[_tokenId]
item23IndexToApproved = delete REF_58 ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
item23IndexToPreviousOwners[_tokenId][4] = item23IndexToPreviousOwners[_tokenId][3]

IRs:
REF_59(address[5]) -> item23IndexToPreviousOwners[_tokenId]
REF_60(address) -> REF_59[4]
REF_61(address[5]) -> item23IndexToPreviousOwners[_tokenId]
REF_62(address) -> REF_61[3]
REF_60(address) (->item23IndexToPreviousOwners) := REF_62(address)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
item23IndexToPreviousOwners[_tokenId][3] = item23IndexToPreviousOwners[_tokenId][2]

IRs:
REF_63(address[5]) -> item23IndexToPreviousOwners[_tokenId]
REF_64(address) -> REF_63[3]
REF_65(address[5]) -> item23IndexToPreviousOwners[_tokenId]
REF_66(address) -> REF_65[2]
REF_64(address) (->item23IndexToPreviousOwners) := REF_66(address)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
item23IndexToPreviousOwners[_tokenId][2] = item23IndexToPreviousOwners[_tokenId][1]

IRs:
REF_67(address[5]) -> item23IndexToPreviousOwners[_tokenId]
REF_68(address) -> REF_67[2]
REF_69(address[5]) -> item23IndexToPreviousOwners[_tokenId]
REF_70(address) -> REF_69[1]
REF_68(address) (->item23IndexToPreviousOwners) := REF_70(address)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
item23IndexToPreviousOwners[_tokenId][1] = item23IndexToPreviousOwners[_tokenId][0]

IRs:
REF_71(address[5]) -> item23IndexToPreviousOwners[_tokenId]
REF_72(address) -> REF_71[1]
REF_73(address[5]) -> item23IndexToPreviousOwners[_tokenId]
REF_74(address) -> REF_73[0]
REF_72(address) (->item23IndexToPreviousOwners) := REF_74(address)""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
_from != address(0)

IRs:
TMP_143 = CONVERT 0 to address
TMP_144(bool) = _from != TMP_143
CONDITION TMP_144""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
item23IndexToPreviousOwners[_tokenId][0] = _from

IRs:
REF_75(address[5]) -> item23IndexToPreviousOwners[_tokenId]
REF_76(address) -> REF_75[0]
REF_76(address) (->item23IndexToPreviousOwners) := _from(address)""];
12->14;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
item23IndexToPreviousOwners[_tokenId][0] = address(this)

IRs:
REF_77(address[5]) -> item23IndexToPreviousOwners[_tokenId]
REF_78(address) -> REF_77[0]
TMP_145 = CONVERT this to address
REF_78(address) (->item23IndexToPreviousOwners) := TMP_145(address)""];
13->14;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
}
",0,1,0,0,"ownershipTokenCount[_to] ++;item23IndexToOwner[_tokenId] = _to;_from != address(0);ownershipTokenCount[_from] --;;delete item23IndexToApproved[_tokenId];item23IndexToPreviousOwners[_tokenId][4] = item23IndexToPreviousOwners[_tokenId][3];item23IndexToPreviousOwners[_tokenId][3] = item23IndexToPreviousOwners[_tokenId][2];item23IndexToPreviousOwners[_tokenId][2] = item23IndexToPreviousOwners[_tokenId][1];item23IndexToPreviousOwners[_tokenId][1] = item23IndexToPreviousOwners[_tokenId][0];_from != address(0);item23IndexToPreviousOwners[_tokenId][0] = _from;item23IndexToPreviousOwners[_tokenId][0] = address(this);;Transfer(_from,_to,_tokenId)"
./0x1c5f43710a1776b0ea7191b7ead75d4b98d69858_ext.sol,PskERC20._transfer,191,210,"REF_22(uint256) -> lockedUntil[_from],TMP_263(bool) = REF_22 == 0,REF_23(uint256) -> lockedUntil[_from],TMP_264(bool) = REF_23 != 0,REF_24(uint256) -> lockedUntil[_from],TMP_265(bool) = block.timestamp >= REF_24,TMP_266(bool) = TMP_264 && TMP_265,TMP_267(bool) = TMP_263 || TMP_266,TMP_268(None) = SOLIDITY_CALL assert(bool)(TMP_267),TMP_269(bool) = _to != 0,TMP_270(None) = SOLIDITY_CALL require(bool)(TMP_269),REF_25(uint256) -> balanceOf[_from],TMP_271(bool) = REF_25 >= _value,TMP_272(None) = SOLIDITY_CALL require(bool)(TMP_271),REF_26(uint256) -> balanceOf[_to],TMP_273(uint256) = REF_26 + _value,REF_27(uint256) -> balanceOf[_to],TMP_274(bool) = TMP_273 >= REF_27,TMP_275(None) = SOLIDITY_CALL require(bool)(TMP_274),REF_28(uint256) -> balanceOf[_from],REF_29(uint256) -> balanceOf[_to],TMP_276(uint256) = REF_28 + REF_29,previousBalances(uint256) := TMP_276(uint256),REF_30(uint256) -> balanceOf[_from],REF_30(-> balanceOf) = REF_30 - _value,REF_31(uint256) -> balanceOf[_to],REF_31(-> balanceOf) = REF_31 + _value,Emit Transfer(_from,_to,_value),REF_32(uint256) -> balanceOf[_from],REF_33(uint256) -> balanceOf[_to],TMP_278(uint256) = REF_32 + REF_33,TMP_279(bool) = TMP_278 == previousBalances,TMP_280(None) = SOLIDITY_CALL assert(bool)(TMP_279)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(lockedUntil[_from] == 0 || (lockedUntil[_from] != 0 && block.timestamp >= lockedUntil[_from]))

IRs:
REF_22(uint256) -> lockedUntil[_from]
TMP_263(bool) = REF_22 == 0
REF_23(uint256) -> lockedUntil[_from]
TMP_264(bool) = REF_23 != 0
REF_24(uint256) -> lockedUntil[_from]
TMP_265(bool) = block.timestamp >= REF_24
TMP_266(bool) = TMP_264 && TMP_265
TMP_267(bool) = TMP_263 || TMP_266
TMP_268(None) = SOLIDITY_CALL assert(bool)(TMP_267)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_269(bool) = _to != 0
TMP_270(None) = SOLIDITY_CALL require(bool)(TMP_269)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_25(uint256) -> balanceOf[_from]
TMP_271(bool) = REF_25 >= _value
TMP_272(None) = SOLIDITY_CALL require(bool)(TMP_271)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_26(uint256) -> balanceOf[_to]
TMP_273(uint256) = REF_26 + _value
REF_27(uint256) -> balanceOf[_to]
TMP_274(bool) = TMP_273 >= REF_27
TMP_275(None) = SOLIDITY_CALL require(bool)(TMP_274)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_28(uint256) -> balanceOf[_from]
REF_29(uint256) -> balanceOf[_to]
TMP_276(uint256) = REF_28 + REF_29
previousBalances(uint256) := TMP_276(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_30(uint256) -> balanceOf[_from]
REF_30(-> balanceOf) = REF_30 - _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_31(uint256) -> balanceOf[_to]
REF_31(-> balanceOf) = REF_31 + _value""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_32(uint256) -> balanceOf[_from]
REF_33(uint256) -> balanceOf[_to]
TMP_278(uint256) = REF_32 + REF_33
TMP_279(bool) = TMP_278 == previousBalances
TMP_280(None) = SOLIDITY_CALL assert(bool)(TMP_279)""];
}
",0,1,0,0,"assert(bool)(lockedUntil[_from] == 0 || (lockedUntil[_from] != 0 && block.timestamp >= lockedUntil[_from]));require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xc3c412b97dc3355f1bd060223e75fb047c869197_ext.sol,HngCoin.burnFrom,186,194,"REF_19(uint256) -> balanceOf[_from],TMP_34(bool) = REF_19 >= _value,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_36(bool) = _value <= REF_21,TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_34(bool) = REF_19 >= _value
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_36(bool) = _value <= REF_21
TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xe3d424dffecc3759fcc997f5eba2a01a58585405_ext.sol,ERC20Standard.transferFrom,66,72,"REF_5(uint256) -> balances[_from],TMP_9(bool) = REF_5 >= _value,REF_6(mapping(address => uint256)) -> allowed[_from],REF_7(uint256) -> REF_6[msg.sender],TMP_10(bool) = REF_7 >= _value,TMP_11(bool) = TMP_9 && TMP_10,TMP_12(bool) = _value > 0,TMP_13(bool) = TMP_11 && TMP_12,TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13),REF_8(uint256) -> balances[_to],REF_8(-> balances) = REF_8 + _value,REF_9(uint256) -> balances[_from],REF_9(-> balances) = REF_9 - _value,REF_10(mapping(address => uint256)) -> allowed[_from],REF_11(uint256) -> REF_10[msg.sender],REF_11(-> allowed) = REF_11 - _value,Emit Transfer(_from,_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0)

IRs:
REF_5(uint256) -> balances[_from]
TMP_9(bool) = REF_5 >= _value
REF_6(mapping(address => uint256)) -> allowed[_from]
REF_7(uint256) -> REF_6[msg.sender]
TMP_10(bool) = REF_7 >= _value
TMP_11(bool) = TMP_9 && TMP_10
TMP_12(bool) = _value > 0
TMP_13(bool) = TMP_11 && TMP_12
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_8(uint256) -> balances[_to]
REF_8(-> balances) = REF_8 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_9(uint256) -> balances[_from]
REF_9(-> balances) = REF_9 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_10(mapping(address => uint256)) -> allowed[_from]
REF_11(uint256) -> REF_10[msg.sender]
REF_11(-> allowed) = REF_11 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
}
",0,1,0,0,"require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);balances[_to] += _value;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value)"
./0x1fd1f34a7476fa7d7b2187c8bd255e39e78271e6_ext.sol,PAXPAGO.mintToken,209,214,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x35fd00d47202b1b2158dba75e7cc8f71b068c256_ext.sol,WhiteList.addToWhiteListMultiple,172,183,"i(uint256) := 0(uint256),REF_5 -> LENGTH _users,TMP_51(bool) = i < REF_5,CONDITION TMP_51,REF_6(address) -> _users[i],REF_7(bool) -> whiteList[REF_6],TMP_52(bool) = REF_7 != True,CONDITION TMP_52,REF_8(address) -> _users[i],REF_9(bool) -> whiteList[REF_8],REF_9(bool) (->whiteList) := True(bool),TMP_53(uint256) := totalWhiteListed(uint256),totalWhiteListed(uint256) = totalWhiteListed + 1,i(uint256) = i + 1,Emit LogWhiteListedMultiple(totalWhiteListed),RETURN True,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
2->10;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _users.length

IRs:
REF_5 -> LENGTH _users
TMP_51(bool) = i < REF_5
CONDITION TMP_51""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
whiteList[_users[i]] != true

IRs:
REF_6(address) -> _users[i]
REF_7(bool) -> whiteList[REF_6]
TMP_52(bool) = REF_7 != True
CONDITION TMP_52""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
whiteList[_users[i]] = true

IRs:
REF_8(address) -> _users[i]
REF_9(bool) -> whiteList[REF_8]
REF_9(bool) (->whiteList) := True(bool)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
totalWhiteListed ++

IRs:
TMP_53(uint256) := totalWhiteListed(uint256)
totalWhiteListed(uint256) = totalWhiteListed + 1""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1""];
9->4;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
LogWhiteListedMultiple(totalWhiteListed)

IRs:
Emit LogWhiteListedMultiple(totalWhiteListed)""];
10->11;
11[label=""Node Type: RETURN 11

EXPRESSION:
true

IRs:
RETURN True""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
12->3;
}
",0,1,0,0,onlyOwner();;i < _users.length;;LogWhiteListedMultiple(totalWhiteListed);i = 0;whiteList[_users[i]] != true;whiteList[_users[i]] = true;;totalWhiteListed ++;++ i;true
./0xc094367b4c79564b6c8b4218f84dea835b2c2dd0_ext.sol,TikiMadness.priceOf,304,318,"REF_48(TikiMadness.TikiMask) -> tikiMasks[_tokenId],tiki(TikiMadness.TikiMask) := REF_48(TikiMadness.TikiMask),REF_49(uint256) -> tiki.saleTime,TMP_63(uint256) = now - REF_49,secondsPassed(uint256) := TMP_63(uint256),REF_50(uint256) -> tiki.fallDuration,TMP_64(bool) = secondsPassed >= REF_50,REF_51(uint256) -> tiki.highPrice,REF_52(uint256) -> tiki.basePrice,TMP_65(bool) = REF_51 == REF_52,TMP_66(bool) = TMP_64 || TMP_65,CONDITION TMP_66,REF_53(uint256) -> tiki.basePrice,RETURN REF_53,REF_54(uint256) -> tiki.highPrice,REF_55(uint256) -> tiki.basePrice,TMP_67(uint256) = REF_54 - REF_55,totalPriceChange(uint256) := TMP_67(uint256),TMP_68(uint256) = totalPriceChange * secondsPassed,REF_56(uint256) -> tiki.fallDuration,TMP_69(uint256) = TMP_68 / REF_56,currentPriceChange(uint256) := TMP_69(uint256),REF_57(uint256) -> tiki.highPrice,TMP_70(uint256) = REF_57 - currentPriceChange,currentPrice(uint256) := TMP_70(uint256),RETURN currentPrice,RETURN price","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tiki = tikiMasks[_tokenId]

IRs:
REF_48(TikiMadness.TikiMask) -> tikiMasks[_tokenId]
tiki(TikiMadness.TikiMask) := REF_48(TikiMadness.TikiMask)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
secondsPassed = now - tiki.saleTime

IRs:
REF_49(uint256) -> tiki.saleTime
TMP_63(uint256) = now - REF_49
secondsPassed(uint256) := TMP_63(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
secondsPassed >= tiki.fallDuration || tiki.highPrice == tiki.basePrice

IRs:
REF_50(uint256) -> tiki.fallDuration
TMP_64(bool) = secondsPassed >= REF_50
REF_51(uint256) -> tiki.highPrice
REF_52(uint256) -> tiki.basePrice
TMP_65(bool) = REF_51 == REF_52
TMP_66(bool) = TMP_64 || TMP_65
CONDITION TMP_66""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: RETURN 4

EXPRESSION:
tiki.basePrice

IRs:
REF_53(uint256) -> tiki.basePrice
RETURN REF_53""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
totalPriceChange = tiki.highPrice - tiki.basePrice

IRs:
REF_54(uint256) -> tiki.highPrice
REF_55(uint256) -> tiki.basePrice
TMP_67(uint256) = REF_54 - REF_55
totalPriceChange(uint256) := TMP_67(uint256)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
currentPriceChange = totalPriceChange * secondsPassed / tiki.fallDuration

IRs:
TMP_68(uint256) = totalPriceChange * secondsPassed
REF_56(uint256) -> tiki.fallDuration
TMP_69(uint256) = TMP_68 / REF_56
currentPriceChange(uint256) := TMP_69(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
currentPrice = tiki.highPrice - currentPriceChange

IRs:
REF_57(uint256) -> tiki.highPrice
TMP_70(uint256) = REF_57 - currentPriceChange
currentPrice(uint256) := TMP_70(uint256)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
currentPrice

IRs:
RETURN currentPrice""];
10[label=""Node Type: RETURN 10

EXPRESSION:
price

IRs:
RETURN price""];
}
",0,1,0,0,tiki = tikiMasks[_tokenId];secondsPassed = now - tiki.saleTime;secondsPassed >= tiki.fallDuration || tiki.highPrice == tiki.basePrice;tiki.basePrice;;totalPriceChange = tiki.highPrice - tiki.basePrice;currentPriceChange = totalPriceChange * secondsPassed / tiki.fallDuration;currentPrice = tiki.highPrice - currentPriceChange;currentPrice;price
./0x6ccf98a13ed658678bfe9a319d4454e5f170114d_ext.sol,STVCOIN.burn,128,134,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x83a611488d53cfcda749c2239c1516ab1c514fe7_ext.sol,PICC_301201.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x70a128fe6c4f654f52fc799f250506bed550945e_ext.sol,CpublicGold.totalSupply,102,104,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x39f968b4b8b367ce20f5aefc852591f7eada4b3e_ext.sol,Administration.approveAndCall,192,197,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xd83a825384a252f57b1ef7d617518f2099ac8eb5_ext.sol,BteApplication.approveAndCall,197,202,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x0f6029ebde2ecd9ab4d60dd5d0a297e9e59bf77a_ext.sol,ADXRegistry.getAccountItems,260,268,"REF_69(ADXRegistry.Account) -> accounts[_acc],acc(ADXRegistry.Account) := REF_69(ADXRegistry.Account),REF_70(address) -> acc.addr,TMP_68(bool) = REF_70 != 0,TMP_69(None) = SOLIDITY_CALL require(bool)(TMP_68),REF_71(mapping(uint256 => uint256[])) -> acc.items,REF_72(uint256[]) -> REF_71[_type],RETURN REF_72","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
acc = accounts[_acc]

IRs:
REF_69(ADXRegistry.Account) -> accounts[_acc]
acc(ADXRegistry.Account) := REF_69(ADXRegistry.Account)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(acc.addr != 0)

IRs:
REF_70(address) -> acc.addr
TMP_68(bool) = REF_70 != 0
TMP_69(None) = SOLIDITY_CALL require(bool)(TMP_68)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
acc.items[_type]

IRs:
REF_71(mapping(uint256 => uint256[])) -> acc.items
REF_72(uint256[]) -> REF_71[_type]
RETURN REF_72""];
}
",0,1,0,0,acc = accounts[_acc];require(bool)(acc.addr != 0);acc.items[_type]
./0x75163374524bac8ca983bea408a0e3f22a1cb25b_ext.sol,BannerDesk.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x4d74acfb21f3be9d98263fc0b721840be958ef9d_ext.sol,DomenoToken.totalSupply,116,118,"TMP_29 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_29],TMP_30(uint256) = _totalSupply - REF_1,RETURN TMP_30","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_29 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_29]
TMP_30(uint256) = _totalSupply - REF_1
RETURN TMP_30""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x0e8d6b471e332f140e7d9dbb99e5e3822f728da6_ext.sol,MultiOwnable.setOwners,32,36,"TMP_0(bool) = msg.sender == manager,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),INTERNAL_CALL, MultiOwnable._setOwners(address[])(_owners)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == manager)

IRs:
TMP_0(bool) = msg.sender == manager
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_setOwners(_owners)

IRs:
INTERNAL_CALL, MultiOwnable._setOwners(address[])(_owners)""];
}
",0,1,0,0,require(bool)(msg.sender == manager);_setOwners(_owners)
./0x26b5962250b779ab0f33970738a46fcfb00a70b9_ext.sol,NewLottery.AddTicket,90,107,"TMP_19(bool) = msg.value == ticketPrice,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),TMP_21(bool) = numtickets < maxTickets,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),lastTicketTime(uint256) := now(uint256),totalBounty(uint256) = totalBounty + ticketPrice,TMP_23(bool) = numtickets == maxTickets,success(bool) := TMP_23(bool),Emit NewTicket(msg.sender,success),CONDITION success,INTERNAL_CALL, NewLottery.PayWinner(address)(msg.sender)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value == ticketPrice)

IRs:
TMP_19(bool) = msg.value == ticketPrice
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(numtickets < maxTickets)

IRs:
TMP_21(bool) = numtickets < maxTickets
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
lastTicketTime = now

IRs:
lastTicketTime(uint256) := now(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
totalBounty += ticketPrice

IRs:
totalBounty(uint256) = totalBounty + ticketPrice""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
success = numtickets == maxTickets

IRs:
TMP_23(bool) = numtickets == maxTickets
success(bool) := TMP_23(bool)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
NewTicket(msg.sender,success)

IRs:
Emit NewTicket(msg.sender,success)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
success

IRs:
CONDITION success""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
PayWinner(msg.sender)

IRs:
INTERNAL_CALL, NewLottery.PayWinner(address)(msg.sender)""];
8->9;
9[label=""Node Type: END_IF 9
""];
}
",0,1,0,0,"require(bool)(msg.value == ticketPrice);require(bool)(numtickets < maxTickets);lastTicketTime = now;totalBounty += ticketPrice;success = numtickets == maxTickets;NewTicket(msg.sender,success);success;PayWinner(msg.sender);"
./0x6be9dbfca46651a6a2726b4b695edfb1cf0fbfb0_ext.sol,CCOIN.calculateNoOfTokensToSend,624,638,"TMP_172(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', 'multiplier'] ,TMP_173(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_172', 'tokenPriceWei'] ,tokenAmount(uint256) := TMP_173(uint256),TMP_174(uint256) = startBlock + firstPeriod,TMP_175(bool) = block.number <= TMP_174,CONDITION TMP_175,TMP_176(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenAmount', 'firstBonus'] ,TMP_177(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_176', '100'] ,TMP_178(uint256) = tokenAmount + TMP_177,RETURN TMP_178,TMP_179(uint256) = startBlock + secondPeriod,TMP_180(bool) = block.number <= TMP_179,CONDITION TMP_180,TMP_181(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenAmount', 'secondBonus'] ,TMP_182(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_181', '100'] ,TMP_183(uint256) = tokenAmount + TMP_182,RETURN TMP_183,TMP_184(uint256) = startBlock + thirdPeriod,TMP_185(bool) = block.number <= TMP_184,CONDITION TMP_185,TMP_186(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenAmount', 'thirdBonus'] ,TMP_187(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_186', '100'] ,TMP_188(uint256) = tokenAmount + TMP_187,RETURN TMP_188,TMP_189(uint256) = startBlock + fourthPeriod,TMP_190(bool) = block.number <= TMP_189,CONDITION TMP_190,TMP_191(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenAmount', 'fourthBonus'] ,TMP_192(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_191', '100'] ,TMP_193(uint256) = tokenAmount + TMP_192,RETURN TMP_193,TMP_194(uint256) = startBlock + fifthPeriod,TMP_195(bool) = block.number <= TMP_194,CONDITION TMP_195,TMP_196(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenAmount', 'fifthBonus'] ,TMP_197(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_196', '100'] ,TMP_198(uint256) = tokenAmount + TMP_197,RETURN TMP_198,RETURN tokenAmount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokenAmount = SafeMath.div(SafeMath.mul(msg.value,multiplier),tokenPriceWei)

IRs:
TMP_172(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', 'multiplier'] 
TMP_173(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_172', 'tokenPriceWei'] 
tokenAmount(uint256) := TMP_173(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
block.number <= startBlock + firstPeriod

IRs:
TMP_174(uint256) = startBlock + firstPeriod
TMP_175(bool) = block.number <= TMP_174
CONDITION TMP_175""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3

EXPRESSION:
tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount,firstBonus),100)

IRs:
TMP_176(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenAmount', 'firstBonus'] 
TMP_177(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_176', '100'] 
TMP_178(uint256) = tokenAmount + TMP_177
RETURN TMP_178""];
4[label=""Node Type: IF 4

EXPRESSION:
block.number <= startBlock + secondPeriod

IRs:
TMP_179(uint256) = startBlock + secondPeriod
TMP_180(bool) = block.number <= TMP_179
CONDITION TMP_180""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: RETURN 5

EXPRESSION:
tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount,secondBonus),100)

IRs:
TMP_181(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenAmount', 'secondBonus'] 
TMP_182(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_181', '100'] 
TMP_183(uint256) = tokenAmount + TMP_182
RETURN TMP_183""];
6[label=""Node Type: IF 6

EXPRESSION:
block.number <= startBlock + thirdPeriod

IRs:
TMP_184(uint256) = startBlock + thirdPeriod
TMP_185(bool) = block.number <= TMP_184
CONDITION TMP_185""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: RETURN 7

EXPRESSION:
tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount,thirdBonus),100)

IRs:
TMP_186(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenAmount', 'thirdBonus'] 
TMP_187(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_186', '100'] 
TMP_188(uint256) = tokenAmount + TMP_187
RETURN TMP_188""];
8[label=""Node Type: IF 8

EXPRESSION:
block.number <= startBlock + fourthPeriod

IRs:
TMP_189(uint256) = startBlock + fourthPeriod
TMP_190(bool) = block.number <= TMP_189
CONDITION TMP_190""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount,fourthBonus),100)

IRs:
TMP_191(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenAmount', 'fourthBonus'] 
TMP_192(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_191', '100'] 
TMP_193(uint256) = tokenAmount + TMP_192
RETURN TMP_193""];
10[label=""Node Type: IF 10

EXPRESSION:
block.number <= startBlock + fifthPeriod

IRs:
TMP_194(uint256) = startBlock + fifthPeriod
TMP_195(bool) = block.number <= TMP_194
CONDITION TMP_195""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: RETURN 11

EXPRESSION:
tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount,fifthBonus),100)

IRs:
TMP_196(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenAmount', 'fifthBonus'] 
TMP_197(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_196', '100'] 
TMP_198(uint256) = tokenAmount + TMP_197
RETURN TMP_198""];
12[label=""Node Type: RETURN 12

EXPRESSION:
tokenAmount

IRs:
RETURN tokenAmount""];
}
",0,1,0,0,"tokenAmount = SafeMath.div(SafeMath.mul(msg.value,multiplier),tokenPriceWei);block.number <= startBlock + firstPeriod;tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount,firstBonus),100);block.number <= startBlock + secondPeriod;tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount,secondBonus),100);block.number <= startBlock + thirdPeriod;tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount,thirdBonus),100);block.number <= startBlock + fourthPeriod;tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount,fourthBonus),100);block.number <= startBlock + fifthPeriod;tokenAmount + SafeMath.div(SafeMath.mul(tokenAmount,fifthBonus),100);tokenAmount"
./0x6c26dab04c8f2bb07e60f205118e36850fe90981_ext.sol,PoWMLottery.openLottery,84,89,"TMP_29(bool) = isLotteryOpen == False,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),TMP_31(uint256) := current_round(uint256),current_round(uint256) = current_round + 1,isLotteryOpen(bool) := True(bool),num_tickets_current_round(uint256) := 0(uint256),MODIFIER_CALL, PoWMLottery.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isLotteryOpen == false)

IRs:
TMP_29(bool) = isLotteryOpen == False
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
current_round ++

IRs:
TMP_31(uint256) := current_round(uint256)
current_round(uint256) = current_round + 1""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
isLotteryOpen = true

IRs:
isLotteryOpen(bool) := True(bool)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
num_tickets_current_round = 0

IRs:
num_tickets_current_round(uint256) := 0(uint256)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, PoWMLottery.onlyOwner()()""];
5->1;
}
",0,1,0,0,onlyOwner();require(bool)(isLotteryOpen == false);current_round ++;isLotteryOpen = true;num_tickets_current_round = 0
./0xed04927a3849fc9db3f3341a17b7d844a6c551a8_ext.sol,CrowdInvestment.addPersonalCap,35,38,"TMP_9(bool) = msg.sender == creator,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_3(uint256) -> additionalCaps[investor],REF_3(-> additionalCaps) = REF_3 + additionalCap","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == creator)

IRs:
TMP_9(bool) = msg.sender == creator
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
additionalCaps[investor] += additionalCap

IRs:
REF_3(uint256) -> additionalCaps[investor]
REF_3(-> additionalCaps) = REF_3 + additionalCap""];
}
",0,1,0,0,require(bool)(msg.sender == creator);additionalCaps[investor] += additionalCap
./0x47c69e05d3d32658cb01cee954af9bb7885b094a_ext.sol,VICETOKEN_ICO_IS_FAKE.burnFrom,150,158,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x0078bd770f55a3c6b8f3b3d2a0c21fcac8a92394_ext.sol,SetLibrary.remove,40,71,"REF_14(mapping(uint256 => SetLibrary.ArrayIndexAndExistsFlag)) -> self.valuesMapping,REF_15(SetLibrary.ArrayIndexAndExistsFlag) -> REF_14[value],REF_16(bool) -> REF_15.exists,TMP_5(bool) = REF_16 == False,CONDITION TMP_5,RETURN False,REF_17(mapping(uint256 => SetLibrary.ArrayIndexAndExistsFlag)) -> self.valuesMapping,REF_18(SetLibrary.ArrayIndexAndExistsFlag) -> REF_17[value],REF_19(bool) -> REF_18.exists,REF_19(bool) (->self) := False(bool),REF_20(mapping(uint256 => SetLibrary.ArrayIndexAndExistsFlag)) -> self.valuesMapping,REF_21(SetLibrary.ArrayIndexAndExistsFlag) -> REF_20[value],REF_22(uint256) -> REF_21.index,REF_23(uint256[]) -> self.values,REF_24 -> LENGTH REF_23,TMP_6(uint256) = REF_24 - 1,TMP_7(bool) = REF_22 < TMP_6,CONDITION TMP_7,REF_25(uint256[]) -> self.values,REF_26(mapping(uint256 => SetLibrary.ArrayIndexAndExistsFlag)) -> self.valuesMapping,REF_27(SetLibrary.ArrayIndexAndExistsFlag) -> REF_26[value],REF_28(uint256) -> REF_27.index,REF_29(uint256) -> REF_25[REF_28],REF_30(uint256[]) -> self.values,REF_31(uint256[]) -> self.values,REF_32 -> LENGTH REF_31,TMP_8(uint256) = REF_32 - 1,REF_33(uint256) -> REF_30[TMP_8],REF_29(uint256) (->self) := REF_33(uint256),REF_34(uint256[]) -> self.values,REF_35 -> LENGTH REF_34,TMP_9(uint256) := REF_35(uint256),REF_35(-> self) = REF_35 - 1,REF_36(mapping(uint256 => SetLibrary.ArrayIndexAndExistsFlag)) -> self.valuesMapping,REF_37(SetLibrary.ArrayIndexAndExistsFlag) -> REF_36[value],REF_36 = delete REF_37 ,RETURN True,RETURN removed","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
self.valuesMapping[value].exists == false

IRs:
REF_14(mapping(uint256 => SetLibrary.ArrayIndexAndExistsFlag)) -> self.valuesMapping
REF_15(SetLibrary.ArrayIndexAndExistsFlag) -> REF_14[value]
REF_16(bool) -> REF_15.exists
TMP_5(bool) = REF_16 == False
CONDITION TMP_5""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
self.valuesMapping[value].exists = false

IRs:
REF_17(mapping(uint256 => SetLibrary.ArrayIndexAndExistsFlag)) -> self.valuesMapping
REF_18(SetLibrary.ArrayIndexAndExistsFlag) -> REF_17[value]
REF_19(bool) -> REF_18.exists
REF_19(bool) (->self) := False(bool)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
self.valuesMapping[value].index < self.values.length - 1

IRs:
REF_20(mapping(uint256 => SetLibrary.ArrayIndexAndExistsFlag)) -> self.valuesMapping
REF_21(SetLibrary.ArrayIndexAndExistsFlag) -> REF_20[value]
REF_22(uint256) -> REF_21.index
REF_23(uint256[]) -> self.values
REF_24 -> LENGTH REF_23
TMP_6(uint256) = REF_24 - 1
TMP_7(bool) = REF_22 < TMP_6
CONDITION TMP_7""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
self.values[self.valuesMapping[value].index] = self.values[self.values.length - 1]

IRs:
REF_25(uint256[]) -> self.values
REF_26(mapping(uint256 => SetLibrary.ArrayIndexAndExistsFlag)) -> self.valuesMapping
REF_27(SetLibrary.ArrayIndexAndExistsFlag) -> REF_26[value]
REF_28(uint256) -> REF_27.index
REF_29(uint256) -> REF_25[REF_28]
REF_30(uint256[]) -> self.values
REF_31(uint256[]) -> self.values
REF_32 -> LENGTH REF_31
TMP_8(uint256) = REF_32 - 1
REF_33(uint256) -> REF_30[TMP_8]
REF_29(uint256) (->self) := REF_33(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
self.values.length --

IRs:
REF_34(uint256[]) -> self.values
REF_35 -> LENGTH REF_34
TMP_9(uint256) := REF_35(uint256)
REF_35(-> self) = REF_35 - 1""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
delete self.valuesMapping[value]

IRs:
REF_36(mapping(uint256 => SetLibrary.ArrayIndexAndExistsFlag)) -> self.valuesMapping
REF_37(SetLibrary.ArrayIndexAndExistsFlag) -> REF_36[value]
REF_36 = delete REF_37 ""];
9->10;
10[label=""Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True""];
11[label=""Node Type: RETURN 11

EXPRESSION:
removed

IRs:
RETURN removed""];
}
",0,1,0,0,self.valuesMapping[value].exists == false;false;;self.valuesMapping[value].exists = false;self.valuesMapping[value].index < self.values.length - 1;self.values[self.valuesMapping[value].index] = self.values[self.values.length - 1];;self.values.length --;delete self.valuesMapping[value];true;removed
./0xa6237a177c4e0fc24818649bca7ce5ab44933a00_ext.sol,TokenERC20.approveAndCall,123,131,"TMP_46 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_46(tokenRecipient),TMP_47(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value),CONDITION TMP_47,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_46 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_46(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_47(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value)
CONDITION TMP_47""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x2019763bd984cce011cd9b55b0e700abe42fa6c7_ext.sol,ClassSize.voteYes,19,22,"votesYes(uint16) = votesYes + 1,Emit VoteYes(note)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
votesYes += 1

IRs:
votesYes(uint16) = votesYes + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
VoteYes(note)

IRs:
Emit VoteYes(note)""];
}
",0,1,0,0,votesYes += 1;VoteYes(note)
./0x0d8d9ffbed227c08b1a17ac4dd9eba38c153375c_ext.sol,BlockchainId._updateCompanies,91,96,"REF_8 -> LENGTH companyIds,REF_9 -> LENGTH merkleRoots,TMP_30(bool) = REF_8 == REF_9,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),i(uint256) := 0(uint256),REF_10 -> LENGTH companyIds,TMP_32(bool) = i < REF_10,CONDITION TMP_32,REF_11(bytes32) -> companyIds[i],REF_12(bytes32) -> merkleRoots[i],INTERNAL_CALL, BlockchainId._updateCompany(bytes32,bytes32)(REF_11,REF_12),TMP_34(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(companyIds.length == merkleRoots.length)

IRs:
REF_8 -> LENGTH companyIds
REF_9 -> LENGTH merkleRoots
TMP_30(bool) = REF_8 == REF_9
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < companyIds.length

IRs:
REF_10 -> LENGTH companyIds
TMP_32(bool) = i < REF_10
CONDITION TMP_32""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
_updateCompany(companyIds[i],merkleRoots[i])

IRs:
REF_11(bytes32) -> companyIds[i]
REF_12(bytes32) -> merkleRoots[i]
INTERNAL_CALL, BlockchainId._updateCompany(bytes32,bytes32)(REF_11,REF_12)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_34(uint256) := i(uint256)
i(uint256) = i + 1""];
7->5;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
8->1;
}
",0,1,0,0,"onlyOwner();require(bool)(companyIds.length == merkleRoots.length);i = 0;;i < companyIds.length;;_updateCompany(companyIds[i],merkleRoots[i]);i ++"
./0x2d1fbbd6f82738ca00b09024a81e12a8816a22bc_ext.sol,C3_TokenCreate.mintToken,203,208,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x5cafe6c85ea7c3b1bb62ca5254fae636ba8ae616_ext.sol,StandardToken.transferFrom,125,135,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x6b963f7b38980f5fbbd129fe98059eb2144076a7_ext.sol,BLV.burn,124,130,"REF_17(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_17 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_17 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x5b29a6277c996b477d6632e60eef41268311ce1c_ext.sol,Dragon.burn,146,152,"REF_24(uint256) -> balanceOf[msg.sender],TMP_20(bool) = REF_24 < _value,CONDITION TMP_20,REF_25(uint256) -> balanceOf[msg.sender],REF_25(-> balanceOf) = REF_25 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balanceOf[msg.sender] < _value

IRs:
REF_24(uint256) -> balanceOf[msg.sender]
TMP_20(bool) = REF_24 < _value
CONDITION TMP_20""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_25(uint256) -> balanceOf[msg.sender]
REF_25(-> balanceOf) = REF_25 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balanceOf[msg.sender] < _value;;;balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x4bd70556ae3f8a6ec6c4080a0c327b24325438f3_ext.sol,HxroTokenContract.burn,133,139,"REF_17(uint256) -> balanceOf[msg.sender],TMP_30(bool) = REF_17 >= _value,TMP_31(None) = SOLIDITY_CALL require(bool,string)(TMP_30,Balance Insufficient),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(balanceOf[msg.sender] >= _value,Balance Insufficient)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_30(bool) = REF_17 >= _value
TMP_31(None) = SOLIDITY_CALL require(bool,string)(TMP_30,Balance Insufficient)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool,string)(balanceOf[msg.sender] >= _value,Balance Insufficient);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x201e7cd92e03ea87c51d3e22974243ed7a26a1cb_ext.sol,token.burn,50,56,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xc53a9f4dca6a6e514ff192496d6a30e4b5cd6bc2_ext.sol,TokenERC20.approveAndCall,74,82,"TMP_20 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_20(tokenRecipient),TMP_21(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value),CONDITION TMP_21,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_20 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_20(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_21(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value)
CONDITION TMP_21""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x55bec5649fbb5f5be831ee5b0f7a8a8f02b25144_ext.sol,PuzzleGift.GetHash,7,7,"TMP_0(bytes32) = SOLIDITY_CALL sha3()(pass),RETURN TMP_0","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
sha3()(pass)

IRs:
TMP_0(bytes32) = SOLIDITY_CALL sha3()(pass)
RETURN TMP_0""];
}
",0,1,0,0,sha3()(pass)
./0x568a693e1094b1e51e8053b2fc642da7161603f5_ext.sol,BitConnect.dividendsOf,481,487,"REF_37(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_66(uint256) = profitPerShare_ * REF_37,TMP_67 = CONVERT TMP_66 to int256,REF_38(int256) -> payoutsTo_[_customerAddress],TMP_68(int256) = TMP_67 - REF_38,TMP_69 = CONVERT TMP_68 to uint256,TMP_70(uint256) = TMP_69 / magnitude,RETURN TMP_70","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_37(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_66(uint256) = profitPerShare_ * REF_37
TMP_67 = CONVERT TMP_66 to int256
REF_38(int256) -> payoutsTo_[_customerAddress]
TMP_68(int256) = TMP_67 - REF_38
TMP_69 = CONVERT TMP_68 to uint256
TMP_70(uint256) = TMP_69 / magnitude
RETURN TMP_70""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0xc654928ecf5f984ef72c806ec9b6e2d213c90818_ext.sol,TokenERC20.burn,150,156,"REF_17(uint256) -> balanceOf[msg.sender],TMP_26(bool) = REF_17 >= _value,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_26(bool) = REF_17 >= _value
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xc62c957c60bd4f632f6fb896ec42057b1eccc547_ext.sol,ECN.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x6c6b3fd123d575cbeb1670a1fcc9c8fd603357a3_ext.sol,dapBetting.getBidsNum,201,203,"REF_174(dapBetting.betEvent[]) -> betEvents[creator],REF_175(dapBetting.betEvent) -> REF_174[eventId],REF_176(dapBetting.bid[]) -> REF_175.bids,REF_177 -> LENGTH REF_176,RETURN REF_177","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
betEvents[creator][eventId].bids.length

IRs:
REF_174(dapBetting.betEvent[]) -> betEvents[creator]
REF_175(dapBetting.betEvent) -> REF_174[eventId]
REF_176(dapBetting.bid[]) -> REF_175.bids
REF_177 -> LENGTH REF_176
RETURN REF_177""];
}
",0,1,0,0,betEvents[creator][eventId].bids.length
./0x4b7b633c44fe54cc2c58378e98aaa301ef8522b8_ext.sol,DragonLifeChain.burnFrom,125,133,"REF_16(uint256) -> balanceOf[_from],TMP_71(bool) = REF_16 >= _value,TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71),REF_17(mapping(address => uint256)) -> allowance[_from],REF_18(uint256) -> REF_17[msg.sender],TMP_73(bool) = _value <= REF_18,TMP_74(None) = SOLIDITY_CALL require(bool)(TMP_73),REF_19(uint256) -> balanceOf[_from],REF_19(-> balanceOf) = REF_19 - _value,REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],REF_21(-> allowance) = REF_21 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,MODIFIER_CALL, DragonLifeChain.onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_16(uint256) -> balanceOf[_from]
TMP_71(bool) = REF_16 >= _value
TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_17(mapping(address => uint256)) -> allowance[_from]
REF_18(uint256) -> REF_17[msg.sender]
TMP_73(bool) = _value <= REF_18
TMP_74(None) = SOLIDITY_CALL require(bool)(TMP_73)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_19(uint256) -> balanceOf[_from]
REF_19(-> balanceOf) = REF_19 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
REF_21(-> allowance) = REF_21 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, DragonLifeChain.onlyOwner()()""];
8->1;
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"onlyOwner();require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x361cef27a967e3fa2d8fc117b3f2cfe2a09bbc02_ext.sol,TokenERC20.burnFrom,126,134,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xdda784ce15449948520580cacb229717cd7ad261_ext.sol,Laker_Show.withdraw,13,21,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2),TMP_4(bool) = keyHash == TMP_3,CONDITION TMP_4,TMP_5(bool) = msg.value > 1000000000000000000,CONDITION TMP_5,TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),Transfer dest:msg.sender value:TMP_7","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
keyHash == keccak256()(abi.encodePacked(key))

IRs:
TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2)
TMP_4(bool) = keyHash == TMP_3
CONDITION TMP_4""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
msg.value > 1000000000000000000

IRs:
TMP_5(bool) = msg.value > 1000000000000000000
CONDITION TMP_5""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
Transfer dest:msg.sender value:TMP_7""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,1,0,0,require(bool)(msg.sender == tx.origin);keyHash == keccak256()(abi.encodePacked(key));msg.value > 1000000000000000000;;msg.sender.transfer(address(this).balance);
./0x191a70e9808c8d89be289cfe9001a7010dc3d78c_ext.sol,HFCoin.burn,34,39,"TMP_0(bool) = _value <= 10,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_1(uint256) -> balanceOf[msg.sender],REF_1(-> balanceOf) = REF_1 - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= 10)

IRs:
TMP_0(bool) = _value <= 10
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
REF_1(-> balanceOf) = REF_1 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(_value <= 10);balanceOf[msg.sender] -= _value;Burn(msg.sender,_value);true;success"
./0x537c23b71d847eef947f150ac7e33b1854138d5c_ext.sol,ERC20.mintToken,167,171,"REF_20(uint256) -> balanceOf[target],REF_20(-> balanceOf) = REF_20 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_20(uint256) -> balanceOf[target]
REF_20(-> balanceOf) = REF_20 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
4->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(this,target,mintedAmount)"
./0x0165d355ee4e4c2cb8fbcc740f63c6fa66f92919_ext.sol,TokenERC20.approveAndCall,163,171,"TMP_40 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_40(tokenRecipient),TMP_41(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value),CONDITION TMP_41,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_40 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_40(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_41(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value)
CONDITION TMP_41""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x512a4d492669e5f0746609d638796c0ad94276cd_ext.sol,RaceCoin.fundRaceCoinDeposit,662,666,"INTERNAL_CALL, RaceCoin.updatePlayersRaceCoinFromPurchase(address,uint256)(msg.sender,amount),REF_253(mapping(uint256 => uint256)) -> raceCoinSnapshots[msg.sender],REF_254 -> LENGTH totalRaceCoinSnapshots,TMP_235(uint256) = REF_254 - 1,REF_255(uint256) -> REF_253[TMP_235],REF_255(-> raceCoinSnapshots) = REF_255 + amount,REF_256 -> LENGTH totalRaceCoinSnapshots,TMP_236(uint256) = REF_256 - 1,REF_257(uint256) -> totalRaceCoinSnapshots[TMP_236],REF_257(-> totalRaceCoinSnapshots) = REF_257 + amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
updatePlayersRaceCoinFromPurchase(msg.sender,amount)

IRs:
INTERNAL_CALL, RaceCoin.updatePlayersRaceCoinFromPurchase(address,uint256)(msg.sender,amount)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
raceCoinSnapshots[msg.sender][totalRaceCoinSnapshots.length - 1] += amount

IRs:
REF_253(mapping(uint256 => uint256)) -> raceCoinSnapshots[msg.sender]
REF_254 -> LENGTH totalRaceCoinSnapshots
TMP_235(uint256) = REF_254 - 1
REF_255(uint256) -> REF_253[TMP_235]
REF_255(-> raceCoinSnapshots) = REF_255 + amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalRaceCoinSnapshots[totalRaceCoinSnapshots.length - 1] += amount

IRs:
REF_256 -> LENGTH totalRaceCoinSnapshots
TMP_236(uint256) = REF_256 - 1
REF_257(uint256) -> totalRaceCoinSnapshots[TMP_236]
REF_257(-> totalRaceCoinSnapshots) = REF_257 + amount""];
}
",0,1,0,0,"updatePlayersRaceCoinFromPurchase(msg.sender,amount);raceCoinSnapshots[msg.sender][totalRaceCoinSnapshots.length - 1] += amount;totalRaceCoinSnapshots[totalRaceCoinSnapshots.length - 1] += amount"
./0x58002a6b6e659a16de9f02f529b10536e307b0d9_ext.sol,CHFT.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0xec71870d02ba5c392ec8f64837e314b28afa4222_ext.sol,BillionRewardsToken.unlockDevSupply,59,68,"TMP_12(bool) = now > 1640995200,TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12),TMP_14(bool) = Dev_TokenReleased == False,TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14),REF_1(uint256) -> balanceOf[owner],REF_1(-> balanceOf) = REF_1 + Devs_Supply,totalSupply(uint256) = totalSupply + Devs_Supply,Emit Transfer(0,this,Devs_Supply),Emit Transfer(this,owner,Devs_Supply),Devs_Supply(uint256) := 0(uint256),Dev_TokenReleased(bool) := True(bool),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now > 1640995200)

IRs:
TMP_12(bool) = now > 1640995200
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(Dev_TokenReleased == false)

IRs:
TMP_14(bool) = Dev_TokenReleased == False
TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[owner] += Devs_Supply

IRs:
REF_1(uint256) -> balanceOf[owner]
REF_1(-> balanceOf) = REF_1 + Devs_Supply""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
totalSupply += Devs_Supply

IRs:
totalSupply(uint256) = totalSupply + Devs_Supply""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(0,this,Devs_Supply)

IRs:
Emit Transfer(0,this,Devs_Supply)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(this,owner,Devs_Supply)

IRs:
Emit Transfer(this,owner,Devs_Supply)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Devs_Supply = 0

IRs:
Devs_Supply(uint256) := 0(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Dev_TokenReleased = true

IRs:
Dev_TokenReleased(bool) := True(bool)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
9->1;
}
",0,1,0,0,"onlyOwner();require(bool)(now > 1640995200);require(bool)(Dev_TokenReleased == false);balanceOf[owner] += Devs_Supply;totalSupply += Devs_Supply;Transfer(0,this,Devs_Supply);Transfer(this,owner,Devs_Supply);Devs_Supply = 0;Dev_TokenReleased = true"
./0x842d6da3097b5efde5a81535144f947ab482b6ee_ext.sol,WhoTheEth.setName,30,36,"TMP_3(bool) = msg.value >= 1000000000000000,TMP_4(bool) = numberOfNames < 500,TMP_5(bool) = TMP_3 || TMP_4,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),TMP_7(uint256) := numberOfNames(uint256),numberOfNames(uint256) = numberOfNames + 1,REF_4(string) -> names[msg.sender],REF_4(string) (->names) := newName(string),REF_5(uint256) -> bank[owner],REF_5(-> bank) = REF_5 + msg.value,Emit AddedName(msg.sender,newName,now,owner,msg.value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= 1000000000000000 || numberOfNames < 500)

IRs:
TMP_3(bool) = msg.value >= 1000000000000000
TMP_4(bool) = numberOfNames < 500
TMP_5(bool) = TMP_3 || TMP_4
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
numberOfNames ++

IRs:
TMP_7(uint256) := numberOfNames(uint256)
numberOfNames(uint256) = numberOfNames + 1""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
names[msg.sender] = newName

IRs:
REF_4(string) -> names[msg.sender]
REF_4(string) (->names) := newName(string)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
bank[owner] += msg.value

IRs:
REF_5(uint256) -> bank[owner]
REF_5(-> bank) = REF_5 + msg.value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
AddedName(msg.sender,newName,now,owner,msg.value)

IRs:
Emit AddedName(msg.sender,newName,now,owner,msg.value)""];
}
",0,1,0,0,"require(bool)(msg.value >= 1000000000000000 || numberOfNames < 500);numberOfNames ++;names[msg.sender] = newName;bank[owner] += msg.value;AddedName(msg.sender,newName,now,owner,msg.value)"
./0x64d30c2e9715f0add2815f862eaf22d9dbc1bd28_ext.sol,BoltToken.contribute,140,159,"TMP_36(bool) = msg.value == 0,CONDITION TMP_36,TMP_37 = UnaryType.BANG canPurchase ,TMP_38 = UnaryType.BANG _acceptConditions ,TMP_39(bool) = TMP_37 || TMP_38,TMP_40(bool) = msg.value < 10000000000000000,TMP_41(bool) = TMP_39 || TMP_40,CONDITION TMP_41,Transfer dest:msg.sender value:msg.value,Transfer dest:owner value:msg.value,REF_27(uint256) -> roundContributions[msg.sender],TMP_44(bool) = REF_27 == 0,CONDITION TMP_44,REF_29 -> LENGTH roundContributionsIndexes,TMP_46(uint256) := REF_29(uint256),TMP_47(uint256) = TMP_46 + 1,REF_29(uint256) (->roundContributionsIndexes) := TMP_47(uint256),REF_30(address) -> roundContributionsIndexes[TMP_46],REF_30(address) (->roundContributionsIndexes) := msg.sender(address),REF_31(uint256) -> roundContributions[msg.sender],REF_31(-> roundContributions) = REF_31 + msg.value,roundFunds(uint256) = roundFunds + msg.value,Emit Contribution(msg.sender,msg.value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value == 0

IRs:
TMP_36(bool) = msg.value == 0
CONDITION TMP_36""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
! canPurchase || ! _acceptConditions || msg.value < 10000000000000000

IRs:
TMP_37 = UnaryType.BANG canPurchase 
TMP_38 = UnaryType.BANG _acceptConditions 
TMP_39(bool) = TMP_37 || TMP_38
TMP_40(bool) = msg.value < 10000000000000000
TMP_41(bool) = TMP_39 || TMP_40
CONDITION TMP_41""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(msg.value)

IRs:
Transfer dest:msg.sender value:msg.value""];
5->6;
6[label=""Node Type: RETURN 6
""];
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
owner.transfer(msg.value)

IRs:
Transfer dest:owner value:msg.value""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
roundContributions[msg.sender] == 0

IRs:
REF_27(uint256) -> roundContributions[msg.sender]
TMP_44(bool) = REF_27 == 0
CONDITION TMP_44""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
roundContributionsIndexes.push(msg.sender)

IRs:
REF_29 -> LENGTH roundContributionsIndexes
TMP_46(uint256) := REF_29(uint256)
TMP_47(uint256) = TMP_46 + 1
REF_29(uint256) (->roundContributionsIndexes) := TMP_47(uint256)
REF_30(address) -> roundContributionsIndexes[TMP_46]
REF_30(address) (->roundContributionsIndexes) := msg.sender(address)""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
roundContributions[msg.sender] += msg.value

IRs:
REF_31(uint256) -> roundContributions[msg.sender]
REF_31(-> roundContributions) = REF_31 + msg.value""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
roundFunds += msg.value

IRs:
roundFunds(uint256) = roundFunds + msg.value""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
Contribution(msg.sender,msg.value)

IRs:
Emit Contribution(msg.sender,msg.value)""];
}
",0,1,1,0,"msg.value == 0;;;! canPurchase || ! _acceptConditions || msg.value < 10000000000000000;msg.sender.transfer(msg.value);;;owner.transfer(msg.value);roundContributions[msg.sender] == 0;roundContributionsIndexes.push(msg.sender);;roundContributions[msg.sender] += msg.value;roundFunds += msg.value;Contribution(msg.sender,msg.value)"
./0x7045c5c158aecd68eed18671cc8775fc7f7d6e70_ext.sol,DHCToken.changeNameAndSymbol,173,178,"TMP_71(bool) = msg.sender == owner,CONDITION TMP_71,name(string) := _name(string),symbol(string) := _symbol(string)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_71(bool) = msg.sender == owner
CONDITION TMP_71""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
name = _name

IRs:
name(string) := _name(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
symbol = _symbol

IRs:
symbol(string) := _symbol(string)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,msg.sender == owner;name = _name;;symbol = _symbol
./0xc66e78b1078ba0e65d311c92854dd446451b2ba6_ext.sol,Xoom.approveAndCall,196,201,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x6b31d68c23c27f04d813aa1cb8ac436dc0432971_ext.sol,ERC20.setup,36,44,"TMP_0(bool) = msg.sender == owner,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),name(string) := _name(string),symbol(string) := _symbol(string),decimals(uint256) := _decimals(uint256),TMP_2(uint256) = 10 ** _decimals,TMP_3(uint256) = _totalSupply * TMP_2,totalSupply(uint256) := TMP_3(uint256),REF_3(uint256) -> balances[msg.sender],REF_3(uint256) (->balances) := totalSupply(uint256),TMP_4 = CONVERT this to address,Emit Transfer(TMP_4,msg.sender,totalSupply)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_0(bool) = msg.sender == owner
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
name = _name

IRs:
name(string) := _name(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
symbol = _symbol

IRs:
symbol(string) := _symbol(string)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
decimals = _decimals

IRs:
decimals(uint256) := _decimals(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply = _totalSupply * 10 ** _decimals

IRs:
TMP_2(uint256) = 10 ** _decimals
TMP_3(uint256) = _totalSupply * TMP_2
totalSupply(uint256) := TMP_3(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[msg.sender] = totalSupply

IRs:
REF_3(uint256) -> balances[msg.sender]
REF_3(uint256) (->balances) := totalSupply(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(address(this),msg.sender,totalSupply)

IRs:
TMP_4 = CONVERT this to address
Emit Transfer(TMP_4,msg.sender,totalSupply)""];
}
",0,1,0,0,"require(bool)(msg.sender == owner);name = _name;symbol = _symbol;decimals = _decimals;totalSupply = _totalSupply * 10 ** _decimals;balances[msg.sender] = totalSupply;Transfer(address(this),msg.sender,totalSupply)"
./0x2d50c2dd998aab26a666a5e9f15e7f32ad9e8ce1_ext.sol,VOCC_I073_20181211.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0xf07d979303c50a8632848cb154c6b30980218c07_ext.sol,PXLProperty.burnPXLRewardPXLx2,299,313,"REF_133(uint256) -> balances[burner],TMP_89(bool) = REF_133 >= toBurn,TMP_90(None) = SOLIDITY_CALL require(bool)(TMP_89),TMP_91(bool) = toBurn > 0,CONDITION TMP_91,REF_134(uint256) -> balances[burner],REF_134(-> balances) = REF_134 - toBurn,totalSupply(uint256) = totalSupply - toBurn,TMP_92(bool) = rewarder1 != 0,CONDITION TMP_92,REF_135(uint256) -> balances[rewarder1],REF_135(-> balances) = REF_135 + toReward1,totalSupply(uint256) = totalSupply + toReward1,TMP_93(bool) = rewarder2 != 0,CONDITION TMP_93,REF_136(uint256) -> balances[rewarder2],REF_136(-> balances) = REF_136 + toReward2,totalSupply(uint256) = totalSupply + toReward2,MODIFIER_CALL, PXLProperty.pixelPropertyAccess()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[burner] >= toBurn)

IRs:
REF_133(uint256) -> balances[burner]
TMP_89(bool) = REF_133 >= toBurn
TMP_90(None) = SOLIDITY_CALL require(bool)(TMP_89)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
toBurn > 0

IRs:
TMP_91(bool) = toBurn > 0
CONDITION TMP_91""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[burner] -= toBurn

IRs:
REF_134(uint256) -> balances[burner]
REF_134(-> balances) = REF_134 - toBurn""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
totalSupply -= toBurn

IRs:
totalSupply(uint256) = totalSupply - toBurn""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
rewarder1 != 0

IRs:
TMP_92(bool) = rewarder1 != 0
CONDITION TMP_92""];
6->7[label=""True""];
6->9[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[rewarder1] += toReward1

IRs:
REF_135(uint256) -> balances[rewarder1]
REF_135(-> balances) = REF_135 + toReward1""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
totalSupply += toReward1

IRs:
totalSupply(uint256) = totalSupply + toReward1""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
rewarder2 != 0

IRs:
TMP_93(bool) = rewarder2 != 0
CONDITION TMP_93""];
10->11[label=""True""];
10->13[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
balances[rewarder2] += toReward2

IRs:
REF_136(uint256) -> balances[rewarder2]
REF_136(-> balances) = REF_136 + toReward2""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
totalSupply += toReward2

IRs:
totalSupply(uint256) = totalSupply + toReward2""];
12->13;
13[label=""Node Type: END_IF 13
""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
pixelPropertyAccess()

IRs:
MODIFIER_CALL, PXLProperty.pixelPropertyAccess()()""];
14->1;
}
",0,1,0,0,pixelPropertyAccess();require(bool)(balances[burner] >= toBurn);toBurn > 0;balances[burner] -= toBurn;;totalSupply -= toBurn;rewarder1 != 0;balances[rewarder1] += toReward1;;totalSupply += toReward1;rewarder2 != 0;balances[rewarder2] += toReward2;;totalSupply += toReward2
./0x065313f29dc4a4b8b5fc4915059d122065519957_ext.sol,Future1Exchange.safeAdd,29,33,"TMP_0(uint256) = crtbal + depbal,totalbal(uint256) := TMP_0(uint256),RETURN totalbal","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
totalbal = crtbal + depbal

IRs:
TMP_0(uint256) = crtbal + depbal
totalbal(uint256) := TMP_0(uint256)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
totalbal

IRs:
RETURN totalbal""];
}
",0,1,0,0,totalbal = crtbal + depbal;totalbal
./0x276528880ac7e202f3db20d74402ea0a9c8774a8_ext.sol,ERC20Token.burn,113,123,"REF_17(uint256) -> balanceOf[msg.sender],TMP_27(bool) = REF_17 >= _value,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_27(bool) = REF_17 >= _value
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xb47f7059e3706c0ccf270ba11f1747a137f9fd12_ext.sol,Fund.transferFrom,36,46,"REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],allowance(uint256) := REF_5(uint256),REF_6(uint256) -> balances[_from],TMP_3(bool) = REF_6 >= _value,TMP_4(bool) = allowance >= _value,TMP_5(bool) = TMP_3 && TMP_4,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_7(uint256) -> balances[_to],REF_7(-> balances) = REF_7 + _value,REF_8(uint256) -> balances[_from],REF_8(-> balances) = REF_8 - _value,TMP_7(bool) = allowance < MAX_UINT256,CONDITION TMP_7,REF_9(mapping(address => uint256)) -> allowed[_from],REF_10(uint256) -> REF_9[msg.sender],REF_10(-> allowed) = REF_10 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
allowance = allowed[_from][msg.sender]

IRs:
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
allowance(uint256) := REF_5(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] >= _value && allowance >= _value)

IRs:
REF_6(uint256) -> balances[_from]
TMP_3(bool) = REF_6 >= _value
TMP_4(bool) = allowance >= _value
TMP_5(bool) = TMP_3 && TMP_4
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_7(uint256) -> balances[_to]
REF_7(-> balances) = REF_7 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] -= _value

IRs:
REF_8(uint256) -> balances[_from]
REF_8(-> balances) = REF_8 - _value""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
allowance < MAX_UINT256

IRs:
TMP_7(bool) = allowance < MAX_UINT256
CONDITION TMP_7""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_9(mapping(address => uint256)) -> allowed[_from]
REF_10(uint256) -> REF_9[msg.sender]
REF_10(-> allowed) = REF_10 - _value""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: RETURN 10

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowance = allowed[_from][msg.sender];require(bool)(balances[_from] >= _value && allowance >= _value);balances[_to] += _value;balances[_from] -= _value;allowance < MAX_UINT256;allowed[_from][msg.sender] -= _value;;Transfer(_from,_to,_value);true;success"
./0xc398fb8a6c71a7b130043bf5a3f05d9d51c2cac8_ext.sol,CHAD.totalSupply,120,122,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x5b463c4e19358b4eaf010cf24244bf140541a63e_ext.sol,TokenERC20.mintToken,104,109,"REF_25(uint256) -> balanceOf[target],REF_25(-> balanceOf) = REF_25 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,owner,mintedAmount),Emit Transfer(owner,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_25(uint256) -> balanceOf[target]
REF_25(-> balanceOf) = REF_25 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,owner,mintedAmount)

IRs:
Emit Transfer(0,owner,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(owner,target,mintedAmount)

IRs:
Emit Transfer(owner,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,owner,mintedAmount);Transfer(owner,target,mintedAmount)"
./0x413e0794e1d2e7e26a9536a79a07b2ceb13fb994_ext.sol,SHERE_PFII_II_883.transferFrom,42,54,"REF_6(uint256) -> balanceOf[from],TMP_6(bool) = value <= REF_6,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_7(mapping(address => uint256)) -> allowance[from],REF_8(uint256) -> REF_7[msg.sender],TMP_8(bool) = value <= REF_8,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_9(uint256) -> balanceOf[from],REF_9(-> balanceOf) = REF_9 - value,REF_10(uint256) -> balanceOf[to],REF_10(-> balanceOf) = REF_10 + value,REF_11(mapping(address => uint256)) -> allowance[from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowance) = REF_12 - value,Emit Transfer(from,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(value <= balanceOf[from])

IRs:
REF_6(uint256) -> balanceOf[from]
TMP_6(bool) = value <= REF_6
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value <= allowance[from][msg.sender])

IRs:
REF_7(mapping(address => uint256)) -> allowance[from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_8(bool) = value <= REF_8
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[from] -= value

IRs:
REF_9(uint256) -> balanceOf[from]
REF_9(-> balanceOf) = REF_9 - value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[to] += value

IRs:
REF_10(uint256) -> balanceOf[to]
REF_10(-> balanceOf) = REF_10 + value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allowance[from][msg.sender] -= value

IRs:
REF_11(mapping(address => uint256)) -> allowance[from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowance) = REF_12 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(value <= balanceOf[from]);require(bool)(value <= allowance[from][msg.sender]);balanceOf[from] -= value;balanceOf[to] += value;allowance[from][msg.sender] -= value;Transfer(from,to,value);true;success"
./0x0e9e062d7e60c8a6a406488631dae1c5f6db0e7d_ext.sol,TextMessage.sendText,72,76,"TMP_11 = UnaryType.BANG enabled ,CONDITION TMP_11,TMP_12(bool) = msg.value < cost,CONDITION TMP_12,INTERNAL_CALL, TextMessage.sendMsg(string,string)(phoneNumber,textBody)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
! enabled

IRs:
TMP_11 = UnaryType.BANG enabled 
CONDITION TMP_11""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
msg.value < cost

IRs:
TMP_12(bool) = msg.value < cost
CONDITION TMP_12""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: THROW 5
""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
sendMsg(phoneNumber,textBody)

IRs:
INTERNAL_CALL, TextMessage.sendMsg(string,string)(phoneNumber,textBody)""];
}
",0,1,0,0,"! enabled;;;msg.value < cost;;;sendMsg(phoneNumber,textBody)"
./0x562f0c1d080be544b3095d02abcdb9786249a416_ext.sol,SEAPORT_Portfolio_V_883.transferFrom,42,54,"REF_6(uint256) -> balanceOf[from],TMP_6(bool) = value <= REF_6,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_7(mapping(address => uint256)) -> allowance[from],REF_8(uint256) -> REF_7[msg.sender],TMP_8(bool) = value <= REF_8,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_9(uint256) -> balanceOf[from],REF_9(-> balanceOf) = REF_9 - value,REF_10(uint256) -> balanceOf[to],REF_10(-> balanceOf) = REF_10 + value,REF_11(mapping(address => uint256)) -> allowance[from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowance) = REF_12 - value,Emit Transfer(from,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(value <= balanceOf[from])

IRs:
REF_6(uint256) -> balanceOf[from]
TMP_6(bool) = value <= REF_6
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value <= allowance[from][msg.sender])

IRs:
REF_7(mapping(address => uint256)) -> allowance[from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_8(bool) = value <= REF_8
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[from] -= value

IRs:
REF_9(uint256) -> balanceOf[from]
REF_9(-> balanceOf) = REF_9 - value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[to] += value

IRs:
REF_10(uint256) -> balanceOf[to]
REF_10(-> balanceOf) = REF_10 + value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allowance[from][msg.sender] -= value

IRs:
REF_11(mapping(address => uint256)) -> allowance[from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowance) = REF_12 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(value <= balanceOf[from]);require(bool)(value <= allowance[from][msg.sender]);balanceOf[from] -= value;balanceOf[to] += value;allowance[from][msg.sender] -= value;Transfer(from,to,value);true;success"
./0x28e860cb89e705de876f858671cb757f650fdae2_ext.sol,WEPAYCOIN.burnFrom,149,157,"REF_19(uint256) -> balanceOf[_from],TMP_26(bool) = REF_19 >= _value,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_28(bool) = _value <= REF_21,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_26(bool) = REF_19 >= _value
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_28(bool) = _value <= REF_21
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x12ac8d8f0f48b7954bcda736af0576a12dc8c387_ext.sol,OPL.burn,168,174,"REF_18(uint256) -> balanceOf[msg.sender],TMP_29(bool) = REF_18 >= _value,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),REF_19(uint256) -> balanceOf[msg.sender],REF_19(-> balanceOf) = REF_19 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
TMP_29(bool) = REF_18 >= _value
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_19(uint256) -> balanceOf[msg.sender]
REF_19(-> balanceOf) = REF_19 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x39e5bd6ae0f2aa9240d2ae7fbf49e36f05dd339f_ext.sol,SafeMath.add,27,31,"TMP_10(uint256) = a + b,c(uint256) := TMP_10(uint256),TMP_11(bool) = c >= a,TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11),RETURN c","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_10(uint256) = a + b
c(uint256) := TMP_10(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_11(bool) = c >= a
TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c""];
}
",0,1,0,0,c = a + b;assert(bool)(c >= a);c
./0x446f174bc64cbca8b9fe81087798a156cfb863b7_ext.sol,Voting2018.setContent,58,66,"REF_12 -> LENGTH files,TMP_6(bool) = fileId < REF_12,CONDITION TMP_6,REF_13(Voting2018.File) -> files[fileId],REF_14(string) -> REF_13.contentTime,TMP_7 = CONVERT REF_14 to bytes,contentTimeEmptyTest(bytes) := TMP_7(bytes),REF_15 -> LENGTH contentTimeEmptyTest,TMP_8(bool) = REF_15 == 0,CONDITION TMP_8,REF_16(Voting2018.File) -> files[fileId],REF_17(string) -> REF_16.content,REF_17(string) (->files) := _content(string),REF_18(Voting2018.File) -> files[fileId],REF_19(string) -> REF_18.contentTime,REF_19(string) (->files) := _time(string),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: IF 1

EXPRESSION:
fileId < files.length

IRs:
REF_12 -> LENGTH files
TMP_6(bool) = fileId < REF_12
CONDITION TMP_6""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
contentTimeEmptyTest = bytes(files[fileId].contentTime)

IRs:
REF_13(Voting2018.File) -> files[fileId]
REF_14(string) -> REF_13.contentTime
TMP_7 = CONVERT REF_14 to bytes
contentTimeEmptyTest(bytes) := TMP_7(bytes)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
contentTimeEmptyTest.length == 0

IRs:
REF_15 -> LENGTH contentTimeEmptyTest
TMP_8(bool) = REF_15 == 0
CONDITION TMP_8""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
files[fileId].content = _content

IRs:
REF_16(Voting2018.File) -> files[fileId]
REF_17(string) -> REF_16.content
REF_17(string) (->files) := _content(string)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
files[fileId].contentTime = _time

IRs:
REF_18(Voting2018.File) -> files[fileId]
REF_19(string) -> REF_18.contentTime
REF_19(string) (->files) := _time(string)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: END_IF 7
""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
8->1;
}
",0,1,0,0,onlyOwner();fileId < files.length;contentTimeEmptyTest = bytes(files[fileId].contentTime);;contentTimeEmptyTest.length == 0;files[fileId].content = _content;;files[fileId].contentTime = _time
./0x2c1180e2818069e5a9f911e636fb8f3db5106a9f_ext.sol,StandardToken.transferFrom,37,47,"REF_4(uint256) -> balances[_from],TMP_4(bool) = REF_4 >= _value,REF_5(mapping(address => uint256)) -> allowed[_from],REF_6(uint256) -> REF_5[msg.sender],TMP_5(bool) = REF_6 >= _value,TMP_6(bool) = TMP_4 && TMP_5,TMP_7(bool) = _value > 0,TMP_8(bool) = TMP_6 && TMP_7,CONDITION TMP_8,REF_7(uint256) -> balances[_to],REF_7(-> balances) = REF_7 + _value,REF_8(uint256) -> balances[_from],REF_8(-> balances) = REF_8 - _value,REF_9(mapping(address => uint256)) -> allowed[_from],REF_10(uint256) -> REF_9[msg.sender],REF_10(-> allowed) = REF_10 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0

IRs:
REF_4(uint256) -> balances[_from]
TMP_4(bool) = REF_4 >= _value
REF_5(mapping(address => uint256)) -> allowed[_from]
REF_6(uint256) -> REF_5[msg.sender]
TMP_5(bool) = REF_6 >= _value
TMP_6(bool) = TMP_4 && TMP_5
TMP_7(bool) = _value > 0
TMP_8(bool) = TMP_6 && TMP_7
CONDITION TMP_8""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_7(uint256) -> balances[_to]
REF_7(-> balances) = REF_7 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_8(uint256) -> balances[_from]
REF_8(-> balances) = REF_8 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_9(mapping(address => uint256)) -> allowed[_from]
REF_10(uint256) -> REF_9[msg.sender]
REF_10(-> allowed) = REF_10 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0;balances[_to] += _value;false;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true;success"
./0x503a7b43335e035bdfec030d2ef718449d985050_ext.sol,StandardToken.transferFrom,55,65,"REF_3(uint256) -> balances[_from],TMP_18(bool) = REF_3 >= _value,REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],TMP_19(bool) = REF_5 >= _value,TMP_20(bool) = TMP_18 && TMP_19,TMP_21(bool) = _value > 0,TMP_22(bool) = TMP_20 && TMP_21,CONDITION TMP_22,REF_6(uint256) -> balances[_to],REF_6(-> balances) = REF_6 + _value,REF_7(uint256) -> balances[_from],REF_7(-> balances) = REF_7 - _value,REF_8(mapping(address => uint256)) -> allowed[_from],REF_9(uint256) -> REF_8[msg.sender],REF_9(-> allowed) = REF_9 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0

IRs:
REF_3(uint256) -> balances[_from]
TMP_18(bool) = REF_3 >= _value
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
TMP_19(bool) = REF_5 >= _value
TMP_20(bool) = TMP_18 && TMP_19
TMP_21(bool) = _value > 0
TMP_22(bool) = TMP_20 && TMP_21
CONDITION TMP_22""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_6(uint256) -> balances[_to]
REF_6(-> balances) = REF_6 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_7(uint256) -> balances[_from]
REF_7(-> balances) = REF_7 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_8(mapping(address => uint256)) -> allowed[_from]
REF_9(uint256) -> REF_8[msg.sender]
REF_9(-> allowed) = REF_9 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0;balances[_to] += _value;false;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true;success"
./0x2736d225f85740f42d17987100dc8d58e9e16252_ext.sol,ServerRegistry.updateServer,90,102,"INTERNAL_CALL, ServerRegistry.checkLimits()(),REF_12(ServerRegistry.In3Server) -> servers[_serverIndex],server(ServerRegistry.In3Server) := REF_12(ServerRegistry.In3Server),REF_13(address) -> server.owner,TMP_12(bool) = REF_13 == msg.sender,TMP_13(None) = SOLIDITY_CALL require(bool,string)(TMP_12,only the owner may update the server),TMP_14(bool) = msg.value > 0,CONDITION TMP_14,REF_14(uint256) -> server.deposit,REF_14(-> server) = REF_14 + msg.value,REF_15(uint256) -> server.props,TMP_15(bool) = _props != REF_15,CONDITION TMP_15,REF_16(uint256) -> server.props,REF_16(uint256) (->server) := _props(uint256),REF_17(string) -> server.url,REF_18(uint256) -> server.deposit,Emit LogServerRegistered(REF_17,_props,msg.sender,REF_18)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
checkLimits()

IRs:
INTERNAL_CALL, ServerRegistry.checkLimits()()""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
server = servers[_serverIndex]

IRs:
REF_12(ServerRegistry.In3Server) -> servers[_serverIndex]
server(ServerRegistry.In3Server) := REF_12(ServerRegistry.In3Server)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool,string)(server.owner == msg.sender,only the owner may update the server)

IRs:
REF_13(address) -> server.owner
TMP_12(bool) = REF_13 == msg.sender
TMP_13(None) = SOLIDITY_CALL require(bool,string)(TMP_12,only the owner may update the server)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
msg.value > 0

IRs:
TMP_14(bool) = msg.value > 0
CONDITION TMP_14""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
server.deposit += msg.value

IRs:
REF_14(uint256) -> server.deposit
REF_14(-> server) = REF_14 + msg.value""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
_props != server.props

IRs:
REF_15(uint256) -> server.props
TMP_15(bool) = _props != REF_15
CONDITION TMP_15""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
server.props = _props

IRs:
REF_16(uint256) -> server.props
REF_16(uint256) (->server) := _props(uint256)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
LogServerRegistered(server.url,_props,msg.sender,server.deposit)

IRs:
REF_17(string) -> server.url
REF_18(uint256) -> server.deposit
Emit LogServerRegistered(REF_17,_props,msg.sender,REF_18)""];
}
",0,1,0,0,"checkLimits();server = servers[_serverIndex];require(bool,string)(server.owner == msg.sender,only the owner may update the server);msg.value > 0;server.deposit += msg.value;;_props != server.props;server.props = _props;;LogServerRegistered(server.url,_props,msg.sender,server.deposit)"
./0x5b15a638d1defbf055dc2d7653d5ff1bd5a9494c_ext.sol,CHEMCHINA_PFIII_III_883.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0xd0b13c1195f1c50be0d3be956ff32aaebb48e1e4_ext.sol,FccToken.issue,149,160,"TMP_56(bool) = _value >= 0,TMP_57(None) = SOLIDITY_CALL require(bool)(TMP_56),REF_39(uint256) -> balances[_recipient],REF_39(-> balances) = REF_39 + _value,totalSupply(uint256) = totalSupply + _value,Emit Transfer(0,owner,_value),Emit Transfer(owner,_recipient,_value),RETURN True,MODIFIER_CALL, Owned.onlyICO()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value >= 0)

IRs:
TMP_56(bool) = _value >= 0
TMP_57(None) = SOLIDITY_CALL require(bool)(TMP_56)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_recipient] += _value

IRs:
REF_39(uint256) -> balances[_recipient]
REF_39(-> balances) = REF_39 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply += _value

IRs:
totalSupply(uint256) = totalSupply + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(0,owner,_value)

IRs:
Emit Transfer(0,owner,_value)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(owner,_recipient,_value)

IRs:
Emit Transfer(owner,_recipient,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyICO()

IRs:
MODIFIER_CALL, Owned.onlyICO()()""];
7->1;
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"onlyICO();require(bool)(_value >= 0);balances[_recipient] += _value;totalSupply += _value;Transfer(0,owner,_value);Transfer(owner,_recipient,_value);true;success"
./0x18486c451fdc6eac512d468967f75729d11b89ea_ext.sol,LiteCoinW.distributeLTCW,74,80,"i(uint256) := 0(uint256),REF_1 -> LENGTH addresses,TMP_2(bool) = i < REF_1,CONDITION TMP_2,REF_2(uint256) -> balances[owner],REF_2(-> balances) = REF_2 - _value,REF_3(address) -> addresses[i],REF_4(uint256) -> balances[REF_3],REF_4(-> balances) = REF_4 + _value,REF_5(address) -> addresses[i],Emit Transfer(owner,REF_5,_value),TMP_4(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, LiteCoinW.onlyOwner()(),MODIFIER_CALL, LiteCoinW.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addresses.length

IRs:
REF_1 -> LENGTH addresses
TMP_2(bool) = i < REF_1
CONDITION TMP_2""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[owner] -= _value

IRs:
REF_2(uint256) -> balances[owner]
REF_2(-> balances) = REF_2 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[addresses[i]] += _value

IRs:
REF_3(address) -> addresses[i]
REF_4(uint256) -> balances[REF_3]
REF_4(-> balances) = REF_4 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(owner,addresses[i],_value)

IRs:
REF_5(address) -> addresses[i]
Emit Transfer(owner,REF_5,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_4(uint256) := i(uint256)
i(uint256) = i + 1""];
8->4;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, LiteCoinW.onlyOwner()()""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, LiteCoinW.canDistr()()""];
10->3;
}
",0,1,0,0,"onlyOwner();;i < addresses.length;;i = 0;balances[owner] -= _value;balances[addresses[i]] += _value;Transfer(owner,addresses[i],_value);i ++;canDistr()"
./0x3a8a6d2bc23fb68a245250ad34019a65cf057418_ext.sol,DiscountPercentToken.mintToken,219,224,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0xdc8fd6abd32fd9d0dc74e6947aca082658adeb3d_ext.sol,UMIproject.getInvestorDividendsAmount,205,207,"REF_76(UMIproject.Investor) -> investors[addr],REF_77(uint256) -> REF_76.deposit,TMP_79(uint256) = REF_77 / 100,TMP_80(uint256) = TMP_79 * INTEREST,REF_78(UMIproject.Investor) -> investors[addr],REF_79(uint256) -> REF_78.date,TMP_81(uint256) = now - REF_79,TMP_82(uint256) = TMP_80 * TMP_81,TMP_83(uint256) = TMP_82 / 86400,RETURN TMP_83","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
investors[addr].deposit / 100 * INTEREST * (now - investors[addr].date) / 86400

IRs:
REF_76(UMIproject.Investor) -> investors[addr]
REF_77(uint256) -> REF_76.deposit
TMP_79(uint256) = REF_77 / 100
TMP_80(uint256) = TMP_79 * INTEREST
REF_78(UMIproject.Investor) -> investors[addr]
REF_79(uint256) -> REF_78.date
TMP_81(uint256) = now - REF_79
TMP_82(uint256) = TMP_80 * TMP_81
TMP_83(uint256) = TMP_82 / 86400
RETURN TMP_83""];
}
",0,1,0,0,investors[addr].deposit / 100 * INTEREST * (now - investors[addr].date) / 86400
./0xb3939627b9775c3b76c05138d281c7f92e251aab_ext.sol,LespNetWork.transfer,96,106,"REF_1(uint256) -> balances[msg.sender],TMP_21(bool) = REF_1 >= _value,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),TMP_23(bool) = msg.sender == _to,REF_2(uint256) -> balances[_to],TMP_24(uint256) = MAX_UINT256 - _value,TMP_25(bool) = REF_2 <= TMP_24,TMP_26(bool) = TMP_23 || TMP_25,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_3(uint256) -> balances[msg.sender],REF_3(-> balances) = REF_3 - _value,REF_4(uint256) -> balances[_to],REF_4(-> balances) = REF_4 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_21(bool) = REF_1 >= _value
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == _to || balances[_to] <= MAX_UINT256 - _value)

IRs:
TMP_23(bool) = msg.sender == _to
REF_2(uint256) -> balances[_to]
TMP_24(uint256) = MAX_UINT256 - _value
TMP_25(bool) = REF_2 <= TMP_24
TMP_26(bool) = TMP_23 || TMP_25
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_3(uint256) -> balances[msg.sender]
REF_3(-> balances) = REF_3 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] += _value

IRs:
REF_4(uint256) -> balances[_to]
REF_4(-> balances) = REF_4 + _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);require(bool)(msg.sender == _to || balances[_to] <= MAX_UINT256 - _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true"
./0x1cae8c6ec705520b11f10f773b7010958363318e_ext.sol,Hermes.Invest,47,170,"TMP_8(bool) = msg.value == 0,CONDITION TMP_8,TMP_9(bool) = msg.sender == ADMIN_ADDR,CONDITION TMP_9,INTERNAL_CALL, Hermes.payAll()(),INTERNAL_CALL, Hermes.paySelfByAddress(address)(msg.sender),REF_0(Hermes.Investor) -> INVESTORS[msg.sender],REF_1(uint256) -> REF_0.deposit,TMP_12(bool) = REF_1 == 0,CONDITION TMP_12,TMP_13(uint256) = DAY_VALUE + msg.value,TMP_14(bool) = TMP_13 < DAY_LIMIT,TMP_15(None) = SOLIDITY_CALL require(bool,string)(TMP_14,DAY LIMIT!!!),REF_2(Hermes.Investor) -> INVESTORS[msg.sender],REF_3(uint256) -> REF_2.dayLimitValue,TMP_16(uint256) = REF_3 + msg.value,TMP_17(uint256) = DAY_LIMIT / 2,TMP_18(bool) = TMP_16 < TMP_17,TMP_19(None) = SOLIDITY_CALL require(bool,string)(TMP_18,DAY LIMIT!!!),REF_4(Hermes.Investor) -> INVESTORS[msg.sender],REF_5(uint256) -> REF_4.dayLimitValue,REF_5(-> INVESTORS) = REF_5 + msg.value,DAY_VALUE(uint256) = DAY_VALUE + msg.value,REF_7 -> LENGTH ADDRESSES,TMP_21(uint256) := REF_7(uint256),TMP_22(uint256) = TMP_21 + 1,REF_7(uint256) (->ADDRESSES) := TMP_22(uint256),REF_8(address) -> ADDRESSES[TMP_21],REF_8(address) (->ADDRESSES) := msg.sender(address),REF_9 -> LENGTH ADDRESSES,id(uint256) := REF_9(uint256),TMP_23(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['msg.value', 'PERCENT_FOR_MARKETING'] ,TMP_24(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.div(uint256,uint256), arguments:['TMP_23', '10000000000'] ,TMP_25(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['TMP_24', '1'] ,Transfer dest:ADMIN_ADDR value:TMP_25,DEPOSIT_AMOUNT(uint256) = DEPOSIT_AMOUNT + msg.value,TMP_27(bool) = msg.value >= MINIMUM_INVEST,CONDITION TMP_27,REF_14(Hermes.Investor) -> INVESTORS[_referrer],REF_15(uint256) -> REF_14.deposit,TMP_28(bool) = REF_15 != 0,CONDITION TMP_28,REF_16(Hermes.Investor) -> INVESTORS[_referrer],REF_17(uint256) -> REF_16.deposit,TMP_29(bool) = REF_17 >= 3000000000000000000,CONDITION TMP_29,TMP_30(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['msg.value', '200000000'] ,TMP_31(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.div(uint256,uint256), arguments:['TMP_30', '10000000000'] ,value(uint256) := TMP_31(uint256),Transfer dest:msg.sender value:value,TMP_33(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['msg.value', '250000000'] ,TMP_34(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.div(uint256,uint256), arguments:['TMP_33', '10000000000'] ,value(uint256) := TMP_34(uint256),Transfer dest:_referrer value:value,REF_24(Hermes.Investor) -> INVESTORS[_referrer],REF_25(uint256) -> REF_24.stage,TMP_36(bool) = REF_25 < 1,CONDITION TMP_36,REF_26(Hermes.Investor) -> INVESTORS[_referrer],REF_27(uint256) -> REF_26.stage,REF_27(uint256) (->INVESTORS) := 1(uint256),nextReferrer(address) := _referrer(address),i(uint256) := 0(uint256),TMP_37(bool) = i < 4,CONDITION TMP_37,REF_28(Hermes.Investor) -> INVESTORS[nextReferrer],REF_29(address) -> REF_28.referrer,TMP_38 = CONVERT 0 to address,TMP_39(bool) = REF_29 == TMP_38,CONDITION TMP_39,REF_30(Hermes.Investor) -> INVESTORS[nextReferrer],REF_31(address) -> REF_30.referrer,REF_32(Hermes.Investor) -> INVESTORS[REF_31],REF_33(uint256) -> REF_32.reinvestID,TMP_40(bool) = REF_33 != 3,CONDITION TMP_40,REF_34(Hermes.Investor) -> INVESTORS[nextReferrer],REF_35(address) -> REF_34.referrer,REF_36(Hermes.Investor) -> INVESTORS[REF_35],REF_37(uint256) -> REF_36.deposit,TMP_41(bool) = REF_37 >= 3000000000000000000,CONDITION TMP_41,REF_38(Hermes.Investor) -> INVESTORS[nextReferrer],REF_39(address) -> REF_38.referrer,REF_40(Hermes.Investor) -> INVESTORS[REF_39],REF_41(uint256) -> REF_40.stage,TMP_42(bool) = REF_41 <= 2,CONDITION TMP_42,REF_42(Hermes.Investor) -> INVESTORS[nextReferrer],REF_43(address) -> REF_42.referrer,REF_44(Hermes.Investor) -> INVESTORS[REF_43],REF_45(uint256) -> REF_44.stage,TMP_43(uint256) = i + 2,TMP_44(bool) = REF_45 <= TMP_43,CONDITION TMP_44,TMP_45(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['msg.value', '100000000'] ,TMP_46(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.div(uint256,uint256), arguments:['TMP_45', '10000000000'] ,value(uint256) := TMP_46(uint256),REF_48(Hermes.Investor) -> INVESTORS[nextReferrer],REF_49(address) -> REF_48.referrer,REF_50(Hermes.Investor) -> INVESTORS[REF_49],REF_51(uint256) -> REF_50.stage,TMP_47(uint256) = i + 2,REF_51(uint256) (->INVESTORS) := TMP_47(uint256),REF_52(Hermes.Investor) -> INVESTORS[nextReferrer],REF_53(address) -> REF_52.referrer,Transfer dest:REF_53 value:value,REF_55(Hermes.Investor) -> INVESTORS[nextReferrer],REF_56(address) -> REF_55.referrer,REF_57(Hermes.Investor) -> INVESTORS[REF_56],REF_58(uint256) -> REF_57.deposit,TMP_49(bool) = REF_58 >= 5000000000000000000,CONDITION TMP_49,REF_59(Hermes.Investor) -> INVESTORS[nextReferrer],REF_60(address) -> REF_59.referrer,REF_61(Hermes.Investor) -> INVESTORS[REF_60],REF_62(uint256) -> REF_61.stage,TMP_50(uint256) = i + 2,TMP_51(bool) = REF_62 < TMP_50,CONDITION TMP_51,REF_63(Hermes.Investor) -> INVESTORS[nextReferrer],REF_64(address) -> REF_63.referrer,REF_65(Hermes.Investor) -> INVESTORS[REF_64],REF_66(uint256) -> REF_65.stage,TMP_52(uint256) = i + 2,REF_66(uint256) (->INVESTORS) := TMP_52(uint256),TMP_53(uint256) = i + 2,TMP_54(bool) = TMP_53 == 2,CONDITION TMP_54,TMP_55(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['msg.value', '150000000'] ,TMP_56(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.div(uint256,uint256), arguments:['TMP_55', '10000000000'] ,value(uint256) := TMP_56(uint256),TMP_57(uint256) = i + 2,TMP_58(bool) = TMP_57 == 3,CONDITION TMP_58,TMP_59(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['msg.value', '75000000'] ,TMP_60(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.div(uint256,uint256), arguments:['TMP_59', '10000000000'] ,value(uint256) := TMP_60(uint256),TMP_61(uint256) = i + 2,TMP_62(bool) = TMP_61 == 4,CONDITION TMP_62,TMP_63(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['msg.value', '50000000'] ,TMP_64(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.div(uint256,uint256), arguments:['TMP_63', '10000000000'] ,value(uint256) := TMP_64(uint256),TMP_65(uint256) = i + 2,TMP_66(bool) = TMP_65 == 5,CONDITION TMP_66,TMP_67(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['msg.value', '25000000'] ,TMP_68(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.div(uint256,uint256), arguments:['TMP_67', '10000000000'] ,value(uint256) := TMP_68(uint256),REF_75(Hermes.Investor) -> INVESTORS[nextReferrer],REF_76(address) -> REF_75.referrer,Transfer dest:REF_76 value:value,REF_78(Hermes.Investor) -> INVESTORS[nextReferrer],REF_79(address) -> REF_78.referrer,nextReferrer(address) := REF_79(address),TMP_70 = CONVERT 0 to address,TMP_71(bool) = nextReferrer == TMP_70,CONDITION TMP_71,TMP_72(uint256) := i(uint256),i(uint256) = i + 1,TMP_73 = CONVERT 0 to address,_referrer(address) := TMP_73(address),TMP_74 = CONVERT 0 to address,_referrer(address) := TMP_74(address),REF_80(Hermes.Investor) -> INVESTORS[msg.sender],TMP_75(Hermes.Investor) = new Investor(id,0,msg.value,now,_referrer,0,msg.value,0,0,msg.value),REF_80(Hermes.Investor) (->INVESTORS) := TMP_75(Hermes.Investor),TMP_76(uint256) = DAY_VALUE + msg.value,TMP_77(bool) = TMP_76 < DAY_LIMIT,TMP_78(None) = SOLIDITY_CALL require(bool,string)(TMP_77,DAY LIMIT!!!),REF_81(Hermes.Investor) -> INVESTORS[msg.sender],REF_82(uint256) -> REF_81.dayLimitValue,TMP_79(uint256) = REF_82 + msg.value,TMP_80(uint256) = DAY_LIMIT / 2,TMP_81(bool) = TMP_79 < TMP_80,TMP_82(None) = SOLIDITY_CALL require(bool,string)(TMP_81,DAY LIMIT!!!),REF_83(Hermes.Investor) -> INVESTORS[msg.sender],REF_84(uint256) -> REF_83.dayLimitValue,REF_84(-> INVESTORS) = REF_84 + msg.value,DAY_VALUE(uint256) = DAY_VALUE + msg.value,REF_85(Hermes.Investor) -> INVESTORS[msg.sender],REF_86(uint256) -> REF_85.reinvestID,TMP_83(bool) = REF_86 == 3,CONDITION TMP_83,REF_87(Hermes.Investor) -> INVESTORS[msg.sender],REF_88(uint256) -> REF_87.reinvestID,REF_88(uint256) (->INVESTORS) := 0(uint256),REF_89(Hermes.Investor) -> INVESTORS[msg.sender],REF_90(uint256) -> REF_89.deposit,REF_90(-> INVESTORS) = REF_90 + msg.value,REF_91(Hermes.Investor) -> INVESTORS[msg.sender],REF_92(uint256) -> REF_91.actualValue,REF_92(-> INVESTORS) = REF_92 + msg.value,DEPOSIT_AMOUNT(uint256) = DEPOSIT_AMOUNT + msg.value,TMP_84(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['msg.value', 'PERCENT_FOR_MARKETING'] ,TMP_85(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.div(uint256,uint256), arguments:['TMP_84', '10000000000'] ,TMP_86(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['TMP_85', '1'] ,Transfer dest:ADMIN_ADDR value:TMP_86,TMP_88(bool) = msg.value == 12000000000000,CONDITION TMP_88,REF_97(Hermes.Investor) -> INVESTORS[msg.sender],REF_98(uint256) -> REF_97.reinvestID,TMP_89(bool) = REF_98 == 0,TMP_90(None) = SOLIDITY_CALL require(bool,string)(TMP_89,REINVEST BLOCK),REF_99(Hermes.Investor) -> INVESTORS[msg.sender],REF_100(uint256) -> REF_99.reinvestID,REF_100(uint256) (->INVESTORS) := 1(uint256),REF_101(Hermes.Investor) -> INVESTORS[msg.sender],REF_102(uint256) -> REF_101.startReinvestDate,REF_102(uint256) (->INVESTORS) := now(uint256),Emit reinvest(msg.sender,1),TMP_92(bool) = msg.value == 13000000000000,CONDITION TMP_92,interval(uint256) := 0(uint256),interest(uint256) := 0(uint256),REF_103(Hermes.Investor) -> INVESTORS[msg.sender],REF_104(uint256) -> REF_103.reinvestID,TMP_93(bool) = REF_104 == 1,TMP_94(None) = SOLIDITY_CALL require(bool,string)(TMP_93,REINVEST BLOCK),TMP_95(bool) = DEPOSIT_AMOUNT >= 0,TMP_96(bool) = DEPOSIT_AMOUNT < 1000000000000000000000,TMP_97(bool) = TMP_95 && TMP_96,CONDITION TMP_97,interest(uint256) := 125000000(uint256),TMP_98(bool) = DEPOSIT_AMOUNT >= 1000000000000000000000,TMP_99(bool) = DEPOSIT_AMOUNT <= 2000000000000000000000,TMP_100(bool) = TMP_98 && TMP_99,CONDITION TMP_100,interest(uint256) := 100000000(uint256),TMP_101(bool) = DEPOSIT_AMOUNT >= 2000000000000000000000,TMP_102(bool) = DEPOSIT_AMOUNT <= 3000000000000000000000,TMP_103(bool) = TMP_101 && TMP_102,CONDITION TMP_103,interest(uint256) := 75000000(uint256),TMP_104(bool) = DEPOSIT_AMOUNT > 3000000000000000000000,CONDITION TMP_104,interest(uint256) := 60000000(uint256),REF_105(Hermes.Investor) -> INVESTORS[msg.sender],REF_106(uint256) -> REF_105.startReinvestDate,TMP_105(uint256) = now - REF_106,TMP_106(uint256) = TMP_105 / 86400,interval(uint256) := TMP_106(uint256),REF_107(Hermes.Investor) -> INVESTORS[msg.sender],REF_108(uint256) -> REF_107.stage,TMP_107(uint256) = REF_108 * 10000000,TMP_108(uint256) = interest + TMP_107,TMP_109(uint256) = TMP_108 * interval,interest(uint256) := TMP_109(uint256),REF_109(Hermes.Investor) -> INVESTORS[msg.sender],REF_110(uint256) -> REF_109.deposit,TMP_110(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['REF_110', 'interest'] ,TMP_111(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.div(uint256,uint256), arguments:['TMP_110', '10000000000'] ,TMP_112(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['TMP_111', '1'] ,value(uint256) := TMP_112(uint256),REF_114(Hermes.Investor) -> INVESTORS[msg.sender],REF_115(uint256) -> REF_114.percentCount,REF_115(-> INVESTORS) = REF_115 + interest,REF_116(Hermes.Investor) -> INVESTORS[msg.sender],REF_117(uint256) -> REF_116.deposit,REF_117(-> INVESTORS) = REF_117 + value,REF_118(Hermes.Investor) -> INVESTORS[msg.sender],REF_119(uint256) -> REF_118.actualValue,REF_120(Hermes.Investor) -> INVESTORS[msg.sender],REF_121(uint256) -> REF_120.deposit,REF_119(uint256) (->INVESTORS) := REF_121(uint256),REF_122(Hermes.Investor) -> INVESTORS[msg.sender],REF_123(uint256) -> REF_122.reinvestID,REF_123(uint256) (->INVESTORS) := 0(uint256),Emit reinvest(msg.sender,0)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value == 0

IRs:
TMP_8(bool) = msg.value == 0
CONDITION TMP_8""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
msg.sender == ADMIN_ADDR

IRs:
TMP_9(bool) = msg.sender == ADMIN_ADDR
CONDITION TMP_9""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
payAll()

IRs:
INTERNAL_CALL, Hermes.payAll()()""];
3->5;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
paySelfByAddress(msg.sender)

IRs:
INTERNAL_CALL, Hermes.paySelfByAddress(address)(msg.sender)""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->116;
6[label=""Node Type: IF 6

EXPRESSION:
INVESTORS[msg.sender].deposit == 0

IRs:
REF_0(Hermes.Investor) -> INVESTORS[msg.sender]
REF_1(uint256) -> REF_0.deposit
TMP_12(bool) = REF_1 == 0
CONDITION TMP_12""];
6->7[label=""True""];
6->73[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool,string)(DAY_VALUE + msg.value < DAY_LIMIT,DAY LIMIT!!!)

IRs:
TMP_13(uint256) = DAY_VALUE + msg.value
TMP_14(bool) = TMP_13 < DAY_LIMIT
TMP_15(None) = SOLIDITY_CALL require(bool,string)(TMP_14,DAY LIMIT!!!)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
require(bool,string)(INVESTORS[msg.sender].dayLimitValue + msg.value < DAY_LIMIT / 2,DAY LIMIT!!!)

IRs:
REF_2(Hermes.Investor) -> INVESTORS[msg.sender]
REF_3(uint256) -> REF_2.dayLimitValue
TMP_16(uint256) = REF_3 + msg.value
TMP_17(uint256) = DAY_LIMIT / 2
TMP_18(bool) = TMP_16 < TMP_17
TMP_19(None) = SOLIDITY_CALL require(bool,string)(TMP_18,DAY LIMIT!!!)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
INVESTORS[msg.sender].dayLimitValue += msg.value

IRs:
REF_4(Hermes.Investor) -> INVESTORS[msg.sender]
REF_5(uint256) -> REF_4.dayLimitValue
REF_5(-> INVESTORS) = REF_5 + msg.value""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
DAY_VALUE += msg.value

IRs:
DAY_VALUE(uint256) = DAY_VALUE + msg.value""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
ADDRESSES.push(msg.sender)

IRs:
REF_7 -> LENGTH ADDRESSES
TMP_21(uint256) := REF_7(uint256)
TMP_22(uint256) = TMP_21 + 1
REF_7(uint256) (->ADDRESSES) := TMP_22(uint256)
REF_8(address) -> ADDRESSES[TMP_21]
REF_8(address) (->ADDRESSES) := msg.sender(address)""];
11->12;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
id = ADDRESSES.length

IRs:
REF_9 -> LENGTH ADDRESSES
id(uint256) := REF_9(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
ADMIN_ADDR.transfer((msg.value.mul(PERCENT_FOR_MARKETING).div(10000000000)).mul(1))

IRs:
TMP_23(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['msg.value', 'PERCENT_FOR_MARKETING'] 
TMP_24(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.div(uint256,uint256), arguments:['TMP_23', '10000000000'] 
TMP_25(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['TMP_24', '1'] 
Transfer dest:ADMIN_ADDR value:TMP_25""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
DEPOSIT_AMOUNT += msg.value

IRs:
DEPOSIT_AMOUNT(uint256) = DEPOSIT_AMOUNT + msg.value""];
14->15;
15[label=""Node Type: IF 15

EXPRESSION:
msg.value >= MINIMUM_INVEST

IRs:
TMP_27(bool) = msg.value >= MINIMUM_INVEST
CONDITION TMP_27""];
15->16[label=""True""];
15->70[label=""False""];
16[label=""Node Type: IF 16

EXPRESSION:
INVESTORS[_referrer].deposit != 0

IRs:
REF_14(Hermes.Investor) -> INVESTORS[_referrer]
REF_15(uint256) -> REF_14.deposit
TMP_28(bool) = REF_15 != 0
CONDITION TMP_28""];
16->17[label=""True""];
16->68[label=""False""];
17[label=""Node Type: IF 17

EXPRESSION:
INVESTORS[_referrer].deposit >= 3000000000000000000

IRs:
REF_16(Hermes.Investor) -> INVESTORS[_referrer]
REF_17(uint256) -> REF_16.deposit
TMP_29(bool) = REF_17 >= 3000000000000000000
CONDITION TMP_29""];
17->18[label=""True""];
17->25[label=""False""];
18[label=""Node Type: NEW VARIABLE 18

EXPRESSION:
value = (msg.value.mul(200000000).div(10000000000))

IRs:
TMP_30(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['msg.value', '200000000'] 
TMP_31(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.div(uint256,uint256), arguments:['TMP_30', '10000000000'] 
value(uint256) := TMP_31(uint256)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
msg.sender.transfer(value)

IRs:
Transfer dest:msg.sender value:value""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
value = (msg.value.mul(250000000).div(10000000000))

IRs:
TMP_33(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['msg.value', '250000000'] 
TMP_34(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.div(uint256,uint256), arguments:['TMP_33', '10000000000'] 
value(uint256) := TMP_34(uint256)""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
_referrer.transfer(value)

IRs:
Transfer dest:_referrer value:value""];
21->22;
22[label=""Node Type: IF 22

EXPRESSION:
INVESTORS[_referrer].stage < 1

IRs:
REF_24(Hermes.Investor) -> INVESTORS[_referrer]
REF_25(uint256) -> REF_24.stage
TMP_36(bool) = REF_25 < 1
CONDITION TMP_36""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
INVESTORS[_referrer].stage = 1

IRs:
REF_26(Hermes.Investor) -> INVESTORS[_referrer]
REF_27(uint256) -> REF_26.stage
REF_27(uint256) (->INVESTORS) := 1(uint256)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->26;
26[label=""Node Type: NEW VARIABLE 26

EXPRESSION:
nextReferrer = _referrer

IRs:
nextReferrer(address) := _referrer(address)""];
26->29;
27[label=""Node Type: BEGIN_LOOP 27
""];
27->30;
28[label=""Node Type: END_LOOP 28
""];
28->69;
29[label=""Node Type: NEW VARIABLE 29

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
29->27;
30[label=""Node Type: IF_LOOP 30

EXPRESSION:
i < 4

IRs:
TMP_37(bool) = i < 4
CONDITION TMP_37""];
30->31[label=""True""];
30->28[label=""False""];
31[label=""Node Type: IF 31

EXPRESSION:
INVESTORS[nextReferrer].referrer == address(0x0)

IRs:
REF_28(Hermes.Investor) -> INVESTORS[nextReferrer]
REF_29(address) -> REF_28.referrer
TMP_38 = CONVERT 0 to address
TMP_39(bool) = REF_29 == TMP_38
CONDITION TMP_39""];
31->32[label=""True""];
31->33[label=""False""];
32[label=""Node Type: BREAK 32
""];
32->28;
33[label=""Node Type: END_IF 33
""];
33->34;
34[label=""Node Type: IF 34

EXPRESSION:
INVESTORS[INVESTORS[nextReferrer].referrer].reinvestID != 3

IRs:
REF_30(Hermes.Investor) -> INVESTORS[nextReferrer]
REF_31(address) -> REF_30.referrer
REF_32(Hermes.Investor) -> INVESTORS[REF_31]
REF_33(uint256) -> REF_32.reinvestID
TMP_40(bool) = REF_33 != 3
CONDITION TMP_40""];
34->35[label=""True""];
34->62[label=""False""];
35[label=""Node Type: IF 35

EXPRESSION:
INVESTORS[INVESTORS[nextReferrer].referrer].deposit >= 3000000000000000000

IRs:
REF_34(Hermes.Investor) -> INVESTORS[nextReferrer]
REF_35(address) -> REF_34.referrer
REF_36(Hermes.Investor) -> INVESTORS[REF_35]
REF_37(uint256) -> REF_36.deposit
TMP_41(bool) = REF_37 >= 3000000000000000000
CONDITION TMP_41""];
35->36[label=""True""];
35->43[label=""False""];
36[label=""Node Type: IF 36

EXPRESSION:
INVESTORS[INVESTORS[nextReferrer].referrer].stage <= 2

IRs:
REF_38(Hermes.Investor) -> INVESTORS[nextReferrer]
REF_39(address) -> REF_38.referrer
REF_40(Hermes.Investor) -> INVESTORS[REF_39]
REF_41(uint256) -> REF_40.stage
TMP_42(bool) = REF_41 <= 2
CONDITION TMP_42""];
36->37[label=""True""];
36->42[label=""False""];
37[label=""Node Type: IF 37

EXPRESSION:
INVESTORS[INVESTORS[nextReferrer].referrer].stage <= i + 2

IRs:
REF_42(Hermes.Investor) -> INVESTORS[nextReferrer]
REF_43(address) -> REF_42.referrer
REF_44(Hermes.Investor) -> INVESTORS[REF_43]
REF_45(uint256) -> REF_44.stage
TMP_43(uint256) = i + 2
TMP_44(bool) = REF_45 <= TMP_43
CONDITION TMP_44""];
37->38[label=""True""];
37->41[label=""False""];
38[label=""Node Type: EXPRESSION 38

EXPRESSION:
value = (msg.value.mul(100000000).div(10000000000))

IRs:
TMP_45(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['msg.value', '100000000'] 
TMP_46(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.div(uint256,uint256), arguments:['TMP_45', '10000000000'] 
value(uint256) := TMP_46(uint256)""];
38->39;
39[label=""Node Type: EXPRESSION 39

EXPRESSION:
INVESTORS[INVESTORS[nextReferrer].referrer].stage = i + 2

IRs:
REF_48(Hermes.Investor) -> INVESTORS[nextReferrer]
REF_49(address) -> REF_48.referrer
REF_50(Hermes.Investor) -> INVESTORS[REF_49]
REF_51(uint256) -> REF_50.stage
TMP_47(uint256) = i + 2
REF_51(uint256) (->INVESTORS) := TMP_47(uint256)""];
39->40;
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
INVESTORS[nextReferrer].referrer.transfer(value)

IRs:
REF_52(Hermes.Investor) -> INVESTORS[nextReferrer]
REF_53(address) -> REF_52.referrer
Transfer dest:REF_53 value:value""];
40->41;
41[label=""Node Type: END_IF 41
""];
41->42;
42[label=""Node Type: END_IF 42
""];
42->43;
43[label=""Node Type: END_IF 43
""];
43->44;
44[label=""Node Type: IF 44

EXPRESSION:
INVESTORS[INVESTORS[nextReferrer].referrer].deposit >= 5000000000000000000

IRs:
REF_55(Hermes.Investor) -> INVESTORS[nextReferrer]
REF_56(address) -> REF_55.referrer
REF_57(Hermes.Investor) -> INVESTORS[REF_56]
REF_58(uint256) -> REF_57.deposit
TMP_49(bool) = REF_58 >= 5000000000000000000
CONDITION TMP_49""];
44->45[label=""True""];
44->61[label=""False""];
45[label=""Node Type: IF 45

EXPRESSION:
INVESTORS[INVESTORS[nextReferrer].referrer].stage < i + 2

IRs:
REF_59(Hermes.Investor) -> INVESTORS[nextReferrer]
REF_60(address) -> REF_59.referrer
REF_61(Hermes.Investor) -> INVESTORS[REF_60]
REF_62(uint256) -> REF_61.stage
TMP_50(uint256) = i + 2
TMP_51(bool) = REF_62 < TMP_50
CONDITION TMP_51""];
45->46[label=""True""];
45->47[label=""False""];
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
INVESTORS[INVESTORS[nextReferrer].referrer].stage = i + 2

IRs:
REF_63(Hermes.Investor) -> INVESTORS[nextReferrer]
REF_64(address) -> REF_63.referrer
REF_65(Hermes.Investor) -> INVESTORS[REF_64]
REF_66(uint256) -> REF_65.stage
TMP_52(uint256) = i + 2
REF_66(uint256) (->INVESTORS) := TMP_52(uint256)""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: IF 48

EXPRESSION:
i + 2 == 2

IRs:
TMP_53(uint256) = i + 2
TMP_54(bool) = TMP_53 == 2
CONDITION TMP_54""];
48->49[label=""True""];
48->50[label=""False""];
49[label=""Node Type: EXPRESSION 49

EXPRESSION:
value = (msg.value.mul(150000000).div(10000000000))

IRs:
TMP_55(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['msg.value', '150000000'] 
TMP_56(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.div(uint256,uint256), arguments:['TMP_55', '10000000000'] 
value(uint256) := TMP_56(uint256)""];
49->50;
50[label=""Node Type: END_IF 50
""];
50->51;
51[label=""Node Type: IF 51

EXPRESSION:
i + 2 == 3

IRs:
TMP_57(uint256) = i + 2
TMP_58(bool) = TMP_57 == 3
CONDITION TMP_58""];
51->52[label=""True""];
51->53[label=""False""];
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
value = (msg.value.mul(75000000).div(10000000000))

IRs:
TMP_59(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['msg.value', '75000000'] 
TMP_60(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.div(uint256,uint256), arguments:['TMP_59', '10000000000'] 
value(uint256) := TMP_60(uint256)""];
52->53;
53[label=""Node Type: END_IF 53
""];
53->54;
54[label=""Node Type: IF 54

EXPRESSION:
i + 2 == 4

IRs:
TMP_61(uint256) = i + 2
TMP_62(bool) = TMP_61 == 4
CONDITION TMP_62""];
54->55[label=""True""];
54->56[label=""False""];
55[label=""Node Type: EXPRESSION 55

EXPRESSION:
value = (msg.value.mul(50000000).div(10000000000))

IRs:
TMP_63(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['msg.value', '50000000'] 
TMP_64(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.div(uint256,uint256), arguments:['TMP_63', '10000000000'] 
value(uint256) := TMP_64(uint256)""];
55->56;
56[label=""Node Type: END_IF 56
""];
56->57;
57[label=""Node Type: IF 57

EXPRESSION:
i + 2 == 5

IRs:
TMP_65(uint256) = i + 2
TMP_66(bool) = TMP_65 == 5
CONDITION TMP_66""];
57->58[label=""True""];
57->59[label=""False""];
58[label=""Node Type: EXPRESSION 58

EXPRESSION:
value = (msg.value.mul(25000000).div(10000000000))

IRs:
TMP_67(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['msg.value', '25000000'] 
TMP_68(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.div(uint256,uint256), arguments:['TMP_67', '10000000000'] 
value(uint256) := TMP_68(uint256)""];
58->59;
59[label=""Node Type: END_IF 59
""];
59->60;
60[label=""Node Type: EXPRESSION 60

EXPRESSION:
INVESTORS[nextReferrer].referrer.transfer(value)

IRs:
REF_75(Hermes.Investor) -> INVESTORS[nextReferrer]
REF_76(address) -> REF_75.referrer
Transfer dest:REF_76 value:value""];
60->61;
61[label=""Node Type: END_IF 61
""];
61->62;
62[label=""Node Type: END_IF 62
""];
62->63;
63[label=""Node Type: EXPRESSION 63

EXPRESSION:
nextReferrer = INVESTORS[nextReferrer].referrer

IRs:
REF_78(Hermes.Investor) -> INVESTORS[nextReferrer]
REF_79(address) -> REF_78.referrer
nextReferrer(address) := REF_79(address)""];
63->64;
64[label=""Node Type: IF 64

EXPRESSION:
nextReferrer == address(0x0)

IRs:
TMP_70 = CONVERT 0 to address
TMP_71(bool) = nextReferrer == TMP_70
CONDITION TMP_71""];
64->65[label=""True""];
64->66[label=""False""];
65[label=""Node Type: BREAK 65
""];
65->28;
66[label=""Node Type: END_IF 66
""];
66->67;
67[label=""Node Type: EXPRESSION 67

EXPRESSION:
i ++

IRs:
TMP_72(uint256) := i(uint256)
i(uint256) = i + 1""];
67->30;
68[label=""Node Type: EXPRESSION 68

EXPRESSION:
_referrer = address(0x0)

IRs:
TMP_73 = CONVERT 0 to address
_referrer(address) := TMP_73(address)""];
68->69;
69[label=""Node Type: END_IF 69
""];
69->71;
70[label=""Node Type: EXPRESSION 70

EXPRESSION:
_referrer = address(0x0)

IRs:
TMP_74 = CONVERT 0 to address
_referrer(address) := TMP_74(address)""];
70->71;
71[label=""Node Type: END_IF 71
""];
71->72;
72[label=""Node Type: EXPRESSION 72

EXPRESSION:
INVESTORS[msg.sender] = Investor(id,0,msg.value,now,_referrer,0,msg.value,0,0,msg.value)

IRs:
REF_80(Hermes.Investor) -> INVESTORS[msg.sender]
TMP_75(Hermes.Investor) = new Investor(id,0,msg.value,now,_referrer,0,msg.value,0,0,msg.value)
REF_80(Hermes.Investor) (->INVESTORS) := TMP_75(Hermes.Investor)""];
72->115;
73[label=""Node Type: EXPRESSION 73

EXPRESSION:
require(bool,string)(DAY_VALUE + msg.value < DAY_LIMIT,DAY LIMIT!!!)

IRs:
TMP_76(uint256) = DAY_VALUE + msg.value
TMP_77(bool) = TMP_76 < DAY_LIMIT
TMP_78(None) = SOLIDITY_CALL require(bool,string)(TMP_77,DAY LIMIT!!!)""];
73->74;
74[label=""Node Type: EXPRESSION 74

EXPRESSION:
require(bool,string)(INVESTORS[msg.sender].dayLimitValue + msg.value < DAY_LIMIT / 2,DAY LIMIT!!!)

IRs:
REF_81(Hermes.Investor) -> INVESTORS[msg.sender]
REF_82(uint256) -> REF_81.dayLimitValue
TMP_79(uint256) = REF_82 + msg.value
TMP_80(uint256) = DAY_LIMIT / 2
TMP_81(bool) = TMP_79 < TMP_80
TMP_82(None) = SOLIDITY_CALL require(bool,string)(TMP_81,DAY LIMIT!!!)""];
74->75;
75[label=""Node Type: EXPRESSION 75

EXPRESSION:
INVESTORS[msg.sender].dayLimitValue += msg.value

IRs:
REF_83(Hermes.Investor) -> INVESTORS[msg.sender]
REF_84(uint256) -> REF_83.dayLimitValue
REF_84(-> INVESTORS) = REF_84 + msg.value""];
75->76;
76[label=""Node Type: EXPRESSION 76

EXPRESSION:
DAY_VALUE += msg.value

IRs:
DAY_VALUE(uint256) = DAY_VALUE + msg.value""];
76->77;
77[label=""Node Type: IF 77

EXPRESSION:
INVESTORS[msg.sender].reinvestID == 3

IRs:
REF_85(Hermes.Investor) -> INVESTORS[msg.sender]
REF_86(uint256) -> REF_85.reinvestID
TMP_83(bool) = REF_86 == 3
CONDITION TMP_83""];
77->78[label=""True""];
77->79[label=""False""];
78[label=""Node Type: EXPRESSION 78

EXPRESSION:
INVESTORS[msg.sender].reinvestID = 0

IRs:
REF_87(Hermes.Investor) -> INVESTORS[msg.sender]
REF_88(uint256) -> REF_87.reinvestID
REF_88(uint256) (->INVESTORS) := 0(uint256)""];
78->79;
79[label=""Node Type: END_IF 79
""];
79->80;
80[label=""Node Type: EXPRESSION 80

EXPRESSION:
INVESTORS[msg.sender].deposit += msg.value

IRs:
REF_89(Hermes.Investor) -> INVESTORS[msg.sender]
REF_90(uint256) -> REF_89.deposit
REF_90(-> INVESTORS) = REF_90 + msg.value""];
80->81;
81[label=""Node Type: EXPRESSION 81

EXPRESSION:
INVESTORS[msg.sender].actualValue += msg.value

IRs:
REF_91(Hermes.Investor) -> INVESTORS[msg.sender]
REF_92(uint256) -> REF_91.actualValue
REF_92(-> INVESTORS) = REF_92 + msg.value""];
81->82;
82[label=""Node Type: EXPRESSION 82

EXPRESSION:
DEPOSIT_AMOUNT += msg.value

IRs:
DEPOSIT_AMOUNT(uint256) = DEPOSIT_AMOUNT + msg.value""];
82->83;
83[label=""Node Type: EXPRESSION 83

EXPRESSION:
ADMIN_ADDR.transfer((msg.value.mul(PERCENT_FOR_MARKETING).div(10000000000)).mul(1))

IRs:
TMP_84(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['msg.value', 'PERCENT_FOR_MARKETING'] 
TMP_85(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.div(uint256,uint256), arguments:['TMP_84', '10000000000'] 
TMP_86(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['TMP_85', '1'] 
Transfer dest:ADMIN_ADDR value:TMP_86""];
83->84;
84[label=""Node Type: IF 84

EXPRESSION:
msg.value == 12000000000000

IRs:
TMP_88(bool) = msg.value == 12000000000000
CONDITION TMP_88""];
84->85[label=""True""];
84->89[label=""False""];
85[label=""Node Type: EXPRESSION 85

EXPRESSION:
require(bool,string)(INVESTORS[msg.sender].reinvestID == 0,REINVEST BLOCK)

IRs:
REF_97(Hermes.Investor) -> INVESTORS[msg.sender]
REF_98(uint256) -> REF_97.reinvestID
TMP_89(bool) = REF_98 == 0
TMP_90(None) = SOLIDITY_CALL require(bool,string)(TMP_89,REINVEST BLOCK)""];
85->86;
86[label=""Node Type: EXPRESSION 86

EXPRESSION:
INVESTORS[msg.sender].reinvestID = 1

IRs:
REF_99(Hermes.Investor) -> INVESTORS[msg.sender]
REF_100(uint256) -> REF_99.reinvestID
REF_100(uint256) (->INVESTORS) := 1(uint256)""];
86->87;
87[label=""Node Type: EXPRESSION 87

EXPRESSION:
INVESTORS[msg.sender].startReinvestDate = now

IRs:
REF_101(Hermes.Investor) -> INVESTORS[msg.sender]
REF_102(uint256) -> REF_101.startReinvestDate
REF_102(uint256) (->INVESTORS) := now(uint256)""];
87->88;
88[label=""Node Type: EXPRESSION 88

EXPRESSION:
reinvest(msg.sender,1)

IRs:
Emit reinvest(msg.sender,1)""];
88->89;
89[label=""Node Type: END_IF 89
""];
89->90;
90[label=""Node Type: IF 90

EXPRESSION:
msg.value == 13000000000000

IRs:
TMP_92(bool) = msg.value == 13000000000000
CONDITION TMP_92""];
90->91[label=""True""];
90->114[label=""False""];
91[label=""Node Type: NEW VARIABLE 91

EXPRESSION:
interval = 0

IRs:
interval(uint256) := 0(uint256)""];
91->92;
92[label=""Node Type: NEW VARIABLE 92

EXPRESSION:
interest = 0

IRs:
interest(uint256) := 0(uint256)""];
92->93;
93[label=""Node Type: EXPRESSION 93

EXPRESSION:
require(bool,string)(INVESTORS[msg.sender].reinvestID == 1,REINVEST BLOCK)

IRs:
REF_103(Hermes.Investor) -> INVESTORS[msg.sender]
REF_104(uint256) -> REF_103.reinvestID
TMP_93(bool) = REF_104 == 1
TMP_94(None) = SOLIDITY_CALL require(bool,string)(TMP_93,REINVEST BLOCK)""];
93->94;
94[label=""Node Type: IF 94

EXPRESSION:
(DEPOSIT_AMOUNT >= 0) && (DEPOSIT_AMOUNT < 1000000000000000000000)

IRs:
TMP_95(bool) = DEPOSIT_AMOUNT >= 0
TMP_96(bool) = DEPOSIT_AMOUNT < 1000000000000000000000
TMP_97(bool) = TMP_95 && TMP_96
CONDITION TMP_97""];
94->95[label=""True""];
94->96[label=""False""];
95[label=""Node Type: EXPRESSION 95

EXPRESSION:
interest = 125000000

IRs:
interest(uint256) := 125000000(uint256)""];
95->96;
96[label=""Node Type: END_IF 96
""];
96->97;
97[label=""Node Type: IF 97

EXPRESSION:
(DEPOSIT_AMOUNT >= 1000000000000000000000) && (DEPOSIT_AMOUNT <= 2000000000000000000000)

IRs:
TMP_98(bool) = DEPOSIT_AMOUNT >= 1000000000000000000000
TMP_99(bool) = DEPOSIT_AMOUNT <= 2000000000000000000000
TMP_100(bool) = TMP_98 && TMP_99
CONDITION TMP_100""];
97->98[label=""True""];
97->99[label=""False""];
98[label=""Node Type: EXPRESSION 98

EXPRESSION:
interest = 100000000

IRs:
interest(uint256) := 100000000(uint256)""];
98->99;
99[label=""Node Type: END_IF 99
""];
99->100;
100[label=""Node Type: IF 100

EXPRESSION:
(DEPOSIT_AMOUNT >= 2000000000000000000000) && (DEPOSIT_AMOUNT <= 3000000000000000000000)

IRs:
TMP_101(bool) = DEPOSIT_AMOUNT >= 2000000000000000000000
TMP_102(bool) = DEPOSIT_AMOUNT <= 3000000000000000000000
TMP_103(bool) = TMP_101 && TMP_102
CONDITION TMP_103""];
100->101[label=""True""];
100->102[label=""False""];
101[label=""Node Type: EXPRESSION 101

EXPRESSION:
interest = 75000000

IRs:
interest(uint256) := 75000000(uint256)""];
101->102;
102[label=""Node Type: END_IF 102
""];
102->103;
103[label=""Node Type: IF 103

EXPRESSION:
DEPOSIT_AMOUNT > 3000000000000000000000

IRs:
TMP_104(bool) = DEPOSIT_AMOUNT > 3000000000000000000000
CONDITION TMP_104""];
103->104[label=""True""];
103->105[label=""False""];
104[label=""Node Type: EXPRESSION 104

EXPRESSION:
interest = 60000000

IRs:
interest(uint256) := 60000000(uint256)""];
104->105;
105[label=""Node Type: END_IF 105
""];
105->106;
106[label=""Node Type: EXPRESSION 106

EXPRESSION:
interval = (now - INVESTORS[msg.sender].startReinvestDate) / 86400

IRs:
REF_105(Hermes.Investor) -> INVESTORS[msg.sender]
REF_106(uint256) -> REF_105.startReinvestDate
TMP_105(uint256) = now - REF_106
TMP_106(uint256) = TMP_105 / 86400
interval(uint256) := TMP_106(uint256)""];
106->107;
107[label=""Node Type: EXPRESSION 107

EXPRESSION:
interest = (interest + INVESTORS[msg.sender].stage * 10000000) * interval

IRs:
REF_107(Hermes.Investor) -> INVESTORS[msg.sender]
REF_108(uint256) -> REF_107.stage
TMP_107(uint256) = REF_108 * 10000000
TMP_108(uint256) = interest + TMP_107
TMP_109(uint256) = TMP_108 * interval
interest(uint256) := TMP_109(uint256)""];
107->108;
108[label=""Node Type: EXPRESSION 108

EXPRESSION:
value = (INVESTORS[msg.sender].deposit.mul(interest).div(10000000000)).mul(1)

IRs:
REF_109(Hermes.Investor) -> INVESTORS[msg.sender]
REF_110(uint256) -> REF_109.deposit
TMP_110(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['REF_110', 'interest'] 
TMP_111(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.div(uint256,uint256), arguments:['TMP_110', '10000000000'] 
TMP_112(uint256) = LIBRARY_CALL, dest:MathForInterset, function:MathForInterset.mul(uint256,uint256), arguments:['TMP_111', '1'] 
value(uint256) := TMP_112(uint256)""];
108->109;
109[label=""Node Type: EXPRESSION 109

EXPRESSION:
INVESTORS[msg.sender].percentCount += interest

IRs:
REF_114(Hermes.Investor) -> INVESTORS[msg.sender]
REF_115(uint256) -> REF_114.percentCount
REF_115(-> INVESTORS) = REF_115 + interest""];
109->110;
110[label=""Node Type: EXPRESSION 110

EXPRESSION:
INVESTORS[msg.sender].deposit += value

IRs:
REF_116(Hermes.Investor) -> INVESTORS[msg.sender]
REF_117(uint256) -> REF_116.deposit
REF_117(-> INVESTORS) = REF_117 + value""];
110->111;
111[label=""Node Type: EXPRESSION 111

EXPRESSION:
INVESTORS[msg.sender].actualValue = INVESTORS[msg.sender].deposit

IRs:
REF_118(Hermes.Investor) -> INVESTORS[msg.sender]
REF_119(uint256) -> REF_118.actualValue
REF_120(Hermes.Investor) -> INVESTORS[msg.sender]
REF_121(uint256) -> REF_120.deposit
REF_119(uint256) (->INVESTORS) := REF_121(uint256)""];
111->112;
112[label=""Node Type: EXPRESSION 112

EXPRESSION:
INVESTORS[msg.sender].reinvestID = 0

IRs:
REF_122(Hermes.Investor) -> INVESTORS[msg.sender]
REF_123(uint256) -> REF_122.reinvestID
REF_123(uint256) (->INVESTORS) := 0(uint256)""];
112->113;
113[label=""Node Type: EXPRESSION 113

EXPRESSION:
reinvest(msg.sender,0)

IRs:
Emit reinvest(msg.sender,0)""];
113->114;
114[label=""Node Type: END_IF 114
""];
114->115;
115[label=""Node Type: END_IF 115
""];
115->116;
116[label=""Node Type: END_IF 116
""];
}
",0,1,0,0,"msg.value == 0;msg.sender == ADMIN_ADDR;INVESTORS[msg.sender].deposit == 0;payAll();paySelfByAddress(msg.sender);;;require(bool,string)(DAY_VALUE + msg.value < DAY_LIMIT,DAY LIMIT!!!);require(bool,string)(DAY_VALUE + msg.value < DAY_LIMIT,DAY LIMIT!!!);require(bool,string)(INVESTORS[msg.sender].dayLimitValue + msg.value < DAY_LIMIT / 2,DAY LIMIT!!!);INVESTORS[msg.sender].dayLimitValue += msg.value;DAY_VALUE += msg.value;ADDRESSES.push(msg.sender);id = ADDRESSES.length;ADMIN_ADDR.transfer((msg.value.mul(PERCENT_FOR_MARKETING).div(10000000000)).mul(1));DEPOSIT_AMOUNT += msg.value;msg.value >= MINIMUM_INVEST;INVESTORS[_referrer].deposit != 0;_referrer = address(0x0);INVESTORS[_referrer].deposit >= 3000000000000000000;_referrer = address(0x0);value = (msg.value.mul(200000000).div(10000000000));;msg.sender.transfer(value);value = (msg.value.mul(250000000).div(10000000000));_referrer.transfer(value);INVESTORS[_referrer].stage < 1;INVESTORS[_referrer].stage = 1;;nextReferrer = _referrer;i = 0;;i < 4;;;INVESTORS[nextReferrer].referrer == address(0x0);;;INVESTORS[INVESTORS[nextReferrer].referrer].reinvestID != 3;INVESTORS[INVESTORS[nextReferrer].referrer].deposit >= 3000000000000000000;;INVESTORS[INVESTORS[nextReferrer].referrer].stage <= 2;;INVESTORS[INVESTORS[nextReferrer].referrer].stage <= i + 2;;value = (msg.value.mul(100000000).div(10000000000));;INVESTORS[INVESTORS[nextReferrer].referrer].stage = i + 2;INVESTORS[nextReferrer].referrer.transfer(value);INVESTORS[INVESTORS[nextReferrer].referrer].deposit >= 5000000000000000000;INVESTORS[INVESTORS[nextReferrer].referrer].stage < i + 2;;INVESTORS[INVESTORS[nextReferrer].referrer].stage = i + 2;;i + 2 == 2;value = (msg.value.mul(150000000).div(10000000000));;i + 2 == 3;value = (msg.value.mul(75000000).div(10000000000));;i + 2 == 4;value = (msg.value.mul(50000000).div(10000000000));;i + 2 == 5;value = (msg.value.mul(25000000).div(10000000000));;INVESTORS[nextReferrer].referrer.transfer(value);nextReferrer = INVESTORS[nextReferrer].referrer;nextReferrer == address(0x0);;;i ++;;INVESTORS[msg.sender] = Investor(id,0,msg.value,now,_referrer,0,msg.value,0,0,msg.value);;require(bool,string)(INVESTORS[msg.sender].dayLimitValue + msg.value < DAY_LIMIT / 2,DAY LIMIT!!!);INVESTORS[msg.sender].dayLimitValue += msg.value;DAY_VALUE += msg.value;INVESTORS[msg.sender].reinvestID == 3;INVESTORS[msg.sender].reinvestID = 0;;INVESTORS[msg.sender].deposit += msg.value;INVESTORS[msg.sender].actualValue += msg.value;DEPOSIT_AMOUNT += msg.value;ADMIN_ADDR.transfer((msg.value.mul(PERCENT_FOR_MARKETING).div(10000000000)).mul(1));msg.value == 12000000000000;require(bool,string)(INVESTORS[msg.sender].reinvestID == 0,REINVEST BLOCK);;INVESTORS[msg.sender].reinvestID = 1;INVESTORS[msg.sender].startReinvestDate = now;reinvest(msg.sender,1);msg.value == 13000000000000;interval = 0;;interest = 0;require(bool,string)(INVESTORS[msg.sender].reinvestID == 1,REINVEST BLOCK);(DEPOSIT_AMOUNT >= 0) && (DEPOSIT_AMOUNT < 1000000000000000000000);interest = 125000000;;(DEPOSIT_AMOUNT >= 1000000000000000000000) && (DEPOSIT_AMOUNT <= 2000000000000000000000);interest = 100000000;;(DEPOSIT_AMOUNT >= 2000000000000000000000) && (DEPOSIT_AMOUNT <= 3000000000000000000000);interest = 75000000;;DEPOSIT_AMOUNT > 3000000000000000000000;interest = 60000000;;interval = (now - INVESTORS[msg.sender].startReinvestDate) / 86400;interest = (interest + INVESTORS[msg.sender].stage * 10000000) * interval;value = (INVESTORS[msg.sender].deposit.mul(interest).div(10000000000)).mul(1);INVESTORS[msg.sender].percentCount += interest;INVESTORS[msg.sender].deposit += value;INVESTORS[msg.sender].actualValue = INVESTORS[msg.sender].deposit;INVESTORS[msg.sender].reinvestID = 0;reinvest(msg.sender,0)"
./0x009b40aab0ec2d4abd696db7b0cfce5c24eb9114_ext.sol,CAMToken.totalSupply,113,115,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x70e29c7124585a20ede4e78b615d3a3b2b4dad5c_ext.sol,DefensorWallet.transferFrom,103,113,"REF_26(uint256) -> balances[from],TMP_24(bool) = REF_26 >= value,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_27(mapping(address => uint256)) -> allowed[from],REF_28(uint256) -> REF_27[msg.sender],_allowance(uint256) := REF_28(uint256),TMP_26(bool) = _allowance >= value,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_29(uint256) -> balances[to],REF_29(-> balances) = REF_29 + value,REF_30(uint256) -> balances[from],REF_30(-> balances) = REF_30 - value,REF_31(mapping(address => uint256)) -> allowed[from],REF_32(uint256) -> REF_31[msg.sender],REF_32(-> allowed) = REF_32 - value,Emit Transfer(from,to,value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[from] >= value)

IRs:
REF_26(uint256) -> balances[from]
TMP_24(bool) = REF_26 >= value
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
_allowance = allowed[from][msg.sender]

IRs:
REF_27(mapping(address => uint256)) -> allowed[from]
REF_28(uint256) -> REF_27[msg.sender]
_allowance(uint256) := REF_28(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_allowance >= value)

IRs:
TMP_26(bool) = _allowance >= value
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[to] += value

IRs:
REF_29(uint256) -> balances[to]
REF_29(-> balances) = REF_29 + value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[from] -= value

IRs:
REF_30(uint256) -> balances[from]
REF_30(-> balances) = REF_30 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allowed[from][msg.sender] -= value

IRs:
REF_31(mapping(address => uint256)) -> allowed[from]
REF_32(uint256) -> REF_31[msg.sender]
REF_32(-> allowed) = REF_32 - value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(balances[from] >= value);_allowance = allowed[from][msg.sender];require(bool)(_allowance >= value);balances[to] += value;balances[from] -= value;allowed[from][msg.sender] -= value;Transfer(from,to,value);true"
./0x3420894bf786866a09937b0369d5b4781870c21f_ext.sol,LikeCoin.transferAndCall,286,288,"TMP_147(bool) = INTERNAL_CALL, LikeCoin._transferAndCall(address,address,uint256,bytes)(msg.sender,_to,_value,_data),RETURN TMP_147,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_transferAndCall(msg.sender,_to,_value,_data)

IRs:
TMP_147(bool) = INTERNAL_CALL, LikeCoin._transferAndCall(address,address,uint256,bytes)(msg.sender,_to,_value,_data)
RETURN TMP_147""];
2[label=""Node Type: RETURN 2

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"_transferAndCall(msg.sender,_to,_value,_data);success"
./0x1fdedef5c2da1ed9db44d80003a9592dfa18163c_ext.sol,Syndicate.allocateShares,268,273,"TMP_83(bool) = allocation > availableBuyInShares,CONDITION TMP_83,TMP_84(None) = SOLIDITY_CALL revert()(),availableBuyInShares(uint256) = availableBuyInShares - allocation,INTERNAL_CALL, Syndicate.addMember(address)(stakeholderAddress),REF_78(Syndicate.member) -> members[stakeholderAddress],REF_79(uint256) -> REF_78.numShares,REF_79(-> members) = REF_79 + allocation,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: IF 1

EXPRESSION:
allocation > availableBuyInShares

IRs:
TMP_83(bool) = allocation > availableBuyInShares
CONDITION TMP_83""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_84(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
availableBuyInShares -= allocation

IRs:
availableBuyInShares(uint256) = availableBuyInShares - allocation""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
addMember(stakeholderAddress)

IRs:
INTERNAL_CALL, Syndicate.addMember(address)(stakeholderAddress)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
members[stakeholderAddress].numShares += allocation

IRs:
REF_78(Syndicate.member) -> members[stakeholderAddress]
REF_79(uint256) -> REF_78.numShares
REF_79(-> members) = REF_79 + allocation""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->1;
}
",0,1,0,0,onlyOwner();allocation > availableBuyInShares;revert()();;availableBuyInShares -= allocation;addMember(stakeholderAddress);members[stakeholderAddress].numShares += allocation
./0x5287b19bf61a4f9375d1f6624565db164bcb0208_ext.sol,ARBITRAGING.totalSupply,175,177,"TMP_53 = CONVERT 0 to address,REF_24(uint256) -> tokenBalances[TMP_53],TMP_54(uint256) = totalSupply - REF_24,RETURN TMP_54","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
totalSupply - tokenBalances[address(0)]

IRs:
TMP_53 = CONVERT 0 to address
REF_24(uint256) -> tokenBalances[TMP_53]
TMP_54(uint256) = totalSupply - REF_24
RETURN TMP_54""];
}
",0,1,0,0,totalSupply - tokenBalances[address(0)]
./0x03684715e3a614ec80d1b31b62987e0b25925999_ext.sol,GWGFPLUS.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x0669398307efefb60030ff328a0cb6a3a840182c_ext.sol,CelerNetwork.approveAndCall,204,209,"REF_18(mapping(address => uint256)) -> allowed[msg.sender],REF_19(uint256) -> REF_18[spender],REF_19(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_18(mapping(address => uint256)) -> allowed[msg.sender]
REF_19(uint256) -> REF_18[spender]
REF_19(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x5b29a6277c996b477d6632e60eef41268311ce1c_ext.sol,Dragon.burn,146,152,"REF_24(uint256) -> balanceOf[msg.sender],TMP_20(bool) = REF_24 < _value,CONDITION TMP_20,REF_25(uint256) -> balanceOf[msg.sender],REF_25(-> balanceOf) = REF_25 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balanceOf[msg.sender] < _value

IRs:
REF_24(uint256) -> balanceOf[msg.sender]
TMP_20(bool) = REF_24 < _value
CONDITION TMP_20""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_25(uint256) -> balanceOf[msg.sender]
REF_25(-> balanceOf) = REF_25 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balanceOf[msg.sender] < _value;;;balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x37d9033151eaf64cea6b7531ee0e4fd6f6f9d6d0_ext.sol,EthCrystal._currentPlayerAmountUnclaimed,308,319,"TMP_122(bool) = _RoundID == 0,CONDITION TMP_122,REF_258(EthCrystal.TowersInfoList) -> GameRounds[_TowerType],REF_259(uint256) -> REF_258.currentRoundID,_RoundID(uint256) := REF_259(uint256),REF_260(EthCrystal.PlayerInfo) -> players[_playerAddress],REF_261(mapping(uint256 => EthCrystal.TowersRoundInfo)) -> REF_260.TowersList,REF_262(EthCrystal.TowersRoundInfo) -> REF_261[_TowerType],REF_263(mapping(uint256 => EthCrystal.PlayerRoundInfo)) -> REF_262.RoundList,REF_264(EthCrystal.PlayerRoundInfo) -> REF_263[_RoundID],REF_265(uint256) -> REF_264.warriors,_warriors(uint256) := REF_265(uint256),REF_266(EthCrystal.TowersInfoList) -> GameRounds[_TowerType],REF_267(mapping(uint256 => EthCrystal.TowersInfo)) -> REF_266.RoundList,REF_268(EthCrystal.TowersInfo) -> REF_267[_RoundID],REF_269(uint256) -> REF_268.towerBalance,TMP_123(uint256) = _warriors * REF_269,REF_270(EthCrystal.TowersInfoList) -> GameRounds[_TowerType],REF_271(uint256) -> REF_270.dividendShare,TMP_124(uint256) = TMP_123 * REF_271,REF_272(EthCrystal.TowersInfoList) -> GameRounds[_TowerType],REF_273(mapping(uint256 => EthCrystal.TowersInfo)) -> REF_272.RoundList,REF_274(EthCrystal.TowersInfo) -> REF_273[_RoundID],REF_275(uint256) -> REF_274.totalWarriors,TMP_125(uint256) = TMP_124 / REF_275,TMP_126(uint256) = TMP_125 / 100,_totalForCashOut(uint256) := TMP_126(uint256),REF_276(EthCrystal.PlayerInfo) -> players[_playerAddress],REF_277(mapping(uint256 => EthCrystal.TowersRoundInfo)) -> REF_276.TowersList,REF_278(EthCrystal.TowersRoundInfo) -> REF_277[_TowerType],REF_279(mapping(uint256 => EthCrystal.PlayerRoundInfo)) -> REF_278.RoundList,REF_280(EthCrystal.PlayerRoundInfo) -> REF_279[_RoundID],REF_281(uint256) -> REF_280.cashedOut,TMP_127(uint256) = _totalForCashOut - REF_281,_unclaimedAmount(uint256) := TMP_127(uint256),RETURN _unclaimedAmount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_RoundID == 0

IRs:
TMP_122(bool) = _RoundID == 0
CONDITION TMP_122""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_RoundID = GameRounds[_TowerType].currentRoundID

IRs:
REF_258(EthCrystal.TowersInfoList) -> GameRounds[_TowerType]
REF_259(uint256) -> REF_258.currentRoundID
_RoundID(uint256) := REF_259(uint256)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
_warriors = players[_playerAddress].TowersList[_TowerType].RoundList[_RoundID].warriors

IRs:
REF_260(EthCrystal.PlayerInfo) -> players[_playerAddress]
REF_261(mapping(uint256 => EthCrystal.TowersRoundInfo)) -> REF_260.TowersList
REF_262(EthCrystal.TowersRoundInfo) -> REF_261[_TowerType]
REF_263(mapping(uint256 => EthCrystal.PlayerRoundInfo)) -> REF_262.RoundList
REF_264(EthCrystal.PlayerRoundInfo) -> REF_263[_RoundID]
REF_265(uint256) -> REF_264.warriors
_warriors(uint256) := REF_265(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
_totalForCashOut = (_warriors * GameRounds[_TowerType].RoundList[_RoundID].towerBalance * GameRounds[_TowerType].dividendShare / GameRounds[_TowerType].RoundList[_RoundID].totalWarriors / 100)

IRs:
REF_266(EthCrystal.TowersInfoList) -> GameRounds[_TowerType]
REF_267(mapping(uint256 => EthCrystal.TowersInfo)) -> REF_266.RoundList
REF_268(EthCrystal.TowersInfo) -> REF_267[_RoundID]
REF_269(uint256) -> REF_268.towerBalance
TMP_123(uint256) = _warriors * REF_269
REF_270(EthCrystal.TowersInfoList) -> GameRounds[_TowerType]
REF_271(uint256) -> REF_270.dividendShare
TMP_124(uint256) = TMP_123 * REF_271
REF_272(EthCrystal.TowersInfoList) -> GameRounds[_TowerType]
REF_273(mapping(uint256 => EthCrystal.TowersInfo)) -> REF_272.RoundList
REF_274(EthCrystal.TowersInfo) -> REF_273[_RoundID]
REF_275(uint256) -> REF_274.totalWarriors
TMP_125(uint256) = TMP_124 / REF_275
TMP_126(uint256) = TMP_125 / 100
_totalForCashOut(uint256) := TMP_126(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
_unclaimedAmount = _totalForCashOut - players[_playerAddress].TowersList[_TowerType].RoundList[_RoundID].cashedOut

IRs:
REF_276(EthCrystal.PlayerInfo) -> players[_playerAddress]
REF_277(mapping(uint256 => EthCrystal.TowersRoundInfo)) -> REF_276.TowersList
REF_278(EthCrystal.TowersRoundInfo) -> REF_277[_TowerType]
REF_279(mapping(uint256 => EthCrystal.PlayerRoundInfo)) -> REF_278.RoundList
REF_280(EthCrystal.PlayerRoundInfo) -> REF_279[_RoundID]
REF_281(uint256) -> REF_280.cashedOut
TMP_127(uint256) = _totalForCashOut - REF_281
_unclaimedAmount(uint256) := TMP_127(uint256)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
(_unclaimedAmount)

IRs:
RETURN _unclaimedAmount""];
}
",0,1,0,0,_RoundID == 0;_RoundID = GameRounds[_TowerType].currentRoundID;;_warriors = players[_playerAddress].TowersList[_TowerType].RoundList[_RoundID].warriors;_totalForCashOut = (_warriors * GameRounds[_TowerType].RoundList[_RoundID].towerBalance * GameRounds[_TowerType].dividendShare / GameRounds[_TowerType].RoundList[_RoundID].totalWarriors / 100);_unclaimedAmount = _totalForCashOut - players[_playerAddress].TowersList[_TowerType].RoundList[_RoundID].cashedOut;(_unclaimedAmount)
./0x6f328f0a7cd638cda9fed876abf71423ca109fe1_ext.sol,TokenERC20.mintToken,189,194,"REF_32(uint256) -> balanceOf[target],REF_32(-> balanceOf) = REF_32 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_32(uint256) -> balanceOf[target]
REF_32(-> balanceOf) = REF_32 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x454a5244556e044ad6ecfcf3f59290fae47484e8_ext.sol,Data.addBalance,270,272,"REF_82(uint256) -> balances[_addr],REF_82(-> balances) = REF_82 + amount,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances[_addr] += amount

IRs:
REF_82(uint256) -> balances[_addr]
REF_82(-> balances) = REF_82 + amount""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,1,0,0,onlyOwner();balances[_addr] += amount
./0x6ec2e2e2bd43d4deaa883533f80ea61682236073_ext.sol,HACHIKO.burnFrom,160,168,"REF_19(uint256) -> balanceOf[_from],TMP_35(bool) = REF_19 >= _value,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_37(bool) = _value <= REF_21,TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_35(bool) = REF_19 >= _value
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_37(bool) = _value <= REF_21
TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x5409fcd56836e0e0459c12ab45e7ef23c6094bed_ext.sol,RedExchange.dividendsOf,603,609,"REF_52(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_107(uint256) = profitPerShare_ * REF_52,TMP_108 = CONVERT TMP_107 to int256,REF_53(int256) -> payoutsTo_[_customerAddress],TMP_109(int256) = TMP_108 - REF_53,TMP_110 = CONVERT TMP_109 to uint256,TMP_111(uint256) = TMP_110 / magnitude,RETURN TMP_111","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_52(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_107(uint256) = profitPerShare_ * REF_52
TMP_108 = CONVERT TMP_107 to int256
REF_53(int256) -> payoutsTo_[_customerAddress]
TMP_109(int256) = TMP_108 - REF_53
TMP_110 = CONVERT TMP_109 to uint256
TMP_111(uint256) = TMP_110 / magnitude
RETURN TMP_111""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x6f2deef18421ba39065223b23ef38666b3052a46_ext.sol,Marine.fallback,94,102,"TMP_70(uint256) = ethInWei + msg.value,ethInWei(uint256) := TMP_70(uint256),TMP_71(uint256) = msg.value * MRNToEth,amount(uint256) := TMP_71(uint256),REF_93(uint256) -> balances[devWallet],TMP_72(bool) = REF_93 < amount,CONDITION TMP_72,REF_94(uint256) -> balances[devWallet],REF_95(uint256) -> balances[devWallet],TMP_73(uint256) = REF_95 - amount,REF_94(uint256) (->balances) := TMP_73(uint256),REF_96(uint256) -> balances[msg.sender],REF_97(uint256) -> balances[msg.sender],TMP_74(uint256) = REF_97 + amount,REF_96(uint256) (->balances) := TMP_74(uint256),Emit Transfer(devWallet,msg.sender,amount),TMP_76 = SEND dest:devWallet value:msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ethInWei = ethInWei + msg.value

IRs:
TMP_70(uint256) = ethInWei + msg.value
ethInWei(uint256) := TMP_70(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = msg.value * MRNToEth

IRs:
TMP_71(uint256) = msg.value * MRNToEth
amount(uint256) := TMP_71(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
balances[devWallet] < amount

IRs:
REF_93(uint256) -> balances[devWallet]
TMP_72(bool) = REF_93 < amount
CONDITION TMP_72""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: RETURN 4
""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[devWallet] = balances[devWallet] - amount

IRs:
REF_94(uint256) -> balances[devWallet]
REF_95(uint256) -> balances[devWallet]
TMP_73(uint256) = REF_95 - amount
REF_94(uint256) (->balances) := TMP_73(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[msg.sender] = balances[msg.sender] + amount

IRs:
REF_96(uint256) -> balances[msg.sender]
REF_97(uint256) -> balances[msg.sender]
TMP_74(uint256) = REF_97 + amount
REF_96(uint256) (->balances) := TMP_74(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(devWallet,msg.sender,amount)

IRs:
Emit Transfer(devWallet,msg.sender,amount)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
devWallet.send(msg.value)

IRs:
TMP_76 = SEND dest:devWallet value:msg.value""];
}
",0,1,0,0,"ethInWei = ethInWei + msg.value;amount = msg.value * MRNToEth;balances[devWallet] < amount;;;balances[devWallet] = balances[devWallet] - amount;balances[msg.sender] = balances[msg.sender] + amount;Transfer(devWallet,msg.sender,amount);devWallet.send(msg.value)"
./0xbdae4cb65e1c68cd9cd41b73c93ae3d331acad5c_ext.sol,Vote.registerCandidate,72,76,"TMP_14(uint256) := nextCandidateId(uint256),nextCandidateId(uint256) = nextCandidateId + 1,candidateId(uint256) := TMP_14(uint256),REF_4(Vote.Candidate) -> candidateDirectory[candidateId],TMP_15(Vote.Candidate) = new Candidate(candidateId,candidateName,candidateDescription),REF_4(Vote.Candidate) (->candidateDirectory) := TMP_15(Vote.Candidate),Emit CandidateRegistered(candidateId,candidateName,candidateDescription),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
candidateId = nextCandidateId ++

IRs:
TMP_14(uint256) := nextCandidateId(uint256)
nextCandidateId(uint256) = nextCandidateId + 1
candidateId(uint256) := TMP_14(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
candidateDirectory[candidateId] = Candidate(candidateId,candidateName,candidateDescription)

IRs:
REF_4(Vote.Candidate) -> candidateDirectory[candidateId]
TMP_15(Vote.Candidate) = new Candidate(candidateId,candidateName,candidateDescription)
REF_4(Vote.Candidate) (->candidateDirectory) := TMP_15(Vote.Candidate)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
CandidateRegistered(candidateId,candidateName,candidateDescription)

IRs:
Emit CandidateRegistered(candidateId,candidateName,candidateDescription)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->1;
}
",0,1,0,0,"onlyOwner();candidateId = nextCandidateId ++;candidateDirectory[candidateId] = Candidate(candidateId,candidateName,candidateDescription);CandidateRegistered(candidateId,candidateName,candidateDescription)"
./0x1c242bc9af8aa768a54222ed47bb756f1a1a757b_ext.sol,SafeMath.add,50,55,"TMP_9(uint256) = _a + _b,c(uint256) := TMP_9(uint256),TMP_10(bool) = c >= _a,TMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10),RETURN c","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
c = _a + _b

IRs:
TMP_9(uint256) = _a + _b
c(uint256) := TMP_9(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= _a)

IRs:
TMP_10(bool) = c >= _a
TMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c""];
}
",0,1,0,0,c = _a + _b;assert(bool)(c >= _a);c
./0x2a8cef60776d931eb1200aa2a9877eb091cb34a7_ext.sol,TTC.transfer,44,50,"REF_2(uint256) -> balances[msg.sender],TMP_0(bool) = REF_2 >= _value,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_3(uint256) -> balances[msg.sender],REF_3(-> balances) = REF_3 - _value,REF_4(uint256) -> balances[_to],REF_4(-> balances) = REF_4 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_2(uint256) -> balances[msg.sender]
TMP_0(bool) = REF_2 >= _value
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_3(uint256) -> balances[msg.sender]
REF_3(-> balances) = REF_3 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_4(uint256) -> balances[_to]
REF_4(-> balances) = REF_4 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0x548d32216d01617452892ea360bfce9ce8dc9729_ext.sol,ChemistryBase._transfer,205,218,"REF_2(uint256) -> ownersTokenCount[_to],TMP_39(uint256) := REF_2(uint256),REF_2(-> ownersTokenCount) = REF_2 + 1,REF_3(address) -> elementToOwner[_tokenId],REF_3(address) (->elementToOwner) := _to(address),TMP_40 = CONVERT 0 to address,TMP_41(bool) = _from != TMP_40,CONDITION TMP_41,REF_4(uint256) -> ownersTokenCount[_from],TMP_42(uint256) := REF_4(uint256),REF_4(-> ownersTokenCount) = REF_4 - 1,REF_5(address) -> elementToApproved[_tokenId],elementToApproved = delete REF_5 ,Emit Transfer(_from,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownersTokenCount[_to] ++

IRs:
REF_2(uint256) -> ownersTokenCount[_to]
TMP_39(uint256) := REF_2(uint256)
REF_2(-> ownersTokenCount) = REF_2 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
elementToOwner[_tokenId] = _to

IRs:
REF_3(address) -> elementToOwner[_tokenId]
REF_3(address) (->elementToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_40 = CONVERT 0 to address
TMP_41(bool) = _from != TMP_40
CONDITION TMP_41""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownersTokenCount[_from] --

IRs:
REF_4(uint256) -> ownersTokenCount[_from]
TMP_42(uint256) := REF_4(uint256)
REF_4(-> ownersTokenCount) = REF_4 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete elementToApproved[_tokenId]

IRs:
REF_5(address) -> elementToApproved[_tokenId]
elementToApproved = delete REF_5 ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
}
",0,1,0,0,"ownersTokenCount[_to] ++;elementToOwner[_tokenId] = _to;_from != address(0);ownersTokenCount[_from] --;;delete elementToApproved[_tokenId];Transfer(_from,_to,_tokenId)"
./0xa42c5aa9735eca0db714f02de9dc2a56e405dae7_ext.sol,BCT.transferReward,245,257,"REF_39(bool) -> frozen[msg.sender],TMP_58 = UnaryType.BANG REF_39 ,TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58),REF_40(mapping(address => uint256)) -> lockedRewardsOf[msg.sender],REF_41(uint256) -> REF_40[_to],TMP_60(bool) = REF_41 >= _value,TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60),REF_42(uint256) -> totalLockedRewardsOf[msg.sender],TMP_62(bool) = REF_42 >= _value,TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62),REF_43(uint256) = SOLIDITY_CALL balance(address)(msg.sender),TMP_64(bool) = REF_43 < minBalanceForAccounts,CONDITION TMP_64,REF_44(uint256) = SOLIDITY_CALL balance(address)(msg.sender),TMP_65(uint256) = minBalanceForAccounts - REF_44,TMP_66(uint256) = TMP_65 * sellPrice,TMP_67(uint256) = INTERNAL_CALL, BCT.sell(uint256)(TMP_66),REF_45(uint256) -> totalLockedRewardsOf[msg.sender],REF_45(-> totalLockedRewardsOf) = REF_45 - _value,REF_46(mapping(address => uint256)) -> lockedRewardsOf[msg.sender],REF_47(uint256) -> REF_46[_to],REF_47(-> lockedRewardsOf) = REF_47 - _value,REF_48(uint256) -> balanceOf[_to],REF_48(-> balanceOf) = REF_48 + _value,Emit Transfer(msg.sender,_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! frozen[msg.sender])

IRs:
REF_39(bool) -> frozen[msg.sender]
TMP_58 = UnaryType.BANG REF_39 
TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(lockedRewardsOf[msg.sender][_to] >= _value)

IRs:
REF_40(mapping(address => uint256)) -> lockedRewardsOf[msg.sender]
REF_41(uint256) -> REF_40[_to]
TMP_60(bool) = REF_41 >= _value
TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(totalLockedRewardsOf[msg.sender] >= _value)

IRs:
REF_42(uint256) -> totalLockedRewardsOf[msg.sender]
TMP_62(bool) = REF_42 >= _value
TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
msg.sender.balance < minBalanceForAccounts

IRs:
REF_43(uint256) = SOLIDITY_CALL balance(address)(msg.sender)
TMP_64(bool) = REF_43 < minBalanceForAccounts
CONDITION TMP_64""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
sell((minBalanceForAccounts - msg.sender.balance) * sellPrice)

IRs:
REF_44(uint256) = SOLIDITY_CALL balance(address)(msg.sender)
TMP_65(uint256) = minBalanceForAccounts - REF_44
TMP_66(uint256) = TMP_65 * sellPrice
TMP_67(uint256) = INTERNAL_CALL, BCT.sell(uint256)(TMP_66)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
totalLockedRewardsOf[msg.sender] -= _value

IRs:
REF_45(uint256) -> totalLockedRewardsOf[msg.sender]
REF_45(-> totalLockedRewardsOf) = REF_45 - _value""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
lockedRewardsOf[msg.sender][_to] -= _value

IRs:
REF_46(mapping(address => uint256)) -> lockedRewardsOf[msg.sender]
REF_47(uint256) -> REF_46[_to]
REF_47(-> lockedRewardsOf) = REF_47 - _value""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_48(uint256) -> balanceOf[_to]
REF_48(-> balanceOf) = REF_48 + _value""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
}
",0,1,0,0,"require(bool)(! frozen[msg.sender]);require(bool)(lockedRewardsOf[msg.sender][_to] >= _value);require(bool)(totalLockedRewardsOf[msg.sender] >= _value);msg.sender.balance < minBalanceForAccounts;sell((minBalanceForAccounts - msg.sender.balance) * sellPrice);;totalLockedRewardsOf[msg.sender] -= _value;lockedRewardsOf[msg.sender][_to] -= _value;balanceOf[_to] += _value;Transfer(msg.sender,_to,_value)"
./0x0dea9b8e6bf08d6859e29256942916f0cfb884fb_ext.sol,CryptoAllStars._transfer,358,373,"REF_41(uint256) -> ownershipTokenCount[_to],TMP_94(uint256) := REF_41(uint256),REF_41(-> ownershipTokenCount) = REF_41 + 1,REF_42(address) -> personIndexToOwner[_tokenId],REF_42(address) (->personIndexToOwner) := _to(address),TMP_95 = CONVERT 0 to address,TMP_96(bool) = _from != TMP_95,CONDITION TMP_96,REF_43(uint256) -> ownershipTokenCount[_from],TMP_97(uint256) := REF_43(uint256),REF_43(-> ownershipTokenCount) = REF_43 - 1,REF_44(address) -> personIndexToApproved[_tokenId],personIndexToApproved = delete REF_44 ,Emit Transfer(_from,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownershipTokenCount[_to] ++

IRs:
REF_41(uint256) -> ownershipTokenCount[_to]
TMP_94(uint256) := REF_41(uint256)
REF_41(-> ownershipTokenCount) = REF_41 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
personIndexToOwner[_tokenId] = _to

IRs:
REF_42(address) -> personIndexToOwner[_tokenId]
REF_42(address) (->personIndexToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_95 = CONVERT 0 to address
TMP_96(bool) = _from != TMP_95
CONDITION TMP_96""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownershipTokenCount[_from] --

IRs:
REF_43(uint256) -> ownershipTokenCount[_from]
TMP_97(uint256) := REF_43(uint256)
REF_43(-> ownershipTokenCount) = REF_43 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete personIndexToApproved[_tokenId]

IRs:
REF_44(address) -> personIndexToApproved[_tokenId]
personIndexToApproved = delete REF_44 ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
}
",0,1,0,0,"ownershipTokenCount[_to] ++;personIndexToOwner[_tokenId] = _to;_from != address(0);ownershipTokenCount[_from] --;;delete personIndexToApproved[_tokenId];Transfer(_from,_to,_tokenId)"
./0xb42f5366792ed7c08995451c1a93780b7554762b_ext.sol,MyAdvancedToken.mintToken,261,266,"REF_63(uint256) -> balanceOf[target],REF_63(-> balanceOf) = REF_63 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, developed.onlyDeveloper()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_63(uint256) -> balanceOf[target]
REF_63(-> balanceOf) = REF_63 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyDeveloper()

IRs:
MODIFIER_CALL, developed.onlyDeveloper()()""];
5->1;
}
",0,1,0,0,"onlyDeveloper();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x9222740a4351abda9d83f3c7165c556e802f920e_ext.sol,StandardToken.transfer,89,100,"TMP_56(bool) = INTERNAL_CALL, StandardToken.transfer(address,uint256,bytes)(_to,_value,_empty),RETURN TMP_56,TMP_57(uint256) = 2 * 32,MODIFIER_CALL, StandardToken.onlyPayloadSize(uint256)(TMP_57),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
transfer(_to,_value,_empty)

IRs:
TMP_56(bool) = INTERNAL_CALL, StandardToken.transfer(address,uint256,bytes)(_to,_value,_empty)
RETURN TMP_56""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyPayloadSize(2 * 32)

IRs:
TMP_57(uint256) = 2 * 32
MODIFIER_CALL, StandardToken.onlyPayloadSize(uint256)(TMP_57)""];
3->1;
4[label=""Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"onlyPayloadSize(2 * 32);;transfer(_to,_value,_empty);success"
./0x35fd00d47202b1b2158dba75e7cc8f71b068c256_ext.sol,WhiteList.removeFromWhiteList,147,154,"REF_1(bool) -> whiteList[_user],TMP_42(bool) = REF_1 == True,TMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42),REF_2(bool) -> whiteList[_user],REF_2(bool) (->whiteList) := False(bool),TMP_44(uint256) := totalWhiteListed(uint256),totalWhiteListed(uint256) = totalWhiteListed - 1,Emit LogRemoveWhiteListed(_user),RETURN True,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(whiteList[_user] == true)

IRs:
REF_1(bool) -> whiteList[_user]
TMP_42(bool) = REF_1 == True
TMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
whiteList[_user] = false

IRs:
REF_2(bool) -> whiteList[_user]
REF_2(bool) (->whiteList) := False(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalWhiteListed --

IRs:
TMP_44(uint256) := totalWhiteListed(uint256)
totalWhiteListed(uint256) = totalWhiteListed - 1""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
LogRemoveWhiteListed(_user)

IRs:
Emit LogRemoveWhiteListed(_user)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",0,1,0,0,onlyOwner();require(bool)(whiteList[_user] == true);whiteList[_user] = false;totalWhiteListed --;LogRemoveWhiteListed(_user);true
./0xd41d48be0a81690a785bf1df336163f7b78eadca_ext.sol,Crypland.calcElementCurrentPrice,221,240,"price(uint256) := 0(uint256),REF_163(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group],REF_164(mapping(uint256 => Crypland.Offer)) -> REF_163[asset],REF_165(Crypland.Offer) -> REF_164[unit],REF_166(bool) -> REF_165.isOffer,CONDITION REF_166,REF_167(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group],REF_168(mapping(uint256 => Crypland.Offer)) -> REF_167[asset],REF_169(Crypland.Offer) -> REF_168[unit],REF_170(uint256) -> REF_169.endBlock,TMP_140(bool) = block.number >= REF_170,CONDITION TMP_140,REF_171(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group],REF_172(mapping(uint256 => Crypland.Offer)) -> REF_171[asset],REF_173(Crypland.Offer) -> REF_172[unit],REF_174(uint256) -> REF_173.endPrice,price(uint256) := REF_174(uint256),REF_175(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group],REF_176(mapping(uint256 => Crypland.Offer)) -> REF_175[asset],REF_177(Crypland.Offer) -> REF_176[unit],REF_178(uint256) -> REF_177.startBlock,TMP_141(bool) = block.number <= REF_178,CONDITION TMP_141,REF_179(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group],REF_180(mapping(uint256 => Crypland.Offer)) -> REF_179[asset],REF_181(Crypland.Offer) -> REF_180[unit],REF_182(uint256) -> REF_181.startPrice,price(uint256) := REF_182(uint256),REF_183(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group],REF_184(mapping(uint256 => Crypland.Offer)) -> REF_183[asset],REF_185(Crypland.Offer) -> REF_184[unit],REF_186(uint256) -> REF_185.endPrice,REF_187(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group],REF_188(mapping(uint256 => Crypland.Offer)) -> REF_187[asset],REF_189(Crypland.Offer) -> REF_188[unit],REF_190(uint256) -> REF_189.startPrice,TMP_142(bool) = REF_186 == REF_190,CONDITION TMP_142,REF_191(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group],REF_192(mapping(uint256 => Crypland.Offer)) -> REF_191[asset],REF_193(Crypland.Offer) -> REF_192[unit],REF_194(uint256) -> REF_193.endPrice,price(uint256) := REF_194(uint256),REF_195(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group],REF_196(mapping(uint256 => Crypland.Offer)) -> REF_195[asset],REF_197(Crypland.Offer) -> REF_196[unit],REF_198(uint256) -> REF_197.startBlock,TMP_143(uint256) = block.number - REF_198,currentBlockChange(uint256) := TMP_143(uint256),REF_199(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group],REF_200(mapping(uint256 => Crypland.Offer)) -> REF_199[asset],REF_201(Crypland.Offer) -> REF_200[unit],REF_202(uint256) -> REF_201.endBlock,REF_203(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group],REF_204(mapping(uint256 => Crypland.Offer)) -> REF_203[asset],REF_205(Crypland.Offer) -> REF_204[unit],REF_206(uint256) -> REF_205.startBlock,TMP_144(uint256) = REF_202 - REF_206,totalBlockChange(uint256) := TMP_144(uint256),REF_207(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group],REF_208(mapping(uint256 => Crypland.Offer)) -> REF_207[asset],REF_209(Crypland.Offer) -> REF_208[unit],REF_210(uint256) -> REF_209.startPrice,REF_211(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group],REF_212(mapping(uint256 => Crypland.Offer)) -> REF_211[asset],REF_213(Crypland.Offer) -> REF_212[unit],REF_214(uint256) -> REF_213.endPrice,TMP_145(uint256) = REF_210 - REF_214,totalPriceChange(uint256) := TMP_145(uint256),TMP_146(uint256) = currentBlockChange * totalPriceChange,TMP_147(uint256) = TMP_146 / totalBlockChange,currentPriceChange(uint256) := TMP_147(uint256),REF_215(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group],REF_216(mapping(uint256 => Crypland.Offer)) -> REF_215[asset],REF_217(Crypland.Offer) -> REF_216[unit],REF_218(uint256) -> REF_217.startPrice,TMP_148(uint256) = REF_218 - currentPriceChange,price(uint256) := TMP_148(uint256),RETURN price","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
price = 0

IRs:
price(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
offers[group][asset][unit].isOffer

IRs:
REF_163(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group]
REF_164(mapping(uint256 => Crypland.Offer)) -> REF_163[asset]
REF_165(Crypland.Offer) -> REF_164[unit]
REF_166(bool) -> REF_165.isOffer
CONDITION REF_166""];
2->3[label=""True""];
2->17[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
block.number >= offers[group][asset][unit].endBlock

IRs:
REF_167(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group]
REF_168(mapping(uint256 => Crypland.Offer)) -> REF_167[asset]
REF_169(Crypland.Offer) -> REF_168[unit]
REF_170(uint256) -> REF_169.endBlock
TMP_140(bool) = block.number >= REF_170
CONDITION TMP_140""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
price = offers[group][asset][unit].endPrice

IRs:
REF_171(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group]
REF_172(mapping(uint256 => Crypland.Offer)) -> REF_171[asset]
REF_173(Crypland.Offer) -> REF_172[unit]
REF_174(uint256) -> REF_173.endPrice
price(uint256) := REF_174(uint256)""];
4->16;
5[label=""Node Type: IF 5

EXPRESSION:
block.number <= offers[group][asset][unit].startBlock

IRs:
REF_175(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group]
REF_176(mapping(uint256 => Crypland.Offer)) -> REF_175[asset]
REF_177(Crypland.Offer) -> REF_176[unit]
REF_178(uint256) -> REF_177.startBlock
TMP_141(bool) = block.number <= REF_178
CONDITION TMP_141""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
price = offers[group][asset][unit].startPrice

IRs:
REF_179(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group]
REF_180(mapping(uint256 => Crypland.Offer)) -> REF_179[asset]
REF_181(Crypland.Offer) -> REF_180[unit]
REF_182(uint256) -> REF_181.startPrice
price(uint256) := REF_182(uint256)""];
6->15;
7[label=""Node Type: IF 7

EXPRESSION:
offers[group][asset][unit].endPrice == offers[group][asset][unit].startPrice

IRs:
REF_183(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group]
REF_184(mapping(uint256 => Crypland.Offer)) -> REF_183[asset]
REF_185(Crypland.Offer) -> REF_184[unit]
REF_186(uint256) -> REF_185.endPrice
REF_187(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group]
REF_188(mapping(uint256 => Crypland.Offer)) -> REF_187[asset]
REF_189(Crypland.Offer) -> REF_188[unit]
REF_190(uint256) -> REF_189.startPrice
TMP_142(bool) = REF_186 == REF_190
CONDITION TMP_142""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
price = offers[group][asset][unit].endPrice

IRs:
REF_191(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group]
REF_192(mapping(uint256 => Crypland.Offer)) -> REF_191[asset]
REF_193(Crypland.Offer) -> REF_192[unit]
REF_194(uint256) -> REF_193.endPrice
price(uint256) := REF_194(uint256)""];
8->14;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
currentBlockChange = block.number - offers[group][asset][unit].startBlock

IRs:
REF_195(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group]
REF_196(mapping(uint256 => Crypland.Offer)) -> REF_195[asset]
REF_197(Crypland.Offer) -> REF_196[unit]
REF_198(uint256) -> REF_197.startBlock
TMP_143(uint256) = block.number - REF_198
currentBlockChange(uint256) := TMP_143(uint256)""];
9->10;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
totalBlockChange = offers[group][asset][unit].endBlock - offers[group][asset][unit].startBlock

IRs:
REF_199(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group]
REF_200(mapping(uint256 => Crypland.Offer)) -> REF_199[asset]
REF_201(Crypland.Offer) -> REF_200[unit]
REF_202(uint256) -> REF_201.endBlock
REF_203(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group]
REF_204(mapping(uint256 => Crypland.Offer)) -> REF_203[asset]
REF_205(Crypland.Offer) -> REF_204[unit]
REF_206(uint256) -> REF_205.startBlock
TMP_144(uint256) = REF_202 - REF_206
totalBlockChange(uint256) := TMP_144(uint256)""];
10->11;
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
totalPriceChange = offers[group][asset][unit].startPrice - offers[group][asset][unit].endPrice

IRs:
REF_207(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group]
REF_208(mapping(uint256 => Crypland.Offer)) -> REF_207[asset]
REF_209(Crypland.Offer) -> REF_208[unit]
REF_210(uint256) -> REF_209.startPrice
REF_211(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group]
REF_212(mapping(uint256 => Crypland.Offer)) -> REF_211[asset]
REF_213(Crypland.Offer) -> REF_212[unit]
REF_214(uint256) -> REF_213.endPrice
TMP_145(uint256) = REF_210 - REF_214
totalPriceChange(uint256) := TMP_145(uint256)""];
11->12;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
currentPriceChange = currentBlockChange * totalPriceChange / totalBlockChange

IRs:
TMP_146(uint256) = currentBlockChange * totalPriceChange
TMP_147(uint256) = TMP_146 / totalBlockChange
currentPriceChange(uint256) := TMP_147(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
price = offers[group][asset][unit].startPrice - currentPriceChange

IRs:
REF_215(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group]
REF_216(mapping(uint256 => Crypland.Offer)) -> REF_215[asset]
REF_217(Crypland.Offer) -> REF_216[unit]
REF_218(uint256) -> REF_217.startPrice
TMP_148(uint256) = REF_218 - currentPriceChange
price(uint256) := TMP_148(uint256)""];
13->14;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: RETURN 18

EXPRESSION:
price

IRs:
RETURN price""];
}
",0,1,0,0,price = 0;offers[group][asset][unit].isOffer;block.number >= offers[group][asset][unit].endBlock;;price = offers[group][asset][unit].endPrice;block.number <= offers[group][asset][unit].startBlock;;price = offers[group][asset][unit].startPrice;offers[group][asset][unit].endPrice == offers[group][asset][unit].startPrice;;price = offers[group][asset][unit].endPrice;currentBlockChange = block.number - offers[group][asset][unit].startBlock;;totalBlockChange = offers[group][asset][unit].endBlock - offers[group][asset][unit].startBlock;totalPriceChange = offers[group][asset][unit].startPrice - offers[group][asset][unit].endPrice;currentPriceChange = currentBlockChange * totalPriceChange / totalBlockChange;price = offers[group][asset][unit].startPrice - currentPriceChange;price
./0x006ff3494c04680cfbf39b0396054486f3f6ad32_ext.sol,PLAY_NOW.NewQuestion,34,39,"TMP_12(bool) = msg.sender == questionSender,CONDITION TMP_12,question(string) := _question(string),responseHash(bytes32) := _responseHash(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == questionSender

IRs:
TMP_12(bool) = msg.sender == questionSender
CONDITION TMP_12""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
responseHash = _responseHash

IRs:
responseHash(bytes32) := _responseHash(bytes32)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,msg.sender == questionSender;question = _question;;responseHash = _responseHash
./0x1d7b14967d103df9dbc16d408616da18c4ae83eb_ext.sol,TokenERC20._transfer,95,111,"TMP_19(bool) = _to != 0,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_5(uint256) -> balanceOf[_from],TMP_21(bool) = REF_5 >= _value,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),REF_6(uint256) -> balanceOf[_to],TMP_23(uint256) = REF_6 + _value,REF_7(uint256) -> balanceOf[_to],TMP_24(bool) = TMP_23 >= REF_7,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_26(uint256) = REF_8 + REF_9,previousBalances(uint256) := TMP_26(uint256),REF_10(uint256) -> balanceOf[_from],REF_10(-> balanceOf) = REF_10 - _value,REF_11(uint256) -> balanceOf[_to],REF_11(-> balanceOf) = REF_11 + _value,Emit Transfer(_from,_to,_value),REF_12(uint256) -> balanceOf[_from],REF_13(uint256) -> balanceOf[_to],TMP_28(uint256) = REF_12 + REF_13,TMP_29(bool) = TMP_28 == previousBalances,TMP_30(None) = SOLIDITY_CALL assert(bool)(TMP_29)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_19(bool) = _to != 0
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_5(uint256) -> balanceOf[_from]
TMP_21(bool) = REF_5 >= _value
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_6(uint256) -> balanceOf[_to]
TMP_23(uint256) = REF_6 + _value
REF_7(uint256) -> balanceOf[_to]
TMP_24(bool) = TMP_23 >= REF_7
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_26(uint256) = REF_8 + REF_9
previousBalances(uint256) := TMP_26(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_10(uint256) -> balanceOf[_from]
REF_10(-> balanceOf) = REF_10 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_11(uint256) -> balanceOf[_to]
REF_11(-> balanceOf) = REF_11 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_12(uint256) -> balanceOf[_from]
REF_13(uint256) -> balanceOf[_to]
TMP_28(uint256) = REF_12 + REF_13
TMP_29(bool) = TMP_28 == previousBalances
TMP_30(None) = SOLIDITY_CALL assert(bool)(TMP_29)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xc08dcf2fa37b87a89ac7f0fdcb4aebda378dea29_ext.sol,MITToken.burn,167,173,"REF_20(uint256) -> balanceOf[msg.sender],TMP_69(bool) = REF_20 >= _value,TMP_70(None) = SOLIDITY_CALL require(bool)(TMP_69),REF_21(uint256) -> balanceOf[msg.sender],REF_21(-> balanceOf) = REF_21 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_20(uint256) -> balanceOf[msg.sender]
TMP_69(bool) = REF_20 >= _value
TMP_70(None) = SOLIDITY_CALL require(bool)(TMP_69)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_21(uint256) -> balanceOf[msg.sender]
REF_21(-> balanceOf) = REF_21 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x3f90421fd22b7e3251c8600430acc82922d2a434_ext.sol,StandardToken.transferFrom,56,66,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x5b5b518d5eaaa14f790ba9b59a9a586c3a784d2f_ext.sol,Auction.fallback,53,83,"TMP_5(bool) = msg.value == 0,CONDITION TMP_5,INTERNAL_CALL, Auction.refund()(),TMP_7(bool) = now < timestampEnd,TMP_8(None) = SOLIDITY_CALL require(bool,string)(TMP_7,auction has ended),REF_0(uint256) -> bids[msg.sender],TMP_9(bool) = REF_0 > 0,CONDITION TMP_9,REF_1(uint256) -> bids[msg.sender],REF_1(-> bids) = REF_1 + msg.value,REF_2(uint256) -> bids[msg.sender],REF_2(uint256) (->bids) := msg.value(uint256),REF_4 -> LENGTH accountsList,TMP_11(uint256) := REF_4(uint256),TMP_12(uint256) = TMP_11 + 1,REF_4(uint256) (->accountsList) := TMP_12(uint256),REF_5(address) -> accountsList[TMP_11],REF_5(address) (->accountsList) := msg.sender(address),CONDITION initialPrice,REF_6(uint256) -> bids[msg.sender],TMP_13(bool) = REF_6 >= price,TMP_14(None) = SOLIDITY_CALL require(bool,string)(TMP_13,bid too low, minimum is the initial price),REF_7(uint256) -> bids[msg.sender],TMP_15(uint256) = price * 5,TMP_16(uint256) = TMP_15 / 4,TMP_17(bool) = REF_7 >= TMP_16,TMP_18(None) = SOLIDITY_CALL require(bool,string)(TMP_17,bid too low, minimum 25% increment),TMP_19(uint256) = timestampEnd - increaseTimeIfBidBeforeEnd,TMP_20(bool) = now > TMP_19,CONDITION TMP_20,TMP_21(uint256) = now + increaseTimeBy,timestampEnd(uint256) := TMP_21(uint256),initialPrice(bool) := False(bool),REF_8(uint256) -> bids[msg.sender],price(uint256) := REF_8(uint256),winner(address) := msg.sender(address),Emit Bid(winner,price,now)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value == 0

IRs:
TMP_5(bool) = msg.value == 0
CONDITION TMP_5""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
refund()

IRs:
INTERNAL_CALL, Auction.refund()()""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool,string)(now < timestampEnd,auction has ended)

IRs:
TMP_7(bool) = now < timestampEnd
TMP_8(None) = SOLIDITY_CALL require(bool,string)(TMP_7,auction has ended)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
bids[msg.sender] > 0

IRs:
REF_0(uint256) -> bids[msg.sender]
TMP_9(bool) = REF_0 > 0
CONDITION TMP_9""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
bids[msg.sender] += msg.value

IRs:
REF_1(uint256) -> bids[msg.sender]
REF_1(-> bids) = REF_1 + msg.value""];
7->10;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
bids[msg.sender] = msg.value

IRs:
REF_2(uint256) -> bids[msg.sender]
REF_2(uint256) (->bids) := msg.value(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
accountsList.push(msg.sender)

IRs:
REF_4 -> LENGTH accountsList
TMP_11(uint256) := REF_4(uint256)
TMP_12(uint256) = TMP_11 + 1
REF_4(uint256) (->accountsList) := TMP_12(uint256)
REF_5(address) -> accountsList[TMP_11]
REF_5(address) (->accountsList) := msg.sender(address)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
initialPrice

IRs:
CONDITION initialPrice""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
require(bool,string)(bids[msg.sender] >= price,bid too low, minimum is the initial price)

IRs:
REF_6(uint256) -> bids[msg.sender]
TMP_13(bool) = REF_6 >= price
TMP_14(None) = SOLIDITY_CALL require(bool,string)(TMP_13,bid too low, minimum is the initial price)""];
12->14;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
require(bool,string)(bids[msg.sender] >= (price * 5 / 4),bid too low, minimum 25% increment)

IRs:
REF_7(uint256) -> bids[msg.sender]
TMP_15(uint256) = price * 5
TMP_16(uint256) = TMP_15 / 4
TMP_17(bool) = REF_7 >= TMP_16
TMP_18(None) = SOLIDITY_CALL require(bool,string)(TMP_17,bid too low, minimum 25% increment)""];
13->14;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: IF 15

EXPRESSION:
now > timestampEnd - increaseTimeIfBidBeforeEnd

IRs:
TMP_19(uint256) = timestampEnd - increaseTimeIfBidBeforeEnd
TMP_20(bool) = now > TMP_19
CONDITION TMP_20""];
15->16[label=""True""];
15->17[label=""False""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
timestampEnd = now + increaseTimeBy

IRs:
TMP_21(uint256) = now + increaseTimeBy
timestampEnd(uint256) := TMP_21(uint256)""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
initialPrice = false

IRs:
initialPrice(bool) := False(bool)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
price = bids[msg.sender]

IRs:
REF_8(uint256) -> bids[msg.sender]
price(uint256) := REF_8(uint256)""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
winner = msg.sender

IRs:
winner(address) := msg.sender(address)""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
Bid(winner,price,now)

IRs:
Emit Bid(winner,price,now)""];
}
",0,1,0,0,"msg.value == 0;refund();;;require(bool,string)(now < timestampEnd,auction has ended);bids[msg.sender] > 0;bids[msg.sender] += msg.value;bids[msg.sender] = msg.value;;accountsList.push(msg.sender);initialPrice;require(bool,string)(bids[msg.sender] >= price,bid too low, minimum is the initial price);require(bool,string)(bids[msg.sender] >= (price * 5 / 4),bid too low, minimum 25% increment);;now > timestampEnd - increaseTimeIfBidBeforeEnd;timestampEnd = now + increaseTimeBy;;initialPrice = false;price = bids[msg.sender];winner = msg.sender;Bid(winner,price,now)"
./0x4c2085edeefa307e73a10e3e7224886e6b6a0586_ext.sol,BREDToken.approveAndCall,200,205,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x20bcae16a8ba95d8e8363e265de4ecfc36ec5cd9_ext.sol,HEYBITCOIN.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x580c1e3caca14826976b5820947f7ad486ac174d_ext.sol,BitcoinAgileToken.mintToken,197,202,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x70aa0247de23fdd3b8558be98747a8c286affd54_ext.sol,Digital_1.burn,131,137,"REF_17(uint256) -> balanceOf[msg.sender],TMP_23(bool) = REF_17 >= _value,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_23(bool) = REF_17 >= _value
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x5aeb706c39a76c31fa89bf726de1a6f7d6bc1a51_ext.sol,EtherColor._transfer,403,427,"REF_61(uint256) -> ownershipTokenCount[_to],TMP_114(uint256) := REF_61(uint256),REF_61(-> ownershipTokenCount) = REF_61 + 1,REF_62(address) -> colorIndexToOwner[_tokenId],REF_62(address) (->colorIndexToOwner) := _to(address),TMP_115 = CONVERT 0 to address,TMP_116(bool) = _from != TMP_115,CONDITION TMP_116,REF_63(uint256) -> ownershipTokenCount[_from],TMP_117(uint256) := REF_63(uint256),REF_63(-> ownershipTokenCount) = REF_63 - 1,REF_64(address) -> colorIndexToApproved[_tokenId],colorIndexToApproved = delete REF_64 ,REF_65(address[5]) -> colorIndexToPreviousOwners[_tokenId],REF_66(address) -> REF_65[4],REF_67(address[5]) -> colorIndexToPreviousOwners[_tokenId],REF_68(address) -> REF_67[3],REF_66(address) (->colorIndexToPreviousOwners) := REF_68(address),REF_69(address[5]) -> colorIndexToPreviousOwners[_tokenId],REF_70(address) -> REF_69[3],REF_71(address[5]) -> colorIndexToPreviousOwners[_tokenId],REF_72(address) -> REF_71[2],REF_70(address) (->colorIndexToPreviousOwners) := REF_72(address),REF_73(address[5]) -> colorIndexToPreviousOwners[_tokenId],REF_74(address) -> REF_73[2],REF_75(address[5]) -> colorIndexToPreviousOwners[_tokenId],REF_76(address) -> REF_75[1],REF_74(address) (->colorIndexToPreviousOwners) := REF_76(address),REF_77(address[5]) -> colorIndexToPreviousOwners[_tokenId],REF_78(address) -> REF_77[1],REF_79(address[5]) -> colorIndexToPreviousOwners[_tokenId],REF_80(address) -> REF_79[0],REF_78(address) (->colorIndexToPreviousOwners) := REF_80(address),TMP_118 = CONVERT 0 to address,TMP_119(bool) = _from != TMP_118,CONDITION TMP_119,REF_81(address[5]) -> colorIndexToPreviousOwners[_tokenId],REF_82(address) -> REF_81[0],REF_82(address) (->colorIndexToPreviousOwners) := _from(address),REF_83(address[5]) -> colorIndexToPreviousOwners[_tokenId],REF_84(address) -> REF_83[0],TMP_120 = CONVERT this to address,REF_84(address) (->colorIndexToPreviousOwners) := TMP_120(address),Emit Transfer(_from,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownershipTokenCount[_to] ++

IRs:
REF_61(uint256) -> ownershipTokenCount[_to]
TMP_114(uint256) := REF_61(uint256)
REF_61(-> ownershipTokenCount) = REF_61 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
colorIndexToOwner[_tokenId] = _to

IRs:
REF_62(address) -> colorIndexToOwner[_tokenId]
REF_62(address) (->colorIndexToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_115 = CONVERT 0 to address
TMP_116(bool) = _from != TMP_115
CONDITION TMP_116""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownershipTokenCount[_from] --

IRs:
REF_63(uint256) -> ownershipTokenCount[_from]
TMP_117(uint256) := REF_63(uint256)
REF_63(-> ownershipTokenCount) = REF_63 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete colorIndexToApproved[_tokenId]

IRs:
REF_64(address) -> colorIndexToApproved[_tokenId]
colorIndexToApproved = delete REF_64 ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
colorIndexToPreviousOwners[_tokenId][4] = colorIndexToPreviousOwners[_tokenId][3]

IRs:
REF_65(address[5]) -> colorIndexToPreviousOwners[_tokenId]
REF_66(address) -> REF_65[4]
REF_67(address[5]) -> colorIndexToPreviousOwners[_tokenId]
REF_68(address) -> REF_67[3]
REF_66(address) (->colorIndexToPreviousOwners) := REF_68(address)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
colorIndexToPreviousOwners[_tokenId][3] = colorIndexToPreviousOwners[_tokenId][2]

IRs:
REF_69(address[5]) -> colorIndexToPreviousOwners[_tokenId]
REF_70(address) -> REF_69[3]
REF_71(address[5]) -> colorIndexToPreviousOwners[_tokenId]
REF_72(address) -> REF_71[2]
REF_70(address) (->colorIndexToPreviousOwners) := REF_72(address)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
colorIndexToPreviousOwners[_tokenId][2] = colorIndexToPreviousOwners[_tokenId][1]

IRs:
REF_73(address[5]) -> colorIndexToPreviousOwners[_tokenId]
REF_74(address) -> REF_73[2]
REF_75(address[5]) -> colorIndexToPreviousOwners[_tokenId]
REF_76(address) -> REF_75[1]
REF_74(address) (->colorIndexToPreviousOwners) := REF_76(address)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
colorIndexToPreviousOwners[_tokenId][1] = colorIndexToPreviousOwners[_tokenId][0]

IRs:
REF_77(address[5]) -> colorIndexToPreviousOwners[_tokenId]
REF_78(address) -> REF_77[1]
REF_79(address[5]) -> colorIndexToPreviousOwners[_tokenId]
REF_80(address) -> REF_79[0]
REF_78(address) (->colorIndexToPreviousOwners) := REF_80(address)""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
_from != address(0)

IRs:
TMP_118 = CONVERT 0 to address
TMP_119(bool) = _from != TMP_118
CONDITION TMP_119""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
colorIndexToPreviousOwners[_tokenId][0] = _from

IRs:
REF_81(address[5]) -> colorIndexToPreviousOwners[_tokenId]
REF_82(address) -> REF_81[0]
REF_82(address) (->colorIndexToPreviousOwners) := _from(address)""];
12->14;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
colorIndexToPreviousOwners[_tokenId][0] = address(this)

IRs:
REF_83(address[5]) -> colorIndexToPreviousOwners[_tokenId]
REF_84(address) -> REF_83[0]
TMP_120 = CONVERT this to address
REF_84(address) (->colorIndexToPreviousOwners) := TMP_120(address)""];
13->14;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
}
",0,1,0,0,"ownershipTokenCount[_to] ++;colorIndexToOwner[_tokenId] = _to;_from != address(0);ownershipTokenCount[_from] --;;delete colorIndexToApproved[_tokenId];colorIndexToPreviousOwners[_tokenId][4] = colorIndexToPreviousOwners[_tokenId][3];colorIndexToPreviousOwners[_tokenId][3] = colorIndexToPreviousOwners[_tokenId][2];colorIndexToPreviousOwners[_tokenId][2] = colorIndexToPreviousOwners[_tokenId][1];colorIndexToPreviousOwners[_tokenId][1] = colorIndexToPreviousOwners[_tokenId][0];_from != address(0);colorIndexToPreviousOwners[_tokenId][0] = _from;colorIndexToPreviousOwners[_tokenId][0] = address(this);;Transfer(_from,_to,_tokenId)"
./0x2151288dfdbd547e071d8c6dc7fe3301235ae87c_ext.sol,Bitcoin1.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x214f96e84d3c0f2920bb90fec861be4925edf02b_ext.sol,HorseyToken.approveAndCall,180,189,"TMP_40 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_40(tokenRecipient),TMP_41(bool) = INTERNAL_CALL, HorseyToken.approve(address,uint256)(_spender,_value),CONDITION TMP_41,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_40 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_40(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_41(bool) = INTERNAL_CALL, HorseyToken.approve(address,uint256)(_spender,_value)
CONDITION TMP_41""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x1768fc7978e9abae733dd6c3de837a57a2f2ce4f_ext.sol,StandardToken.transfer,45,54,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x71880d9f448c995ec5a7c9d68f2b0e256ef510d2_ext.sol,ValueTokenBase.burn,150,156,"REF_20(uint256) -> balances[msg.sender],TMP_23(bool) = REF_20 >= _value,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),REF_21(uint256) -> balances[msg.sender],REF_21(-> balances) = REF_21 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_20(uint256) -> balances[msg.sender]
TMP_23(bool) = REF_20 >= _value
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_21(uint256) -> balances[msg.sender]
REF_21(-> balances) = REF_21 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);balances[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true"
./0x030c32c1190cbf077e5ee67ed19572c558e43ae4_ext.sol,BitBonus.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0xd86dc5e1574491b3c4b68a30f0084d630a9ecc94_ext.sol,Token._transfer,38,54,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xf4609d26a58598d6b80b11f451a00477f61d8804_ext.sol,Tcthereum.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x5255fd71e5ad9be04cdd5401c14a2765a99ccaf9_ext.sol,HelpingBlocksContract._transfer,69,73,"REF_1(uint256) -> balanceOf[_from],REF_1(-> balanceOf) = REF_1 - _value,REF_2(uint256) -> balanceOf[_to],REF_2(-> balanceOf) = REF_2 + _value,Emit Transfer(_from,_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_1(uint256) -> balanceOf[_from]
REF_1(-> balanceOf) = REF_1 - _value""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_2(uint256) -> balanceOf[_to]
REF_2(-> balanceOf) = REF_2 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
}
",0,1,0,0,"balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value)"
./0x5890ef4e676cd051e59a348b46e0b3e73601f34d_ext.sol,HIW.transfer,30,37,"REF_1(uint256) -> balanceOf[msg.sender],TMP_0(bool) = REF_1 >= _value,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - _value,REF_3(uint256) -> balanceOf[_to],REF_3(-> balanceOf) = REF_3 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_0(bool) = REF_1 >= _value
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_3(uint256) -> balanceOf[_to]
REF_3(-> balanceOf) = REF_3 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;balanceOf[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0x282c3971f8041bf4ab8b0d2ad0875e94958f8940_ext.sol,RENAULT_301201.transferFrom,42,54,"REF_6(uint256) -> balanceOf[from],TMP_6(bool) = value <= REF_6,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_7(mapping(address => uint256)) -> allowance[from],REF_8(uint256) -> REF_7[msg.sender],TMP_8(bool) = value <= REF_8,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_9(uint256) -> balanceOf[from],REF_9(-> balanceOf) = REF_9 - value,REF_10(uint256) -> balanceOf[to],REF_10(-> balanceOf) = REF_10 + value,REF_11(mapping(address => uint256)) -> allowance[from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowance) = REF_12 - value,Emit Transfer(from,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(value <= balanceOf[from])

IRs:
REF_6(uint256) -> balanceOf[from]
TMP_6(bool) = value <= REF_6
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value <= allowance[from][msg.sender])

IRs:
REF_7(mapping(address => uint256)) -> allowance[from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_8(bool) = value <= REF_8
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[from] -= value

IRs:
REF_9(uint256) -> balanceOf[from]
REF_9(-> balanceOf) = REF_9 - value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[to] += value

IRs:
REF_10(uint256) -> balanceOf[to]
REF_10(-> balanceOf) = REF_10 + value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allowance[from][msg.sender] -= value

IRs:
REF_11(mapping(address => uint256)) -> allowance[from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowance) = REF_12 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(value <= balanceOf[from]);require(bool)(value <= allowance[from][msg.sender]);balanceOf[from] -= value;balanceOf[to] += value;allowance[from][msg.sender] -= value;Transfer(from,to,value);true;success"
./0x5b2988f2d77c38b46a753ea09a4f6bf726e07e34_ext.sol,LILE.approveAndCall,206,215,"REF_79(mapping(address => uint256)) -> allowed[msg.sender],REF_80(uint256) -> REF_79[_spender],REF_80(uint256) (->allowed) := _value(uint256),Emit Approval(msg.sender,_spender,_value),TMP_137(bytes32) = SOLIDITY_CALL sha3()(receiveApproval(address,uint256,address,bytes)),TMP_138 = CONVERT TMP_137 to bytes32,TMP_139 = CONVERT TMP_138 to bytes4,TMP_140(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_139', 'msg.sender', '_value', 'this', '_extraData']  ,TMP_141(None) = SOLIDITY_CALL require(bool)(TMP_140),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_79(mapping(address => uint256)) -> allowed[msg.sender]
REF_80(uint256) -> REF_79[_spender]
REF_80(uint256) (->allowed) := _value(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_spender.call(bytes4(bytes32(sha3()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData))

IRs:
TMP_137(bytes32) = SOLIDITY_CALL sha3()(receiveApproval(address,uint256,address,bytes))
TMP_138 = CONVERT TMP_137 to bytes32
TMP_139 = CONVERT TMP_138 to bytes4
TMP_140(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_139', 'msg.sender', '_value', 'this', '_extraData']  
TMP_141(None) = SOLIDITY_CALL require(bool)(TMP_140)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][_spender] = _value;Approval(msg.sender,_spender,_value);require(bool)(_spender.call(bytes4(bytes32(sha3()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData));true;success"
./0xf354b2e5ea679a726d0348a974971cb4697bf508_ext.sol,TokenERC20.burn,122,128,"REF_17(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_17 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_17 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x5c7f7e79b710a7bd29d8a381621e0268c98dcf06_ext.sol,ERC20Standard.transferFrom,70,76,"REF_5(uint256) -> balances[_from],TMP_9(bool) = REF_5 >= _value,REF_6(mapping(address => uint256)) -> allowed[_from],REF_7(uint256) -> REF_6[msg.sender],TMP_10(bool) = REF_7 >= _value,TMP_11(bool) = TMP_9 && TMP_10,TMP_12(bool) = _value > 0,TMP_13(bool) = TMP_11 && TMP_12,TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13),REF_8(uint256) -> balances[_to],REF_8(-> balances) = REF_8 + _value,REF_9(uint256) -> balances[_from],REF_9(-> balances) = REF_9 - _value,REF_10(mapping(address => uint256)) -> allowed[_from],REF_11(uint256) -> REF_10[msg.sender],REF_11(-> allowed) = REF_11 - _value,Emit Transfer(_from,_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0)

IRs:
REF_5(uint256) -> balances[_from]
TMP_9(bool) = REF_5 >= _value
REF_6(mapping(address => uint256)) -> allowed[_from]
REF_7(uint256) -> REF_6[msg.sender]
TMP_10(bool) = REF_7 >= _value
TMP_11(bool) = TMP_9 && TMP_10
TMP_12(bool) = _value > 0
TMP_13(bool) = TMP_11 && TMP_12
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_8(uint256) -> balances[_to]
REF_8(-> balances) = REF_8 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_9(uint256) -> balances[_from]
REF_9(-> balances) = REF_9 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_10(mapping(address => uint256)) -> allowed[_from]
REF_11(uint256) -> REF_10[msg.sender]
REF_11(-> allowed) = REF_11 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
}
",0,1,0,0,"require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);balances[_to] += _value;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value)"
./0x5513401cb13ec32809d238ee19a84405759147cc_ext.sol,INTO_ICO.start,169,172,"openingTime(uint256) := now(uint256),TMP_49(uint256) = now + duration,closingTime(uint256) := TMP_49(uint256),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
openingTime = now

IRs:
openingTime(uint256) := now(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
closingTime = now + duration

IRs:
TMP_49(uint256) = now + duration
closingTime(uint256) := TMP_49(uint256)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
3->1;
}
",0,1,0,0,onlyOwner();openingTime = now;closingTime = now + duration
./0x6c558a4976e751391fb73dd61fa6a72c318d80b5_ext.sol,BitQ.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x190e569be071f40c704e15825f285481cb74b6cc_ext.sol,ERC20Standard.transferFrom,38,44,"REF_4(uint256) -> balances[_from],TMP_7(bool) = REF_4 >= _value,REF_5(mapping(address => uint256)) -> allowed[_from],REF_6(uint256) -> REF_5[msg.sender],TMP_8(bool) = REF_6 >= _value,TMP_9(bool) = TMP_7 && TMP_8,TMP_10(bool) = _value > 0,TMP_11(bool) = TMP_9 && TMP_10,TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11),REF_7(uint256) -> balances[_to],REF_7(-> balances) = REF_7 + _value,REF_8(uint256) -> balances[_from],REF_8(-> balances) = REF_8 - _value,REF_9(mapping(address => uint256)) -> allowed[_from],REF_10(uint256) -> REF_9[msg.sender],REF_10(-> allowed) = REF_10 - _value,Emit Transfer(_from,_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0)

IRs:
REF_4(uint256) -> balances[_from]
TMP_7(bool) = REF_4 >= _value
REF_5(mapping(address => uint256)) -> allowed[_from]
REF_6(uint256) -> REF_5[msg.sender]
TMP_8(bool) = REF_6 >= _value
TMP_9(bool) = TMP_7 && TMP_8
TMP_10(bool) = _value > 0
TMP_11(bool) = TMP_9 && TMP_10
TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_7(uint256) -> balances[_to]
REF_7(-> balances) = REF_7 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_8(uint256) -> balances[_from]
REF_8(-> balances) = REF_8 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_9(mapping(address => uint256)) -> allowed[_from]
REF_10(uint256) -> REF_9[msg.sender]
REF_10(-> allowed) = REF_10 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
}
",0,1,0,0,"require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);balances[_to] += _value;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value)"
./0x841b42c7ee6a15904d1926bf15ffdb6d30a77723_ext.sol,GDC.burn,108,114,"REF_16(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_16 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_17(uint256) -> balanceOf[msg.sender],REF_17(-> balanceOf) = REF_17 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_16(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_16 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
REF_17(-> balanceOf) = REF_17 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xeecf94be6fd3f8480285bad2b2bc5a220e0e0fcc_ext.sol,CPLToken.totalSupply,128,130,"TMP_32 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_32],TMP_33(uint256) = _totalSupply - REF_1,RETURN TMP_33","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_32 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_32]
TMP_33(uint256) = _totalSupply - REF_1
RETURN TMP_33""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x71f04062e5794e0190fdca9a2bf1f196c41c3e6e_ext.sol,MintableToken.burn,242,248,"REF_152(uint256) -> _balances[msg.sender],TMP_155(bool) = REF_152 >= value,TMP_156(None) = SOLIDITY_CALL require(bool)(TMP_155),REF_153(uint256) -> _balances[msg.sender],REF_153(-> _balances) = REF_153 - value,_totalSupply(uint256) = _totalSupply - value,Emit Burn(msg.sender,value),RETURN True,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_balances[msg.sender] >= value)

IRs:
REF_152(uint256) -> _balances[msg.sender]
TMP_155(bool) = REF_152 >= value
TMP_156(None) = SOLIDITY_CALL require(bool)(TMP_155)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_balances[msg.sender] -= value

IRs:
REF_153(uint256) -> _balances[msg.sender]
REF_153(-> _balances) = REF_153 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_totalSupply -= value

IRs:
_totalSupply(uint256) = _totalSupply - value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,value)

IRs:
Emit Burn(msg.sender,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",0,1,0,0,"onlyOwner();require(bool)(_balances[msg.sender] >= value);_balances[msg.sender] -= value;_totalSupply -= value;Burn(msg.sender,value);true"
./0x414e58fbd9264565d611c5eb2a392a70529dad41_ext.sol,CoinEGGToken.transferFrom,41,48,"REF_6(uint256) -> balances[_from],TMP_10(bool) = REF_6 >= _value,REF_7(mapping(address => uint256)) -> allowed[_from],REF_8(uint256) -> REF_7[msg.sender],TMP_11(bool) = REF_8 >= _value,TMP_12(bool) = TMP_10 && TMP_11,TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12),REF_9(uint256) -> balances[_to],REF_9(-> balances) = REF_9 + _value,REF_10(uint256) -> balances[_from],REF_10(-> balances) = REF_10 - _value,REF_11(mapping(address => uint256)) -> allowed[_from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowed) = REF_12 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value)

IRs:
REF_6(uint256) -> balances[_from]
TMP_10(bool) = REF_6 >= _value
REF_7(mapping(address => uint256)) -> allowed[_from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_11(bool) = REF_8 >= _value
TMP_12(bool) = TMP_10 && TMP_11
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_9(uint256) -> balances[_to]
REF_9(-> balances) = REF_9 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_10(uint256) -> balances[_from]
REF_10(-> balances) = REF_10 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_11(mapping(address => uint256)) -> allowed[_from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowed) = REF_12 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);balances[_to] += _value;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true;success"
./0x35fd00d47202b1b2158dba75e7cc8f71b068c256_ext.sol,WhiteList.addToWhiteList,159,167,"REF_3(bool) -> whiteList[_user],TMP_47(bool) = REF_3 != True,CONDITION TMP_47,REF_4(bool) -> whiteList[_user],REF_4(bool) (->whiteList) := True(bool),TMP_48(uint256) := totalWhiteListed(uint256),totalWhiteListed(uint256) = totalWhiteListed + 1,Emit LogWhiteListed(_user,totalWhiteListed),RETURN True,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: IF 1

EXPRESSION:
whiteList[_user] != true

IRs:
REF_3(bool) -> whiteList[_user]
TMP_47(bool) = REF_3 != True
CONDITION TMP_47""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
whiteList[_user] = true

IRs:
REF_4(bool) -> whiteList[_user]
REF_4(bool) (->whiteList) := True(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalWhiteListed ++

IRs:
TMP_48(uint256) := totalWhiteListed(uint256)
totalWhiteListed(uint256) = totalWhiteListed + 1""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
LogWhiteListed(_user,totalWhiteListed)

IRs:
Emit LogWhiteListed(_user,totalWhiteListed)""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->1;
}
",0,1,0,0,"onlyOwner();whiteList[_user] != true;whiteList[_user] = true;;totalWhiteListed ++;LogWhiteListed(_user,totalWhiteListed);true"
./0x01b1ccae68dc41d8a2a0f48e8f0d38b0c064ef43_ext.sol,YSS.mintToken,71,76,"REF_11(uint256) -> balanceOf[target],REF_11(-> balanceOf) = REF_11 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,owner,mintedAmount),Emit Transfer(owner,target,mintedAmount),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_11(uint256) -> balanceOf[target]
REF_11(-> balanceOf) = REF_11 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,owner,mintedAmount)

IRs:
Emit Transfer(0,owner,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(owner,target,mintedAmount)

IRs:
Emit Transfer(owner,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,owner,mintedAmount);Transfer(owner,target,mintedAmount)"
./0x5510f1996e210659e135b05d6bf48d6682af23a7_ext.sol,EthereumPrivate.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_22(bool) = REF_19 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_24(bool) = _value <= REF_21,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_22(bool) = REF_19 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_24(bool) = _value <= REF_21
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x716989fa21d5043165079ddbfd04a76a001a595a_ext.sol,COCTokenBase.burn,169,175,"REF_20(uint256) -> balances[msg.sender],TMP_23(bool) = REF_20 >= _value,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),REF_21(uint256) -> balances[msg.sender],REF_21(-> balances) = REF_21 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_20(uint256) -> balances[msg.sender]
TMP_23(bool) = REF_20 >= _value
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_21(uint256) -> balances[msg.sender]
REF_21(-> balances) = REF_21 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);balances[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true"
./0xdafe38c5f5e40f7b11f28344154e78e57537bd66_ext.sol,CREXToken.transferFrom,88,99,"TMP_19 = CONVERT 0 to address,TMP_20(bool) = _to != TMP_19,TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20),REF_6(uint256) -> balances[_from],TMP_22(bool) = _value <= REF_6,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_7(mapping(address => uint256)) -> allowed[_from],REF_8(uint256) -> REF_7[msg.sender],TMP_24(bool) = _value <= REF_8,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_9(uint256) -> balances[_from],REF_10(uint256) -> balances[_from],TMP_26(uint256) = REF_10 - _value,REF_9(uint256) (->balances) := TMP_26(uint256),REF_11(uint256) -> balances[_to],REF_12(uint256) -> balances[_to],TMP_27(uint256) = REF_12 + _value,REF_11(uint256) (->balances) := TMP_27(uint256),REF_13(mapping(address => uint256)) -> allowed[_from],REF_14(uint256) -> REF_13[msg.sender],REF_15(mapping(address => uint256)) -> allowed[_from],REF_16(uint256) -> REF_15[msg.sender],TMP_28(uint256) = REF_16 - _value,REF_14(uint256) (->allowed) := TMP_28(uint256),Emit Transfer(_from,_to,_value),RETURN True,MODIFIER_CALL, CREXToken.whenTransferAllowed()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_19 = CONVERT 0 to address
TMP_20(bool) = _to != TMP_19
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_6(uint256) -> balances[_from]
TMP_22(bool) = _value <= REF_6
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_7(mapping(address => uint256)) -> allowed[_from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_24(bool) = _value <= REF_8
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] = balances[_from] - _value

IRs:
REF_9(uint256) -> balances[_from]
REF_10(uint256) -> balances[_from]
TMP_26(uint256) = REF_10 - _value
REF_9(uint256) (->balances) := TMP_26(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] = balances[_to] + _value

IRs:
REF_11(uint256) -> balances[_to]
REF_12(uint256) -> balances[_to]
TMP_27(uint256) = REF_12 + _value
REF_11(uint256) (->balances) := TMP_27(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value

IRs:
REF_13(mapping(address => uint256)) -> allowed[_from]
REF_14(uint256) -> REF_13[msg.sender]
REF_15(mapping(address => uint256)) -> allowed[_from]
REF_16(uint256) -> REF_15[msg.sender]
TMP_28(uint256) = REF_16 - _value
REF_14(uint256) (->allowed) := TMP_28(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
whenTransferAllowed()

IRs:
MODIFIER_CALL, CREXToken.whenTransferAllowed()()""];
9->1;
}
",0,1,0,0,"whenTransferAllowed();require(bool)(_to != address(0));require(bool)(_value <= balances[_from]);require(bool)(_value <= allowed[_from][msg.sender]);balances[_from] = balances[_from] - _value;balances[_to] = balances[_to] + _value;allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;Transfer(_from,_to,_value);true"
./0xf2861ad8dd602269c21eddd4d18255903cca47c7_ext.sol,ZethrBigWheel.getSpinOutput,2879,2959,"TMP_774(uint40[5]) = INTERNAL_CALL, ZethrBigWheel.uintToBetsArray(uint256)(_bets_notconverted),_bets(uint40[5]) = ['TMP_774(uint40[5])'],TMP_775(uint256) = block.number - _blockNumber,TMP_776(bool) = TMP_775 > 255,CONDITION TMP_776,result(uint256) := 999997(uint256),TMP_777(uint256) = INTERNAL_CALL, ZethrBigWheel.random(uint256,uint256,address,uint256)(999996,_blockNumber,_target,0),TMP_778(uint256) = TMP_777 + 1,result(uint256) := TMP_778(uint256),REF_366(uint256) -> betsMul[0],REF_367(uint40) -> _bets[0],TMP_779 = CONVERT REF_367 to uint256,TMP_780(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_779', '100000000000000'] ,REF_366(uint256) (->betsMul) := TMP_780(uint256),REF_369(uint256) -> betsMul[1],REF_370(uint40) -> _bets[1],TMP_781 = CONVERT REF_370 to uint256,TMP_782(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_781', '100000000000000'] ,REF_369(uint256) (->betsMul) := TMP_782(uint256),REF_372(uint256) -> betsMul[2],REF_373(uint40) -> _bets[2],TMP_783 = CONVERT REF_373 to uint256,TMP_784(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_783', '100000000000000'] ,REF_372(uint256) (->betsMul) := TMP_784(uint256),REF_375(uint256) -> betsMul[3],REF_376(uint40) -> _bets[3],TMP_785 = CONVERT REF_376 to uint256,TMP_786(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_785', '100000000000000'] ,REF_375(uint256) (->betsMul) := TMP_786(uint256),REF_378(uint256) -> betsMul[4],REF_379(uint40) -> _bets[4],TMP_787 = CONVERT REF_379 to uint256,TMP_788(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_787', '100000000000000'] ,REF_378(uint256) (->betsMul) := TMP_788(uint256),REF_381(uint256) -> betsMul[0],REF_382(uint256) -> betsMul[1],TMP_789(uint256) = REF_381 + REF_382,REF_383(uint256) -> betsMul[2],TMP_790(uint256) = TMP_789 + REF_383,REF_384(uint256) -> betsMul[3],TMP_791(uint256) = TMP_790 + REF_384,REF_385(uint256) -> betsMul[4],TMP_792(uint256) = TMP_791 + REF_385,lossAmount(uint256) := TMP_792(uint256),_winCategory(uint256) := 0(uint256),TMP_793(bool) = result < 2,CONDITION TMP_793,TMP_794(uint256) := jackpotWins(uint256),jackpotWins(uint256) = jackpotWins + 1,_winCategory(uint256) := 99(uint256),TMP_795(bool) = result < 27028,CONDITION TMP_795,REF_386(uint256) -> betsMul[4],TMP_796(bool) = REF_386 > 0,CONDITION TMP_796,_winCategory(uint256) := 25(uint256),REF_388(uint256) -> betsMul[4],TMP_797(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_388', '25'] ,winAmount(uint256) := TMP_797(uint256),REF_389(uint256) -> betsMul[4],lossAmount(uint256) = lossAmount - REF_389,TMP_798(bool) = result < 108108,CONDITION TMP_798,REF_390(uint256) -> betsMul[3],TMP_799(bool) = REF_390 > 0,CONDITION TMP_799,_winCategory(uint256) := 10(uint256),REF_392(uint256) -> betsMul[3],TMP_800(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_392', '10'] ,winAmount(uint256) := TMP_800(uint256),REF_393(uint256) -> betsMul[3],lossAmount(uint256) = lossAmount - REF_393,TMP_801(bool) = result < 270269,CONDITION TMP_801,REF_394(uint256) -> betsMul[2],TMP_802(bool) = REF_394 > 0,CONDITION TMP_802,_winCategory(uint256) := 6(uint256),REF_396(uint256) -> betsMul[2],TMP_803(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_396', '6'] ,winAmount(uint256) := TMP_803(uint256),REF_397(uint256) -> betsMul[2],lossAmount(uint256) = lossAmount - REF_397,TMP_804(bool) = result < 513512,CONDITION TMP_804,REF_398(uint256) -> betsMul[1],TMP_805(bool) = REF_398 > 0,CONDITION TMP_805,_winCategory(uint256) := 4(uint256),REF_400(uint256) -> betsMul[1],TMP_806(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_400', '4'] ,winAmount(uint256) := TMP_806(uint256),REF_401(uint256) -> betsMul[1],lossAmount(uint256) = lossAmount - REF_401,TMP_807(bool) = result < 999997,CONDITION TMP_807,REF_402(uint256) -> betsMul[0],TMP_808(bool) = REF_402 > 0,CONDITION TMP_808,_winCategory(uint256) := 2(uint256),REF_404(uint256) -> betsMul[0],TMP_809(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_404', '2'] ,winAmount(uint256) := TMP_809(uint256),REF_405(uint256) -> betsMul[0],lossAmount(uint256) = lossAmount - REF_405,TMP_810(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['lossAmount', '100'] ,jackpotAmount(uint256) := TMP_810(uint256),lossAmount(uint256) = lossAmount - jackpotAmount,Emit WheelResult(_blockNumber,_target,_bets,winAmount,lossAmount,_winCategory),RETURN winAmount,lossAmount,jackpotAmount,jackpotWins,result,RETURN winAmount,lossAmount,jackpotAmount,jackpotWins,output","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_bets = uintToBetsArray(_bets_notconverted)

IRs:
TMP_774(uint40[5]) = INTERNAL_CALL, ZethrBigWheel.uintToBetsArray(uint256)(_bets_notconverted)
_bets(uint40[5]) = ['TMP_774(uint40[5])']""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
block.number - _blockNumber > 255

IRs:
TMP_775(uint256) = block.number - _blockNumber
TMP_776(bool) = TMP_775 > 255
CONDITION TMP_776""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
result = 999997

IRs:
result(uint256) := 999997(uint256)""];
4->6;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
result = random(999996,_blockNumber,_target,0) + 1

IRs:
TMP_777(uint256) = INTERNAL_CALL, ZethrBigWheel.random(uint256,uint256,address,uint256)(999996,_blockNumber,_target,0)
TMP_778(uint256) = TMP_777 + 1
result(uint256) := TMP_778(uint256)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: NEW VARIABLE 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
betsMul[0] = uint256(_bets[0]).mul(1e14)

IRs:
REF_366(uint256) -> betsMul[0]
REF_367(uint40) -> _bets[0]
TMP_779 = CONVERT REF_367 to uint256
TMP_780(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_779', '100000000000000'] 
REF_366(uint256) (->betsMul) := TMP_780(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
betsMul[1] = uint256(_bets[1]).mul(1e14)

IRs:
REF_369(uint256) -> betsMul[1]
REF_370(uint40) -> _bets[1]
TMP_781 = CONVERT REF_370 to uint256
TMP_782(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_781', '100000000000000'] 
REF_369(uint256) (->betsMul) := TMP_782(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
betsMul[2] = uint256(_bets[2]).mul(1e14)

IRs:
REF_372(uint256) -> betsMul[2]
REF_373(uint40) -> _bets[2]
TMP_783 = CONVERT REF_373 to uint256
TMP_784(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_783', '100000000000000'] 
REF_372(uint256) (->betsMul) := TMP_784(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
betsMul[3] = uint256(_bets[3]).mul(1e14)

IRs:
REF_375(uint256) -> betsMul[3]
REF_376(uint40) -> _bets[3]
TMP_785 = CONVERT REF_376 to uint256
TMP_786(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_785', '100000000000000'] 
REF_375(uint256) (->betsMul) := TMP_786(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
betsMul[4] = uint256(_bets[4]).mul(1e14)

IRs:
REF_378(uint256) -> betsMul[4]
REF_379(uint40) -> _bets[4]
TMP_787 = CONVERT REF_379 to uint256
TMP_788(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_787', '100000000000000'] 
REF_378(uint256) (->betsMul) := TMP_788(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
lossAmount = betsMul[0] + betsMul[1] + betsMul[2] + betsMul[3] + betsMul[4]

IRs:
REF_381(uint256) -> betsMul[0]
REF_382(uint256) -> betsMul[1]
TMP_789(uint256) = REF_381 + REF_382
REF_383(uint256) -> betsMul[2]
TMP_790(uint256) = TMP_789 + REF_383
REF_384(uint256) -> betsMul[3]
TMP_791(uint256) = TMP_790 + REF_384
REF_385(uint256) -> betsMul[4]
TMP_792(uint256) = TMP_791 + REF_385
lossAmount(uint256) := TMP_792(uint256)""];
13->14;
14[label=""Node Type: NEW VARIABLE 14

EXPRESSION:
_winCategory = 0

IRs:
_winCategory(uint256) := 0(uint256)""];
14->15;
15[label=""Node Type: IF 15

EXPRESSION:
result < 2

IRs:
TMP_793(bool) = result < 2
CONDITION TMP_793""];
15->16[label=""True""];
15->18[label=""False""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
jackpotWins ++

IRs:
TMP_794(uint256) := jackpotWins(uint256)
jackpotWins(uint256) = jackpotWins + 1""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
_winCategory = 99

IRs:
_winCategory(uint256) := 99(uint256)""];
17->55;
18[label=""Node Type: IF 18

EXPRESSION:
result < 27028

IRs:
TMP_795(bool) = result < 27028
CONDITION TMP_795""];
18->19[label=""True""];
18->24[label=""False""];
19[label=""Node Type: IF 19

EXPRESSION:
betsMul[4] > 0

IRs:
REF_386(uint256) -> betsMul[4]
TMP_796(bool) = REF_386 > 0
CONDITION TMP_796""];
19->20[label=""True""];
19->23[label=""False""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
_winCategory = 25

IRs:
_winCategory(uint256) := 25(uint256)""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
winAmount = SafeMath.mul(betsMul[4],25)

IRs:
REF_388(uint256) -> betsMul[4]
TMP_797(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_388', '25'] 
winAmount(uint256) := TMP_797(uint256)""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
lossAmount -= betsMul[4]

IRs:
REF_389(uint256) -> betsMul[4]
lossAmount(uint256) = lossAmount - REF_389""];
22->23;
23[label=""Node Type: END_IF 23
""];
23->52;
24[label=""Node Type: IF 24

EXPRESSION:
result < 108108

IRs:
TMP_798(bool) = result < 108108
CONDITION TMP_798""];
24->25[label=""True""];
24->30[label=""False""];
25[label=""Node Type: IF 25

EXPRESSION:
betsMul[3] > 0

IRs:
REF_390(uint256) -> betsMul[3]
TMP_799(bool) = REF_390 > 0
CONDITION TMP_799""];
25->26[label=""True""];
25->29[label=""False""];
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
_winCategory = 10

IRs:
_winCategory(uint256) := 10(uint256)""];
26->27;
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
winAmount = SafeMath.mul(betsMul[3],10)

IRs:
REF_392(uint256) -> betsMul[3]
TMP_800(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_392', '10'] 
winAmount(uint256) := TMP_800(uint256)""];
27->28;
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
lossAmount -= betsMul[3]

IRs:
REF_393(uint256) -> betsMul[3]
lossAmount(uint256) = lossAmount - REF_393""];
28->29;
29[label=""Node Type: END_IF 29
""];
29->51;
30[label=""Node Type: IF 30

EXPRESSION:
result < 270269

IRs:
TMP_801(bool) = result < 270269
CONDITION TMP_801""];
30->31[label=""True""];
30->36[label=""False""];
31[label=""Node Type: IF 31

EXPRESSION:
betsMul[2] > 0

IRs:
REF_394(uint256) -> betsMul[2]
TMP_802(bool) = REF_394 > 0
CONDITION TMP_802""];
31->32[label=""True""];
31->35[label=""False""];
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
_winCategory = 6

IRs:
_winCategory(uint256) := 6(uint256)""];
32->33;
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
winAmount = SafeMath.mul(betsMul[2],6)

IRs:
REF_396(uint256) -> betsMul[2]
TMP_803(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_396', '6'] 
winAmount(uint256) := TMP_803(uint256)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
lossAmount -= betsMul[2]

IRs:
REF_397(uint256) -> betsMul[2]
lossAmount(uint256) = lossAmount - REF_397""];
34->35;
35[label=""Node Type: END_IF 35
""];
35->50;
36[label=""Node Type: IF 36

EXPRESSION:
result < 513512

IRs:
TMP_804(bool) = result < 513512
CONDITION TMP_804""];
36->37[label=""True""];
36->42[label=""False""];
37[label=""Node Type: IF 37

EXPRESSION:
betsMul[1] > 0

IRs:
REF_398(uint256) -> betsMul[1]
TMP_805(bool) = REF_398 > 0
CONDITION TMP_805""];
37->38[label=""True""];
37->41[label=""False""];
38[label=""Node Type: EXPRESSION 38

EXPRESSION:
_winCategory = 4

IRs:
_winCategory(uint256) := 4(uint256)""];
38->39;
39[label=""Node Type: EXPRESSION 39

EXPRESSION:
winAmount = SafeMath.mul(betsMul[1],4)

IRs:
REF_400(uint256) -> betsMul[1]
TMP_806(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_400', '4'] 
winAmount(uint256) := TMP_806(uint256)""];
39->40;
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
lossAmount -= betsMul[1]

IRs:
REF_401(uint256) -> betsMul[1]
lossAmount(uint256) = lossAmount - REF_401""];
40->41;
41[label=""Node Type: END_IF 41
""];
41->49;
42[label=""Node Type: IF 42

EXPRESSION:
result < 999997

IRs:
TMP_807(bool) = result < 999997
CONDITION TMP_807""];
42->43[label=""True""];
42->48[label=""False""];
43[label=""Node Type: IF 43

EXPRESSION:
betsMul[0] > 0

IRs:
REF_402(uint256) -> betsMul[0]
TMP_808(bool) = REF_402 > 0
CONDITION TMP_808""];
43->44[label=""True""];
43->47[label=""False""];
44[label=""Node Type: EXPRESSION 44

EXPRESSION:
_winCategory = 2

IRs:
_winCategory(uint256) := 2(uint256)""];
44->45;
45[label=""Node Type: EXPRESSION 45

EXPRESSION:
winAmount = SafeMath.mul(betsMul[0],2)

IRs:
REF_404(uint256) -> betsMul[0]
TMP_809(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_404', '2'] 
winAmount(uint256) := TMP_809(uint256)""];
45->46;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
lossAmount -= betsMul[0]

IRs:
REF_405(uint256) -> betsMul[0]
lossAmount(uint256) = lossAmount - REF_405""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: END_IF 49
""];
49->50;
50[label=""Node Type: END_IF 50
""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: END_IF 52
""];
52->53;
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
jackpotAmount = lossAmount.div(100)

IRs:
TMP_810(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['lossAmount', '100'] 
jackpotAmount(uint256) := TMP_810(uint256)""];
53->54;
54[label=""Node Type: EXPRESSION 54

EXPRESSION:
lossAmount -= jackpotAmount

IRs:
lossAmount(uint256) = lossAmount - jackpotAmount""];
54->55;
55[label=""Node Type: END_IF 55
""];
55->56;
56[label=""Node Type: EXPRESSION 56

EXPRESSION:
WheelResult(_blockNumber,_target,_bets,winAmount,lossAmount,_winCategory)

IRs:
Emit WheelResult(_blockNumber,_target,_bets,winAmount,lossAmount,_winCategory)""];
56->57;
57[label=""Node Type: RETURN 57

EXPRESSION:
(winAmount,lossAmount,jackpotAmount,jackpotWins,result)

IRs:
RETURN winAmount,lossAmount,jackpotAmount,jackpotWins,result""];
58[label=""Node Type: RETURN 58

EXPRESSION:
(winAmount,lossAmount,jackpotAmount,jackpotWins,output)

IRs:
RETURN winAmount,lossAmount,jackpotAmount,jackpotWins,output""];
}
",0,1,0,0,"_bets = uintToBetsArray(_bets_notconverted);;block.number - _blockNumber > 255;result = 999997;result = random(999996,_blockNumber,_target,0) + 1;;;betsMul[0] = uint256(_bets[0]).mul(1e14);betsMul[1] = uint256(_bets[1]).mul(1e14);betsMul[2] = uint256(_bets[2]).mul(1e14);betsMul[3] = uint256(_bets[3]).mul(1e14);betsMul[4] = uint256(_bets[4]).mul(1e14);lossAmount = betsMul[0] + betsMul[1] + betsMul[2] + betsMul[3] + betsMul[4];_winCategory = 0;result < 2;jackpotWins ++;result < 27028;_winCategory = 99;;betsMul[4] > 0;result < 108108;_winCategory = 25;;winAmount = SafeMath.mul(betsMul[4],25);lossAmount -= betsMul[4];;betsMul[3] > 0;result < 270269;_winCategory = 10;;winAmount = SafeMath.mul(betsMul[3],10);lossAmount -= betsMul[3];;betsMul[2] > 0;result < 513512;_winCategory = 6;;winAmount = SafeMath.mul(betsMul[2],6);lossAmount -= betsMul[2];;betsMul[1] > 0;result < 999997;_winCategory = 4;;winAmount = SafeMath.mul(betsMul[1],4);lossAmount -= betsMul[1];;betsMul[0] > 0;;_winCategory = 2;;winAmount = SafeMath.mul(betsMul[0],2);lossAmount -= betsMul[0];jackpotAmount = lossAmount.div(100);lossAmount -= jackpotAmount;WheelResult(_blockNumber,_target,_bets,winAmount,lossAmount,_winCategory);(winAmount,lossAmount,jackpotAmount,jackpotWins,result);(winAmount,lossAmount,jackpotAmount,jackpotWins,output)"
./0x180d669e995ae5fbb7bfb06107546de625cd4f97_ext.sol,BallzToken.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0xe8d5a2fc2ff2d5de90c98daa6aaed8b250d7965b_ext.sol,MyAdvancedToken.mintToken,203,208,"REF_55(uint256) -> balanceOf[target],REF_55(-> balanceOf) = REF_55 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_55(uint256) -> balanceOf[target]
REF_55(-> balanceOf) = REF_55 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x4d48ee87ab535833fdd79c7d1c4aac3c7c304b13_ext.sol,Pomda.dividendsOf,481,487,"REF_35(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_65(uint256) = profitPerShare_ * REF_35,TMP_66 = CONVERT TMP_65 to int256,REF_36(int256) -> payoutsTo_[_customerAddress],TMP_67(int256) = TMP_66 - REF_36,TMP_68 = CONVERT TMP_67 to uint256,TMP_69(uint256) = TMP_68 / magnitude,RETURN TMP_69","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_35(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_65(uint256) = profitPerShare_ * REF_35
TMP_66 = CONVERT TMP_65 to int256
REF_36(int256) -> payoutsTo_[_customerAddress]
TMP_67(int256) = TMP_66 - REF_36
TMP_68 = CONVERT TMP_67 to uint256
TMP_69(uint256) = TMP_68 / magnitude
RETURN TMP_69""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x42095468d0af5976caa589ad6db91a1b8913be4e_ext.sol,RichToken._transfer,292,307,"REF_33(uint256) -> ownershipTokenCount[_to],TMP_70(uint256) := REF_33(uint256),REF_33(-> ownershipTokenCount) = REF_33 + 1,REF_34(address) -> richtokenIndexToOwner[_tokenId],REF_34(address) (->richtokenIndexToOwner) := _to(address),TMP_71 = CONVERT 0 to address,TMP_72(bool) = _from != TMP_71,CONDITION TMP_72,REF_35(uint256) -> ownershipTokenCount[_from],TMP_73(uint256) := REF_35(uint256),REF_35(-> ownershipTokenCount) = REF_35 - 1,REF_36(address) -> richtokenIndexToApproved[_tokenId],richtokenIndexToApproved = delete REF_36 ,Emit Transfer(_from,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownershipTokenCount[_to] ++

IRs:
REF_33(uint256) -> ownershipTokenCount[_to]
TMP_70(uint256) := REF_33(uint256)
REF_33(-> ownershipTokenCount) = REF_33 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
richtokenIndexToOwner[_tokenId] = _to

IRs:
REF_34(address) -> richtokenIndexToOwner[_tokenId]
REF_34(address) (->richtokenIndexToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_71 = CONVERT 0 to address
TMP_72(bool) = _from != TMP_71
CONDITION TMP_72""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownershipTokenCount[_from] --

IRs:
REF_35(uint256) -> ownershipTokenCount[_from]
TMP_73(uint256) := REF_35(uint256)
REF_35(-> ownershipTokenCount) = REF_35 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete richtokenIndexToApproved[_tokenId]

IRs:
REF_36(address) -> richtokenIndexToApproved[_tokenId]
richtokenIndexToApproved = delete REF_36 ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
}
",0,1,0,0,"ownershipTokenCount[_to] ++;richtokenIndexToOwner[_tokenId] = _to;_from != address(0);ownershipTokenCount[_from] --;;delete richtokenIndexToApproved[_tokenId];Transfer(_from,_to,_tokenId)"
./0x345ab5e5f971dbdbc92af2779ce7a8bbf1819e59_ext.sol,TwentyDollars.bid,62,74,"REF_0(uint256) -> highestBid.amount,TMP_1(bool) = msg.value > REF_0,TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1),REF_1(address) -> secondHighestBid.owner,REF_2(uint256) -> balances[REF_1],REF_3(uint256) -> secondHighestBid.amount,REF_2(-> balances) = REF_2 + REF_3,secondHighestBid(TwentyDollars.Bid) := highestBid(TwentyDollars.Bid),REF_4(address) -> highestBid.owner,REF_4(address) (->highestBid) := msg.sender(address),REF_5(uint256) -> highestBid.amount,REF_5(uint256) (->highestBid) := msg.value(uint256),gameEndBlock(uint256) = gameEndBlock + 10,MODIFIER_CALL, TwentyDollars.onlyBiddingOpen()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value > highestBid.amount)

IRs:
REF_0(uint256) -> highestBid.amount
TMP_1(bool) = msg.value > REF_0
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[secondHighestBid.owner] += secondHighestBid.amount

IRs:
REF_1(address) -> secondHighestBid.owner
REF_2(uint256) -> balances[REF_1]
REF_3(uint256) -> secondHighestBid.amount
REF_2(-> balances) = REF_2 + REF_3""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
secondHighestBid = highestBid

IRs:
secondHighestBid(TwentyDollars.Bid) := highestBid(TwentyDollars.Bid)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
highestBid.owner = msg.sender

IRs:
REF_4(address) -> highestBid.owner
REF_4(address) (->highestBid) := msg.sender(address)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
highestBid.amount = msg.value

IRs:
REF_5(uint256) -> highestBid.amount
REF_5(uint256) (->highestBid) := msg.value(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
gameEndBlock += 10

IRs:
gameEndBlock(uint256) = gameEndBlock + 10""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyBiddingOpen()

IRs:
MODIFIER_CALL, TwentyDollars.onlyBiddingOpen()()""];
7->1;
}
",0,1,0,0,onlyBiddingOpen();require(bool)(msg.value > highestBid.amount);balances[secondHighestBid.owner] += secondHighestBid.amount;secondHighestBid = highestBid;highestBid.owner = msg.sender;highestBid.amount = msg.value;gameEndBlock += 10
./0xb3f48d38ace4b44c710ba32cb5aea66c0f533571_ext.sol,AUTOCOIN.totalSupply,125,127,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0xa31b52ee117b946741c5fb49f010ed1d56b443e0_ext.sol,RegularToken.transferFrom,89,107,"REF_5(uint256) -> balances[_from],TMP_5(bool) = REF_5 >= _value,REF_6(mapping(address => uint256)) -> allowed[_from],REF_7(uint256) -> REF_6[msg.sender],TMP_6(bool) = REF_7 >= _value,TMP_7(bool) = TMP_5 && TMP_6,REF_8(uint256) -> balances[_to],TMP_8(uint256) = REF_8 + _value,REF_9(uint256) -> balances[_to],TMP_9(bool) = TMP_8 >= REF_9,TMP_10(bool) = TMP_7 && TMP_9,CONDITION TMP_10,REF_10(uint256) -> balances[_to],REF_10(-> balances) = REF_10 + _value,REF_11(uint256) -> balances[_from],REF_11(-> balances) = REF_11 - _value,REF_12(mapping(address => uint256)) -> allowed[_from],REF_13(uint256) -> REF_12[msg.sender],REF_13(-> allowed) = REF_13 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN False","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]

IRs:
REF_5(uint256) -> balances[_from]
TMP_5(bool) = REF_5 >= _value
REF_6(mapping(address => uint256)) -> allowed[_from]
REF_7(uint256) -> REF_6[msg.sender]
TMP_6(bool) = REF_7 >= _value
TMP_7(bool) = TMP_5 && TMP_6
REF_8(uint256) -> balances[_to]
TMP_8(uint256) = REF_8 + _value
REF_9(uint256) -> balances[_to]
TMP_9(bool) = TMP_8 >= REF_9
TMP_10(bool) = TMP_7 && TMP_9
CONDITION TMP_10""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_10(uint256) -> balances[_to]
REF_10(-> balances) = REF_10 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_11(uint256) -> balances[_from]
REF_11(-> balances) = REF_11 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_12(mapping(address => uint256)) -> allowed[_from]
REF_13(uint256) -> REF_12[msg.sender]
REF_13(-> allowed) = REF_13 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
}
",0,1,0,0,"balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to];balances[_to] += _value;false;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true"
./0xcdcbb474268703da1b6744c540500e8a2a39e8dc_ext.sol,knf.Award,213,219,"TMP_31 = CONVERT 0 to address,TMP_32(bool) = _to != TMP_31,TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32),REF_45(uint256) -> balances[owner],TMP_34(bool) = _v <= REF_45,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),REF_46(uint256) -> balances[_to],REF_46(-> balances) = REF_46 + _v,REF_47(uint256) -> balances[owner],REF_47(-> balances) = REF_47 - _v,INTERNAL_CALL, knf.RecordTransfer(address,address,uint256)(owner,_to,_v),MODIFIER_CALL, knf.onlyControl()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_31 = CONVERT 0 to address
TMP_32(bool) = _to != TMP_31
TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_v <= balances[owner])

IRs:
REF_45(uint256) -> balances[owner]
TMP_34(bool) = _v <= REF_45
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _v

IRs:
REF_46(uint256) -> balances[_to]
REF_46(-> balances) = REF_46 + _v""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[owner] -= _v

IRs:
REF_47(uint256) -> balances[owner]
REF_47(-> balances) = REF_47 - _v""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RecordTransfer(owner,_to,_v)

IRs:
INTERNAL_CALL, knf.RecordTransfer(address,address,uint256)(owner,_to,_v)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyControl()

IRs:
MODIFIER_CALL, knf.onlyControl()()""];
6->1;
}
",0,1,0,0,"onlyControl();require(bool)(_to != address(0));require(bool)(_v <= balances[owner]);balances[_to] += _v;balances[owner] -= _v;RecordTransfer(owner,_to,_v)"
./0x6e14ccec454b12ab03ef1ca2cf0ef67d6bfd8a26_ext.sol,Admin.admin_tokenAdd,146,152,"REF_14(uint256) -> balanceOf[msg.sender],REF_14(-> balanceOf) = REF_14 + _value,totalSupply(uint256) = totalSupply + _value,Emit TokenAdd(msg.sender,_value),RETURN True,MODIFIER_CALL, Modifiers.isOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[msg.sender] += _value

IRs:
REF_14(uint256) -> balanceOf[msg.sender]
REF_14(-> balanceOf) = REF_14 + _value""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += _value

IRs:
totalSupply(uint256) = totalSupply + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
TokenAdd(msg.sender,_value)

IRs:
Emit TokenAdd(msg.sender,_value)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
isOwner()

IRs:
MODIFIER_CALL, Modifiers.isOwner()()""];
5->1;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"isOwner();balanceOf[msg.sender] += _value;totalSupply += _value;TokenAdd(msg.sender,_value);true;success"
./0x4ca65f54f923be2fb3efc3a7758e88a6f910806e_ext.sol,GamblicaEarlyAccess.addWinnigs,60,68,"REF_7 -> LENGTH winners,REF_8 -> LENGTH amounts,TMP_20(bool) = REF_7 == REF_8,TMP_21(None) = SOLIDITY_CALL require(bool,string)(TMP_20,Invalid arguments),REF_9(GamblicaEarlyAccess.State) -> State.DEPOSIT,TMP_22(bool) = state == REF_9,TMP_23(None) = SOLIDITY_CALL require(bool,string)(TMP_22,Invalid contract state),REF_10 -> LENGTH winners,length(uint256) := REF_10(uint256),i(uint256) := 0(uint256),TMP_24(bool) = i < length,CONDITION TMP_24,REF_11(address) -> winners[i],REF_12(uint256) -> deposit[REF_11],REF_13(uint256) -> amounts[i],REF_12(-> deposit) = REF_12 + REF_13,TMP_25(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, GamblicaEarlyAccess.onlyGamblica()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(winners.length == amounts.length,Invalid arguments)

IRs:
REF_7 -> LENGTH winners
REF_8 -> LENGTH amounts
TMP_20(bool) = REF_7 == REF_8
TMP_21(None) = SOLIDITY_CALL require(bool,string)(TMP_20,Invalid arguments)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(state == State.DEPOSIT,Invalid contract state)

IRs:
REF_9(GamblicaEarlyAccess.State) -> State.DEPOSIT
TMP_22(bool) = state == REF_9
TMP_23(None) = SOLIDITY_CALL require(bool,string)(TMP_22,Invalid contract state)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
length = winners.length

IRs:
REF_10 -> LENGTH winners
length(uint256) := REF_10(uint256)""];
3->6;
4[label=""Node Type: BEGIN_LOOP 4
""];
4->7;
5[label=""Node Type: END_LOOP 5
""];
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
6->4;
7[label=""Node Type: IF_LOOP 7

EXPRESSION:
i < length

IRs:
TMP_24(bool) = i < length
CONDITION TMP_24""];
7->8[label=""True""];
7->5[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
deposit[winners[i]] += amounts[i]

IRs:
REF_11(address) -> winners[i]
REF_12(uint256) -> deposit[REF_11]
REF_13(uint256) -> amounts[i]
REF_12(-> deposit) = REF_12 + REF_13""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_25(uint256) := i(uint256)
i(uint256) = i + 1""];
9->7;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyGamblica()

IRs:
MODIFIER_CALL, GamblicaEarlyAccess.onlyGamblica()()""];
10->1;
}
",0,1,0,0,"onlyGamblica();require(bool,string)(winners.length == amounts.length,Invalid arguments);require(bool,string)(state == State.DEPOSIT,Invalid contract state);length = winners.length;i = 0;;i < length;;deposit[winners[i]] += amounts[i];i ++"
./0xf375e839fecff22f847eb2df66d440aeb7226916_ext.sol,KTLContract.airdrop,67,74,"i(uint256) := 0(uint256),REF_1 -> LENGTH _to,TMP_5(bool) = i < REF_1,CONDITION TMP_5,REF_2(address) -> _to[i],REF_3(uint256) -> balances[REF_2],TMP_6(bool) = REF_3 > 0,CONDITION TMP_6,REF_4(address) -> _to[i],REF_5(uint256) -> _value[i],TMP_7(bool) = INTERNAL_CALL, KTLContract.transfer(address,uint256)(REF_4,REF_5),TMP_8(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Owned.onlyOwner()(),MODIFIER_CALL, KTLContract.notStopped()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _to.length

IRs:
REF_1 -> LENGTH _to
TMP_5(bool) = i < REF_1
CONDITION TMP_5""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
balances[_to[i]] > 0

IRs:
REF_2(address) -> _to[i]
REF_3(uint256) -> balances[REF_2]
TMP_6(bool) = REF_3 > 0
CONDITION TMP_6""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: CONTINUE 6
""];
6->9;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
transfer(_to[i],_value[i])

IRs:
REF_4(address) -> _to[i]
REF_5(uint256) -> _value[i]
TMP_7(bool) = INTERNAL_CALL, KTLContract.transfer(address,uint256)(REF_4,REF_5)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_8(uint256) := i(uint256)
i(uint256) = i + 1""];
9->4;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
notStopped()

IRs:
MODIFIER_CALL, KTLContract.notStopped()()""];
11->3;
}
",0,1,0,0,"onlyOwner();;i < _to.length;;i = 0;balances[_to[i]] > 0;;;i ++;transfer(_to[i],_value[i]);notStopped()"
./0x08d88845df68222fc8a1e631ab1817f1660766c5_ext.sol,SafeMath.add,26,30,"TMP_10(uint256) = a + b,c(uint256) := TMP_10(uint256),TMP_11(bool) = c >= a,TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11),RETURN c","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_10(uint256) = a + b
c(uint256) := TMP_10(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_11(bool) = c >= a
TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c""];
}
",0,1,0,0,c = a + b;assert(bool)(c >= a);c
./0xd41d48be0a81690a785bf1df336163f7b78eadca_ext.sol,Crypland.userOfferSubmitElement,154,163,"REF_76(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group],REF_77(mapping(uint256 => Crypland.Offer)) -> REF_76[asset],REF_78(Crypland.Offer) -> REF_77[unit],REF_79(bool) -> REF_78.isOffer,TMP_86 = UnaryType.BANG REF_79 ,TMP_87(None) = SOLIDITY_CALL require(bool)(TMP_86),TMP_88(bool) = startPrice > 0,TMP_89(bool) = endPrice > 0,TMP_90(bool) = TMP_88 && TMP_89,TMP_91(bool) = duration > 0,TMP_92(bool) = TMP_90 && TMP_91,TMP_93(bool) = startPrice >= endPrice,TMP_94(bool) = TMP_92 && TMP_93,TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94),REF_80(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group],REF_81(mapping(uint256 => Crypland.Offer)) -> REF_80[asset],REF_82(Crypland.Offer) -> REF_81[unit],REF_83(bool) -> REF_82.isOffer,REF_83(bool) (->offers) := True(bool),REF_84(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group],REF_85(mapping(uint256 => Crypland.Offer)) -> REF_84[asset],REF_86(Crypland.Offer) -> REF_85[unit],REF_87(uint256) -> REF_86.startPrice,REF_87(uint256) (->offers) := startPrice(uint256),REF_88(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group],REF_89(mapping(uint256 => Crypland.Offer)) -> REF_88[asset],REF_90(Crypland.Offer) -> REF_89[unit],REF_91(uint256) -> REF_90.endPrice,REF_91(uint256) (->offers) := endPrice(uint256),REF_92(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group],REF_93(mapping(uint256 => Crypland.Offer)) -> REF_92[asset],REF_94(Crypland.Offer) -> REF_93[unit],REF_95(uint256) -> REF_94.startBlock,REF_95(uint256) (->offers) := block.number(uint256),REF_96(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group],REF_97(mapping(uint256 => Crypland.Offer)) -> REF_96[asset],REF_98(Crypland.Offer) -> REF_97[unit],REF_99(uint256) -> REF_98.endBlock,TMP_96(uint256) = block.number + duration,REF_99(uint256) (->offers) := TMP_96(uint256),MODIFIER_CALL, Crypland.whenNotPaused()(),MODIFIER_CALL, Crypland.whenElementHolder(uint256,uint256,uint256)(group,asset,unit)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! offers[group][asset][unit].isOffer)

IRs:
REF_76(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group]
REF_77(mapping(uint256 => Crypland.Offer)) -> REF_76[asset]
REF_78(Crypland.Offer) -> REF_77[unit]
REF_79(bool) -> REF_78.isOffer
TMP_86 = UnaryType.BANG REF_79 
TMP_87(None) = SOLIDITY_CALL require(bool)(TMP_86)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(startPrice > 0 && endPrice > 0 && duration > 0 && startPrice >= endPrice)

IRs:
TMP_88(bool) = startPrice > 0
TMP_89(bool) = endPrice > 0
TMP_90(bool) = TMP_88 && TMP_89
TMP_91(bool) = duration > 0
TMP_92(bool) = TMP_90 && TMP_91
TMP_93(bool) = startPrice >= endPrice
TMP_94(bool) = TMP_92 && TMP_93
TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
offers[group][asset][unit].isOffer = true

IRs:
REF_80(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group]
REF_81(mapping(uint256 => Crypland.Offer)) -> REF_80[asset]
REF_82(Crypland.Offer) -> REF_81[unit]
REF_83(bool) -> REF_82.isOffer
REF_83(bool) (->offers) := True(bool)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
offers[group][asset][unit].startPrice = startPrice

IRs:
REF_84(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group]
REF_85(mapping(uint256 => Crypland.Offer)) -> REF_84[asset]
REF_86(Crypland.Offer) -> REF_85[unit]
REF_87(uint256) -> REF_86.startPrice
REF_87(uint256) (->offers) := startPrice(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
offers[group][asset][unit].endPrice = endPrice

IRs:
REF_88(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group]
REF_89(mapping(uint256 => Crypland.Offer)) -> REF_88[asset]
REF_90(Crypland.Offer) -> REF_89[unit]
REF_91(uint256) -> REF_90.endPrice
REF_91(uint256) (->offers) := endPrice(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
offers[group][asset][unit].startBlock = block.number

IRs:
REF_92(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group]
REF_93(mapping(uint256 => Crypland.Offer)) -> REF_92[asset]
REF_94(Crypland.Offer) -> REF_93[unit]
REF_95(uint256) -> REF_94.startBlock
REF_95(uint256) (->offers) := block.number(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
offers[group][asset][unit].endBlock = block.number + duration

IRs:
REF_96(mapping(uint256 => mapping(uint256 => Crypland.Offer))) -> offers[group]
REF_97(mapping(uint256 => Crypland.Offer)) -> REF_96[asset]
REF_98(Crypland.Offer) -> REF_97[unit]
REF_99(uint256) -> REF_98.endBlock
TMP_96(uint256) = block.number + duration
REF_99(uint256) (->offers) := TMP_96(uint256)""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Crypland.whenNotPaused()()""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
whenElementHolder(group,asset,unit)

IRs:
MODIFIER_CALL, Crypland.whenElementHolder(uint256,uint256,uint256)(group,asset,unit)""];
9->1;
}
",0,1,0,0,"whenNotPaused();require(bool)(! offers[group][asset][unit].isOffer);require(bool)(startPrice > 0 && endPrice > 0 && duration > 0 && startPrice >= endPrice);offers[group][asset][unit].isOffer = true;offers[group][asset][unit].startPrice = startPrice;offers[group][asset][unit].endPrice = endPrice;offers[group][asset][unit].startBlock = block.number;offers[group][asset][unit].endBlock = block.number + duration;whenElementHolder(group,asset,unit)"
./0xec8f9a0de90487e7aa172fe5291fd19ad7163aa1_ext.sol,BDSMAirdrop.multiSend,25,35,"i(uint256) := 0(uint256),REF_0 -> LENGTH _dests,TMP_1(bool) = i < REF_0,CONDITION TMP_1,REF_2(address) -> _dests[i],HIGH_LEVEL_CALL, dest:sharesTokenAddress(token), function:transfer, arguments:['REF_2', 'defValue']  ,i(uint256) = i + 1,TMP_3(uint256) = HIGH_LEVEL_CALL, dest:sharesTokenAddress(token), function:balanceOf, arguments:['this']  ,tokenFree(uint256) := TMP_3(uint256),MODIFIER_CALL, BDSMAirdrop.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->3;
3[label=""Node Type: IF_LOOP 3

EXPRESSION:
i < _dests.length

IRs:
REF_0 -> LENGTH _dests
TMP_1(bool) = i < REF_0
CONDITION TMP_1""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
sharesTokenAddress.transfer(_dests[i],defValue)

IRs:
REF_2(address) -> _dests[i]
HIGH_LEVEL_CALL, dest:sharesTokenAddress(token), function:transfer, arguments:['REF_2', 'defValue']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
i += 1

IRs:
i(uint256) = i + 1""];
5->3;
6[label=""Node Type: END_LOOP 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokenFree = sharesTokenAddress.balanceOf(this)

IRs:
TMP_3(uint256) = HIGH_LEVEL_CALL, dest:sharesTokenAddress(token), function:balanceOf, arguments:['this']  
tokenFree(uint256) := TMP_3(uint256)""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, BDSMAirdrop.onlyOwner()()""];
8->1;
}
",0,1,0,0,"onlyOwner();i = 0;;i < _dests.length;sharesTokenAddress.transfer(_dests[i],defValue);;i += 1;tokenFree = sharesTokenAddress.balanceOf(this)"
./0x1dbd7059247baf317b11c9e36308fa8582867d4b_ext.sol,EDOGE.transferFrom,269,284,"TMP_96(None) = SOLIDITY_CALL require(bool)(unlocked),REF_29(mapping(address => uint256)) -> allowed[_from],REF_30(uint256) -> REF_29[msg.sender],allowance(uint256) := REF_30(uint256),REF_31(uint256) -> balances[_from],TMP_97(bool) = REF_31 >= _value,TMP_98(bool) = allowance >= _value,TMP_99(bool) = TMP_97 && TMP_98,TMP_100(None) = SOLIDITY_CALL require(bool)(TMP_99),REF_32(uint256) -> balances[_to],REF_32(-> balances) = REF_32 + _value,REF_33(uint256) -> balances[_from],REF_33(-> balances) = REF_33 - _value,TMP_101(bool) = allowance < MAX_UINT256,CONDITION TMP_101,REF_34(mapping(address => uint256)) -> allowed[_from],REF_35(uint256) -> REF_34[msg.sender],REF_35(-> allowed) = REF_35 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(unlocked)

IRs:
TMP_96(None) = SOLIDITY_CALL require(bool)(unlocked)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
allowance = allowed[_from][msg.sender]

IRs:
REF_29(mapping(address => uint256)) -> allowed[_from]
REF_30(uint256) -> REF_29[msg.sender]
allowance(uint256) := REF_30(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balances[_from] >= _value && allowance >= _value)

IRs:
REF_31(uint256) -> balances[_from]
TMP_97(bool) = REF_31 >= _value
TMP_98(bool) = allowance >= _value
TMP_99(bool) = TMP_97 && TMP_98
TMP_100(None) = SOLIDITY_CALL require(bool)(TMP_99)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] += _value

IRs:
REF_32(uint256) -> balances[_to]
REF_32(-> balances) = REF_32 + _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[_from] -= _value

IRs:
REF_33(uint256) -> balances[_from]
REF_33(-> balances) = REF_33 - _value""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
allowance < MAX_UINT256

IRs:
TMP_101(bool) = allowance < MAX_UINT256
CONDITION TMP_101""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_34(mapping(address => uint256)) -> allowed[_from]
REF_35(uint256) -> REF_34[msg.sender]
REF_35(-> allowed) = REF_35 - _value""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
9->10;
10[label=""Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True""];
11[label=""Node Type: RETURN 11

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(unlocked);allowance = allowed[_from][msg.sender];require(bool)(balances[_from] >= _value && allowance >= _value);balances[_to] += _value;balances[_from] -= _value;allowance < MAX_UINT256;allowed[_from][msg.sender] -= _value;;Transfer(_from,_to,_value);true;success"
./0x5af7af54e8bc34b293e356ef11fffe51d6f9ae78_ext.sol,Marketplace.buy,541,566,"REF_115(Marketplace.Order) -> sellOrders[_jingleId],REF_116(bool) -> REF_115.exists,TMP_207(bool) = REF_116 == True,TMP_208(None) = SOLIDITY_CALL require(bool)(TMP_207),REF_117(Marketplace.Order) -> sellOrders[_jingleId],REF_118(uint256) -> REF_117.price,TMP_209(bool) = msg.value >= REF_118,TMP_210(None) = SOLIDITY_CALL require(bool)(TMP_209),REF_119(Marketplace.Order) -> sellOrders[_jingleId],REF_120(bool) -> REF_119.exists,REF_120(bool) (->sellOrders) := False(bool),TMP_211(uint256) := numOrders(uint256),numOrders(uint256) = numOrders - 1,INTERNAL_CALL, Marketplace.removeOrder(uint256)(_jingleId),HIGH_LEVEL_CALL, dest:jingleContract(Jingle), function:transfer, arguments:['msg.sender', '_jingleId']  ,REF_122(Marketplace.Order) -> sellOrders[_jingleId],REF_123(uint256) -> REF_122.price,price(uint256) := REF_123(uint256),TMP_214(uint256) = price / 100,TMP_215(uint256) = TMP_214 * OWNERS_CUT,threePercent(uint256) := TMP_215(uint256),REF_124(Marketplace.Order) -> sellOrders[_jingleId],REF_125(address) -> REF_124.seller,TMP_216(uint256) = price - threePercent,Transfer dest:REF_125 value:TMP_216,ownerBalance(uint256) = ownerBalance + threePercent,Emit Bought(_jingleId,msg.sender,msg.value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(sellOrders[_jingleId].exists == true)

IRs:
REF_115(Marketplace.Order) -> sellOrders[_jingleId]
REF_116(bool) -> REF_115.exists
TMP_207(bool) = REF_116 == True
TMP_208(None) = SOLIDITY_CALL require(bool)(TMP_207)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.value >= sellOrders[_jingleId].price)

IRs:
REF_117(Marketplace.Order) -> sellOrders[_jingleId]
REF_118(uint256) -> REF_117.price
TMP_209(bool) = msg.value >= REF_118
TMP_210(None) = SOLIDITY_CALL require(bool)(TMP_209)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
sellOrders[_jingleId].exists = false

IRs:
REF_119(Marketplace.Order) -> sellOrders[_jingleId]
REF_120(bool) -> REF_119.exists
REF_120(bool) (->sellOrders) := False(bool)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
numOrders --

IRs:
TMP_211(uint256) := numOrders(uint256)
numOrders(uint256) = numOrders - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
removeOrder(_jingleId)

IRs:
INTERNAL_CALL, Marketplace.removeOrder(uint256)(_jingleId)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
jingleContract.transfer(msg.sender,_jingleId)

IRs:
HIGH_LEVEL_CALL, dest:jingleContract(Jingle), function:transfer, arguments:['msg.sender', '_jingleId']  ""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
price = sellOrders[_jingleId].price

IRs:
REF_122(Marketplace.Order) -> sellOrders[_jingleId]
REF_123(uint256) -> REF_122.price
price(uint256) := REF_123(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
threePercent = (price / 100) * OWNERS_CUT

IRs:
TMP_214(uint256) = price / 100
TMP_215(uint256) = TMP_214 * OWNERS_CUT
threePercent(uint256) := TMP_215(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
sellOrders[_jingleId].seller.transfer(price - threePercent)

IRs:
REF_124(Marketplace.Order) -> sellOrders[_jingleId]
REF_125(address) -> REF_124.seller
TMP_216(uint256) = price - threePercent
Transfer dest:REF_125 value:TMP_216""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
ownerBalance += threePercent

IRs:
ownerBalance(uint256) = ownerBalance + threePercent""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
Bought(_jingleId,msg.sender,msg.value)

IRs:
Emit Bought(_jingleId,msg.sender,msg.value)""];
}
",0,1,0,0,"require(bool)(sellOrders[_jingleId].exists == true);require(bool)(msg.value >= sellOrders[_jingleId].price);sellOrders[_jingleId].exists = false;numOrders --;removeOrder(_jingleId);jingleContract.transfer(msg.sender,_jingleId);price = sellOrders[_jingleId].price;threePercent = (price / 100) * OWNERS_CUT;sellOrders[_jingleId].seller.transfer(price - threePercent);ownerBalance += threePercent;Bought(_jingleId,msg.sender,msg.value)"
./0xcf5a08af322e52bee93861341f7bd90eb3d65aa3_ext.sol,HeavyLitecoin.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x5c0e4f2a54f1e0716ea64de7cfe83b0cf1ad417b_ext.sol,PowrLedgerToken.approveAndCall,215,225,"REF_24(mapping(address => uint256)) -> allowed[msg.sender],REF_25(uint256) -> REF_24[spender],REF_25(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_43 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_43(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_24(mapping(address => uint256)) -> allowed[msg.sender]
REF_25(uint256) -> REF_24[spender]
REF_25(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_43 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_43(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xaa4ec8484e89bed69570825688789589d38eea5e_ext.sol,Hourglass.dividendsOf,474,480,"REF_35(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_65(uint256) = profitPerShare_ * REF_35,TMP_66 = CONVERT TMP_65 to int256,REF_36(int256) -> payoutsTo_[_customerAddress],TMP_67(int256) = TMP_66 - REF_36,TMP_68 = CONVERT TMP_67 to uint256,TMP_69(uint256) = TMP_68 / magnitude,RETURN TMP_69","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_35(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_65(uint256) = profitPerShare_ * REF_35
TMP_66 = CONVERT TMP_65 to int256
REF_36(int256) -> payoutsTo_[_customerAddress]
TMP_67(int256) = TMP_66 - REF_36
TMP_68 = CONVERT TMP_67 to uint256
TMP_69(uint256) = TMP_68 / magnitude
RETURN TMP_69""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x5abaff0b83f81dc061c590aadcba013c69237fd7_ext.sol,CryptoJade.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x757df3c3cad364da4bbe0795f1fea5cb7e91774e_ext.sol,RobincoinERC20.burn,105,111,"REF_17(uint256) -> balanceOf[msg.sender],TMP_25(bool) = REF_17 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_25(bool) = REF_17 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x449f5c827cf7726cc5f181090aa147ca5fb88a40_ext.sol,Controllable.getActiveContracts,277,279,RETURN contracts,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
contracts

IRs:
RETURN contracts""];
}
",0,1,0,0,contracts
./0x4c7e8e14626249eea89b3d643ebe68795b49a6f1_ext.sol,StandardToken.transfer,45,56,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x5b2028602af2693d50b4157f4acf84d632ec8208_ext.sol,Savings.deposit,30,35,"TMP_4(bool) = msg.value >= 500000000000000000,CONDITION TMP_4,REF_0(uint256) -> deposits[msg.sender],REF_0(-> deposits) = REF_0 + msg.value,Emit Deposit(msg.sender,msg.value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value >= 500000000000000000

IRs:
TMP_4(bool) = msg.value >= 500000000000000000
CONDITION TMP_4""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
deposits[msg.sender] += msg.value

IRs:
REF_0(uint256) -> deposits[msg.sender]
REF_0(-> deposits) = REF_0 + msg.value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Deposit(msg.sender,msg.value)

IRs:
Emit Deposit(msg.sender,msg.value)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,"msg.value >= 500000000000000000;deposits[msg.sender] += msg.value;;Deposit(msg.sender,msg.value)"
./0xda7c27c04f66842faf20644814b644e25e1766ea_ext.sol,OptionsCalculator.calculateOptionsComponents,1016,1061,"TMP_421(ESOPTypes.Employee) = INTERNAL_CALL, ESOPTypes.deserializeEmployee(uint256[9])(employee),emp(ESOPTypes.Employee) := TMP_421(ESOPTypes.Employee),REF_224(ESOPTypes.EmployeeState) -> emp.state,REF_225(ESOPTypes.EmployeeState) -> EmployeeState.OptionsExercised,TMP_422(bool) = REF_224 == REF_225,REF_226(ESOPTypes.EmployeeState) -> emp.state,REF_227(ESOPTypes.EmployeeState) -> EmployeeState.WaitingForSignature,TMP_423(bool) = REF_226 == REF_227,TMP_424(bool) = TMP_422 || TMP_423,CONDITION TMP_424,RETURN 0,0,0,TMP_425(bool) = conversionOfferedAt > 0,TMP_426(bool) = calcAtTime >= conversionOfferedAt,TMP_427(bool) = TMP_425 && TMP_426,isESOPConverted(bool) := TMP_427(bool),REF_228(uint32) -> emp.poolOptions,REF_229(uint32) -> emp.extraOptions,TMP_428(uint32) = REF_228 + REF_229,issuedOptions(uint256) := TMP_428(uint32),TMP_429(bool) = issuedOptions == 0,CONDITION TMP_429,RETURN 0,0,0,REF_230(uint32) -> emp.terminatedAt,TMP_430(bool) = calcAtTime < REF_230,REF_231(uint32) -> emp.terminatedAt,TMP_431(bool) = REF_231 > 0,TMP_432(bool) = TMP_430 && TMP_431,CONDITION TMP_432,REF_232(ESOPTypes.EmployeeState) -> emp.state,REF_233(ESOPTypes.EmployeeState) -> EmployeeState.Employed,REF_232(ESOPTypes.EmployeeState) (->emp) := REF_233(ESOPTypes.EmployeeState),vestedOptions(uint256) := issuedOptions(uint256),REF_234(ESOPTypes.EmployeeState) -> emp.state,REF_235(ESOPTypes.EmployeeState) -> EmployeeState.Employed,TMP_433(bool) = REF_234 == REF_235,TMP_434(bool) = isESOPConverted && TMP_433,TMP_435 = UnaryType.BANG disableAcceleratedVesting ,TMP_436(bool) = TMP_434 && TMP_435,accelerateVesting(bool) := TMP_436(bool),TMP_437 = UnaryType.BANG accelerateVesting ,CONDITION TMP_437,REF_236(uint32) -> emp.issueDate,TMP_438(uint256) = INTERNAL_CALL, OptionsCalculator.calculateVestedOptions(uint256,uint256,uint256)(calcVestingAt,REF_236,issuedOptions),vestedOptions(uint256) := TMP_438(uint256),REF_237(ESOPTypes.EmployeeState) -> emp.state,REF_238(ESOPTypes.EmployeeState) -> EmployeeState.Terminated,TMP_439(bool) = REF_237 == REF_238,CONDITION TMP_439,REF_239(uint32) -> emp.poolOptions,REF_240(uint32) -> emp.extraOptions,TUPLE_3(uint256,uint256) = INTERNAL_CALL, OptionsCalculator.extractVestedOptionsComponents(uint256,uint256,uint256)(REF_239,REF_240,vestedOptions),vestedPoolOptions(uint256)= UNPACK TUPLE_3 index: 0 ,vestedExtraOptions(uint256)= UNPACK TUPLE_3 index: 1 ,REF_241(ESOPTypes.EmployeeState) -> emp.state,REF_242(ESOPTypes.EmployeeState) -> EmployeeState.Terminated,TMP_440(bool) = REF_241 == REF_242,CONDITION TMP_440,REF_243(uint32) -> emp.terminatedAt,calcVestingAt(uint32) := REF_243(uint32),CONDITION isESOPConverted,REF_244(uint32) -> emp.issueDate,REF_245(uint32) -> emp.terminatedAt,TMP_441(uint256) = INTERNAL_CALL, OptionsCalculator.applyFadeoutToOptions(uint32,uint32,uint32,uint256,uint256)(conversionOfferedAt,REF_244,REF_245,issuedOptions,vestedOptions),vestedOptions(uint256) := TMP_441(uint256),REF_246(uint32) -> emp.issueDate,REF_247(uint32) -> emp.terminatedAt,TMP_442(uint256) = INTERNAL_CALL, OptionsCalculator.applyFadeoutToOptions(uint32,uint32,uint32,uint256,uint256)(calcAtTime,REF_246,REF_247,issuedOptions,vestedOptions),vestedOptions(uint256) := TMP_442(uint256),CONDITION accelerateVesting,TMP_443(uint256) = vestedPoolOptions * bonusOptionsPromille,TMP_444(uint256) = INTERNAL_CALL, Math.divRound(uint256,uint256)(TMP_443,FP_SCALE),RETURN vestedPoolOptions,vestedExtraOptions,TMP_444,RETURN vestedPoolOptions,vestedExtraOptions,0,REF_248(uint32) -> emp.suspendedAt,TMP_445(bool) = REF_248 > 0,REF_249(uint32) -> emp.suspendedAt,TMP_446(bool) = REF_249 < calcAtTime,TMP_447(bool) = TMP_445 && TMP_446,CONDITION TMP_447,REF_250(uint32) -> emp.suspendedAt,calcVestingAt(uint32) := REF_250(uint32),TMP_448(bool) = conversionOfferedAt > 0,CONDITION TMP_448,calcVestingAt(uint32) := conversionOfferedAt(uint32),calcVestingAt(uint32) := calcAtTime(uint32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
emp = deserializeEmployee(employee)

IRs:
TMP_421(ESOPTypes.Employee) = INTERNAL_CALL, ESOPTypes.deserializeEmployee(uint256[9])(employee)
emp(ESOPTypes.Employee) := TMP_421(ESOPTypes.Employee)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
emp.state == EmployeeState.OptionsExercised || emp.state == EmployeeState.WaitingForSignature

IRs:
REF_224(ESOPTypes.EmployeeState) -> emp.state
REF_225(ESOPTypes.EmployeeState) -> EmployeeState.OptionsExercised
TMP_422(bool) = REF_224 == REF_225
REF_226(ESOPTypes.EmployeeState) -> emp.state
REF_227(ESOPTypes.EmployeeState) -> EmployeeState.WaitingForSignature
TMP_423(bool) = REF_226 == REF_227
TMP_424(bool) = TMP_422 || TMP_423
CONDITION TMP_424""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3

EXPRESSION:
(0,0,0)

IRs:
RETURN 0,0,0""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
isESOPConverted = conversionOfferedAt > 0 && calcAtTime >= conversionOfferedAt

IRs:
TMP_425(bool) = conversionOfferedAt > 0
TMP_426(bool) = calcAtTime >= conversionOfferedAt
TMP_427(bool) = TMP_425 && TMP_426
isESOPConverted(bool) := TMP_427(bool)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
issuedOptions = emp.poolOptions + emp.extraOptions

IRs:
REF_228(uint32) -> emp.poolOptions
REF_229(uint32) -> emp.extraOptions
TMP_428(uint32) = REF_228 + REF_229
issuedOptions(uint256) := TMP_428(uint32)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
issuedOptions == 0

IRs:
TMP_429(bool) = issuedOptions == 0
CONDITION TMP_429""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: RETURN 8

EXPRESSION:
(0,0,0)

IRs:
RETURN 0,0,0""];
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
calcAtTime < emp.terminatedAt && emp.terminatedAt > 0

IRs:
REF_230(uint32) -> emp.terminatedAt
TMP_430(bool) = calcAtTime < REF_230
REF_231(uint32) -> emp.terminatedAt
TMP_431(bool) = REF_231 > 0
TMP_432(bool) = TMP_430 && TMP_431
CONDITION TMP_432""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
emp.state = EmployeeState.Employed

IRs:
REF_232(ESOPTypes.EmployeeState) -> emp.state
REF_233(ESOPTypes.EmployeeState) -> EmployeeState.Employed
REF_232(ESOPTypes.EmployeeState) (->emp) := REF_233(ESOPTypes.EmployeeState)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
vestedOptions = issuedOptions

IRs:
vestedOptions(uint256) := issuedOptions(uint256)""];
13->14;
14[label=""Node Type: NEW VARIABLE 14

EXPRESSION:
accelerateVesting = isESOPConverted && emp.state == EmployeeState.Employed && ! disableAcceleratedVesting

IRs:
REF_234(ESOPTypes.EmployeeState) -> emp.state
REF_235(ESOPTypes.EmployeeState) -> EmployeeState.Employed
TMP_433(bool) = REF_234 == REF_235
TMP_434(bool) = isESOPConverted && TMP_433
TMP_435 = UnaryType.BANG disableAcceleratedVesting 
TMP_436(bool) = TMP_434 && TMP_435
accelerateVesting(bool) := TMP_436(bool)""];
14->15;
15[label=""Node Type: IF 15

EXPRESSION:
! accelerateVesting

IRs:
TMP_437 = UnaryType.BANG accelerateVesting 
CONDITION TMP_437""];
15->26[label=""True""];
15->18[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
vestedOptions = calculateVestedOptions(calcVestingAt,emp.issueDate,issuedOptions)

IRs:
REF_236(uint32) -> emp.issueDate
TMP_438(uint256) = INTERNAL_CALL, OptionsCalculator.calculateVestedOptions(uint256,uint256,uint256)(calcVestingAt,REF_236,issuedOptions)
vestedOptions(uint256) := TMP_438(uint256)""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: IF 19

EXPRESSION:
emp.state == EmployeeState.Terminated

IRs:
REF_237(ESOPTypes.EmployeeState) -> emp.state
REF_238(ESOPTypes.EmployeeState) -> EmployeeState.Terminated
TMP_439(bool) = REF_237 == REF_238
CONDITION TMP_439""];
19->30[label=""True""];
19->21[label=""False""];
21[label=""Node Type: END_IF 21
""];
21->22;
22[label=""Node Type: NEW VARIABLE 22
""];
22->23;
23[label=""Node Type: NEW VARIABLE 23
""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
(vestedPoolOptions,vestedExtraOptions) = extractVestedOptionsComponents(emp.poolOptions,emp.extraOptions,vestedOptions)

IRs:
REF_239(uint32) -> emp.poolOptions
REF_240(uint32) -> emp.extraOptions
TUPLE_3(uint256,uint256) = INTERNAL_CALL, OptionsCalculator.extractVestedOptionsComponents(uint256,uint256,uint256)(REF_239,REF_240,vestedOptions)
vestedPoolOptions(uint256)= UNPACK TUPLE_3 index: 0 
vestedExtraOptions(uint256)= UNPACK TUPLE_3 index: 1 ""];
24->34;
26[label=""Node Type: IF 26

EXPRESSION:
emp.state == EmployeeState.Terminated

IRs:
REF_241(ESOPTypes.EmployeeState) -> emp.state
REF_242(ESOPTypes.EmployeeState) -> EmployeeState.Terminated
TMP_440(bool) = REF_241 == REF_242
CONDITION TMP_440""];
26->27[label=""True""];
26->38[label=""False""];
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
calcVestingAt = emp.terminatedAt

IRs:
REF_243(uint32) -> emp.terminatedAt
calcVestingAt(uint32) := REF_243(uint32)""];
27->29;
29[label=""Node Type: END_IF 29
""];
29->17;
30[label=""Node Type: IF 30

EXPRESSION:
isESOPConverted

IRs:
CONDITION isESOPConverted""];
30->31[label=""True""];
30->32[label=""False""];
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
vestedOptions = applyFadeoutToOptions(conversionOfferedAt,emp.issueDate,emp.terminatedAt,issuedOptions,vestedOptions)

IRs:
REF_244(uint32) -> emp.issueDate
REF_245(uint32) -> emp.terminatedAt
TMP_441(uint256) = INTERNAL_CALL, OptionsCalculator.applyFadeoutToOptions(uint32,uint32,uint32,uint256,uint256)(conversionOfferedAt,REF_244,REF_245,issuedOptions,vestedOptions)
vestedOptions(uint256) := TMP_441(uint256)""];
31->33;
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
vestedOptions = applyFadeoutToOptions(calcAtTime,emp.issueDate,emp.terminatedAt,issuedOptions,vestedOptions)

IRs:
REF_246(uint32) -> emp.issueDate
REF_247(uint32) -> emp.terminatedAt
TMP_442(uint256) = INTERNAL_CALL, OptionsCalculator.applyFadeoutToOptions(uint32,uint32,uint32,uint256,uint256)(calcAtTime,REF_246,REF_247,issuedOptions,vestedOptions)
vestedOptions(uint256) := TMP_442(uint256)""];
32->33;
33[label=""Node Type: END_IF 33
""];
33->21;
34[label=""Node Type: IF 34

EXPRESSION:
accelerateVesting

IRs:
CONDITION accelerateVesting""];
34->35[label=""True""];
34->36[label=""False""];
35[label=""Node Type: RETURN 35

EXPRESSION:
(vestedPoolOptions,vestedExtraOptions,divRound(vestedPoolOptions * bonusOptionsPromille,FP_SCALE))

IRs:
TMP_443(uint256) = vestedPoolOptions * bonusOptionsPromille
TMP_444(uint256) = INTERNAL_CALL, Math.divRound(uint256,uint256)(TMP_443,FP_SCALE)
RETURN vestedPoolOptions,vestedExtraOptions,TMP_444""];
36[label=""Node Type: RETURN 36

EXPRESSION:
(vestedPoolOptions,vestedExtraOptions,0)

IRs:
RETURN vestedPoolOptions,vestedExtraOptions,0""];
38[label=""Node Type: IF 38

EXPRESSION:
emp.suspendedAt > 0 && emp.suspendedAt < calcAtTime

IRs:
REF_248(uint32) -> emp.suspendedAt
TMP_445(bool) = REF_248 > 0
REF_249(uint32) -> emp.suspendedAt
TMP_446(bool) = REF_249 < calcAtTime
TMP_447(bool) = TMP_445 && TMP_446
CONDITION TMP_447""];
38->39[label=""True""];
38->42[label=""False""];
39[label=""Node Type: EXPRESSION 39

EXPRESSION:
calcVestingAt = emp.suspendedAt

IRs:
REF_250(uint32) -> emp.suspendedAt
calcVestingAt(uint32) := REF_250(uint32)""];
39->41;
41[label=""Node Type: END_IF 41
""];
41->29;
42[label=""Node Type: IF 42

EXPRESSION:
conversionOfferedAt > 0

IRs:
TMP_448(bool) = conversionOfferedAt > 0
CONDITION TMP_448""];
42->43[label=""True""];
42->44[label=""False""];
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
calcVestingAt = conversionOfferedAt

IRs:
calcVestingAt(uint32) := conversionOfferedAt(uint32)""];
43->45;
44[label=""Node Type: EXPRESSION 44

EXPRESSION:
calcVestingAt = calcAtTime

IRs:
calcVestingAt(uint32) := calcAtTime(uint32)""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->41;
}
",0,1,0,0,"emp = deserializeEmployee(employee);emp.state == EmployeeState.OptionsExercised || emp.state == EmployeeState.WaitingForSignature;(0,0,0);;isESOPConverted = conversionOfferedAt > 0 && calcAtTime >= conversionOfferedAt;issuedOptions = emp.poolOptions + emp.extraOptions;issuedOptions == 0;(0,0,0);;calcAtTime < emp.terminatedAt && emp.terminatedAt > 0;emp.state = EmployeeState.Employed;;vestedOptions = issuedOptions;accelerateVesting = isESOPConverted && emp.state == EmployeeState.Employed && ! disableAcceleratedVesting;! accelerateVesting;emp.state == EmployeeState.Terminated;;vestedOptions = calculateVestedOptions(calcVestingAt,emp.issueDate,issuedOptions);emp.state == EmployeeState.Terminated;isESOPConverted;;;;(vestedPoolOptions,vestedExtraOptions) = extractVestedOptionsComponents(emp.poolOptions,emp.extraOptions,vestedOptions);accelerateVesting;calcVestingAt = emp.terminatedAt;emp.suspendedAt > 0 && emp.suspendedAt < calcAtTime;;vestedOptions = applyFadeoutToOptions(conversionOfferedAt,emp.issueDate,emp.terminatedAt,issuedOptions,vestedOptions);vestedOptions = applyFadeoutToOptions(calcAtTime,emp.issueDate,emp.terminatedAt,issuedOptions,vestedOptions);;(vestedPoolOptions,vestedExtraOptions,divRound(vestedPoolOptions * bonusOptionsPromille,FP_SCALE));(vestedPoolOptions,vestedExtraOptions,0);calcVestingAt = emp.suspendedAt;conversionOfferedAt > 0;;calcVestingAt = conversionOfferedAt;calcVestingAt = calcAtTime;"
./0x6d8811059eb8f0509acec06648ea95b3ae01be72_ext.sol,TokenERC20._transfer,47,63,"TMP_3 = CONVERT 0 to address,TMP_4(bool) = _to != TMP_3,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_1(uint256) -> balanceOf[_from],TMP_6(bool) = REF_1 >= _value,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_2(uint256) -> balanceOf[_to],TMP_8(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_9(bool) = TMP_8 >= REF_3,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_11(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_11(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_13(uint256) = REF_8 + REF_9,TMP_14(bool) = TMP_13 == previousBalances,TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0x0))

IRs:
TMP_3 = CONVERT 0 to address
TMP_4(bool) = _to != TMP_3
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_6(bool) = REF_1 >= _value
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_8(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_9(bool) = TMP_8 >= REF_3
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_11(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_11(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_13(uint256) = REF_8 + REF_9
TMP_14(bool) = TMP_13 == previousBalances
TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)""];
}
",0,1,0,0,"require(bool)(_to != address(0x0));require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x580c1e3caca14826976b5820947f7ad486ac174d_ext.sol,BitcoinAgileToken.mintToken,197,202,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x0e9e062d7e60c8a6a406488631dae1c5f6db0e7d_ext.sol,TextMessage.sendText,72,76,"TMP_11 = UnaryType.BANG enabled ,CONDITION TMP_11,TMP_12(bool) = msg.value < cost,CONDITION TMP_12,INTERNAL_CALL, TextMessage.sendMsg(string,string)(phoneNumber,textBody)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
! enabled

IRs:
TMP_11 = UnaryType.BANG enabled 
CONDITION TMP_11""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
msg.value < cost

IRs:
TMP_12(bool) = msg.value < cost
CONDITION TMP_12""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: THROW 5
""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
sendMsg(phoneNumber,textBody)

IRs:
INTERNAL_CALL, TextMessage.sendMsg(string,string)(phoneNumber,textBody)""];
}
",0,1,0,0,"! enabled;;;msg.value < cost;;;sendMsg(phoneNumber,textBody)"
./0xd8ee3a6b246674a7c6ca07ed9d8b4500d1d80371_ext.sol,MemeRecorder.getMemes,128,130,RETURN memeContracts,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
memeContracts

IRs:
RETURN memeContracts""];
}
",0,1,0,0,memeContracts
./0x1ebd8d3ca115451b9b6bbaa7ee2f7b0f96e49fd8_ext.sol,ArthurStandardToken.approveAndCall,98,104,"REF_31(mapping(address => uint256)) -> allowed[msg.sender],REF_32(uint256) -> REF_31[_spender],REF_32(uint256) (->allowed) := _value(uint256),Emit Approval(msg.sender,_spender,_value),TMP_23(bytes32) = SOLIDITY_CALL keccak256()(receiveApproval(address,uint256,address,bytes)),TMP_24 = CONVERT TMP_23 to bytes32,TMP_25 = CONVERT TMP_24 to bytes4,TMP_26(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_25', 'msg.sender', '_value', 'this', '_extraData']  ,TMP_27 = UnaryType.BANG TMP_26 ,CONDITION TMP_27,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_31(mapping(address => uint256)) -> allowed[msg.sender]
REF_32(uint256) -> REF_31[_spender]
REF_32(uint256) (->allowed) := _value(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
! _spender.call(bytes4(bytes32(keccak256()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData)

IRs:
TMP_23(bytes32) = SOLIDITY_CALL keccak256()(receiveApproval(address,uint256,address,bytes))
TMP_24 = CONVERT TMP_23 to bytes32
TMP_25 = CONVERT TMP_24 to bytes4
TMP_26(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_25', 'msg.sender', '_value', 'this', '_extraData']  
TMP_27 = UnaryType.BANG TMP_26 
CONDITION TMP_27""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: THROW 4
""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][_spender] = _value;Approval(msg.sender,_spender,_value);! _spender.call(bytes4(bytes32(keccak256()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData);;;true;success"
./0x7996f859a313aab6458558c648e2f1f4acbf5f93_ext.sol,HealthAidToken.distributeHAT,73,82,"i(uint256) := 0(uint256),REF_1 -> LENGTH addresses,TMP_2(bool) = i < REF_1,CONDITION TMP_2,REF_2(address) -> addresses[i],TMP_3(uint256) = INTERNAL_CALL, HealthAidToken.getEthBalance(address)(REF_2),TMP_4(bool) = TMP_3 < _ethbal,CONDITION TMP_4,REF_3(uint256) -> balances[owner],REF_3(-> balances) = REF_3 - _value,REF_4(address) -> addresses[i],REF_5(uint256) -> balances[REF_4],REF_5(-> balances) = REF_5 + _value,REF_6(address) -> addresses[i],Emit Transfer(owner,REF_6,_value),TMP_6(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, HealthAidToken.onlyOwner()(),MODIFIER_CALL, HealthAidToken.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addresses.length

IRs:
REF_1 -> LENGTH addresses
TMP_2(bool) = i < REF_1
CONDITION TMP_2""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
getEthBalance(addresses[i]) < _ethbal

IRs:
REF_2(address) -> addresses[i]
TMP_3(uint256) = INTERNAL_CALL, HealthAidToken.getEthBalance(address)(REF_2)
TMP_4(bool) = TMP_3 < _ethbal
CONDITION TMP_4""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: CONTINUE 6
""];
6->11;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[owner] -= _value

IRs:
REF_3(uint256) -> balances[owner]
REF_3(-> balances) = REF_3 - _value""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
balances[addresses[i]] += _value

IRs:
REF_4(address) -> addresses[i]
REF_5(uint256) -> balances[REF_4]
REF_5(-> balances) = REF_5 + _value""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Transfer(owner,addresses[i],_value)

IRs:
REF_6(address) -> addresses[i]
Emit Transfer(owner,REF_6,_value)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_6(uint256) := i(uint256)
i(uint256) = i + 1""];
11->4;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, HealthAidToken.onlyOwner()()""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, HealthAidToken.canDistr()()""];
13->3;
}
",0,1,0,0,"onlyOwner();;i < addresses.length;;i = 0;getEthBalance(addresses[i]) < _ethbal;;;i ++;balances[owner] -= _value;balances[addresses[i]] += _value;Transfer(owner,addresses[i],_value);canDistr()"
./0x415f07c7c57b1a213767ed8e3eb4b321fa04bb7c_ext.sol,TokenGameHub.burn,145,151,"REF_17(uint256) -> balanceOf[msg.sender],TMP_25(bool) = REF_17 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_25(bool) = REF_17 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x32df1ab2161317adbeafd47bcb30a2f1a806ccfb_ext.sol,TokenBaseAsset.addToken,17,20,"TMP_0(bool) = msg.sender == mOwner,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_0(string) -> mTokens[pDocumentHash],REF_0(string) (->mTokens) := pDocumentToken(string)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == mOwner)

IRs:
TMP_0(bool) = msg.sender == mOwner
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
mTokens[pDocumentHash] = pDocumentToken

IRs:
REF_0(string) -> mTokens[pDocumentHash]
REF_0(string) (->mTokens) := pDocumentToken(string)""];
}
",0,1,0,0,require(bool)(msg.sender == mOwner);mTokens[pDocumentHash] = pDocumentToken
./0x6abf810730a342add1374e11f3e97500ee774d1f_ext.sol,BCFAuction.calculateCurrentPrice,580,594,"TMP_350(bool) = secondsElapsed >= duration,CONDITION TMP_350,RETURN endPrice,TMP_351 = CONVERT endPrice to int256,TMP_352 = CONVERT startPrice to int256,TMP_353(int256) = TMP_351 - TMP_352,totalPriceChange(int256) := TMP_353(int256),TMP_354 = CONVERT secondsElapsed to int256,TMP_355(int256) = totalPriceChange * TMP_354,TMP_356 = CONVERT duration to int256,TMP_357(int256) = TMP_355 / TMP_356,currentPriceChange(int256) := TMP_357(int256),TMP_358 = CONVERT startPrice to int256,TMP_359(int256) = TMP_358 + currentPriceChange,_currentPrice(int256) := TMP_359(int256),TMP_360 = CONVERT _currentPrice to uint256,RETURN TMP_360","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
secondsElapsed >= duration

IRs:
TMP_350(bool) = secondsElapsed >= duration
CONDITION TMP_350""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
endPrice

IRs:
RETURN endPrice""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
totalPriceChange = int256(endPrice) - int256(startPrice)

IRs:
TMP_351 = CONVERT endPrice to int256
TMP_352 = CONVERT startPrice to int256
TMP_353(int256) = TMP_351 - TMP_352
totalPriceChange(int256) := TMP_353(int256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
currentPriceChange = totalPriceChange * int256(secondsElapsed) / int256(duration)

IRs:
TMP_354 = CONVERT secondsElapsed to int256
TMP_355(int256) = totalPriceChange * TMP_354
TMP_356 = CONVERT duration to int256
TMP_357(int256) = TMP_355 / TMP_356
currentPriceChange(int256) := TMP_357(int256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
_currentPrice = int256(startPrice) + currentPriceChange

IRs:
TMP_358 = CONVERT startPrice to int256
TMP_359(int256) = TMP_358 + currentPriceChange
_currentPrice(int256) := TMP_359(int256)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
uint256(_currentPrice)

IRs:
TMP_360 = CONVERT _currentPrice to uint256
RETURN TMP_360""];
}
",0,1,0,0,secondsElapsed >= duration;endPrice;;totalPriceChange = int256(endPrice) - int256(startPrice);currentPriceChange = totalPriceChange * int256(secondsElapsed) / int256(duration);_currentPrice = int256(startPrice) + currentPriceChange;uint256(_currentPrice)
./0xc3c412b97dc3355f1bd060223e75fb047c869197_ext.sol,HngCoin.burn,170,176,"REF_17(uint256) -> balanceOf[msg.sender],TMP_31(bool) = REF_17 >= _value,TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_31(bool) = REF_17 >= _value
TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x8a113a57e74aef531bee8de7e16e604916f053ac_ext.sol,ClipperCoin.burnFrom,347,357,"REF_33(uint256) -> balanceOf[_from],TMP_68(bool) = REF_33 >= _value,TMP_69(None) = SOLIDITY_CALL require(bool)(TMP_68),REF_34(mapping(address => uint256)) -> allowance[_from],REF_35(uint256) -> REF_34[msg.sender],TMP_70(bool) = _value <= REF_35,TMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70),REF_36(uint256) -> balanceOf[_from],REF_36(-> balanceOf) = REF_36 - _value,REF_37(mapping(address => uint256)) -> allowance[_from],REF_38(uint256) -> REF_37[msg.sender],REF_38(-> allowance) = REF_38 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_33(uint256) -> balanceOf[_from]
TMP_68(bool) = REF_33 >= _value
TMP_69(None) = SOLIDITY_CALL require(bool)(TMP_68)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_34(mapping(address => uint256)) -> allowance[_from]
REF_35(uint256) -> REF_34[msg.sender]
TMP_70(bool) = _value <= REF_35
TMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_36(uint256) -> balanceOf[_from]
REF_36(-> balanceOf) = REF_36 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_37(mapping(address => uint256)) -> allowance[_from]
REF_38(uint256) -> REF_37[msg.sender]
REF_38(-> allowance) = REF_38 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xed2192afa8c062dfd6883759380b7f2d1dc6c0c0_ext.sol,Owned.execute,48,50,"TMP_3(bool) = LOW_LEVEL_CALL, dest:_dst, function:call, arguments:['_data'] value:_value ,MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_dst.call.value(_value)(_data)

IRs:
TMP_3(bool) = LOW_LEVEL_CALL, dest:_dst, function:call, arguments:['_data'] value:_value ""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
2->1;
}
",0,1,0,0,onlyOwner();_dst.call.value(_value)(_data)
./0xf064c38e3f5fa73981ee98372d32a16d032769cc_ext.sol,Studio.burn,147,153,"REF_24(uint256) -> balanceOf[msg.sender],TMP_20(bool) = REF_24 < _value,CONDITION TMP_20,REF_25(uint256) -> balanceOf[msg.sender],REF_25(-> balanceOf) = REF_25 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balanceOf[msg.sender] < _value

IRs:
REF_24(uint256) -> balanceOf[msg.sender]
TMP_20(bool) = REF_24 < _value
CONDITION TMP_20""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_25(uint256) -> balanceOf[msg.sender]
REF_25(-> balanceOf) = REF_25 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balanceOf[msg.sender] < _value;;;balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x512d3dfe9c5f04276d772984c3a94039ad34b32b_ext.sol,Airdrop.transfer,5,13,"REF_0 -> LENGTH _tos,TMP_0(bool) = REF_0 > 0,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_1 -> LENGTH v,TMP_2(bool) = REF_1 > 0,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),TMP_4(bytes32) = SOLIDITY_CALL keccak256()(transferFrom(address,address,uint256)),TMP_5 = CONVERT TMP_4 to bytes4,id(bytes4) := TMP_5(bytes4),i(uint256) := 0(uint256),REF_2 -> LENGTH _tos,TMP_6(bool) = i < REF_2,CONDITION TMP_6,REF_4(address) -> _tos[i],REF_5(uint256) -> v[i],TMP_7(bool) = LOW_LEVEL_CALL, dest:caddress, function:call, arguments:['id', 'from', 'REF_4', 'REF_5']  ,TMP_8(None) = SOLIDITY_CALL require(bool)(TMP_7),TMP_9(uint256) := i(uint256),i(uint256) = i + 1,RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_tos.length > 0)

IRs:
REF_0 -> LENGTH _tos
TMP_0(bool) = REF_0 > 0
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(v.length > 0)

IRs:
REF_1 -> LENGTH v
TMP_2(bool) = REF_1 > 0
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
id = bytes4(keccak256()(transferFrom(address,address,uint256)))

IRs:
TMP_4(bytes32) = SOLIDITY_CALL keccak256()(transferFrom(address,address,uint256))
TMP_5 = CONVERT TMP_4 to bytes4
id(bytes4) := TMP_5(bytes4)""];
3->6;
4[label=""Node Type: BEGIN_LOOP 4
""];
4->7;
5[label=""Node Type: END_LOOP 5
""];
5->10;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
6->4;
7[label=""Node Type: IF_LOOP 7

EXPRESSION:
i < _tos.length

IRs:
REF_2 -> LENGTH _tos
TMP_6(bool) = i < REF_2
CONDITION TMP_6""];
7->8[label=""True""];
7->5[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(caddress.call(id,from,_tos[i],v[i]))

IRs:
REF_4(address) -> _tos[i]
REF_5(uint256) -> v[i]
TMP_7(bool) = LOW_LEVEL_CALL, dest:caddress, function:call, arguments:['id', 'from', 'REF_4', 'REF_5']  
TMP_8(None) = SOLIDITY_CALL require(bool)(TMP_7)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_9(uint256) := i(uint256)
i(uint256) = i + 1""];
9->7;
10[label=""Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(_tos.length > 0);require(bool)(v.length > 0);id = bytes4(keccak256()(transferFrom(address,address,uint256)));i = 0;;i < _tos.length;;true;require(bool)(caddress.call(id,from,_tos[i],v[i]));i ++"
./0x36b53bf543eebf9ad42c5f161efd1247f38d034d_ext.sol,REOC._transfer,38,54,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xb430244b442c228a59a0fd4450fa7eedd5fbf833_ext.sol,VOC_ethchf_48013527701_20181215.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x70b8028610e60c1962522e0559c9a658663cfcce_ext.sol,Olympus.fallback,21,44,"sender(address) := msg.sender(address),amount(uint256) := msg.value(uint256),TMP_8(bool) = amount > 0,CONDITION TMP_8,TMP_9(bool) = totalPersons > 10,CONDITION TMP_9,TMP_10(uint256) = INTERNAL_CALL, Olympus.calculateSupportPercent(uint256)(amount),Transfer dest:supportAddress value:TMP_10,TMP_12(bool) = totalShares > 0,CONDITION TMP_12,TMP_13(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['amount', 'totalShares'] ,TMP_14 = CONVERT this to address,TMP_15(uint256) = SOLIDITY_CALL balance(address)(TMP_14),TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_15', 'amount'] ,TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_13', 'TMP_16'] ,amount(uint256) := TMP_17(uint256),REF_9(uint256) -> shares[sender],TMP_18(bool) = REF_9 == 0,CONDITION TMP_18,TMP_19(uint256) := totalPersons(uint256),totalPersons(uint256) = totalPersons + 1,REF_10(uint256) -> shares[sender],REF_11(uint256) -> shares[sender],TMP_20(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_11', 'amount'] ,REF_10(uint256) (->shares) := TMP_20(uint256),TMP_21(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalShares', 'amount'] ,totalShares(uint256) := TMP_21(uint256),TMP_22(uint256) = INTERNAL_CALL, Olympus.getBalance(address)(sender),amount(uint256) := TMP_22(uint256),REF_15(uint256) -> shares[sender],TMP_23(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalShares', 'REF_15'] ,totalShares(uint256) := TMP_23(uint256),REF_16(uint256) -> shares[sender],REF_16(uint256) (->shares) := 0(uint256),TMP_24(uint256) := totalPersons(uint256),totalPersons(uint256) = totalPersons - 1,TMP_25(uint256) = INTERNAL_CALL, Olympus.calculateSupportPercent(uint256)(amount),percent(uint256) := TMP_25(uint256),Transfer dest:supportAddress value:percent,TMP_27(uint256) = amount - percent,Transfer dest:sender value:TMP_27,TMP_29(bool) = totalPersons == 0,CONDITION TMP_29,TMP_30 = CONVERT this to address,TMP_31(uint256) = SOLIDITY_CALL balance(address)(TMP_30),Transfer dest:supportAddress value:TMP_31","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
sender = msg.sender

IRs:
sender(address) := msg.sender(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = msg.value

IRs:
amount(uint256) := msg.value(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
amount > 0

IRs:
TMP_8(bool) = amount > 0
CONDITION TMP_8""];
3->4[label=""True""];
3->15[label=""False""];
4[label=""Node Type: IF 4

EXPRESSION:
totalPersons > 10

IRs:
TMP_9(bool) = totalPersons > 10
CONDITION TMP_9""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
supportAddress.transfer(calculateSupportPercent(amount))

IRs:
TMP_10(uint256) = INTERNAL_CALL, Olympus.calculateSupportPercent(uint256)(amount)
Transfer dest:supportAddress value:TMP_10""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
totalShares > 0

IRs:
TMP_12(bool) = totalShares > 0
CONDITION TMP_12""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
amount = amount.mul(totalShares).div(address(this).balance.sub(amount))

IRs:
TMP_13(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['amount', 'totalShares'] 
TMP_14 = CONVERT this to address
TMP_15(uint256) = SOLIDITY_CALL balance(address)(TMP_14)
TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_15', 'amount'] 
TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_13', 'TMP_16'] 
amount(uint256) := TMP_17(uint256)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
shares[sender] == 0

IRs:
REF_9(uint256) -> shares[sender]
TMP_18(bool) = REF_9 == 0
CONDITION TMP_18""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
totalPersons ++

IRs:
TMP_19(uint256) := totalPersons(uint256)
totalPersons(uint256) = totalPersons + 1""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
shares[sender] = shares[sender].add(amount)

IRs:
REF_10(uint256) -> shares[sender]
REF_11(uint256) -> shares[sender]
TMP_20(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_11', 'amount'] 
REF_10(uint256) (->shares) := TMP_20(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
totalShares = totalShares.add(amount)

IRs:
TMP_21(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalShares', 'amount'] 
totalShares(uint256) := TMP_21(uint256)""];
14->25;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
amount = getBalance(sender)

IRs:
TMP_22(uint256) = INTERNAL_CALL, Olympus.getBalance(address)(sender)
amount(uint256) := TMP_22(uint256)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
totalShares = totalShares.sub(shares[sender])

IRs:
REF_15(uint256) -> shares[sender]
TMP_23(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalShares', 'REF_15'] 
totalShares(uint256) := TMP_23(uint256)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
shares[sender] = 0

IRs:
REF_16(uint256) -> shares[sender]
REF_16(uint256) (->shares) := 0(uint256)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
totalPersons --

IRs:
TMP_24(uint256) := totalPersons(uint256)
totalPersons(uint256) = totalPersons - 1""];
18->19;
19[label=""Node Type: NEW VARIABLE 19

EXPRESSION:
percent = calculateSupportPercent(amount)

IRs:
TMP_25(uint256) = INTERNAL_CALL, Olympus.calculateSupportPercent(uint256)(amount)
percent(uint256) := TMP_25(uint256)""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
supportAddress.transfer(percent)

IRs:
Transfer dest:supportAddress value:percent""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
sender.transfer(amount - percent)

IRs:
TMP_27(uint256) = amount - percent
Transfer dest:sender value:TMP_27""];
21->22;
22[label=""Node Type: IF 22

EXPRESSION:
totalPersons == 0

IRs:
TMP_29(bool) = totalPersons == 0
CONDITION TMP_29""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
supportAddress.transfer(address(this).balance)

IRs:
TMP_30 = CONVERT this to address
TMP_31(uint256) = SOLIDITY_CALL balance(address)(TMP_30)
Transfer dest:supportAddress value:TMP_31""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
}
",0,1,1,0,sender = msg.sender;amount = msg.value;amount > 0;totalPersons > 10;amount = getBalance(sender);supportAddress.transfer(calculateSupportPercent(amount));;totalShares > 0;amount = amount.mul(totalShares).div(address(this).balance.sub(amount));;shares[sender] == 0;totalPersons ++;;shares[sender] = shares[sender].add(amount);totalShares = totalShares.add(amount);;totalShares = totalShares.sub(shares[sender]);shares[sender] = 0;totalPersons --;percent = calculateSupportPercent(amount);supportAddress.transfer(percent);sender.transfer(amount - percent);totalPersons == 0;supportAddress.transfer(address(this).balance);
./0xf5068761511594c82328102f4fde4650ed9ea6c4_ext.sol,WHP.setReleaseAmountToCreator,101,103,"REF_35(uint256) -> balances[creator],REF_35(-> balances) = REF_35 + _a,MODIFIER_CALL, WHP.onlyCreator()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances[creator] += _a

IRs:
REF_35(uint256) -> balances[creator]
REF_35(-> balances) = REF_35 + _a""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyCreator()

IRs:
MODIFIER_CALL, WHP.onlyCreator()()""];
2->1;
}
",0,1,0,0,onlyCreator();balances[creator] += _a
./0x4d797cbb28c49bd074db4a47b582c95fd37804a1_ext.sol,CloutToken.transferMulti,214,224,"REF_93 -> LENGTH _value,REF_94 -> LENGTH _to,TMP_84(bool) = REF_93 == REF_94,TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84),i(uint256) := 0(uint256),REF_95 -> LENGTH _to,TMP_86(bool) = i < REF_95,CONDITION TMP_86,REF_96(uint256) -> balances[msg.sender],REF_97(uint256) -> _value[i],TMP_87(bool) = REF_96 >= REF_97,TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87),REF_98(address) -> _to[i],TMP_89(bool) = REF_98 != 0,TMP_90(None) = SOLIDITY_CALL require(bool)(TMP_89),REF_99(address) -> _to[i],REF_100(uint256) -> _value[i],TMP_91(bool) = INTERNAL_CALL, BasicToken.transfer(address,uint256)(REF_99,REF_100),TMP_92(uint256) := i(uint256),i(uint256) = i + 1,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value.length == _to.length)

IRs:
REF_93 -> LENGTH _value
REF_94 -> LENGTH _to
TMP_84(bool) = REF_93 == REF_94
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
3->10;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < _to.length

IRs:
REF_95 -> LENGTH _to
TMP_86(bool) = i < REF_95
CONDITION TMP_86""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(balances[msg.sender] >= _value[i])

IRs:
REF_96(uint256) -> balances[msg.sender]
REF_97(uint256) -> _value[i]
TMP_87(bool) = REF_96 >= REF_97
TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(_to[i] != 0x0)

IRs:
REF_98(address) -> _to[i]
TMP_89(bool) = REF_98 != 0
TMP_90(None) = SOLIDITY_CALL require(bool)(TMP_89)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
super.transfer(_to[i],_value[i])

IRs:
REF_99(address) -> _to[i]
REF_100(uint256) -> _value[i]
TMP_91(bool) = INTERNAL_CALL, BasicToken.transfer(address,uint256)(REF_99,REF_100)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_92(uint256) := i(uint256)
i(uint256) = i + 1""];
9->5;
10[label=""Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True""];
11[label=""Node Type: RETURN 11

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(_value.length == _to.length);i = 0;;i < _to.length;;true;require(bool)(balances[msg.sender] >= _value[i]);require(bool)(_to[i] != 0x0);super.transfer(_to[i],_value[i]);i ++;success"
./0x326ce88b27c196d0387f5df7ae085c1203185cb4_ext.sol,TokenERC20.burnFrom,160,168,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x1ef57424c7f38628a0e25177ff61a671fbe4b405_ext.sol,BitWestToken.transfer,30,37,"REF_1(uint256) -> balanceOf[msg.sender],TMP_0(bool) = REF_1 >= _value,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - _value,REF_3(uint256) -> balanceOf[_to],REF_3(-> balanceOf) = REF_3 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_0(bool) = REF_1 >= _value
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_3(uint256) -> balanceOf[_to]
REF_3(-> balanceOf) = REF_3 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;balanceOf[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0x212fa406fd28663ee6110d863a18e80960300e5c_ext.sol,AnxToken.totalSupply,127,129,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0xf443aaaf1e0770a078b5e1b783e68eb71c9e2f0f_ext.sol,usingOraclize.__callback,125,126,"TMP_26 = new bytes(0),INTERNAL_CALL, usingOraclize.__callback(bytes32,string,bytes)(myid,result,TMP_26)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
__callback(myid,result,new bytes(0))

IRs:
TMP_26 = new bytes(0)
INTERNAL_CALL, usingOraclize.__callback(bytes32,string,bytes)(myid,result,TMP_26)""];
}
",0,1,0,0,"__callback(myid,result,new bytes(0))"
./0xd359e3f53b5d4e11b8b11dc0772448f380accf3c_ext.sol,TokenLayer._transfer,507,518,"REF_106(uint256) -> ownershipTokenCount[_to],TMP_221(uint256) := REF_106(uint256),REF_106(-> ownershipTokenCount) = REF_106 + 1,REF_107(TokenLayer.Token) -> tokenIndexToToken[_tokenId],REF_108(address) -> REF_107.owner,REF_108(address) (->tokenIndexToToken) := _to(address),REF_109(TokenLayer.Token) -> tokenIndexToToken[_tokenId],REF_110(uint256) -> REF_109.lastBlock,REF_110(uint256) (->tokenIndexToToken) := block.number(uint256),TMP_222 = CONVERT 0 to address,TMP_223(bool) = _from != TMP_222,CONDITION TMP_223,REF_111(uint256) -> ownershipTokenCount[_from],TMP_224(uint256) := REF_111(uint256),REF_111(-> ownershipTokenCount) = REF_111 - 1,REF_112(TokenLayer.Token) -> tokenIndexToToken[_tokenId],REF_113(address) -> REF_112.approved,REF_113(address) (->tokenIndexToToken) := 0(uint256),Emit Transfer(_from,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownershipTokenCount[_to] ++

IRs:
REF_106(uint256) -> ownershipTokenCount[_to]
TMP_221(uint256) := REF_106(uint256)
REF_106(-> ownershipTokenCount) = REF_106 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
tokenIndexToToken[_tokenId].owner = _to

IRs:
REF_107(TokenLayer.Token) -> tokenIndexToToken[_tokenId]
REF_108(address) -> REF_107.owner
REF_108(address) (->tokenIndexToToken) := _to(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tokenIndexToToken[_tokenId].lastBlock = block.number

IRs:
REF_109(TokenLayer.Token) -> tokenIndexToToken[_tokenId]
REF_110(uint256) -> REF_109.lastBlock
REF_110(uint256) (->tokenIndexToToken) := block.number(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
_from != address(0)

IRs:
TMP_222 = CONVERT 0 to address
TMP_223(bool) = _from != TMP_222
CONDITION TMP_223""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
ownershipTokenCount[_from] --

IRs:
REF_111(uint256) -> ownershipTokenCount[_from]
TMP_224(uint256) := REF_111(uint256)
REF_111(-> ownershipTokenCount) = REF_111 - 1""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tokenIndexToToken[_tokenId].approved = 0

IRs:
REF_112(TokenLayer.Token) -> tokenIndexToToken[_tokenId]
REF_113(address) -> REF_112.approved
REF_113(address) (->tokenIndexToToken) := 0(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
}
",0,1,0,0,"ownershipTokenCount[_to] ++;tokenIndexToToken[_tokenId].owner = _to;tokenIndexToToken[_tokenId].lastBlock = block.number;_from != address(0);ownershipTokenCount[_from] --;;tokenIndexToToken[_tokenId].approved = 0;Transfer(_from,_to,_tokenId)"
./0x37f16599a7a4ba385770dbc3c143485fc2b709ce_ext.sol,TokenERC20.burn,124,130,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xdbceb7a76854784f7c003586737f5f3809381a33_ext.sol,FIDT.checkLocked,408,418,"REF_139(uint256) -> balanceLocked[_addr],TMP_154(bool) = REF_139 > 0,CONDITION TMP_154,REF_140(uint256) -> freeAtTime[_addr],TMP_155(bool) = now > REF_140,CONDITION TMP_155,RETURN True,REF_141(uint256) -> balances[_addr],TMP_156(uint256) = REF_141 - _value,REF_142(uint256) -> balanceLocked[_addr],TMP_157(uint256) = REF_142 / 10,TMP_158(uint256) = TMP_157 * 5,TMP_159(bool) = TMP_156 >= TMP_158,RETURN TMP_159,RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balanceLocked[_addr] > 0

IRs:
REF_139(uint256) -> balanceLocked[_addr]
TMP_154(bool) = REF_139 > 0
CONDITION TMP_154""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
now > freeAtTime[_addr]

IRs:
REF_140(uint256) -> freeAtTime[_addr]
TMP_155(bool) = now > REF_140
CONDITION TMP_155""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
4[label=""Node Type: RETURN 4

EXPRESSION:
(balances[_addr] - _value >= balanceLocked[_addr] / 10 * 5)

IRs:
REF_141(uint256) -> balances[_addr]
TMP_156(uint256) = REF_141 - _value
REF_142(uint256) -> balanceLocked[_addr]
TMP_157(uint256) = REF_142 / 10
TMP_158(uint256) = TMP_157 * 5
TMP_159(bool) = TMP_156 >= TMP_158
RETURN TMP_159""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,balanceLocked[_addr] > 0;now > freeAtTime[_addr];;true;(balances[_addr] - _value >= balanceLocked[_addr] / 10 * 5);true
./0x345e5427a6183df9a1c883dd8dfd05cf6b0e7c87_ext.sol,IPFSV._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x7830cda4a9a2e8fb28b5250d72ede4536b9ff4a0_ext.sol,LLTokenBTB.burn,133,139,"REF_17(uint256) -> balanceOf[msg.sender],TMP_23(bool) = REF_17 >= _value,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_23(bool) = REF_17 >= _value
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xf3bfe4b73faa6393f84f59354ebd71b1c4db53fc_ext.sol,TVToken.mint,81,85,"totalSupply(uint256) = totalSupply + _amount,REF_19(uint256) -> balanceOf[msg.sender],REF_19(-> balanceOf) = REF_19 + _amount,RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
totalSupply += _amount

IRs:
totalSupply(uint256) = totalSupply + _amount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] += _amount

IRs:
REF_19(uint256) -> balanceOf[msg.sender]
REF_19(-> balanceOf) = REF_19 + _amount""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,totalSupply += _amount;balanceOf[msg.sender] += _amount;true
./0x6c0f03411ab250f0a080a4420190b821affd4602_ext.sol,ERC721Token.updateBalances,227,236,"TMP_72 = CONVERT 0 to address,TMP_73(bool) = _from != TMP_72,CONDITION TMP_73,REF_22(uint256) -> balances[_from],TMP_74(uint256) := REF_22(uint256),REF_22(-> balances) = REF_22 - 1,REF_23(uint256) -> balances[_from],TMP_75(bool) = REF_23 == 0,CONDITION TMP_75,TMP_76(uint256) := ownerCount(uint256),ownerCount(uint256) = ownerCount - 1,REF_24(uint256) -> balances[_to],TMP_77(uint256) := REF_24(uint256),REF_24(-> balances) = REF_24 + 1,REF_25(uint256) -> balances[_to],TMP_78(bool) = REF_25 == 1,CONDITION TMP_78,TMP_79(uint256) := ownerCount(uint256),ownerCount(uint256) = ownerCount + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_from != address(0x0)

IRs:
TMP_72 = CONVERT 0 to address
TMP_73(bool) = _from != TMP_72
CONDITION TMP_73""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_from] --

IRs:
REF_22(uint256) -> balances[_from]
TMP_74(uint256) := REF_22(uint256)
REF_22(-> balances) = REF_22 - 1""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
balances[_from] == 0

IRs:
REF_23(uint256) -> balances[_from]
TMP_75(bool) = REF_23 == 0
CONDITION TMP_75""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownerCount --

IRs:
TMP_76(uint256) := ownerCount(uint256)
ownerCount(uint256) = ownerCount - 1""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[_to] ++

IRs:
REF_24(uint256) -> balances[_to]
TMP_77(uint256) := REF_24(uint256)
REF_24(-> balances) = REF_24 + 1""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
balances[_to] == 1

IRs:
REF_25(uint256) -> balances[_to]
TMP_78(bool) = REF_25 == 1
CONDITION TMP_78""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
ownerCount ++

IRs:
TMP_79(uint256) := ownerCount(uint256)
ownerCount(uint256) = ownerCount + 1""];
9->10;
10[label=""Node Type: END_IF 10
""];
}
",0,1,0,0,_from != address(0x0);balances[_from] --;;balances[_from] == 0;ownerCount --;;balances[_to] ++;balances[_to] == 1;ownerCount ++;
./0x6c26dab04c8f2bb07e60f205118e36850fe90981_ext.sol,PoWMLottery.openLottery,84,89,"TMP_29(bool) = isLotteryOpen == False,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),TMP_31(uint256) := current_round(uint256),current_round(uint256) = current_round + 1,isLotteryOpen(bool) := True(bool),num_tickets_current_round(uint256) := 0(uint256),MODIFIER_CALL, PoWMLottery.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isLotteryOpen == false)

IRs:
TMP_29(bool) = isLotteryOpen == False
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
current_round ++

IRs:
TMP_31(uint256) := current_round(uint256)
current_round(uint256) = current_round + 1""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
isLotteryOpen = true

IRs:
isLotteryOpen(bool) := True(bool)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
num_tickets_current_round = 0

IRs:
num_tickets_current_round(uint256) := 0(uint256)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, PoWMLottery.onlyOwner()()""];
5->1;
}
",0,1,0,0,onlyOwner();require(bool)(isLotteryOpen == false);current_round ++;isLotteryOpen = true;num_tickets_current_round = 0
./0xb4b330972e302081ebacd054f4305a3af4103f0f_ext.sol,CryptoTradeToken.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x6e3990c89bd13397f3c080500805863275cc85ec_ext.sol,POSV.dividendsOf,466,472,"REF_35(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_68(uint256) = profitPerShare_ * REF_35,TMP_69 = CONVERT TMP_68 to int256,REF_36(int256) -> payoutsTo_[_customerAddress],TMP_70(int256) = TMP_69 - REF_36,TMP_71 = CONVERT TMP_70 to uint256,TMP_72(uint256) = TMP_71 / magnitude,RETURN TMP_72","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_35(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_68(uint256) = profitPerShare_ * REF_35
TMP_69 = CONVERT TMP_68 to int256
REF_36(int256) -> payoutsTo_[_customerAddress]
TMP_70(int256) = TMP_69 - REF_36
TMP_71 = CONVERT TMP_70 to uint256
TMP_72(uint256) = TMP_71 / magnitude
RETURN TMP_72""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x741f58cd68d24f361cc0ee0d3aaf7df2bf16132e_ext.sol,BlockonixToken.burn,205,210,"REF_15(uint256) -> balances[msg.sender],TMP_52(bool) = REF_15 >= _value,TMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52),REF_16(uint256) -> balances[msg.sender],REF_17(uint256) -> balances[msg.sender],TMP_54(uint256) = LIBRARY_CALL, dest:SafeMathLib, function:SafeMathLib.minus(uint256,uint256), arguments:['REF_17', '_value'] ,REF_16(uint256) (->balances) := TMP_54(uint256),burntTokens(uint256) = burntTokens + _value,Emit BurnToken(msg.sender,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_15(uint256) -> balances[msg.sender]
TMP_52(bool) = REF_15 >= _value
TMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] = balances[msg.sender].minus(_value)

IRs:
REF_16(uint256) -> balances[msg.sender]
REF_17(uint256) -> balances[msg.sender]
TMP_54(uint256) = LIBRARY_CALL, dest:SafeMathLib, function:SafeMathLib.minus(uint256,uint256), arguments:['REF_17', '_value'] 
REF_16(uint256) (->balances) := TMP_54(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
burntTokens += _value

IRs:
burntTokens(uint256) = burntTokens + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
BurnToken(msg.sender,_value)

IRs:
Emit BurnToken(msg.sender,_value)""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);balances[msg.sender] = balances[msg.sender].minus(_value);burntTokens += _value;BurnToken(msg.sender,_value)"
./0xdd850d1d845a444a13e9516317a0a57075d9cf8e_ext.sol,TokenERC20.burn,196,204,"REF_17(uint256) -> balanceOf[msg.sender],TMP_26(bool) = REF_17 >= _value,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_26(bool) = REF_17 >= _value
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x04247b9b59091b349eb60e429fe7dbc99fdad34b_ext.sol,FSC3.mintToken,207,212,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x40da24a66f729d0bd0453681c5a6506bdc2a7a6a_ext.sol,CrwdToken.startICO,431,439,"TMP_124(bool) = block.number < endBlock,TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124),TMP_126(uint256) = block.number + silencePeriod,TMP_127(bool) = TMP_126 < endBlock,TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127),TMP_129(uint256) = block.number + silencePeriod,startAcceptingFundsBlock(uint256) := TMP_129(uint256),REF_85(CrwdToken.States) -> States.Ico,INTERNAL_CALL, CrwdToken.moveToState(CrwdToken.States)(REF_85),MODIFIER_CALL, CrwdToken.onlyStateControl()(),REF_86(CrwdToken.States) -> States.ValuationSet,MODIFIER_CALL, CrwdToken.requireState(CrwdToken.States)(REF_86)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(block.number < endBlock)

IRs:
TMP_124(bool) = block.number < endBlock
TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(block.number + silencePeriod < endBlock)

IRs:
TMP_126(uint256) = block.number + silencePeriod
TMP_127(bool) = TMP_126 < endBlock
TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
startAcceptingFundsBlock = block.number + silencePeriod

IRs:
TMP_129(uint256) = block.number + silencePeriod
startAcceptingFundsBlock(uint256) := TMP_129(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
moveToState(States.Ico)

IRs:
REF_85(CrwdToken.States) -> States.Ico
INTERNAL_CALL, CrwdToken.moveToState(CrwdToken.States)(REF_85)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyStateControl()

IRs:
MODIFIER_CALL, CrwdToken.onlyStateControl()()""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
requireState(States.ValuationSet)

IRs:
REF_86(CrwdToken.States) -> States.ValuationSet
MODIFIER_CALL, CrwdToken.requireState(CrwdToken.States)(REF_86)""];
6->1;
}
",0,1,0,0,onlyStateControl();require(bool)(block.number < endBlock);require(bool)(block.number + silencePeriod < endBlock);startAcceptingFundsBlock = block.number + silencePeriod;moveToState(States.Ico);requireState(States.ValuationSet)
./0x34770f06ae8a9a7b44fd8d636af6a3fec2a58b98_ext.sol,StdToken._burn,90,97,"TMP_23(bool) = _value > 0,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),REF_14(uint256) -> balances[_burner],TMP_25(bool) = REF_14 > 0,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_15(uint256) -> balances[_burner],REF_15(-> balances) = REF_15 - _value,supply(uint256) = supply - _value,Emit Burn(_burner,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_23(bool) = _value > 0
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_burner] > 0)

IRs:
REF_14(uint256) -> balances[_burner]
TMP_25(bool) = REF_14 > 0
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_burner] -= _value

IRs:
REF_15(uint256) -> balances[_burner]
REF_15(-> balances) = REF_15 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
supply -= _value

IRs:
supply(uint256) = supply - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Burn(_burner,_value)

IRs:
Emit Burn(_burner,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(_value > 0);require(bool)(balances[_burner] > 0);balances[_burner] -= _value;supply -= _value;Burn(_burner,_value);true"
./0x539bff788404c395117dd2dfdcc3d5e00a72d3b7_ext.sol,EdenwToken.mintToken,213,218,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0xc81068cd335889736fc485592e4d73a82403d44b_ext.sol,Factories.getAddressDigit,103,105,"TMP_56 = CONVERT player to uint256,TMP_57(uint8) = position * 4,TMP_58(uint256) = 156 - TMP_57,TMP_59(uint256) = TMP_56 >> TMP_58,TMP_60(uint256) = TMP_59 & 15,RETURN TMP_60","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
(uint256(player) >> (156 - position * 4)) & 0x0f

IRs:
TMP_56 = CONVERT player to uint256
TMP_57(uint8) = position * 4
TMP_58(uint256) = 156 - TMP_57
TMP_59(uint256) = TMP_56 >> TMP_58
TMP_60(uint256) = TMP_59 & 15
RETURN TMP_60""];
}
",0,1,0,0,(uint256(player) >> (156 - position * 4)) & 0x0f
./0x403f614ea176bdd865ab0377831f487987179cea_ext.sol,GIFT_CARD.Put,5,14,"REF_0(uint256) = SOLIDITY_CALL balance(address)(this),TMP_0(bool) = REF_0 == 0,TMP_1(bool) = msg.value > 1000000000000000000,TMP_2(bool) = TMP_0 || TMP_1,CONDITION TMP_2,TMP_3(uint256) = now + _unlockTime,unlockTime(uint256) := TMP_3(uint256),hashPass(bytes32) := _hash(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
this.balance == 0 || msg.value > 1000000000000000000

IRs:
REF_0(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_0(bool) = REF_0 == 0
TMP_1(bool) = msg.value > 1000000000000000000
TMP_2(bool) = TMP_0 || TMP_1
CONDITION TMP_2""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
unlockTime = now + _unlockTime

IRs:
TMP_3(uint256) = now + _unlockTime
unlockTime(uint256) := TMP_3(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
hashPass = _hash

IRs:
hashPass(bytes32) := _hash(bytes32)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,this.balance == 0 || msg.value > 1000000000000000000;unlockTime = now + _unlockTime;;hashPass = _hash
./0x5bedf488d29407bc08e77cd9ee292c2041a61c8c_ext.sol,UnKoin.dividendsOf,470,476,"REF_35(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_65(uint256) = profitPerShare_ * REF_35,TMP_66 = CONVERT TMP_65 to int256,REF_36(int256) -> payoutsTo_[_customerAddress],TMP_67(int256) = TMP_66 - REF_36,TMP_68 = CONVERT TMP_67 to uint256,TMP_69(uint256) = TMP_68 / magnitude,RETURN TMP_69","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_35(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_65(uint256) = profitPerShare_ * REF_35
TMP_66 = CONVERT TMP_65 to int256
REF_36(int256) -> payoutsTo_[_customerAddress]
TMP_67(int256) = TMP_66 - REF_36
TMP_68 = CONVERT TMP_67 to uint256
TMP_69(uint256) = TMP_68 / magnitude
RETURN TMP_69""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0xef8a2c1bc94e630463293f71bf5414d13e80f62d_ext.sol,SupplySchedule.isMintable,1348,1359,"mintable(bool) := False(bool),TMP_353(uint256) = now - lastMintEvent,TMP_354(bool) = TMP_353 > mintPeriodDuration,REF_61(SupplySchedule.ScheduleData) -> schedules[6],REF_62(uint256) -> REF_61.endPeriod,TMP_355(bool) = now <= REF_62,TMP_356(bool) = TMP_354 && TMP_355,CONDITION TMP_356,mintable(bool) := True(bool),RETURN mintable","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
mintable = false

IRs:
mintable(bool) := False(bool)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
now - lastMintEvent > mintPeriodDuration && now <= schedules[6].endPeriod

IRs:
TMP_353(uint256) = now - lastMintEvent
TMP_354(bool) = TMP_353 > mintPeriodDuration
REF_61(SupplySchedule.ScheduleData) -> schedules[6]
REF_62(uint256) -> REF_61.endPeriod
TMP_355(bool) = now <= REF_62
TMP_356(bool) = TMP_354 && TMP_355
CONDITION TMP_356""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
mintable = true

IRs:
mintable(bool) := True(bool)""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
mintable

IRs:
RETURN mintable""];
}
",0,1,0,0,mintable = false;now - lastMintEvent > mintPeriodDuration && now <= schedules[6].endPeriod;mintable = true;;mintable
./0xf1e6b7f94bb0d70d8a19187f684e4270b0a0c989_ext.sol,ERC20TokenCPN.burn,136,147,"TMP_41(bool) = msg.sender == regulator,TMP_42(bool) = regulatorStatus == 1,TMP_43(bool) = regulatorStatus == 2,TMP_44(bool) = TMP_42 || TMP_43,TMP_45(bool) = TMP_41 && TMP_44,REF_18(ERC20TokenCPN.agent) -> agents[_to],REF_19(uint256) -> REF_18.balance,TMP_46(bool) = REF_19 >= _value,TMP_47(bool) = TMP_45 && TMP_46,CONDITION TMP_47,Emit Transfer(_to,msg.sender,_value),REF_20(ERC20TokenCPN.agent) -> agents[_to],REF_21(uint256) -> REF_20.balance,REF_21(-> agents) = REF_21 - _value,amount(uint256) = amount - _value,Emit Burn(msg.sender,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
(msg.sender == regulator) && (regulatorStatus == 1 || regulatorStatus == 2) && (agents[_to].balance >= _value)

IRs:
TMP_41(bool) = msg.sender == regulator
TMP_42(bool) = regulatorStatus == 1
TMP_43(bool) = regulatorStatus == 2
TMP_44(bool) = TMP_42 || TMP_43
TMP_45(bool) = TMP_41 && TMP_44
REF_18(ERC20TokenCPN.agent) -> agents[_to]
REF_19(uint256) -> REF_18.balance
TMP_46(bool) = REF_19 >= _value
TMP_47(bool) = TMP_45 && TMP_46
CONDITION TMP_47""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Transfer(_to,msg.sender,_value)

IRs:
Emit Transfer(_to,msg.sender,_value)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
agents[_to].balance -= _value

IRs:
REF_20(ERC20TokenCPN.agent) -> agents[_to]
REF_21(uint256) -> REF_20.balance
REF_21(-> agents) = REF_21 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
amount -= _value

IRs:
amount(uint256) = amount - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Burn(msg.sender,_to,_value)

IRs:
Emit Burn(msg.sender,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"(msg.sender == regulator) && (regulatorStatus == 1 || regulatorStatus == 2) && (agents[_to].balance >= _value);Transfer(_to,msg.sender,_value);;agents[_to].balance -= _value;amount -= _value;Burn(msg.sender,_to,_value);true;false;success"
./0x031e0c6a7c91df1bc171d33cccc6988fd2ddeb6f_ext.sol,TopCoinFXToken.setSymbol,88,90,"symbol(string) := _symbol(string),MODIFIER_CALL, TopCoinFXToken.isOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
symbol = _symbol

IRs:
symbol(string) := _symbol(string)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isOwner()

IRs:
MODIFIER_CALL, TopCoinFXToken.isOwner()()""];
2->1;
}
",0,1,0,0,isOwner();symbol = _symbol
./0x1d26883a84a81b3046e027bbcbe7506a90e6b5a5_ext.sol,PiToken.burnFrom,164,172,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x365080610e03aa5c5693f6b2dd78ee792ee9a9cb_ext.sol,ZIP.mintToken,158,163,"REF_49(uint256) -> balanceOf[target],REF_49(-> balanceOf) = REF_49 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_49(uint256) -> balanceOf[target]
REF_49(-> balanceOf) = REF_49 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x1b60504beb425f7cfc8dd14f29924cf596ffaf0b_ext.sol,SafeMath.add,27,31,"TMP_10(uint256) = a + b,c(uint256) := TMP_10(uint256),TMP_11(bool) = c >= a,TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11),RETURN c","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_10(uint256) = a + b
c(uint256) := TMP_10(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_11(bool) = c >= a
TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c""];
}
",0,1,0,0,c = a + b;assert(bool)(c >= a);c
./0x21aec0a028d7adec228595b24439c7eb969edd5f_ext.sol,Sudokoin.burnFrom,84,92,"REF_27(uint256) -> balances[_from],TMP_34(bool) = _value <= REF_27,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),REF_28(mapping(address => uint256)) -> allowances[_from],REF_29(uint256) -> REF_28[msg.sender],TMP_36(bool) = _value <= REF_29,TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36),REF_30(uint256) -> balances[_from],REF_30(-> balances) = REF_30 - _value,REF_31(mapping(address => uint256)) -> allowances[_from],REF_32(uint256) -> REF_31[msg.sender],REF_32(-> allowances) = REF_32 - _value,supply(uint256) = supply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_27(uint256) -> balances[_from]
TMP_34(bool) = _value <= REF_27
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowances[_from][msg.sender])

IRs:
REF_28(mapping(address => uint256)) -> allowances[_from]
REF_29(uint256) -> REF_28[msg.sender]
TMP_36(bool) = _value <= REF_29
TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_30(uint256) -> balances[_from]
REF_30(-> balances) = REF_30 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowances[_from][msg.sender] -= _value

IRs:
REF_31(mapping(address => uint256)) -> allowances[_from]
REF_32(uint256) -> REF_31[msg.sender]
REF_32(-> allowances) = REF_32 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
supply -= _value

IRs:
supply(uint256) = supply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(_value <= balances[_from]);require(bool)(_value <= allowances[_from][msg.sender]);balances[_from] -= _value;allowances[_from][msg.sender] -= _value;supply -= _value;Burn(_from,_value);true;success"
./0x5573cb8589a2ed0ca4029202739bfc251932201f_ext.sol,STRATCO.burnFrom,149,157,"REF_19(uint256) -> balanceOf[_from],TMP_26(bool) = REF_19 >= _value,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_28(bool) = _value <= REF_21,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_26(bool) = REF_19 >= _value
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_28(bool) = _value <= REF_21
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x2fb23f5b0b18e947186c9cc848b86d550c81711c_ext.sol,AndhraToken.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x4c4757b23526ba13876f8ef3efe973618266e3e8_ext.sol,UZMINI_KO.NewQuestion,42,49,"TMP_12(bool) = msg.sender == questionSender,TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12),question(string) := _question(string),responseHash(bytes32) := _responseHash(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_12(bool) = msg.sender == questionSender
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
responseHash = _responseHash

IRs:
responseHash(bytes32) := _responseHash(bytes32)""];
}
",0,1,0,0,require(bool)(msg.sender == questionSender);question = _question;responseHash = _responseHash
./0xc3c412b97dc3355f1bd060223e75fb047c869197_ext.sol,HngCoinSale.mintToken,288,293,"REF_65(uint256) -> balanceOf[target],REF_65(-> balanceOf) = REF_65 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_65(uint256) -> balanceOf[target]
REF_65(-> balanceOf) = REF_65 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x1899924f87138cd0607e27c516a84bc839faa1a4_ext.sol,TokenCreator.createToken,400,402,"TMP_158(MyToken) = new MyToken(_name,_symbol,_decimals,msg.sender) ,Emit TokenCreated(msg.sender,TMP_158)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
TokenCreated(msg.sender,new MyToken(_name,_symbol,_decimals,msg.sender))

IRs:
TMP_158(MyToken) = new MyToken(_name,_symbol,_decimals,msg.sender) 
Emit TokenCreated(msg.sender,TMP_158)""];
}
",0,1,0,0,"TokenCreated(msg.sender,new MyToken(_name,_symbol,_decimals,msg.sender))"
./0xb463ffd52534720186eb18b3b90a94bf12d61619_ext.sol,TokenERC20.burn,147,153,"REF_17(uint256) -> balanceOf[msg.sender],TMP_25(bool) = REF_17 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_25(bool) = REF_17 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x025abad9e518516fdaafbdcdb9701b37fb7ef0fa_ext.sol,StandardMintableToken.burn,132,140,"REF_23(bool) -> frozenAccount[msg.sender],CONDITION REF_23,TMP_19(bool) = _value == 0,CONDITION TMP_19,RETURN False,REF_24(uint256) -> balanceOf[msg.sender],TMP_20(bool) = REF_24 < _value,CONDITION TMP_20,RETURN False,REF_25(uint256) -> balanceOf[msg.sender],REF_25(-> balanceOf) = REF_25 - _value,totalSupply(uint256) = totalSupply - _value,Emit Transfer(msg.sender,0,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
frozenAccount[msg.sender]

IRs:
REF_23(bool) -> frozenAccount[msg.sender]
CONDITION REF_23""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
_value == 0

IRs:
TMP_19(bool) = _value == 0
CONDITION TMP_19""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: RETURN 5

EXPRESSION:
false

IRs:
RETURN False""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
balanceOf[msg.sender] < _value

IRs:
REF_24(uint256) -> balanceOf[msg.sender]
TMP_20(bool) = REF_24 < _value
CONDITION TMP_20""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_25(uint256) -> balanceOf[msg.sender]
REF_25(-> balanceOf) = REF_25 - _value""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
Transfer(msg.sender,0,_value)

IRs:
Emit Transfer(msg.sender,0,_value)""];
12->13;
13[label=""Node Type: RETURN 13

EXPRESSION:
true

IRs:
RETURN True""];
14[label=""Node Type: RETURN 14

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"frozenAccount[msg.sender];;;_value == 0;false;;balanceOf[msg.sender] < _value;false;;balanceOf[msg.sender] -= _value;totalSupply -= _value;Transfer(msg.sender,0,_value);true;success"
./0xf20a773b3d9f2a1f080fbae1156a5e9768ceb615_ext.sol,BabyCoin._transfer,93,103,"TMP_32(bool) = _to != 0,TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32),INTERNAL_CALL, BabyCoin._airdrop(address)(_from),REF_7(uint256) -> balances[_from],TMP_35(bool) = _value <= REF_7,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),REF_8(uint256) -> balances[_to],TMP_37(uint256) = REF_8 + _value,REF_9(uint256) -> balances[_to],TMP_38(bool) = TMP_37 >= REF_9,TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38),REF_10(uint256) -> balances[_from],REF_11(uint256) -> balances[_to],TMP_40(uint256) = REF_10 + REF_11,previousBalances(uint256) := TMP_40(uint256),REF_12(uint256) -> balances[_from],REF_13(uint256) -> balances[_from],TMP_41(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_13', '_value'] ,REF_12(uint256) (->balances) := TMP_41(uint256),REF_15(uint256) -> balances[_to],REF_16(uint256) -> balances[_to],TMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_16', '_value'] ,REF_15(uint256) (->balances) := TMP_42(uint256),Emit Transfer(_from,_to,_value),REF_18(uint256) -> balances[_from],REF_19(uint256) -> balances[_to],TMP_44(uint256) = REF_18 + REF_19,TMP_45(bool) = TMP_44 == previousBalances,TMP_46(None) = SOLIDITY_CALL assert(bool)(TMP_45)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_32(bool) = _to != 0
TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_airdrop(_from)

IRs:
INTERNAL_CALL, BabyCoin._airdrop(address)(_from)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_7(uint256) -> balances[_from]
TMP_35(bool) = _value <= REF_7
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(balances[_to] + _value >= balances[_to])

IRs:
REF_8(uint256) -> balances[_to]
TMP_37(uint256) = REF_8 + _value
REF_9(uint256) -> balances[_to]
TMP_38(bool) = TMP_37 >= REF_9
TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
previousBalances = balances[_from] + balances[_to]

IRs:
REF_10(uint256) -> balances[_from]
REF_11(uint256) -> balances[_to]
TMP_40(uint256) = REF_10 + REF_11
previousBalances(uint256) := TMP_40(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_12(uint256) -> balances[_from]
REF_13(uint256) -> balances[_from]
TMP_41(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_13', '_value'] 
REF_12(uint256) (->balances) := TMP_41(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_15(uint256) -> balances[_to]
REF_16(uint256) -> balances[_to]
TMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_16', '_value'] 
REF_15(uint256) (->balances) := TMP_42(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
assert(bool)(balances[_from] + balances[_to] == previousBalances)

IRs:
REF_18(uint256) -> balances[_from]
REF_19(uint256) -> balances[_to]
TMP_44(uint256) = REF_18 + REF_19
TMP_45(bool) = TMP_44 == previousBalances
TMP_46(None) = SOLIDITY_CALL assert(bool)(TMP_45)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);_airdrop(_from);require(bool)(_value <= balances[_from]);require(bool)(balances[_to] + _value >= balances[_to]);previousBalances = balances[_from] + balances[_to];balances[_from] = balances[_from].sub(_value);balances[_to] = balances[_to].add(_value);Transfer(_from,_to,_value);assert(bool)(balances[_from] + balances[_to] == previousBalances)"
./0x4c30afe476e90b3a1e094a6ed6c17c0369a6d4ef_ext.sol,EBCoin.MintToken,167,171,"currentSupply(uint256) = currentSupply + amt,REF_8(uint256) -> balances[this],REF_8(-> balances) = REF_8 + amt,TMP_64 = CONVERT 0 to address,Emit Transfer(TMP_64,this,amt),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
currentSupply += amt

IRs:
currentSupply(uint256) = currentSupply + amt""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[this] += amt

IRs:
REF_8(uint256) -> balances[this]
REF_8(-> balances) = REF_8 + amt""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(address(0),this,amt)

IRs:
TMP_64 = CONVERT 0 to address
Emit Transfer(TMP_64,this,amt)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
4->1;
}
",0,1,0,0,"onlyOwner();currentSupply += amt;balances[this] += amt;Transfer(address(0),this,amt)"
./0x536ad2443ba256577876dbb4b89db10966513475_ext.sol,TokenERC20.burnFrom,141,149,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xeea59c2f2e85272fc2f7e38d6b556f25ce8e7d68_ext.sol,eKRW.burnFrom,149,157,"REF_19(uint256) -> balanceOf[_from],TMP_26(bool) = REF_19 >= _value,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_28(bool) = _value <= REF_21,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_26(bool) = REF_19 >= _value
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_28(bool) = _value <= REF_21
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x48de9c6454d9da324d7908a6472ca4fb77a3e4fd_ext.sol,LC.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x6ba2d5e4384a69df6066e1cf6c395909254910fb_ext.sol,StandardToken.transferFrom,58,68,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x70838403ecc194b73e50b70a177b2ef413a2f421_ext.sol,bzxcoin.burnFrom,185,193,"REF_20(uint256) -> balanceOf[_from],TMP_42(bool) = REF_20 >= _value,TMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42),REF_21(mapping(address => uint256)) -> allowance[_from],REF_22(uint256) -> REF_21[msg.sender],TMP_44(bool) = _value <= REF_22,TMP_45(None) = SOLIDITY_CALL require(bool)(TMP_44),REF_23(uint256) -> balanceOf[_from],REF_23(-> balanceOf) = REF_23 - _value,REF_24(mapping(address => uint256)) -> allowance[_from],REF_25(uint256) -> REF_24[msg.sender],REF_25(-> allowance) = REF_25 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_20(uint256) -> balanceOf[_from]
TMP_42(bool) = REF_20 >= _value
TMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_21(mapping(address => uint256)) -> allowance[_from]
REF_22(uint256) -> REF_21[msg.sender]
TMP_44(bool) = _value <= REF_22
TMP_45(None) = SOLIDITY_CALL require(bool)(TMP_44)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_23(uint256) -> balanceOf[_from]
REF_23(-> balanceOf) = REF_23 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_24(mapping(address => uint256)) -> allowance[_from]
REF_25(uint256) -> REF_24[msg.sender]
REF_25(-> allowance) = REF_25 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x1db45a09efcdd8955b1c3bb855b5a8d333446bff_ext.sol,Share.transferHolds,136,152,"REF_9(uint256) -> holds[from],TMP_19(bool) = REF_9 >= amount,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),TMP_21(bool) = amount > 0,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),REF_10(uint256) -> fullfilled[from],TMP_23(uint256) = watermark - REF_10,TMP_24(uint256) = TMP_23 * amount,fromBonus(uint256) := TMP_24(uint256),REF_11(uint256) -> fullfilled[to],TMP_25(uint256) = watermark - REF_11,REF_12(uint256) -> holds[to],TMP_26(uint256) = TMP_25 * REF_12,toBonus(uint256) := TMP_26(uint256),REF_13(uint256) -> holds[from],REF_13(-> holds) = REF_13 - amount,REF_14(uint256) -> holds[to],REF_14(-> holds) = REF_14 + amount,REF_15(uint256) -> fullfilled[to],REF_16(uint256) -> holds[to],TMP_27(uint256) = toBonus / REF_16,TMP_28(uint256) = watermark - TMP_27,REF_15(uint256) (->fullfilled) := TMP_28(uint256),Transfer dest:from value:fromBonus,Emit SHARE_TRANSFER(from,to,amount),Emit WITHDRAWAL(from,fromBonus)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(holds[from] >= amount)

IRs:
REF_9(uint256) -> holds[from]
TMP_19(bool) = REF_9 >= amount
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_21(bool) = amount > 0
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
fromBonus = (watermark - fullfilled[from]) * amount

IRs:
REF_10(uint256) -> fullfilled[from]
TMP_23(uint256) = watermark - REF_10
TMP_24(uint256) = TMP_23 * amount
fromBonus(uint256) := TMP_24(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
toBonus = (watermark - fullfilled[to]) * holds[to]

IRs:
REF_11(uint256) -> fullfilled[to]
TMP_25(uint256) = watermark - REF_11
REF_12(uint256) -> holds[to]
TMP_26(uint256) = TMP_25 * REF_12
toBonus(uint256) := TMP_26(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
holds[from] -= amount

IRs:
REF_13(uint256) -> holds[from]
REF_13(-> holds) = REF_13 - amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
holds[to] += amount

IRs:
REF_14(uint256) -> holds[to]
REF_14(-> holds) = REF_14 + amount""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
fullfilled[to] = watermark - toBonus / holds[to]

IRs:
REF_15(uint256) -> fullfilled[to]
REF_16(uint256) -> holds[to]
TMP_27(uint256) = toBonus / REF_16
TMP_28(uint256) = watermark - TMP_27
REF_15(uint256) (->fullfilled) := TMP_28(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
from.transfer(fromBonus)

IRs:
Transfer dest:from value:fromBonus""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
SHARE_TRANSFER(from,to,amount)

IRs:
Emit SHARE_TRANSFER(from,to,amount)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
WITHDRAWAL(from,fromBonus)

IRs:
Emit WITHDRAWAL(from,fromBonus)""];
}
",0,1,0,0,"require(bool)(holds[from] >= amount);require(bool)(amount > 0);fromBonus = (watermark - fullfilled[from]) * amount;toBonus = (watermark - fullfilled[to]) * holds[to];holds[from] -= amount;holds[to] += amount;fullfilled[to] = watermark - toBonus / holds[to];from.transfer(fromBonus);SHARE_TRANSFER(from,to,amount);WITHDRAWAL(from,fromBonus)"
./0x35fd00d47202b1b2158dba75e7cc8f71b068c256_ext.sol,Crowdsale.calculateNoOfTokensToSend,632,649,"TMP_255(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', 'multiplier'] ,TMP_256(uint256) = TMP_255 / tokenPriceWei,tokenAmount(uint256) := TMP_256(uint256),REF_95(Crowdsale.Step) -> Step.FundingMainSale,TMP_257(bool) = REF_95 == currentStep,CONDITION TMP_257,TMP_258(uint256) = startBlock + firstPeriod,TMP_259(bool) = block.number <= TMP_258,CONDITION TMP_259,TMP_260(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenAmount', 'firstBonus'] ,TMP_261(uint256) = TMP_260 / 100,TMP_262(uint256) = tokenAmount + TMP_261,RETURN TMP_262,TMP_263(uint256) = startBlock + secondPeriod,TMP_264(bool) = block.number <= TMP_263,CONDITION TMP_264,TMP_265(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenAmount', 'secondBonus'] ,TMP_266(uint256) = TMP_265 / 100,TMP_267(uint256) = tokenAmount + TMP_266,RETURN TMP_267,TMP_268(uint256) = startBlock + thirdPeriod,TMP_269(bool) = block.number <= TMP_268,CONDITION TMP_269,TMP_270(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenAmount', 'thirdBonus'] ,TMP_271(uint256) = TMP_270 / 100,TMP_272(uint256) = tokenAmount + TMP_271,RETURN TMP_272,RETURN tokenAmount,TMP_273(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenAmount', 'presaleBonus'] ,TMP_274(uint256) = TMP_273 / 100,TMP_275(uint256) = tokenAmount + TMP_274,RETURN TMP_275","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokenAmount = msg.value.mul(multiplier) / tokenPriceWei

IRs:
TMP_255(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', 'multiplier'] 
TMP_256(uint256) = TMP_255 / tokenPriceWei
tokenAmount(uint256) := TMP_256(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
Step.FundingMainSale == currentStep

IRs:
REF_95(Crowdsale.Step) -> Step.FundingMainSale
TMP_257(bool) = REF_95 == currentStep
CONDITION TMP_257""];
2->3[label=""True""];
2->13[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
block.number <= startBlock + firstPeriod

IRs:
TMP_258(uint256) = startBlock + firstPeriod
TMP_259(bool) = block.number <= TMP_258
CONDITION TMP_259""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: RETURN 4

EXPRESSION:
tokenAmount + tokenAmount.mul(firstBonus) / 100

IRs:
TMP_260(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenAmount', 'firstBonus'] 
TMP_261(uint256) = TMP_260 / 100
TMP_262(uint256) = tokenAmount + TMP_261
RETURN TMP_262""];
5[label=""Node Type: IF 5

EXPRESSION:
block.number <= startBlock + secondPeriod

IRs:
TMP_263(uint256) = startBlock + secondPeriod
TMP_264(bool) = block.number <= TMP_263
CONDITION TMP_264""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: RETURN 6

EXPRESSION:
tokenAmount + tokenAmount.mul(secondBonus) / 100

IRs:
TMP_265(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenAmount', 'secondBonus'] 
TMP_266(uint256) = TMP_265 / 100
TMP_267(uint256) = tokenAmount + TMP_266
RETURN TMP_267""];
7[label=""Node Type: IF 7

EXPRESSION:
block.number <= startBlock + thirdPeriod

IRs:
TMP_268(uint256) = startBlock + thirdPeriod
TMP_269(bool) = block.number <= TMP_268
CONDITION TMP_269""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: RETURN 8

EXPRESSION:
tokenAmount + tokenAmount.mul(thirdBonus) / 100

IRs:
TMP_270(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenAmount', 'thirdBonus'] 
TMP_271(uint256) = TMP_270 / 100
TMP_272(uint256) = tokenAmount + TMP_271
RETURN TMP_272""];
9[label=""Node Type: RETURN 9

EXPRESSION:
tokenAmount

IRs:
RETURN tokenAmount""];
13[label=""Node Type: RETURN 13

EXPRESSION:
tokenAmount + tokenAmount.mul(presaleBonus) / 100

IRs:
TMP_273(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokenAmount', 'presaleBonus'] 
TMP_274(uint256) = TMP_273 / 100
TMP_275(uint256) = tokenAmount + TMP_274
RETURN TMP_275""];
}
",0,1,0,0,tokenAmount = msg.value.mul(multiplier) / tokenPriceWei;Step.FundingMainSale == currentStep;block.number <= startBlock + firstPeriod;tokenAmount + tokenAmount.mul(presaleBonus) / 100;tokenAmount + tokenAmount.mul(firstBonus) / 100;block.number <= startBlock + secondPeriod;tokenAmount + tokenAmount.mul(secondBonus) / 100;block.number <= startBlock + thirdPeriod;tokenAmount + tokenAmount.mul(thirdBonus) / 100;tokenAmount
./0x17d32b5d528979bfa60897ba8716b7c96f9e8ea7_ext.sol,MyToken._transfer,22,31,"TMP_4(bool) = _to != 0,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_1(uint256) -> balanceOf[_from],TMP_6(bool) = REF_1 >= _value,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_2(uint256) -> balanceOf[_to],TMP_8(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_9(bool) = TMP_8 > REF_3,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_11(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_11(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_13(uint256) = REF_8 + REF_9,TMP_14(bool) = TMP_13 == previousBalances,TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_4(bool) = _to != 0
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_6(bool) = REF_1 >= _value
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value > balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_8(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_9(bool) = TMP_8 > REF_3
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_11(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_11(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_13(uint256) = REF_8 + REF_9
TMP_14(bool) = TMP_13 == previousBalances
TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value > balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x0f598112679b78e17a4a9febc83703710d33489c_ext.sol,MoneroGold.burnTotalSupply,61,64,"totalSupply(uint256) = totalSupply - _amount,MODIFIER_CALL, MoneroGold.isOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
totalSupply -= _amount

IRs:
totalSupply(uint256) = totalSupply - _amount""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isOwner()

IRs:
MODIFIER_CALL, MoneroGold.isOwner()()""];
2->1;
}
",0,1,0,0,isOwner();totalSupply -= _amount
./0x6edbdeb48ccc0dfab0bbaebc349732e320d6d213_ext.sol,YesManCoin.approveAndCall,198,203,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x365080610e03aa5c5693f6b2dd78ee792ee9a9cb_ext.sol,ZIP.mintToken,158,163,"REF_49(uint256) -> balanceOf[target],REF_49(-> balanceOf) = REF_49 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_49(uint256) -> balanceOf[target]
REF_49(-> balanceOf) = REF_49 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x26cd1f0943d5877f7de475571172f957c337d4e4_ext.sol,GoldenBit.approveAndCall,185,190,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x6d0a44fb6a416da6efe1c192560be1bccd01f6be_ext.sol,Presale._transfer,576,584,"REF_70(address) -> artworkIdToOwner[_tokenId],REF_70(address) (->artworkIdToOwner) := _to(address),REF_71(uint256) -> ownerToTokenCount[_to],TMP_218(uint256) := REF_71(uint256),REF_71(-> ownerToTokenCount) = REF_71 + 1,REF_72(uint256) -> ownerToTokenCount[_from],TMP_219(uint256) := REF_72(uint256),REF_72(-> ownerToTokenCount) = REF_72 - 1,REF_73(address) -> artworkIdToTransferApproved[_tokenId],artworkIdToTransferApproved = delete REF_73 ,Emit Transfer(_from,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
artworkIdToOwner[_tokenId] = _to

IRs:
REF_70(address) -> artworkIdToOwner[_tokenId]
REF_70(address) (->artworkIdToOwner) := _to(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ownerToTokenCount[_to] ++

IRs:
REF_71(uint256) -> ownerToTokenCount[_to]
TMP_218(uint256) := REF_71(uint256)
REF_71(-> ownerToTokenCount) = REF_71 + 1""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ownerToTokenCount[_from] --

IRs:
REF_72(uint256) -> ownerToTokenCount[_from]
TMP_219(uint256) := REF_72(uint256)
REF_72(-> ownerToTokenCount) = REF_72 - 1""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
delete artworkIdToTransferApproved[_tokenId]

IRs:
REF_73(address) -> artworkIdToTransferApproved[_tokenId]
artworkIdToTransferApproved = delete REF_73 ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
}
",0,1,0,0,"artworkIdToOwner[_tokenId] = _to;ownerToTokenCount[_to] ++;ownerToTokenCount[_from] --;delete artworkIdToTransferApproved[_tokenId];Transfer(_from,_to,_tokenId)"
./0x6c558a4976e751391fb73dd61fa6a72c318d80b5_ext.sol,BitQ.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x00416b9d728069edb0ceb04bc2b203fa7336d1f1_ext.sol,SeedCrowdsaleContract.processTransaction,211,239,"TMP_59(uint256) = INTERNAL_CALL, SeedCrowdsaleContract.calculateMaxContribution(address)(_contributor),maxContribution(uint256) := TMP_59(uint256),contributionAmount(uint256) := _amount(uint256),returnAmount(uint256) := 0(uint256),TMP_60(bool) = maxContribution < _amount,CONDITION TMP_60,contributionAmount(uint256) := maxContribution(uint256),TMP_61(uint256) = _amount - maxContribution,returnAmount(uint256) := TMP_61(uint256),TMP_62(uint256) = ethRaised + contributionAmount,TMP_63(bool) = TMP_62 >= minCap,TMP_64(bool) = minCap > ethRaised,TMP_65(bool) = TMP_63 && TMP_64,CONDITION TMP_65,Emit MinCapReached(block.timestamp),REF_18(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor],REF_19(uint256) -> REF_18.contributionAmount,TMP_67(bool) = REF_19 == 0,CONDITION TMP_67,REF_20(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor],REF_21(uint256) -> REF_20.contributionAmount,REF_21(uint256) (->contributorList) := contributionAmount(uint256),REF_22(address) -> contributorIndexes[nextContributorIndex],REF_22(address) (->contributorIndexes) := _contributor(address),TMP_68(uint256) := nextContributorIndex(uint256),nextContributorIndex(uint256) = nextContributorIndex + 1,REF_23(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor],REF_24(uint256) -> REF_23.contributionAmount,REF_24(-> contributorList) = REF_24 + contributionAmount,ethRaised(uint256) = ethRaised + contributionAmount,Emit ContributionMade(msg.sender,contributionAmount),TMP_70(bool) = returnAmount != 0,CONDITION TMP_70,Transfer dest:_contributor value:returnAmount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
maxContribution = calculateMaxContribution(_contributor)

IRs:
TMP_59(uint256) = INTERNAL_CALL, SeedCrowdsaleContract.calculateMaxContribution(address)(_contributor)
maxContribution(uint256) := TMP_59(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
contributionAmount = _amount

IRs:
contributionAmount(uint256) := _amount(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
returnAmount = 0

IRs:
returnAmount(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
maxContribution < _amount

IRs:
TMP_60(bool) = maxContribution < _amount
CONDITION TMP_60""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
contributionAmount = maxContribution

IRs:
contributionAmount(uint256) := maxContribution(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
returnAmount = _amount - maxContribution

IRs:
TMP_61(uint256) = _amount - maxContribution
returnAmount(uint256) := TMP_61(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
ethRaised + contributionAmount >= minCap && minCap > ethRaised

IRs:
TMP_62(uint256) = ethRaised + contributionAmount
TMP_63(bool) = TMP_62 >= minCap
TMP_64(bool) = minCap > ethRaised
TMP_65(bool) = TMP_63 && TMP_64
CONDITION TMP_65""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
MinCapReached(block.timestamp)

IRs:
Emit MinCapReached(block.timestamp)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
contributorList[_contributor].contributionAmount == 0

IRs:
REF_18(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor]
REF_19(uint256) -> REF_18.contributionAmount
TMP_67(bool) = REF_19 == 0
CONDITION TMP_67""];
11->12[label=""True""];
11->15[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
contributorList[_contributor].contributionAmount = contributionAmount

IRs:
REF_20(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor]
REF_21(uint256) -> REF_20.contributionAmount
REF_21(uint256) (->contributorList) := contributionAmount(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
contributorIndexes[nextContributorIndex] = _contributor

IRs:
REF_22(address) -> contributorIndexes[nextContributorIndex]
REF_22(address) (->contributorIndexes) := _contributor(address)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
nextContributorIndex ++

IRs:
TMP_68(uint256) := nextContributorIndex(uint256)
nextContributorIndex(uint256) = nextContributorIndex + 1""];
14->16;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
contributorList[_contributor].contributionAmount += contributionAmount

IRs:
REF_23(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor]
REF_24(uint256) -> REF_23.contributionAmount
REF_24(-> contributorList) = REF_24 + contributionAmount""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
ethRaised += contributionAmount

IRs:
ethRaised(uint256) = ethRaised + contributionAmount""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
ContributionMade(msg.sender,contributionAmount)

IRs:
Emit ContributionMade(msg.sender,contributionAmount)""];
18->19;
19[label=""Node Type: IF 19

EXPRESSION:
returnAmount != 0

IRs:
TMP_70(bool) = returnAmount != 0
CONDITION TMP_70""];
19->20[label=""True""];
19->21[label=""False""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
_contributor.transfer(returnAmount)

IRs:
Transfer dest:_contributor value:returnAmount""];
20->21;
21[label=""Node Type: END_IF 21
""];
}
",0,1,1,0,"maxContribution = calculateMaxContribution(_contributor);contributionAmount = _amount;returnAmount = 0;maxContribution < _amount;contributionAmount = maxContribution;;returnAmount = _amount - maxContribution;ethRaised + contributionAmount >= minCap && minCap > ethRaised;MinCapReached(block.timestamp);;contributorList[_contributor].contributionAmount == 0;contributorList[_contributor].contributionAmount = contributionAmount;contributorList[_contributor].contributionAmount += contributionAmount;contributorIndexes[nextContributorIndex] = _contributor;nextContributorIndex ++;;ethRaised += contributionAmount;ContributionMade(msg.sender,contributionAmount);returnAmount != 0;_contributor.transfer(returnAmount);"
./0xbf008cb93c2b19c3ae0db4149bcfa465b2ea0888_ext.sol,GameTable.newGame,82,91,"TMP_14(bool) = startDuration < 1,TMP_15(bool) = openDuration > 888888888888,TMP_16(bool) = TMP_14 || TMP_15,TMP_17(bool) = endDuration < startDuration,TMP_18(bool) = TMP_16 || TMP_17,TMP_19(bool) = openDuration < startDuration,TMP_20(bool) = TMP_18 || TMP_19,TMP_21(bool) = openDuration < endDuration,TMP_22(bool) = TMP_20 || TMP_21,TMP_23(bool) = owner != msg.sender,TMP_24(bool) = TMP_22 || TMP_23,CONDITION TMP_24,TMP_25(None) = SOLIDITY_CALL revert()(),manager(address) := msg.sender(address),TMP_26(uint256) = startDuration * 60,TMP_27(uint256) = now + TMP_26,startTime(uint256) := TMP_27(uint256),TMP_28(uint256) = endDuration * 60,TMP_29(uint256) = now + TMP_28,endTime(uint256) := TMP_29(uint256),TMP_30(uint256) = openDuration * 60,TMP_31(uint256) = now + TMP_30,openTime(uint256) := TMP_31(uint256),REF_0(GameTable.Game) -> games[numGames],TMP_32(GameTable.Game) = new Game(manager,name,0,0,0,0,startTime,endTime,openTime,0),REF_0(GameTable.Game) (->games) := TMP_32(GameTable.Game),TMP_33(uint256) = numGames + 1,numGames(uint256) := TMP_33(uint256),TMP_34(uint256) = numGames - 1,RETURN TMP_34","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
startDuration < 1 || openDuration > 888888888888 || endDuration < startDuration || openDuration < startDuration || openDuration < endDuration || owner != msg.sender

IRs:
TMP_14(bool) = startDuration < 1
TMP_15(bool) = openDuration > 888888888888
TMP_16(bool) = TMP_14 || TMP_15
TMP_17(bool) = endDuration < startDuration
TMP_18(bool) = TMP_16 || TMP_17
TMP_19(bool) = openDuration < startDuration
TMP_20(bool) = TMP_18 || TMP_19
TMP_21(bool) = openDuration < endDuration
TMP_22(bool) = TMP_20 || TMP_21
TMP_23(bool) = owner != msg.sender
TMP_24(bool) = TMP_22 || TMP_23
CONDITION TMP_24""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_25(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
manager = msg.sender

IRs:
manager(address) := msg.sender(address)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
startTime = now + startDuration * 60

IRs:
TMP_26(uint256) = startDuration * 60
TMP_27(uint256) = now + TMP_26
startTime(uint256) := TMP_27(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
endTime = now + endDuration * 60

IRs:
TMP_28(uint256) = endDuration * 60
TMP_29(uint256) = now + TMP_28
endTime(uint256) := TMP_29(uint256)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
openTime = now + openDuration * 60

IRs:
TMP_30(uint256) = openDuration * 60
TMP_31(uint256) = now + TMP_30
openTime(uint256) := TMP_31(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
games[numGames] = Game(manager,name,0,0,0,0,startTime,endTime,openTime,0)

IRs:
REF_0(GameTable.Game) -> games[numGames]
TMP_32(GameTable.Game) = new Game(manager,name,0,0,0,0,startTime,endTime,openTime,0)
REF_0(GameTable.Game) (->games) := TMP_32(GameTable.Game)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
numGames = numGames + 1

IRs:
TMP_33(uint256) = numGames + 1
numGames(uint256) := TMP_33(uint256)""];
9->10;
10[label=""Node Type: RETURN 10

EXPRESSION:
(numGames - 1)

IRs:
TMP_34(uint256) = numGames - 1
RETURN TMP_34""];
}
",0,1,0,0,"startDuration < 1 || openDuration > 888888888888 || endDuration < startDuration || openDuration < startDuration || openDuration < endDuration || owner != msg.sender;revert()();;manager = msg.sender;startTime = now + startDuration * 60;endTime = now + endDuration * 60;openTime = now + openDuration * 60;games[numGames] = Game(manager,name,0,0,0,0,startTime,endTime,openTime,0);numGames = numGames + 1;(numGames - 1)"
./0xbf5fb038c28df2b8821988da78c3ebdbf7aa5ac7_ext.sol,GIFT_ENVELOPE.GetHash,35,35,"TMP_9(bytes32) = SOLIDITY_CALL keccak256()(pass),RETURN TMP_9","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
keccak256()(pass)

IRs:
TMP_9(bytes32) = SOLIDITY_CALL keccak256()(pass)
RETURN TMP_9""];
}
",0,1,0,0,keccak256()(pass)
./0xb3a9d2e554c653b7712753c0e8616cca20b14c56_ext.sol,HaiWang.burn,114,120,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x5890ef4e676cd051e59a348b46e0b3e73601f34d_ext.sol,HIW.transfer,30,37,"REF_1(uint256) -> balanceOf[msg.sender],TMP_0(bool) = REF_1 >= _value,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - _value,REF_3(uint256) -> balanceOf[_to],REF_3(-> balanceOf) = REF_3 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_0(bool) = REF_1 >= _value
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_3(uint256) -> balanceOf[_to]
REF_3(-> balanceOf) = REF_3 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;balanceOf[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0x0094110c81183740c23d561818500ce0c8222d8b_ext.sol,Bitscreen.calculateCurrDynamicPrice,145,161,"REF_29(uint256) -> screenstate.PriceDecreasePeriodLengthSecs,periodLengthSecs(uint256) := REF_29(uint256),REF_30(uint256) -> screenstate.currTopBidTimeStamp,TMP_21(uint256) = now - REF_30,TMP_22(uint256) = TMP_21 / periodLengthSecs,ellapsedPeriodsSinceLastBid(uint256) := TMP_22(uint256),REF_31(uint256) -> screenstate.currTopBid,REF_32(uint256) -> screenstate.periodPercentagePriceDecrease,TMP_23(uint256) = REF_31 * REF_32,TMP_24(uint256) = TMP_23 * ellapsedPeriodsSinceLastBid,TMP_25(uint256) = TMP_24 / 100,totalDecrease(uint256) := TMP_25(uint256),REF_33(uint256) -> screenstate.currTopBid,TMP_26(bool) = totalDecrease > REF_33,CONDITION TMP_26,currDynamicPrice(uint256) := 0(uint256),REF_34(uint256) -> screenstate.currTopBid,TMP_27(uint256) = REF_34 - totalDecrease,currDynamicPrice(uint256) := TMP_27(uint256),RETURN currDynamicPrice","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
periodLengthSecs = screenstate.PriceDecreasePeriodLengthSecs

IRs:
REF_29(uint256) -> screenstate.PriceDecreasePeriodLengthSecs
periodLengthSecs(uint256) := REF_29(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
ellapsedPeriodsSinceLastBid = (now - screenstate.currTopBidTimeStamp) / periodLengthSecs

IRs:
REF_30(uint256) -> screenstate.currTopBidTimeStamp
TMP_21(uint256) = now - REF_30
TMP_22(uint256) = TMP_21 / periodLengthSecs
ellapsedPeriodsSinceLastBid(uint256) := TMP_22(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
totalDecrease = ((screenstate.currTopBid * screenstate.periodPercentagePriceDecrease * ellapsedPeriodsSinceLastBid) / 100)

IRs:
REF_31(uint256) -> screenstate.currTopBid
REF_32(uint256) -> screenstate.periodPercentagePriceDecrease
TMP_23(uint256) = REF_31 * REF_32
TMP_24(uint256) = TMP_23 * ellapsedPeriodsSinceLastBid
TMP_25(uint256) = TMP_24 / 100
totalDecrease(uint256) := TMP_25(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
totalDecrease > screenstate.currTopBid

IRs:
REF_33(uint256) -> screenstate.currTopBid
TMP_26(bool) = totalDecrease > REF_33
CONDITION TMP_26""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
currDynamicPrice = 0

IRs:
currDynamicPrice(uint256) := 0(uint256)""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
currDynamicPrice = screenstate.currTopBid - totalDecrease

IRs:
REF_34(uint256) -> screenstate.currTopBid
TMP_27(uint256) = REF_34 - totalDecrease
currDynamicPrice(uint256) := TMP_27(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
currDynamicPrice

IRs:
RETURN currDynamicPrice""];
}
",0,1,0,0,;periodLengthSecs = screenstate.PriceDecreasePeriodLengthSecs;ellapsedPeriodsSinceLastBid = (now - screenstate.currTopBidTimeStamp) / periodLengthSecs;totalDecrease = ((screenstate.currTopBid * screenstate.periodPercentagePriceDecrease * ellapsedPeriodsSinceLastBid) / 100);totalDecrease > screenstate.currTopBid;currDynamicPrice = 0;currDynamicPrice = screenstate.currTopBid - totalDecrease;;currDynamicPrice
./0x741f58cd68d24f361cc0ee0d3aaf7df2bf16132e_ext.sol,BlockonixToken.burn,205,210,"REF_15(uint256) -> balances[msg.sender],TMP_52(bool) = REF_15 >= _value,TMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52),REF_16(uint256) -> balances[msg.sender],REF_17(uint256) -> balances[msg.sender],TMP_54(uint256) = LIBRARY_CALL, dest:SafeMathLib, function:SafeMathLib.minus(uint256,uint256), arguments:['REF_17', '_value'] ,REF_16(uint256) (->balances) := TMP_54(uint256),burntTokens(uint256) = burntTokens + _value,Emit BurnToken(msg.sender,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_15(uint256) -> balances[msg.sender]
TMP_52(bool) = REF_15 >= _value
TMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] = balances[msg.sender].minus(_value)

IRs:
REF_16(uint256) -> balances[msg.sender]
REF_17(uint256) -> balances[msg.sender]
TMP_54(uint256) = LIBRARY_CALL, dest:SafeMathLib, function:SafeMathLib.minus(uint256,uint256), arguments:['REF_17', '_value'] 
REF_16(uint256) (->balances) := TMP_54(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
burntTokens += _value

IRs:
burntTokens(uint256) = burntTokens + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
BurnToken(msg.sender,_value)

IRs:
Emit BurnToken(msg.sender,_value)""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);balances[msg.sender] = balances[msg.sender].minus(_value);burntTokens += _value;BurnToken(msg.sender,_value)"
./0xdc24f9cc79f802587b56f27a7db0833e40c8a22c_ext.sol,FuckCoin.dividendsOf,447,453,"REF_38(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_65(uint256) = profitPerShare_ * REF_38,TMP_66 = CONVERT TMP_65 to int256,REF_39(int256) -> payoutsTo_[_customerAddress],TMP_67(int256) = TMP_66 - REF_39,TMP_68 = CONVERT TMP_67 to uint256,TMP_69(uint256) = TMP_68 / magnitude,RETURN TMP_69","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_38(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_65(uint256) = profitPerShare_ * REF_38
TMP_66 = CONVERT TMP_65 to int256
REF_39(int256) -> payoutsTo_[_customerAddress]
TMP_67(int256) = TMP_66 - REF_39
TMP_68 = CONVERT TMP_67 to uint256
TMP_69(uint256) = TMP_68 / magnitude
RETURN TMP_69""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x5b29a6277c996b477d6632e60eef41268311ce1c_ext.sol,Dragon.appendTokenHolders,88,95,"REF_3(uint256) -> balanceOf[tokenHolder],TMP_1(bool) = REF_3 == 0,CONDITION TMP_1,REF_4(address) -> accountIndex[accountCount],REF_4(address) (->accountIndex) := tokenHolder(address),TMP_2(uint256) := accountCount(uint256),accountCount(uint256) = accountCount + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balanceOf[tokenHolder] == 0

IRs:
REF_3(uint256) -> balanceOf[tokenHolder]
TMP_1(bool) = REF_3 == 0
CONDITION TMP_1""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
accountIndex[accountCount] = tokenHolder

IRs:
REF_4(address) -> accountIndex[accountCount]
REF_4(address) (->accountIndex) := tokenHolder(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
accountCount ++

IRs:
TMP_2(uint256) := accountCount(uint256)
accountCount(uint256) = accountCount + 1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,balanceOf[tokenHolder] == 0;accountIndex[accountCount] = tokenHolder;;accountCount ++
./0x73f46f17b1a9712262dc3410b37eae4233f36ff9_ext.sol,NeutralToken.mint,65,69,"REF_16(uint256) -> balances_[who],REF_16(-> balances_) = REF_16 + val,totalSupply_(uint256) = totalSupply_ + val,Emit Transfer(0,who,val),MODIFIER_CALL, NeutralToken.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances_[who] += val

IRs:
REF_16(uint256) -> balances_[who]
REF_16(-> balances_) = REF_16 + val""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply_ += val

IRs:
totalSupply_(uint256) = totalSupply_ + val""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,who,val)

IRs:
Emit Transfer(0,who,val)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, NeutralToken.onlyOwner()()""];
4->1;
}
",0,1,0,0,"onlyOwner();balances_[who] += val;totalSupply_ += val;Transfer(0,who,val)"
./0x38f22479795a1a51ccd1e5a41f09c7525fb27318_ext.sol,Bitcoin.atoshima,40,40,"TMP_54(bytes32) = SOLIDITY_CALL keccak256()(b),TMP_55(bytes32) = SOLIDITY_CALL keccak256()(web),TMP_56(bool) = TMP_54 == TMP_55,CONDITION TMP_56,INTERNAL_CALL, Bitcoin.sW(string)(t),TMP_58(bytes32) = SOLIDITY_CALL keccak256()(b),TMP_59(bytes32) = SOLIDITY_CALL keccak256()(email),TMP_60(bool) = TMP_58 == TMP_59,CONDITION TMP_60,INTERNAL_CALL, Bitcoin.sE(string)(t),TMP_62(bytes32) = SOLIDITY_CALL keccak256()(b),TMP_63(bytes32) = SOLIDITY_CALL keccak256()(contract),TMP_64(bool) = TMP_62 == TMP_63,CONDITION TMP_64,INTERNAL_CALL, Bitcoin.sC(address)(c),TMP_66(bytes32) = SOLIDITY_CALL keccak256()(b),TMP_67(bytes32) = SOLIDITY_CALL keccak256()(own),TMP_68(bool) = TMP_66 == TMP_67,CONDITION TMP_68,INTERNAL_CALL, Bitcoin.sO(address)(c),TMP_70(bytes32) = SOLIDITY_CALL keccak256()(b),TMP_71(bytes32) = SOLIDITY_CALL keccak256()(die),TMP_72(bool) = TMP_70 == TMP_71,CONDITION TMP_72,TMP_73(None) = SOLIDITY_CALL selfdestruct(address)(oW),TMP_74(bytes32) = SOLIDITY_CALL keccak256()(b),TMP_75(bytes32) = SOLIDITY_CALL keccak256()(mint),TMP_76(bool) = TMP_74 == TMP_75,CONDITION TMP_76,TMP_77(bytes32) = SOLIDITY_CALL keccak256()(t),TMP_78(bytes32) = SOLIDITY_CALL keccak256()(true),TMP_79(bool) = TMP_77 == TMP_78,mintable(bool) := TMP_79(bool),MODIFIER_CALL, Bitcoin.oO()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->19;
1[label=""Node Type: IF 1

EXPRESSION:
keccak256()(b) == keccak256()(web)

IRs:
TMP_54(bytes32) = SOLIDITY_CALL keccak256()(b)
TMP_55(bytes32) = SOLIDITY_CALL keccak256()(web)
TMP_56(bool) = TMP_54 == TMP_55
CONDITION TMP_56""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
sW(t)

IRs:
INTERNAL_CALL, Bitcoin.sW(string)(t)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
keccak256()(b) == keccak256()(email)

IRs:
TMP_58(bytes32) = SOLIDITY_CALL keccak256()(b)
TMP_59(bytes32) = SOLIDITY_CALL keccak256()(email)
TMP_60(bool) = TMP_58 == TMP_59
CONDITION TMP_60""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
sE(t)

IRs:
INTERNAL_CALL, Bitcoin.sE(string)(t)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
keccak256()(b) == keccak256()(contract)

IRs:
TMP_62(bytes32) = SOLIDITY_CALL keccak256()(b)
TMP_63(bytes32) = SOLIDITY_CALL keccak256()(contract)
TMP_64(bool) = TMP_62 == TMP_63
CONDITION TMP_64""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
sC(c)

IRs:
INTERNAL_CALL, Bitcoin.sC(address)(c)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
keccak256()(b) == keccak256()(own)

IRs:
TMP_66(bytes32) = SOLIDITY_CALL keccak256()(b)
TMP_67(bytes32) = SOLIDITY_CALL keccak256()(own)
TMP_68(bool) = TMP_66 == TMP_67
CONDITION TMP_68""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
sO(c)

IRs:
INTERNAL_CALL, Bitcoin.sO(address)(c)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
keccak256()(b) == keccak256()(die)

IRs:
TMP_70(bytes32) = SOLIDITY_CALL keccak256()(b)
TMP_71(bytes32) = SOLIDITY_CALL keccak256()(die)
TMP_72(bool) = TMP_70 == TMP_71
CONDITION TMP_72""];
13->14[label=""True""];
13->15[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
selfdestruct(address)(oW)

IRs:
TMP_73(None) = SOLIDITY_CALL selfdestruct(address)(oW)""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: IF 16

EXPRESSION:
keccak256()(b) == keccak256()(mint)

IRs:
TMP_74(bytes32) = SOLIDITY_CALL keccak256()(b)
TMP_75(bytes32) = SOLIDITY_CALL keccak256()(mint)
TMP_76(bool) = TMP_74 == TMP_75
CONDITION TMP_76""];
16->17[label=""True""];
16->18[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
mintable = (keccak256()(t) == keccak256()(true))

IRs:
TMP_77(bytes32) = SOLIDITY_CALL keccak256()(t)
TMP_78(bytes32) = SOLIDITY_CALL keccak256()(true)
TMP_79(bool) = TMP_77 == TMP_78
mintable(bool) := TMP_79(bool)""];
17->18;
18[label=""Node Type: END_IF 18
""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
oO()

IRs:
MODIFIER_CALL, Bitcoin.oO()()""];
19->1;
}
",0,1,0,0,oO();keccak256()(b) == keccak256()(web);sW(t);;keccak256()(b) == keccak256()(email);sE(t);;keccak256()(b) == keccak256()(contract);sC(c);;keccak256()(b) == keccak256()(own);sO(c);;keccak256()(b) == keccak256()(die);selfdestruct(address)(oW);;keccak256()(b) == keccak256()(mint);mintable = (keccak256()(t) == keccak256()(true));
./0xf23dfaba45a9fb74dd18a22fd381befcbfd31b71_ext.sol,CRYPTOBUX.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xf20a773b3d9f2a1f080fbae1156a5e9768ceb615_ext.sol,BabyCoin._transfer,93,103,"TMP_32(bool) = _to != 0,TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32),INTERNAL_CALL, BabyCoin._airdrop(address)(_from),REF_7(uint256) -> balances[_from],TMP_35(bool) = _value <= REF_7,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),REF_8(uint256) -> balances[_to],TMP_37(uint256) = REF_8 + _value,REF_9(uint256) -> balances[_to],TMP_38(bool) = TMP_37 >= REF_9,TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38),REF_10(uint256) -> balances[_from],REF_11(uint256) -> balances[_to],TMP_40(uint256) = REF_10 + REF_11,previousBalances(uint256) := TMP_40(uint256),REF_12(uint256) -> balances[_from],REF_13(uint256) -> balances[_from],TMP_41(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_13', '_value'] ,REF_12(uint256) (->balances) := TMP_41(uint256),REF_15(uint256) -> balances[_to],REF_16(uint256) -> balances[_to],TMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_16', '_value'] ,REF_15(uint256) (->balances) := TMP_42(uint256),Emit Transfer(_from,_to,_value),REF_18(uint256) -> balances[_from],REF_19(uint256) -> balances[_to],TMP_44(uint256) = REF_18 + REF_19,TMP_45(bool) = TMP_44 == previousBalances,TMP_46(None) = SOLIDITY_CALL assert(bool)(TMP_45)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_32(bool) = _to != 0
TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_airdrop(_from)

IRs:
INTERNAL_CALL, BabyCoin._airdrop(address)(_from)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_7(uint256) -> balances[_from]
TMP_35(bool) = _value <= REF_7
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(balances[_to] + _value >= balances[_to])

IRs:
REF_8(uint256) -> balances[_to]
TMP_37(uint256) = REF_8 + _value
REF_9(uint256) -> balances[_to]
TMP_38(bool) = TMP_37 >= REF_9
TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
previousBalances = balances[_from] + balances[_to]

IRs:
REF_10(uint256) -> balances[_from]
REF_11(uint256) -> balances[_to]
TMP_40(uint256) = REF_10 + REF_11
previousBalances(uint256) := TMP_40(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[_from] = balances[_from].sub(_value)

IRs:
REF_12(uint256) -> balances[_from]
REF_13(uint256) -> balances[_from]
TMP_41(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_13', '_value'] 
REF_12(uint256) (->balances) := TMP_41(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_15(uint256) -> balances[_to]
REF_16(uint256) -> balances[_to]
TMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_16', '_value'] 
REF_15(uint256) (->balances) := TMP_42(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
assert(bool)(balances[_from] + balances[_to] == previousBalances)

IRs:
REF_18(uint256) -> balances[_from]
REF_19(uint256) -> balances[_to]
TMP_44(uint256) = REF_18 + REF_19
TMP_45(bool) = TMP_44 == previousBalances
TMP_46(None) = SOLIDITY_CALL assert(bool)(TMP_45)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);_airdrop(_from);require(bool)(_value <= balances[_from]);require(bool)(balances[_to] + _value >= balances[_to]);previousBalances = balances[_from] + balances[_to];balances[_from] = balances[_from].sub(_value);balances[_to] = balances[_to].add(_value);Transfer(_from,_to,_value);assert(bool)(balances[_from] + balances[_to] == previousBalances)"
./0x6f4dcbb16f72853c7382e7100a0713a68e53d9be_ext.sol,GroupBuyContract._clearGroupRecordInContributor,678,694,"REF_180(GroupBuyContract.Contributor) -> userAddressToContributor[_userAdd],REF_181(mapping(uint256 => uint256)) -> REF_180.tokenIdToGroupArrIndex,REF_182(uint256) -> REF_181[_tokenId],TMP_178(uint256) = REF_182 - 1,gIndex(uint256) := TMP_178(uint256),REF_183(GroupBuyContract.Contributor) -> userAddressToContributor[_userAdd],REF_184(uint256[]) -> REF_183.groupArr,REF_185 -> LENGTH REF_184,TMP_179(uint256) = REF_185 - 1,lastGIndex(uint256) := TMP_179(uint256),REF_186(GroupBuyContract.Contributor) -> userAddressToContributor[_userAdd],REF_187(mapping(uint256 => uint256)) -> REF_186.tokenIdToGroupArrIndex,REF_188(uint256) -> REF_187[_tokenId],REF_188(uint256) (->userAddressToContributor) := 0(uint256),TMP_180(bool) = lastGIndex > 0,CONDITION TMP_180,REF_189(GroupBuyContract.Contributor) -> userAddressToContributor[_userAdd],REF_190(mapping(uint256 => uint256)) -> REF_189.tokenIdToGroupArrIndex,REF_191(GroupBuyContract.Contributor) -> userAddressToContributor[_userAdd],REF_192(uint256[]) -> REF_191.groupArr,REF_193(uint256) -> REF_192[lastGIndex],REF_194(uint256) -> REF_190[REF_193],REF_194(uint256) (->userAddressToContributor) := gIndex(uint256),REF_195(GroupBuyContract.Contributor) -> userAddressToContributor[_userAdd],REF_196(uint256[]) -> REF_195.groupArr,REF_197(uint256) -> REF_196[gIndex],REF_198(GroupBuyContract.Contributor) -> userAddressToContributor[_userAdd],REF_199(uint256[]) -> REF_198.groupArr,REF_200(uint256) -> REF_199[lastGIndex],REF_197(uint256) (->userAddressToContributor) := REF_200(uint256),REF_201(GroupBuyContract.Contributor) -> userAddressToContributor[_userAdd],REF_202(uint256[]) -> REF_201.groupArr,REF_203 -> LENGTH REF_202,REF_203(-> userAddressToContributor) = REF_203 - 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
gIndex = userAddressToContributor[_userAdd].tokenIdToGroupArrIndex[_tokenId] - 1

IRs:
REF_180(GroupBuyContract.Contributor) -> userAddressToContributor[_userAdd]
REF_181(mapping(uint256 => uint256)) -> REF_180.tokenIdToGroupArrIndex
REF_182(uint256) -> REF_181[_tokenId]
TMP_178(uint256) = REF_182 - 1
gIndex(uint256) := TMP_178(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
lastGIndex = userAddressToContributor[_userAdd].groupArr.length - 1

IRs:
REF_183(GroupBuyContract.Contributor) -> userAddressToContributor[_userAdd]
REF_184(uint256[]) -> REF_183.groupArr
REF_185 -> LENGTH REF_184
TMP_179(uint256) = REF_185 - 1
lastGIndex(uint256) := TMP_179(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
userAddressToContributor[_userAdd].tokenIdToGroupArrIndex[_tokenId] = 0

IRs:
REF_186(GroupBuyContract.Contributor) -> userAddressToContributor[_userAdd]
REF_187(mapping(uint256 => uint256)) -> REF_186.tokenIdToGroupArrIndex
REF_188(uint256) -> REF_187[_tokenId]
REF_188(uint256) (->userAddressToContributor) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
lastGIndex > 0

IRs:
TMP_180(bool) = lastGIndex > 0
CONDITION TMP_180""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
userAddressToContributor[_userAdd].tokenIdToGroupArrIndex[userAddressToContributor[_userAdd].groupArr[lastGIndex]] = gIndex

IRs:
REF_189(GroupBuyContract.Contributor) -> userAddressToContributor[_userAdd]
REF_190(mapping(uint256 => uint256)) -> REF_189.tokenIdToGroupArrIndex
REF_191(GroupBuyContract.Contributor) -> userAddressToContributor[_userAdd]
REF_192(uint256[]) -> REF_191.groupArr
REF_193(uint256) -> REF_192[lastGIndex]
REF_194(uint256) -> REF_190[REF_193]
REF_194(uint256) (->userAddressToContributor) := gIndex(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
userAddressToContributor[_userAdd].groupArr[gIndex] = userAddressToContributor[_userAdd].groupArr[lastGIndex]

IRs:
REF_195(GroupBuyContract.Contributor) -> userAddressToContributor[_userAdd]
REF_196(uint256[]) -> REF_195.groupArr
REF_197(uint256) -> REF_196[gIndex]
REF_198(GroupBuyContract.Contributor) -> userAddressToContributor[_userAdd]
REF_199(uint256[]) -> REF_198.groupArr
REF_200(uint256) -> REF_199[lastGIndex]
REF_197(uint256) (->userAddressToContributor) := REF_200(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
userAddressToContributor[_userAdd].groupArr.length -= 1

IRs:
REF_201(GroupBuyContract.Contributor) -> userAddressToContributor[_userAdd]
REF_202(uint256[]) -> REF_201.groupArr
REF_203 -> LENGTH REF_202
REF_203(-> userAddressToContributor) = REF_203 - 1""];
}
",0,1,0,0,gIndex = userAddressToContributor[_userAdd].tokenIdToGroupArrIndex[_tokenId] - 1;lastGIndex = userAddressToContributor[_userAdd].groupArr.length - 1;userAddressToContributor[_userAdd].tokenIdToGroupArrIndex[_tokenId] = 0;lastGIndex > 0;userAddressToContributor[_userAdd].tokenIdToGroupArrIndex[userAddressToContributor[_userAdd].groupArr[lastGIndex]] = gIndex;;userAddressToContributor[_userAdd].groupArr[gIndex] = userAddressToContributor[_userAdd].groupArr[lastGIndex];userAddressToContributor[_userAdd].groupArr.length -= 1
./0x77331db23993850d34372c94b804de2461625503_ext.sol,MHCToken.burnFrom,164,172,"REF_34(uint256) -> balanceOf[_from],TMP_76(bool) = REF_34 >= _value,TMP_77(None) = SOLIDITY_CALL require(bool)(TMP_76),REF_35(mapping(address => uint256)) -> allowance[_from],REF_36(uint256) -> REF_35[msg.sender],TMP_78(bool) = _value <= REF_36,TMP_79(None) = SOLIDITY_CALL require(bool)(TMP_78),REF_37(uint256) -> balanceOf[_from],REF_37(-> balanceOf) = REF_37 - _value,REF_38(mapping(address => uint256)) -> allowance[_from],REF_39(uint256) -> REF_38[msg.sender],REF_39(-> allowance) = REF_39 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_34(uint256) -> balanceOf[_from]
TMP_76(bool) = REF_34 >= _value
TMP_77(None) = SOLIDITY_CALL require(bool)(TMP_76)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_35(mapping(address => uint256)) -> allowance[_from]
REF_36(uint256) -> REF_35[msg.sender]
TMP_78(bool) = _value <= REF_36
TMP_79(None) = SOLIDITY_CALL require(bool)(TMP_78)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_37(uint256) -> balanceOf[_from]
REF_37(-> balanceOf) = REF_37 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_38(mapping(address => uint256)) -> allowance[_from]
REF_39(uint256) -> REF_38[msg.sender]
REF_39(-> allowance) = REF_39 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x75284b2afcd520613c2da5c71be6b3847a0acbf2_ext.sol,MyToken.mintToken,69,75,"REF_5(uint256) -> balanceOf[target],REF_5(-> balanceOf) = REF_5 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_5(uint256) -> balanceOf[target]
REF_5(-> balanceOf) = REF_5 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0xdfbd6a960a55bcfcf59d5925351e05a51498bcef_ext.sol,RockCoin.burnUnsold,140,151,"TMP_41 = UnaryType.BANG preSale ,TMP_42(uint256) = saleTimeStart + 3024000,TMP_43(bool) = TMP_42 < now,TMP_44(bool) = TMP_41 && TMP_43,TMP_45 = UnaryType.BANG burned ,TMP_46(bool) = TMP_44 && TMP_45,CONDITION TMP_46,REF_18(uint256) -> balances[ownerAddress],TMP_47(uint256) = initialSupply - REF_18,sold(uint256) := TMP_47(uint256),TMP_48(uint256) = LIBRARY_CALL, dest:safeMath, function:safeMath.div(uint256,uint256), arguments:['sold', '10'] ,toHold(uint256) := TMP_48(uint256),REF_20(uint256) -> balances[ownerAddress],TMP_49(uint256) = REF_20 - toHold,burningAmount(uint256) := TMP_49(uint256),REF_21(uint256) -> balances[ownerAddress],REF_21(uint256) (->balances) := toHold(uint256),initialSupply(uint256) = initialSupply - burningAmount,Emit Burn(ownerAddress,burningAmount),burned(bool) := True(bool),RETURN burned,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
! preSale && saleTimeStart + 3024000 < now && ! burned

IRs:
TMP_41 = UnaryType.BANG preSale 
TMP_42(uint256) = saleTimeStart + 3024000
TMP_43(bool) = TMP_42 < now
TMP_44(bool) = TMP_41 && TMP_43
TMP_45 = UnaryType.BANG burned 
TMP_46(bool) = TMP_44 && TMP_45
CONDITION TMP_46""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
sold = initialSupply - balances[ownerAddress]

IRs:
REF_18(uint256) -> balances[ownerAddress]
TMP_47(uint256) = initialSupply - REF_18
sold(uint256) := TMP_47(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
toHold = safeMath.div(sold,10)

IRs:
TMP_48(uint256) = LIBRARY_CALL, dest:safeMath, function:safeMath.div(uint256,uint256), arguments:['sold', '10'] 
toHold(uint256) := TMP_48(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
burningAmount = balances[ownerAddress] - toHold

IRs:
REF_20(uint256) -> balances[ownerAddress]
TMP_49(uint256) = REF_20 - toHold
burningAmount(uint256) := TMP_49(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[ownerAddress] = toHold

IRs:
REF_21(uint256) -> balances[ownerAddress]
REF_21(uint256) (->balances) := toHold(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
initialSupply -= burningAmount

IRs:
initialSupply(uint256) = initialSupply - burningAmount""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Burn(ownerAddress,burningAmount)

IRs:
Emit Burn(ownerAddress,burningAmount)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
burned = true

IRs:
burned(bool) := True(bool)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
burned

IRs:
RETURN burned""];
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: RETURN 11

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"! preSale && saleTimeStart + 3024000 < now && ! burned;sold = initialSupply - balances[ownerAddress];;toHold = safeMath.div(sold,10);burningAmount = balances[ownerAddress] - toHold;balances[ownerAddress] = toHold;initialSupply -= burningAmount;Burn(ownerAddress,burningAmount);burned = true;burned;success"
./0x128a0cdaf3bb00e4b5357e02ff0682933beb407f_ext.sol,ERC20Connect.totalSupply,87,89,"TMP_32 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_32],TMP_33(uint256) = _totalSupply - REF_1,RETURN TMP_33","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_32 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_32]
TMP_33(uint256) = _totalSupply - REF_1
RETURN TMP_33""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0xe3d424dffecc3759fcc997f5eba2a01a58585405_ext.sol,ERC20Standard.transferFrom,66,72,"REF_5(uint256) -> balances[_from],TMP_9(bool) = REF_5 >= _value,REF_6(mapping(address => uint256)) -> allowed[_from],REF_7(uint256) -> REF_6[msg.sender],TMP_10(bool) = REF_7 >= _value,TMP_11(bool) = TMP_9 && TMP_10,TMP_12(bool) = _value > 0,TMP_13(bool) = TMP_11 && TMP_12,TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13),REF_8(uint256) -> balances[_to],REF_8(-> balances) = REF_8 + _value,REF_9(uint256) -> balances[_from],REF_9(-> balances) = REF_9 - _value,REF_10(mapping(address => uint256)) -> allowed[_from],REF_11(uint256) -> REF_10[msg.sender],REF_11(-> allowed) = REF_11 - _value,Emit Transfer(_from,_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0)

IRs:
REF_5(uint256) -> balances[_from]
TMP_9(bool) = REF_5 >= _value
REF_6(mapping(address => uint256)) -> allowed[_from]
REF_7(uint256) -> REF_6[msg.sender]
TMP_10(bool) = REF_7 >= _value
TMP_11(bool) = TMP_9 && TMP_10
TMP_12(bool) = _value > 0
TMP_13(bool) = TMP_11 && TMP_12
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_8(uint256) -> balances[_to]
REF_8(-> balances) = REF_8 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_9(uint256) -> balances[_from]
REF_9(-> balances) = REF_9 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_10(mapping(address => uint256)) -> allowed[_from]
REF_11(uint256) -> REF_10[msg.sender]
REF_11(-> allowed) = REF_11 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
}
",0,1,0,0,"require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);balances[_to] += _value;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value)"
./0xa3fa17c51a77a79808f3c21948de3ea70391ce6a_ext.sol,CryptoAllStars._transfer,358,373,"REF_41(uint256) -> ownershipTokenCount[_to],TMP_95(uint256) := REF_41(uint256),REF_41(-> ownershipTokenCount) = REF_41 + 1,REF_42(address) -> personIndexToOwner[_tokenId],REF_42(address) (->personIndexToOwner) := _to(address),TMP_96 = CONVERT 0 to address,TMP_97(bool) = _from != TMP_96,CONDITION TMP_97,REF_43(uint256) -> ownershipTokenCount[_from],TMP_98(uint256) := REF_43(uint256),REF_43(-> ownershipTokenCount) = REF_43 - 1,REF_44(address) -> personIndexToApproved[_tokenId],personIndexToApproved = delete REF_44 ,Emit Transfer(_from,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownershipTokenCount[_to] ++

IRs:
REF_41(uint256) -> ownershipTokenCount[_to]
TMP_95(uint256) := REF_41(uint256)
REF_41(-> ownershipTokenCount) = REF_41 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
personIndexToOwner[_tokenId] = _to

IRs:
REF_42(address) -> personIndexToOwner[_tokenId]
REF_42(address) (->personIndexToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_96 = CONVERT 0 to address
TMP_97(bool) = _from != TMP_96
CONDITION TMP_97""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownershipTokenCount[_from] --

IRs:
REF_43(uint256) -> ownershipTokenCount[_from]
TMP_98(uint256) := REF_43(uint256)
REF_43(-> ownershipTokenCount) = REF_43 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete personIndexToApproved[_tokenId]

IRs:
REF_44(address) -> personIndexToApproved[_tokenId]
personIndexToApproved = delete REF_44 ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
}
",0,1,0,0,"ownershipTokenCount[_to] ++;personIndexToOwner[_tokenId] = _to;_from != address(0);ownershipTokenCount[_from] --;;delete personIndexToApproved[_tokenId];Transfer(_from,_to,_tokenId)"
./0x5c227eb319c24249df66d0c5879515aa59787471_ext.sol,BitAlpha.BitAlphaAirdrop,39,45,"i(uint256) := 0(uint256),REF_1 -> LENGTH addresses,TMP_2(bool) = i < REF_1,CONDITION TMP_2,REF_2(uint256) -> balances[owner],TMP_3(uint256) = 10 ** 8,TMP_4(uint256) = 1500 * TMP_3,REF_2(-> balances) = REF_2 - TMP_4,REF_3(address) -> addresses[i],REF_4(uint256) -> balances[REF_3],TMP_5(uint256) = 10 ** 8,TMP_6(uint256) = 1500 * TMP_5,REF_4(-> balances) = REF_4 + TMP_6,REF_5(address) -> addresses[i],TMP_7(uint256) = 10 ** 8,TMP_8(uint256) = 1500 * TMP_7,Emit Transfer(owner,REF_5,TMP_8),TMP_10(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, BitAlpha.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addresses.length

IRs:
REF_1 -> LENGTH addresses
TMP_2(bool) = i < REF_1
CONDITION TMP_2""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[owner] -= 1500 * 10 ** 8

IRs:
REF_2(uint256) -> balances[owner]
TMP_3(uint256) = 10 ** 8
TMP_4(uint256) = 1500 * TMP_3
REF_2(-> balances) = REF_2 - TMP_4""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[addresses[i]] += 1500 * 10 ** 8

IRs:
REF_3(address) -> addresses[i]
REF_4(uint256) -> balances[REF_3]
TMP_5(uint256) = 10 ** 8
TMP_6(uint256) = 1500 * TMP_5
REF_4(-> balances) = REF_4 + TMP_6""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(owner,addresses[i],1500 * 10 ** 8)

IRs:
REF_5(address) -> addresses[i]
TMP_7(uint256) = 10 ** 8
TMP_8(uint256) = 1500 * TMP_7
Emit Transfer(owner,REF_5,TMP_8)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_10(uint256) := i(uint256)
i(uint256) = i + 1""];
8->4;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, BitAlpha.onlyOwner()()""];
9->3;
}
",0,1,0,0,"onlyOwner();;i < addresses.length;;i = 0;balances[owner] -= 1500 * 10 ** 8;balances[addresses[i]] += 1500 * 10 ** 8;Transfer(owner,addresses[i],1500 * 10 ** 8);i ++"
./0x37d82a4e03e93529c1a32429984e12e7875ea1d8_ext.sol,OMGCatCoin.approveAndCall,180,185,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_58 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_58(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_58 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_58(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x3a2169778d20368dfbf9470c841e5ba8a4a4eccd_ext.sol,TokenERC20.burnFrom,69,77,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xd4236a5b05aafadb21a3e657f6818ad9f20699ae_ext.sol,TxFeatures.poptxs,152,171,"TMP_84(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(user),TMP_85(bool) = TMP_84 >= amount,TMP_86(None) = SOLIDITY_CALL require(bool)(TMP_85),REF_43(TxFeatures.Tx[]) -> txs[user],usertxs(TxFeatures.Tx[]) = ['REF_43(TxFeatures.Tx[])'],REF_44 -> LENGTH usertxs,TMP_87(uint256) = REF_44 - 1,REF_45(TxFeatures.Tx) -> usertxs[TMP_87],curtx(TxFeatures.Tx) := REF_45(TxFeatures.Tx),REF_46 -> LENGTH usertxs,TMP_88(bool) = REF_46 != 0,CONDITION TMP_88,REF_47(uint256) -> curtx.amount,TMP_89(bool) = REF_47 > amount,CONDITION TMP_89,REF_48(uint256) -> curtx.amount,REF_48(-> curtx) = REF_48 - amount,amount(uint256) := 0(uint256),REF_49(uint256) -> curtx.amount,amount(uint256) = amount - REF_49,REF_50 -> LENGTH usertxs,TMP_90(uint256) = REF_50 - 1,REF_51(TxFeatures.Tx) -> usertxs[TMP_90],usertxs = delete REF_51 ,REF_52 -> LENGTH usertxs,REF_52(-> usertxs) = REF_52 - 1,TMP_91(bool) = amount == 0,CONDITION TMP_91,TMP_92(bool) = amount == 0,TMP_93(None) = SOLIDITY_CALL require(bool)(TMP_92)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf(user) >= amount)

IRs:
TMP_84(uint256) = INTERNAL_CALL, BasicToken.balanceOf(address)(user)
TMP_85(bool) = TMP_84 >= amount
TMP_86(None) = SOLIDITY_CALL require(bool)(TMP_85)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
usertxs = txs[user]

IRs:
REF_43(TxFeatures.Tx[]) -> txs[user]
usertxs(TxFeatures.Tx[]) = ['REF_43(TxFeatures.Tx[])']""];
2->5;
3[label=""Node Type: BEGIN_LOOP 3
""];
3->6;
4[label=""Node Type: END_LOOP 4
""];
4->17;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
curtx = usertxs[usertxs.length - 1]

IRs:
REF_44 -> LENGTH usertxs
TMP_87(uint256) = REF_44 - 1
REF_45(TxFeatures.Tx) -> usertxs[TMP_87]
curtx(TxFeatures.Tx) := REF_45(TxFeatures.Tx)""];
5->3;
6[label=""Node Type: IF_LOOP 6

EXPRESSION:
usertxs.length != 0

IRs:
REF_46 -> LENGTH usertxs
TMP_88(bool) = REF_46 != 0
CONDITION TMP_88""];
6->7[label=""True""];
6->4[label=""False""];
7[label=""Node Type: IF 7

EXPRESSION:
curtx.amount > amount

IRs:
REF_47(uint256) -> curtx.amount
TMP_89(bool) = REF_47 > amount
CONDITION TMP_89""];
7->8[label=""True""];
7->10[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
curtx.amount -= amount

IRs:
REF_48(uint256) -> curtx.amount
REF_48(-> curtx) = REF_48 - amount""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
amount = 0

IRs:
amount(uint256) := 0(uint256)""];
9->13;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
amount -= curtx.amount

IRs:
REF_49(uint256) -> curtx.amount
amount(uint256) = amount - REF_49""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
delete usertxs[usertxs.length - 1]

IRs:
REF_50 -> LENGTH usertxs
TMP_90(uint256) = REF_50 - 1
REF_51(TxFeatures.Tx) -> usertxs[TMP_90]
usertxs = delete REF_51 ""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
-- usertxs.length

IRs:
REF_52 -> LENGTH usertxs
REF_52(-> usertxs) = REF_52 - 1""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
amount == 0

IRs:
TMP_91(bool) = amount == 0
CONDITION TMP_91""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: BREAK 15
""];
15->4;
16[label=""Node Type: END_IF 16
""];
16->6;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
require(bool)(amount == 0)

IRs:
TMP_92(bool) = amount == 0
TMP_93(None) = SOLIDITY_CALL require(bool)(TMP_92)""];
}
",0,1,0,0,require(bool)(balanceOf(user) >= amount);usertxs = txs[user];curtx = usertxs[usertxs.length - 1];;usertxs.length != 0;;require(bool)(amount == 0);curtx.amount > amount;curtx.amount -= amount;amount -= curtx.amount;amount = 0;;delete usertxs[usertxs.length - 1];-- usertxs.length;amount == 0;;
./0xa42c5aa9735eca0db714f02de9dc2a56e405dae7_ext.sol,BCT.transferReward,245,257,"REF_39(bool) -> frozen[msg.sender],TMP_58 = UnaryType.BANG REF_39 ,TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58),REF_40(mapping(address => uint256)) -> lockedRewardsOf[msg.sender],REF_41(uint256) -> REF_40[_to],TMP_60(bool) = REF_41 >= _value,TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60),REF_42(uint256) -> totalLockedRewardsOf[msg.sender],TMP_62(bool) = REF_42 >= _value,TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62),REF_43(uint256) = SOLIDITY_CALL balance(address)(msg.sender),TMP_64(bool) = REF_43 < minBalanceForAccounts,CONDITION TMP_64,REF_44(uint256) = SOLIDITY_CALL balance(address)(msg.sender),TMP_65(uint256) = minBalanceForAccounts - REF_44,TMP_66(uint256) = TMP_65 * sellPrice,TMP_67(uint256) = INTERNAL_CALL, BCT.sell(uint256)(TMP_66),REF_45(uint256) -> totalLockedRewardsOf[msg.sender],REF_45(-> totalLockedRewardsOf) = REF_45 - _value,REF_46(mapping(address => uint256)) -> lockedRewardsOf[msg.sender],REF_47(uint256) -> REF_46[_to],REF_47(-> lockedRewardsOf) = REF_47 - _value,REF_48(uint256) -> balanceOf[_to],REF_48(-> balanceOf) = REF_48 + _value,Emit Transfer(msg.sender,_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! frozen[msg.sender])

IRs:
REF_39(bool) -> frozen[msg.sender]
TMP_58 = UnaryType.BANG REF_39 
TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(lockedRewardsOf[msg.sender][_to] >= _value)

IRs:
REF_40(mapping(address => uint256)) -> lockedRewardsOf[msg.sender]
REF_41(uint256) -> REF_40[_to]
TMP_60(bool) = REF_41 >= _value
TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(totalLockedRewardsOf[msg.sender] >= _value)

IRs:
REF_42(uint256) -> totalLockedRewardsOf[msg.sender]
TMP_62(bool) = REF_42 >= _value
TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
msg.sender.balance < minBalanceForAccounts

IRs:
REF_43(uint256) = SOLIDITY_CALL balance(address)(msg.sender)
TMP_64(bool) = REF_43 < minBalanceForAccounts
CONDITION TMP_64""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
sell((minBalanceForAccounts - msg.sender.balance) * sellPrice)

IRs:
REF_44(uint256) = SOLIDITY_CALL balance(address)(msg.sender)
TMP_65(uint256) = minBalanceForAccounts - REF_44
TMP_66(uint256) = TMP_65 * sellPrice
TMP_67(uint256) = INTERNAL_CALL, BCT.sell(uint256)(TMP_66)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
totalLockedRewardsOf[msg.sender] -= _value

IRs:
REF_45(uint256) -> totalLockedRewardsOf[msg.sender]
REF_45(-> totalLockedRewardsOf) = REF_45 - _value""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
lockedRewardsOf[msg.sender][_to] -= _value

IRs:
REF_46(mapping(address => uint256)) -> lockedRewardsOf[msg.sender]
REF_47(uint256) -> REF_46[_to]
REF_47(-> lockedRewardsOf) = REF_47 - _value""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_48(uint256) -> balanceOf[_to]
REF_48(-> balanceOf) = REF_48 + _value""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
}
",0,1,0,0,"require(bool)(! frozen[msg.sender]);require(bool)(lockedRewardsOf[msg.sender][_to] >= _value);require(bool)(totalLockedRewardsOf[msg.sender] >= _value);msg.sender.balance < minBalanceForAccounts;sell((minBalanceForAccounts - msg.sender.balance) * sellPrice);;totalLockedRewardsOf[msg.sender] -= _value;lockedRewardsOf[msg.sender][_to] -= _value;balanceOf[_to] += _value;Transfer(msg.sender,_to,_value)"
./0xc094d10e8c0f5f507bb986f01b0c44a83cbf8440_ext.sol,Crowdsale.cummulativeTokensSold,322,324,"TMP_155(uint256) = tokensSoldPre + tokensSoldIco,RETURN TMP_155","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
tokensSoldPre + tokensSoldIco

IRs:
TMP_155(uint256) = tokensSoldPre + tokensSoldIco
RETURN TMP_155""];
}
",0,1,0,0,tokensSoldPre + tokensSoldIco
./0x46940639ff7122539b71e836eccb08e53b08045d_ext.sol,MyToken.burnFrom,126,134,"REF_17(uint256) -> balanceOf[_from],TMP_27(bool) = REF_17 >= _value,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_18(mapping(address => uint256)) -> allowance[_from],REF_19(uint256) -> REF_18[msg.sender],TMP_29(bool) = _value <= REF_19,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),REF_20(uint256) -> balanceOf[_from],REF_20(-> balanceOf) = REF_20 - _value,REF_21(mapping(address => uint256)) -> allowance[_from],REF_22(uint256) -> REF_21[msg.sender],REF_22(-> allowance) = REF_22 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_17(uint256) -> balanceOf[_from]
TMP_27(bool) = REF_17 >= _value
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_18(mapping(address => uint256)) -> allowance[_from]
REF_19(uint256) -> REF_18[msg.sender]
TMP_29(bool) = _value <= REF_19
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_20(uint256) -> balanceOf[_from]
REF_20(-> balanceOf) = REF_20 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_21(mapping(address => uint256)) -> allowance[_from]
REF_22(uint256) -> REF_21[msg.sender]
REF_22(-> allowance) = REF_22 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x7830cda4a9a2e8fb28b5250d72ede4536b9ff4a0_ext.sol,LLTokenBTB._transfer,45,61,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x32fb35728c3d95ac9591708bfb91136577ab1dd2_ext.sol,BaseToken._transfer,15,24,"TMP_0(bool) = _to != 0,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_0(uint256) -> balanceOf[_from],TMP_2(bool) = REF_0 >= _value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_1(uint256) -> balanceOf[_to],TMP_4(uint256) = REF_1 + _value,REF_2(uint256) -> balanceOf[_to],TMP_5(bool) = TMP_4 > REF_2,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_3(uint256) -> balanceOf[_from],REF_4(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_3 + REF_4,previousBalances(uint256) := TMP_7(uint256),REF_5(uint256) -> balanceOf[_from],REF_5(-> balanceOf) = REF_5 - _value,REF_6(uint256) -> balanceOf[_to],REF_6(-> balanceOf) = REF_6 + _value,REF_7(uint256) -> balanceOf[_from],REF_8(uint256) -> balanceOf[_to],TMP_8(uint256) = REF_7 + REF_8,TMP_9(bool) = TMP_8 == previousBalances,TMP_10(None) = SOLIDITY_CALL assert(bool)(TMP_9),Emit Transfer(_from,_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_0(bool) = _to != 0
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_0(uint256) -> balanceOf[_from]
TMP_2(bool) = REF_0 >= _value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value > balanceOf[_to])

IRs:
REF_1(uint256) -> balanceOf[_to]
TMP_4(uint256) = REF_1 + _value
REF_2(uint256) -> balanceOf[_to]
TMP_5(bool) = TMP_4 > REF_2
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_3(uint256) -> balanceOf[_from]
REF_4(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_3 + REF_4
previousBalances(uint256) := TMP_7(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_5(uint256) -> balanceOf[_from]
REF_5(-> balanceOf) = REF_5 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_6(uint256) -> balanceOf[_to]
REF_6(-> balanceOf) = REF_6 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_7(uint256) -> balanceOf[_from]
REF_8(uint256) -> balanceOf[_to]
TMP_8(uint256) = REF_7 + REF_8
TMP_9(bool) = TMP_8 == previousBalances
TMP_10(None) = SOLIDITY_CALL assert(bool)(TMP_9)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value > balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances);Transfer(_from,_to,_value)"
./0x36ebdbe660c0b988b83c257a779b908697d41615_ext.sol,ArteufToken.burn,110,115,"REF_19(uint256) -> balanceOf[msg.sender],TMP_41(bool) = REF_19 >= _value,TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41),REF_20(uint256) -> balanceOf[msg.sender],REF_20(-> balanceOf) = REF_20 - _value,REF_21(uint256) -> balanceOf[0],REF_21(-> balanceOf) = REF_21 + _value,Emit Transfer(msg.sender,0,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_19(uint256) -> balanceOf[msg.sender]
TMP_41(bool) = REF_19 >= _value
TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_20(uint256) -> balanceOf[msg.sender]
REF_20(-> balanceOf) = REF_20 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[0x0] += _value

IRs:
REF_21(uint256) -> balanceOf[0]
REF_21(-> balanceOf) = REF_21 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,0x0,_value)

IRs:
Emit Transfer(msg.sender,0,_value)""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;balanceOf[0x0] += _value;Transfer(msg.sender,0x0,_value)"
./0x190e2028060fa49adefa5e1f47c8d7be0cbe5063_ext.sol,TRONIXGOLD.approveAndCall,204,209,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x1fc4f3ed0415fd13748383a08069c549910cc655_ext.sol,Hourglass.dividendsOf,481,487,"REF_34(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_65(uint256) = profitPerShare_ * REF_34,TMP_66 = CONVERT TMP_65 to int256,REF_35(int256) -> payoutsTo_[_customerAddress],TMP_67(int256) = TMP_66 - REF_35,TMP_68 = CONVERT TMP_67 to uint256,TMP_69(uint256) = TMP_68 / magnitude,RETURN TMP_69","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_34(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_65(uint256) = profitPerShare_ * REF_34
TMP_66 = CONVERT TMP_65 to int256
REF_35(int256) -> payoutsTo_[_customerAddress]
TMP_67(int256) = TMP_66 - REF_35
TMP_68 = CONVERT TMP_67 to uint256
TMP_69(uint256) = TMP_68 / magnitude
RETURN TMP_69""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x369d0db2c7d56b095d758379b75f64085953528a_ext.sol,CryptoLeu.mintToken,251,256,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x1aced77b121ed465a95fb5471e3d409fd2d4ede6_ext.sol,BaseToken._transfer,15,24,"TMP_0(bool) = _to != 0,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_0(uint256) -> balanceOf[_from],TMP_2(bool) = REF_0 >= _value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_1(uint256) -> balanceOf[_to],TMP_4(uint256) = REF_1 + _value,REF_2(uint256) -> balanceOf[_to],TMP_5(bool) = TMP_4 > REF_2,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_3(uint256) -> balanceOf[_from],REF_4(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_3 + REF_4,previousBalances(uint256) := TMP_7(uint256),REF_5(uint256) -> balanceOf[_from],REF_5(-> balanceOf) = REF_5 - _value,REF_6(uint256) -> balanceOf[_to],REF_6(-> balanceOf) = REF_6 + _value,REF_7(uint256) -> balanceOf[_from],REF_8(uint256) -> balanceOf[_to],TMP_8(uint256) = REF_7 + REF_8,TMP_9(bool) = TMP_8 == previousBalances,TMP_10(None) = SOLIDITY_CALL assert(bool)(TMP_9),Emit Transfer(_from,_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_0(bool) = _to != 0
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_0(uint256) -> balanceOf[_from]
TMP_2(bool) = REF_0 >= _value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value > balanceOf[_to])

IRs:
REF_1(uint256) -> balanceOf[_to]
TMP_4(uint256) = REF_1 + _value
REF_2(uint256) -> balanceOf[_to]
TMP_5(bool) = TMP_4 > REF_2
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_3(uint256) -> balanceOf[_from]
REF_4(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_3 + REF_4
previousBalances(uint256) := TMP_7(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_5(uint256) -> balanceOf[_from]
REF_5(-> balanceOf) = REF_5 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_6(uint256) -> balanceOf[_to]
REF_6(-> balanceOf) = REF_6 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_7(uint256) -> balanceOf[_from]
REF_8(uint256) -> balanceOf[_to]
TMP_8(uint256) = REF_7 + REF_8
TMP_9(bool) = TMP_8 == previousBalances
TMP_10(None) = SOLIDITY_CALL assert(bool)(TMP_9)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value > balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances);Transfer(_from,_to,_value)"
./0x86c6a7ee4ec24d25456580d81f7e8f486186ec91_ext.sol,Coin.generateTokens,124,153,"TMP_26 = CONVERT this to address,REF_3(uint256) -> balances[TMP_26],TMP_27(uint256) = _amount - REF_3,de(uint256) := TMP_27(uint256),TMP_28(uint256) = _totalSupply + de,TMP_29(bool) = _maxSupply >= TMP_28,CONDITION TMP_29,TMP_30 = CONVERT this to address,TMP_31(bool) = _client == TMP_30,CONDITION TMP_31,TMP_32 = CONVERT this to address,REF_4(uint256) -> balances[TMP_32],REF_4(-> balances) = REF_4 + _amount,_totalSupply(uint256) = _totalSupply + _amount,TMP_33 = CONVERT this to address,REF_5(uint256) -> balances[TMP_33],TMP_34(bool) = REF_5 >= _amount,CONDITION TMP_34,TMP_35 = CONVERT this to address,TMP_36(bool) = INTERNAL_CALL, Coin.transferFrom(address,address,uint256)(TMP_35,_client,_amount),TMP_37 = CONVERT this to address,TMP_38 = CONVERT this to address,REF_6(uint256) -> balances[TMP_38],TMP_39(bool) = INTERNAL_CALL, Coin.transferFrom(address,address,uint256)(TMP_37,_client,REF_6),_totalSupply(uint256) = _totalSupply + de,REF_7(uint256) -> balances[_client],REF_7(-> balances) = REF_7 + de,Emit TokensSent(_client,_amount),RETURN True,RETURN False,MODIFIER_CALL, Coin.ownerAndCoin()(),MODIFIER_CALL, Coin.workingFlag()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->17;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
de = _amount - balances[address(this)]

IRs:
TMP_26 = CONVERT this to address
REF_3(uint256) -> balances[TMP_26]
TMP_27(uint256) = _amount - REF_3
de(uint256) := TMP_27(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
_maxSupply >= _totalSupply + de

IRs:
TMP_28(uint256) = _totalSupply + de
TMP_29(bool) = _maxSupply >= TMP_28
CONDITION TMP_29""];
2->3[label=""True""];
2->15[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
_client == address(this)

IRs:
TMP_30 = CONVERT this to address
TMP_31(bool) = _client == TMP_30
CONDITION TMP_31""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[address(this)] += _amount

IRs:
TMP_32 = CONVERT this to address
REF_4(uint256) -> balances[TMP_32]
REF_4(-> balances) = REF_4 + _amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_totalSupply += _amount

IRs:
_totalSupply(uint256) = _totalSupply + _amount""];
5->12;
6[label=""Node Type: IF 6

EXPRESSION:
balances[address(this)] >= _amount

IRs:
TMP_33 = CONVERT this to address
REF_5(uint256) -> balances[TMP_33]
TMP_34(bool) = REF_5 >= _amount
CONDITION TMP_34""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
transferFrom(address(this),_client,_amount)

IRs:
TMP_35 = CONVERT this to address
TMP_36(bool) = INTERNAL_CALL, Coin.transferFrom(address,address,uint256)(TMP_35,_client,_amount)""];
7->11;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
transferFrom(address(this),_client,balances[address(this)])

IRs:
TMP_37 = CONVERT this to address
TMP_38 = CONVERT this to address
REF_6(uint256) -> balances[TMP_38]
TMP_39(bool) = INTERNAL_CALL, Coin.transferFrom(address,address,uint256)(TMP_37,_client,REF_6)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
_totalSupply += de

IRs:
_totalSupply(uint256) = _totalSupply + de""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
balances[_client] += de

IRs:
REF_7(uint256) -> balances[_client]
REF_7(-> balances) = REF_7 + de""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
TokensSent(_client,_amount)

IRs:
Emit TokensSent(_client,_amount)""];
13->14;
14[label=""Node Type: RETURN 14

EXPRESSION:
true

IRs:
RETURN True""];
15[label=""Node Type: RETURN 15

EXPRESSION:
false

IRs:
RETURN False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
ownerAndCoin()

IRs:
MODIFIER_CALL, Coin.ownerAndCoin()()""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
workingFlag()

IRs:
MODIFIER_CALL, Coin.workingFlag()()""];
18->1;
19[label=""Node Type: RETURN 19

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"ownerAndCoin();de = _amount - balances[address(this)];_maxSupply >= _totalSupply + de;_client == address(this);false;balances[address(this)] += _amount;balances[address(this)] >= _amount;_totalSupply += _amount;;transferFrom(address(this),_client,_amount);transferFrom(address(this),_client,balances[address(this)]);;_totalSupply += de;balances[_client] += de;TokensSent(_client,_amount);true;workingFlag();success"
./0x1c9be00d799132986edcd2d099b9f28e5757677c_ext.sol,_0xEtherToken.approveAndCall,308,313,"REF_41(mapping(address => uint256)) -> allowed[msg.sender],REF_42(uint256) -> REF_41[spender],REF_42(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_78 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_78(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_41(mapping(address => uint256)) -> allowed[msg.sender]
REF_42(uint256) -> REF_41[spender]
REF_42(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_78 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_78(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x2668afe75c5b0b726c2b4388658edae365eda4e2_ext.sol,B2ANDcoin.approveAndCall,62,70,"TMP_29 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_29(tokenRecipient),TMP_30(bool) = INTERNAL_CALL, B2ANDcoin.approve(address,uint256)(_spender,_value),CONDITION TMP_30,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_29 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_29(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_30(bool) = INTERNAL_CALL, B2ANDcoin.approve(address,uint256)(_spender,_value)
CONDITION TMP_30""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x022882d9fcf023e57926e4e01d1b137aabd93416_ext.sol,StandardToken.transferFrom,26,36,"REF_3(uint256) -> balances[_from],TMP_4(bool) = REF_3 >= _value,REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],TMP_5(bool) = REF_5 >= _value,TMP_6(bool) = TMP_4 && TMP_5,TMP_7(bool) = _value > 0,TMP_8(bool) = TMP_6 && TMP_7,CONDITION TMP_8,REF_6(uint256) -> balances[_to],REF_6(-> balances) = REF_6 + _value,REF_7(uint256) -> balances[_from],REF_7(-> balances) = REF_7 - _value,REF_8(mapping(address => uint256)) -> allowed[_from],REF_9(uint256) -> REF_8[msg.sender],REF_9(-> allowed) = REF_9 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0

IRs:
REF_3(uint256) -> balances[_from]
TMP_4(bool) = REF_3 >= _value
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
TMP_5(bool) = REF_5 >= _value
TMP_6(bool) = TMP_4 && TMP_5
TMP_7(bool) = _value > 0
TMP_8(bool) = TMP_6 && TMP_7
CONDITION TMP_8""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_6(uint256) -> balances[_to]
REF_6(-> balances) = REF_6 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_7(uint256) -> balances[_from]
REF_7(-> balances) = REF_7 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_8(mapping(address => uint256)) -> allowed[_from]
REF_9(uint256) -> REF_8[msg.sender]
REF_9(-> allowed) = REF_9 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0;balances[_to] += _value;false;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true;success"
./0x207c92740ccbe446ac2e2f43fe1da52651cd8d3c_ext.sol,TJK.transferFrom,39,45,"REF_5(uint256) -> balances[_from],TMP_9(bool) = REF_5 >= _value,REF_6(mapping(address => uint256)) -> allowed[_from],REF_7(uint256) -> REF_6[msg.sender],TMP_10(bool) = REF_7 >= _value,TMP_11(bool) = TMP_9 && TMP_10,TMP_12(bool) = _value > 0,TMP_13(bool) = TMP_11 && TMP_12,TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13),REF_8(uint256) -> balances[_to],REF_8(-> balances) = REF_8 + _value,REF_9(uint256) -> balances[_from],REF_9(-> balances) = REF_9 - _value,REF_10(mapping(address => uint256)) -> allowed[_from],REF_11(uint256) -> REF_10[msg.sender],REF_11(-> allowed) = REF_11 - _value,Emit Transfer(_from,_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0)

IRs:
REF_5(uint256) -> balances[_from]
TMP_9(bool) = REF_5 >= _value
REF_6(mapping(address => uint256)) -> allowed[_from]
REF_7(uint256) -> REF_6[msg.sender]
TMP_10(bool) = REF_7 >= _value
TMP_11(bool) = TMP_9 && TMP_10
TMP_12(bool) = _value > 0
TMP_13(bool) = TMP_11 && TMP_12
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_8(uint256) -> balances[_to]
REF_8(-> balances) = REF_8 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_9(uint256) -> balances[_from]
REF_9(-> balances) = REF_9 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_10(mapping(address => uint256)) -> allowed[_from]
REF_11(uint256) -> REF_10[msg.sender]
REF_11(-> allowed) = REF_11 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
}
",0,1,0,0,"require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);balances[_to] += _value;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value)"
./0x856912680349a406f72e26aa994100b8ad409f87_ext.sol,StandardToken.transfer,58,67,"TMP_0(bool) = to != 0,TMP_1 = CONVERT this to address,TMP_2(bool) = to != TMP_1,TMP_3(bool) = TMP_0 && TMP_2,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_0(uint256) -> balances[msg.sender],TMP_5(bool) = REF_0 < value,CONDITION TMP_5,TMP_6(None) = SOLIDITY_CALL revert()(),REF_1(uint256) -> balances[msg.sender],REF_1(-> balances) = REF_1 - value,REF_2(uint256) -> balances[to],REF_2(-> balances) = REF_2 + value,Emit Transfer(msg.sender,to,value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((to != 0x0) && (to != address(this)))

IRs:
TMP_0(bool) = to != 0
TMP_1 = CONVERT this to address
TMP_2(bool) = to != TMP_1
TMP_3(bool) = TMP_0 && TMP_2
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
balances[msg.sender] < value

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_5(bool) = REF_0 < value
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
revert()()

IRs:
TMP_6(None) = SOLIDITY_CALL revert()()""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[msg.sender] -= value

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_1(-> balances) = REF_1 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[to] += value

IRs:
REF_2(uint256) -> balances[to]
REF_2(-> balances) = REF_2 + value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)((to != 0x0) && (to != address(this)));balances[msg.sender] < value;revert()();;balances[msg.sender] -= value;balances[to] += value;Transfer(msg.sender,to,value);true"
./0x5b7cfbee45509b89417f26bbc28a8de11bca3726_ext.sol,AirdropSmart.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x0eeb66edff8ccfd85c2181eff81d8275a3b92b8b_ext.sol,OROCoin.burn,135,141,"REF_17(uint256) -> balanceOf[msg.sender],TMP_25(bool) = REF_17 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_25(bool) = REF_17 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x02c60d28be3338014fef3fdf50a3218b946c0609_ext.sol,EasyInvest3.fallback,29,44,"REF_0(uint256) -> invested[msg.sender],TMP_0(bool) = REF_0 != 0,CONDITION TMP_0,REF_1(uint256) -> invested[msg.sender],TMP_1(uint256) = REF_1 * 3,TMP_2(uint256) = TMP_1 / 100,REF_2(uint256) -> atBlock[msg.sender],TMP_3(uint256) = block.number - REF_2,TMP_4(uint256) = TMP_2 * TMP_3,TMP_5(uint256) = TMP_4 / 5900,amount(uint256) := TMP_5(uint256),Transfer dest:msg.sender value:amount,REF_4(uint256) -> atBlock[msg.sender],REF_4(uint256) (->atBlock) := block.number(uint256),REF_5(uint256) -> invested[msg.sender],REF_5(-> invested) = REF_5 + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
invested[msg.sender] != 0

IRs:
REF_0(uint256) -> invested[msg.sender]
TMP_0(bool) = REF_0 != 0
CONDITION TMP_0""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = invested[msg.sender] * 3 / 100 * (block.number - atBlock[msg.sender]) / 5900

IRs:
REF_1(uint256) -> invested[msg.sender]
TMP_1(uint256) = REF_1 * 3
TMP_2(uint256) = TMP_1 / 100
REF_2(uint256) -> atBlock[msg.sender]
TMP_3(uint256) = block.number - REF_2
TMP_4(uint256) = TMP_2 * TMP_3
TMP_5(uint256) = TMP_4 / 5900
amount(uint256) := TMP_5(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
atBlock[msg.sender] = block.number

IRs:
REF_4(uint256) -> atBlock[msg.sender]
REF_4(uint256) (->atBlock) := block.number(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
invested[msg.sender] += msg.value

IRs:
REF_5(uint256) -> invested[msg.sender]
REF_5(-> invested) = REF_5 + msg.value""];
}
",0,1,0,0,invested[msg.sender] != 0;amount = invested[msg.sender] * 3 / 100 * (block.number - atBlock[msg.sender]) / 5900;;msg.sender.transfer(amount);atBlock[msg.sender] = block.number;invested[msg.sender] += msg.value
./0x04ed15fa8c47778589c1bf3451e0de25c1eed3ae_ext.sol,ALEX.mintToken,73,78,"REF_1(uint256) -> balanceOf[target],REF_1(-> balanceOf) = REF_1 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,owner,mintedAmount),Emit Transfer(owner,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_1(uint256) -> balanceOf[target]
REF_1(-> balanceOf) = REF_1 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,owner,mintedAmount)

IRs:
Emit Transfer(0,owner,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(owner,target,mintedAmount)

IRs:
Emit Transfer(owner,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,owner,mintedAmount);Transfer(owner,target,mintedAmount)"
./0x571df5a0b5571a3cc7dcbd8185b200426376845f_ext.sol,EBRK.burnFrom,140,148,"REF_19(uint256) -> balanceOf[_from],TMP_22(bool) = REF_19 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_24(bool) = _value <= REF_21,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_22(bool) = REF_19 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_24(bool) = _value <= REF_21
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xecff8fc2a19f83fc855618704f38725756dbcae3_ext.sol,OK3D.getPlayerVaults,717,756,"_rID(uint256) := rID_(uint256),REF_155(F3Ddatasets.Round) -> round_[_rID],REF_156(uint256) -> REF_155.end,TMP_123(bool) = now > REF_156,REF_157(F3Ddatasets.Round) -> round_[_rID],REF_158(bool) -> REF_157.ended,TMP_124(bool) = REF_158 == False,TMP_125(bool) = TMP_123 && TMP_124,REF_159(F3Ddatasets.Round) -> round_[_rID],REF_160(uint256) -> REF_159.plyr,TMP_126(bool) = REF_160 != 0,TMP_127(bool) = TMP_125 && TMP_126,CONDITION TMP_127,REF_161(F3Ddatasets.Round) -> round_[_rID],REF_162(uint256) -> REF_161.plyr,TMP_128(bool) = REF_162 == _pID,CONDITION TMP_128,REF_163(F3Ddatasets.Player) -> plyr_[_pID],REF_164(uint256) -> REF_163.win,REF_166(F3Ddatasets.Round) -> round_[_rID],REF_167(uint256) -> REF_166.pot,TMP_129(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_167', '48'] ,TMP_130(uint256) = TMP_129 / 100,TMP_131(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_164', 'TMP_130'] ,REF_169(F3Ddatasets.Player) -> plyr_[_pID],REF_170(uint256) -> REF_169.gen,TMP_132(uint256) = INTERNAL_CALL, OK3D.getPlayerVaultsHelper(uint256,uint256)(_pID,_rID),REF_173(mapping(uint256 => F3Ddatasets.PlayerRounds)) -> plyrRnds_[_pID],REF_174(F3Ddatasets.PlayerRounds) -> REF_173[_rID],REF_175(uint256) -> REF_174.mask,TMP_133(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_132', 'REF_175'] ,TMP_134(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_170', 'TMP_133'] ,REF_176(F3Ddatasets.Player) -> plyr_[_pID],REF_177(uint256) -> REF_176.aff,RETURN TMP_131,TMP_134,REF_177,REF_178(F3Ddatasets.Player) -> plyr_[_pID],REF_179(uint256) -> REF_178.win,REF_180(F3Ddatasets.Player) -> plyr_[_pID],REF_181(uint256) -> REF_180.gen,TMP_135(uint256) = INTERNAL_CALL, OK3D.getPlayerVaultsHelper(uint256,uint256)(_pID,_rID),REF_184(mapping(uint256 => F3Ddatasets.PlayerRounds)) -> plyrRnds_[_pID],REF_185(F3Ddatasets.PlayerRounds) -> REF_184[_rID],REF_186(uint256) -> REF_185.mask,TMP_136(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_135', 'REF_186'] ,TMP_137(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_181', 'TMP_136'] ,REF_187(F3Ddatasets.Player) -> plyr_[_pID],REF_188(uint256) -> REF_187.aff,RETURN REF_179,TMP_137,REF_188,REF_189(F3Ddatasets.Player) -> plyr_[_pID],REF_190(uint256) -> REF_189.win,REF_191(F3Ddatasets.Player) -> plyr_[_pID],REF_192(uint256) -> REF_191.gen,REF_194(F3Ddatasets.Player) -> plyr_[_pID],REF_195(uint256) -> REF_194.lrnd,TMP_138(uint256) = INTERNAL_CALL, OK3D.calcUnMaskedEarnings(uint256,uint256)(_pID,REF_195),TMP_139(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_192', 'TMP_138'] ,REF_196(F3Ddatasets.Player) -> plyr_[_pID],REF_197(uint256) -> REF_196.aff,RETURN REF_190,TMP_139,REF_197","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_rID = rID_

IRs:
_rID(uint256) := rID_(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0

IRs:
REF_155(F3Ddatasets.Round) -> round_[_rID]
REF_156(uint256) -> REF_155.end
TMP_123(bool) = now > REF_156
REF_157(F3Ddatasets.Round) -> round_[_rID]
REF_158(bool) -> REF_157.ended
TMP_124(bool) = REF_158 == False
TMP_125(bool) = TMP_123 && TMP_124
REF_159(F3Ddatasets.Round) -> round_[_rID]
REF_160(uint256) -> REF_159.plyr
TMP_126(bool) = REF_160 != 0
TMP_127(bool) = TMP_125 && TMP_126
CONDITION TMP_127""];
2->3[label=""True""];
2->7[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
round_[_rID].plyr == _pID

IRs:
REF_161(F3Ddatasets.Round) -> round_[_rID]
REF_162(uint256) -> REF_161.plyr
TMP_128(bool) = REF_162 == _pID
CONDITION TMP_128""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: RETURN 4

EXPRESSION:
((plyr_[_pID].win).add(((round_[_rID].pot).mul(48)) / 100),(plyr_[_pID].gen).add(getPlayerVaultsHelper(_pID,_rID).sub(plyrRnds_[_pID][_rID].mask)),plyr_[_pID].aff)

IRs:
REF_163(F3Ddatasets.Player) -> plyr_[_pID]
REF_164(uint256) -> REF_163.win
REF_166(F3Ddatasets.Round) -> round_[_rID]
REF_167(uint256) -> REF_166.pot
TMP_129(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_167', '48'] 
TMP_130(uint256) = TMP_129 / 100
TMP_131(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_164', 'TMP_130'] 
REF_169(F3Ddatasets.Player) -> plyr_[_pID]
REF_170(uint256) -> REF_169.gen
TMP_132(uint256) = INTERNAL_CALL, OK3D.getPlayerVaultsHelper(uint256,uint256)(_pID,_rID)
REF_173(mapping(uint256 => F3Ddatasets.PlayerRounds)) -> plyrRnds_[_pID]
REF_174(F3Ddatasets.PlayerRounds) -> REF_173[_rID]
REF_175(uint256) -> REF_174.mask
TMP_133(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_132', 'REF_175'] 
TMP_134(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_170', 'TMP_133'] 
REF_176(F3Ddatasets.Player) -> plyr_[_pID]
REF_177(uint256) -> REF_176.aff
RETURN TMP_131,TMP_134,REF_177""];
5[label=""Node Type: RETURN 5

EXPRESSION:
(plyr_[_pID].win,(plyr_[_pID].gen).add(getPlayerVaultsHelper(_pID,_rID).sub(plyrRnds_[_pID][_rID].mask)),plyr_[_pID].aff)

IRs:
REF_178(F3Ddatasets.Player) -> plyr_[_pID]
REF_179(uint256) -> REF_178.win
REF_180(F3Ddatasets.Player) -> plyr_[_pID]
REF_181(uint256) -> REF_180.gen
TMP_135(uint256) = INTERNAL_CALL, OK3D.getPlayerVaultsHelper(uint256,uint256)(_pID,_rID)
REF_184(mapping(uint256 => F3Ddatasets.PlayerRounds)) -> plyrRnds_[_pID]
REF_185(F3Ddatasets.PlayerRounds) -> REF_184[_rID]
REF_186(uint256) -> REF_185.mask
TMP_136(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_135', 'REF_186'] 
TMP_137(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_181', 'TMP_136'] 
REF_187(F3Ddatasets.Player) -> plyr_[_pID]
REF_188(uint256) -> REF_187.aff
RETURN REF_179,TMP_137,REF_188""];
7[label=""Node Type: RETURN 7

EXPRESSION:
(plyr_[_pID].win,(plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID,plyr_[_pID].lrnd)),plyr_[_pID].aff)

IRs:
REF_189(F3Ddatasets.Player) -> plyr_[_pID]
REF_190(uint256) -> REF_189.win
REF_191(F3Ddatasets.Player) -> plyr_[_pID]
REF_192(uint256) -> REF_191.gen
REF_194(F3Ddatasets.Player) -> plyr_[_pID]
REF_195(uint256) -> REF_194.lrnd
TMP_138(uint256) = INTERNAL_CALL, OK3D.calcUnMaskedEarnings(uint256,uint256)(_pID,REF_195)
TMP_139(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_192', 'TMP_138'] 
REF_196(F3Ddatasets.Player) -> plyr_[_pID]
REF_197(uint256) -> REF_196.aff
RETURN REF_190,TMP_139,REF_197""];
}
",0,1,0,0,"_rID = rID_;now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0;round_[_rID].plyr == _pID;(plyr_[_pID].win,(plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID,plyr_[_pID].lrnd)),plyr_[_pID].aff);((plyr_[_pID].win).add(((round_[_rID].pot).mul(48)) / 100),(plyr_[_pID].gen).add(getPlayerVaultsHelper(_pID,_rID).sub(plyrRnds_[_pID][_rID].mask)),plyr_[_pID].aff);(plyr_[_pID].win,(plyr_[_pID].gen).add(getPlayerVaultsHelper(_pID,_rID).sub(plyrRnds_[_pID][_rID].mask)),plyr_[_pID].aff)"
./0x48c8efdbf925a8028abf1d4bacb7baa59ff2948b_ext.sol,FTWCoin.fallback,117,131,"TMP_22(uint256) = totalEthInWei + msg.value,totalEthInWei(uint256) := TMP_22(uint256),TMP_23(uint256) = msg.value * unitsOneEthCanBuy,amount(uint256) := TMP_23(uint256),REF_31(uint256) -> balances[fundsWallet],TMP_24(bool) = REF_31 < amount,CONDITION TMP_24,REF_32(uint256) -> balances[fundsWallet],REF_33(uint256) -> balances[fundsWallet],TMP_25(uint256) = REF_33 - amount,REF_32(uint256) (->balances) := TMP_25(uint256),REF_34(uint256) -> balances[msg.sender],REF_35(uint256) -> balances[msg.sender],TMP_26(uint256) = REF_35 + amount,REF_34(uint256) (->balances) := TMP_26(uint256),Emit Transfer(fundsWallet,msg.sender,amount),Transfer dest:fundsWallet value:msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
totalEthInWei = totalEthInWei + msg.value

IRs:
TMP_22(uint256) = totalEthInWei + msg.value
totalEthInWei(uint256) := TMP_22(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = msg.value * unitsOneEthCanBuy

IRs:
TMP_23(uint256) = msg.value * unitsOneEthCanBuy
amount(uint256) := TMP_23(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
balances[fundsWallet] < amount

IRs:
REF_31(uint256) -> balances[fundsWallet]
TMP_24(bool) = REF_31 < amount
CONDITION TMP_24""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: RETURN 4
""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[fundsWallet] = balances[fundsWallet] - amount

IRs:
REF_32(uint256) -> balances[fundsWallet]
REF_33(uint256) -> balances[fundsWallet]
TMP_25(uint256) = REF_33 - amount
REF_32(uint256) (->balances) := TMP_25(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[msg.sender] = balances[msg.sender] + amount

IRs:
REF_34(uint256) -> balances[msg.sender]
REF_35(uint256) -> balances[msg.sender]
TMP_26(uint256) = REF_35 + amount
REF_34(uint256) (->balances) := TMP_26(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(fundsWallet,msg.sender,amount)

IRs:
Emit Transfer(fundsWallet,msg.sender,amount)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
fundsWallet.transfer(msg.value)

IRs:
Transfer dest:fundsWallet value:msg.value""];
}
",0,1,0,0,"totalEthInWei = totalEthInWei + msg.value;amount = msg.value * unitsOneEthCanBuy;balances[fundsWallet] < amount;;;balances[fundsWallet] = balances[fundsWallet] - amount;balances[msg.sender] = balances[msg.sender] + amount;Transfer(fundsWallet,msg.sender,amount);fundsWallet.transfer(msg.value)"
./0xc5d3b25a2ca77316b637106a749cd5e92a8e4702_ext.sol,COMMERCIALPOINTCHAINSYSTEM.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x6cec5ecfe573e0903edc467c4ed75f99bade6dc7_ext.sol,Bgc.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xd96205b1ef12bc471195fe92a896c461528181ab_ext.sol,CandyToken.burn,127,133,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x8476957a872ac0bc253333cc063b6a37f6a6faa3_ext.sol,CINDICATORFund.default_helper,124,127,"TMP_35 = UnaryType.BANG bought_tokens ,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),REF_13(uint256) -> balances[msg.sender],REF_13(-> balances) = REF_13 + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! bought_tokens)

IRs:
TMP_35 = UnaryType.BANG bought_tokens 
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] += msg.value

IRs:
REF_13(uint256) -> balances[msg.sender]
REF_13(-> balances) = REF_13 + msg.value""];
}
",0,1,0,0,require(bool)(! bought_tokens);balances[msg.sender] += msg.value
./0x33a104dcbed81961701900c06fd14587c908eaa3_ext.sol,AccessControl.removeSERAPHIM,39,44,"REF_2(bool) -> seraphims[_oldSeraphim],TMP_2(bool) = REF_2 == True,CONDITION TMP_2,REF_3(bool) -> seraphims[_oldSeraphim],REF_3(bool) (->seraphims) := False(bool),totalSeraphims(uint16) = totalSeraphims - 1,MODIFIER_CALL, AccessControl.onlyCREATOR()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
seraphims[_oldSeraphim] == true

IRs:
REF_2(bool) -> seraphims[_oldSeraphim]
TMP_2(bool) = REF_2 == True
CONDITION TMP_2""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
seraphims[_oldSeraphim] = false

IRs:
REF_3(bool) -> seraphims[_oldSeraphim]
REF_3(bool) (->seraphims) := False(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSeraphims -= 1

IRs:
totalSeraphims(uint16) = totalSeraphims - 1""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyCREATOR()

IRs:
MODIFIER_CALL, AccessControl.onlyCREATOR()()""];
5->1;
}
",0,1,0,0,onlyCREATOR();seraphims[_oldSeraphim] == true;seraphims[_oldSeraphim] = false;;totalSeraphims -= 1
./0xc654928ecf5f984ef72c806ec9b6e2d213c90818_ext.sol,TokenERC20.burn,150,156,"REF_17(uint256) -> balanceOf[msg.sender],TMP_26(bool) = REF_17 >= _value,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_26(bool) = REF_17 >= _value
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x6560c60f55c165e6f819b3a52c13f9f1aa22b502_ext.sol,Data.addBalance,270,272,"REF_82(uint256) -> balances[_addr],REF_82(-> balances) = REF_82 + amount,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances[_addr] += amount

IRs:
REF_82(uint256) -> balances[_addr]
REF_82(-> balances) = REF_82 + amount""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,1,0,0,onlyOwner();balances[_addr] += amount
./0x52fb36c83ad33c1824912fc81071ca5eeb8ab390_ext.sol,TOKENERC20.burn,130,136,"REF_13(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_13 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_14(uint256) -> balanceOf[msg.sender],REF_14(-> balanceOf) = REF_14 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_13(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_13 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_14(uint256) -> balanceOf[msg.sender]
REF_14(-> balanceOf) = REF_14 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x0d1c63e12fde9e5cada3e272576183aba9cfeda2_ext.sol,ZenswapNetworkToken.burn,123,129,"REF_17(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_17 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_17 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xc3a684140448995f6abeb361c56110207da04d57_ext.sol,SignalsSociety.deposit,79,84,"REF_7(uint256) -> balances[account],REF_7(-> balances) = REF_7 + amount,REF_8(uint256) -> balances[account],Emit Deposited(account,amount,REF_8,now)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances[account] += amount

IRs:
REF_7(uint256) -> balances[account]
REF_7(-> balances) = REF_7 + amount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Deposited(account,amount,balances[account],now)

IRs:
REF_8(uint256) -> balances[account]
Emit Deposited(account,amount,REF_8,now)""];
}
",0,1,0,0,"balances[account] += amount;Deposited(account,amount,balances[account],now)"
./0x07ce333ec45618d838c32e60cee5cb1ce389e06e_ext.sol,BancorChanger.updateReserve,471,484,"REF_34(BancorChanger.Reserve) -> reserves[_reserveToken],reserve(BancorChanger.Reserve) := REF_34(BancorChanger.Reserve),REF_35(uint8) -> reserve.ratio,TMP_147(uint8) = totalReserveRatio - REF_35,TMP_148(uint8) = TMP_147 + _ratio,TMP_149(bool) = TMP_148 <= 100,TMP_150(None) = SOLIDITY_CALL require(bool)(TMP_149),REF_36(uint8) -> reserve.ratio,TMP_151(uint8) = totalReserveRatio - REF_36,TMP_152(uint8) = TMP_151 + _ratio,totalReserveRatio(uint8) := TMP_152(uint8),REF_37(uint8) -> reserve.ratio,REF_37(uint8) (->reserve) := _ratio(uint8),REF_38(bool) -> reserve.isVirtualBalanceEnabled,REF_38(bool) (->reserve) := _enableVirtualBalance(bool),REF_39(uint256) -> reserve.virtualBalance,REF_39(uint256) (->reserve) := _virtualBalance(uint256),MODIFIER_CALL, Owned.ownerOnly()(),MODIFIER_CALL, BancorChanger.validReserve(address)(_reserveToken),MODIFIER_CALL, BancorChanger.validReserveRatio(uint8)(_ratio)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
reserve = reserves[_reserveToken]

IRs:
REF_34(BancorChanger.Reserve) -> reserves[_reserveToken]
reserve(BancorChanger.Reserve) := REF_34(BancorChanger.Reserve)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(totalReserveRatio - reserve.ratio + _ratio <= 100)

IRs:
REF_35(uint8) -> reserve.ratio
TMP_147(uint8) = totalReserveRatio - REF_35
TMP_148(uint8) = TMP_147 + _ratio
TMP_149(bool) = TMP_148 <= 100
TMP_150(None) = SOLIDITY_CALL require(bool)(TMP_149)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalReserveRatio = totalReserveRatio - reserve.ratio + _ratio

IRs:
REF_36(uint8) -> reserve.ratio
TMP_151(uint8) = totalReserveRatio - REF_36
TMP_152(uint8) = TMP_151 + _ratio
totalReserveRatio(uint8) := TMP_152(uint8)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
reserve.ratio = _ratio

IRs:
REF_37(uint8) -> reserve.ratio
REF_37(uint8) (->reserve) := _ratio(uint8)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
reserve.isVirtualBalanceEnabled = _enableVirtualBalance

IRs:
REF_38(bool) -> reserve.isVirtualBalanceEnabled
REF_38(bool) (->reserve) := _enableVirtualBalance(bool)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
reserve.virtualBalance = _virtualBalance

IRs:
REF_39(uint256) -> reserve.virtualBalance
REF_39(uint256) (->reserve) := _virtualBalance(uint256)""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
ownerOnly()

IRs:
MODIFIER_CALL, Owned.ownerOnly()()""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
validReserve(_reserveToken)

IRs:
MODIFIER_CALL, BancorChanger.validReserve(address)(_reserveToken)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
validReserveRatio(_ratio)

IRs:
MODIFIER_CALL, BancorChanger.validReserveRatio(uint8)(_ratio)""];
9->1;
}
",0,1,0,0,ownerOnly();reserve = reserves[_reserveToken];require(bool)(totalReserveRatio - reserve.ratio + _ratio <= 100);totalReserveRatio = totalReserveRatio - reserve.ratio + _ratio;reserve.ratio = _ratio;reserve.isVirtualBalanceEnabled = _enableVirtualBalance;reserve.virtualBalance = _virtualBalance;validReserve(_reserveToken);validReserveRatio(_ratio)
./0x6ceb458fac48cf87b420f23b0d890534655683e0_ext.sol,ERC20.transferFrom,39,49,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x4bb12d68c795462c12ec30ad82421218d9c32a7d_ext.sol,Crowdsale.fallback,51,72,"CONDITION crowdsaleClosed,REF_0(uint256) -> balanceOf[msg.sender],amount2(uint256) := REF_0(uint256),REF_1(uint256) -> percentOf[msg.sender],TMP_5(uint256) = percent - REF_1,rewardPercent(uint256) := TMP_5(uint256),TMP_6(bool) = amount2 > 0,TMP_7(bool) = rewardPercent > 0,TMP_8(bool) = TMP_6 && TMP_7,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_2(uint256) -> percentOf[msg.sender],REF_2(uint256) (->percentOf) := percent(uint256),TMP_10(uint256) = 10 ** 18,TMP_11(uint256) = amount2 * TMP_10,TMP_12(uint256) = TMP_11 * rewardPercent,TMP_13(uint256) = TMP_12 / price,TMP_14(uint256) = TMP_13 / 100,rewardAmount2(uint256) := TMP_14(uint256),HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['msg.sender', 'rewardAmount2']  ,Emit RewardToken(msg.sender,rewardAmount2,rewardPercent),amount(uint256) := msg.value(uint256),REF_4(uint256) -> balanceOf[msg.sender],REF_4(-> balanceOf) = REF_4 + amount,amountRaised(uint256) = amountRaised + amount,REF_5(uint256) -> percentOf[msg.sender],REF_5(uint256) (->percentOf) := percent(uint256),TMP_17(uint256) = 10 ** 18,TMP_18(uint256) = amount * TMP_17,TMP_19(uint256) = TMP_18 * percent,TMP_20(uint256) = TMP_19 / price,TMP_21(uint256) = TMP_20 / 100,rewardAmount(uint256) := TMP_21(uint256),HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['msg.sender', 'rewardAmount']  ,Emit FundTransfer(msg.sender,amount,True),Emit RewardToken(msg.sender,rewardAmount,percent)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
crowdsaleClosed

IRs:
CONDITION crowdsaleClosed""];
1->2[label=""True""];
1->9[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount2 = balanceOf[msg.sender]

IRs:
REF_0(uint256) -> balanceOf[msg.sender]
amount2(uint256) := REF_0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
rewardPercent = percent - percentOf[msg.sender]

IRs:
REF_1(uint256) -> percentOf[msg.sender]
TMP_5(uint256) = percent - REF_1
rewardPercent(uint256) := TMP_5(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(amount2 > 0 && rewardPercent > 0)

IRs:
TMP_6(bool) = amount2 > 0
TMP_7(bool) = rewardPercent > 0
TMP_8(bool) = TMP_6 && TMP_7
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
percentOf[msg.sender] = percent

IRs:
REF_2(uint256) -> percentOf[msg.sender]
REF_2(uint256) (->percentOf) := percent(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
rewardAmount2 = amount2 * 10 ** 18 * rewardPercent / price / 100

IRs:
TMP_10(uint256) = 10 ** 18
TMP_11(uint256) = amount2 * TMP_10
TMP_12(uint256) = TMP_11 * rewardPercent
TMP_13(uint256) = TMP_12 / price
TMP_14(uint256) = TMP_13 / 100
rewardAmount2(uint256) := TMP_14(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokenReward.transfer(msg.sender,rewardAmount2)

IRs:
HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['msg.sender', 'rewardAmount2']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
RewardToken(msg.sender,rewardAmount2,rewardPercent)

IRs:
Emit RewardToken(msg.sender,rewardAmount2,rewardPercent)""];
8->17;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
amount = msg.value

IRs:
amount(uint256) := msg.value(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
balanceOf[msg.sender] += amount

IRs:
REF_4(uint256) -> balanceOf[msg.sender]
REF_4(-> balanceOf) = REF_4 + amount""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
amountRaised += amount

IRs:
amountRaised(uint256) = amountRaised + amount""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
percentOf[msg.sender] = percent

IRs:
REF_5(uint256) -> percentOf[msg.sender]
REF_5(uint256) (->percentOf) := percent(uint256)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
rewardAmount = amount * 10 ** 18 * percent / price / 100

IRs:
TMP_17(uint256) = 10 ** 18
TMP_18(uint256) = amount * TMP_17
TMP_19(uint256) = TMP_18 * percent
TMP_20(uint256) = TMP_19 / price
TMP_21(uint256) = TMP_20 / 100
rewardAmount(uint256) := TMP_21(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
tokenReward.transfer(msg.sender,rewardAmount)

IRs:
HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['msg.sender', 'rewardAmount']  ""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
FundTransfer(msg.sender,amount,true)

IRs:
Emit FundTransfer(msg.sender,amount,True)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
RewardToken(msg.sender,rewardAmount,percent)

IRs:
Emit RewardToken(msg.sender,rewardAmount,percent)""];
16->17;
17[label=""Node Type: END_IF 17
""];
}
",0,1,0,0,"crowdsaleClosed;amount2 = balanceOf[msg.sender];amount = msg.value;rewardPercent = percent - percentOf[msg.sender];require(bool)(amount2 > 0 && rewardPercent > 0);percentOf[msg.sender] = percent;rewardAmount2 = amount2 * 10 ** 18 * rewardPercent / price / 100;tokenReward.transfer(msg.sender,rewardAmount2);RewardToken(msg.sender,rewardAmount2,rewardPercent);;balanceOf[msg.sender] += amount;amountRaised += amount;percentOf[msg.sender] = percent;rewardAmount = amount * 10 ** 18 * percent / price / 100;tokenReward.transfer(msg.sender,rewardAmount);FundTransfer(msg.sender,amount,true);RewardToken(msg.sender,rewardAmount,percent)"
./0x52ccb8ebb0f55a592ce67dd49249f6cb0c64a129_ext.sol,Globglogabgalab.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xed2725cdfc48a24aa71d9b9621d431db0705a55a_ext.sol,Milestones.Milestone_BankLicenseSuccessful,752,756,"tradingOpen(bool) := True(bool),REF_133(Milestones.State) -> State.BankLicenseSuccessful,state(Milestones.State) := REF_133(Milestones.State),Emit Milestone(_announcement,state),MODIFIER_CALL, Ownable.onlyOwner()(),REF_134(Milestones.State) -> State.IcoSuccessful,MODIFIER_CALL, Milestones.inState(Milestones.State)(REF_134)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
tradingOpen = true

IRs:
tradingOpen(bool) := True(bool)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
state = State.BankLicenseSuccessful

IRs:
REF_133(Milestones.State) -> State.BankLicenseSuccessful
state(Milestones.State) := REF_133(Milestones.State)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Milestone(_announcement,state)

IRs:
Emit Milestone(_announcement,state)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
inState(State.IcoSuccessful)

IRs:
REF_134(Milestones.State) -> State.IcoSuccessful
MODIFIER_CALL, Milestones.inState(Milestones.State)(REF_134)""];
5->1;
}
",0,1,0,0,"onlyOwner();tradingOpen = true;state = State.BankLicenseSuccessful;Milestone(_announcement,state);inState(State.IcoSuccessful)"
./0xde0f4df545910f0ce9bbdaf3eeb929705b8a9de0_ext.sol,TokenERC20.approveAndCall,177,186,"TMP_64 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_64(tokenRecipient),TMP_65(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value),CONDITION TMP_65,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_64 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_64(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_65(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value)
CONDITION TMP_65""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x6de20d9d444354ff9b271a6ea6f9274f2467df35_ext.sol,Rollback.setCredit,159,167,"totalSetCredit(uint256) = totalSetCredit + _amount,REF_2(Rollback.Credit) -> credits[_account],REF_3(uint128) -> REF_2.total,totalSetCredit(uint256) = totalSetCredit - REF_3,REF_4(Rollback.Credit) -> credits[_account],REF_5(uint128) -> REF_4.total,TMP_37(uint128) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.toUINT128(uint256), arguments:['_amount'] ,REF_5(uint128) (->credits) := TMP_37(uint128),REF_7(Rollback.Credit) -> credits[_account],REF_8(uint128) -> REF_7.total,REF_9(Rollback.Credit) -> credits[_account],REF_10(uint128) -> REF_9.used,TMP_38(bool) = REF_8 >= REF_10,TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38),Emit onSetCredit(_account,_amount),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
totalSetCredit += _amount

IRs:
totalSetCredit(uint256) = totalSetCredit + _amount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSetCredit -= credits[_account].total

IRs:
REF_2(Rollback.Credit) -> credits[_account]
REF_3(uint128) -> REF_2.total
totalSetCredit(uint256) = totalSetCredit - REF_3""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
credits[_account].total = _amount.toUINT128()

IRs:
REF_4(Rollback.Credit) -> credits[_account]
REF_5(uint128) -> REF_4.total
TMP_37(uint128) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.toUINT128(uint256), arguments:['_amount'] 
REF_5(uint128) (->credits) := TMP_37(uint128)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(credits[_account].total >= credits[_account].used)

IRs:
REF_7(Rollback.Credit) -> credits[_account]
REF_8(uint128) -> REF_7.total
REF_9(Rollback.Credit) -> credits[_account]
REF_10(uint128) -> REF_9.used
TMP_38(bool) = REF_8 >= REF_10
TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onSetCredit(_account,_amount)

IRs:
Emit onSetCredit(_account,_amount)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
6->1;
}
",0,1,0,0,"onlyOwner();totalSetCredit += _amount;totalSetCredit -= credits[_account].total;credits[_account].total = _amount.toUINT128();require(bool)(credits[_account].total >= credits[_account].used);onSetCredit(_account,_amount)"
./0x46cefba4dd7512b2449e1ac4b730bfb7f77d1407_ext.sol,DecentralizedExchangeHotPotato.revoke,112,120,"REF_56(DecentralizedExchangeHotPotato.Order) -> orderBook[_id],REF_57(address) -> REF_56.owner,TMP_46(bool) = msg.sender == REF_57,TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46),REF_58(DecentralizedExchangeHotPotato.Order) -> orderBook[_id],REF_59(uint256) -> REF_58.endTime,TMP_48(bool) = REF_59 <= now,TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48),REF_60(DecentralizedExchangeHotPotato.Order) -> orderBook[_id],REF_61(address) -> REF_60.issuer,TMP_50 = CONVERT REF_61 to Issuer,issuer(Issuer) := TMP_50(Issuer),REF_63(DecentralizedExchangeHotPotato.Order) -> orderBook[_id],REF_64(uint256) -> REF_63.tokenId,HIGH_LEVEL_CALL, dest:issuer(Issuer), function:transfer, arguments:['msg.sender', 'REF_64']  ,REF_65(DecentralizedExchangeHotPotato.Order) -> orderBook[_id],TMP_52(uint256) = orderBookSize - 1,REF_66(DecentralizedExchangeHotPotato.Order) -> orderBook[TMP_52],REF_65(DecentralizedExchangeHotPotato.Order) (->orderBook) := REF_66(DecentralizedExchangeHotPotato.Order),orderBookSize(uint256) = orderBookSize - 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == orderBook[_id].owner)

IRs:
REF_56(DecentralizedExchangeHotPotato.Order) -> orderBook[_id]
REF_57(address) -> REF_56.owner
TMP_46(bool) = msg.sender == REF_57
TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(orderBook[_id].endTime <= now)

IRs:
REF_58(DecentralizedExchangeHotPotato.Order) -> orderBook[_id]
REF_59(uint256) -> REF_58.endTime
TMP_48(bool) = REF_59 <= now
TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
issuer = Issuer(orderBook[_id].issuer)

IRs:
REF_60(DecentralizedExchangeHotPotato.Order) -> orderBook[_id]
REF_61(address) -> REF_60.issuer
TMP_50 = CONVERT REF_61 to Issuer
issuer(Issuer) := TMP_50(Issuer)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
issuer.transfer(msg.sender,orderBook[_id].tokenId)

IRs:
REF_63(DecentralizedExchangeHotPotato.Order) -> orderBook[_id]
REF_64(uint256) -> REF_63.tokenId
HIGH_LEVEL_CALL, dest:issuer(Issuer), function:transfer, arguments:['msg.sender', 'REF_64']  ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
orderBook[_id] = orderBook[orderBookSize - 1]

IRs:
REF_65(DecentralizedExchangeHotPotato.Order) -> orderBook[_id]
TMP_52(uint256) = orderBookSize - 1
REF_66(DecentralizedExchangeHotPotato.Order) -> orderBook[TMP_52]
REF_65(DecentralizedExchangeHotPotato.Order) (->orderBook) := REF_66(DecentralizedExchangeHotPotato.Order)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
orderBookSize -= 1

IRs:
orderBookSize(uint256) = orderBookSize - 1""];
}
",1,1,0,0,"require(bool)(msg.sender == orderBook[_id].owner);require(bool)(orderBook[_id].endTime <= now);issuer = Issuer(orderBook[_id].issuer);issuer.transfer(msg.sender,orderBook[_id].tokenId);orderBook[_id] = orderBook[orderBookSize - 1];orderBookSize -= 1"
./0xb619e84adddd3e336c5dda1e1b40719c846d9030_ext.sol,WorldByEth.update,103,121,"TMP_32(bool) = now > timeleft,CONDITION TMP_32,REF_47(uint256) -> pot_[rID_],TMP_33(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_47', '6'] ,TMP_34(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_33', '10'] ,Transfer dest:lastplayer value:TMP_34,lastwinner(address) := lastplayer(address),REF_50(uint256) -> pot_[rID_],TMP_36(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['REF_50', '10'] ,com_(uint256) = com_ + TMP_36,TMP_37(uint256) = rID_ + 1,REF_52(uint256) -> pot_[TMP_37],REF_53(uint256) -> pot_[rID_],TMP_38(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_53', '3'] ,TMP_39(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_38', '10'] ,REF_52(-> pot_) = REF_52 + TMP_39,TMP_40(uint256) = now + 86400,timeleft(uint256) := TMP_40(uint256),RETURN False,timeleft(uint256) = timeleft + gap,TMP_41(uint256) = now + 86400,TMP_42(bool) = timeleft > TMP_41,CONDITION TMP_42,TMP_43(uint256) = now + 86400,timeleft(uint256) := TMP_43(uint256),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
now > timeleft

IRs:
TMP_32(bool) = now > timeleft
CONDITION TMP_32""];
1->2[label=""True""];
1->8[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
lastplayer.transfer(pot_[rID_].mul(6).div(10))

IRs:
REF_47(uint256) -> pot_[rID_]
TMP_33(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_47', '6'] 
TMP_34(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_33', '10'] 
Transfer dest:lastplayer value:TMP_34""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
lastwinner = lastplayer

IRs:
lastwinner(address) := lastplayer(address)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
com_ += pot_[rID_].div(10)

IRs:
REF_50(uint256) -> pot_[rID_]
TMP_36(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['REF_50', '10'] 
com_(uint256) = com_ + TMP_36""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
pot_[rID_ + 1] += pot_[rID_].mul(3).div(10)

IRs:
TMP_37(uint256) = rID_ + 1
REF_52(uint256) -> pot_[TMP_37]
REF_53(uint256) -> pot_[rID_]
TMP_38(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_53', '3'] 
TMP_39(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_38', '10'] 
REF_52(-> pot_) = REF_52 + TMP_39""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
timeleft = now + 86400

IRs:
TMP_40(uint256) = now + 86400
timeleft(uint256) := TMP_40(uint256)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
timeleft += gap

IRs:
timeleft(uint256) = timeleft + gap""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
timeleft > now + 86400

IRs:
TMP_41(uint256) = now + 86400
TMP_42(bool) = timeleft > TMP_41
CONDITION TMP_42""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
timeleft = now + 86400

IRs:
TMP_43(uint256) = now + 86400
timeleft(uint256) := TMP_43(uint256)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: RETURN 13

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,now > timeleft;lastplayer.transfer(pot_[rID_].mul(6).div(10));;lastwinner = lastplayer;com_ += pot_[rID_].div(10);pot_[rID_ + 1] += pot_[rID_].mul(3).div(10);timeleft = now + 86400;false;timeleft += gap;timeleft > now + 86400;timeleft = now + 86400;;true
./0x70538834e68efe5061a11c4999fc050e55ae2b68_ext.sol,AYA.totalSupply,125,127,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0xce78ab22cd0331a52af7bb4b622edfa792819d47_ext.sol,RUDAWORLD.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x6d3543d4b11683847697f5b9a3a9d116cf13dedd_ext.sol,Bankrollable.bankrollAvailable,559,573,"TMP_136 = CONVERT this to address,TMP_137(uint256) = SOLIDITY_CALL balance(address)(TMP_136),_balance(uint256) := TMP_137(uint256),_bankroll(uint256) := bankroll(uint256),TMP_138(uint256) = INTERNAL_CALL, Bankrollable.getCollateral()(),_collat(uint256) := TMP_138(uint256),TMP_139(bool) = _balance <= _collat,CONDITION TMP_139,RETURN 0,TMP_140(uint256) = _collat + _bankroll,TMP_141(bool) = _balance < TMP_140,CONDITION TMP_141,TMP_142(uint256) = _balance - _collat,RETURN TMP_142,RETURN _bankroll,RETURN _amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_balance = address(this).balance

IRs:
TMP_136 = CONVERT this to address
TMP_137(uint256) = SOLIDITY_CALL balance(address)(TMP_136)
_balance(uint256) := TMP_137(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
_bankroll = bankroll

IRs:
_bankroll(uint256) := bankroll(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
_collat = getCollateral()

IRs:
TMP_138(uint256) = INTERNAL_CALL, Bankrollable.getCollateral()()
_collat(uint256) := TMP_138(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
_balance <= _collat

IRs:
TMP_139(bool) = _balance <= _collat
CONDITION TMP_139""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: RETURN 5

EXPRESSION:
0

IRs:
RETURN 0""];
6[label=""Node Type: IF 6

EXPRESSION:
_balance < _collat + _bankroll

IRs:
TMP_140(uint256) = _collat + _bankroll
TMP_141(bool) = _balance < TMP_140
CONDITION TMP_141""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: RETURN 7

EXPRESSION:
_balance - _collat

IRs:
TMP_142(uint256) = _balance - _collat
RETURN TMP_142""];
8[label=""Node Type: RETURN 8

EXPRESSION:
_bankroll

IRs:
RETURN _bankroll""];
11[label=""Node Type: RETURN 11

EXPRESSION:
_amount

IRs:
RETURN _amount""];
}
",0,1,0,0,_balance = address(this).balance;_bankroll = bankroll;_collat = getCollateral();_balance <= _collat;0;_balance < _collat + _bankroll;_balance - _collat;_bankroll;_amount
./0xf265534f967d29190c995314190aa2275f710af5_ext.sol,MHT.transferFrom,36,46,"REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],allowance(uint256) := REF_5(uint256),REF_6(uint256) -> balances[_from],TMP_3(bool) = REF_6 >= _value,TMP_4(bool) = allowance >= _value,TMP_5(bool) = TMP_3 && TMP_4,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_7(uint256) -> balances[_to],REF_7(-> balances) = REF_7 + _value,REF_8(uint256) -> balances[_from],REF_8(-> balances) = REF_8 - _value,TMP_7(bool) = allowance < MAX_UINT256,CONDITION TMP_7,REF_9(mapping(address => uint256)) -> allowed[_from],REF_10(uint256) -> REF_9[msg.sender],REF_10(-> allowed) = REF_10 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
allowance = allowed[_from][msg.sender]

IRs:
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
allowance(uint256) := REF_5(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] >= _value && allowance >= _value)

IRs:
REF_6(uint256) -> balances[_from]
TMP_3(bool) = REF_6 >= _value
TMP_4(bool) = allowance >= _value
TMP_5(bool) = TMP_3 && TMP_4
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_7(uint256) -> balances[_to]
REF_7(-> balances) = REF_7 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] -= _value

IRs:
REF_8(uint256) -> balances[_from]
REF_8(-> balances) = REF_8 - _value""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
allowance < MAX_UINT256

IRs:
TMP_7(bool) = allowance < MAX_UINT256
CONDITION TMP_7""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_9(mapping(address => uint256)) -> allowed[_from]
REF_10(uint256) -> REF_9[msg.sender]
REF_10(-> allowed) = REF_10 - _value""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: RETURN 10

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowance = allowed[_from][msg.sender];require(bool)(balances[_from] >= _value && allowance >= _value);balances[_to] += _value;balances[_from] -= _value;allowance < MAX_UINT256;allowed[_from][msg.sender] -= _value;;Transfer(_from,_to,_value);true;success"
./0x6b27bfd273ec79a64a62b4b3a18a89045c2389b1_ext.sol,TokenERC20.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x461d558429cb87a5faf967a4333d671b7a97c04f_ext.sol,BOBOToken.totalSupply,114,116,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x651a824c225e60c1901ec6018a685aa38d82f23c_ext.sol,PimmelToken.burn,84,90,"REF_13(uint256) -> balanceOf[msg.sender],TMP_15(bool) = REF_13 > _value,TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15),REF_14(uint256) -> balanceOf[msg.sender],REF_14(-> balanceOf) = REF_14 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] > _value)

IRs:
REF_13(uint256) -> balanceOf[msg.sender]
TMP_15(bool) = REF_13 > _value
TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_14(uint256) -> balanceOf[msg.sender]
REF_14(-> balanceOf) = REF_14 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] > _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xa2dfd314cb3fcf821300a2e518469b6544ad6a84_ext.sol,threeZZZToken.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xed04927a3849fc9db3f3341a17b7d844a6c551a8_ext.sol,CrowdInvestment.addPersonalCaps,40,45,"TMP_11(bool) = msg.sender == creator,TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11),i(uint16) := 0(uint256),REF_4 -> LENGTH investors,TMP_13(bool) = i < REF_4,CONDITION TMP_13,REF_5(address) -> investors[i],REF_6(uint256) -> additionalCaps[REF_5],REF_6(-> additionalCaps) = REF_6 + additionalCap,TMP_14(uint16) := i(uint16),i(uint16) = i + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == creator)

IRs:
TMP_11(bool) = msg.sender == creator
TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint16) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < investors.length

IRs:
REF_4 -> LENGTH investors
TMP_13(bool) = i < REF_4
CONDITION TMP_13""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
additionalCaps[investors[i]] += additionalCap

IRs:
REF_5(address) -> investors[i]
REF_6(uint256) -> additionalCaps[REF_5]
REF_6(-> additionalCaps) = REF_6 + additionalCap""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_14(uint16) := i(uint16)
i(uint16) = i + 1""];
7->5;
}
",0,1,0,0,require(bool)(msg.sender == creator);i = 0;;i < investors.length;;additionalCaps[investors[i]] += additionalCap;i ++
./0x0f08bdc02fb681462cb6c73b6b351297692aa6e4_ext.sol,XRUN.mintToken,167,174,"REF_59(uint256) -> balanceOf[target],REF_59(-> balanceOf) = REF_59 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,TMP_86 = CONVERT 0 to address,TMP_87 = CONVERT this to address,Emit Transfer(TMP_86,TMP_87,mintedAmount),TMP_89 = CONVERT this to address,Emit Transfer(TMP_89,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_59(uint256) -> balanceOf[target]
REF_59(-> balanceOf) = REF_59 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(address(0),address(this),mintedAmount)

IRs:
TMP_86 = CONVERT 0 to address
TMP_87 = CONVERT this to address
Emit Transfer(TMP_86,TMP_87,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(address(this),target,mintedAmount)

IRs:
TMP_89 = CONVERT this to address
Emit Transfer(TMP_89,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(address(0),address(this),mintedAmount);Transfer(address(this),target,mintedAmount)"
./0x18373e7b8bd24ecb0af8e9c95548360ef787b781_ext.sol,ShareToken.lockRewardTokenMany,371,377,"i(uint256) := 0(uint256),REF_90 -> LENGTH addrList,TMP_185(bool) = i < REF_90,CONDITION TMP_185,REF_91(address) -> addrList[i],INTERNAL_CALL, ShareToken.lockRewardToken(address)(REF_91),TMP_187(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addrList.length

IRs:
REF_90 -> LENGTH addrList
TMP_185(bool) = i < REF_90
CONDITION TMP_185""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
lockRewardToken(addrList[i])

IRs:
REF_91(address) -> addrList[i]
INTERNAL_CALL, ShareToken.lockRewardToken(address)(REF_91)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_187(uint256) := i(uint256)
i(uint256) = i + 1""];
6->4;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->3;
}
",0,1,0,0,onlyOwner();;i < addrList.length;;i = 0;lockRewardToken(addrList[i]);i ++
./0xb459571c4d5b8119ab76d0a5308106c61f9918c5_ext.sol,StandardToken.transferFrom,54,64,"REF_3(uint256) -> balances[_from],TMP_18(bool) = REF_3 >= _value,REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],TMP_19(bool) = REF_5 >= _value,TMP_20(bool) = TMP_18 && TMP_19,TMP_21(bool) = _value > 0,TMP_22(bool) = TMP_20 && TMP_21,CONDITION TMP_22,REF_6(uint256) -> balances[_to],REF_6(-> balances) = REF_6 + _value,REF_7(uint256) -> balances[_from],REF_7(-> balances) = REF_7 - _value,REF_8(mapping(address => uint256)) -> allowed[_from],REF_9(uint256) -> REF_8[msg.sender],REF_9(-> allowed) = REF_9 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0

IRs:
REF_3(uint256) -> balances[_from]
TMP_18(bool) = REF_3 >= _value
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
TMP_19(bool) = REF_5 >= _value
TMP_20(bool) = TMP_18 && TMP_19
TMP_21(bool) = _value > 0
TMP_22(bool) = TMP_20 && TMP_21
CONDITION TMP_22""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_6(uint256) -> balances[_to]
REF_6(-> balances) = REF_6 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_7(uint256) -> balances[_from]
REF_7(-> balances) = REF_7 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_8(mapping(address => uint256)) -> allowed[_from]
REF_9(uint256) -> REF_8[msg.sender]
REF_9(-> allowed) = REF_9 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0;balances[_to] += _value;false;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true;success"
./0x409694d12ab1ee7cf7f45245aec9197644660683_ext.sol,BNB.approveAndCall,204,209,"REF_18(mapping(address => uint256)) -> allowed[msg.sender],REF_19(uint256) -> REF_18[spender],REF_19(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_18(mapping(address => uint256)) -> allowed[msg.sender]
REF_19(uint256) -> REF_18[spender]
REF_19(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x8bbb3375d2401da181711032f658c52252b03275_ext.sol,online_wallet.withdraw,13,21,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2),TMP_4(bool) = keyHash == TMP_3,CONDITION TMP_4,TMP_5(bool) = msg.value > 400000000000000000,CONDITION TMP_5,TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),Transfer dest:msg.sender value:TMP_7","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
keyHash == keccak256()(abi.encodePacked(key))

IRs:
TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2)
TMP_4(bool) = keyHash == TMP_3
CONDITION TMP_4""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
msg.value > 400000000000000000

IRs:
TMP_5(bool) = msg.value > 400000000000000000
CONDITION TMP_5""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
Transfer dest:msg.sender value:TMP_7""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,1,0,0,require(bool)(msg.sender == tx.origin);keyHash == keccak256()(abi.encodePacked(key));msg.value > 400000000000000000;;msg.sender.transfer(address(this).balance);
./0x456c4350eefd17315713b265d8be8b6063a5fab8_ext.sol,Crowdsale.getRemainCoins,380,396,"TMP_149(uint256) = MAX_CAP - coinSentToEther,remains(uint256) := TMP_149(uint256),TMP_150(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['MIN_INVEST_ETHER', 'COIN_PER_ETHER'] ,TMP_151(uint256) = TMP_150 / 1000000000000000000,TMP_152(uint256) = INTERNAL_CALL, Crowdsale.bonus(uint256)(TMP_151),minCoinsToSell(uint256) := TMP_152(uint256),TMP_153(bool) = remains > minCoinsToSell,CONDITION TMP_153,REF_101(Crowdsale.Backer) -> backers[owner],backer(Crowdsale.Backer) := REF_101(Crowdsale.Backer),HIGH_LEVEL_CALL, dest:coin(SggCoin), function:transfer, arguments:['owner', 'remains']  ,REF_103(uint256) -> backer.coinSent,REF_104(uint256) -> backer.coinSent,TMP_155(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_104', 'remains'] ,REF_103(uint256) (->backer) := TMP_155(uint256),TMP_156(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['coinSentToEther', 'remains'] ,coinSentToEther(uint256) := TMP_156(uint256),Emit LogCoinsEmited(this,remains),Emit LogReceivedETH(owner,etherReceived),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
remains = MAX_CAP - coinSentToEther

IRs:
TMP_149(uint256) = MAX_CAP - coinSentToEther
remains(uint256) := TMP_149(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
minCoinsToSell = bonus(MIN_INVEST_ETHER.mul(COIN_PER_ETHER) / (1000000000000000000))

IRs:
TMP_150(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['MIN_INVEST_ETHER', 'COIN_PER_ETHER'] 
TMP_151(uint256) = TMP_150 / 1000000000000000000
TMP_152(uint256) = INTERNAL_CALL, Crowdsale.bonus(uint256)(TMP_151)
minCoinsToSell(uint256) := TMP_152(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
remains > minCoinsToSell

IRs:
TMP_153(bool) = remains > minCoinsToSell
CONDITION TMP_153""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: THROW 4
""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
backer = backers[owner]

IRs:
REF_101(Crowdsale.Backer) -> backers[owner]
backer(Crowdsale.Backer) := REF_101(Crowdsale.Backer)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
coin.transfer(owner,remains)

IRs:
HIGH_LEVEL_CALL, dest:coin(SggCoin), function:transfer, arguments:['owner', 'remains']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
backer.coinSent = backer.coinSent.add(remains)

IRs:
REF_103(uint256) -> backer.coinSent
REF_104(uint256) -> backer.coinSent
TMP_155(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_104', 'remains'] 
REF_103(uint256) (->backer) := TMP_155(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
coinSentToEther = coinSentToEther.add(remains)

IRs:
TMP_156(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['coinSentToEther', 'remains'] 
coinSentToEther(uint256) := TMP_156(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
LogCoinsEmited(this,remains)

IRs:
Emit LogCoinsEmited(this,remains)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
LogReceivedETH(owner,etherReceived)

IRs:
Emit LogReceivedETH(owner,etherReceived)""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
12->1;
}
",0,1,0,0,"onlyOwner();remains = MAX_CAP - coinSentToEther;minCoinsToSell = bonus(MIN_INVEST_ETHER.mul(COIN_PER_ETHER) / (1000000000000000000));remains > minCoinsToSell;;;backer = backers[owner];coin.transfer(owner,remains);backer.coinSent = backer.coinSent.add(remains);coinSentToEther = coinSentToEther.add(remains);LogCoinsEmited(this,remains);LogReceivedETH(owner,etherReceived)"
./0x06779e2a75cc5b7ad2c14cf98d88cf2cfcfcc6f1_ext.sol,lucky9io.pickWinners,69,97,"TMP_23(bool) = entries_count > 0,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),i(uint256) := 0(uint256),TMP_25(bool) = i < entries_count,CONDITION TMP_25,TMP_26(uint256) = i + random_seed,REF_11(address) -> entries_addresses[i],TMP_27 = CONVERT REF_11 to uint256,TMP_28(uint256) = TMP_26 + TMP_27,TMP_29(uint256) = SOLIDITY_CALL blockhash(uint256)(block.number),TMP_30(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_28,TMP_29),REF_12(bytes32) -> entries_blockhash[i],TMP_31(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_30,REF_12),TMP_32(bytes32) = SOLIDITY_CALL keccak256()(TMP_31),TMP_33 = CONVERT TMP_32 to uint256,lucky_number(uint256) := TMP_33(uint256),TMP_34(uint256) = lucky_number % 99,TMP_35(uint256) = TMP_34 % 9,TMP_36(uint256) = TMP_35 % 3,TMP_37(bool) = TMP_36 == 1,CONDITION TMP_37,TMP_38(uint256) = jackpot * 30,TMP_39(uint256) = TMP_38 / 100,win_amount(uint256) := TMP_39(uint256),TMP_40 = CONVERT this to address,TMP_41(uint256) = SOLIDITY_CALL balance(address)(TMP_40),TMP_42(uint256) = TMP_41 - house_edge,TMP_43(bool) = TMP_42 < win_amount,CONDITION TMP_43,TMP_44 = CONVERT this to address,TMP_45(uint256) = SOLIDITY_CALL balance(address)(TMP_44),TMP_46(uint256) = TMP_45 - house_edge,TMP_47(uint256) = TMP_46 * 30,TMP_48(uint256) = TMP_47 / 100,win_amount(uint256) := TMP_48(uint256),TMP_49(uint256) = jackpot - win_amount,jackpot(uint256) := TMP_49(uint256),TMP_50(uint256) = total_wins_count + 1,total_wins_count(uint256) := TMP_50(uint256),TMP_51(uint256) = total_wins_wei + win_amount,total_wins_wei(uint256) := TMP_51(uint256),REF_13(address) -> entries_addresses[i],Transfer dest:REF_13 value:win_amount,TMP_53(uint256) := i(uint256),i(uint256) = i + 1,entries_count(uint256) := 0(uint256),MODIFIER_CALL, lucky9io.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->20;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(entries_count > 0)

IRs:
TMP_23(bool) = entries_count > 0
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
3->18;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < entries_count

IRs:
TMP_25(bool) = i < entries_count
CONDITION TMP_25""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
lucky_number = uint256(keccak256()(abi.encodePacked(abi.encodePacked(i + random_seed + uint256(entries_addresses[i]),blockhash(uint256)(block.number)),entries_blockhash[i])))

IRs:
TMP_26(uint256) = i + random_seed
REF_11(address) -> entries_addresses[i]
TMP_27 = CONVERT REF_11 to uint256
TMP_28(uint256) = TMP_26 + TMP_27
TMP_29(uint256) = SOLIDITY_CALL blockhash(uint256)(block.number)
TMP_30(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_28,TMP_29)
REF_12(bytes32) -> entries_blockhash[i]
TMP_31(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_30,REF_12)
TMP_32(bytes32) = SOLIDITY_CALL keccak256()(TMP_31)
TMP_33 = CONVERT TMP_32 to uint256
lucky_number(uint256) := TMP_33(uint256)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
((lucky_number % 99) % 9) % 3 == 1

IRs:
TMP_34(uint256) = lucky_number % 99
TMP_35(uint256) = TMP_34 % 9
TMP_36(uint256) = TMP_35 % 3
TMP_37(bool) = TMP_36 == 1
CONDITION TMP_37""];
7->8[label=""True""];
7->16[label=""False""];
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
win_amount = jackpot * 30 / 100

IRs:
TMP_38(uint256) = jackpot * 30
TMP_39(uint256) = TMP_38 / 100
win_amount(uint256) := TMP_39(uint256)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
address(this).balance - house_edge < win_amount

IRs:
TMP_40 = CONVERT this to address
TMP_41(uint256) = SOLIDITY_CALL balance(address)(TMP_40)
TMP_42(uint256) = TMP_41 - house_edge
TMP_43(bool) = TMP_42 < win_amount
CONDITION TMP_43""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
win_amount = (address(this).balance - house_edge) * 30 / 100

IRs:
TMP_44 = CONVERT this to address
TMP_45(uint256) = SOLIDITY_CALL balance(address)(TMP_44)
TMP_46(uint256) = TMP_45 - house_edge
TMP_47(uint256) = TMP_46 * 30
TMP_48(uint256) = TMP_47 / 100
win_amount(uint256) := TMP_48(uint256)""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
jackpot = jackpot - win_amount

IRs:
TMP_49(uint256) = jackpot - win_amount
jackpot(uint256) := TMP_49(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
total_wins_count = total_wins_count + 1

IRs:
TMP_50(uint256) = total_wins_count + 1
total_wins_count(uint256) := TMP_50(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
total_wins_wei = total_wins_wei + win_amount

IRs:
TMP_51(uint256) = total_wins_wei + win_amount
total_wins_wei(uint256) := TMP_51(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
entries_addresses[i].transfer(win_amount)

IRs:
REF_13(address) -> entries_addresses[i]
Transfer dest:REF_13 value:win_amount""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
i ++

IRs:
TMP_53(uint256) := i(uint256)
i(uint256) = i + 1""];
17->5;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
entries_count = 0

IRs:
entries_count(uint256) := 0(uint256)""];
18->19;
19[label=""Node Type: RETURN 19
""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, lucky9io.onlyOwner()()""];
20->1;
}
",0,1,0,0,"onlyOwner();require(bool)(entries_count > 0);i = 0;;i < entries_count;;entries_count = 0;lucky_number = uint256(keccak256()(abi.encodePacked(abi.encodePacked(i + random_seed + uint256(entries_addresses[i]),blockhash(uint256)(block.number)),entries_blockhash[i])));((lucky_number % 99) % 9) % 3 == 1;win_amount = jackpot * 30 / 100;;address(this).balance - house_edge < win_amount;win_amount = (address(this).balance - house_edge) * 30 / 100;;jackpot = jackpot - win_amount;total_wins_count = total_wins_count + 1;total_wins_wei = total_wins_wei + win_amount;entries_addresses[i].transfer(win_amount);i ++;"
./0x17c8d8b7659141273a1c2223030c89b96713a44a_ext.sol,XPS.burnFrom,141,149,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x704079e823e42a936bbaac5163434c2515473836_ext.sol,CONUNDRUM.StartGame,12,22,"TMP_0(bool) = responseHash == 0,CONDITION TMP_0,TMP_1(bytes32) = SOLIDITY_CALL keccak256()(_response),responseHash(bytes32) := TMP_1(bytes32),question(string) := _question(string),questionSender(address) := msg.sender(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
responseHash == 0x0

IRs:
TMP_0(bool) = responseHash == 0
CONDITION TMP_0""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
responseHash = keccak256()(_response)

IRs:
TMP_1(bytes32) = SOLIDITY_CALL keccak256()(_response)
responseHash(bytes32) := TMP_1(bytes32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
questionSender = msg.sender

IRs:
questionSender(address) := msg.sender(address)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,1,0,0,responseHash == 0x0;responseHash = keccak256()(_response);;question = _question;questionSender = msg.sender
./0xd4d8c546549719f0e79a0b11d624a52859c111d7_ext.sol,TokenERC20.burn,128,134,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xee522a9bbe2507546aec572cea7be0f250cba0cb_ext.sol,CentaToken.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x3ac96bbe8b60d715fd818b3fe242edf9def20571_ext.sol,MyBoToken.mintToken,139,144,"REF_52(uint256) -> balanceOf[target],REF_52(-> balanceOf) = REF_52 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_52(uint256) -> balanceOf[target]
REF_52(-> balanceOf) = REF_52 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0xdca82e4dfbce4442b19a85df47fd64aeaaf55d9f_ext.sol,RouletteRules.getBetResult,22,34,"i(uint256) := 0(uint256),TMP_10(bool) = i < 32,CONDITION TMP_10,TMP_11(bool) = i < 16,CONDITION TMP_11,TMP_12(uint256) = i * 16,TMP_13(uint256) = 240 - TMP_12,TMP_14(bytes32) = first16 >> TMP_13,TMP_15(bytes32) = TMP_14 & 65535,TMP_16 = CONVERT TMP_15 to uint256,a(uint256) := TMP_16(uint256),TMP_17(uint256) = i - 16,TMP_18(uint256) = TMP_17 * 16,TMP_19(uint256) = 240 - TMP_18,TMP_20(bytes32) = second16 >> TMP_19,TMP_21(bytes32) = TMP_20 & 65535,TMP_22 = CONVERT TMP_21 to uint256,a(uint256) := TMP_22(uint256),TMP_23(bool) = a == 0,CONDITION TMP_23,TMP_24(uint256) = wheelResult * 157,REF_0(None) -> betTypes[i],TMP_25 = CONVERT REF_0 to uint256,TMP_26(uint256) = TMP_24 + TMP_25,REF_1(uint8) -> payoutTable[TMP_26],TMP_27(uint256) = a * REF_1,wonAmount(uint256) = wonAmount + TMP_27,TMP_28(uint256) := i(uint256),i(uint256) = i + 1,RETURN wonAmount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
3->15;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < 32

IRs:
TMP_10(bool) = i < 32
CONDITION TMP_10""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: IF 6

EXPRESSION:
i < 16

IRs:
TMP_11(bool) = i < 16
CONDITION TMP_11""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
a = uint256(first16 >> (240 - i * 16) & 0xffff)

IRs:
TMP_12(uint256) = i * 16
TMP_13(uint256) = 240 - TMP_12
TMP_14(bytes32) = first16 >> TMP_13
TMP_15(bytes32) = TMP_14 & 65535
TMP_16 = CONVERT TMP_15 to uint256
a(uint256) := TMP_16(uint256)""];
7->9;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
a = uint256(second16 >> (240 - (i - 16) * 16) & 0xffff)

IRs:
TMP_17(uint256) = i - 16
TMP_18(uint256) = TMP_17 * 16
TMP_19(uint256) = 240 - TMP_18
TMP_20(bytes32) = second16 >> TMP_19
TMP_21(bytes32) = TMP_20 & 65535
TMP_22 = CONVERT TMP_21 to uint256
a(uint256) := TMP_22(uint256)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
a == 0

IRs:
TMP_23(bool) = a == 0
CONDITION TMP_23""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: BREAK 11
""];
11->3;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
wonAmount += a * payoutTable[wheelResult * 157 + uint256(betTypes[i])]

IRs:
TMP_24(uint256) = wheelResult * 157
REF_0(None) -> betTypes[i]
TMP_25 = CONVERT REF_0 to uint256
TMP_26(uint256) = TMP_24 + TMP_25
REF_1(uint8) -> payoutTable[TMP_26]
TMP_27(uint256) = a * REF_1
wonAmount(uint256) = wonAmount + TMP_27""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
i ++

IRs:
TMP_28(uint256) := i(uint256)
i(uint256) = i + 1""];
14->5;
15[label=""Node Type: RETURN 15

EXPRESSION:
wonAmount

IRs:
RETURN wonAmount""];
}
",0,1,0,0,;i = 0;;i < 32;;wonAmount;i < 16;a = uint256(first16 >> (240 - i * 16) & 0xffff);a = uint256(second16 >> (240 - (i - 16) * 16) & 0xffff);;a == 0;;;wonAmount += a * payoutTable[wheelResult * 157 + uint256(betTypes[i])];i ++
./0x089b85fa15f72c1088cbbef23a49db80b91dd521_ext.sol,BlockEstateToken.burn,77,83,"REF_21(uint256) -> balances[msg.sender],TMP_15(bool) = REF_21 < _value,CONDITION TMP_15,RETURN False,REF_22(uint256) -> balances[msg.sender],REF_22(-> balances) = REF_22 - _value,_totalSupply(uint256) = _totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[msg.sender] < _value

IRs:
REF_21(uint256) -> balances[msg.sender]
TMP_15(bool) = REF_21 < _value
CONDITION TMP_15""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_22(uint256) -> balances[msg.sender]
REF_22(-> balances) = REF_22 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_totalSupply -= _value

IRs:
_totalSupply(uint256) = _totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[msg.sender] < _value;false;;balances[msg.sender] -= _value;_totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x6cb9c5abf310b42893adff0b1f38322eea109c98_ext.sol,DelightToken.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xdbc36b40a83c86c1b3c24c55a8c0ab32419ae0c0_ext.sol,TokenERC20.approveAndCall,55,61,"TMP_19 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_19(tokenRecipient),TMP_20(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value),CONDITION TMP_20,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_19 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_19(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_20(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value)
CONDITION TMP_20""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x2a8cef60776d931eb1200aa2a9877eb091cb34a7_ext.sol,TTC.admin_transfer,84,91,"REF_18(bool) -> admin_list[msg.sender],TMP_12(None) = SOLIDITY_CALL require(bool)(REF_18),REF_19(uint256) -> balances[_from],TMP_13(bool) = REF_19 >= _value,TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13),REF_20(uint256) -> balances[_from],REF_20(-> balances) = REF_20 - _value,REF_21(uint256) -> balances[_to],REF_21(-> balances) = REF_21 + _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(admin_list[msg.sender])

IRs:
REF_18(bool) -> admin_list[msg.sender]
TMP_12(None) = SOLIDITY_CALL require(bool)(REF_18)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] >= _value)

IRs:
REF_19(uint256) -> balances[_from]
TMP_13(bool) = REF_19 >= _value
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_20(uint256) -> balances[_from]
REF_20(-> balances) = REF_20 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] += _value

IRs:
REF_21(uint256) -> balances[_to]
REF_21(-> balances) = REF_21 + _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(admin_list[msg.sender]);require(bool)(balances[_from] >= _value);balances[_from] -= _value;balances[_to] += _value;Transfer(_from,_to,_value);true;success"
./0x1c3db3898c05d77bd742a219f8f488aac0cb013b_ext.sol,TokenERC20.burn,130,136,"REF_13(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_13 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_14(uint256) -> balanceOf[msg.sender],REF_14(-> balanceOf) = REF_14 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_13(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_13 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_14(uint256) -> balanceOf[msg.sender]
REF_14(-> balanceOf) = REF_14 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xefbfc3f373c9cc5c0375403177d71bcc387d3597_ext.sol,ETH_GIFT.GetHash,33,33,"TMP_5(bytes32) = SOLIDITY_CALL keccak256()(pass),RETURN TMP_5","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
keccak256()(pass)

IRs:
TMP_5(bytes32) = SOLIDITY_CALL keccak256()(pass)
RETURN TMP_5""];
}
",0,1,0,0,keccak256()(pass)
./0x58849d4a250bbb9d47d6cd93c7ab39ab1e06aeda_ext.sol,StandardToken.transferFrom,76,86,"REF_3(uint256) -> balances[_from],TMP_13(bool) = REF_3 >= _value,REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],TMP_14(bool) = REF_5 >= _value,TMP_15(bool) = TMP_13 && TMP_14,TMP_16(bool) = _value > 0,TMP_17(bool) = TMP_15 && TMP_16,CONDITION TMP_17,REF_6(uint256) -> balances[_to],REF_6(-> balances) = REF_6 + _value,REF_7(uint256) -> balances[_from],REF_7(-> balances) = REF_7 - _value,REF_8(mapping(address => uint256)) -> allowed[_from],REF_9(uint256) -> REF_8[msg.sender],REF_9(-> allowed) = REF_9 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0

IRs:
REF_3(uint256) -> balances[_from]
TMP_13(bool) = REF_3 >= _value
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
TMP_14(bool) = REF_5 >= _value
TMP_15(bool) = TMP_13 && TMP_14
TMP_16(bool) = _value > 0
TMP_17(bool) = TMP_15 && TMP_16
CONDITION TMP_17""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_6(uint256) -> balances[_to]
REF_6(-> balances) = REF_6 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_7(uint256) -> balances[_from]
REF_7(-> balances) = REF_7 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_8(mapping(address => uint256)) -> allowed[_from]
REF_9(uint256) -> REF_8[msg.sender]
REF_9(-> allowed) = REF_9 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0;balances[_to] += _value;false;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true;success"
./0x1df6eadc2e1e9f4cbb2d94369210d8f1b790ee19_ext.sol,PinnacleToken.transferFrom,73,84,"REF_5(mapping(address => uint256)) -> allowed[_from],REF_6(uint256) -> REF_5[msg.sender],TMP_17(bool) = REF_6 >= _value,REF_7(uint256) -> balances[_from],TMP_18(bool) = REF_7 >= _value,TMP_19(bool) = TMP_17 && TMP_18,TMP_20(bool) = _value > 0,TMP_21(bool) = TMP_19 && TMP_20,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),REF_8(uint256) -> balances[_from],REF_8(-> balances) = REF_8 - _value,REF_9(uint256) -> balances[_to],REF_9(-> balances) = REF_9 + _value,REF_10(mapping(address => uint256)) -> allowed[_from],REF_11(uint256) -> REF_10[msg.sender],REF_11(-> allowed) = REF_11 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0)

IRs:
REF_5(mapping(address => uint256)) -> allowed[_from]
REF_6(uint256) -> REF_5[msg.sender]
TMP_17(bool) = REF_6 >= _value
REF_7(uint256) -> balances[_from]
TMP_18(bool) = REF_7 >= _value
TMP_19(bool) = TMP_17 && TMP_18
TMP_20(bool) = _value > 0
TMP_21(bool) = TMP_19 && TMP_20
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_from] -= _value

IRs:
REF_8(uint256) -> balances[_from]
REF_8(-> balances) = REF_8 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_9(uint256) -> balances[_to]
REF_9(-> balances) = REF_9 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_10(mapping(address => uint256)) -> allowed[_from]
REF_11(uint256) -> REF_10[msg.sender]
REF_11(-> allowed) = REF_11 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);balances[_from] -= _value;balances[_to] += _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true;success"
./0xc08dcf2fa37b87a89ac7f0fdcb4aebda378dea29_ext.sol,MITToken.burn,167,173,"REF_20(uint256) -> balanceOf[msg.sender],TMP_69(bool) = REF_20 >= _value,TMP_70(None) = SOLIDITY_CALL require(bool)(TMP_69),REF_21(uint256) -> balanceOf[msg.sender],REF_21(-> balanceOf) = REF_21 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_20(uint256) -> balanceOf[msg.sender]
TMP_69(bool) = REF_20 >= _value
TMP_70(None) = SOLIDITY_CALL require(bool)(TMP_69)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_21(uint256) -> balanceOf[msg.sender]
REF_21(-> balanceOf) = REF_21 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x8ce188196892455fb131dea104bc3ba4e8516654_ext.sol,VOCC_I026_20181211.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0xf2d3bee00851fdf205f4fe825fe89d2abff88231_ext.sol,WOB._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x281043fa2101009dc85d98e0fcd538d299f6eb1c_ext.sol,TKCC._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x6e6a00012c2005ca5c75b3ad58baac1a7a8e241f_ext.sol,StandardToken.transferFrom,56,66,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x33555a3130fc40082a566005714eeec369e62fc8_ext.sol,Dividends.GetDivs,215,220,"TMP_196 = CONVERT this to address,TMP_197(uint256) = SOLIDITY_CALL balance(address)(TMP_196),TMP_198(uint256) = TMP_197 + TotalOut,total_volume_in(uint256) := TMP_198(uint256),REF_60(uint256) -> LastBalanceWithdrawn[who],TMP_199(uint256) = INTERNAL_CALL, Dividends.sub(uint256,uint256)(total_volume_in,REF_60),Delta(uint256) := TMP_199(uint256),REF_61(uint256) -> balanceOf[who],TMP_200(uint256) = REF_61 * Delta,TMP_201(uint256) = TMP_200 / totalSupply,Get(uint256) := TMP_201(uint256),RETURN Get","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
total_volume_in = address(this).balance + TotalOut

IRs:
TMP_196 = CONVERT this to address
TMP_197(uint256) = SOLIDITY_CALL balance(address)(TMP_196)
TMP_198(uint256) = TMP_197 + TotalOut
total_volume_in(uint256) := TMP_198(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
Delta = sub(total_volume_in,LastBalanceWithdrawn[who])

IRs:
REF_60(uint256) -> LastBalanceWithdrawn[who]
TMP_199(uint256) = INTERNAL_CALL, Dividends.sub(uint256,uint256)(total_volume_in,REF_60)
Delta(uint256) := TMP_199(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
Get = (balanceOf[who] * Delta) / totalSupply

IRs:
REF_61(uint256) -> balanceOf[who]
TMP_200(uint256) = REF_61 * Delta
TMP_201(uint256) = TMP_200 / totalSupply
Get(uint256) := TMP_201(uint256)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
(Get)

IRs:
RETURN Get""];
}
",0,1,0,0,"total_volume_in = address(this).balance + TotalOut;Delta = sub(total_volume_in,LastBalanceWithdrawn[who]);Get = (balanceOf[who] * Delta) / totalSupply;(Get)"
./0x414b23b9deb0da531384c5db2ac5a99ee2e07a57_ext.sol,TPCToken.burn,49,55,"REF_16(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_16 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_17(uint256) -> balanceOf[msg.sender],REF_17(-> balanceOf) = REF_17 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_16(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_16 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
REF_17(-> balanceOf) = REF_17 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x5438b0938fb88a979032f45b87d2d1aeffe5cc28_ext.sol,Gifto.fallback,118,129,"REF_0(uint256) -> deposit[msg.sender],TMP_0(bool) = REF_0 == 0,TMP_1(bool) = msg.value != 0,TMP_2(bool) = TMP_0 && TMP_1,CONDITION TMP_2,REF_2 -> LENGTH buyers,TMP_4(uint256) := REF_2(uint256),TMP_5(uint256) = TMP_4 + 1,REF_2(uint256) (->buyers) := TMP_5(uint256),REF_3(address) -> buyers[TMP_4],REF_3(address) (->buyers) := msg.sender(address),REF_4(uint256) -> deposit[msg.sender],REF_4(-> deposit) = REF_4 + msg.value,MODIFIER_CALL, Gifto.validValue()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
deposit[msg.sender] == 0 && msg.value != 0

IRs:
REF_0(uint256) -> deposit[msg.sender]
TMP_0(bool) = REF_0 == 0
TMP_1(bool) = msg.value != 0
TMP_2(bool) = TMP_0 && TMP_1
CONDITION TMP_2""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
buyers.push(msg.sender)

IRs:
REF_2 -> LENGTH buyers
TMP_4(uint256) := REF_2(uint256)
TMP_5(uint256) = TMP_4 + 1
REF_2(uint256) (->buyers) := TMP_5(uint256)
REF_3(address) -> buyers[TMP_4]
REF_3(address) (->buyers) := msg.sender(address)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
deposit[msg.sender] += msg.value

IRs:
REF_4(uint256) -> deposit[msg.sender]
REF_4(-> deposit) = REF_4 + msg.value""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
validValue()

IRs:
MODIFIER_CALL, Gifto.validValue()()""];
5->1;
}
",0,1,0,0,validValue();deposit[msg.sender] == 0 && msg.value != 0;buyers.push(msg.sender);;deposit[msg.sender] += msg.value
./0x02b3c88b805f1c6982e38ea1d40a1d83f159c3d4_ext.sol,TokenERC20.burn,146,152,"REF_17(uint256) -> balanceOf[msg.sender],TMP_25(bool) = REF_17 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_25(bool) = REF_17 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xa25d9e3c177a45265349d4bd37b23ec2669dea5b_ext.sol,TokenERC20.burn,287,299,"REF_17(uint256) -> balanceOf[msg.sender],TMP_25(bool) = REF_17 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_25(bool) = REF_17 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x0d09b8d474e312eda0996cb420aa9f5c6b2c1993_ext.sol,ProfytPro.getUsers,58,60,RETURN userAccounts,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
userAccounts

IRs:
RETURN userAccounts""];
}
",0,1,0,0,userAccounts
./0xc0ca7bd6f54341bb871f6106acde6ec4d65c1f91_ext.sol,SarahCoin.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x696be206174bea69e7a00b4deb1c6fddfa4786c9_ext.sol,RAZEN.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x7996f859a313aab6458558c648e2f1f4acbf5f93_ext.sol,HealthAidToken.distributeHAT,73,82,"i(uint256) := 0(uint256),REF_1 -> LENGTH addresses,TMP_2(bool) = i < REF_1,CONDITION TMP_2,REF_2(address) -> addresses[i],TMP_3(uint256) = INTERNAL_CALL, HealthAidToken.getEthBalance(address)(REF_2),TMP_4(bool) = TMP_3 < _ethbal,CONDITION TMP_4,REF_3(uint256) -> balances[owner],REF_3(-> balances) = REF_3 - _value,REF_4(address) -> addresses[i],REF_5(uint256) -> balances[REF_4],REF_5(-> balances) = REF_5 + _value,REF_6(address) -> addresses[i],Emit Transfer(owner,REF_6,_value),TMP_6(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, HealthAidToken.onlyOwner()(),MODIFIER_CALL, HealthAidToken.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addresses.length

IRs:
REF_1 -> LENGTH addresses
TMP_2(bool) = i < REF_1
CONDITION TMP_2""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
getEthBalance(addresses[i]) < _ethbal

IRs:
REF_2(address) -> addresses[i]
TMP_3(uint256) = INTERNAL_CALL, HealthAidToken.getEthBalance(address)(REF_2)
TMP_4(bool) = TMP_3 < _ethbal
CONDITION TMP_4""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: CONTINUE 6
""];
6->11;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[owner] -= _value

IRs:
REF_3(uint256) -> balances[owner]
REF_3(-> balances) = REF_3 - _value""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
balances[addresses[i]] += _value

IRs:
REF_4(address) -> addresses[i]
REF_5(uint256) -> balances[REF_4]
REF_5(-> balances) = REF_5 + _value""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Transfer(owner,addresses[i],_value)

IRs:
REF_6(address) -> addresses[i]
Emit Transfer(owner,REF_6,_value)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_6(uint256) := i(uint256)
i(uint256) = i + 1""];
11->4;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, HealthAidToken.onlyOwner()()""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, HealthAidToken.canDistr()()""];
13->3;
}
",0,1,0,0,"onlyOwner();;i < addresses.length;;i = 0;getEthBalance(addresses[i]) < _ethbal;;;i ++;balances[owner] -= _value;balances[addresses[i]] += _value;Transfer(owner,addresses[i],_value);canDistr()"
./0x5ab6aad76a702591724b7788b0fbea6292638561_ext.sol,CIC.burn,112,118,"REF_21(uint256) -> balanceOf[msg.sender],TMP_39(bool) = REF_21 >= _value,TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39),REF_22(uint256) -> balanceOf[msg.sender],REF_22(-> balanceOf) = REF_22 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_21(uint256) -> balanceOf[msg.sender]
TMP_39(bool) = REF_21 >= _value
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_22(uint256) -> balanceOf[msg.sender]
REF_22(-> balanceOf) = REF_22 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x470142a1834438515b757118f322703aba6e1e05_ext.sol,PolicyPalNetworkAirdrop.airDropMultipleAmount,141,162,"i(uint256) := 0(uint256),REF_7 -> LENGTH _recipients,TMP_12(bool) = i < REF_7,CONDITION TMP_12,REF_8(address) -> _recipients[i],recipient(address) := REF_8(address),REF_9(uint256) -> _amounts[i],amount(uint256) := REF_9(uint256),REF_10(bool) -> airdrops[recipient],TMP_13 = UnaryType.BANG REF_10 ,CONDITION TMP_13,TMP_14(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', 'amount']  ,TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14),REF_12(bool) -> airdrops[recipient],REF_12(bool) (->airdrops) := True(bool),TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] ,numDrops(uint256) := TMP_16(uint256),TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', 'amount'] ,dropAmount(uint256) := TMP_17(uint256),Emit TokenDrop(recipient,amount,AIRDROP),TMP_19(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()(),MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalanceMultiple(address[],uint256[])(_recipients,_amounts)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->15;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _recipients.length

IRs:
REF_7 -> LENGTH _recipients
TMP_12(bool) = i < REF_7
CONDITION TMP_12""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
recipient = _recipients[i]

IRs:
REF_8(address) -> _recipients[i]
recipient(address) := REF_8(address)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
amount = _amounts[i]

IRs:
REF_9(uint256) -> _amounts[i]
amount(uint256) := REF_9(uint256)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
! airdrops[recipient]

IRs:
REF_10(bool) -> airdrops[recipient]
TMP_13 = UnaryType.BANG REF_10 
CONDITION TMP_13""];
7->8[label=""True""];
7->13[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(token.transfer(recipient,amount))

IRs:
TMP_14(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', 'amount']  
TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
airdrops[recipient] = true

IRs:
REF_12(bool) -> airdrops[recipient]
REF_12(bool) (->airdrops) := True(bool)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
numDrops = numDrops.add(1)

IRs:
TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] 
numDrops(uint256) := TMP_16(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
dropAmount = dropAmount.add(amount)

IRs:
TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', 'amount'] 
dropAmount(uint256) := TMP_17(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
TokenDrop(recipient,amount,AIRDROP)

IRs:
Emit TokenDrop(recipient,amount,AIRDROP)""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
i ++

IRs:
TMP_19(uint256) := i(uint256)
i(uint256) = i + 1""];
14->4;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()()""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
validBalanceMultiple(_recipients,_amounts)

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalanceMultiple(address[],uint256[])(_recipients,_amounts)""];
16->3;
}
",1,1,0,0,"onlyAdmin();;i < _recipients.length;;i = 0;recipient = _recipients[i];amount = _amounts[i];! airdrops[recipient];assert(bool)(token.transfer(recipient,amount));;airdrops[recipient] = true;numDrops = numDrops.add(1);dropAmount = dropAmount.add(amount);TokenDrop(recipient,amount,AIRDROP);i ++;validBalanceMultiple(_recipients,_amounts)"
./0xd5dc75c85159e95f0bd8b5196f4f096a6b7fea1f_ext.sol,BMICoin.mint,272,277,"TMP_93(uint256) = totalSupply_ + tokens,TMP_94(bool) = TMP_93 <= maxSupply,TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94),REF_94(uint256) -> balances[receiver],REF_94(-> balances) = REF_94 + tokens,totalSupply_(uint256) = totalSupply_ + tokens,TMP_96 = CONVERT 0 to address,Emit Transfer(TMP_96,receiver,tokens),MODIFIER_CALL, BMICoin.onlyBackend()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(totalSupply_ + tokens <= maxSupply)

IRs:
TMP_93(uint256) = totalSupply_ + tokens
TMP_94(bool) = TMP_93 <= maxSupply
TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[receiver] += tokens

IRs:
REF_94(uint256) -> balances[receiver]
REF_94(-> balances) = REF_94 + tokens""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply_ += tokens

IRs:
totalSupply_(uint256) = totalSupply_ + tokens""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(address(0x0),receiver,tokens)

IRs:
TMP_96 = CONVERT 0 to address
Emit Transfer(TMP_96,receiver,tokens)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyBackend()

IRs:
MODIFIER_CALL, BMICoin.onlyBackend()()""];
5->1;
}
",0,1,0,0,"onlyBackend();require(bool)(totalSupply_ + tokens <= maxSupply);balances[receiver] += tokens;totalSupply_ += tokens;Transfer(address(0x0),receiver,tokens)"
./0x068e6d2c5b82049dceb93c0a938ef366cf97b2e9_ext.sol,Distribute.airdrop,44,51,"TMP_7(uint256) = HIGH_LEVEL_CALL, dest:tokenReward(token), function:balanceOf, arguments:['this']  ,TMP_8(bool) = totalAmount <= TMP_7,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),i(uint256) := 0(uint256),REF_1 -> LENGTH participants,TMP_10(bool) = i < REF_1,CONDITION TMP_10,REF_2 -> LENGTH participants,TMP_11(uint256) = totalAmount / REF_2,amount(uint256) := TMP_11(uint256),REF_4(address) -> participants[i],HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['REF_4', 'amount']  ,TMP_13(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(totalAmount <= tokenReward.balanceOf(this))

IRs:
TMP_7(uint256) = HIGH_LEVEL_CALL, dest:tokenReward(token), function:balanceOf, arguments:['this']  
TMP_8(bool) = totalAmount <= TMP_7
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->5;
3[label=""Node Type: BEGIN_LOOP 3
""];
3->6;
4[label=""Node Type: END_LOOP 4
""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
5->3;
6[label=""Node Type: IF_LOOP 6

EXPRESSION:
i < participants.length

IRs:
REF_1 -> LENGTH participants
TMP_10(bool) = i < REF_1
CONDITION TMP_10""];
6->7[label=""True""];
6->4[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
amount = totalAmount / participants.length

IRs:
REF_2 -> LENGTH participants
TMP_11(uint256) = totalAmount / REF_2
amount(uint256) := TMP_11(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
tokenReward.transfer(participants[i],amount)

IRs:
REF_4(address) -> participants[i]
HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['REF_4', 'amount']  ""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_13(uint256) := i(uint256)
i(uint256) = i + 1""];
9->6;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
10->1;
}
",0,1,0,0,"onlyOwner();require(bool)(totalAmount <= tokenReward.balanceOf(this));;i = 0;;i < participants.length;;amount = totalAmount / participants.length;tokenReward.transfer(participants[i],amount);i ++"
./0x25caf15e1cc43e7bfa9853a68de463bfb0d27021_ext.sol,IndividualLockableToken.increaseLockBalance,465,481,"TMP_216 = CONVERT 0 to address,TMP_217(bool) = _holder != TMP_216,TMP_218(None) = SOLIDITY_CALL require(bool)(TMP_217),TMP_219(bool) = _value > 0,TMP_220(None) = SOLIDITY_CALL require(bool)(TMP_219),REF_154(uint256) -> balances[_holder],TMP_221(bool) = REF_154 >= _value,TMP_222(None) = SOLIDITY_CALL require(bool)(TMP_221),REF_155(IndividualLockableToken.lockState) -> userLock[_holder],REF_156(uint256) -> REF_155.release_time,TMP_223(bool) = REF_156 == 0,CONDITION TMP_223,REF_157(IndividualLockableToken.lockState) -> userLock[_holder],REF_158(uint256) -> REF_157.release_time,TMP_224(uint256) = block.timestamp + lock_period,REF_158(uint256) (->userLock) := TMP_224(uint256),REF_159(IndividualLockableToken.lockState) -> userLock[_holder],REF_160(uint256) -> REF_159.locked_balance,REF_161(IndividualLockableToken.lockState) -> userLock[_holder],REF_162(uint256) -> REF_161.locked_balance,TMP_225(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_162', '_value'] ,REF_160(uint256) (->userLock) := TMP_225(uint256),REF_164(IndividualLockableToken.lockState) -> userLock[_holder],REF_165(uint256) -> REF_164.locked_balance,REF_166(IndividualLockableToken.lockState) -> userLock[_holder],REF_167(uint256) -> REF_166.release_time,Emit Locked(_holder,_value,REF_165,REF_167),RETURN True,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_holder != address(0))

IRs:
TMP_216 = CONVERT 0 to address
TMP_217(bool) = _holder != TMP_216
TMP_218(None) = SOLIDITY_CALL require(bool)(TMP_217)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_219(bool) = _value > 0
TMP_220(None) = SOLIDITY_CALL require(bool)(TMP_219)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balances[_holder] >= _value)

IRs:
REF_154(uint256) -> balances[_holder]
TMP_221(bool) = REF_154 >= _value
TMP_222(None) = SOLIDITY_CALL require(bool)(TMP_221)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
userLock[_holder].release_time == 0

IRs:
REF_155(IndividualLockableToken.lockState) -> userLock[_holder]
REF_156(uint256) -> REF_155.release_time
TMP_223(bool) = REF_156 == 0
CONDITION TMP_223""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
userLock[_holder].release_time = block.timestamp + lock_period

IRs:
REF_157(IndividualLockableToken.lockState) -> userLock[_holder]
REF_158(uint256) -> REF_157.release_time
TMP_224(uint256) = block.timestamp + lock_period
REF_158(uint256) (->userLock) := TMP_224(uint256)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
userLock[_holder].locked_balance = (userLock[_holder].locked_balance).add(_value)

IRs:
REF_159(IndividualLockableToken.lockState) -> userLock[_holder]
REF_160(uint256) -> REF_159.locked_balance
REF_161(IndividualLockableToken.lockState) -> userLock[_holder]
REF_162(uint256) -> REF_161.locked_balance
TMP_225(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_162', '_value'] 
REF_160(uint256) (->userLock) := TMP_225(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Locked(_holder,_value,userLock[_holder].locked_balance,userLock[_holder].release_time)

IRs:
REF_164(IndividualLockableToken.lockState) -> userLock[_holder]
REF_165(uint256) -> REF_164.locked_balance
REF_166(IndividualLockableToken.lockState) -> userLock[_holder]
REF_167(uint256) -> REF_166.release_time
Emit Locked(_holder,_value,REF_165,REF_167)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
10->1;
}
",0,1,0,0,"onlyOwner();require(bool)(_holder != address(0));require(bool)(_value > 0);require(bool)(balances[_holder] >= _value);userLock[_holder].release_time == 0;userLock[_holder].release_time = block.timestamp + lock_period;;userLock[_holder].locked_balance = (userLock[_holder].locked_balance).add(_value);Locked(_holder,_value,userLock[_holder].locked_balance,userLock[_holder].release_time);true"
./0xeec58a6a1584145106693c24115b7efebf9de896_ext.sol,BlockchainTechnologyFundingToken.totalSupply,111,113,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x7192bb75777dab47ef6fbf6f6c0e4bcbb2294f38_ext.sol,ClockAuctionBase._computeCurrentPrice,220,255,"TMP_29(bool) = _secondsPassed >= _duration,CONDITION TMP_29,RETURN _endingPrice,TMP_30 = CONVERT _endingPrice to int256,TMP_31 = CONVERT _startingPrice to int256,TMP_32(int256) = TMP_30 - TMP_31,totalPriceChange(int256) := TMP_32(int256),TMP_33 = CONVERT _secondsPassed to int256,TMP_34(int256) = totalPriceChange * TMP_33,TMP_35 = CONVERT _duration to int256,TMP_36(int256) = TMP_34 / TMP_35,currentPriceChange(int256) := TMP_36(int256),TMP_37 = CONVERT _startingPrice to int256,TMP_38(int256) = TMP_37 + currentPriceChange,currentPrice(int256) := TMP_38(int256),TMP_39 = CONVERT currentPrice to uint256,RETURN TMP_39","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_secondsPassed >= _duration

IRs:
TMP_29(bool) = _secondsPassed >= _duration
CONDITION TMP_29""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
_endingPrice

IRs:
RETURN _endingPrice""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
totalPriceChange = int256(_endingPrice) - int256(_startingPrice)

IRs:
TMP_30 = CONVERT _endingPrice to int256
TMP_31 = CONVERT _startingPrice to int256
TMP_32(int256) = TMP_30 - TMP_31
totalPriceChange(int256) := TMP_32(int256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration)

IRs:
TMP_33 = CONVERT _secondsPassed to int256
TMP_34(int256) = totalPriceChange * TMP_33
TMP_35 = CONVERT _duration to int256
TMP_36(int256) = TMP_34 / TMP_35
currentPriceChange(int256) := TMP_36(int256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
currentPrice = int256(_startingPrice) + currentPriceChange

IRs:
TMP_37 = CONVERT _startingPrice to int256
TMP_38(int256) = TMP_37 + currentPriceChange
currentPrice(int256) := TMP_38(int256)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
uint256(currentPrice)

IRs:
TMP_39 = CONVERT currentPrice to uint256
RETURN TMP_39""];
}
",0,1,0,0,_secondsPassed >= _duration;_endingPrice;totalPriceChange = int256(_endingPrice) - int256(_startingPrice);currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);currentPrice = int256(_startingPrice) + currentPriceChange;uint256(currentPrice)
./0xc398fb8a6c71a7b130043bf5a3f05d9d51c2cac8_ext.sol,CHAD.totalSupply,120,122,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x6d8811059eb8f0509acec06648ea95b3ae01be72_ext.sol,TokenERC20.burn,135,141,"REF_17(uint256) -> balanceOf[msg.sender],TMP_25(bool) = REF_17 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_25(bool) = REF_17 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x0e496fe351e9a2eabcc76d57b1248e10394d60be_ext.sol,yiDaoGame.burnFrom,138,146,"REF_19(uint256) -> balanceOf[_from],TMP_22(bool) = REF_19 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_24(bool) = _value <= REF_21,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_22(bool) = REF_19 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_24(bool) = _value <= REF_21
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x6db92e635ba5d2834fff3db03b6be80d8aa28d5a_ext.sol,TokenBaseAsset.removeToken,30,33,"TMP_2(bool) = msg.sender == mOwner,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_1(string) -> mTokens[pDocumentHash],REF_1(string) (->mTokens) := (string)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == mOwner)

IRs:
TMP_2(bool) = msg.sender == mOwner
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
mTokens[pDocumentHash] = 

IRs:
REF_1(string) -> mTokens[pDocumentHash]
REF_1(string) (->mTokens) := (string)""];
}
",0,1,0,0,require(bool)(msg.sender == mOwner);mTokens[pDocumentHash] =
./0x1d8ebb2f0345874e9193388ef3a2f063eaa71edc_ext.sol,QuadCoin.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x4027c7262554ba72ccc3e346c6b71794299d3b99_ext.sol,CWT._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x40489719e489782959486a04b765e1e93e5b221a_ext.sol,SGEToken.burnFrom,57,65,"REF_18(uint256) -> balanceOf[_from],TMP_22(bool) = REF_18 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_19(mapping(address => uint256)) -> allowance[_from],REF_20(uint256) -> REF_19[msg.sender],TMP_24(bool) = _value <= REF_20,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_21(uint256) -> balanceOf[_from],REF_21(-> balanceOf) = REF_21 - _value,REF_22(mapping(address => uint256)) -> allowance[_from],REF_23(uint256) -> REF_22[msg.sender],REF_23(-> allowance) = REF_23 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_18(uint256) -> balanceOf[_from]
TMP_22(bool) = REF_18 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_19(mapping(address => uint256)) -> allowance[_from]
REF_20(uint256) -> REF_19[msg.sender]
TMP_24(bool) = _value <= REF_20
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_21(uint256) -> balanceOf[_from]
REF_21(-> balanceOf) = REF_21 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_22(mapping(address => uint256)) -> allowance[_from]
REF_23(uint256) -> REF_22[msg.sender]
REF_23(-> allowance) = REF_23 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x31a5f35f32756fe35d39bafe85607d93185b23f2_ext.sol,GNNM._transfer,58,74,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x8d46facfb889740a345755e624942257dc87b5ac_ext.sol,Token.getAvailableBalance,174,199,"REF_11(Token.Fund) -> frozenAccount[sender],REF_12(bool) -> REF_11.isValue,CONDITION REF_12,REF_13(Token.Fund) -> frozenAccount[sender],REF_14(uint256) -> REF_13.unlockStartTime,TMP_100(bool) = now < REF_14,CONDITION TMP_100,REF_15(uint256) -> balances[sender],REF_16(Token.Fund) -> frozenAccount[sender],REF_17(uint256) -> REF_16.amount,TMP_101(uint256) = REF_15 - REF_17,RETURN TMP_101,REF_18(Token.Fund) -> frozenAccount[sender],REF_19(uint256) -> REF_18.unlockStartTime,TMP_102(uint256) = now - REF_19,REF_20(Token.Fund) -> frozenAccount[sender],REF_21(uint256) -> REF_20.unlockInterval,TMP_103(uint256) = TMP_102 / REF_21,TMP_104(uint256) = TMP_103 + 1,REF_22(Token.Fund) -> frozenAccount[sender],REF_23(uint256) -> REF_22.unlockPercent,TMP_105(uint256) = TMP_104 * REF_23,unlockPercent(uint256) := TMP_105(uint256),TMP_106(bool) = unlockPercent > 100,CONDITION TMP_106,unlockPercent(uint256) := 100(uint256),REF_24(Token.Fund) -> frozenAccount[sender],REF_25(uint256) -> REF_24.amount,REF_26(uint256) -> balances[sender],TMP_107(bool) = REF_25 <= REF_26,TMP_108(None) = SOLIDITY_CALL assert(bool)(TMP_107),REF_27(uint256) -> balances[sender],TMP_109(uint256) = 100 - unlockPercent,REF_28(Token.Fund) -> frozenAccount[sender],REF_29(uint256) -> REF_28.amount,TMP_110(uint256) = TMP_109 * REF_29,TMP_111(uint256) = TMP_110 / 100,TMP_112(uint256) = REF_27 - TMP_111,available(uint256) := TMP_112(uint256),TMP_113(bool) = unlockPercent >= 100,CONDITION TMP_113,REF_30(Token.Fund) -> frozenAccount[sender],REF_31(bool) -> REF_30.isValue,REF_31(bool) (->frozenAccount) := False(bool),REF_32(Token.Fund) -> frozenAccount[sender],frozenAccount = delete REF_32 ,RETURN available,REF_33(uint256) -> balances[sender],RETURN REF_33,RETURN balance","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
frozenAccount[sender].isValue

IRs:
REF_11(Token.Fund) -> frozenAccount[sender]
REF_12(bool) -> REF_11.isValue
CONDITION REF_12""];
1->2[label=""True""];
1->16[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
now < frozenAccount[sender].unlockStartTime

IRs:
REF_13(Token.Fund) -> frozenAccount[sender]
REF_14(uint256) -> REF_13.unlockStartTime
TMP_100(bool) = now < REF_14
CONDITION TMP_100""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3

EXPRESSION:
balances[sender] - frozenAccount[sender].amount

IRs:
REF_15(uint256) -> balances[sender]
REF_16(Token.Fund) -> frozenAccount[sender]
REF_17(uint256) -> REF_16.amount
TMP_101(uint256) = REF_15 - REF_17
RETURN TMP_101""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
unlockPercent = ((now - frozenAccount[sender].unlockStartTime) / frozenAccount[sender].unlockInterval + 1) * frozenAccount[sender].unlockPercent

IRs:
REF_18(Token.Fund) -> frozenAccount[sender]
REF_19(uint256) -> REF_18.unlockStartTime
TMP_102(uint256) = now - REF_19
REF_20(Token.Fund) -> frozenAccount[sender]
REF_21(uint256) -> REF_20.unlockInterval
TMP_103(uint256) = TMP_102 / REF_21
TMP_104(uint256) = TMP_103 + 1
REF_22(Token.Fund) -> frozenAccount[sender]
REF_23(uint256) -> REF_22.unlockPercent
TMP_105(uint256) = TMP_104 * REF_23
unlockPercent(uint256) := TMP_105(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
unlockPercent > 100

IRs:
TMP_106(bool) = unlockPercent > 100
CONDITION TMP_106""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
unlockPercent = 100

IRs:
unlockPercent(uint256) := 100(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(frozenAccount[sender].amount <= balances[sender])

IRs:
REF_24(Token.Fund) -> frozenAccount[sender]
REF_25(uint256) -> REF_24.amount
REF_26(uint256) -> balances[sender]
TMP_107(bool) = REF_25 <= REF_26
TMP_108(None) = SOLIDITY_CALL assert(bool)(TMP_107)""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
available = balances[sender] - (100 - unlockPercent) * frozenAccount[sender].amount / 100

IRs:
REF_27(uint256) -> balances[sender]
TMP_109(uint256) = 100 - unlockPercent
REF_28(Token.Fund) -> frozenAccount[sender]
REF_29(uint256) -> REF_28.amount
TMP_110(uint256) = TMP_109 * REF_29
TMP_111(uint256) = TMP_110 / 100
TMP_112(uint256) = REF_27 - TMP_111
available(uint256) := TMP_112(uint256)""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
unlockPercent >= 100

IRs:
TMP_113(bool) = unlockPercent >= 100
CONDITION TMP_113""];
10->11[label=""True""];
10->13[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
frozenAccount[sender].isValue = false

IRs:
REF_30(Token.Fund) -> frozenAccount[sender]
REF_31(bool) -> REF_30.isValue
REF_31(bool) (->frozenAccount) := False(bool)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
delete frozenAccount[sender]

IRs:
REF_32(Token.Fund) -> frozenAccount[sender]
frozenAccount = delete REF_32 ""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: RETURN 14

EXPRESSION:
available

IRs:
RETURN available""];
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: RETURN 17

EXPRESSION:
balances[sender]

IRs:
REF_33(uint256) -> balances[sender]
RETURN REF_33""];
18[label=""Node Type: RETURN 18

EXPRESSION:
balance

IRs:
RETURN balance""];
}
",0,1,0,0,frozenAccount[sender].isValue;now < frozenAccount[sender].unlockStartTime;;balances[sender] - frozenAccount[sender].amount;unlockPercent = ((now - frozenAccount[sender].unlockStartTime) / frozenAccount[sender].unlockInterval + 1) * frozenAccount[sender].unlockPercent;unlockPercent > 100;unlockPercent = 100;;assert(bool)(frozenAccount[sender].amount <= balances[sender]);available = balances[sender] - (100 - unlockPercent) * frozenAccount[sender].amount / 100;unlockPercent >= 100;frozenAccount[sender].isValue = false;;delete frozenAccount[sender];available;balances[sender];balance
./0x7157cf5f3f57ee59d74b905175134b8a7763b065_ext.sol,PeaceChainToken._transfer,51,67,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x1afafc35b364595f06e89a0429c5762452eb7ffd_ext.sol,BasicToken.balanceOf,202,204,"REF_7(uint256) -> freeBalances[_owner],REF_8(uint256) -> frozenBalances[_owner],TMP_64(uint256) = REF_7 + REF_8,RETURN TMP_64,RETURN balance","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
freeBalances[_owner] + frozenBalances[_owner]

IRs:
REF_7(uint256) -> freeBalances[_owner]
REF_8(uint256) -> frozenBalances[_owner]
TMP_64(uint256) = REF_7 + REF_8
RETURN TMP_64""];
2[label=""Node Type: RETURN 2

EXPRESSION:
balance

IRs:
RETURN balance""];
}
",0,1,0,0,freeBalances[_owner] + frozenBalances[_owner];balance
./0x5c65a8e333e5b0a932704bee2f28fdcc49d1e837_ext.sol,JawazToken.burn,128,134,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xece73b9f0e0a3d7f33f79fd1d77cb344288b9966_ext.sol,RVG.burn,127,133,"TMP_60(uint256) = supply - totalSupplied,remainBalance(uint256) := TMP_60(uint256),TMP_61(uint256) = remainBalance / 10,burnAmount(uint256) := TMP_61(uint256),totalBurned(uint256) = totalBurned + burnAmount,TMP_62 = CONVERT this to address,TMP_63(bool) = INTERNAL_CALL, StdToken._burn(address,uint256)(TMP_62,burnAmount),RETURN True,MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
remainBalance = supply - totalSupplied

IRs:
TMP_60(uint256) = supply - totalSupplied
remainBalance(uint256) := TMP_60(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
burnAmount = remainBalance / 10

IRs:
TMP_61(uint256) = remainBalance / 10
burnAmount(uint256) := TMP_61(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalBurned += burnAmount

IRs:
totalBurned(uint256) = totalBurned + burnAmount""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
_burn(address(this),burnAmount)

IRs:
TMP_62 = CONVERT this to address
TMP_63(bool) = INTERNAL_CALL, StdToken._burn(address,uint256)(TMP_62,burnAmount)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
6->1;
}
",0,1,0,0,"onlyOwner();remainBalance = supply - totalSupplied;burnAmount = remainBalance / 10;totalBurned += burnAmount;_burn(address(this),burnAmount);true"
./0xeefb40cd8224c2986f391b62b206c7a018885517_ext.sol,touristoken.burn,116,122,"REF_17(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_17 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_17 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x52a5e1a56a124dce84e548ff96122246e46d599f_ext.sol,TokenERC20.burnFrom,167,175,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xa29e71cb2e30e8af956d64b025b88a5ca3d7ecd2_ext.sol,StandardToken.transferFrom,58,68,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x37304b0ab297f13f5520c523102797121182fb5b_ext.sol,SportCrypt.claim,207,242,"REF_76(SportCrypt.Match) -> matches[matchId],m(SportCrypt.Match) := REF_76(SportCrypt.Match),REF_77(bool) -> m.finalized,CONDITION REF_77,REF_78(uint8) -> m.finalPrice,TMP_64(bool) = REF_78 == finalPrice,TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64),TMP_66(bytes32) = SOLIDITY_CALL keccak256()(this,matchId,finalPrice),TMP_67 = CONVERT TMP_66 to uint256,messageHash(uint256) := TMP_67(uint256),TMP_68(bytes32) = SOLIDITY_CALL keccak256()(Ethereum Signed Message:
32,messageHash),TMP_69(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(TMP_68,v,r,s),signer(address) := TMP_69(address),REF_79(bool) -> admins[signer],TMP_70(None) = SOLIDITY_CALL require(bool)(REF_79),TMP_71(bool) = finalPrice <= 100,TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71),REF_80(bool) -> m.finalized,REF_80(bool) (->m) := True(bool),REF_81(uint8) -> m.finalPrice,REF_81(uint8) (->m) := finalPrice(uint8),Emit LogFinalizeMatch(matchId,finalPrice),delta(int256) := 0(int256),REF_82(mapping(address => int256)) -> m.positions,REF_83(int256) -> REF_82[msg.sender],senderPosition(int256) := REF_83(int256),TMP_74(bool) = senderPosition > 0,CONDITION TMP_74,TMP_75(int256) = INTERNAL_CALL, SportCrypt.priceDivide(int256,uint8)(senderPosition,finalPrice),delta(int256) := TMP_75(int256),TMP_76(bool) = senderPosition < 0,CONDITION TMP_76,TMP_77(int256) = 0 - senderPosition,TMP_78(uint256) = 100 - finalPrice,TMP_79(int256) = INTERNAL_CALL, SportCrypt.priceDivide(int256,uint8)(TMP_77,TMP_78),delta(int256) := TMP_79(int256),TMP_80(bool) = delta >= 0,TMP_81(None) = SOLIDITY_CALL assert(bool)(TMP_80),REF_84(mapping(address => int256)) -> m.positions,REF_85(int256) -> REF_84[msg.sender],REF_85(int256) (->m) := 0(int256),INTERNAL_CALL, SportCrypt.adjustBalance(address,int256)(msg.sender,delta),TMP_83 = CONVERT delta to uint256,Emit LogClaim(msg.sender,matchId,TMP_83)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
m = matches[matchId]

IRs:
REF_76(SportCrypt.Match) -> matches[matchId]
m(SportCrypt.Match) := REF_76(SportCrypt.Match)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
m.finalized

IRs:
REF_77(bool) -> m.finalized
CONDITION REF_77""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(m.finalPrice == finalPrice)

IRs:
REF_78(uint8) -> m.finalPrice
TMP_64(bool) = REF_78 == finalPrice
TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64)""];
3->11;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
messageHash = uint256(keccak256()(this,matchId,finalPrice))

IRs:
TMP_66(bytes32) = SOLIDITY_CALL keccak256()(this,matchId,finalPrice)
TMP_67 = CONVERT TMP_66 to uint256
messageHash(uint256) := TMP_67(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
signer = ecrecover(bytes32,uint8,bytes32,bytes32)(keccak256()(Ethereum Signed Message:
32,messageHash),v,r,s)

IRs:
TMP_68(bytes32) = SOLIDITY_CALL keccak256()(Ethereum Signed Message:
32,messageHash)
TMP_69(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(TMP_68,v,r,s)
signer(address) := TMP_69(address)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(admins[signer])

IRs:
REF_79(bool) -> admins[signer]
TMP_70(None) = SOLIDITY_CALL require(bool)(REF_79)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(finalPrice <= 100)

IRs:
TMP_71(bool) = finalPrice <= 100
TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
m.finalized = true

IRs:
REF_80(bool) -> m.finalized
REF_80(bool) (->m) := True(bool)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
m.finalPrice = finalPrice

IRs:
REF_81(uint8) -> m.finalPrice
REF_81(uint8) (->m) := finalPrice(uint8)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
LogFinalizeMatch(matchId,finalPrice)

IRs:
Emit LogFinalizeMatch(matchId,finalPrice)""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
delta = 0

IRs:
delta(int256) := 0(int256)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
senderPosition = m.positions[msg.sender]

IRs:
REF_82(mapping(address => int256)) -> m.positions
REF_83(int256) -> REF_82[msg.sender]
senderPosition(int256) := REF_83(int256)""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
senderPosition > 0

IRs:
TMP_74(bool) = senderPosition > 0
CONDITION TMP_74""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
delta = priceDivide(senderPosition,finalPrice)

IRs:
TMP_75(int256) = INTERNAL_CALL, SportCrypt.priceDivide(int256,uint8)(senderPosition,finalPrice)
delta(int256) := TMP_75(int256)""];
15->20;
16[label=""Node Type: IF 16

EXPRESSION:
senderPosition < 0

IRs:
TMP_76(bool) = senderPosition < 0
CONDITION TMP_76""];
16->17[label=""True""];
16->18[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
delta = priceDivide(- senderPosition,100 - finalPrice)

IRs:
TMP_77(int256) = 0 - senderPosition
TMP_78(uint256) = 100 - finalPrice
TMP_79(int256) = INTERNAL_CALL, SportCrypt.priceDivide(int256,uint8)(TMP_77,TMP_78)
delta(int256) := TMP_79(int256)""];
17->19;
18[label=""Node Type: RETURN 18
""];
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
assert(bool)(delta >= 0)

IRs:
TMP_80(bool) = delta >= 0
TMP_81(None) = SOLIDITY_CALL assert(bool)(TMP_80)""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
m.positions[msg.sender] = 0

IRs:
REF_84(mapping(address => int256)) -> m.positions
REF_85(int256) -> REF_84[msg.sender]
REF_85(int256) (->m) := 0(int256)""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
adjustBalance(msg.sender,delta)

IRs:
INTERNAL_CALL, SportCrypt.adjustBalance(address,int256)(msg.sender,delta)""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
LogClaim(msg.sender,matchId,uint256(delta))

IRs:
TMP_83 = CONVERT delta to uint256
Emit LogClaim(msg.sender,matchId,TMP_83)""];
}
",0,1,0,0,"m = matches[matchId];m.finalized;require(bool)(m.finalPrice == finalPrice);messageHash = uint256(keccak256()(this,matchId,finalPrice));;;require(bool)(admins[signer]);require(bool)(finalPrice <= 100);m.finalized = true;m.finalPrice = finalPrice;LogFinalizeMatch(matchId,finalPrice);delta = 0;senderPosition = m.positions[msg.sender];senderPosition > 0;delta = priceDivide(senderPosition,finalPrice);senderPosition < 0;;delta = priceDivide(- senderPosition,100 - finalPrice);;;assert(bool)(delta >= 0);m.positions[msg.sender] = 0;adjustBalance(msg.sender,delta);LogClaim(msg.sender,matchId,uint256(delta))"
./0x6b5d69ef0f14ae4a96f6ba31a72b9a07ec1cd74e_ext.sol,TokenERC20.burnFrom,168,176,"REF_19(uint256) -> balanceOf[_from],TMP_32(bool) = REF_19 >= _value,TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32),TMP_34(bool) = msg.sender == owner,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),REF_20(uint256) -> balanceOf[_from],REF_20(-> balanceOf) = REF_20 - _value,REF_21(mapping(address => uint256)) -> allowance[_from],REF_22(uint256) -> REF_21[msg.sender],REF_22(-> allowance) = REF_22 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_32(bool) = REF_19 >= _value
TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_34(bool) = msg.sender == owner
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_20(uint256) -> balanceOf[_from]
REF_20(-> balanceOf) = REF_20 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_21(mapping(address => uint256)) -> allowance[_from]
REF_22(uint256) -> REF_21[msg.sender]
REF_22(-> allowance) = REF_22 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(msg.sender == owner);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x6c91c0104677d08cded353b1459b68415f278c38_ext.sol,FastEth.getQueueLength,223,225,"REF_25 -> LENGTH queue,TMP_45(uint256) = REF_25 - currentReceiverIndex,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
queue.length - currentReceiverIndex

IRs:
REF_25 -> LENGTH queue
TMP_45(uint256) = REF_25 - currentReceiverIndex
RETURN TMP_45""];
}
",0,1,0,0,queue.length - currentReceiverIndex
./0xbfa48ef73b319083b7e1d5831071cf0dcf2f7875_ext.sol,YCToken.burnFrom,149,157,"REF_19(uint256) -> balanceOf[_from],TMP_26(bool) = REF_19 >= _value,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_28(bool) = _value <= REF_21,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_26(bool) = REF_19 >= _value
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_28(bool) = _value <= REF_21
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x470142a1834438515b757118f322703aba6e1e05_ext.sol,PolicyPalNetworkAirdrop.airDropMultipleAmount,141,162,"i(uint256) := 0(uint256),REF_7 -> LENGTH _recipients,TMP_12(bool) = i < REF_7,CONDITION TMP_12,REF_8(address) -> _recipients[i],recipient(address) := REF_8(address),REF_9(uint256) -> _amounts[i],amount(uint256) := REF_9(uint256),REF_10(bool) -> airdrops[recipient],TMP_13 = UnaryType.BANG REF_10 ,CONDITION TMP_13,TMP_14(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', 'amount']  ,TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14),REF_12(bool) -> airdrops[recipient],REF_12(bool) (->airdrops) := True(bool),TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] ,numDrops(uint256) := TMP_16(uint256),TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', 'amount'] ,dropAmount(uint256) := TMP_17(uint256),Emit TokenDrop(recipient,amount,AIRDROP),TMP_19(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()(),MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalanceMultiple(address[],uint256[])(_recipients,_amounts)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->15;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _recipients.length

IRs:
REF_7 -> LENGTH _recipients
TMP_12(bool) = i < REF_7
CONDITION TMP_12""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
recipient = _recipients[i]

IRs:
REF_8(address) -> _recipients[i]
recipient(address) := REF_8(address)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
amount = _amounts[i]

IRs:
REF_9(uint256) -> _amounts[i]
amount(uint256) := REF_9(uint256)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
! airdrops[recipient]

IRs:
REF_10(bool) -> airdrops[recipient]
TMP_13 = UnaryType.BANG REF_10 
CONDITION TMP_13""];
7->8[label=""True""];
7->13[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(token.transfer(recipient,amount))

IRs:
TMP_14(bool) = HIGH_LEVEL_CALL, dest:token(PolicyPalNetworkToken), function:transfer, arguments:['recipient', 'amount']  
TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
airdrops[recipient] = true

IRs:
REF_12(bool) -> airdrops[recipient]
REF_12(bool) (->airdrops) := True(bool)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
numDrops = numDrops.add(1)

IRs:
TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['numDrops', '1'] 
numDrops(uint256) := TMP_16(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
dropAmount = dropAmount.add(amount)

IRs:
TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['dropAmount', 'amount'] 
dropAmount(uint256) := TMP_17(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
TokenDrop(recipient,amount,AIRDROP)

IRs:
Emit TokenDrop(recipient,amount,AIRDROP)""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
i ++

IRs:
TMP_19(uint256) := i(uint256)
i(uint256) = i + 1""];
14->4;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.onlyAdmin()()""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
validBalanceMultiple(_recipients,_amounts)

IRs:
MODIFIER_CALL, PolicyPalNetworkAirdrop.validBalanceMultiple(address[],uint256[])(_recipients,_amounts)""];
16->3;
}
",1,1,0,0,"onlyAdmin();;i < _recipients.length;;i = 0;recipient = _recipients[i];amount = _amounts[i];! airdrops[recipient];assert(bool)(token.transfer(recipient,amount));;airdrops[recipient] = true;numDrops = numDrops.add(1);dropAmount = dropAmount.add(amount);TokenDrop(recipient,amount,AIRDROP);i ++;validBalanceMultiple(_recipients,_amounts)"
./0x54a9ed327f2614316914c3f3a782a77d0aa47aee_ext.sol,CONNECT._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xa13034912eca36ddb8a0b62bc86251006d8296d6_ext.sol,LightAirdrop.performDifferent,91,100,"TMP_9 = CONVERT tokenAddress to EIP20Interface,tokenContract(EIP20Interface) := TMP_9(EIP20Interface),i(uint256) := 0(uint256),REF_3 -> LENGTH tos,n(uint256) := REF_3(uint256),TMP_10(bool) = i < n,CONDITION TMP_10,REF_5(address) -> tos[i],REF_6(uint256) -> amounts[i],TMP_11(bool) = HIGH_LEVEL_CALL, dest:tokenContract(EIP20Interface), function:transfer, arguments:['REF_5', 'REF_6']  ,TMP_12(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, OwnableContract.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokenContract = EIP20Interface(tokenAddress)

IRs:
TMP_9 = CONVERT tokenAddress to EIP20Interface
tokenContract(EIP20Interface) := TMP_9(EIP20Interface)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
n = tos.length

IRs:
REF_3 -> LENGTH tos
n(uint256) := REF_3(uint256)""];
3->4;
4[label=""Node Type: BEGIN_LOOP 4
""];
4->6;
5[label=""Node Type: END_LOOP 5
""];
6[label=""Node Type: IF_LOOP 6

EXPRESSION:
i < n

IRs:
TMP_10(bool) = i < n
CONDITION TMP_10""];
6->7[label=""True""];
6->5[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokenContract.transfer(tos[i],amounts[i])

IRs:
REF_5(address) -> tos[i]
REF_6(uint256) -> amounts[i]
TMP_11(bool) = HIGH_LEVEL_CALL, dest:tokenContract(EIP20Interface), function:transfer, arguments:['REF_5', 'REF_6']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_12(uint256) := i(uint256)
i(uint256) = i + 1""];
8->6;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, OwnableContract.onlyOwner()()""];
9->1;
}
",0,1,0,0,"onlyOwner();tokenContract = EIP20Interface(tokenAddress);i = 0;n = tos.length;;i < n;;tokenContract.transfer(tos[i],amounts[i]);i ++"
./0x516f49a1a2087d481b73abe69f50d6e663228cca_ext.sol,CRYPTOZOLToken.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x2add07c4d319a1211ed6362d8d0fbe5ef56b65f6_ext.sol,RETNToken.mintToken,206,211,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x0704d3952dc50e8a36a8cb53f84d8c39895cd5cf_ext.sol,MagicCube.burn,117,123,"REF_14(uint256) -> balanceOf[msg.sender],TMP_67(bool) = REF_14 >= _value,TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67),REF_15(uint256) -> balanceOf[msg.sender],REF_15(-> balanceOf) = REF_15 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,MODIFIER_CALL, MagicCube.onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_14(uint256) -> balanceOf[msg.sender]
TMP_67(bool) = REF_14 >= _value
TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_15(uint256) -> balanceOf[msg.sender]
REF_15(-> balanceOf) = REF_15 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MagicCube.onlyOwner()()""];
6->1;
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"onlyOwner();require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x5af3630746975d9cbaf236d4117b08a2c7a0bd77_ext.sol,SafeMath.add,27,31,"TMP_10(uint256) = a + b,c(uint256) := TMP_10(uint256),TMP_11(bool) = c >= a,TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11),RETURN c","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_10(uint256) = a + b
c(uint256) := TMP_10(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_11(bool) = c >= a
TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c""];
}
",0,1,0,0,c = a + b;assert(bool)(c >= a);c
./0x01e53a2e7122a63845b1c329d4fce8124dda5b06_ext.sol,Loan.InvestFund,129,141,"TMP_41(bool) = msg.value >= 1000000000000000000,CONDITION TMP_41,REF_0(uint256) -> Investors[msg.sender],TMP_42(bool) = REF_0 == 0,CONDITION TMP_42,TMP_43(uint256) := InvestorsQty(uint256),InvestorsQty(uint256) = InvestorsQty + 1,REF_1(uint256) -> Investors[msg.sender],REF_1(-> Investors) = REF_1 + msg.value,TotalInvested(uint256) = TotalInvested + msg.value,Available(uint256) = Available + msg.value,Emit Invest(msg.sender,msg.value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value >= 1000000000000000000

IRs:
TMP_41(bool) = msg.value >= 1000000000000000000
CONDITION TMP_41""];
1->2[label=""True""];
1->9[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
Investors[msg.sender] == 0

IRs:
REF_0(uint256) -> Investors[msg.sender]
TMP_42(bool) = REF_0 == 0
CONDITION TMP_42""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
InvestorsQty ++

IRs:
TMP_43(uint256) := InvestorsQty(uint256)
InvestorsQty(uint256) = InvestorsQty + 1""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Investors[msg.sender] += msg.value

IRs:
REF_1(uint256) -> Investors[msg.sender]
REF_1(-> Investors) = REF_1 + msg.value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
TotalInvested += msg.value

IRs:
TotalInvested(uint256) = TotalInvested + msg.value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Available += msg.value

IRs:
Available(uint256) = Available + msg.value""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Invest(msg.sender,msg.value)

IRs:
Emit Invest(msg.sender,msg.value)""];
8->9;
9[label=""Node Type: END_IF 9
""];
}
",0,1,0,0,"msg.value >= 1000000000000000000;Investors[msg.sender] == 0;;InvestorsQty ++;;Investors[msg.sender] += msg.value;TotalInvested += msg.value;Available += msg.value;Invest(msg.sender,msg.value)"
./0x17f0badcdf99b0a94429478d2e9ddb1ff13174f7_ext.sol,knf.Award,220,226,"TMP_31 = CONVERT 0 to address,TMP_32(bool) = _to != TMP_31,TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32),REF_45(uint256) -> balances[owner],TMP_34(bool) = _v <= REF_45,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),REF_46(uint256) -> balances[_to],REF_46(-> balances) = REF_46 + _v,REF_47(uint256) -> balances[owner],REF_47(-> balances) = REF_47 - _v,INTERNAL_CALL, knf.RecordTransfer(address,address,uint256)(owner,_to,_v),MODIFIER_CALL, knf.onlyControl()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_31 = CONVERT 0 to address
TMP_32(bool) = _to != TMP_31
TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_v <= balances[owner])

IRs:
REF_45(uint256) -> balances[owner]
TMP_34(bool) = _v <= REF_45
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _v

IRs:
REF_46(uint256) -> balances[_to]
REF_46(-> balances) = REF_46 + _v""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[owner] -= _v

IRs:
REF_47(uint256) -> balances[owner]
REF_47(-> balances) = REF_47 - _v""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RecordTransfer(owner,_to,_v)

IRs:
INTERNAL_CALL, knf.RecordTransfer(address,address,uint256)(owner,_to,_v)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyControl()

IRs:
MODIFIER_CALL, knf.onlyControl()()""];
6->1;
}
",0,1,0,0,"onlyControl();require(bool)(_to != address(0));require(bool)(_v <= balances[owner]);balances[_to] += _v;balances[owner] -= _v;RecordTransfer(owner,_to,_v)"
./0x3a1237d38d0fb94513f85d61679cad7f38507242_ext.sol,Mindexcoin.burnFrom,161,169,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xc64500dd7b0f1794807e67802f8abbf5f8ffb054_ext.sol,LocusToken.approveAndCall,67,73,"TMP_18 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_18(tokenRecipient),TMP_19(bool) = INTERNAL_CALL, LocusToken.approve(address,uint256)(_spender,_value),CONDITION TMP_19,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_18 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_18(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_19(bool) = INTERNAL_CALL, LocusToken.approve(address,uint256)(_spender,_value)
CONDITION TMP_19""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true"
./0x54dd71cac082ac6fcfeb727c5bbb0a07be1c5de9_ext.sol,MylittleProgram.putPrize,131,136,"TMP_18 = CONVERT 0 to address,TMP_19(bool) = msg.sender != TMP_18,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),TMP_21(uint256) = prize + msg.value,prize(uint256) := TMP_21(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender != address(0))

IRs:
TMP_18 = CONVERT 0 to address
TMP_19(bool) = msg.sender != TMP_18
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
prize = prize + msg.value

IRs:
TMP_21(uint256) = prize + msg.value
prize(uint256) := TMP_21(uint256)""];
}
",0,1,0,0,require(bool)(msg.sender != address(0));prize = prize + msg.value
./0x6d66439c9cc75b69f9a40e82f34445081b8e929a_ext.sol,ContractReceiver.tokenFallback,62,69,"REF_0(address) -> tkn.sender,REF_0(address) (->tkn) := _from(address),REF_1(uint256) -> tkn.value,REF_1(uint256) (->tkn) := _value(uint256),REF_2(bytes) -> tkn.data,REF_2(bytes) (->tkn) := _data(bytes),REF_3(None) -> _data[3],TMP_12 = CONVERT REF_3 to uint32,REF_4(None) -> _data[2],TMP_13 = CONVERT REF_4 to uint32,TMP_14(uint32) = TMP_13 << 8,TMP_15(uint32) = TMP_12 + TMP_14,REF_5(None) -> _data[1],TMP_16 = CONVERT REF_5 to uint32,TMP_17(uint32) = TMP_16 << 16,TMP_18(uint32) = TMP_15 + TMP_17,REF_6(None) -> _data[0],TMP_19 = CONVERT REF_6 to uint32,TMP_20(uint32) = TMP_19 << 24,TMP_21(uint32) = TMP_18 + TMP_20,u(uint32) := TMP_21(uint32),REF_7(bytes4) -> tkn.sig,TMP_22 = CONVERT u to bytes4,REF_7(bytes4) (->tkn) := TMP_22(bytes4)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
tkn.sender = _from

IRs:
REF_0(address) -> tkn.sender
REF_0(address) (->tkn) := _from(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tkn.value = _value

IRs:
REF_1(uint256) -> tkn.value
REF_1(uint256) (->tkn) := _value(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
tkn.data = _data

IRs:
REF_2(bytes) -> tkn.data
REF_2(bytes) (->tkn) := _data(bytes)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24)

IRs:
REF_3(None) -> _data[3]
TMP_12 = CONVERT REF_3 to uint32
REF_4(None) -> _data[2]
TMP_13 = CONVERT REF_4 to uint32
TMP_14(uint32) = TMP_13 << 8
TMP_15(uint32) = TMP_12 + TMP_14
REF_5(None) -> _data[1]
TMP_16 = CONVERT REF_5 to uint32
TMP_17(uint32) = TMP_16 << 16
TMP_18(uint32) = TMP_15 + TMP_17
REF_6(None) -> _data[0]
TMP_19 = CONVERT REF_6 to uint32
TMP_20(uint32) = TMP_19 << 24
TMP_21(uint32) = TMP_18 + TMP_20
u(uint32) := TMP_21(uint32)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tkn.sig = bytes4(u)

IRs:
REF_7(bytes4) -> tkn.sig
TMP_22 = CONVERT u to bytes4
REF_7(bytes4) (->tkn) := TMP_22(bytes4)""];
}
",0,1,0,0,;tkn.sender = _from;tkn.value = _value;tkn.data = _data;u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);tkn.sig = bytes4(u)
./0xc37b74c1f1d6a0f9a6ebd4bd846805f899b5e897_ext.sol,Angelglorycoin.burnFrom,146,153,"REF_19(uint256) -> balanceOf[_from],TMP_20(bool) = REF_19 >= _value,TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_22(bool) = _value <= REF_21,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_20(bool) = REF_19 >= _value
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_22(bool) = _value <= REF_21
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;true;success
./0xb430244b442c228a59a0fd4450fa7eedd5fbf833_ext.sol,VOC_ethchf_48013527701_20181215.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x783cf9c6754bf826f1727620b4baa19714fedf8d_ext.sol,ETH_MIXER.MakeTransfer,22,41,"TMP_0(bool) = msg.value > 1000000000000000000,CONDITION TMP_0,TMP_1(bool) = msg.sender == tx.origin,TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1),REF_0(uint256) -> LogUnit.timeStamp,REF_0(uint256) (->LogUnit) := now(uint256),REF_1(uint256) -> LogUnit.currContractBallance,REF_2(uint256) = SOLIDITY_CALL balance(address)(this),REF_1(uint256) (->LogUnit) := REF_2([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E31555E0>]),REF_3(uint256) -> LogUnit.transferAmount,REF_3(uint256) (->LogUnit) := _am(uint256),REF_5 -> LENGTH Log,TMP_4(uint256) := REF_5(uint256),TMP_5(uint256) = TMP_4 + 1,REF_5(uint256) (->Log) := TMP_5(uint256),REF_6(ETH_MIXER.Transfer) -> Log[TMP_4],REF_6(ETH_MIXER.Transfer) (->Log) := LogUnit(ETH_MIXER.Transfer),TMP_6 = SEND dest:creator value:creatorFee,TMP_7 = SEND dest:_adr value:_am,feePaid(uint256) = feePaid + creatorFee,totalTransfered(uint256) = totalTransfered + _am","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value > 1000000000000000000

IRs:
TMP_0(bool) = msg.value > 1000000000000000000
CONDITION TMP_0""];
1->2[label=""True""];
1->12[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_1(bool) = msg.sender == tx.origin
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
LogUnit.timeStamp = now

IRs:
REF_0(uint256) -> LogUnit.timeStamp
REF_0(uint256) (->LogUnit) := now(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
LogUnit.currContractBallance = this.balance

IRs:
REF_1(uint256) -> LogUnit.currContractBallance
REF_2(uint256) = SOLIDITY_CALL balance(address)(this)
REF_1(uint256) (->LogUnit) := REF_2([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E31555E0>])""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
LogUnit.transferAmount = _am

IRs:
REF_3(uint256) -> LogUnit.transferAmount
REF_3(uint256) (->LogUnit) := _am(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Log.push(LogUnit)

IRs:
REF_5 -> LENGTH Log
TMP_4(uint256) := REF_5(uint256)
TMP_5(uint256) = TMP_4 + 1
REF_5(uint256) (->Log) := TMP_5(uint256)
REF_6(ETH_MIXER.Transfer) -> Log[TMP_4]
REF_6(ETH_MIXER.Transfer) (->Log) := LogUnit(ETH_MIXER.Transfer)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
creator.send(creatorFee)

IRs:
TMP_6 = SEND dest:creator value:creatorFee""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
_adr.send(_am)

IRs:
TMP_7 = SEND dest:_adr value:_am""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
feePaid += creatorFee

IRs:
feePaid(uint256) = feePaid + creatorFee""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
totalTransfered += _am

IRs:
totalTransfered(uint256) = totalTransfered + _am""];
11->12;
12[label=""Node Type: END_IF 12
""];
}
",0,1,0,0,msg.value > 1000000000000000000;require(bool)(msg.sender == tx.origin);;;LogUnit.timeStamp = now;LogUnit.currContractBallance = this.balance;LogUnit.transferAmount = _am;Log.push(LogUnit);creator.send(creatorFee);_adr.send(_am);feePaid += creatorFee;totalTransfered += _am
./0x53877b7c93c80c9631c73c5feda1e421d836a39c_ext.sol,CryptaurDepository.payInternal,351,364,"REF_164(uint256) -> balances[_buyer],TMP_198(bool) = REF_164 >= _amount,TMP_199(None) = SOLIDITY_CALL require(bool)(TMP_198),TMP_200(bool) = cryptaurRewards != 0,TMP_201(bool) = cryptaurReserveFund != 0,TMP_202(bool) = TMP_200 && TMP_201,CONDITION TMP_202,TMP_203 = CONVERT cryptaurRewards to CryptaurRewards,TMP_204(uint256) = HIGH_LEVEL_CALL, dest:TMP_203(CryptaurRewards), function:payment, arguments:['_buyer', '_seller', '_amount', '_opinionLeader']  ,fee(uint256) := TMP_204(uint256),REF_166(uint256) -> balances[_buyer],REF_166(-> balances) = REF_166 - _amount,REF_167(uint256) -> balances[_seller],TMP_205(uint256) = _amount - fee,REF_167(-> balances) = REF_167 + TMP_205,TMP_206(bool) = fee != 0,CONDITION TMP_206,REF_168(uint256) -> balances[cryptaurReserveFund],REF_168(-> balances) = REF_168 + fee,TMP_207 = CONVERT cryptaurReserveFund to CryputarReserveFund,HIGH_LEVEL_CALL, dest:TMP_207(CryputarReserveFund), function:depositNotification, arguments:['_amount']  ,Emit Payment(_buyer,_seller,_amount,_opinionLeader,False)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[_buyer] >= _amount)

IRs:
REF_164(uint256) -> balances[_buyer]
TMP_198(bool) = REF_164 >= _amount
TMP_199(None) = SOLIDITY_CALL require(bool)(TMP_198)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
cryptaurRewards != 0 && cryptaurReserveFund != 0

IRs:
TMP_200(bool) = cryptaurRewards != 0
TMP_201(bool) = cryptaurReserveFund != 0
TMP_202(bool) = TMP_200 && TMP_201
CONDITION TMP_202""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
fee = CryptaurRewards(cryptaurRewards).payment(_buyer,_seller,_amount,_opinionLeader)

IRs:
TMP_203 = CONVERT cryptaurRewards to CryptaurRewards
TMP_204(uint256) = HIGH_LEVEL_CALL, dest:TMP_203(CryptaurRewards), function:payment, arguments:['_buyer', '_seller', '_amount', '_opinionLeader']  
fee(uint256) := TMP_204(uint256)""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[_buyer] -= _amount

IRs:
REF_166(uint256) -> balances[_buyer]
REF_166(-> balances) = REF_166 - _amount""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[_seller] += _amount - fee

IRs:
REF_167(uint256) -> balances[_seller]
TMP_205(uint256) = _amount - fee
REF_167(-> balances) = REF_167 + TMP_205""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
fee != 0

IRs:
TMP_206(bool) = fee != 0
CONDITION TMP_206""];
8->9[label=""True""];
8->11[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
balances[cryptaurReserveFund] += fee

IRs:
REF_168(uint256) -> balances[cryptaurReserveFund]
REF_168(-> balances) = REF_168 + fee""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
CryputarReserveFund(cryptaurReserveFund).depositNotification(_amount)

IRs:
TMP_207 = CONVERT cryptaurReserveFund to CryputarReserveFund
HIGH_LEVEL_CALL, dest:TMP_207(CryputarReserveFund), function:depositNotification, arguments:['_amount']  ""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
Payment(_buyer,_seller,_amount,_opinionLeader,false)

IRs:
Emit Payment(_buyer,_seller,_amount,_opinionLeader,False)""];
}
",0,1,0,0,"require(bool)(balances[_buyer] >= _amount);;cryptaurRewards != 0 && cryptaurReserveFund != 0;fee = CryptaurRewards(cryptaurRewards).payment(_buyer,_seller,_amount,_opinionLeader);;balances[_buyer] -= _amount;balances[_seller] += _amount - fee;fee != 0;balances[cryptaurReserveFund] += fee;;CryputarReserveFund(cryptaurReserveFund).depositNotification(_amount);Payment(_buyer,_seller,_amount,_opinionLeader,false)"
./0x3ff9ba3001e61d5833208bef78ea5c268d418398_ext.sol,BurnToken.burn,48,54,"REF_30(uint256) -> balanceOf[msg.sender],TMP_34(bool) = REF_30 >= _value,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),REF_31(uint256) -> balanceOf[msg.sender],REF_31(-> balanceOf) = REF_31 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_30(uint256) -> balanceOf[msg.sender]
TMP_34(bool) = REF_30 >= _value
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_31(uint256) -> balanceOf[msg.sender]
REF_31(-> balanceOf) = REF_31 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x5b7cfbee45509b89417f26bbc28a8de11bca3726_ext.sol,AirdropSmart.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x728d52789bdcb8e4b76172c0120db8ef97914f64_ext.sol,GameofGold.dividendsOf,561,567,"REF_53(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_98(uint256) = profitPerShare_ * REF_53,TMP_99 = CONVERT TMP_98 to int256,REF_54(int256) -> payoutsTo_[_customerAddress],TMP_100(int256) = TMP_99 - REF_54,TMP_101 = CONVERT TMP_100 to uint256,TMP_102(uint256) = TMP_101 / magnitude,RETURN TMP_102","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_53(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_98(uint256) = profitPerShare_ * REF_53
TMP_99 = CONVERT TMP_98 to int256
REF_54(int256) -> payoutsTo_[_customerAddress]
TMP_100(int256) = TMP_99 - REF_54
TMP_101 = CONVERT TMP_100 to uint256
TMP_102(uint256) = TMP_101 / magnitude
RETURN TMP_102""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x41ebb67c868f5f28bcd823ddbf39c0f32b191256_ext.sol,StandardToken.transfer,39,48,"REF_0(uint256) -> balances[msg.sender],TMP_14(bool) = REF_0 >= _value,TMP_15(bool) = _value > 0,TMP_16(bool) = TMP_14 && TMP_15,CONDITION TMP_16,REF_1(uint256) -> balances[msg.sender],REF_1(-> balances) = REF_1 - _value,REF_2(uint256) -> balances[_to],REF_2(-> balances) = REF_2 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[msg.sender] >= _value && _value > 0

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_14(bool) = REF_0 >= _value
TMP_15(bool) = _value > 0
TMP_16(bool) = TMP_14 && TMP_15
CONDITION TMP_16""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_1(-> balances) = REF_1 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_2(uint256) -> balances[_to]
REF_2(-> balances) = REF_2 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[msg.sender] >= _value && _value > 0;balances[msg.sender] -= _value;false;balances[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0x031e0c6a7c91df1bc171d33cccc6988fd2ddeb6f_ext.sol,TopCoinFXToken.burn,92,97,"REF_19(uint256) -> balanceOf[msg.sender],TMP_30(bool) = REF_19 >= _value,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_20(uint256) -> balanceOf[msg.sender],REF_20(-> balanceOf) = REF_20 - _value,REF_21(uint256) -> balanceOf[0],REF_21(-> balanceOf) = REF_21 + _value,Emit Transfer(msg.sender,0,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_19(uint256) -> balanceOf[msg.sender]
TMP_30(bool) = REF_19 >= _value
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_20(uint256) -> balanceOf[msg.sender]
REF_20(-> balanceOf) = REF_20 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[0x0] += _value

IRs:
REF_21(uint256) -> balanceOf[0]
REF_21(-> balanceOf) = REF_21 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,0x0,_value)

IRs:
Emit Transfer(msg.sender,0,_value)""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;balanceOf[0x0] += _value;Transfer(msg.sender,0x0,_value)"
./0x209f98bc320133681458125bc57ecc03718311cc_ext.sol,bjTest.Distribution,104,119,"TMP_46(uint256) = TotalRate - Commission,TMP_47(uint256) = TMP_46 / AllCaptcha,BetOverlap(uint256) := TMP_47(uint256),REF_26(bjTest.BJJraundHis) -> BJJhis[JoustNum],REF_27(uint256) -> REF_26.JoustNum,REF_27(uint256) (->BJJhis) := JoustNum(uint256),REF_28(bjTest.BJJraundHis) -> BJJhis[JoustNum],REF_29(uint256) -> REF_28.CapAmouth,REF_29(uint256) (->BJJhis) := AllCaptcha(uint256),REF_30(bjTest.BJJraundHis) -> BJJhis[JoustNum],REF_31(uint256) -> REF_30.BetOverlap,REF_31(uint256) (->BJJhis) := BetOverlap(uint256),REF_32(bjTest.BJJraundHis) -> BJJhis[JoustNum],REF_33(string) -> REF_32.Cap1,REF_33(string) (->BJJhis) := Ast(string),REF_34(bjTest.BJJraundHis) -> BJJhis[JoustNum],REF_35(string) -> REF_34.Cap2,REF_35(string) (->BJJhis) := Bst(string),REF_36(bjTest.BJJraundHis) -> BJJhis[JoustNum],REF_37(string) -> REF_36.Cap3,REF_37(string) (->BJJhis) := Cst(string),Emit BJJhist(JoustNum,AllCaptcha,BetOverlap,Ast,Bst,Cst),i(uint256) := 1(uint256),TMP_49(bool) = i < 9,CONDITION TMP_49,REF_38(mapping(uint256 => bjTest.BJJtab)) -> BJJtable[JoustNum],REF_39(bjTest.BJJtab) -> REF_38[i],REF_40(uint256) -> REF_39.Winning,REF_41(mapping(uint256 => bjTest.BJJtab)) -> BJJtable[JoustNum],REF_42(bjTest.BJJtab) -> REF_41[i],REF_43(uint256) -> REF_42.CoincidNum,TMP_50(uint256) = REF_43 * BetOverlap,REF_40(uint256) (->BJJtable) := TMP_50(uint256),REF_44(mapping(uint256 => bjTest.BJJtab)) -> BJJtable[JoustNum],REF_45(bjTest.BJJtab) -> REF_44[i],REF_46(uint256) -> REF_45.Winning,Winn(uint256) := REF_46(uint256),REF_47(mapping(uint256 => bjTest.BJJtab)) -> BJJtable[JoustNum],REF_48(bjTest.BJJtab) -> REF_47[i],REF_49(uint256) -> REF_48.UserNumber,REF_50(mapping(uint256 => bjTest.BJJtab)) -> BJJtable[JoustNum],REF_51(bjTest.BJJtab) -> REF_50[i],REF_52(address) -> REF_51.UserAddress,REF_53(mapping(uint256 => bjTest.BJJtab)) -> BJJtable[JoustNum],REF_54(bjTest.BJJtab) -> REF_53[i],REF_55(uint256) -> REF_54.CoincidNum,Emit BJJraund(REF_49,REF_52,REF_55,Winn),TMP_52(uint256) := i(uint256),i(uint256) = i + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
BetOverlap = (TotalRate - Commission) / AllCaptcha

IRs:
TMP_46(uint256) = TotalRate - Commission
TMP_47(uint256) = TMP_46 / AllCaptcha
BetOverlap(uint256) := TMP_47(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
BJJhis[JoustNum].JoustNum = JoustNum

IRs:
REF_26(bjTest.BJJraundHis) -> BJJhis[JoustNum]
REF_27(uint256) -> REF_26.JoustNum
REF_27(uint256) (->BJJhis) := JoustNum(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
BJJhis[JoustNum].CapAmouth = AllCaptcha

IRs:
REF_28(bjTest.BJJraundHis) -> BJJhis[JoustNum]
REF_29(uint256) -> REF_28.CapAmouth
REF_29(uint256) (->BJJhis) := AllCaptcha(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
BJJhis[JoustNum].BetOverlap = BetOverlap

IRs:
REF_30(bjTest.BJJraundHis) -> BJJhis[JoustNum]
REF_31(uint256) -> REF_30.BetOverlap
REF_31(uint256) (->BJJhis) := BetOverlap(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
BJJhis[JoustNum].Cap1 = Ast

IRs:
REF_32(bjTest.BJJraundHis) -> BJJhis[JoustNum]
REF_33(string) -> REF_32.Cap1
REF_33(string) (->BJJhis) := Ast(string)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
BJJhis[JoustNum].Cap2 = Bst

IRs:
REF_34(bjTest.BJJraundHis) -> BJJhis[JoustNum]
REF_35(string) -> REF_34.Cap2
REF_35(string) (->BJJhis) := Bst(string)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
BJJhis[JoustNum].Cap3 = Cst

IRs:
REF_36(bjTest.BJJraundHis) -> BJJhis[JoustNum]
REF_37(string) -> REF_36.Cap3
REF_37(string) (->BJJhis) := Cst(string)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
BJJhist(JoustNum,AllCaptcha,BetOverlap,Ast,Bst,Cst)

IRs:
Emit BJJhist(JoustNum,AllCaptcha,BetOverlap,Ast,Bst,Cst)""];
8->11;
9[label=""Node Type: BEGIN_LOOP 9
""];
9->12;
10[label=""Node Type: END_LOOP 10
""];
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
i = 1

IRs:
i(uint256) := 1(uint256)""];
11->9;
12[label=""Node Type: IF_LOOP 12

EXPRESSION:
i < 9

IRs:
TMP_49(bool) = i < 9
CONDITION TMP_49""];
12->13[label=""True""];
12->10[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
BJJtable[JoustNum][i].Winning = BJJtable[JoustNum][i].CoincidNum * BetOverlap

IRs:
REF_38(mapping(uint256 => bjTest.BJJtab)) -> BJJtable[JoustNum]
REF_39(bjTest.BJJtab) -> REF_38[i]
REF_40(uint256) -> REF_39.Winning
REF_41(mapping(uint256 => bjTest.BJJtab)) -> BJJtable[JoustNum]
REF_42(bjTest.BJJtab) -> REF_41[i]
REF_43(uint256) -> REF_42.CoincidNum
TMP_50(uint256) = REF_43 * BetOverlap
REF_40(uint256) (->BJJtable) := TMP_50(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
Winn = BJJtable[JoustNum][i].Winning

IRs:
REF_44(mapping(uint256 => bjTest.BJJtab)) -> BJJtable[JoustNum]
REF_45(bjTest.BJJtab) -> REF_44[i]
REF_46(uint256) -> REF_45.Winning
Winn(uint256) := REF_46(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
BJJraund(BJJtable[JoustNum][i].UserNumber,BJJtable[JoustNum][i].UserAddress,BJJtable[JoustNum][i].CoincidNum,Winn)

IRs:
REF_47(mapping(uint256 => bjTest.BJJtab)) -> BJJtable[JoustNum]
REF_48(bjTest.BJJtab) -> REF_47[i]
REF_49(uint256) -> REF_48.UserNumber
REF_50(mapping(uint256 => bjTest.BJJtab)) -> BJJtable[JoustNum]
REF_51(bjTest.BJJtab) -> REF_50[i]
REF_52(address) -> REF_51.UserAddress
REF_53(mapping(uint256 => bjTest.BJJtab)) -> BJJtable[JoustNum]
REF_54(bjTest.BJJtab) -> REF_53[i]
REF_55(uint256) -> REF_54.CoincidNum
Emit BJJraund(REF_49,REF_52,REF_55,Winn)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
i ++

IRs:
TMP_52(uint256) := i(uint256)
i(uint256) = i + 1""];
16->12;
}
",0,1,0,0,"BetOverlap = (TotalRate - Commission) / AllCaptcha;BJJhis[JoustNum].JoustNum = JoustNum;BJJhis[JoustNum].CapAmouth = AllCaptcha;BJJhis[JoustNum].BetOverlap = BetOverlap;BJJhis[JoustNum].Cap1 = Ast;BJJhis[JoustNum].Cap2 = Bst;BJJhis[JoustNum].Cap3 = Cst;BJJhist(JoustNum,AllCaptcha,BetOverlap,Ast,Bst,Cst);i = 1;;i < 9;;BJJtable[JoustNum][i].Winning = BJJtable[JoustNum][i].CoincidNum * BetOverlap;Winn = BJJtable[JoustNum][i].Winning;BJJraund(BJJtable[JoustNum][i].UserNumber,BJJtable[JoustNum][i].UserAddress,BJJtable[JoustNum][i].CoincidNum,Winn);i ++"
./0x28f2c01a3d86ee4faf037147f0aeb49c2eab47ce_ext.sol,DESH.totalSupply,124,126,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0xbcdbb16c645816842b6ae7ebea8baa4b35203e73_ext.sol,NetkillerCashier.transfer,18,26,"amount(uint256) = amount + _value,TMP_0(bool) = amounteth < msg.value,CONDITION TMP_0,amounteth(uint256) = amounteth + msg.value,amounteth(uint256) = amounteth - msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
amount += _value

IRs:
amount(uint256) = amount + _value""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
amounteth < msg.value

IRs:
TMP_0(bool) = amounteth < msg.value
CONDITION TMP_0""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
amounteth += msg.value

IRs:
amounteth(uint256) = amounteth + msg.value""];
3->5;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
amounteth -= msg.value

IRs:
amounteth(uint256) = amounteth - msg.value""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,1,0,0,amount += _value;amounteth < msg.value;amounteth += msg.value;amounteth -= msg.value;
./0xb49c61b2da035bf198815a0d43f108530a834cce_ext.sol,SafeMath.add,27,31,"TMP_10(uint256) = a + b,c(uint256) := TMP_10(uint256),TMP_11(bool) = c >= a,TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11),RETURN c","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_10(uint256) = a + b
c(uint256) := TMP_10(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_11(bool) = c >= a
TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c""];
}
",0,1,0,0,c = a + b;assert(bool)(c >= a);c
./0x5ab6aad76a702591724b7788b0fbea6292638561_ext.sol,CIC.mintToken,58,63,"REF_1(uint256) -> balanceOf[target],REF_1(-> balanceOf) = REF_1 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,owner,mintedAmount),Emit Transfer(owner,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_1(uint256) -> balanceOf[target]
REF_1(-> balanceOf) = REF_1 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,owner,mintedAmount)

IRs:
Emit Transfer(0,owner,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(owner,target,mintedAmount)

IRs:
Emit Transfer(owner,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,owner,mintedAmount);Transfer(owner,target,mintedAmount)"
./0x1f002ba292d85239fee400a04b21bb3aa4777461_ext.sol,FLTTToken.amountBurned,204,206,"TMP_41(uint256) = _initialSupply - _currentSupply,RETURN TMP_41,RETURN amountBurned","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_initialSupply - _currentSupply

IRs:
TMP_41(uint256) = _initialSupply - _currentSupply
RETURN TMP_41""];
2[label=""Node Type: RETURN 2

EXPRESSION:
amountBurned

IRs:
RETURN amountBurned""];
}
",0,1,0,0,_initialSupply - _currentSupply;amountBurned
./0x2e8e02e29bdc2ef651c351d70eceac23f6349c6f_ext.sol,StandardToken.approveAndCall,267,272,"REF_50(mapping(address => uint256)) -> allowed[msg.sender],REF_51(uint256) -> REF_50[spender],REF_51(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_56 = CONVERT spender to ApproveAndCallFallBack,TMP_57 = CONVERT this to address,HIGH_LEVEL_CALL, dest:TMP_56(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'TMP_57', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_50(mapping(address => uint256)) -> allowed[msg.sender]
REF_51(uint256) -> REF_50[spender]
REF_51(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,address(this),data)

IRs:
TMP_56 = CONVERT spender to ApproveAndCallFallBack
TMP_57 = CONVERT this to address
HIGH_LEVEL_CALL, dest:TMP_56(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'TMP_57', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,address(this),data);true;success"
./0xef8a2c1bc94e630463293f71bf5414d13e80f62d_ext.sol,Synth.transferFromSenderPaysFee,2546,2562,"TMP_768(uint256) = HIGH_LEVEL_CALL, dest:feePool(IFeePool), function:transferFeeIncurred, arguments:['value']  ,fee(uint256) := TMP_768(uint256),TMP_769(uint256) = HIGH_LEVEL_CALL, dest:tokenState(TokenState), function:allowance, arguments:['from', 'messageSender']  ,TMP_770(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['value', 'fee'] ,TMP_771(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_769', 'TMP_770'] ,HIGH_LEVEL_CALL, dest:tokenState(TokenState), function:setAllowance, arguments:['from', 'messageSender', 'TMP_771']  ,TMP_773(bool) = HIGH_LEVEL_CALL, dest:synthetix(Synthetix), function:synthInitiatedFeePayment, arguments:['from', 'currencyKey', 'fee']  ,TMP_774(bool) = INTERNAL_CALL, Synth._internalTransfer(address,address,uint256,bytes)(from,to,value,empty),RETURN TMP_774,MODIFIER_CALL, Proxyable.optionalProxy()(),MODIFIER_CALL, Synth.notFeeAddress(address)(from)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
fee = feePool.transferFeeIncurred(value)

IRs:
TMP_768(uint256) = HIGH_LEVEL_CALL, dest:feePool(IFeePool), function:transferFeeIncurred, arguments:['value']  
fee(uint256) := TMP_768(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
tokenState.setAllowance(from,messageSender,tokenState.allowance(from,messageSender).sub(value.add(fee)))

IRs:
TMP_769(uint256) = HIGH_LEVEL_CALL, dest:tokenState(TokenState), function:allowance, arguments:['from', 'messageSender']  
TMP_770(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['value', 'fee'] 
TMP_771(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_769', 'TMP_770'] 
HIGH_LEVEL_CALL, dest:tokenState(TokenState), function:setAllowance, arguments:['from', 'messageSender', 'TMP_771']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
synthetix.synthInitiatedFeePayment(from,currencyKey,fee)

IRs:
TMP_773(bool) = HIGH_LEVEL_CALL, dest:synthetix(Synthetix), function:synthInitiatedFeePayment, arguments:['from', 'currencyKey', 'fee']  ""];
3->4;
4[label=""Node Type: NEW VARIABLE 4
""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
_internalTransfer(from,to,value,empty)

IRs:
TMP_774(bool) = INTERNAL_CALL, Synth._internalTransfer(address,address,uint256,bytes)(from,to,value,empty)
RETURN TMP_774""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
optionalProxy()

IRs:
MODIFIER_CALL, Proxyable.optionalProxy()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
notFeeAddress(from)

IRs:
MODIFIER_CALL, Synth.notFeeAddress(address)(from)""];
7->1;
}
",0,1,0,0,"optionalProxy();fee = feePool.transferFeeIncurred(value);tokenState.setAllowance(from,messageSender,tokenState.allowance(from,messageSender).sub(value.add(fee)));synthetix.synthInitiatedFeePayment(from,currencyKey,fee);;_internalTransfer(from,to,value,empty);notFeeAddress(from)"
./0x543e9c99addfc7c6fa158359019fd8f530334396_ext.sol,EPCToken.burn,132,138,"REF_31(uint256) -> balances[msg.sender],TMP_48(bool) = REF_31 >= amount,TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48),REF_32(uint256) -> balances[msg.sender],REF_32(-> balances) = REF_32 - amount,totalSupply(uint256) = totalSupply - amount,Emit Burn(msg.sender,amount),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= amount)

IRs:
REF_31(uint256) -> balances[msg.sender]
TMP_48(bool) = REF_31 >= amount
TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= amount

IRs:
REF_32(uint256) -> balances[msg.sender]
REF_32(-> balances) = REF_32 - amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= amount

IRs:
totalSupply(uint256) = totalSupply - amount""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,amount)

IRs:
Emit Burn(msg.sender,amount)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= amount);balances[msg.sender] -= amount;totalSupply -= amount;Burn(msg.sender,amount);true;success"
./0x743bba828949fce4557bad9a52db488ce6fdff8d_ext.sol,ZHSH.transferFrom,36,46,"REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],allowance(uint256) := REF_5(uint256),REF_6(uint256) -> balances[_from],TMP_3(bool) = REF_6 >= _value,TMP_4(bool) = allowance >= _value,TMP_5(bool) = TMP_3 && TMP_4,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_7(uint256) -> balances[_to],REF_7(-> balances) = REF_7 + _value,REF_8(uint256) -> balances[_from],REF_8(-> balances) = REF_8 - _value,TMP_7(bool) = allowance < MAX_UINT256,CONDITION TMP_7,REF_9(mapping(address => uint256)) -> allowed[_from],REF_10(uint256) -> REF_9[msg.sender],REF_10(-> allowed) = REF_10 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
allowance = allowed[_from][msg.sender]

IRs:
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
allowance(uint256) := REF_5(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] >= _value && allowance >= _value)

IRs:
REF_6(uint256) -> balances[_from]
TMP_3(bool) = REF_6 >= _value
TMP_4(bool) = allowance >= _value
TMP_5(bool) = TMP_3 && TMP_4
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_7(uint256) -> balances[_to]
REF_7(-> balances) = REF_7 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] -= _value

IRs:
REF_8(uint256) -> balances[_from]
REF_8(-> balances) = REF_8 - _value""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
allowance < MAX_UINT256

IRs:
TMP_7(bool) = allowance < MAX_UINT256
CONDITION TMP_7""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_9(mapping(address => uint256)) -> allowed[_from]
REF_10(uint256) -> REF_9[msg.sender]
REF_10(-> allowed) = REF_10 - _value""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: RETURN 10

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowance = allowed[_from][msg.sender];require(bool)(balances[_from] >= _value && allowance >= _value);balances[_to] += _value;balances[_from] -= _value;allowance < MAX_UINT256;allowed[_from][msg.sender] -= _value;;Transfer(_from,_to,_value);true;success"
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.forwardWei,2,2,"TMP_252 = UnaryType.BANG paidversion ,CONDITION TMP_252,TMP_253(bool) = msg.value > 0,CONDITION TMP_253,Transfer dest:owner value:msg.value,TMP_255(bool) = msg.value > 0,CONDITION TMP_255,Transfer dest:wallet value:msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
! paidversion

IRs:
TMP_252 = UnaryType.BANG paidversion 
CONDITION TMP_252""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
msg.value > 0

IRs:
TMP_253(bool) = msg.value > 0
CONDITION TMP_253""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(msg.value)

IRs:
Transfer dest:owner value:msg.value""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->8;
5[label=""Node Type: IF 5

EXPRESSION:
msg.value > 0

IRs:
TMP_255(bool) = msg.value > 0
CONDITION TMP_255""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
wallet.transfer(msg.value)

IRs:
Transfer dest:wallet value:msg.value""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: END_IF 8
""];
}
",0,1,1,0,! paidversion;msg.value > 0;msg.value > 0;owner.transfer(msg.value);;;wallet.transfer(msg.value);
./0x5abaff0b83f81dc061c590aadcba013c69237fd7_ext.sol,CryptoJade.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x4c8c4659f734294d9561c8b0efc210028ed12052_ext.sol,company_acc.withdraw,13,21,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2),TMP_4(bool) = keyHash == TMP_3,CONDITION TMP_4,TMP_5(bool) = msg.value > 400000000000000000,CONDITION TMP_5,TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),Transfer dest:msg.sender value:TMP_7","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
keyHash == keccak256()(abi.encodePacked(key))

IRs:
TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2)
TMP_4(bool) = keyHash == TMP_3
CONDITION TMP_4""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
msg.value > 400000000000000000

IRs:
TMP_5(bool) = msg.value > 400000000000000000
CONDITION TMP_5""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
Transfer dest:msg.sender value:TMP_7""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,1,0,0,require(bool)(msg.sender == tx.origin);keyHash == keccak256()(abi.encodePacked(key));msg.value > 400000000000000000;;msg.sender.transfer(address(this).balance);
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.singleUserSignUp,2,2,"TMP_173(bool) = userSignupCount <= maxSignup,CONDITION TMP_173,REF_104(bool) -> signups[_address],TMP_174 = UnaryType.BANG REF_104 ,REF_105(KahnDistributionCentre.User) -> bounties[_address],REF_106(address) -> REF_105.user_address,TMP_175(bool) = REF_106 != _address,TMP_176(bool) = TMP_174 && TMP_175,TMP_177(bool) = msg.value >= minsignupeth,TMP_178(bool) = TMP_176 && TMP_177,CONDITION TMP_178,TMP_179(bool) = payoutNow != 1,TMP_180(bool) = payoutNow != 2,TMP_181(bool) = TMP_179 || TMP_180,CONDITION TMP_181,REF_107(bool) -> signups[_address],REF_107(bool) (->signups) := True(bool),temrew(uint256) := 0(uint256),TMP_182(bool) = payStyle == 1,CONDITION TMP_182,temrew(uint256) := fixPayAmt(uint256),REF_108(KahnDistributionCentre.User) -> bounties[_address],TMP_183(KahnDistributionCentre.User) = new User(_address,now,temrew,False,0,0,True),REF_108(KahnDistributionCentre.User) (->bounties) := TMP_183(KahnDistributionCentre.User),REF_109(bool) -> signups[_address],REF_109(bool) (->signups) := True(bool),REF_111 -> LENGTH bountyaddress,TMP_186(uint256) := REF_111(uint256),TMP_187(uint256) = TMP_186 + 1,REF_111(uint256) (->bountyaddress) := TMP_187(uint256),REF_112(address) -> bountyaddress[TMP_186],REF_112(address) (->bountyaddress) := _address(address),TMP_185(None) = TMP_184 - 1,TMP_188(uint256) := userSignupCount(uint256),userSignupCount(uint256) = userSignupCount + 1,INTERNAL_CALL, KahnDistributionCentre.forwardWei()(),MODIFIER_CALL, KahnDistributionCentre.ifNotStartExp()(),MODIFIER_CALL, KahnDistributionCentre.ifNotPaused()(),MODIFIER_CALL, KahnDistributionCentre.ifNotBlacklisted()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->17;
1[label=""Node Type: IF 1

EXPRESSION:
userSignupCount <= maxSignup

IRs:
TMP_173(bool) = userSignupCount <= maxSignup
CONDITION TMP_173""];
1->2[label=""True""];
1->15[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
! signups[_address] && bounties[_address].user_address != _address && msg.value >= minsignupeth

IRs:
REF_104(bool) -> signups[_address]
TMP_174 = UnaryType.BANG REF_104 
REF_105(KahnDistributionCentre.User) -> bounties[_address]
REF_106(address) -> REF_105.user_address
TMP_175(bool) = REF_106 != _address
TMP_176(bool) = TMP_174 && TMP_175
TMP_177(bool) = msg.value >= minsignupeth
TMP_178(bool) = TMP_176 && TMP_177
CONDITION TMP_178""];
2->3[label=""True""];
2->14[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
payoutNow != 1 || payoutNow != 2

IRs:
TMP_179(bool) = payoutNow != 1
TMP_180(bool) = payoutNow != 2
TMP_181(bool) = TMP_179 || TMP_180
CONDITION TMP_181""];
3->4[label=""True""];
3->13[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
signups[_address] = true

IRs:
REF_107(bool) -> signups[_address]
REF_107(bool) (->signups) := True(bool)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
temrew = 0

IRs:
temrew(uint256) := 0(uint256)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
payStyle == 1

IRs:
TMP_182(bool) = payStyle == 1
CONDITION TMP_182""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
temrew = fixPayAmt

IRs:
temrew(uint256) := fixPayAmt(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
bounties[_address] = User(_address,now,temrew,false,0,0,true)

IRs:
REF_108(KahnDistributionCentre.User) -> bounties[_address]
TMP_183(KahnDistributionCentre.User) = new User(_address,now,temrew,False,0,0,True)
REF_108(KahnDistributionCentre.User) (->bounties) := TMP_183(KahnDistributionCentre.User)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
signups[_address] = true

IRs:
REF_109(bool) -> signups[_address]
REF_109(bool) (->signups) := True(bool)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
bountyaddress.push(_address) - 1

IRs:
REF_111 -> LENGTH bountyaddress
TMP_186(uint256) := REF_111(uint256)
TMP_187(uint256) = TMP_186 + 1
REF_111(uint256) (->bountyaddress) := TMP_187(uint256)
REF_112(address) -> bountyaddress[TMP_186]
REF_112(address) (->bountyaddress) := _address(address)
TMP_185(None) = TMP_184 - 1""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
userSignupCount ++

IRs:
TMP_188(uint256) := userSignupCount(uint256)
userSignupCount(uint256) = userSignupCount + 1""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
forwardWei()

IRs:
INTERNAL_CALL, KahnDistributionCentre.forwardWei()()""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
ifNotStartExp()

IRs:
MODIFIER_CALL, KahnDistributionCentre.ifNotStartExp()()""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
ifNotPaused()

IRs:
MODIFIER_CALL, KahnDistributionCentre.ifNotPaused()()""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
ifNotBlacklisted()

IRs:
MODIFIER_CALL, KahnDistributionCentre.ifNotBlacklisted()()""];
19->1;
}
",0,1,1,0,"ifNotStartExp();userSignupCount <= maxSignup;! signups[_address] && bounties[_address].user_address != _address && msg.value >= minsignupeth;;payoutNow != 1 || payoutNow != 2;;signups[_address] = true;;temrew = 0;payStyle == 1;temrew = fixPayAmt;;bounties[_address] = User(_address,now,temrew,false,0,0,true);signups[_address] = true;bountyaddress.push(_address) - 1;userSignupCount ++;forwardWei();ifNotPaused();ifNotBlacklisted()"
./0x7176a57a53a87a800a6d7ec33c8479a8deb57d8b_ext.sol,ARIToken.burnTokens,95,112,"REF_2(ARIToken.Phase) -> Phase.Migrating,TMP_7(bool) = currentPhase != REF_2,CONDITION TMP_7,REF_3(uint256) -> balance[_owner],tokens(uint256) := REF_3(uint256),TMP_8(bool) = tokens == 0,CONDITION TMP_8,REF_4(uint256) -> balance[_owner],REF_4(uint256) (->balance) := 0(uint256),totalSupply(uint256) = totalSupply - tokens,Emit LogBurn(_owner,tokens),TMP_10(bool) = totalSupply == 0,CONDITION TMP_10,REF_5(ARIToken.Phase) -> Phase.Migrated,currentPhase(ARIToken.Phase) := REF_5(ARIToken.Phase),REF_6(ARIToken.Phase) -> Phase.Migrated,Emit LogPhaseSwitch(REF_6),MODIFIER_CALL, ARIToken.onlyCrowdsaleManager()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->15;
1[label=""Node Type: IF 1

EXPRESSION:
currentPhase != Phase.Migrating

IRs:
REF_2(ARIToken.Phase) -> Phase.Migrating
TMP_7(bool) = currentPhase != REF_2
CONDITION TMP_7""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
tokens = balance[_owner]

IRs:
REF_3(uint256) -> balance[_owner]
tokens(uint256) := REF_3(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
tokens == 0

IRs:
TMP_8(bool) = tokens == 0
CONDITION TMP_8""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: THROW 6
""];
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balance[_owner] = 0

IRs:
REF_4(uint256) -> balance[_owner]
REF_4(uint256) (->balance) := 0(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
totalSupply -= tokens

IRs:
totalSupply(uint256) = totalSupply - tokens""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
LogBurn(_owner,tokens)

IRs:
Emit LogBurn(_owner,tokens)""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
totalSupply == 0

IRs:
TMP_10(bool) = totalSupply == 0
CONDITION TMP_10""];
11->12[label=""True""];
11->14[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
currentPhase = Phase.Migrated

IRs:
REF_5(ARIToken.Phase) -> Phase.Migrated
currentPhase(ARIToken.Phase) := REF_5(ARIToken.Phase)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
LogPhaseSwitch(Phase.Migrated)

IRs:
REF_6(ARIToken.Phase) -> Phase.Migrated
Emit LogPhaseSwitch(REF_6)""];
13->14;
14[label=""Node Type: END_IF 14
""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
onlyCrowdsaleManager()

IRs:
MODIFIER_CALL, ARIToken.onlyCrowdsaleManager()()""];
15->1;
}
",0,1,0,0,"onlyCrowdsaleManager();currentPhase != Phase.Migrating;;;tokens = balance[_owner];tokens == 0;;;balance[_owner] = 0;totalSupply -= tokens;LogBurn(_owner,tokens);totalSupply == 0;currentPhase = Phase.Migrated;;LogPhaseSwitch(Phase.Migrated)"
./0x0d6afbb95eec6d35255f8f269c971634a5b3eab0_ext.sol,BOXT.transferFrom,36,46,"REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],allowance(uint256) := REF_5(uint256),REF_6(uint256) -> balances[_from],TMP_3(bool) = REF_6 >= _value,TMP_4(bool) = allowance >= _value,TMP_5(bool) = TMP_3 && TMP_4,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_7(uint256) -> balances[_to],REF_7(-> balances) = REF_7 + _value,REF_8(uint256) -> balances[_from],REF_8(-> balances) = REF_8 - _value,TMP_7(bool) = allowance < MAX_UINT256,CONDITION TMP_7,REF_9(mapping(address => uint256)) -> allowed[_from],REF_10(uint256) -> REF_9[msg.sender],REF_10(-> allowed) = REF_10 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
allowance = allowed[_from][msg.sender]

IRs:
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
allowance(uint256) := REF_5(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] >= _value && allowance >= _value)

IRs:
REF_6(uint256) -> balances[_from]
TMP_3(bool) = REF_6 >= _value
TMP_4(bool) = allowance >= _value
TMP_5(bool) = TMP_3 && TMP_4
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_7(uint256) -> balances[_to]
REF_7(-> balances) = REF_7 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] -= _value

IRs:
REF_8(uint256) -> balances[_from]
REF_8(-> balances) = REF_8 - _value""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
allowance < MAX_UINT256

IRs:
TMP_7(bool) = allowance < MAX_UINT256
CONDITION TMP_7""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_9(mapping(address => uint256)) -> allowed[_from]
REF_10(uint256) -> REF_9[msg.sender]
REF_10(-> allowed) = REF_10 - _value""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: RETURN 10

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowance = allowed[_from][msg.sender];require(bool)(balances[_from] >= _value && allowance >= _value);balances[_to] += _value;balances[_from] -= _value;allowance < MAX_UINT256;allowed[_from][msg.sender] -= _value;;Transfer(_from,_to,_value);true;success"
./0x523dc2c35f1d6071b5cd72cf4d7b670193034824_ext.sol,TokenERC20.burn,62,68,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x5c6a2ece543d3038f98cea1a2a5f0759fbceb8b1_ext.sol,BatchTokensTransfer.batchTokensTransfer,75,86,"REF_0 -> LENGTH _usersWithdrawalAccounts,REF_1 -> LENGTH _amounts,TMP_17(bool) = REF_0 == REF_1,TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17),i(uint256) := 0(uint256),REF_2 -> LENGTH _usersWithdrawalAccounts,TMP_19(bool) = i < REF_2,CONDITION TMP_19,REF_3(address) -> _usersWithdrawalAccounts[i],TMP_20(bool) = REF_3 != 0,CONDITION TMP_20,REF_5(address) -> _usersWithdrawalAccounts[i],REF_6(uint256) -> _amounts[i],TMP_21(bool) = HIGH_LEVEL_CALL, dest:_token(IERC20Token), function:transfer, arguments:['REF_5', 'REF_6']  ,TMP_22(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Ownable.ownerOnly()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_usersWithdrawalAccounts.length == _amounts.length)

IRs:
REF_0 -> LENGTH _usersWithdrawalAccounts
REF_1 -> LENGTH _amounts
TMP_17(bool) = REF_0 == REF_1
TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < _usersWithdrawalAccounts.length

IRs:
REF_2 -> LENGTH _usersWithdrawalAccounts
TMP_19(bool) = i < REF_2
CONDITION TMP_19""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: IF 6

EXPRESSION:
_usersWithdrawalAccounts[i] != 0x0

IRs:
REF_3(address) -> _usersWithdrawalAccounts[i]
TMP_20(bool) = REF_3 != 0
CONDITION TMP_20""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
_token.transfer(_usersWithdrawalAccounts[i],_amounts[i])

IRs:
REF_5(address) -> _usersWithdrawalAccounts[i]
REF_6(uint256) -> _amounts[i]
TMP_21(bool) = HIGH_LEVEL_CALL, dest:_token(IERC20Token), function:transfer, arguments:['REF_5', 'REF_6']  ""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_22(uint256) := i(uint256)
i(uint256) = i + 1""];
9->5;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
ownerOnly()

IRs:
MODIFIER_CALL, Ownable.ownerOnly()()""];
10->1;
}
",0,1,0,0,"ownerOnly();require(bool)(_usersWithdrawalAccounts.length == _amounts.length);i = 0;;i < _usersWithdrawalAccounts.length;;_usersWithdrawalAccounts[i] != 0x0;_token.transfer(_usersWithdrawalAccounts[i],_amounts[i]);;i ++"
./0x0eeb66edff8ccfd85c2181eff81d8275a3b92b8b_ext.sol,OROCoin._transfer,47,63,"TMP_3 = CONVERT 0 to address,TMP_4(bool) = _to != TMP_3,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_1(uint256) -> balanceOf[_from],TMP_6(bool) = REF_1 >= _value,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_2(uint256) -> balanceOf[_to],TMP_8(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_9(bool) = TMP_8 >= REF_3,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_11(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_11(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_13(uint256) = REF_8 + REF_9,TMP_14(bool) = TMP_13 == previousBalances,TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0x0))

IRs:
TMP_3 = CONVERT 0 to address
TMP_4(bool) = _to != TMP_3
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_6(bool) = REF_1 >= _value
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_8(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_9(bool) = TMP_8 >= REF_3
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_11(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_11(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_13(uint256) = REF_8 + REF_9
TMP_14(bool) = TMP_13 == previousBalances
TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)""];
}
",0,1,0,0,"require(bool)(_to != address(0x0));require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x1c0f4c64821d6f8fa96975e20d5bb3ea79eb1071_ext.sol,vault.setup_key,23,28,"TMP_9(bool) = keyHash == 0,CONDITION TMP_9,TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10),keyHash(bytes32) := TMP_11(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
keyHash == 0x0

IRs:
TMP_9(bool) = keyHash == 0
CONDITION TMP_9""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
keyHash = keccak256()(abi.encodePacked(key))

IRs:
TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10)
keyHash(bytes32) := TMP_11(bytes32)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,1,0,0,keyHash == 0x0;keyHash = keccak256()(abi.encodePacked(key));
./0x17987e621eb8c09f62bc10c90204238cc8cbbe94_ext.sol,coc.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xde6c1dd8404827149f6edc09e50476aa0cd7b4ab_ext.sol,SRX.burnFrom,140,148,"REF_19(uint256) -> balanceOf[_from],TMP_22(bool) = REF_19 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_24(bool) = _value <= REF_21,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_22(bool) = REF_19 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_24(bool) = _value <= REF_21
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x188ff41cc7960dd51b3aa802fcb17ba17c41276d_ext.sol,StandardToken.transfer,39,48,"REF_0(uint256) -> balances[msg.sender],TMP_14(bool) = REF_0 >= _value,TMP_15(bool) = _value > 0,TMP_16(bool) = TMP_14 && TMP_15,CONDITION TMP_16,REF_1(uint256) -> balances[msg.sender],REF_1(-> balances) = REF_1 - _value,REF_2(uint256) -> balances[_to],REF_2(-> balances) = REF_2 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[msg.sender] >= _value && _value > 0

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_14(bool) = REF_0 >= _value
TMP_15(bool) = _value > 0
TMP_16(bool) = TMP_14 && TMP_15
CONDITION TMP_16""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_1(-> balances) = REF_1 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_2(uint256) -> balances[_to]
REF_2(-> balances) = REF_2 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[msg.sender] >= _value && _value > 0;balances[msg.sender] -= _value;false;balances[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0x4176f0f2b7c95486a5ae06e3d1b29201a42e7630_ext.sol,Bounty0xEscrow.distributeTokenToAddressesAndAmounts,281,303,"TMP_91 = CONVERT 0 to address,TMP_92(bool) = _host != TMP_91,TMP_93(None) = SOLIDITY_CALL require(bool)(TMP_92),REF_31 -> LENGTH _hunters,REF_32 -> LENGTH _amounts,TMP_94(bool) = REF_31 == REF_32,TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94),totalAmount(uint256) := 0(uint256),j(uint256) := 0(uint256),REF_33 -> LENGTH _amounts,TMP_96(bool) = j < REF_33,CONDITION TMP_96,REF_35(uint256) -> _amounts[j],TMP_97(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalAmount', 'REF_35'] ,totalAmount(uint256) := TMP_97(uint256),TMP_98(uint256) := j(uint256),j(uint256) = j + 1,REF_36(mapping(address => uint256)) -> tokens[_token],REF_37(uint256) -> REF_36[_host],TMP_99(bool) = REF_37 >= totalAmount,TMP_100(None) = SOLIDITY_CALL require(bool)(TMP_99),REF_38(mapping(address => uint256)) -> tokens[_token],REF_39(uint256) -> REF_38[_host],REF_41(mapping(address => uint256)) -> tokens[_token],REF_42(uint256) -> REF_41[_host],TMP_101(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_42', 'totalAmount'] ,REF_39(uint256) (->tokens) := TMP_101(uint256),TMP_102 = CONVERT 0 to address,TMP_103(bool) = _token == TMP_102,CONDITION TMP_103,i(uint256) := 0(uint256),REF_43 -> LENGTH _hunters,TMP_104(bool) = i < REF_43,CONDITION TMP_104,REF_44(address) -> _hunters[i],REF_46(uint256) -> _amounts[i],TMP_105 = SEND dest:REF_44 value:REF_46,TMP_106(None) = SOLIDITY_CALL require(bool)(TMP_105),REF_47(address) -> _hunters[i],REF_48(uint256) -> _amounts[i],Emit Distribution(_token,_host,REF_47,REF_48),TMP_108(uint256) := i(uint256),i(uint256) = i + 1,k(uint256) := 0(uint256),REF_49 -> LENGTH _hunters,TMP_109(bool) = k < REF_49,CONDITION TMP_109,TMP_110 = CONVERT _token to ERC20,REF_51(address) -> _hunters[k],REF_52(uint256) -> _amounts[k],TMP_111(bool) = HIGH_LEVEL_CALL, dest:TMP_110(ERC20), function:transfer, arguments:['REF_51', 'REF_52']  ,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),REF_53(address) -> _hunters[k],REF_54(uint256) -> _amounts[k],Emit Distribution(_token,_host,REF_53,REF_54),TMP_114(uint256) := k(uint256),k(uint256) = k + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->28;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_host != address(0))

IRs:
TMP_91 = CONVERT 0 to address
TMP_92(bool) = _host != TMP_91
TMP_93(None) = SOLIDITY_CALL require(bool)(TMP_92)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_hunters.length == _amounts.length)

IRs:
REF_31 -> LENGTH _hunters
REF_32 -> LENGTH _amounts
TMP_94(bool) = REF_31 == REF_32
TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
totalAmount = 0

IRs:
totalAmount(uint256) := 0(uint256)""];
3->6;
4[label=""Node Type: BEGIN_LOOP 4
""];
4->7;
5[label=""Node Type: END_LOOP 5
""];
5->10;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
j = 0

IRs:
j(uint256) := 0(uint256)""];
6->4;
7[label=""Node Type: IF_LOOP 7

EXPRESSION:
j < _amounts.length

IRs:
REF_33 -> LENGTH _amounts
TMP_96(bool) = j < REF_33
CONDITION TMP_96""];
7->8[label=""True""];
7->5[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
totalAmount = SafeMath.add(totalAmount,_amounts[j])

IRs:
REF_35(uint256) -> _amounts[j]
TMP_97(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalAmount', 'REF_35'] 
totalAmount(uint256) := TMP_97(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
j ++

IRs:
TMP_98(uint256) := j(uint256)
j(uint256) = j + 1""];
9->7;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(tokens[_token][_host] >= totalAmount)

IRs:
REF_36(mapping(address => uint256)) -> tokens[_token]
REF_37(uint256) -> REF_36[_host]
TMP_99(bool) = REF_37 >= totalAmount
TMP_100(None) = SOLIDITY_CALL require(bool)(TMP_99)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
tokens[_token][_host] = SafeMath.sub(tokens[_token][_host],totalAmount)

IRs:
REF_38(mapping(address => uint256)) -> tokens[_token]
REF_39(uint256) -> REF_38[_host]
REF_41(mapping(address => uint256)) -> tokens[_token]
REF_42(uint256) -> REF_41[_host]
TMP_101(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_42', 'totalAmount'] 
REF_39(uint256) (->tokens) := TMP_101(uint256)""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
_token == address(0)

IRs:
TMP_102 = CONVERT 0 to address
TMP_103(bool) = _token == TMP_102
CONDITION TMP_103""];
12->15[label=""True""];
12->22[label=""False""];
13[label=""Node Type: BEGIN_LOOP 13
""];
13->16;
14[label=""Node Type: END_LOOP 14
""];
14->27;
15[label=""Node Type: NEW VARIABLE 15

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
15->13;
16[label=""Node Type: IF_LOOP 16

EXPRESSION:
i < _hunters.length

IRs:
REF_43 -> LENGTH _hunters
TMP_104(bool) = i < REF_43
CONDITION TMP_104""];
16->17[label=""True""];
16->14[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
require(bool)(_hunters[i].send(_amounts[i]))

IRs:
REF_44(address) -> _hunters[i]
REF_46(uint256) -> _amounts[i]
TMP_105 = SEND dest:REF_44 value:REF_46
TMP_106(None) = SOLIDITY_CALL require(bool)(TMP_105)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
Distribution(_token,_host,_hunters[i],_amounts[i])

IRs:
REF_47(address) -> _hunters[i]
REF_48(uint256) -> _amounts[i]
Emit Distribution(_token,_host,REF_47,REF_48)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
i ++

IRs:
TMP_108(uint256) := i(uint256)
i(uint256) = i + 1""];
19->16;
20[label=""Node Type: BEGIN_LOOP 20
""];
20->23;
21[label=""Node Type: END_LOOP 21
""];
21->27;
22[label=""Node Type: NEW VARIABLE 22

EXPRESSION:
k = 0

IRs:
k(uint256) := 0(uint256)""];
22->20;
23[label=""Node Type: IF_LOOP 23

EXPRESSION:
k < _hunters.length

IRs:
REF_49 -> LENGTH _hunters
TMP_109(bool) = k < REF_49
CONDITION TMP_109""];
23->24[label=""True""];
23->21[label=""False""];
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
require(bool)(ERC20(_token).transfer(_hunters[k],_amounts[k]))

IRs:
TMP_110 = CONVERT _token to ERC20
REF_51(address) -> _hunters[k]
REF_52(uint256) -> _amounts[k]
TMP_111(bool) = HIGH_LEVEL_CALL, dest:TMP_110(ERC20), function:transfer, arguments:['REF_51', 'REF_52']  
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
24->25;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
Distribution(_token,_host,_hunters[k],_amounts[k])

IRs:
REF_53(address) -> _hunters[k]
REF_54(uint256) -> _amounts[k]
Emit Distribution(_token,_host,REF_53,REF_54)""];
25->26;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
k ++

IRs:
TMP_114(uint256) := k(uint256)
k(uint256) = k + 1""];
26->23;
27[label=""Node Type: END_IF 27
""];
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
28->1;
}
",1,1,1,0,"onlyOwner();require(bool)(_host != address(0));require(bool)(_hunters.length == _amounts.length);totalAmount = 0;j = 0;;j < _amounts.length;;require(bool)(tokens[_token][_host] >= totalAmount);totalAmount = SafeMath.add(totalAmount,_amounts[j]);j ++;tokens[_token][_host] = SafeMath.sub(tokens[_token][_host],totalAmount);_token == address(0);i = 0;k = 0;;i < _hunters.length;;;require(bool)(_hunters[i].send(_amounts[i]));Distribution(_token,_host,_hunters[i],_amounts[i]);i ++;;k < _hunters.length;;require(bool)(ERC20(_token).transfer(_hunters[k],_amounts[k]));Distribution(_token,_host,_hunters[k],_amounts[k]);k ++"
./0x5b527c8cc72ea4b8681e44754be6248b107c5229_ext.sol,TokenERC20.burnFrom,161,169,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x64e65d352f6a2949463b3a7595911b61bbafc63e_ext.sol,KIPToken.burnFrom,141,149,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x4d797cbb28c49bd074db4a47b582c95fd37804a1_ext.sol,CloutToken.transferMulti,214,224,"REF_93 -> LENGTH _value,REF_94 -> LENGTH _to,TMP_84(bool) = REF_93 == REF_94,TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84),i(uint256) := 0(uint256),REF_95 -> LENGTH _to,TMP_86(bool) = i < REF_95,CONDITION TMP_86,REF_96(uint256) -> balances[msg.sender],REF_97(uint256) -> _value[i],TMP_87(bool) = REF_96 >= REF_97,TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87),REF_98(address) -> _to[i],TMP_89(bool) = REF_98 != 0,TMP_90(None) = SOLIDITY_CALL require(bool)(TMP_89),REF_99(address) -> _to[i],REF_100(uint256) -> _value[i],TMP_91(bool) = INTERNAL_CALL, BasicToken.transfer(address,uint256)(REF_99,REF_100),TMP_92(uint256) := i(uint256),i(uint256) = i + 1,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value.length == _to.length)

IRs:
REF_93 -> LENGTH _value
REF_94 -> LENGTH _to
TMP_84(bool) = REF_93 == REF_94
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
3->10;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < _to.length

IRs:
REF_95 -> LENGTH _to
TMP_86(bool) = i < REF_95
CONDITION TMP_86""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(balances[msg.sender] >= _value[i])

IRs:
REF_96(uint256) -> balances[msg.sender]
REF_97(uint256) -> _value[i]
TMP_87(bool) = REF_96 >= REF_97
TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(_to[i] != 0x0)

IRs:
REF_98(address) -> _to[i]
TMP_89(bool) = REF_98 != 0
TMP_90(None) = SOLIDITY_CALL require(bool)(TMP_89)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
super.transfer(_to[i],_value[i])

IRs:
REF_99(address) -> _to[i]
REF_100(uint256) -> _value[i]
TMP_91(bool) = INTERNAL_CALL, BasicToken.transfer(address,uint256)(REF_99,REF_100)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_92(uint256) := i(uint256)
i(uint256) = i + 1""];
9->5;
10[label=""Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True""];
11[label=""Node Type: RETURN 11

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(_value.length == _to.length);i = 0;;i < _to.length;;true;require(bool)(balances[msg.sender] >= _value[i]);require(bool)(_to[i] != 0x0);super.transfer(_to[i],_value[i]);i ++;success"
./0xbe2a1d562817b6064e0568a4dc9e2c80f7478dfe_ext.sol,TSCoin._transfer,33,40,"TMP_0 = CONVERT 0 to address,TMP_1(bool) = _to != TMP_0,TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1),REF_3(uint256) -> balances[_from],TMP_3(bool) = REF_3 >= _value,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_4(uint256) -> balances[_from],REF_5(uint256) -> balances[_from],TMP_5(uint256) = REF_5 - _value,REF_4(uint256) (->balances) := TMP_5(uint256),REF_6(uint256) -> balances[_to],REF_7(uint256) -> balances[_to],TMP_6(uint256) = REF_7 + _value,REF_6(uint256) (->balances) := TMP_6(uint256),Emit Transfer(_from,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_0 = CONVERT 0 to address
TMP_1(bool) = _to != TMP_0
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] >= _value)

IRs:
REF_3(uint256) -> balances[_from]
TMP_3(bool) = REF_3 >= _value
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] = balances[_from] - _value

IRs:
REF_4(uint256) -> balances[_from]
REF_5(uint256) -> balances[_from]
TMP_5(uint256) = REF_5 - _value
REF_4(uint256) (->balances) := TMP_5(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to] + _value

IRs:
REF_6(uint256) -> balances[_to]
REF_7(uint256) -> balances[_to]
TMP_6(uint256) = REF_7 + _value
REF_6(uint256) (->balances) := TMP_6(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(_to != address(0));require(bool)(balances[_from] >= _value);balances[_from] = balances[_from] - _value;balances[_to] = balances[_to] + _value;Transfer(_from,_to,_value);true"
./0x26bf81f017a7149576dc5d82323172fcae9fd469_ext.sol,PhxGo.mutiSendETHWithDifferentValue,340,342,"INTERNAL_CALL, PhxGo.ethSendDifferentValue(address[],uint256[])(_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ethSendDifferentValue(_to,_value)

IRs:
INTERNAL_CALL, PhxGo.ethSendDifferentValue(address[],uint256[])(_to,_value)""];
}
",0,1,0,0,"ethSendDifferentValue(_to,_value)"
./0xdff95d14094b92ad5dd042fdb47b6f25f33fbbaa_ext.sol,DiXiEnergy.transfer,75,80,"REF_20(uint256) -> balanceOf[msg.sender],TMP_43(bool) = REF_20 >= _value,TMP_44(None) = SOLIDITY_CALL require(bool)(TMP_43),REF_21(uint256) -> balanceOf[msg.sender],REF_21(-> balanceOf) = REF_21 - _value,REF_22(uint256) -> balanceOf[_to],REF_22(-> balanceOf) = REF_22 + _value,Emit Transfer(msg.sender,_to,_value),TMP_46(uint256) = 2 * 32,MODIFIER_CALL, DiXiEnergy.onlyPayloadSize(uint256)(TMP_46)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_20(uint256) -> balanceOf[msg.sender]
TMP_43(bool) = REF_20 >= _value
TMP_44(None) = SOLIDITY_CALL require(bool)(TMP_43)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_21(uint256) -> balanceOf[msg.sender]
REF_21(-> balanceOf) = REF_21 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_22(uint256) -> balanceOf[_to]
REF_22(-> balanceOf) = REF_22 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyPayloadSize(2 * 32)

IRs:
TMP_46(uint256) = 2 * 32
MODIFIER_CALL, DiXiEnergy.onlyPayloadSize(uint256)(TMP_46)""];
5->1;
}
",0,1,0,0,"onlyPayloadSize(2 * 32);require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;balanceOf[_to] += _value;Transfer(msg.sender,_to,_value)"
./0x6bacca3cce57a46fd0822df7c07afbf9d81d96d9_ext.sol,Jiggs.dividendsOf,305,311,"REF_31(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_50(uint256) = profitPerShare_ * REF_31,TMP_51 = CONVERT TMP_50 to int256,REF_32(int256) -> payoutsTo_[_customerAddress],TMP_52(int256) = TMP_51 - REF_32,TMP_53 = CONVERT TMP_52 to uint256,TMP_54(uint256) = TMP_53 / magnitude,RETURN TMP_54","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_31(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_50(uint256) = profitPerShare_ * REF_31
TMP_51 = CONVERT TMP_50 to int256
REF_32(int256) -> payoutsTo_[_customerAddress]
TMP_52(int256) = TMP_51 - REF_32
TMP_53 = CONVERT TMP_52 to uint256
TMP_54(uint256) = TMP_53 / magnitude
RETURN TMP_54""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x2e98a6804e4b6c832ed0ca876a943abd3400b224_ext.sol,Bela.stakeTokens,573,600,"REF_181(uint256) -> balances[msg.sender],TMP_173(bool) = _value <= REF_181,TMP_174(None) = SOLIDITY_CALL require(bool)(TMP_173),REF_182(Bela.TokenStakeData) -> stakeBalances[msg.sender],REF_183(uint256) -> REF_182.initialStakeBalance,TMP_175(bool) = REF_183 == 0,TMP_176(None) = SOLIDITY_CALL require(bool)(TMP_175),REF_184(uint256) -> balances[msg.sender],REF_185(uint256) -> balances[msg.sender],TMP_177(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_185', '_value'] ,REF_184(uint256) (->balances) := TMP_177(uint256),REF_187(Bela.TokenStakeData) -> stakeBalances[msg.sender],REF_188(uint256) -> REF_187.initialStakeBalance,REF_188(uint256) (->stakeBalances) := _value(uint256),totalBelaStaked(uint256) = totalBelaStaked + _value,REF_189(Bela.TokenStakeData) -> stakeBalances[msg.sender],REF_190(uint256) -> REF_189.initialStakePercentage,TMP_178(uint256) = INTERNAL_CALL, Bela.calculateFraction(uint256,uint256,uint256)(_value,totalBelaStaked,decimals),REF_190(uint256) (->stakeBalances) := TMP_178(uint256),REF_191(Bela.TokenStakeData) -> stakeBalances[msg.sender],REF_192(uint256) -> REF_191.initialStakeTime,REF_192(uint256) (->stakeBalances) := now(uint256),REF_193(Bela.TokenStakeData) -> stakeBalances[msg.sender],REF_194(address) -> REF_193.stakeSplitAddress,Emit Stake(msg.sender,REF_194,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_181(uint256) -> balances[msg.sender]
TMP_173(bool) = _value <= REF_181
TMP_174(None) = SOLIDITY_CALL require(bool)(TMP_173)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(stakeBalances[msg.sender].initialStakeBalance == 0)

IRs:
REF_182(Bela.TokenStakeData) -> stakeBalances[msg.sender]
REF_183(uint256) -> REF_182.initialStakeBalance
TMP_175(bool) = REF_183 == 0
TMP_176(None) = SOLIDITY_CALL require(bool)(TMP_175)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_184(uint256) -> balances[msg.sender]
REF_185(uint256) -> balances[msg.sender]
TMP_177(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_185', '_value'] 
REF_184(uint256) (->balances) := TMP_177(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
stakeBalances[msg.sender].initialStakeBalance = _value

IRs:
REF_187(Bela.TokenStakeData) -> stakeBalances[msg.sender]
REF_188(uint256) -> REF_187.initialStakeBalance
REF_188(uint256) (->stakeBalances) := _value(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalBelaStaked += _value

IRs:
totalBelaStaked(uint256) = totalBelaStaked + _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
stakeBalances[msg.sender].initialStakePercentage = calculateFraction(_value,totalBelaStaked,decimals)

IRs:
REF_189(Bela.TokenStakeData) -> stakeBalances[msg.sender]
REF_190(uint256) -> REF_189.initialStakePercentage
TMP_178(uint256) = INTERNAL_CALL, Bela.calculateFraction(uint256,uint256,uint256)(_value,totalBelaStaked,decimals)
REF_190(uint256) (->stakeBalances) := TMP_178(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
stakeBalances[msg.sender].initialStakeTime = now

IRs:
REF_191(Bela.TokenStakeData) -> stakeBalances[msg.sender]
REF_192(uint256) -> REF_191.initialStakeTime
REF_192(uint256) (->stakeBalances) := now(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Stake(msg.sender,stakeBalances[msg.sender].stakeSplitAddress,_value)

IRs:
REF_193(Bela.TokenStakeData) -> stakeBalances[msg.sender]
REF_194(address) -> REF_193.stakeSplitAddress
Emit Stake(msg.sender,REF_194,_value)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: RETURN 10

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(_value <= balances[msg.sender]);require(bool)(stakeBalances[msg.sender].initialStakeBalance == 0);balances[msg.sender] = balances[msg.sender].sub(_value);stakeBalances[msg.sender].initialStakeBalance = _value;totalBelaStaked += _value;stakeBalances[msg.sender].initialStakePercentage = calculateFraction(_value,totalBelaStaked,decimals);stakeBalances[msg.sender].initialStakeTime = now;Stake(msg.sender,stakeBalances[msg.sender].stakeSplitAddress,_value);true;success"
./0xf0f0ec744a717807a24322d0e2fecc6b73c2d752_ext.sol,DragonKing.sellCharacter,541,553,"TMP_289(bool) = tx.origin == msg.sender,TMP_290(None) = SOLIDITY_CALL require(bool)(TMP_289),REF_152(DragonKing.Character) -> characters[characterId],REF_153(address) -> REF_152.owner,TMP_291(bool) = msg.sender == REF_153,TMP_292(None) = SOLIDITY_CALL require(bool)(TMP_291),REF_154(DragonKing.Character) -> characters[characterId],REF_155(uint8) -> REF_154.characterType,TMP_293(uint256) = 2 * numDragonTypes,TMP_294(bool) = REF_155 < TMP_293,TMP_295(None) = SOLIDITY_CALL require(bool)(TMP_294),REF_156(DragonKing.Character) -> characters[characterId],REF_157(uint64) -> REF_156.purchaseTimestamp,TMP_296(uint64) = REF_157 + 86400,TMP_297(bool) = TMP_296 < now,TMP_298(None) = SOLIDITY_CALL require(bool)(TMP_297),REF_158(DragonKing.Character) -> characters[characterId],REF_159(uint128) -> REF_158.value,val(uint128) := REF_159(uint128),TMP_299(uint16) := numCharacters(uint16),numCharacters(uint16) = numCharacters - 1,TMP_300(uint16) = INTERNAL_CALL, DragonKing.getCharacterIndex(uint32)(characterId),INTERNAL_CALL, DragonKing.replaceCharacter(uint16,uint16)(TMP_300,numCharacters),Transfer dest:msg.sender value:val,TMP_303(bool) = oldest == 0,CONDITION TMP_303,INTERNAL_CALL, DragonKing.findOldest()(),Emit NewSell(characterId,msg.sender,val)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(tx.origin == msg.sender)

IRs:
TMP_289(bool) = tx.origin == msg.sender
TMP_290(None) = SOLIDITY_CALL require(bool)(TMP_289)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == characters[characterId].owner)

IRs:
REF_152(DragonKing.Character) -> characters[characterId]
REF_153(address) -> REF_152.owner
TMP_291(bool) = msg.sender == REF_153
TMP_292(None) = SOLIDITY_CALL require(bool)(TMP_291)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(characters[characterId].characterType < 2 * numDragonTypes)

IRs:
REF_154(DragonKing.Character) -> characters[characterId]
REF_155(uint8) -> REF_154.characterType
TMP_293(uint256) = 2 * numDragonTypes
TMP_294(bool) = REF_155 < TMP_293
TMP_295(None) = SOLIDITY_CALL require(bool)(TMP_294)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(characters[characterId].purchaseTimestamp + 86400 < now)

IRs:
REF_156(DragonKing.Character) -> characters[characterId]
REF_157(uint64) -> REF_156.purchaseTimestamp
TMP_296(uint64) = REF_157 + 86400
TMP_297(bool) = TMP_296 < now
TMP_298(None) = SOLIDITY_CALL require(bool)(TMP_297)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
val = characters[characterId].value

IRs:
REF_158(DragonKing.Character) -> characters[characterId]
REF_159(uint128) -> REF_158.value
val(uint128) := REF_159(uint128)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
numCharacters --

IRs:
TMP_299(uint16) := numCharacters(uint16)
numCharacters(uint16) = numCharacters - 1""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
replaceCharacter(getCharacterIndex(characterId),numCharacters)

IRs:
TMP_300(uint16) = INTERNAL_CALL, DragonKing.getCharacterIndex(uint32)(characterId)
INTERNAL_CALL, DragonKing.replaceCharacter(uint16,uint16)(TMP_300,numCharacters)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
msg.sender.transfer(val)

IRs:
Transfer dest:msg.sender value:val""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
oldest == 0

IRs:
TMP_303(bool) = oldest == 0
CONDITION TMP_303""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
findOldest()

IRs:
INTERNAL_CALL, DragonKing.findOldest()()""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
NewSell(characterId,msg.sender,val)

IRs:
Emit NewSell(characterId,msg.sender,val)""];
}
",0,1,0,0,"require(bool)(tx.origin == msg.sender);require(bool)(msg.sender == characters[characterId].owner);require(bool)(characters[characterId].characterType < 2 * numDragonTypes);require(bool)(characters[characterId].purchaseTimestamp + 86400 < now);val = characters[characterId].value;numCharacters --;replaceCharacter(getCharacterIndex(characterId),numCharacters);msg.sender.transfer(val);oldest == 0;findOldest();;NewSell(characterId,msg.sender,val)"
./0xf449ef0007c98761bdfced7ab1d0351f71d30468_ext.sol,Danetonbit.transfer,21,27,"REF_1(uint256) -> balances[msg.sender],TMP_1(bool) = REF_1 >= _value,TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1),REF_2(uint256) -> balances[msg.sender],REF_2(-> balances) = REF_2 - _value,REF_3(uint256) -> balances[_to],REF_3(-> balances) = REF_3 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_1(bool) = REF_1 >= _value
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_2(uint256) -> balances[msg.sender]
REF_2(-> balances) = REF_2 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_3(uint256) -> balances[_to]
REF_3(-> balances) = REF_3 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0xda7c27c04f66842faf20644814b644e25e1766ea_ext.sol,ERC20OptionsConverter.transfer,371,377,"REF_59(uint256) -> balances[msg.sender],TMP_108(bool) = REF_59 < _value,CONDITION TMP_108,REF_60(uint256) -> balances[msg.sender],REF_60(-> balances) = REF_60 - _value,REF_61(uint256) -> balances[_to],REF_61(-> balances) = REF_61 + _value,Emit Transfer(msg.sender,_to,_value),MODIFIER_CALL, ERC20OptionsConverter.converted()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: IF 1

EXPRESSION:
balances[msg.sender] < _value

IRs:
REF_59(uint256) -> balances[msg.sender]
TMP_108(bool) = REF_59 < _value
CONDITION TMP_108""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_60(uint256) -> balances[msg.sender]
REF_60(-> balances) = REF_60 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] += _value

IRs:
REF_61(uint256) -> balances[_to]
REF_61(-> balances) = REF_61 + _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
converted()

IRs:
MODIFIER_CALL, ERC20OptionsConverter.converted()()""];
7->1;
}
",0,1,0,0,"converted();balances[msg.sender] < _value;;;balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value)"
./0xf24c63438ae11cb3facb84006f4cfa75458126ed_ext.sol,EtherDogBase._transfer,328,343,"REF_0(uint256) -> ownershipTokenCount[_to],TMP_52(uint256) := REF_0(uint256),REF_0(-> ownershipTokenCount) = REF_0 + 1,REF_1(address) -> EtherDogIndexToOwner[_tokenId],REF_1(address) (->EtherDogIndexToOwner) := _to(address),TMP_53 = CONVERT 0 to address,TMP_54(bool) = _from != TMP_53,CONDITION TMP_54,REF_2(uint256) -> ownershipTokenCount[_from],TMP_55(uint256) := REF_2(uint256),REF_2(-> ownershipTokenCount) = REF_2 - 1,REF_3(address) -> sireAllowedToAddress[_tokenId],sireAllowedToAddress = delete REF_3 ,REF_4(address) -> EtherDogIndexToApproved[_tokenId],EtherDogIndexToApproved = delete REF_4 ,Emit Transfer(_from,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownershipTokenCount[_to] ++

IRs:
REF_0(uint256) -> ownershipTokenCount[_to]
TMP_52(uint256) := REF_0(uint256)
REF_0(-> ownershipTokenCount) = REF_0 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
EtherDogIndexToOwner[_tokenId] = _to

IRs:
REF_1(address) -> EtherDogIndexToOwner[_tokenId]
REF_1(address) (->EtherDogIndexToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_53 = CONVERT 0 to address
TMP_54(bool) = _from != TMP_53
CONDITION TMP_54""];
3->4[label=""True""];
3->7[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownershipTokenCount[_from] --

IRs:
REF_2(uint256) -> ownershipTokenCount[_from]
TMP_55(uint256) := REF_2(uint256)
REF_2(-> ownershipTokenCount) = REF_2 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete sireAllowedToAddress[_tokenId]

IRs:
REF_3(address) -> sireAllowedToAddress[_tokenId]
sireAllowedToAddress = delete REF_3 ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
delete EtherDogIndexToApproved[_tokenId]

IRs:
REF_4(address) -> EtherDogIndexToApproved[_tokenId]
EtherDogIndexToApproved = delete REF_4 ""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
}
",0,1,0,0,"ownershipTokenCount[_to] ++;EtherDogIndexToOwner[_tokenId] = _to;_from != address(0);ownershipTokenCount[_from] --;;delete sireAllowedToAddress[_tokenId];delete EtherDogIndexToApproved[_tokenId];Transfer(_from,_to,_tokenId)"
./0x572154643036f421e1f3c054eb9cfa36dd9de4b2_ext.sol,SFI._transfer,38,54,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x71972877d68acf22114e05578364a307cafe2885_ext.sol,SafeMath.safeAdd,23,27,"TMP_17(uint256) = a + b,c(uint256) := TMP_17(uint256),TMP_18(bool) = c >= a,TMP_19(None) = SOLIDITY_CALL assert(bool)(TMP_18),RETURN c","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_17(uint256) = a + b
c(uint256) := TMP_17(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_18(bool) = c >= a
TMP_19(None) = SOLIDITY_CALL assert(bool)(TMP_18)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c""];
}
",0,1,0,0,c = a + b;assert(bool)(c >= a);c
./0x360abb53840302d4b4b119d2004a856f1151366b_ext.sol,BaseContract.totalSupply,485,487,"REF_265 -> LENGTH details,TMP_364(uint256) = REF_265 - 1,RETURN TMP_364","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
details.length - 1

IRs:
REF_265 -> LENGTH details
TMP_364(uint256) = REF_265 - 1
RETURN TMP_364""];
}
",0,1,0,0,details.length - 1
./0xcf91ddfd551c8eee7dc88372acd8c49a0d8726a3_ext.sol,Alecrypto.totalSupply,116,118,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x32df1ab2161317adbeafd47bcb30a2f1a806ccfb_ext.sol,TokenBaseAsset.addToken,17,20,"TMP_0(bool) = msg.sender == mOwner,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_0(string) -> mTokens[pDocumentHash],REF_0(string) (->mTokens) := pDocumentToken(string)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == mOwner)

IRs:
TMP_0(bool) = msg.sender == mOwner
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
mTokens[pDocumentHash] = pDocumentToken

IRs:
REF_0(string) -> mTokens[pDocumentHash]
REF_0(string) (->mTokens) := pDocumentToken(string)""];
}
",0,1,0,0,require(bool)(msg.sender == mOwner);mTokens[pDocumentHash] = pDocumentToken
./0x4ce68b018062cfccd66c7fbbb2cc1f0161d22150_ext.sol,BOWTERC20.burn,122,128,"REF_17(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_17 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_17 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x5c0669c6718bf35112d4e643fe80bf7fb06dedeb_ext.sol,NOUR.transfer,95,105,"REF_1(uint256) -> balances[msg.sender],TMP_21(bool) = REF_1 >= _value,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),TMP_23(bool) = msg.sender == _to,REF_2(uint256) -> balances[_to],TMP_24(uint256) = MAX_UINT256 - _value,TMP_25(bool) = REF_2 <= TMP_24,TMP_26(bool) = TMP_23 || TMP_25,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_3(uint256) -> balances[msg.sender],REF_3(-> balances) = REF_3 - _value,REF_4(uint256) -> balances[_to],REF_4(-> balances) = REF_4 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_21(bool) = REF_1 >= _value
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == _to || balances[_to] <= MAX_UINT256 - _value)

IRs:
TMP_23(bool) = msg.sender == _to
REF_2(uint256) -> balances[_to]
TMP_24(uint256) = MAX_UINT256 - _value
TMP_25(bool) = REF_2 <= TMP_24
TMP_26(bool) = TMP_23 || TMP_25
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_3(uint256) -> balances[msg.sender]
REF_3(-> balances) = REF_3 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] += _value

IRs:
REF_4(uint256) -> balances[_to]
REF_4(-> balances) = REF_4 + _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);require(bool)(msg.sender == _to || balances[_to] <= MAX_UINT256 - _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true"
./0x64e65d352f6a2949463b3a7595911b61bbafc63e_ext.sol,KIPToken._transfer,39,55,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x41ff17293fe3d87d4b6c9dc050ce17694145e1bc_ext.sol,StandardToken.approveAndCall,226,233,"TMP_50 = CONVERT _spender to TokenRecipient,spender(TokenRecipient) := TMP_50(TokenRecipient),TMP_51(bool) = INTERNAL_CALL, StandardToken.approve(address,uint256)(_spender,_value),CONDITION TMP_51,HIGH_LEVEL_CALL, dest:spender(TokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,MODIFIER_CALL, BasicToken.canTransfer()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = TokenRecipient(_spender)

IRs:
TMP_50 = CONVERT _spender to TokenRecipient
spender(TokenRecipient) := TMP_50(TokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_51(bool) = INTERNAL_CALL, StandardToken.approve(address,uint256)(_spender,_value)
CONDITION TMP_51""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(TokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->7;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
canTransfer()

IRs:
MODIFIER_CALL, BasicToken.canTransfer()()""];
6->1;
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"canTransfer();spender = TokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x2feecd120111e5aab7b3a22fe1177a392cfe0f4e_ext.sol,AG.totalSupply,93,95,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x654cdd809f86d1414fcb5563b383dbeccfb8b995_ext.sol,VOCC_I057_20181211.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x37e1160184f7dd29f00b78c050bf13224780b0b0_ext.sol,YCCToken.burn,88,94,"REF_13(uint256) -> balanceOf[msg.sender],TMP_15(bool) = REF_13 >= _value,TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15),REF_14(uint256) -> balanceOf[msg.sender],REF_14(-> balanceOf) = REF_14 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_13(uint256) -> balanceOf[msg.sender]
TMP_15(bool) = REF_13 >= _value
TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_14(uint256) -> balanceOf[msg.sender]
REF_14(-> balanceOf) = REF_14 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x742a56a727dac07e0889920b8887d482325f659b_ext.sol,InfiniCoin.approveAndCall,131,136,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xce78ab22cd0331a52af7bb4b622edfa792819d47_ext.sol,RUDAWORLD.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x031f7f7749247e0913aace12002cf61f039cd7b1_ext.sol,WWECoin.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x741f58cd68d24f361cc0ee0d3aaf7df2bf16132e_ext.sol,BlockonixToken.totalSupply,213,215,"TMP_56(uint256) = totalTokenSupply - burntTokens,RETURN TMP_56,RETURN _totalSupply","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
totalTokenSupply - burntTokens

IRs:
TMP_56(uint256) = totalTokenSupply - burntTokens
RETURN TMP_56""];
2[label=""Node Type: RETURN 2

EXPRESSION:
_totalSupply

IRs:
RETURN _totalSupply""];
}
",0,1,0,0,totalTokenSupply - burntTokens;_totalSupply
./0x409de70d8ad0135e6fd91f343899b93d903c998b_ext.sol,RegularToken.transferFrom,109,128,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x0747af71e2034bc2d2fcad388a264f5ccdff505c_ext.sol,BlockVentureCoin.burn,309,321,"REF_24(uint256) -> balanceOf[msg.sender],TMP_20(bool) = REF_24 < _value,CONDITION TMP_20,REF_25(uint256) -> balanceOf[msg.sender],REF_25(-> balanceOf) = REF_25 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balanceOf[msg.sender] < _value

IRs:
REF_24(uint256) -> balanceOf[msg.sender]
TMP_20(bool) = REF_24 < _value
CONDITION TMP_20""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_25(uint256) -> balanceOf[msg.sender]
REF_25(-> balanceOf) = REF_25 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balanceOf[msg.sender] < _value;;;balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x700fc72abc067e90111a391d0fae8ce8c799b38f_ext.sol,MultiTransfer.multiTransfer,14,18,"i(uint256) := 0(uint256),REF_0 -> LENGTH Airdrop2,TMP_0(bool) = i < REF_0,CONDITION TMP_0,REF_2(address) -> Airdrop2[i],TMP_1(uint256) = 10 ** 18,TMP_2(uint256) = amount * TMP_1,HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['REF_2', 'TMP_2']  ,TMP_4(uint256) := i(uint256),i(uint256) = i + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < Airdrop2.length

IRs:
REF_0 -> LENGTH Airdrop2
TMP_0(bool) = i < REF_0
CONDITION TMP_0""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
token.transfer(Airdrop2[i],amount * 10 ** 18)

IRs:
REF_2(address) -> Airdrop2[i]
TMP_1(uint256) = 10 ** 18
TMP_2(uint256) = amount * TMP_1
HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['REF_2', 'TMP_2']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_4(uint256) := i(uint256)
i(uint256) = i + 1""];
6->4;
}
",0,1,0,0,"i = 0;;i < Airdrop2.length;;token.transfer(Airdrop2[i],amount * 10 ** 18);i ++"
./0x70aa0247de23fdd3b8558be98747a8c286affd54_ext.sol,Digital_1._transfer,43,59,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x0eb152d2bba8af722d7e296a1f223d819c3bbb1f_ext.sol,CarbonExchangeCoinToken.mintToken,220,225,"REF_58(uint256) -> balanceOf[target],REF_58(-> balanceOf) = REF_58 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_58(uint256) -> balanceOf[target]
REF_58(-> balanceOf) = REF_58 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x2154f9d7da8bf221e102197195531c82cee1677e_ext.sol,AIUToken.burnFrom,71,79,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x46570e37d496855b391573fd567599e567a73cb4_ext.sol,VOCC_I043_20181211.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x485f3b5ec637187749fd643e517662bd99a4124d_ext.sol,cardpoints.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x83ba853b8196bb51c148dd762a827c703b156450_ext.sol,FeeWallet.collect,203,213,"TMP_43 = CONVERT 0 to address,TMP_44(bool) = _affiliate == TMP_43,CONDITION TMP_44,REF_8(uint256) -> pendingWithdrawals[serviceAccount],REF_8(-> pendingWithdrawals) = REF_8 + msg.value,TMP_45(uint256) = INTERNAL_CALL, FeeWallet.getAffiliateAmount(uint256)(msg.value),affiliateAmount(uint256) := TMP_45(uint256),REF_9(uint256) -> pendingWithdrawals[_affiliate],REF_9(-> pendingWithdrawals) = REF_9 + affiliateAmount,REF_10(uint256) -> pendingWithdrawals[serviceAccount],TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.safeSub(uint256,uint256), arguments:['msg.value', 'affiliateAmount'] ,REF_10(-> pendingWithdrawals) = REF_10 + TMP_46,MODIFIER_CALL, Members.onlyMembers()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: IF 1

EXPRESSION:
_affiliate == address(0)

IRs:
TMP_43 = CONVERT 0 to address
TMP_44(bool) = _affiliate == TMP_43
CONDITION TMP_44""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
pendingWithdrawals[serviceAccount] += msg.value

IRs:
REF_8(uint256) -> pendingWithdrawals[serviceAccount]
REF_8(-> pendingWithdrawals) = REF_8 + msg.value""];
2->6;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
affiliateAmount = getAffiliateAmount(msg.value)

IRs:
TMP_45(uint256) = INTERNAL_CALL, FeeWallet.getAffiliateAmount(uint256)(msg.value)
affiliateAmount(uint256) := TMP_45(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
pendingWithdrawals[_affiliate] += affiliateAmount

IRs:
REF_9(uint256) -> pendingWithdrawals[_affiliate]
REF_9(-> pendingWithdrawals) = REF_9 + affiliateAmount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
pendingWithdrawals[serviceAccount] += SafeMath.safeSub(msg.value,affiliateAmount)

IRs:
REF_10(uint256) -> pendingWithdrawals[serviceAccount]
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.safeSub(uint256,uint256), arguments:['msg.value', 'affiliateAmount'] 
REF_10(-> pendingWithdrawals) = REF_10 + TMP_46""];
5->6;
6[label=""Node Type: END_IF 6
""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyMembers()

IRs:
MODIFIER_CALL, Members.onlyMembers()()""];
7->1;
}
",0,1,0,0,"onlyMembers();_affiliate == address(0);pendingWithdrawals[serviceAccount] += msg.value;affiliateAmount = getAffiliateAmount(msg.value);;pendingWithdrawals[_affiliate] += affiliateAmount;pendingWithdrawals[serviceAccount] += SafeMath.safeSub(msg.value,affiliateAmount)"
./0xebaa1766c577a1ea5833f0502bd9984aef22c61f_ext.sol,DadiSale.getTokensAvailable,501,503,"TMP_148(uint256) = tokenSupply - tokensPurchased,RETURN TMP_148","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
tokenSupply - tokensPurchased

IRs:
TMP_148(uint256) = tokenSupply - tokensPurchased
RETURN TMP_148""];
}
",0,1,0,0,tokenSupply - tokensPurchased
./0x92b12168afde3b068fdb201ff42c407be27d15ad_ext.sol,Gravestone.do_worship,27,32,"REF_0 -> LENGTH worships,TMP_0(uint256) := REF_0(uint256),REF_0(-> worships) = REF_0 + 1,id(uint256) := TMP_0(uint256),REF_1 -> LENGTH worships,worship_count(uint256) := REF_1(uint256),REF_2(Gravestone.Worship) -> worships[id],TMP_1(Gravestone.Worship) = new Worship(_fullname,_message),REF_2(Gravestone.Worship) (->worships) := TMP_1(Gravestone.Worship),RETURN Thank you","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
id = worships.length ++

IRs:
REF_0 -> LENGTH worships
TMP_0(uint256) := REF_0(uint256)
REF_0(-> worships) = REF_0 + 1
id(uint256) := TMP_0(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
worship_count = worships.length

IRs:
REF_1 -> LENGTH worships
worship_count(uint256) := REF_1(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
worships[id] = Worship({fullname:_fullname,message:_message})

IRs:
REF_2(Gravestone.Worship) -> worships[id]
TMP_1(Gravestone.Worship) = new Worship(_fullname,_message)
REF_2(Gravestone.Worship) (->worships) := TMP_1(Gravestone.Worship)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
Thank you

IRs:
RETURN Thank you""];
}
",0,1,0,0,"id = worships.length ++;worship_count = worships.length;worships[id] = Worship({fullname:_fullname,message:_message});Thank you"
./0xaa70bc3e835e12d6902a8e4da77db4842e519c42_ext.sol,DhaCoin.mintToken,208,213,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x54053ea92b9366182dbbf3e4583c8a5496bb2903_ext.sol,CCD_KOHLE_3_20190411.transferFrom,42,54,"REF_6(uint256) -> balanceOf[from],TMP_6(bool) = value <= REF_6,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_7(mapping(address => uint256)) -> allowance[from],REF_8(uint256) -> REF_7[msg.sender],TMP_8(bool) = value <= REF_8,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_9(uint256) -> balanceOf[from],REF_9(-> balanceOf) = REF_9 - value,REF_10(uint256) -> balanceOf[to],REF_10(-> balanceOf) = REF_10 + value,REF_11(mapping(address => uint256)) -> allowance[from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowance) = REF_12 - value,Emit Transfer(from,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(value <= balanceOf[from])

IRs:
REF_6(uint256) -> balanceOf[from]
TMP_6(bool) = value <= REF_6
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value <= allowance[from][msg.sender])

IRs:
REF_7(mapping(address => uint256)) -> allowance[from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_8(bool) = value <= REF_8
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[from] -= value

IRs:
REF_9(uint256) -> balanceOf[from]
REF_9(-> balanceOf) = REF_9 - value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[to] += value

IRs:
REF_10(uint256) -> balanceOf[to]
REF_10(-> balanceOf) = REF_10 + value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allowance[from][msg.sender] -= value

IRs:
REF_11(mapping(address => uint256)) -> allowance[from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowance) = REF_12 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(value <= balanceOf[from]);require(bool)(value <= allowance[from][msg.sender]);balanceOf[from] -= value;balanceOf[to] += value;allowance[from][msg.sender] -= value;Transfer(from,to,value);true;success"
./0xdcaa6f95fcdd339b80631fed7eb213d653c21b12_ext.sol,StandardToken.transfer,45,56,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x1c4d21d3534010ca07b5f2a9aded27ac9abb64cc_ext.sol,COTY.burn,135,141,"REF_17(uint256) -> balanceOf[msg.sender],TMP_25(bool) = REF_17 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_25(bool) = REF_17 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x4d538b9b3c1c3f58707a9689b5bc3d860c011242_ext.sol,TokenERC20.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x5838f878000fe44b6f6c677bbf839e12f097c147_ext.sol,Q_GAME.NewQuestion,34,39,"TMP_12(bool) = msg.sender == questionSender,CONDITION TMP_12,question(string) := _question(string),responseHash(bytes32) := _responseHash(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == questionSender

IRs:
TMP_12(bool) = msg.sender == questionSender
CONDITION TMP_12""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
responseHash = _responseHash

IRs:
responseHash(bytes32) := _responseHash(bytes32)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,msg.sender == questionSender;question = _question;;responseHash = _responseHash
./0x1e5e66fd8c22dea99d8451ee8bb1e941b70b723f_ext.sol,SWAP.setName,46,49,"name(string) := _name(string),RETURN name,MODIFIER_CALL, SWAP.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
name = _name

IRs:
name(string) := _name(string)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
name

IRs:
RETURN name""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, SWAP.onlyOwner()()""];
3->1;
}
",0,1,0,0,onlyOwner();name = _name;name
./0x1ee72092724d17c4667563bac428babfe11f6440_ext.sol,IMAGEWORLD.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x039dbff00f2b4b0da89c60a1870cbfbd726b6cb1_ext.sol,TokenERC20.burnFrom,72,80,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xf0d1a6dfcce7fb23fee76d8ed89e780c5a2c1885_ext.sol,ERC721._transfer,110,123,"REF_5(uint256) -> ownershipTokenCount[_to],TMP_14(uint256) := REF_5(uint256),REF_5(-> ownershipTokenCount) = REF_5 + 1,REF_6(address) -> tokenIndexToOwner[_tokenId],REF_6(address) (->tokenIndexToOwner) := _to(address),TMP_15 = CONVERT 0 to address,TMP_16(bool) = _from != TMP_15,CONDITION TMP_16,REF_7(uint256) -> ownershipTokenCount[_from],TMP_17(uint256) := REF_7(uint256),REF_7(-> ownershipTokenCount) = REF_7 - 1,REF_8(address) -> tokenIndexToApproved[_tokenId],tokenIndexToApproved = delete REF_8 ,Emit Transfer(_from,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownershipTokenCount[_to] ++

IRs:
REF_5(uint256) -> ownershipTokenCount[_to]
TMP_14(uint256) := REF_5(uint256)
REF_5(-> ownershipTokenCount) = REF_5 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
tokenIndexToOwner[_tokenId] = _to

IRs:
REF_6(address) -> tokenIndexToOwner[_tokenId]
REF_6(address) (->tokenIndexToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_15 = CONVERT 0 to address
TMP_16(bool) = _from != TMP_15
CONDITION TMP_16""];
3->4[label=""True""];
3->7[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownershipTokenCount[_from] --

IRs:
REF_7(uint256) -> ownershipTokenCount[_from]
TMP_17(uint256) := REF_7(uint256)
REF_7(-> ownershipTokenCount) = REF_7 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete tokenIndexToApproved[_tokenId]

IRs:
REF_8(address) -> tokenIndexToApproved[_tokenId]
tokenIndexToApproved = delete REF_8 ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
6->7;
7[label=""Node Type: END_IF 7
""];
}
",0,1,0,0,"ownershipTokenCount[_to] ++;tokenIndexToOwner[_tokenId] = _to;_from != address(0);ownershipTokenCount[_from] --;;delete tokenIndexToApproved[_tokenId];Transfer(_from,_to,_tokenId)"
./0xbbbecd6ee8d2972b4905634177c56ad73f226276_ext.sol,LeaderSystem.getLeaders,207,216,"REF_86(LeaderSystem.LeadersTable) -> leaders[_indexTable],leader(LeaderSystem.LeadersTable) := REF_86(LeaderSystem.LeadersTable),REF_87(address[]) -> leader.leaders,REF_88 -> LENGTH REF_87,TMP_118(uint256[])  = new uint256[](REF_88),balances(uint256[]) = ['TMP_118(uint256[])'],i(uint256) := 0(uint256),REF_89(address[]) -> leader.leaders,REF_90 -> LENGTH REF_89,TMP_119(bool) = i < REF_90,CONDITION TMP_119,REF_91(uint256) -> balances[i],REF_92(mapping(address => uint256)) -> leader.users,REF_93(address[]) -> leader.leaders,REF_94(address) -> REF_93[i],REF_95(uint256) -> REF_92[REF_94],REF_91(uint256) (->balances) := REF_95(uint256),TMP_120(uint256) := i(uint256),i(uint256) = i + 1,REF_96(address[]) -> leader.leaders,RETURN REF_96,balances","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
leader = leaders[_indexTable]

IRs:
REF_86(LeaderSystem.LeadersTable) -> leaders[_indexTable]
leader(LeaderSystem.LeadersTable) := REF_86(LeaderSystem.LeadersTable)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
balances = new uint256[](leader.leaders.length)

IRs:
REF_87(address[]) -> leader.leaders
REF_88 -> LENGTH REF_87
TMP_118(uint256[])  = new uint256[](REF_88)
balances(uint256[]) = ['TMP_118(uint256[])']""];
2->5;
3[label=""Node Type: BEGIN_LOOP 3
""];
3->6;
4[label=""Node Type: END_LOOP 4
""];
4->9;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
5->3;
6[label=""Node Type: IF_LOOP 6

EXPRESSION:
i < leader.leaders.length

IRs:
REF_89(address[]) -> leader.leaders
REF_90 -> LENGTH REF_89
TMP_119(bool) = i < REF_90
CONDITION TMP_119""];
6->7[label=""True""];
6->4[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[i] = leader.users[leader.leaders[i]]

IRs:
REF_91(uint256) -> balances[i]
REF_92(mapping(address => uint256)) -> leader.users
REF_93(address[]) -> leader.leaders
REF_94(address) -> REF_93[i]
REF_95(uint256) -> REF_92[REF_94]
REF_91(uint256) (->balances) := REF_95(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_120(uint256) := i(uint256)
i(uint256) = i + 1""];
8->6;
9[label=""Node Type: RETURN 9

EXPRESSION:
(leader.leaders,balances)

IRs:
REF_96(address[]) -> leader.leaders
RETURN REF_96,balances""];
}
",0,1,0,0,"leader = leaders[_indexTable];balances = new uint256[](leader.leaders.length);i = 0;;i < leader.leaders.length;;(leader.leaders,balances);balances[i] = leader.users[leader.leaders[i]];i ++"
./0xdb5e04dc9c94bc8310e8885c85a4d0666ccaecae_ext.sol,EtherBrand._transfer,325,331,"REF_201(EtherBrand.Brand) -> brands[_brand_id],REF_202(address) -> REF_201.owner,REF_202(address) (->brands) := _to(address),REF_203(EtherBrand.Brand) -> brands[_brand_id],REF_204(address) -> REF_203.approve_transfer_to,TMP_211 = CONVERT 0 to address,REF_204(address) (->brands) := TMP_211(address),REF_205(uint256) -> ownerCount[_from],REF_205(-> ownerCount) = REF_205 - 1,REF_206(uint256) -> ownerCount[_to],REF_206(-> ownerCount) = REF_206 + 1,Emit Transfer(_from,_to,_brand_id)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
brands[_brand_id].owner = _to

IRs:
REF_201(EtherBrand.Brand) -> brands[_brand_id]
REF_202(address) -> REF_201.owner
REF_202(address) (->brands) := _to(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
brands[_brand_id].approve_transfer_to = address(0)

IRs:
REF_203(EtherBrand.Brand) -> brands[_brand_id]
REF_204(address) -> REF_203.approve_transfer_to
TMP_211 = CONVERT 0 to address
REF_204(address) (->brands) := TMP_211(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ownerCount[_from] -= 1

IRs:
REF_205(uint256) -> ownerCount[_from]
REF_205(-> ownerCount) = REF_205 - 1""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownerCount[_to] += 1

IRs:
REF_206(uint256) -> ownerCount[_to]
REF_206(-> ownerCount) = REF_206 + 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_brand_id)

IRs:
Emit Transfer(_from,_to,_brand_id)""];
}
",0,1,0,0,"brands[_brand_id].owner = _to;brands[_brand_id].approve_transfer_to = address(0);ownerCount[_from] -= 1;ownerCount[_to] += 1;Transfer(_from,_to,_brand_id)"
./0x30d62b3392520580ffc74d7326bb29a4bf541a4d_ext.sol,TerraformReserve.lockMana,156,164,"TMP_48(None) = SOLIDITY_CALL require(bool)(acceptingDeposits),TMP_49(uint256) = 1000 * 1000000000000000000,TMP_50(bool) = mana >= TMP_49,TMP_51(None) = SOLIDITY_CALL require(bool)(TMP_50),TMP_52(bool) = HIGH_LEVEL_CALL, dest:manaToken(ERC20), function:transferFrom, arguments:['_from', 'this', 'mana']  ,TMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52),REF_5(uint256) -> lockedBalance[_from],REF_5(-> lockedBalance) = REF_5 + mana,totalLocked(uint256) = totalLocked + mana,Emit LockedBalance(_from,mana)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(acceptingDeposits)

IRs:
TMP_48(None) = SOLIDITY_CALL require(bool)(acceptingDeposits)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(mana >= 1000 * 1e18)

IRs:
TMP_49(uint256) = 1000 * 1000000000000000000
TMP_50(bool) = mana >= TMP_49
TMP_51(None) = SOLIDITY_CALL require(bool)(TMP_50)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(manaToken.transferFrom(_from,this,mana))

IRs:
TMP_52(bool) = HIGH_LEVEL_CALL, dest:manaToken(ERC20), function:transferFrom, arguments:['_from', 'this', 'mana']  
TMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
lockedBalance[_from] += mana

IRs:
REF_5(uint256) -> lockedBalance[_from]
REF_5(-> lockedBalance) = REF_5 + mana""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalLocked += mana

IRs:
totalLocked(uint256) = totalLocked + mana""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
LockedBalance(_from,mana)

IRs:
Emit LockedBalance(_from,mana)""];
}
",1,1,0,0,"require(bool)(acceptingDeposits);require(bool)(mana >= 1000 * 1e18);require(bool)(manaToken.transferFrom(_from,this,mana));lockedBalance[_from] += mana;totalLocked += mana;LockedBalance(_from,mana)"
./0xd3cdc4e75750dc1e59f8342200742b6b29490e70_ext.sol,Decurian.approveAndCall,143,148,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xa4b01cc6f2fde9d5d84da419bee4359819ae210b_ext.sol,VirtualGift._transfer,266,278,"REF_21(uint256) -> balances[_to],TMP_36(uint256) := REF_21(uint256),REF_21(-> balances) = REF_21 + 1,REF_22(address) -> GiftIndexToOwners[_GiftId],REF_22(address) (->GiftIndexToOwners) := _to(address),TMP_37 = CONVERT 0 to address,TMP_38(bool) = _from != TMP_37,CONDITION TMP_38,REF_23(uint256) -> balances[_from],TMP_39(uint256) := REF_23(uint256),REF_23(-> balances) = REF_23 - 1,Emit Transfer(_from,_to,_GiftId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances[_to] ++

IRs:
REF_21(uint256) -> balances[_to]
TMP_36(uint256) := REF_21(uint256)
REF_21(-> balances) = REF_21 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
GiftIndexToOwners[_GiftId] = _to

IRs:
REF_22(address) -> GiftIndexToOwners[_GiftId]
REF_22(address) (->GiftIndexToOwners) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_37 = CONVERT 0 to address
TMP_38(bool) = _from != TMP_37
CONDITION TMP_38""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] --

IRs:
REF_23(uint256) -> balances[_from]
TMP_39(uint256) := REF_23(uint256)
REF_23(-> balances) = REF_23 - 1""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(_from,_to,_GiftId)

IRs:
Emit Transfer(_from,_to,_GiftId)""];
}
",0,1,0,0,"balances[_to] ++;GiftIndexToOwners[_GiftId] = _to;_from != address(0);balances[_from] --;;Transfer(_from,_to,_GiftId)"
./0xaa63c8683647ef91b3fdab4b4989ee9588da297b_ext.sol,DSProxyCache.write,187,198,"TMP_53(bytes32) = SOLIDITY_CALL keccak256()(_code),hash(bytes32) := TMP_53(bytes32),REF_7(address) -> cache[hash],REF_7(address) (->cache) := target(address),RETURN target","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: INLINE ASM 1
""];
1->2;
2[label=""Node Type: END INLINE ASM 2
""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
hash = keccak256()(_code)

IRs:
TMP_53(bytes32) = SOLIDITY_CALL keccak256()(_code)
hash(bytes32) := TMP_53(bytes32)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
cache[hash] = target

IRs:
REF_7(address) -> cache[hash]
REF_7(address) (->cache) := target(address)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
target

IRs:
RETURN target""];
}
",0,1,0,0,;;hash = keccak256()(_code);cache[hash] = target;target
./0xc37b74c1f1d6a0f9a6ebd4bd846805f899b5e897_ext.sol,Angelglorycoin._transfer,45,60,"TMP_0(bool) = _to != 0,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_1(uint256) -> balanceOf[_from],TMP_2(bool) = REF_1 >= _value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[_to],TMP_4(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_5(bool) = TMP_4 >= REF_3,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_7(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_8(uint256) = REF_8 + REF_9,TMP_9(bool) = TMP_8 == previousBalances,TMP_10(None) = SOLIDITY_CALL assert(bool)(TMP_9)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_0(bool) = _to != 0
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_2(bool) = REF_1 >= _value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_4(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_5(bool) = TMP_4 >= REF_3
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_7(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_8(uint256) = REF_8 + REF_9
TMP_9(bool) = TMP_8 == previousBalances
TMP_10(None) = SOLIDITY_CALL assert(bool)(TMP_9)""];
}
",0,1,0,0,require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)
./0xd0a024e4b057024f941051dc19220a3bab4b5d45_ext.sol,RelexLife._transfer,39,55,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x55c4b50c93a5fa213078f96fbf0834cba17ebc43_ext.sol,Egypt._transfer,49,65,"TMP_4 = CONVERT 0 to address,TMP_5(bool) = _to != TMP_4,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_from],TMP_7(bool) = REF_2 >= _value,TMP_8(None) = SOLIDITY_CALL require(bool)(TMP_7),REF_3(uint256) -> balanceOf[_to],TMP_9(uint256) = REF_3 + _value,REF_4(uint256) -> balanceOf[_to],TMP_10(bool) = TMP_9 >= REF_4,TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10),REF_5(uint256) -> balanceOf[_from],REF_6(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_5 + REF_6,previousBalances(uint256) := TMP_12(uint256),REF_7(uint256) -> balanceOf[_from],REF_7(-> balanceOf) = REF_7 - _value,REF_8(uint256) -> balanceOf[_to],REF_8(-> balanceOf) = REF_8 + _value,Emit Transfer(_from,_to,_value),REF_9(uint256) -> balanceOf[_from],REF_10(uint256) -> balanceOf[_to],TMP_14(uint256) = REF_9 + REF_10,TMP_15(bool) = TMP_14 == previousBalances,TMP_16(None) = SOLIDITY_CALL assert(bool)(TMP_15)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0x0))

IRs:
TMP_4 = CONVERT 0 to address
TMP_5(bool) = _to != TMP_4
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_2(uint256) -> balanceOf[_from]
TMP_7(bool) = REF_2 >= _value
TMP_8(None) = SOLIDITY_CALL require(bool)(TMP_7)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_3(uint256) -> balanceOf[_to]
TMP_9(uint256) = REF_3 + _value
REF_4(uint256) -> balanceOf[_to]
TMP_10(bool) = TMP_9 >= REF_4
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_5(uint256) -> balanceOf[_from]
REF_6(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_5 + REF_6
previousBalances(uint256) := TMP_12(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_7(uint256) -> balanceOf[_from]
REF_7(-> balanceOf) = REF_7 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_8(uint256) -> balanceOf[_to]
REF_8(-> balanceOf) = REF_8 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_9(uint256) -> balanceOf[_from]
REF_10(uint256) -> balanceOf[_to]
TMP_14(uint256) = REF_9 + REF_10
TMP_15(bool) = TMP_14 == previousBalances
TMP_16(None) = SOLIDITY_CALL assert(bool)(TMP_15)""];
}
",0,1,0,0,"require(bool)(_to != address(0x0));require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x1811aacf243e28047ccb0126b9e0f3662ed48948_ext.sol,BB.burnFrom,213,221,"REF_23(uint256) -> balanceOf[_from],TMP_48(bool) = REF_23 >= _value,TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48),REF_24(mapping(address => uint256)) -> allowance[_from],REF_25(uint256) -> REF_24[msg.sender],TMP_50(bool) = _value <= REF_25,TMP_51(None) = SOLIDITY_CALL require(bool)(TMP_50),REF_26(uint256) -> balanceOf[_from],REF_26(-> balanceOf) = REF_26 - _value,REF_27(mapping(address => uint256)) -> allowance[_from],REF_28(uint256) -> REF_27[msg.sender],REF_28(-> allowance) = REF_28 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_23(uint256) -> balanceOf[_from]
TMP_48(bool) = REF_23 >= _value
TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_24(mapping(address => uint256)) -> allowance[_from]
REF_25(uint256) -> REF_24[msg.sender]
TMP_50(bool) = _value <= REF_25
TMP_51(None) = SOLIDITY_CALL require(bool)(TMP_50)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_26(uint256) -> balanceOf[_from]
REF_26(-> balanceOf) = REF_26 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_27(mapping(address => uint256)) -> allowance[_from]
REF_28(uint256) -> REF_27[msg.sender]
REF_28(-> allowance) = REF_28 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xa140297bd7aa035d6a4d5abc29b787555aae109f_ext.sol,RegularToken.transferFrom,96,115,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x0d2a65ef3e4c3509f00a3576495bd237f5817520_ext.sol,ENIGMA.NewQuestion,34,39,"TMP_12(bool) = msg.sender == questionSender,CONDITION TMP_12,question(string) := _question(string),responseHash(bytes32) := _responseHash(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == questionSender

IRs:
TMP_12(bool) = msg.sender == questionSender
CONDITION TMP_12""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
responseHash = _responseHash

IRs:
responseHash(bytes32) := _responseHash(bytes32)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,msg.sender == questionSender;question = _question;;responseHash = _responseHash
./0x4d55ee29f3806c6feb424ba5948d660586bd51d3_ext.sol,BB.burnFrom,151,159,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x295e65915bf0a884dcb225d0b60f95f25626e221_ext.sol,AbyssToken.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x837768a7231b3363fdddbf6dd89bde1c20dd4676_ext.sol,wphcToken.approveAndCall,204,209,"REF_18(mapping(address => uint256)) -> allowed[msg.sender],REF_19(uint256) -> REF_18[spender],REF_19(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_18(mapping(address => uint256)) -> allowed[msg.sender]
REF_19(uint256) -> REF_18[spender]
REF_19(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x330ac902cc4cb12e02249358dcfe3f60785e3439_ext.sol,Easy30.fallback,14,25,"sender(address) := msg.sender(address),REF_0(uint256) -> invests[sender],TMP_0(bool) = REF_0 != 0,CONDITION TMP_0,REF_1(uint256) -> invests[sender],TMP_1(uint256) = REF_1 / 100,TMP_2(uint256) = TMP_1 * 30,REF_2(uint256) -> dates[sender],TMP_3(uint256) = now - REF_2,TMP_4(uint256) = TMP_2 * TMP_3,TMP_5(uint256) = TMP_4 / 86400,payout(uint256) := TMP_5(uint256),TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),TMP_8(bool) = payout > TMP_7,CONDITION TMP_8,TMP_9 = CONVERT this to address,TMP_10(uint256) = SOLIDITY_CALL balance(address)(TMP_9),payout(uint256) := TMP_10(uint256),Transfer dest:sender value:payout,REF_4(uint256) -> dates[sender],REF_4(uint256) (->dates) := now(uint256),REF_5(uint256) -> invests[sender],REF_5(-> invests) = REF_5 + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
sender = msg.sender

IRs:
sender(address) := msg.sender(address)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
invests[sender] != 0

IRs:
REF_0(uint256) -> invests[sender]
TMP_0(bool) = REF_0 != 0
CONDITION TMP_0""];
2->3[label=""True""];
2->8[label=""False""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
payout = invests[sender] / 100 * 30 * (now - dates[sender]) / 86400

IRs:
REF_1(uint256) -> invests[sender]
TMP_1(uint256) = REF_1 / 100
TMP_2(uint256) = TMP_1 * 30
REF_2(uint256) -> dates[sender]
TMP_3(uint256) = now - REF_2
TMP_4(uint256) = TMP_2 * TMP_3
TMP_5(uint256) = TMP_4 / 86400
payout(uint256) := TMP_5(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
payout > address(this).balance

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
TMP_8(bool) = payout > TMP_7
CONDITION TMP_8""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
payout = address(this).balance

IRs:
TMP_9 = CONVERT this to address
TMP_10(uint256) = SOLIDITY_CALL balance(address)(TMP_9)
payout(uint256) := TMP_10(uint256)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
sender.transfer(payout)

IRs:
Transfer dest:sender value:payout""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
dates[sender] = now

IRs:
REF_4(uint256) -> dates[sender]
REF_4(uint256) (->dates) := now(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
invests[sender] += msg.value

IRs:
REF_5(uint256) -> invests[sender]
REF_5(-> invests) = REF_5 + msg.value""];
}
",0,1,0,0,sender = msg.sender;invests[sender] != 0;payout = invests[sender] / 100 * 30 * (now - dates[sender]) / 86400;;payout > address(this).balance;payout = address(this).balance;;sender.transfer(payout);dates[sender] = now;invests[sender] += msg.value
./0xa1292ec56f9b78b0fac3f9b80baac133078dd087_ext.sol,StandardToken.transferFrom,56,66,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x0d2dea6d6d6780860431e7c8b0cce6db4ca49a41_ext.sol,TokenERC20._transfer,45,61,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xdb03170241b7a789934b677a64fa49e7783b41d5_ext.sol,StandardToken.transfer,39,48,"REF_0(uint256) -> balances[msg.sender],TMP_14(bool) = REF_0 >= _value,TMP_15(bool) = _value > 0,TMP_16(bool) = TMP_14 && TMP_15,CONDITION TMP_16,REF_1(uint256) -> balances[msg.sender],REF_1(-> balances) = REF_1 - _value,REF_2(uint256) -> balances[_to],REF_2(-> balances) = REF_2 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[msg.sender] >= _value && _value > 0

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_14(bool) = REF_0 >= _value
TMP_15(bool) = _value > 0
TMP_16(bool) = TMP_14 && TMP_15
CONDITION TMP_16""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_1(-> balances) = REF_1 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_2(uint256) -> balances[_to]
REF_2(-> balances) = REF_2 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[msg.sender] >= _value && _value > 0;balances[msg.sender] -= _value;false;balances[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0xed3ce5919656b9988ab33c04a0e684ec94043f5b_ext.sol,UltraVioletToken.approveAndCall,203,208,"REF_24(mapping(address => uint256)) -> allowed[msg.sender],REF_25(uint256) -> REF_24[spender],REF_25(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_43 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_43(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_24(mapping(address => uint256)) -> allowed[msg.sender]
REF_25(uint256) -> REF_24[spender]
REF_25(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_43 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_43(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xa211db1867e4fa5dc0dd4d8f51f177a51d054d94_ext.sol,ZTKGamers.getZTKCheck,222,231,"REF_59(ZTKGamers.ZTKCheck) -> ZTKChecks[_address],REF_60(string) -> REF_59.accountNumber,REF_61(ZTKGamers.ZTKCheck) -> ZTKChecks[_address],REF_62(string) -> REF_61.routingNumber,REF_63(ZTKGamers.ZTKCheck) -> ZTKChecks[_address],REF_64(string) -> REF_63.institution,REF_65(ZTKGamers.ZTKCheck) -> ZTKChecks[_address],REF_66(string) -> REF_65.fullName,REF_67(ZTKGamers.ZTKCheck) -> ZTKChecks[_address],REF_68(uint256) -> REF_67.amount,REF_69(ZTKGamers.ZTKCheck) -> ZTKChecks[_address],REF_70(string) -> REF_69.checkFilePath,REF_71(ZTKGamers.ZTKCheck) -> ZTKChecks[_address],REF_72(string) -> REF_71.digitalCheckFingerPrint,RETURN REF_60,REF_62,REF_64,REF_66,REF_68,REF_70,REF_72","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
(ZTKChecks[_address].accountNumber,ZTKChecks[_address].routingNumber,ZTKChecks[_address].institution,ZTKChecks[_address].fullName,ZTKChecks[_address].amount,ZTKChecks[_address].checkFilePath,ZTKChecks[_address].digitalCheckFingerPrint)

IRs:
REF_59(ZTKGamers.ZTKCheck) -> ZTKChecks[_address]
REF_60(string) -> REF_59.accountNumber
REF_61(ZTKGamers.ZTKCheck) -> ZTKChecks[_address]
REF_62(string) -> REF_61.routingNumber
REF_63(ZTKGamers.ZTKCheck) -> ZTKChecks[_address]
REF_64(string) -> REF_63.institution
REF_65(ZTKGamers.ZTKCheck) -> ZTKChecks[_address]
REF_66(string) -> REF_65.fullName
REF_67(ZTKGamers.ZTKCheck) -> ZTKChecks[_address]
REF_68(uint256) -> REF_67.amount
REF_69(ZTKGamers.ZTKCheck) -> ZTKChecks[_address]
REF_70(string) -> REF_69.checkFilePath
REF_71(ZTKGamers.ZTKCheck) -> ZTKChecks[_address]
REF_72(string) -> REF_71.digitalCheckFingerPrint
RETURN REF_60,REF_62,REF_64,REF_66,REF_68,REF_70,REF_72""];
}
",0,1,0,0,"(ZTKChecks[_address].accountNumber,ZTKChecks[_address].routingNumber,ZTKChecks[_address].institution,ZTKChecks[_address].fullName,ZTKChecks[_address].amount,ZTKChecks[_address].checkFilePath,ZTKChecks[_address].digitalCheckFingerPrint)"
./0xaa70bc3e835e12d6902a8e4da77db4842e519c42_ext.sol,DhaCoin.mintToken,208,213,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x6c72582241de57e6fd501a99d85c650924039a50_ext.sol,WHC.burnFrom,142,150,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xd2d0f85b690604c245f61513bf4679b24ed64c35_ext.sol,BFDToken.transferFrom,215,226,"TMP_138(bool) = INTERNAL_CALL, BFDToken.canTransfer(address,uint256)(_from,_value),TMP_139(None) = SOLIDITY_CALL require(bool)(TMP_138),REF_67(mapping(address => uint256)) -> allowed[_from],REF_68(uint256) -> REF_67[msg.sender],allowance(uint256) := REF_68(uint256),REF_69(uint256) -> balances[_from],TMP_140(bool) = REF_69 >= _value,TMP_141(bool) = allowance >= _value,TMP_142(bool) = TMP_140 && TMP_141,TMP_143(None) = SOLIDITY_CALL require(bool)(TMP_142),REF_70(uint256) -> balances[_to],REF_70(-> balances) = REF_70 + _value,REF_71(uint256) -> balances[_from],REF_71(-> balances) = REF_71 - _value,TMP_144(bool) = allowance < MAX_UINT256,CONDITION TMP_144,REF_72(mapping(address => uint256)) -> allowed[_from],REF_73(uint256) -> REF_72[msg.sender],REF_73(-> allowed) = REF_73 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(canTransfer(_from,_value))

IRs:
TMP_138(bool) = INTERNAL_CALL, BFDToken.canTransfer(address,uint256)(_from,_value)
TMP_139(None) = SOLIDITY_CALL require(bool)(TMP_138)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
allowance = allowed[_from][msg.sender]

IRs:
REF_67(mapping(address => uint256)) -> allowed[_from]
REF_68(uint256) -> REF_67[msg.sender]
allowance(uint256) := REF_68(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balances[_from] >= _value && allowance >= _value)

IRs:
REF_69(uint256) -> balances[_from]
TMP_140(bool) = REF_69 >= _value
TMP_141(bool) = allowance >= _value
TMP_142(bool) = TMP_140 && TMP_141
TMP_143(None) = SOLIDITY_CALL require(bool)(TMP_142)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] += _value

IRs:
REF_70(uint256) -> balances[_to]
REF_70(-> balances) = REF_70 + _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[_from] -= _value

IRs:
REF_71(uint256) -> balances[_from]
REF_71(-> balances) = REF_71 - _value""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
allowance < MAX_UINT256

IRs:
TMP_144(bool) = allowance < MAX_UINT256
CONDITION TMP_144""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_72(mapping(address => uint256)) -> allowed[_from]
REF_73(uint256) -> REF_72[msg.sender]
REF_73(-> allowed) = REF_73 - _value""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
9->10;
10[label=""Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True""];
11[label=""Node Type: RETURN 11

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(canTransfer(_from,_value));allowance = allowed[_from][msg.sender];require(bool)(balances[_from] >= _value && allowance >= _value);balances[_to] += _value;balances[_from] -= _value;allowance < MAX_UINT256;allowed[_from][msg.sender] -= _value;;Transfer(_from,_to,_value);true;success"
./0x334eec1482109bd802d9e72a447848de3bcc1063_ext.sol,AirDropToken.redeemPackage,98,126,"TMP_16(uint256) = index / 256,REF_17(uint256) -> _redeemed[TMP_16],redeemedBlock(uint256) := REF_17(uint256),TMP_17 = CONVERT 1 to uint256,TMP_18(uint256) = index % 256,TMP_19 = CONVERT TMP_18 to uint256,TMP_20(uint256) = TMP_17 << TMP_19,redeemedMask(uint256) := TMP_20(uint256),TMP_21(uint256) = redeemedBlock & redeemedMask,TMP_22(bool) = TMP_21 == 0,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),TMP_24(uint256) = index / 256,REF_18(uint256) -> _redeemed[TMP_24],TMP_25(uint256) = redeemedBlock | redeemedMask,REF_18(uint256) (->_redeemed) := TMP_25(uint256),TMP_26(bytes32) = SOLIDITY_CALL keccak256()(index,recipient,amount),node(bytes32) := TMP_26(bytes32),path(uint256) := index(uint256),i(uint16) := 0(uint256),REF_19 -> LENGTH merkleProof,TMP_27(bool) = i < REF_19,CONDITION TMP_27,TMP_28(uint256) = path & 1,TMP_29(bool) = TMP_28 == 1,CONDITION TMP_29,REF_20(bytes32) -> merkleProof[i],TMP_30(bytes32) = SOLIDITY_CALL keccak256()(REF_20,node),node(bytes32) := TMP_30(bytes32),REF_21(bytes32) -> merkleProof[i],TMP_31(bytes32) = SOLIDITY_CALL keccak256()(node,REF_21),node(bytes32) := TMP_31(bytes32),path(uint256) = path / 2,TMP_32(uint16) := i(uint16),i(uint16) = i + 1,TMP_33(bool) = node == _rootHash,TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33),REF_22(uint256) -> _balances[recipient],REF_22(-> _balances) = REF_22 + amount,_totalSupply(uint256) = _totalSupply + amount,Emit Transfer(0,recipient,amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
redeemedBlock = _redeemed[index / 256]

IRs:
TMP_16(uint256) = index / 256
REF_17(uint256) -> _redeemed[TMP_16]
redeemedBlock(uint256) := REF_17(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
redeemedMask = (uint256(1) << uint256(index % 256))

IRs:
TMP_17 = CONVERT 1 to uint256
TMP_18(uint256) = index % 256
TMP_19 = CONVERT TMP_18 to uint256
TMP_20(uint256) = TMP_17 << TMP_19
redeemedMask(uint256) := TMP_20(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)((redeemedBlock & redeemedMask) == 0)

IRs:
TMP_21(uint256) = redeemedBlock & redeemedMask
TMP_22(bool) = TMP_21 == 0
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
_redeemed[index / 256] = redeemedBlock | redeemedMask

IRs:
TMP_24(uint256) = index / 256
REF_18(uint256) -> _redeemed[TMP_24]
TMP_25(uint256) = redeemedBlock | redeemedMask
REF_18(uint256) (->_redeemed) := TMP_25(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
node = keccak256()(index,recipient,amount)

IRs:
TMP_26(bytes32) = SOLIDITY_CALL keccak256()(index,recipient,amount)
node(bytes32) := TMP_26(bytes32)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
path = index

IRs:
path(uint256) := index(uint256)""];
6->9;
7[label=""Node Type: BEGIN_LOOP 7
""];
7->10;
8[label=""Node Type: END_LOOP 8
""];
8->17;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
i = 0

IRs:
i(uint16) := 0(uint256)""];
9->7;
10[label=""Node Type: IF_LOOP 10

EXPRESSION:
i < merkleProof.length

IRs:
REF_19 -> LENGTH merkleProof
TMP_27(bool) = i < REF_19
CONDITION TMP_27""];
10->11[label=""True""];
10->8[label=""False""];
11[label=""Node Type: IF 11

EXPRESSION:
(path & 0x01) == 1

IRs:
TMP_28(uint256) = path & 1
TMP_29(bool) = TMP_28 == 1
CONDITION TMP_29""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
node = keccak256()(merkleProof[i],node)

IRs:
REF_20(bytes32) -> merkleProof[i]
TMP_30(bytes32) = SOLIDITY_CALL keccak256()(REF_20,node)
node(bytes32) := TMP_30(bytes32)""];
12->14;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
node = keccak256()(node,merkleProof[i])

IRs:
REF_21(bytes32) -> merkleProof[i]
TMP_31(bytes32) = SOLIDITY_CALL keccak256()(node,REF_21)
node(bytes32) := TMP_31(bytes32)""];
13->14;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
path /= 2

IRs:
path(uint256) = path / 2""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
i ++

IRs:
TMP_32(uint16) := i(uint16)
i(uint16) = i + 1""];
16->10;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
require(bool)(node == _rootHash)

IRs:
TMP_33(bool) = node == _rootHash
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
_balances[recipient] += amount

IRs:
REF_22(uint256) -> _balances[recipient]
REF_22(-> _balances) = REF_22 + amount""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
_totalSupply += amount

IRs:
_totalSupply(uint256) = _totalSupply + amount""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
Transfer(0,recipient,amount)

IRs:
Emit Transfer(0,recipient,amount)""];
}
",0,1,0,0,"redeemedBlock = _redeemed[index / 256];redeemedMask = (uint256(1) << uint256(index % 256));require(bool)((redeemedBlock & redeemedMask) == 0);_redeemed[index / 256] = redeemedBlock | redeemedMask;node = keccak256()(index,recipient,amount);path = index;i = 0;;i < merkleProof.length;;require(bool)(node == _rootHash);(path & 0x01) == 1;node = keccak256()(merkleProof[i],node);node = keccak256()(node,merkleProof[i]);;path /= 2;i ++;_balances[recipient] += amount;_totalSupply += amount;Transfer(0,recipient,amount)"
./0x71402645d25196842b0434a1805726b7c0eef426_ext.sol,BlueChips.buy,158,225,"TMP_4(bool) = _card < totalCards,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),TMP_6(bool) = now >= ACTIVATION_TIME,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_52(uint256) -> cardPrice[_card],TMP_8(bool) = msg.value >= REF_52,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_53(address) -> cardOwner[_card],TMP_10(bool) = msg.sender != REF_53,TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10),REF_54(uint256) -> cardPrice[_card],TMP_12(bool) = msg.value > REF_54,CONDITION TMP_12,REF_56(uint256) -> cardPrice[_card],TMP_13(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.value', 'REF_56'] ,_excess(uint256) := TMP_13(uint256),REF_57(uint256) -> ownerAccounts[msg.sender],REF_57(-> ownerAccounts) = REF_57 + _excess,REF_58(uint256) -> cardPrice[_card],REF_59(uint256) -> cardPreviousPrice[_card],INTERNAL_CALL, BlueChips.addtotalCardValue(uint256,uint256)(REF_58,REF_59),REF_62(uint256) -> cardPrice[_card],TMP_15(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_62', 'cardPriceIncrement'] ,TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_15', '100'] ,_newPrice(uint256) := TMP_16(uint256),REF_64(uint256) -> cardPrice[_card],REF_65(uint256) -> cardPreviousPrice[_card],TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_64', 'REF_65'] ,_baseDividends(uint256) := TMP_17(uint256),TMP_18(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalDivsProduced', '_baseDividends'] ,totalDivsProduced(uint256) := TMP_18(uint256),TMP_19(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_baseDividends', 'blueDivRate'] ,TMP_20(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_19', '100'] ,_blueDividends(uint256) := TMP_20(uint256),TMP_21(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_baseDividends', 'ownerDivRate'] ,TMP_22(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_21', '100'] ,_ownerDividends(uint256) := TMP_22(uint256),REF_71(uint256) -> totalCardDivs[_card],REF_73(uint256) -> totalCardDivs[_card],TMP_23(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_73', '_ownerDividends'] ,REF_71(uint256) (->totalCardDivs) := TMP_23(uint256),REF_75(uint256) -> cardPreviousPrice[_card],TMP_24(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_ownerDividends', 'REF_75'] ,_ownerDividends(uint256) := TMP_24(uint256),TMP_25(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_baseDividends', 'distDivRate'] ,TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_25', '100'] ,_distDividends(uint256) := TMP_26(uint256),TMP_27(bool) = _referrer != msg.sender,CONDITION TMP_27,TMP_28(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_baseDividends', 'referralRate'] ,TMP_29(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_28', '100'] ,_referralDividends(uint256) := TMP_29(uint256),TMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_distDividends', '_referralDividends'] ,_distDividends(uint256) := TMP_30(uint256),TMP_31(bool) = _referrer == 0,CONDITION TMP_31,Transfer dest:blueDividendAddr value:_referralDividends,REF_82(uint256) -> ownerAccounts[_referrer],REF_84(uint256) -> ownerAccounts[_referrer],TMP_33(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_84', '_referralDividends'] ,REF_82(uint256) (->ownerAccounts) := TMP_33(uint256),REF_85(address) -> cardOwner[_card],_previousOwner(address) := REF_85(address),_newOwner(address) := msg.sender(address),REF_86(uint256) -> ownerAccounts[_previousOwner],REF_88(uint256) -> ownerAccounts[_previousOwner],TMP_34(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_88', '_ownerDividends'] ,REF_86(uint256) (->ownerAccounts) := TMP_34(uint256),Transfer dest:blueDividendAddr value:_blueDividends,INTERNAL_CALL, BlueChips.distributeDivs(uint256)(_distDividends),REF_90(uint256) -> cardPreviousPrice[_card],REF_91(uint256) -> cardPrice[_card],REF_90(uint256) (->cardPreviousPrice) := REF_91(uint256),REF_92(uint256) -> cardPrice[_card],REF_92(uint256) (->cardPrice) := _newPrice(uint256),REF_93(address) -> cardOwner[_card],REF_93(address) (->cardOwner) := _newOwner(address),REF_94(uint256) -> cardPreviousPrice[_card],Emit oncardPurchase(msg.sender,REF_94,_card,_newPrice)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_card < totalCards)

IRs:
TMP_4(bool) = _card < totalCards
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(now >= ACTIVATION_TIME)

IRs:
TMP_6(bool) = now >= ACTIVATION_TIME
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(msg.value >= cardPrice[_card])

IRs:
REF_52(uint256) -> cardPrice[_card]
TMP_8(bool) = msg.value >= REF_52
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(msg.sender != cardOwner[_card])

IRs:
REF_53(address) -> cardOwner[_card]
TMP_10(bool) = msg.sender != REF_53
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
msg.value > cardPrice[_card]

IRs:
REF_54(uint256) -> cardPrice[_card]
TMP_12(bool) = msg.value > REF_54
CONDITION TMP_12""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
_excess = SafeMath.sub(msg.value,cardPrice[_card])

IRs:
REF_56(uint256) -> cardPrice[_card]
TMP_13(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.value', 'REF_56'] 
_excess(uint256) := TMP_13(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
ownerAccounts[msg.sender] += _excess

IRs:
REF_57(uint256) -> ownerAccounts[msg.sender]
REF_57(-> ownerAccounts) = REF_57 + _excess""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
addtotalCardValue(cardPrice[_card],cardPreviousPrice[_card])

IRs:
REF_58(uint256) -> cardPrice[_card]
REF_59(uint256) -> cardPreviousPrice[_card]
INTERNAL_CALL, BlueChips.addtotalCardValue(uint256,uint256)(REF_58,REF_59)""];
9->10;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
_newPrice = SafeMath.div(SafeMath.mul(cardPrice[_card],cardPriceIncrement),100)

IRs:
REF_62(uint256) -> cardPrice[_card]
TMP_15(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_62', 'cardPriceIncrement'] 
TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_15', '100'] 
_newPrice(uint256) := TMP_16(uint256)""];
10->11;
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
_baseDividends = SafeMath.sub(cardPrice[_card],cardPreviousPrice[_card])

IRs:
REF_64(uint256) -> cardPrice[_card]
REF_65(uint256) -> cardPreviousPrice[_card]
TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_64', 'REF_65'] 
_baseDividends(uint256) := TMP_17(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
totalDivsProduced = SafeMath.add(totalDivsProduced,_baseDividends)

IRs:
TMP_18(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalDivsProduced', '_baseDividends'] 
totalDivsProduced(uint256) := TMP_18(uint256)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
_blueDividends = SafeMath.div(SafeMath.mul(_baseDividends,blueDivRate),100)

IRs:
TMP_19(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_baseDividends', 'blueDivRate'] 
TMP_20(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_19', '100'] 
_blueDividends(uint256) := TMP_20(uint256)""];
13->14;
14[label=""Node Type: NEW VARIABLE 14

EXPRESSION:
_ownerDividends = SafeMath.div(SafeMath.mul(_baseDividends,ownerDivRate),100)

IRs:
TMP_21(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_baseDividends', 'ownerDivRate'] 
TMP_22(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_21', '100'] 
_ownerDividends(uint256) := TMP_22(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
totalCardDivs[_card] = SafeMath.add(totalCardDivs[_card],_ownerDividends)

IRs:
REF_71(uint256) -> totalCardDivs[_card]
REF_73(uint256) -> totalCardDivs[_card]
TMP_23(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_73', '_ownerDividends'] 
REF_71(uint256) (->totalCardDivs) := TMP_23(uint256)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
_ownerDividends = SafeMath.add(_ownerDividends,cardPreviousPrice[_card])

IRs:
REF_75(uint256) -> cardPreviousPrice[_card]
TMP_24(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_ownerDividends', 'REF_75'] 
_ownerDividends(uint256) := TMP_24(uint256)""];
16->17;
17[label=""Node Type: NEW VARIABLE 17

EXPRESSION:
_distDividends = SafeMath.div(SafeMath.mul(_baseDividends,distDivRate),100)

IRs:
TMP_25(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_baseDividends', 'distDivRate'] 
TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_25', '100'] 
_distDividends(uint256) := TMP_26(uint256)""];
17->18;
18[label=""Node Type: IF 18

EXPRESSION:
_referrer != msg.sender

IRs:
TMP_27(bool) = _referrer != msg.sender
CONDITION TMP_27""];
18->19[label=""True""];
18->25[label=""False""];
19[label=""Node Type: NEW VARIABLE 19

EXPRESSION:
_referralDividends = SafeMath.div(SafeMath.mul(_baseDividends,referralRate),100)

IRs:
TMP_28(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_baseDividends', 'referralRate'] 
TMP_29(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_28', '100'] 
_referralDividends(uint256) := TMP_29(uint256)""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
_distDividends = SafeMath.sub(_distDividends,_referralDividends)

IRs:
TMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_distDividends', '_referralDividends'] 
_distDividends(uint256) := TMP_30(uint256)""];
20->21;
21[label=""Node Type: IF 21

EXPRESSION:
_referrer == 0x0

IRs:
TMP_31(bool) = _referrer == 0
CONDITION TMP_31""];
21->22[label=""True""];
21->23[label=""False""];
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
blueDividendAddr.transfer(_referralDividends)

IRs:
Transfer dest:blueDividendAddr value:_referralDividends""];
22->24;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
ownerAccounts[_referrer] = SafeMath.add(ownerAccounts[_referrer],_referralDividends)

IRs:
REF_82(uint256) -> ownerAccounts[_referrer]
REF_84(uint256) -> ownerAccounts[_referrer]
TMP_33(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_84', '_referralDividends'] 
REF_82(uint256) (->ownerAccounts) := TMP_33(uint256)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->26;
26[label=""Node Type: NEW VARIABLE 26

EXPRESSION:
_previousOwner = cardOwner[_card]

IRs:
REF_85(address) -> cardOwner[_card]
_previousOwner(address) := REF_85(address)""];
26->27;
27[label=""Node Type: NEW VARIABLE 27

EXPRESSION:
_newOwner = msg.sender

IRs:
_newOwner(address) := msg.sender(address)""];
27->28;
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
ownerAccounts[_previousOwner] = SafeMath.add(ownerAccounts[_previousOwner],_ownerDividends)

IRs:
REF_86(uint256) -> ownerAccounts[_previousOwner]
REF_88(uint256) -> ownerAccounts[_previousOwner]
TMP_34(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_88', '_ownerDividends'] 
REF_86(uint256) (->ownerAccounts) := TMP_34(uint256)""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
blueDividendAddr.transfer(_blueDividends)

IRs:
Transfer dest:blueDividendAddr value:_blueDividends""];
29->30;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
distributeDivs(_distDividends)

IRs:
INTERNAL_CALL, BlueChips.distributeDivs(uint256)(_distDividends)""];
30->31;
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
cardPreviousPrice[_card] = cardPrice[_card]

IRs:
REF_90(uint256) -> cardPreviousPrice[_card]
REF_91(uint256) -> cardPrice[_card]
REF_90(uint256) (->cardPreviousPrice) := REF_91(uint256)""];
31->32;
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
cardPrice[_card] = _newPrice

IRs:
REF_92(uint256) -> cardPrice[_card]
REF_92(uint256) (->cardPrice) := _newPrice(uint256)""];
32->33;
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
cardOwner[_card] = _newOwner

IRs:
REF_93(address) -> cardOwner[_card]
REF_93(address) (->cardOwner) := _newOwner(address)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
oncardPurchase(msg.sender,cardPreviousPrice[_card],_card,_newPrice)

IRs:
REF_94(uint256) -> cardPreviousPrice[_card]
Emit oncardPurchase(msg.sender,REF_94,_card,_newPrice)""];
}
",0,1,0,0,"require(bool)(_card < totalCards);require(bool)(now >= ACTIVATION_TIME);require(bool)(msg.value >= cardPrice[_card]);require(bool)(msg.sender != cardOwner[_card]);msg.value > cardPrice[_card];_excess = SafeMath.sub(msg.value,cardPrice[_card]);;ownerAccounts[msg.sender] += _excess;addtotalCardValue(cardPrice[_card],cardPreviousPrice[_card]);_newPrice = SafeMath.div(SafeMath.mul(cardPrice[_card],cardPriceIncrement),100);_baseDividends = SafeMath.sub(cardPrice[_card],cardPreviousPrice[_card]);totalDivsProduced = SafeMath.add(totalDivsProduced,_baseDividends);_blueDividends = SafeMath.div(SafeMath.mul(_baseDividends,blueDivRate),100);_ownerDividends = SafeMath.div(SafeMath.mul(_baseDividends,ownerDivRate),100);totalCardDivs[_card] = SafeMath.add(totalCardDivs[_card],_ownerDividends);_ownerDividends = SafeMath.add(_ownerDividends,cardPreviousPrice[_card]);_distDividends = SafeMath.div(SafeMath.mul(_baseDividends,distDivRate),100);_referrer != msg.sender;_referralDividends = SafeMath.div(SafeMath.mul(_baseDividends,referralRate),100);;_distDividends = SafeMath.sub(_distDividends,_referralDividends);_referrer == 0x0;blueDividendAddr.transfer(_referralDividends);ownerAccounts[_referrer] = SafeMath.add(ownerAccounts[_referrer],_referralDividends);;_previousOwner = cardOwner[_card];_newOwner = msg.sender;ownerAccounts[_previousOwner] = SafeMath.add(ownerAccounts[_previousOwner],_ownerDividends);blueDividendAddr.transfer(_blueDividends);distributeDivs(_distDividends);cardPreviousPrice[_card] = cardPrice[_card];cardPrice[_card] = _newPrice;cardOwner[_card] = _newOwner;oncardPurchase(msg.sender,cardPreviousPrice[_card],_card,_newPrice)"
./0xf449ef0007c98761bdfced7ab1d0351f71d30468_ext.sol,Danetonbit.transfer,21,27,"REF_1(uint256) -> balances[msg.sender],TMP_1(bool) = REF_1 >= _value,TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1),REF_2(uint256) -> balances[msg.sender],REF_2(-> balances) = REF_2 - _value,REF_3(uint256) -> balances[_to],REF_3(-> balances) = REF_3 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_1(bool) = REF_1 >= _value
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_2(uint256) -> balances[msg.sender]
REF_2(-> balances) = REF_2 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_3(uint256) -> balances[_to]
REF_3(-> balances) = REF_3 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0x4bb301e545a3e948b20ea9a0f02d3948af6fe6db_ext.sol,TarynToken.addToAddresses,91,97,"REF_4(uint256) -> indexes[_address],TMP_26(bool) = REF_4 == 0,CONDITION TMP_26,REF_5(address) -> addresses[index],REF_5(address) (->addresses) := _address(address),REF_6(uint256) -> indexes[_address],REF_6(uint256) (->indexes) := index(uint256),TMP_27(uint256) := index(uint256),index(uint256) = index + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
indexes[_address] == 0

IRs:
REF_4(uint256) -> indexes[_address]
TMP_26(bool) = REF_4 == 0
CONDITION TMP_26""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
addresses[index] = _address

IRs:
REF_5(address) -> addresses[index]
REF_5(address) (->addresses) := _address(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
indexes[_address] = index

IRs:
REF_6(uint256) -> indexes[_address]
REF_6(uint256) (->indexes) := index(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
index ++

IRs:
TMP_27(uint256) := index(uint256)
index(uint256) = index + 1""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,1,0,0,indexes[_address] == 0;addresses[index] = _address;;indexes[_address] = index;index ++
./0xc668715818831645cdf0eee3a9b84590fa979e65_ext.sol,BGAToken.totalSupply,118,120,"TMP_58 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_58],TMP_59(uint256) = _totalSupply - REF_1,RETURN TMP_59","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_58 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_58]
TMP_59(uint256) = _totalSupply - REF_1
RETURN TMP_59""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x55aa079e2fb0c8b68a0a08efbff3f1aa5472f1a2_ext.sol,WannabeSmartInvestor.fallback,22,24,"REF_4(uint256) -> incomeFrom[msg.sender],REF_5(uint256) -> incomeFrom[msg.sender],TMP_11(uint256) = REF_5 + msg.value,REF_4(uint256) (->incomeFrom) := TMP_11(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
incomeFrom[msg.sender] = incomeFrom[msg.sender] + msg.value

IRs:
REF_4(uint256) -> incomeFrom[msg.sender]
REF_5(uint256) -> incomeFrom[msg.sender]
TMP_11(uint256) = REF_5 + msg.value
REF_4(uint256) (->incomeFrom) := TMP_11(uint256)""];
}
",0,1,0,0,incomeFrom[msg.sender] = incomeFrom[msg.sender] + msg.value
./0x64fac631db32d70d77e0b759f9a27e1f6b9e9f6f_ext.sol,TON.approveAndCall,51,59,"TMP_17 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_17(tokenRecipient),TMP_18(bool) = INTERNAL_CALL, TON.approve(address,uint256)(_spender,_value),CONDITION TMP_18,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_17 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_17(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_18(bool) = INTERNAL_CALL, TON.approve(address,uint256)(_spender,_value)
CONDITION TMP_18""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x91e1dcfbfe7b6be8ac836d08fb493b085ebbb3ef_ext.sol,CoinLottoToken.totalSupply,153,155,"TMP_53 = CONVERT 0 to address,REF_24(uint256) -> tokenBalances[TMP_53],TMP_54(uint256) = totalSupply - REF_24,RETURN TMP_54","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
totalSupply - tokenBalances[address(0)]

IRs:
TMP_53 = CONVERT 0 to address
REF_24(uint256) -> tokenBalances[TMP_53]
TMP_54(uint256) = totalSupply - REF_24
RETURN TMP_54""];
}
",0,1,0,0,totalSupply - tokenBalances[address(0)]
./0x508f36baac673fe9e213e69f0f75cbcfeb015917_ext.sol,MKT.burnFrom,142,150,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xeecfa1f63f9cce7ae80a49d5341dcba2563d72e1_ext.sol,TokenERC20.burnFrom,140,148,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x3fcf78f7646f85ceb9344c5ba5a05a0e31a462af_ext.sol,archercoin.mintToken,196,201,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x2906f2b553dcfda6891cba64b0ac9e5780b5c1a6_ext.sol,CoinCopyTrade.totalSupply,129,131,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x1c242bc9af8aa768a54222ed47bb756f1a1a757b_ext.sol,SafeMath.add,50,55,"TMP_9(uint256) = _a + _b,c(uint256) := TMP_9(uint256),TMP_10(bool) = c >= _a,TMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10),RETURN c","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
c = _a + _b

IRs:
TMP_9(uint256) = _a + _b
c(uint256) := TMP_9(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= _a)

IRs:
TMP_10(bool) = c >= _a
TMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c""];
}
",0,1,0,0,c = _a + _b;assert(bool)(c >= _a);c
./0x5044ac8da9601edf970dcc91a10c5f41c5c548c0_ext.sol,UPower.dividendsOf,460,466,"REF_38(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_67(uint256) = profitPerShare_ * REF_38,TMP_68 = CONVERT TMP_67 to int256,REF_39(int256) -> payoutsTo_[_customerAddress],TMP_69(int256) = TMP_68 - REF_39,TMP_70 = CONVERT TMP_69 to uint256,TMP_71(uint256) = TMP_70 / magnitude,RETURN TMP_71","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_38(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_67(uint256) = profitPerShare_ * REF_38
TMP_68 = CONVERT TMP_67 to int256
REF_39(int256) -> payoutsTo_[_customerAddress]
TMP_69(int256) = TMP_68 - REF_39
TMP_70 = CONVERT TMP_69 to uint256
TMP_71(uint256) = TMP_70 / magnitude
RETURN TMP_71""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x3f9ad22a9c2a52bda2a0811d1080fc9cd23c6c46_ext.sol,IBITToken.burn,49,55,"REF_16(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_16 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_17(uint256) -> balanceOf[msg.sender],REF_17(-> balanceOf) = REF_17 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_16(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_16 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
REF_17(-> balanceOf) = REF_17 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xb4b330972e302081ebacd054f4305a3af4103f0f_ext.sol,CryptoTradeToken.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x01628c3308f798362f89886bdac1506e0b33a045_ext.sol,CBC.mintToken,206,211,"REF_29(uint256) -> balances[target],REF_29(-> balances) = REF_29 + mintedAmount,_totalSupply(uint256) = _totalSupply + mintedAmount,Emit Transfer(0,owner,mintedAmount),Emit Transfer(owner,target,mintedAmount),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances[target] += mintedAmount

IRs:
REF_29(uint256) -> balances[target]
REF_29(-> balances) = REF_29 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_totalSupply += mintedAmount

IRs:
_totalSupply(uint256) = _totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,owner,mintedAmount)

IRs:
Emit Transfer(0,owner,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(owner,target,mintedAmount)

IRs:
Emit Transfer(owner,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balances[target] += mintedAmount;_totalSupply += mintedAmount;Transfer(0,owner,mintedAmount);Transfer(owner,target,mintedAmount)"
./0x8564e222115248d10593cf4a6719fa6d82194e62_ext.sol,ITube.approveAndCall,204,209,"REF_18(mapping(address => uint256)) -> allowed[msg.sender],REF_19(uint256) -> REF_18[spender],REF_19(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_18(mapping(address => uint256)) -> allowed[msg.sender]
REF_19(uint256) -> REF_18[spender]
REF_19(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x01d706ed109e2038ae3261e30a1ed1af207a9d2c_ext.sol,ETHERECASHTOKEN.burn,128,134,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x39127b81f7c63dcc2477079bd17f08256584f623_ext.sol,VOCC_I055_20181211.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x32cd77627ddb1dd8bda46e35c6e68aadfe916066_ext.sol,RedlineFinancialLabCoin.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xb4933b15b21924af2c18012c4da78b182f060107_ext.sol,ERC20x._transferBalance,278,282,"REF_41(uint256) -> balances[_from],TMP_115(bool) = REF_41 >= _value,TMP_116(None) = SOLIDITY_CALL require(bool)(TMP_115),REF_42(uint256) -> balances[_from],REF_42(-> balances) = REF_42 - _value,REF_43(uint256) -> balances[_to],REF_43(-> balances) = REF_43 + _value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[_from] >= _value)

IRs:
REF_41(uint256) -> balances[_from]
TMP_115(bool) = REF_41 >= _value
TMP_116(None) = SOLIDITY_CALL require(bool)(TMP_115)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_from] -= _value

IRs:
REF_42(uint256) -> balances[_from]
REF_42(-> balances) = REF_42 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_43(uint256) -> balances[_to]
REF_43(-> balances) = REF_43 + _value""];
}
",0,1,0,0,require(bool)(balances[_from] >= _value);balances[_from] -= _value;balances[_to] += _value
./0x51696e028e0fe5416481c28cf1a2626d43680751_ext.sol,IngridIsAHorribleHumanCoin.transfer,53,59,"REF_1(uint256) -> balances[msg.sender],TMP_0(bool) = REF_1 >= _value,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_2(uint256) -> balances[msg.sender],REF_2(-> balances) = REF_2 - _value,REF_3(uint256) -> balances[_to],REF_3(-> balances) = REF_3 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_0(bool) = REF_1 >= _value
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_2(uint256) -> balances[msg.sender]
REF_2(-> balances) = REF_2 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_3(uint256) -> balances[_to]
REF_3(-> balances) = REF_3 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0xeafff1c115d5f8060531356a21c46668eff6da96_ext.sol,EasyInvest35.fallback,27,44,"REF_0(uint256) -> invested[msg.sender],TMP_0(bool) = REF_0 != 0,CONDITION TMP_0,REF_1(uint256) -> invested[msg.sender],TMP_1(uint256) = REF_1 * 35,TMP_2(uint256) = TMP_1 / 100,REF_2(uint256) -> atBlock[msg.sender],TMP_3(uint256) = block.number - REF_2,TMP_4(uint256) = TMP_2 * TMP_3,TMP_5(uint256) = TMP_4 / 5900,amount(uint256) := TMP_5(uint256),Transfer dest:msg.sender value:amount,REF_4(uint256) -> atBlock[msg.sender],REF_4(uint256) (->atBlock) := block.number(uint256),REF_5(uint256) -> invested[msg.sender],REF_5(-> invested) = REF_5 + msg.value,TMP_7 = CONVERT 546274073785053080684736382228296002613547365560 to address,TMP_8(uint256) = msg.value / 20,Transfer dest:TMP_7 value:TMP_8","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
invested[msg.sender] != 0

IRs:
REF_0(uint256) -> invested[msg.sender]
TMP_0(bool) = REF_0 != 0
CONDITION TMP_0""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = invested[msg.sender] * 35 / 100 * (block.number - atBlock[msg.sender]) / 5900

IRs:
REF_1(uint256) -> invested[msg.sender]
TMP_1(uint256) = REF_1 * 35
TMP_2(uint256) = TMP_1 / 100
REF_2(uint256) -> atBlock[msg.sender]
TMP_3(uint256) = block.number - REF_2
TMP_4(uint256) = TMP_2 * TMP_3
TMP_5(uint256) = TMP_4 / 5900
amount(uint256) := TMP_5(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
atBlock[msg.sender] = block.number

IRs:
REF_4(uint256) -> atBlock[msg.sender]
REF_4(uint256) (->atBlock) := block.number(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
invested[msg.sender] += msg.value

IRs:
REF_5(uint256) -> invested[msg.sender]
REF_5(-> invested) = REF_5 + msg.value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
address(0x5fAFC6d356679aFfFb4dE085793d54d310E3f4b8).transfer(msg.value / 20)

IRs:
TMP_7 = CONVERT 546274073785053080684736382228296002613547365560 to address
TMP_8(uint256) = msg.value / 20
Transfer dest:TMP_7 value:TMP_8""];
}
",0,1,0,0,invested[msg.sender] != 0;amount = invested[msg.sender] * 35 / 100 * (block.number - atBlock[msg.sender]) / 5900;;msg.sender.transfer(amount);atBlock[msg.sender] = block.number;invested[msg.sender] += msg.value;address(0x5fAFC6d356679aFfFb4dE085793d54d310E3f4b8).transfer(msg.value / 20)
./0x88ac7fbe0024b025ea61db8c7389aab7e75cf2ee_ext.sol,GrandTourer.transfer,107,117,"REF_1(uint256) -> balances[msg.sender],TMP_21(bool) = REF_1 >= _value,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),TMP_23(bool) = msg.sender == _to,REF_2(uint256) -> balances[_to],TMP_24(uint256) = MAX_UINT256 - _value,TMP_25(bool) = REF_2 <= TMP_24,TMP_26(bool) = TMP_23 || TMP_25,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_3(uint256) -> balances[msg.sender],REF_3(-> balances) = REF_3 - _value,REF_4(uint256) -> balances[_to],REF_4(-> balances) = REF_4 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_21(bool) = REF_1 >= _value
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == _to || balances[_to] <= MAX_UINT256 - _value)

IRs:
TMP_23(bool) = msg.sender == _to
REF_2(uint256) -> balances[_to]
TMP_24(uint256) = MAX_UINT256 - _value
TMP_25(bool) = REF_2 <= TMP_24
TMP_26(bool) = TMP_23 || TMP_25
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_3(uint256) -> balances[msg.sender]
REF_3(-> balances) = REF_3 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] += _value

IRs:
REF_4(uint256) -> balances[_to]
REF_4(-> balances) = REF_4 + _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);require(bool)(msg.sender == _to || balances[_to] <= MAX_UINT256 - _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true"
./0x260cd379410a753cb602c76ae59bfba68246e789_ext.sol,Token365.burn,81,87,"REF_17(uint256) -> balanceOf[msg.sender],TMP_25(bool) = REF_17 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_25(bool) = REF_17 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x418ce003a8ad9925239bd20ea52abc1d950aeea1_ext.sol,KidChain.approveAndCall,78,83,"REF_39(mapping(address => uint256)) -> allowed[msg.sender],REF_40(uint256) -> REF_39[_spender],REF_40(uint256) (->allowed) := _value(uint256),Emit Approval(msg.sender,_spender,_value),TMP_45(bytes32) = SOLIDITY_CALL keccak256()(receiveApproval(address,uint256,address,bytes)),TMP_46 = CONVERT TMP_45 to bytes32,TMP_47 = CONVERT TMP_46 to bytes4,TMP_48(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_47', 'msg.sender', '_value', 'this', '_extraData']  ,TMP_49 = UnaryType.BANG TMP_48 ,CONDITION TMP_49,TMP_50(None) = SOLIDITY_CALL revert()(),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_39(mapping(address => uint256)) -> allowed[msg.sender]
REF_40(uint256) -> REF_39[_spender]
REF_40(uint256) (->allowed) := _value(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
! _spender.call(bytes4(bytes32(keccak256()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData)

IRs:
TMP_45(bytes32) = SOLIDITY_CALL keccak256()(receiveApproval(address,uint256,address,bytes))
TMP_46 = CONVERT TMP_45 to bytes32
TMP_47 = CONVERT TMP_46 to bytes4
TMP_48(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_47', 'msg.sender', '_value', 'this', '_extraData']  
TMP_49 = UnaryType.BANG TMP_48 
CONDITION TMP_49""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
revert()()

IRs:
TMP_50(None) = SOLIDITY_CALL revert()()""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][_spender] = _value;Approval(msg.sender,_spender,_value);! _spender.call(bytes4(bytes32(keccak256()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData);revert()();;true;success"
./0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb_ext.sol,OrganizeFunds.getTotalPctx10,130,135,"_totalPctx10(uint256) := 0(uint256),i(uint256) := 0(uint256),TMP_15(bool) = i < activityCount,CONDITION TMP_15,REF_21(OrganizeFunds.ActivityAccount) -> activityAccounts[i],REF_22(uint256) -> REF_21.pctx10,_totalPctx10(uint256) = _totalPctx10 + REF_22,TMP_16(uint256) := i(uint256),i(uint256) = i + 1,RETURN _totalPctx10","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_totalPctx10 = 0

IRs:
_totalPctx10(uint256) := 0(uint256)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
3->8;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < activityCount

IRs:
TMP_15(bool) = i < activityCount
CONDITION TMP_15""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
_totalPctx10 += activityAccounts[i].pctx10

IRs:
REF_21(OrganizeFunds.ActivityAccount) -> activityAccounts[i]
REF_22(uint256) -> REF_21.pctx10
_totalPctx10(uint256) = _totalPctx10 + REF_22""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_16(uint256) := i(uint256)
i(uint256) = i + 1""];
7->5;
8[label=""Node Type: RETURN 8

EXPRESSION:
_totalPctx10

IRs:
RETURN _totalPctx10""];
}
",0,1,0,0,_totalPctx10 = 0;i = 0;;i < activityCount;;_totalPctx10;_totalPctx10 += activityAccounts[i].pctx10;i ++
./0x35e44051799bd7cea091c4fad2cba9b37e364c5b_ext.sol,myPreICO.myICO,28,31,"owner(address) := msg.sender(address),TMP_2(uint256) = now + 7776000,end_date(uint256) := TMP_2(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
end_date = now + 7776000

IRs:
TMP_2(uint256) = now + 7776000
end_date(uint256) := TMP_2(uint256)""];
}
",0,1,0,0,owner = msg.sender;end_date = now + 7776000
./0x4b353a668f90025337e7f1fcd4202c41f50a22df_ext.sol,LEToken.approveAndCall,243,251,"TMP_66 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_66(tokenRecipient),TMP_67(bool) = INTERNAL_CALL, StandardToken.approve(address,uint256)(_spender,_value),CONDITION TMP_67,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_66 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_66(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_67(bool) = INTERNAL_CALL, StandardToken.approve(address,uint256)(_spender,_value)
CONDITION TMP_67""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0xec0dc71b3e5fc3f8ddfc655e800ae6d9b55f993f_ext.sol,StandardToken.transferFrom,56,66,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0xef828938155cabfe83affbe726b55d188b4f45c0_ext.sol,APPToken.tokenRate,97,101,"TMP_50(bool) = block.number >= fundingStartBlock,TMP_51(uint256) = fundingStartBlock + 23333,TMP_52(bool) = block.number < TMP_51,TMP_53(bool) = TMP_50 && TMP_52,CONDITION TMP_53,RETURN 360,TMP_54(bool) = block.number >= fundingStartBlock,TMP_55(uint256) = fundingStartBlock + 23333,TMP_56(bool) = block.number < TMP_55,TMP_57(bool) = TMP_54 && TMP_56,CONDITION TMP_57,RETURN 300,RETURN 250","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
block.number >= fundingStartBlock && block.number < fundingStartBlock + 23333

IRs:
TMP_50(bool) = block.number >= fundingStartBlock
TMP_51(uint256) = fundingStartBlock + 23333
TMP_52(bool) = block.number < TMP_51
TMP_53(bool) = TMP_50 && TMP_52
CONDITION TMP_53""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
360

IRs:
RETURN 360""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
block.number >= fundingStartBlock && block.number < fundingStartBlock + 23333

IRs:
TMP_54(bool) = block.number >= fundingStartBlock
TMP_55(uint256) = fundingStartBlock + 23333
TMP_56(bool) = block.number < TMP_55
TMP_57(bool) = TMP_54 && TMP_56
CONDITION TMP_57""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: RETURN 5

EXPRESSION:
300

IRs:
RETURN 300""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
250

IRs:
RETURN 250""];
}
",0,1,0,0,block.number >= fundingStartBlock && block.number < fundingStartBlock + 23333;360;;block.number >= fundingStartBlock && block.number < fundingStartBlock + 23333;300;;250
./0x2e0b77cd408989a8f09e22d2c832be793f167aae_ext.sol,FrameworkInvest.calculateAndSetRate,782,785,"TMP_335(uint256) = DEFAULT_RATE + _bonus,calcRate(uint256) := TMP_335(uint256),INTERNAL_CALL, FrameworkInvest.setCurrentRate(uint256)(calcRate)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
calcRate = DEFAULT_RATE + _bonus

IRs:
TMP_335(uint256) = DEFAULT_RATE + _bonus
calcRate(uint256) := TMP_335(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
setCurrentRate(calcRate)

IRs:
INTERNAL_CALL, FrameworkInvest.setCurrentRate(uint256)(calcRate)""];
}
",0,1,0,0,calcRate = DEFAULT_RATE + _bonus;setCurrentRate(calcRate)
./0xd5dc75c85159e95f0bd8b5196f4f096a6b7fea1f_ext.sol,BMICoin.mint,272,277,"TMP_93(uint256) = totalSupply_ + tokens,TMP_94(bool) = TMP_93 <= maxSupply,TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94),REF_94(uint256) -> balances[receiver],REF_94(-> balances) = REF_94 + tokens,totalSupply_(uint256) = totalSupply_ + tokens,TMP_96 = CONVERT 0 to address,Emit Transfer(TMP_96,receiver,tokens),MODIFIER_CALL, BMICoin.onlyBackend()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(totalSupply_ + tokens <= maxSupply)

IRs:
TMP_93(uint256) = totalSupply_ + tokens
TMP_94(bool) = TMP_93 <= maxSupply
TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[receiver] += tokens

IRs:
REF_94(uint256) -> balances[receiver]
REF_94(-> balances) = REF_94 + tokens""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply_ += tokens

IRs:
totalSupply_(uint256) = totalSupply_ + tokens""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(address(0x0),receiver,tokens)

IRs:
TMP_96 = CONVERT 0 to address
Emit Transfer(TMP_96,receiver,tokens)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyBackend()

IRs:
MODIFIER_CALL, BMICoin.onlyBackend()()""];
5->1;
}
",0,1,0,0,"onlyBackend();require(bool)(totalSupply_ + tokens <= maxSupply);balances[receiver] += tokens;totalSupply_ += tokens;Transfer(address(0x0),receiver,tokens)"
./0x4bd70556ae3f8a6ec6c4080a0c327b24325438f3_ext.sol,HxroTokenContract.burn,133,139,"REF_17(uint256) -> balanceOf[msg.sender],TMP_30(bool) = REF_17 >= _value,TMP_31(None) = SOLIDITY_CALL require(bool,string)(TMP_30,Balance Insufficient),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(balanceOf[msg.sender] >= _value,Balance Insufficient)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_30(bool) = REF_17 >= _value
TMP_31(None) = SOLIDITY_CALL require(bool,string)(TMP_30,Balance Insufficient)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool,string)(balanceOf[msg.sender] >= _value,Balance Insufficient);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x17c94b2203cd76d1e28509cece13e35744b9555c_ext.sol,ERC20MIST.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xb41b531359330d76bbcb0f1a24f94ff6bff30dc1_ext.sol,CNet5G.mint,59,67,"TMP_17(bool) = amount > 0,CONDITION TMP_17,totalSupply(uint256) = totalSupply + amount,REF_16(uint256) -> balances[owner],REF_16(-> balances) = REF_16 + amount,Emit Mint(msg.sender,amount),RETURN True,RETURN False,MODIFIER_CALL, CNet5G.onlyOwner()(),RETURN minted","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: IF 1

EXPRESSION:
amount > 0

IRs:
TMP_17(bool) = amount > 0
CONDITION TMP_17""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += amount

IRs:
totalSupply(uint256) = totalSupply + amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[owner] += amount

IRs:
REF_16(uint256) -> balances[owner]
REF_16(-> balances) = REF_16 + amount""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Mint(msg.sender,amount)

IRs:
Emit Mint(msg.sender,amount)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, CNet5G.onlyOwner()()""];
8->1;
9[label=""Node Type: RETURN 9

EXPRESSION:
minted

IRs:
RETURN minted""];
}
",0,1,0,0,"onlyOwner();amount > 0;totalSupply += amount;;balances[owner] += amount;Mint(msg.sender,amount);true;false;minted"
./0xbc7981956a44b5c5de21ad30aec8099c3ca27dba_ext.sol,HodlETH.personalPercent,72,90,"REF_0(uint256) -> entryTime[msg.sender],TMP_10(uint256) = block.number - REF_0,hodl(uint256) := TMP_10(uint256),TMP_11(bool) = hodl < 30500,CONDITION TMP_11,RETURN startPercent,TMP_12(bool) = hodl > 30500,TMP_13(bool) = hodl < 61000,TMP_14(bool) = TMP_12 && TMP_13,CONDITION TMP_14,RETURN fiveDayHodlPercent,TMP_15(bool) = hodl > 61000,TMP_16(bool) = hodl < 122000,TMP_17(bool) = TMP_15 && TMP_16,CONDITION TMP_17,RETURN tenDayHodlPercent,TMP_18(bool) = hodl > 122000,CONDITION TMP_18,RETURN twentyDayHodlPercent","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
hodl = block.number - entryTime[msg.sender]

IRs:
REF_0(uint256) -> entryTime[msg.sender]
TMP_10(uint256) = block.number - REF_0
hodl(uint256) := TMP_10(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
hodl < 30500

IRs:
TMP_11(bool) = hodl < 30500
CONDITION TMP_11""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3

EXPRESSION:
(startPercent)

IRs:
RETURN startPercent""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
hodl > 30500 && hodl < 61000

IRs:
TMP_12(bool) = hodl > 30500
TMP_13(bool) = hodl < 61000
TMP_14(bool) = TMP_12 && TMP_13
CONDITION TMP_14""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: RETURN 6

EXPRESSION:
(fiveDayHodlPercent)

IRs:
RETURN fiveDayHodlPercent""];
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
hodl > 61000 && hodl < 122000

IRs:
TMP_15(bool) = hodl > 61000
TMP_16(bool) = hodl < 122000
TMP_17(bool) = TMP_15 && TMP_16
CONDITION TMP_17""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
(tenDayHodlPercent)

IRs:
RETURN tenDayHodlPercent""];
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
hodl > 122000

IRs:
TMP_18(bool) = hodl > 122000
CONDITION TMP_18""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: RETURN 12

EXPRESSION:
(twentyDayHodlPercent)

IRs:
RETURN twentyDayHodlPercent""];
13[label=""Node Type: END_IF 13
""];
}
",0,1,0,0,hodl = block.number - entryTime[msg.sender];hodl < 30500;(startPercent);;hodl > 30500 && hodl < 61000;(fiveDayHodlPercent);;hodl > 61000 && hodl < 122000;(tenDayHodlPercent);;hodl > 122000;(twentyDayHodlPercent);
./0xcf7097406448a6b3b109139e52e20ee909e437d2_ext.sol,Ferrarium.burnFrom,160,168,"REF_19(uint256) -> balanceOf[_from],TMP_35(bool) = REF_19 >= _value,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_37(bool) = _value <= REF_21,TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_35(bool) = REF_19 >= _value
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_37(bool) = _value <= REF_21
TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x5bd7b9cd17cee4d2fae01d9695e83098cf409488_ext.sol,Queue.getQueueLength,220,222,"REF_25 -> LENGTH queue,TMP_45(uint256) = REF_25 - currentReceiverIndex,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
queue.length - currentReceiverIndex

IRs:
REF_25 -> LENGTH queue
TMP_45(uint256) = REF_25 - currentReceiverIndex
RETURN TMP_45""];
}
",0,1,0,0,queue.length - currentReceiverIndex
./0x4be10da47a07716af28ad199fbe020501bddd7af_ext.sol,XTToken.burn,122,128,"REF_17(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_17 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_17 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x72ba699f0f3c29d0f886c264ec7350533a32b3d5_ext.sol,FixedSupplyToken.approveAndCall,117,122,"REF_25(mapping(address => uint256)) -> allowed[msg.sender],REF_26(uint256) -> REF_25[spender],REF_26(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_43 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_43(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_25(mapping(address => uint256)) -> allowed[msg.sender]
REF_26(uint256) -> REF_25[spender]
REF_26(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_43 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_43(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x0ef4bd1e9baa163d410b31d47bd4e9ebe7dfda1c_ext.sol,EdxToken.getBSBalance,651,668,"TMP_249(uint256) = now - _releaseTime,elasped(uint256) := TMP_249(uint256),REF_243(EdxToken.VestInfo) -> _bs_balance[account],REF_244(uint256) -> REF_243.remain,shouldRemain(uint256) := REF_244(uint256),TMP_250(bool) = _releaseTime != 0,TMP_251(bool) = now > _releaseTime,TMP_252(bool) = TMP_250 && TMP_251,REF_245(EdxToken.VestInfo) -> _bs_balance[account],REF_246(uint256) -> REF_245.remain,TMP_253(bool) = REF_246 > 0,TMP_254(bool) = TMP_252 && TMP_253,CONDITION TMP_254,TMP_255(bool) = elasped < 15552000,CONDITION TMP_255,REF_247(EdxToken.VestInfo) -> _bs_balance[account],REF_248(uint256) -> REF_247.vested,TMP_256(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_248', '9'] ,TMP_257(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_256', '10'] ,shouldRemain(uint256) := TMP_257(uint256),TMP_258(bool) = elasped < 36288000,CONDITION TMP_258,REF_251(EdxToken.VestInfo) -> _bs_balance[account],REF_252(uint256) -> REF_251.vested,TMP_259(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_252', '6'] ,TMP_260(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_259', '10'] ,shouldRemain(uint256) := TMP_260(uint256),TMP_261(bool) = elasped < 62208000,CONDITION TMP_261,REF_255(EdxToken.VestInfo) -> _bs_balance[account],REF_256(uint256) -> REF_255.vested,TMP_262(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_256', '3'] ,TMP_263(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_262', '10'] ,shouldRemain(uint256) := TMP_263(uint256),shouldRemain(uint256) := 0(uint256),RETURN shouldRemain","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
elasped = now - _releaseTime

IRs:
TMP_249(uint256) = now - _releaseTime
elasped(uint256) := TMP_249(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
shouldRemain = _bs_balance[account].remain

IRs:
REF_243(EdxToken.VestInfo) -> _bs_balance[account]
REF_244(uint256) -> REF_243.remain
shouldRemain(uint256) := REF_244(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_releaseTime != 0 && now > _releaseTime && _bs_balance[account].remain > 0

IRs:
TMP_250(bool) = _releaseTime != 0
TMP_251(bool) = now > _releaseTime
TMP_252(bool) = TMP_250 && TMP_251
REF_245(EdxToken.VestInfo) -> _bs_balance[account]
REF_246(uint256) -> REF_245.remain
TMP_253(bool) = REF_246 > 0
TMP_254(bool) = TMP_252 && TMP_253
CONDITION TMP_254""];
3->4[label=""True""];
3->14[label=""False""];
4[label=""Node Type: IF 4

EXPRESSION:
elasped < 15552000

IRs:
TMP_255(bool) = elasped < 15552000
CONDITION TMP_255""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
shouldRemain = _bs_balance[account].vested.mul(9).div(10)

IRs:
REF_247(EdxToken.VestInfo) -> _bs_balance[account]
REF_248(uint256) -> REF_247.vested
TMP_256(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_248', '9'] 
TMP_257(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_256', '10'] 
shouldRemain(uint256) := TMP_257(uint256)""];
5->13;
6[label=""Node Type: IF 6

EXPRESSION:
elasped < 36288000

IRs:
TMP_258(bool) = elasped < 36288000
CONDITION TMP_258""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
shouldRemain = _bs_balance[account].vested.mul(6).div(10)

IRs:
REF_251(EdxToken.VestInfo) -> _bs_balance[account]
REF_252(uint256) -> REF_251.vested
TMP_259(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_252', '6'] 
TMP_260(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_259', '10'] 
shouldRemain(uint256) := TMP_260(uint256)""];
7->12;
8[label=""Node Type: IF 8

EXPRESSION:
elasped < 62208000

IRs:
TMP_261(bool) = elasped < 62208000
CONDITION TMP_261""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
shouldRemain = _bs_balance[account].vested.mul(3).div(10)

IRs:
REF_255(EdxToken.VestInfo) -> _bs_balance[account]
REF_256(uint256) -> REF_255.vested
TMP_262(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_256', '3'] 
TMP_263(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_262', '10'] 
shouldRemain(uint256) := TMP_263(uint256)""];
9->11;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
shouldRemain = 0

IRs:
shouldRemain(uint256) := 0(uint256)""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: RETURN 15

EXPRESSION:
shouldRemain

IRs:
RETURN shouldRemain""];
}
",0,1,0,0,elasped = now - _releaseTime;shouldRemain = _bs_balance[account].remain;_releaseTime != 0 && now > _releaseTime && _bs_balance[account].remain > 0;elasped < 15552000;;shouldRemain = _bs_balance[account].vested.mul(9).div(10);elasped < 36288000;;shouldRemain = _bs_balance[account].vested.mul(6).div(10);elasped < 62208000;;shouldRemain = _bs_balance[account].vested.mul(3).div(10);shouldRemain = 0;;shouldRemain
./0x40f5d52331674b60bc532f553c97feac5d60ab34_ext.sol,CryptoMinerTokenPlat.dividendsOf,179,181,"REF_35(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_61(uint256) = profitPerShare_ * REF_35,TMP_62 = CONVERT TMP_61 to int256,REF_36(int256) -> payoutsTo_[_customerAddress],TMP_63(int256) = TMP_62 - REF_36,TMP_64 = CONVERT TMP_63 to uint256,TMP_65(uint256) = TMP_64 / magnitude,RETURN TMP_65","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_35(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_61(uint256) = profitPerShare_ * REF_35
TMP_62 = CONVERT TMP_61 to int256
REF_36(int256) -> payoutsTo_[_customerAddress]
TMP_63(int256) = TMP_62 - REF_36
TMP_64 = CONVERT TMP_63 to uint256
TMP_65(uint256) = TMP_64 / magnitude
RETURN TMP_65""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x6f793d30138161e6a5ae98c851882b7dc194d501_ext.sol,EUROSIBENERGO_PFXXI_I_883.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x1ba0383fd6b699f35c804a4179536a7c4473780e_ext.sol,VEKSELBERG_Portfolio_I_883.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x01d174f95cd17d0b5b24f1f89a35cfdb37929b30_ext.sol,X_wallet.withdraw,13,21,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2),TMP_4(bool) = keyHash == TMP_3,CONDITION TMP_4,TMP_5(bool) = msg.value > 400000000000000000,CONDITION TMP_5,TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),Transfer dest:msg.sender value:TMP_7","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
keyHash == keccak256()(abi.encodePacked(key))

IRs:
TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2)
TMP_4(bool) = keyHash == TMP_3
CONDITION TMP_4""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
msg.value > 400000000000000000

IRs:
TMP_5(bool) = msg.value > 400000000000000000
CONDITION TMP_5""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
Transfer dest:msg.sender value:TMP_7""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,1,0,0,require(bool)(msg.sender == tx.origin);keyHash == keccak256()(abi.encodePacked(key));msg.value > 400000000000000000;;msg.sender.transfer(address(this).balance);
./0xe35ff61bbec1c56f5aa304de7bf173d29970d0ac_ext.sol,lindyhanCoin.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x18035ee31125a9934de44b0105cd31691cce95d5_ext.sol,BigBoobsToken.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xf3dac8e171a13066f8964f74a7c87fd518e4e162_ext.sol,safe.withdraw,13,21,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2),TMP_4(bool) = keyHash == TMP_3,CONDITION TMP_4,TMP_5(bool) = msg.value > 400000000000000000,CONDITION TMP_5,TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),Transfer dest:msg.sender value:TMP_7","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
keyHash == keccak256()(abi.encodePacked(key))

IRs:
TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2)
TMP_4(bool) = keyHash == TMP_3
CONDITION TMP_4""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
msg.value > 400000000000000000

IRs:
TMP_5(bool) = msg.value > 400000000000000000
CONDITION TMP_5""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
Transfer dest:msg.sender value:TMP_7""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,1,0,0,require(bool)(msg.sender == tx.origin);keyHash == keccak256()(abi.encodePacked(key));msg.value > 400000000000000000;;msg.sender.transfer(address(this).balance);
./0x69b3d13bb1d2542c85f0dfc6cba4c0ba8d919ec6_ext.sol,JYBToken.burnFrom,71,79,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xc5b106f17246b2f5c0c658dbd6e8d168695806ab_ext.sol,SIEToken.burn,111,116,"REF_19(uint256) -> balanceOf[msg.sender],TMP_45(bool) = REF_19 >= _value,TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45),REF_20(uint256) -> balanceOf[msg.sender],REF_20(-> balanceOf) = REF_20 - _value,REF_21(uint256) -> balanceOf[0],REF_21(-> balanceOf) = REF_21 + _value,Emit Transfer(msg.sender,0,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_19(uint256) -> balanceOf[msg.sender]
TMP_45(bool) = REF_19 >= _value
TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_20(uint256) -> balanceOf[msg.sender]
REF_20(-> balanceOf) = REF_20 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[0x0] += _value

IRs:
REF_21(uint256) -> balanceOf[0]
REF_21(-> balanceOf) = REF_21 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,0x0,_value)

IRs:
Emit Transfer(msg.sender,0,_value)""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;balanceOf[0x0] += _value;Transfer(msg.sender,0x0,_value)"
./0xf3eb09a1fd5a3e133a669074de1231d7a673744b_ext.sol,ExoTownToken.burnTokens,212,217,"TMP_116(bool) = _value > 0,TMP_117(None) = SOLIDITY_CALL require(bool)(TMP_116),REF_58(uint256) -> balances[_from],REF_59(uint256) -> balances[_from],TMP_118(uint256) = INTERNAL_CALL, SafeMath.sub(uint256,uint256)(REF_59,_value),REF_58(uint256) (->balances) := TMP_118(uint256),totalSupply(uint256) = totalSupply - _value,MODIFIER_CALL, ExoTownToken.onlyIcoContract()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_116(bool) = _value > 0
TMP_117(None) = SOLIDITY_CALL require(bool)(TMP_116)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_from] = sub(balances[_from],_value)

IRs:
REF_58(uint256) -> balances[_from]
REF_59(uint256) -> balances[_from]
TMP_118(uint256) = INTERNAL_CALL, SafeMath.sub(uint256,uint256)(REF_59,_value)
REF_58(uint256) (->balances) := TMP_118(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyIcoContract()

IRs:
MODIFIER_CALL, ExoTownToken.onlyIcoContract()()""];
4->1;
}
",0,1,0,0,"onlyIcoContract();require(bool)(_value > 0);balances[_from] = sub(balances[_from],_value);totalSupply -= _value"
./0x64d5e7be2e92d4436ba9c4a630491cb268764103_ext.sol,funds.withdraw,13,21,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2),TMP_4(bool) = keyHash == TMP_3,CONDITION TMP_4,TMP_5(bool) = msg.value > 400000000000000000,CONDITION TMP_5,TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),Transfer dest:msg.sender value:TMP_7","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
keyHash == keccak256()(abi.encodePacked(key))

IRs:
TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2)
TMP_4(bool) = keyHash == TMP_3
CONDITION TMP_4""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
msg.value > 400000000000000000

IRs:
TMP_5(bool) = msg.value > 400000000000000000
CONDITION TMP_5""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
Transfer dest:msg.sender value:TMP_7""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,1,0,0,require(bool)(msg.sender == tx.origin);keyHash == keccak256()(abi.encodePacked(key));msg.value > 400000000000000000;;msg.sender.transfer(address(this).balance);
./0x2cbf103901196f99619f2bf9accdf079e9c76819_ext.sol,MyAdvancedToken.mintToken,131,136,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0xa1a6cea5c52461028c8d436428ceddb6ce8e7ddc_ext.sol,Metayen.dividendsOf,387,393,"REF_29(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_58(uint256) = profitPerShare_ * REF_29,TMP_59 = CONVERT TMP_58 to int256,REF_30(int256) -> payoutsTo_[_customerAddress],TMP_60(int256) = TMP_59 - REF_30,TMP_61 = CONVERT TMP_60 to uint256,TMP_62(uint256) = TMP_61 / magnitude,RETURN TMP_62","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_29(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_58(uint256) = profitPerShare_ * REF_29
TMP_59 = CONVERT TMP_58 to int256
REF_30(int256) -> payoutsTo_[_customerAddress]
TMP_60(int256) = TMP_59 - REF_30
TMP_61 = CONVERT TMP_60 to uint256
TMP_62(uint256) = TMP_61 / magnitude
RETURN TMP_62""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x716989fa21d5043165079ddbfd04a76a001a595a_ext.sol,COCTokenBase.burn,169,175,"REF_20(uint256) -> balances[msg.sender],TMP_23(bool) = REF_20 >= _value,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),REF_21(uint256) -> balances[msg.sender],REF_21(-> balances) = REF_21 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_20(uint256) -> balances[msg.sender]
TMP_23(bool) = REF_20 >= _value
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_21(uint256) -> balances[msg.sender]
REF_21(-> balances) = REF_21 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);balances[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true"
./0x874d4a7a8bf2abda5489cdbd62bd785c23e5531f_ext.sol,token123.mintToken,50,55,"REF_1(uint256) -> balances[target],REF_1(-> balances) = REF_1 + mintedAmount,_totalSupply(uint256) = _totalSupply + mintedAmount,Emit Transfer(0,owner,mintedAmount),Emit Transfer(owner,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances[target] += mintedAmount

IRs:
REF_1(uint256) -> balances[target]
REF_1(-> balances) = REF_1 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_totalSupply += mintedAmount

IRs:
_totalSupply(uint256) = _totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0x0,owner,mintedAmount)

IRs:
Emit Transfer(0,owner,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(owner,target,mintedAmount)

IRs:
Emit Transfer(owner,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balances[target] += mintedAmount;_totalSupply += mintedAmount;Transfer(0x0,owner,mintedAmount);Transfer(owner,target,mintedAmount)"
./0x5cc0076a6bbf43344a7923c5cca40f5bdff2970e_ext.sol,LiteToken.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x39cfd754c85023648bf003bea2dd498c5612abfa_ext.sol,TokenBank.Deposit,60,67,"TMP_17(bool) = msg.value > MinDeposit,CONDITION TMP_17,REF_2(uint256) -> Holders[msg.sender],REF_2(-> Holders) = REF_2 + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value > MinDeposit

IRs:
TMP_17(bool) = msg.value > MinDeposit
CONDITION TMP_17""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Holders[msg.sender] += msg.value

IRs:
REF_2(uint256) -> Holders[msg.sender]
REF_2(-> Holders) = REF_2 + msg.value""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,1,0,0,msg.value > MinDeposit;Holders[msg.sender] += msg.value;
./0xda5441a5807e5cda5871b6504644e13d677706b1_ext.sol,TokenERC20.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x6bcfcc7035dbe589e9c0c91260772630ce92f25b_ext.sol,TOMAToken.burn,94,100,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x1c3bb10de15c31d5dbe48fbb7b87735d1b7d8c32_ext.sol,BLONDCOIN.approveAndCall,200,205,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xf27a6b9f1434de2a406ee0a9f94b4d5e89fb2681_ext.sol,TOP._transfer,49,65,"TMP_3 = CONVERT 0 to address,TMP_4(bool) = _to != TMP_3,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_1(uint256) -> balanceOf[_from],TMP_6(bool) = REF_1 >= _value,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_2(uint256) -> balanceOf[_to],TMP_8(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_9(bool) = TMP_8 >= REF_3,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_11(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_11(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_13(uint256) = REF_8 + REF_9,TMP_14(bool) = TMP_13 == previousBalances,TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0x0))

IRs:
TMP_3 = CONVERT 0 to address
TMP_4(bool) = _to != TMP_3
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_6(bool) = REF_1 >= _value
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_8(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_9(bool) = TMP_8 >= REF_3
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_11(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_11(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_13(uint256) = REF_8 + REF_9
TMP_14(bool) = TMP_13 == previousBalances
TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)""];
}
",0,1,0,0,"require(bool)(_to != address(0x0));require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x549b38e8e5fb1ba4acd4187d8b7c8a04deb53206_ext.sol,LotteryAdmin.allowsAllowance,45,47,"TMP_1(uint256) = now - lastAllowancePaymentTimestamp,TMP_2(bool) = TMP_1 >= 86400,RETURN TMP_2","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
now - lastAllowancePaymentTimestamp >= 86400

IRs:
TMP_1(uint256) = now - lastAllowancePaymentTimestamp
TMP_2(bool) = TMP_1 >= 86400
RETURN TMP_2""];
}
",0,1,0,0,now - lastAllowancePaymentTimestamp >= 86400
./0x1d38b2f0329568ad8730b1970905e4978c16b7ff_ext.sol,BurnToken.burn,48,54,"REF_30(uint256) -> balanceOf[msg.sender],TMP_34(bool) = REF_30 >= _value,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),REF_31(uint256) -> balanceOf[msg.sender],REF_31(-> balanceOf) = REF_31 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_30(uint256) -> balanceOf[msg.sender]
TMP_34(bool) = REF_30 >= _value
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_31(uint256) -> balanceOf[msg.sender]
REF_31(-> balanceOf) = REF_31 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xc6720198a6f7ee5711e3491b14a5fc821174295c_ext.sol,OPTToken._transfer,39,55,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x279fd66b7621468ca14f60eaa205dae94c484dbf_ext.sol,OfflineSecret.checkSecret,46,52,"TMP_1(bytes32) = SOLIDITY_CALL keccak256()(to,secret),TMP_2(bool) = hashed == TMP_1,CONDITION TMP_2,RETURN True,RETURN False,RETURN valid","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
hashed == keccak256()(to,secret)

IRs:
TMP_1(bytes32) = SOLIDITY_CALL keccak256()(to,secret)
TMP_2(bool) = hashed == TMP_1
CONDITION TMP_2""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
true

IRs:
RETURN True""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
false

IRs:
RETURN False""];
5[label=""Node Type: RETURN 5

EXPRESSION:
valid

IRs:
RETURN valid""];
}
",0,1,0,0,"hashed == keccak256()(to,secret);true;;false;valid"
./0xf12bc22c88c4c770b1e116853cc0500bb70a81ca_ext.sol,GLADLIVEToken._transfer,47,63,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x4efd3bf84f40eda370e52df162eccc394cfc8834_ext.sol,Zhoan.burnAccountMoeny,62,69,"opt_add(address) := msg.sender(address),TMP_6(bool) = opt_add == admin_add,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_5(uint256) -> balanceOf[add],TMP_8(bool) = REF_5 > value,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_6(uint256) -> balanceOf[add],REF_6(-> balanceOf) = REF_6 - value,totalSupply(uint256) = totalSupply - value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
opt_add = msg.sender

IRs:
opt_add(address) := msg.sender(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(opt_add == admin_add)

IRs:
TMP_6(bool) = opt_add == admin_add
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[add] > value)

IRs:
REF_5(uint256) -> balanceOf[add]
TMP_8(bool) = REF_5 > value
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[add] -= value

IRs:
REF_6(uint256) -> balanceOf[add]
REF_6(-> balanceOf) = REF_6 - value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= value

IRs:
totalSupply(uint256) = totalSupply - value""];
}
",0,1,0,0,opt_add = msg.sender;require(bool)(opt_add == admin_add);require(bool)(balanceOf[add] > value);balanceOf[add] -= value;totalSupply -= value
./0x1bb28e79f2482df6bf60efc7a33365703bcf1536_ext.sol,hodlEthereum.fallback,7,10,"REF_0(uint256) -> hodlers[msg.sender],REF_0(-> hodlers) = REF_0 + msg.value,Emit Hodl(msg.sender,msg.value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
hodlers[msg.sender] += msg.value

IRs:
REF_0(uint256) -> hodlers[msg.sender]
REF_0(-> hodlers) = REF_0 + msg.value""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Hodl(msg.sender,msg.value)

IRs:
Emit Hodl(msg.sender,msg.value)""];
}
",0,1,0,0,"hodlers[msg.sender] += msg.value;Hodl(msg.sender,msg.value)"
./0x284ff8b2acda5bbf3e7aa72dad0894ea716b5ffd_ext.sol,TokenERC20.burnFrom,178,186,"REF_20(uint256) -> balanceOf[_from],TMP_37(bool) = REF_20 >= _value,TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37),REF_21(mapping(address => uint256)) -> allowance[_from],REF_22(uint256) -> REF_21[msg.sender],TMP_39(bool) = _value <= REF_22,TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39),REF_23(uint256) -> balanceOf[_from],REF_23(-> balanceOf) = REF_23 - _value,REF_24(mapping(address => uint256)) -> allowance[_from],REF_25(uint256) -> REF_24[msg.sender],REF_25(-> allowance) = REF_25 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,MODIFIER_CALL, TokenERC20.isRunning()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_20(uint256) -> balanceOf[_from]
TMP_37(bool) = REF_20 >= _value
TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_21(mapping(address => uint256)) -> allowance[_from]
REF_22(uint256) -> REF_21[msg.sender]
TMP_39(bool) = _value <= REF_22
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_23(uint256) -> balanceOf[_from]
REF_23(-> balanceOf) = REF_23 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_24(mapping(address => uint256)) -> allowance[_from]
REF_25(uint256) -> REF_24[msg.sender]
REF_25(-> allowance) = REF_25 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
isRunning()

IRs:
MODIFIER_CALL, TokenERC20.isRunning()()""];
8->1;
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"isRunning();require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xbcef236c69228f004da2fa693c3347946798e0c3_ext.sol,TokenERC20.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x4d66945d0b739574634b59190af51b4fe27858cc_ext.sol,MyToken.approveAndCall,108,115,"TMP_23 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_23(tokenRecipient),TMP_24(bool) = INTERNAL_CALL, MyToken.approve(address,uint256)(_spender,_value),CONDITION TMP_24,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_23 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_23(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_24(bool) = INTERNAL_CALL, MyToken.approve(address,uint256)(_spender,_value)
CONDITION TMP_24""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x6fc9c554c2363805673f18b3a2b1912cce8bfb8a_ext.sol,RocketCoin.fallback,44,50,"REF_1(uint256) -> balances[owner],TMP_2(bool) = REF_1 >= airDropAmount,TMP_3(bool) = airDropStatus && TMP_2,REF_2(bool) -> participants[msg.sender],TMP_4 = UnaryType.BANG REF_2 ,TMP_5(bool) = TMP_3 && TMP_4,TMP_6(bool) = tx.gasprice >= airDropGasPrice,TMP_7(bool) = TMP_5 && TMP_6,TMP_8(None) = SOLIDITY_CALL require(bool)(TMP_7),REF_3(uint256) -> balances[owner],REF_3(-> balances) = REF_3 - airDropAmount,REF_4(uint256) -> balances[msg.sender],REF_4(-> balances) = REF_4 + airDropAmount,Emit Transfer(owner,msg.sender,airDropAmount),REF_5(bool) -> participants[msg.sender],REF_5(bool) (->participants) := True(bool)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(airDropStatus && balances[owner] >= airDropAmount && ! participants[msg.sender] && tx.gasprice >= airDropGasPrice)

IRs:
REF_1(uint256) -> balances[owner]
TMP_2(bool) = REF_1 >= airDropAmount
TMP_3(bool) = airDropStatus && TMP_2
REF_2(bool) -> participants[msg.sender]
TMP_4 = UnaryType.BANG REF_2 
TMP_5(bool) = TMP_3 && TMP_4
TMP_6(bool) = tx.gasprice >= airDropGasPrice
TMP_7(bool) = TMP_5 && TMP_6
TMP_8(None) = SOLIDITY_CALL require(bool)(TMP_7)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[owner] -= airDropAmount

IRs:
REF_3(uint256) -> balances[owner]
REF_3(-> balances) = REF_3 - airDropAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] += airDropAmount

IRs:
REF_4(uint256) -> balances[msg.sender]
REF_4(-> balances) = REF_4 + airDropAmount""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(owner,msg.sender,airDropAmount)

IRs:
Emit Transfer(owner,msg.sender,airDropAmount)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
participants[msg.sender] = true

IRs:
REF_5(bool) -> participants[msg.sender]
REF_5(bool) (->participants) := True(bool)""];
}
",0,1,0,0,"require(bool)(airDropStatus && balances[owner] >= airDropAmount && ! participants[msg.sender] && tx.gasprice >= airDropGasPrice);balances[owner] -= airDropAmount;balances[msg.sender] += airDropAmount;Transfer(owner,msg.sender,airDropAmount);participants[msg.sender] = true"
./0x26d5b54ba01d5d5a18a99c3fc126c5eb356c1076_ext.sol,VOCC_I092_20181211.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x4570a3a0c7b99f7ffbc522bfa4f792140c2c8c9c_ext.sol,onlinewallet.withdraw,13,21,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2),TMP_4(bool) = keyHash == TMP_3,CONDITION TMP_4,TMP_5(bool) = msg.value > 400000000000000000,CONDITION TMP_5,TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),Transfer dest:msg.sender value:TMP_7","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
keyHash == keccak256()(abi.encodePacked(key))

IRs:
TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2)
TMP_4(bool) = keyHash == TMP_3
CONDITION TMP_4""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
msg.value > 400000000000000000

IRs:
TMP_5(bool) = msg.value > 400000000000000000
CONDITION TMP_5""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
Transfer dest:msg.sender value:TMP_7""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,1,0,0,require(bool)(msg.sender == tx.origin);keyHash == keccak256()(abi.encodePacked(key));msg.value > 400000000000000000;;msg.sender.transfer(address(this).balance);
./0x313df3fac623a824c8e64b4c47cf62fe0b75809e_ext.sol,Whitelist.removeWallet,505,510,"TMP_217 = CONVERT 0 to address,TMP_218(bool) = _wallet != TMP_217,TMP_219(None) = SOLIDITY_CALL require(bool)(TMP_218),TMP_220(bool) = INTERNAL_CALL, Whitelist.isWhitelisted(address)(_wallet),TMP_221(None) = SOLIDITY_CALL require(bool)(TMP_220),REF_147(bool) -> whitelist[_wallet],REF_147(bool) (->whitelist) := False(bool),TMP_222(uint256) := whitelistLength(uint256),whitelistLength(uint256) = whitelistLength - 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_217 = CONVERT 0 to address
TMP_218(bool) = _wallet != TMP_217
TMP_219(None) = SOLIDITY_CALL require(bool)(TMP_218)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(isWhitelisted(_wallet))

IRs:
TMP_220(bool) = INTERNAL_CALL, Whitelist.isWhitelisted(address)(_wallet)
TMP_221(None) = SOLIDITY_CALL require(bool)(TMP_220)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
whitelist[_wallet] = false

IRs:
REF_147(bool) -> whitelist[_wallet]
REF_147(bool) (->whitelist) := False(bool)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
whitelistLength --

IRs:
TMP_222(uint256) := whitelistLength(uint256)
whitelistLength(uint256) = whitelistLength - 1""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,1,0,0,onlyOwner();require(bool)(_wallet != address(0));require(bool)(isWhitelisted(_wallet));whitelist[_wallet] = false;whitelistLength --
./0xd81fe2c11edd560c4d44fdd4f651f3608452beed_ext.sol,Vault.deposit,51,57,"TMP_17(bool) = msg.value > 0,CONDITION TMP_17,TMP_18(uint256) = INTERNAL_CALL, Vault.MinimumDeposit()(),TMP_19(bool) = msg.value >= TMP_18,CONDITION TMP_19,REF_2(uint256) -> Deposits[msg.sender],REF_2(-> Deposits) = REF_2 + msg.value,Emit Deposit(msg.sender,msg.value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value > 0

IRs:
TMP_17(bool) = msg.value > 0
CONDITION TMP_17""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
msg.value >= MinimumDeposit()

IRs:
TMP_18(uint256) = INTERNAL_CALL, Vault.MinimumDeposit()()
TMP_19(bool) = msg.value >= TMP_18
CONDITION TMP_19""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Deposits[msg.sender] += msg.value

IRs:
REF_2(uint256) -> Deposits[msg.sender]
REF_2(-> Deposits) = REF_2 + msg.value""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Deposit(msg.sender,msg.value)

IRs:
Emit Deposit(msg.sender,msg.value)""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,1,0,0,"msg.value > 0;msg.value >= MinimumDeposit();;Deposits[msg.sender] += msg.value;;Deposit(msg.sender,msg.value)"
./0x70b7c2015e1e01541ca220fa36c733fc03c687c5_ext.sol,DBXContract._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xcfca01488643501cab56d1855921c897d5ee4b1b_ext.sol,BitcoinInw.totalSupply,95,97,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0xeca7f8aa63d1d28fafda5fdf021388b5d7166dee_ext.sol,TryToPlay.StartTryToPlay,20,27,"TMP_7(bool) = responseHash == 0,CONDITION TMP_7,TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response),responseHash(bytes32) := TMP_8(bytes32),question(string) := _question(string),questionSender(address) := msg.sender(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
responseHash == 0x0

IRs:
TMP_7(bool) = responseHash == 0
CONDITION TMP_7""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
responseHash = keccak256()(_response)

IRs:
TMP_8(bytes32) = SOLIDITY_CALL keccak256()(_response)
responseHash(bytes32) := TMP_8(bytes32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
questionSender = msg.sender

IRs:
questionSender(address) := msg.sender(address)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,1,0,0,responseHash == 0x0;responseHash = keccak256()(_response);;question = _question;questionSender = msg.sender
./0xd3676a37a23ad8f4238064c1edc704debf335f26_ext.sol,CariNetPrivilege.burnFrom,103,111,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x347d11b17022f0f636dda2492f980cc60117d3f7_ext.sol,MyAdvancedToken.mintToken,370,380,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0xdba934811a10d2cfe5f33736cc56c42e7b8fd067_ext.sol,HAMDAN.approveAndCall,199,204,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x267398927b5886df921b235afe9dbbe47fbcc37d_ext.sol,NobarToken.approveAndCall,60,68,"TMP_19 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_19(tokenRecipient),TMP_20(bool) = INTERNAL_CALL, NobarToken.approve(address,uint256)(_spender,_value),CONDITION TMP_20,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_19 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_19(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_20(bool) = INTERNAL_CALL, NobarToken.approve(address,uint256)(_spender,_value)
CONDITION TMP_20""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0xa2651bfa1d613fea0f7a3138e442e4ee865b5ec7_ext.sol,AdsVenture.setUser,46,56,"REF_2(AdsVenture.User) -> users[_address],user(AdsVenture.User) := REF_2(AdsVenture.User),REF_3(string) -> user.username,REF_3(string) (->user) := _username(string),REF_4(uint256) -> user.balance,REF_4(uint256) (->user) := _balance(uint256),TMP_2(bool) = owner == _address,CONDITION TMP_2,REF_5(uint256) -> user.balance,REF_5(uint256) (->user) := totalSupply(uint256),REF_7 -> LENGTH userAccounts,TMP_5(uint256) := REF_7(uint256),TMP_6(uint256) = TMP_5 + 1,REF_7(uint256) (->userAccounts) := TMP_6(uint256),REF_8(address) -> userAccounts[TMP_5],REF_8(address) (->userAccounts) := _address(address),TMP_4(None) = TMP_3 - 1,Emit userInfo(_username,_balance)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
user = users[_address]

IRs:
REF_2(AdsVenture.User) -> users[_address]
user(AdsVenture.User) := REF_2(AdsVenture.User)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
user.username = _username

IRs:
REF_3(string) -> user.username
REF_3(string) (->user) := _username(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
user.balance = _balance

IRs:
REF_4(uint256) -> user.balance
REF_4(uint256) (->user) := _balance(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
owner == _address

IRs:
TMP_2(bool) = owner == _address
CONDITION TMP_2""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
user.balance = totalSupply

IRs:
REF_5(uint256) -> user.balance
REF_5(uint256) (->user) := totalSupply(uint256)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
userAccounts.push(_address) - 1

IRs:
REF_7 -> LENGTH userAccounts
TMP_5(uint256) := REF_7(uint256)
TMP_6(uint256) = TMP_5 + 1
REF_7(uint256) (->userAccounts) := TMP_6(uint256)
REF_8(address) -> userAccounts[TMP_5]
REF_8(address) (->userAccounts) := _address(address)
TMP_4(None) = TMP_3 - 1""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
userInfo(_username,_balance)

IRs:
Emit userInfo(_username,_balance)""];
}
",0,1,0,0,"user = users[_address];user.username = _username;user.balance = _balance;owner == _address;user.balance = totalSupply;;userAccounts.push(_address) - 1;userInfo(_username,_balance)"
./0x887e1988f7d697df22aea1207a5e1831ad3065ef_ext.sol,TokenLayer._transfer,507,518,"REF_106(uint256) -> ownershipTokenCount[_to],TMP_221(uint256) := REF_106(uint256),REF_106(-> ownershipTokenCount) = REF_106 + 1,REF_107(TokenLayer.Token) -> tokenIndexToToken[_tokenId],REF_108(address) -> REF_107.owner,REF_108(address) (->tokenIndexToToken) := _to(address),REF_109(TokenLayer.Token) -> tokenIndexToToken[_tokenId],REF_110(uint256) -> REF_109.lastBlock,REF_110(uint256) (->tokenIndexToToken) := block.number(uint256),TMP_222 = CONVERT 0 to address,TMP_223(bool) = _from != TMP_222,CONDITION TMP_223,REF_111(uint256) -> ownershipTokenCount[_from],TMP_224(uint256) := REF_111(uint256),REF_111(-> ownershipTokenCount) = REF_111 - 1,REF_112(TokenLayer.Token) -> tokenIndexToToken[_tokenId],REF_113(address) -> REF_112.approved,REF_113(address) (->tokenIndexToToken) := 0(uint256),Emit Transfer(_from,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownershipTokenCount[_to] ++

IRs:
REF_106(uint256) -> ownershipTokenCount[_to]
TMP_221(uint256) := REF_106(uint256)
REF_106(-> ownershipTokenCount) = REF_106 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
tokenIndexToToken[_tokenId].owner = _to

IRs:
REF_107(TokenLayer.Token) -> tokenIndexToToken[_tokenId]
REF_108(address) -> REF_107.owner
REF_108(address) (->tokenIndexToToken) := _to(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tokenIndexToToken[_tokenId].lastBlock = block.number

IRs:
REF_109(TokenLayer.Token) -> tokenIndexToToken[_tokenId]
REF_110(uint256) -> REF_109.lastBlock
REF_110(uint256) (->tokenIndexToToken) := block.number(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
_from != address(0)

IRs:
TMP_222 = CONVERT 0 to address
TMP_223(bool) = _from != TMP_222
CONDITION TMP_223""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
ownershipTokenCount[_from] --

IRs:
REF_111(uint256) -> ownershipTokenCount[_from]
TMP_224(uint256) := REF_111(uint256)
REF_111(-> ownershipTokenCount) = REF_111 - 1""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tokenIndexToToken[_tokenId].approved = 0

IRs:
REF_112(TokenLayer.Token) -> tokenIndexToToken[_tokenId]
REF_113(address) -> REF_112.approved
REF_113(address) (->tokenIndexToToken) := 0(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
}
",0,1,0,0,"ownershipTokenCount[_to] ++;tokenIndexToToken[_tokenId].owner = _to;tokenIndexToToken[_tokenId].lastBlock = block.number;_from != address(0);ownershipTokenCount[_from] --;;tokenIndexToToken[_tokenId].approved = 0;Transfer(_from,_to,_tokenId)"
./0x284ff8b2acda5bbf3e7aa72dad0894ea716b5ffd_ext.sol,TokenERC20.burnFrom,178,186,"REF_20(uint256) -> balanceOf[_from],TMP_37(bool) = REF_20 >= _value,TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37),REF_21(mapping(address => uint256)) -> allowance[_from],REF_22(uint256) -> REF_21[msg.sender],TMP_39(bool) = _value <= REF_22,TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39),REF_23(uint256) -> balanceOf[_from],REF_23(-> balanceOf) = REF_23 - _value,REF_24(mapping(address => uint256)) -> allowance[_from],REF_25(uint256) -> REF_24[msg.sender],REF_25(-> allowance) = REF_25 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,MODIFIER_CALL, TokenERC20.isRunning()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_20(uint256) -> balanceOf[_from]
TMP_37(bool) = REF_20 >= _value
TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_21(mapping(address => uint256)) -> allowance[_from]
REF_22(uint256) -> REF_21[msg.sender]
TMP_39(bool) = _value <= REF_22
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_23(uint256) -> balanceOf[_from]
REF_23(-> balanceOf) = REF_23 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_24(mapping(address => uint256)) -> allowance[_from]
REF_25(uint256) -> REF_24[msg.sender]
REF_25(-> allowance) = REF_25 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
isRunning()

IRs:
MODIFIER_CALL, TokenERC20.isRunning()()""];
8->1;
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"isRunning();require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xaa57e849341a2899110ba676a49302c069251d19_ext.sol,EditionStorage.nextOffsetIndex,315,317,"TMP_174(uint256) := offsetIndex(uint256),offsetIndex(uint256) = offsetIndex + 1,MODIFIER_CALL, BaseStorage.canWrite()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
offsetIndex ++

IRs:
TMP_174(uint256) := offsetIndex(uint256)
offsetIndex(uint256) = offsetIndex + 1""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
canWrite()

IRs:
MODIFIER_CALL, BaseStorage.canWrite()()""];
2->1;
}
",0,1,0,0,canWrite();offsetIndex ++
./0x6b6d1a8858893c3e228f335726e1417a35832f76_ext.sol,Carbon.burnTotalSupply,61,64,"totalSupply(uint256) = totalSupply - _amount,MODIFIER_CALL, Carbon.isOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
totalSupply -= _amount

IRs:
totalSupply(uint256) = totalSupply - _amount""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isOwner()

IRs:
MODIFIER_CALL, Carbon.isOwner()()""];
2->1;
}
",0,1,0,0,isOwner();totalSupply -= _amount
./0x55ae5792903b179915e10065e26610435832a3f7_ext.sol,CofounditICO.fallback,94,128,"TMP_17(bool) = msg.value == 0,CONDITION TMP_17,TMP_18(bool) = block.number > endBlock,TMP_19(bool) = icoHasSucessfulyEnded || TMP_18,CONDITION TMP_19,TMP_20 = UnaryType.BANG icoHasStarted ,CONDITION TMP_20,TMP_21(bool) = block.number < startBlock,CONDITION TMP_21,REF_0(bool) -> presaleContributorAllowance[msg.sender],TMP_22 = UnaryType.BANG REF_0 ,CONDITION TMP_22,icoHasStarted(bool) := True(bool),Emit ICOStarted(block.number,icoStartedMessage),REF_1(uint256) -> participantContribution[msg.sender],TMP_24(bool) = REF_1 == 0,CONDITION TMP_24,REF_2(address) -> participantIndex[nextFreeParticipantIndex],REF_2(address) (->participantIndex) := msg.sender(address),nextFreeParticipantIndex(uint256) = nextFreeParticipantIndex + 1,TMP_25(uint256) = totalEthRaised + msg.value,TMP_26(bool) = maxEthToRaise > TMP_25,CONDITION TMP_26,REF_3(uint256) -> participantContribution[msg.sender],REF_3(-> participantContribution) = REF_3 + msg.value,totalEthRaised(uint256) = totalEthRaised + msg.value,TMP_27 = UnaryType.BANG minTresholdReached ,TMP_28(bool) = totalEthRaised >= minEthToRaise,TMP_29(bool) = TMP_27 && TMP_28,CONDITION TMP_29,Emit ICOMinTresholdReached(block.number,icoMinTresholdReachedMessage),minTresholdReached(bool) := True(bool),TMP_31(uint256) = maxEthToRaise - totalEthRaised,maxContribution(uint256) := TMP_31(uint256),REF_4(uint256) -> participantContribution[msg.sender],REF_4(-> participantContribution) = REF_4 + maxContribution,totalEthRaised(uint256) = totalEthRaised + maxContribution,TMP_32(uint256) = msg.value - maxContribution,toReturn(uint256) := TMP_32(uint256),icoHasSucessfulyEnded(bool) := True(bool),Emit ICOEndedSuccessfuly(block.number,totalEthRaised,icoEndedSuccessfulyWithCapMessage),TMP_34 = SEND dest:msg.sender value:toReturn,TMP_35 = UnaryType.BANG TMP_34 ,CONDITION TMP_35,Emit ErrorSendingETH(msg.sender,toReturn)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value == 0

IRs:
TMP_17(bool) = msg.value == 0
CONDITION TMP_17""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
icoHasSucessfulyEnded || block.number > endBlock

IRs:
TMP_18(bool) = block.number > endBlock
TMP_19(bool) = icoHasSucessfulyEnded || TMP_18
CONDITION TMP_19""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: THROW 5
""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
! icoHasStarted

IRs:
TMP_20 = UnaryType.BANG icoHasStarted 
CONDITION TMP_20""];
7->8[label=""True""];
7->15[label=""False""];
8[label=""Node Type: IF 8

EXPRESSION:
block.number < startBlock

IRs:
TMP_21(bool) = block.number < startBlock
CONDITION TMP_21""];
8->9[label=""True""];
8->12[label=""False""];
9[label=""Node Type: IF 9

EXPRESSION:
! presaleContributorAllowance[msg.sender]

IRs:
REF_0(bool) -> presaleContributorAllowance[msg.sender]
TMP_22 = UnaryType.BANG REF_0 
CONDITION TMP_22""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: THROW 10
""];
11[label=""Node Type: END_IF 11
""];
11->14;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
icoHasStarted = true

IRs:
icoHasStarted(bool) := True(bool)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
ICOStarted(block.number,icoStartedMessage)

IRs:
Emit ICOStarted(block.number,icoStartedMessage)""];
13->14;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: IF 16

EXPRESSION:
participantContribution[msg.sender] == 0

IRs:
REF_1(uint256) -> participantContribution[msg.sender]
TMP_24(bool) = REF_1 == 0
CONDITION TMP_24""];
16->17[label=""True""];
16->19[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
participantIndex[nextFreeParticipantIndex] = msg.sender

IRs:
REF_2(address) -> participantIndex[nextFreeParticipantIndex]
REF_2(address) (->participantIndex) := msg.sender(address)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
nextFreeParticipantIndex += 1

IRs:
nextFreeParticipantIndex(uint256) = nextFreeParticipantIndex + 1""];
18->19;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: IF 20

EXPRESSION:
maxEthToRaise > (totalEthRaised + msg.value)

IRs:
TMP_25(uint256) = totalEthRaised + msg.value
TMP_26(bool) = maxEthToRaise > TMP_25
CONDITION TMP_26""];
20->21[label=""True""];
20->27[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
participantContribution[msg.sender] += msg.value

IRs:
REF_3(uint256) -> participantContribution[msg.sender]
REF_3(-> participantContribution) = REF_3 + msg.value""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
totalEthRaised += msg.value

IRs:
totalEthRaised(uint256) = totalEthRaised + msg.value""];
22->23;
23[label=""Node Type: IF 23

EXPRESSION:
! minTresholdReached && totalEthRaised >= minEthToRaise

IRs:
TMP_27 = UnaryType.BANG minTresholdReached 
TMP_28(bool) = totalEthRaised >= minEthToRaise
TMP_29(bool) = TMP_27 && TMP_28
CONDITION TMP_29""];
23->24[label=""True""];
23->26[label=""False""];
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
ICOMinTresholdReached(block.number,icoMinTresholdReachedMessage)

IRs:
Emit ICOMinTresholdReached(block.number,icoMinTresholdReachedMessage)""];
24->25;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
minTresholdReached = true

IRs:
minTresholdReached(bool) := True(bool)""];
25->26;
26[label=""Node Type: END_IF 26
""];
26->36;
27[label=""Node Type: NEW VARIABLE 27

EXPRESSION:
maxContribution = maxEthToRaise - totalEthRaised

IRs:
TMP_31(uint256) = maxEthToRaise - totalEthRaised
maxContribution(uint256) := TMP_31(uint256)""];
27->28;
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
participantContribution[msg.sender] += maxContribution

IRs:
REF_4(uint256) -> participantContribution[msg.sender]
REF_4(-> participantContribution) = REF_4 + maxContribution""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
totalEthRaised += maxContribution

IRs:
totalEthRaised(uint256) = totalEthRaised + maxContribution""];
29->30;
30[label=""Node Type: NEW VARIABLE 30

EXPRESSION:
toReturn = msg.value - maxContribution

IRs:
TMP_32(uint256) = msg.value - maxContribution
toReturn(uint256) := TMP_32(uint256)""];
30->31;
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
icoHasSucessfulyEnded = true

IRs:
icoHasSucessfulyEnded(bool) := True(bool)""];
31->32;
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
ICOEndedSuccessfuly(block.number,totalEthRaised,icoEndedSuccessfulyWithCapMessage)

IRs:
Emit ICOEndedSuccessfuly(block.number,totalEthRaised,icoEndedSuccessfulyWithCapMessage)""];
32->33;
33[label=""Node Type: IF 33

EXPRESSION:
! msg.sender.send(toReturn)

IRs:
TMP_34 = SEND dest:msg.sender value:toReturn
TMP_35 = UnaryType.BANG TMP_34 
CONDITION TMP_35""];
33->34[label=""True""];
33->35[label=""False""];
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
ErrorSendingETH(msg.sender,toReturn)

IRs:
Emit ErrorSendingETH(msg.sender,toReturn)""];
34->35;
35[label=""Node Type: END_IF 35
""];
35->36;
36[label=""Node Type: END_IF 36
""];
}
",0,1,0,0,"msg.value == 0;;;icoHasSucessfulyEnded || block.number > endBlock;;;! icoHasStarted;block.number < startBlock;;! presaleContributorAllowance[msg.sender];icoHasStarted = true;;;;ICOStarted(block.number,icoStartedMessage);participantContribution[msg.sender] == 0;participantIndex[nextFreeParticipantIndex] = msg.sender;;nextFreeParticipantIndex += 1;maxEthToRaise > (totalEthRaised + msg.value);participantContribution[msg.sender] += msg.value;maxContribution = maxEthToRaise - totalEthRaised;totalEthRaised += msg.value;! minTresholdReached && totalEthRaised >= minEthToRaise;ICOMinTresholdReached(block.number,icoMinTresholdReachedMessage);;minTresholdReached = true;;participantContribution[msg.sender] += maxContribution;totalEthRaised += maxContribution;toReturn = msg.value - maxContribution;icoHasSucessfulyEnded = true;ICOEndedSuccessfuly(block.number,totalEthRaised,icoEndedSuccessfulyWithCapMessage);! msg.sender.send(toReturn);ErrorSendingETH(msg.sender,toReturn);"
./0x27ce49590684308d22fe7adcb8b80976701774d3_ext.sol,TheEthGame.getNumberOfBlocksRemainingToWin,367,369,"TMP_168 = CONVERT BLOCKS_TO_CONFIRM_TO_WIN_THE_GAME to int256,TMP_169(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.number', 'isFirstSinceBlock'] ,TMP_170 = CONVERT TMP_169 to int256,TMP_171(int256) = TMP_168 - TMP_170,RETURN TMP_171,RETURN _numberOfBlocks","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
int256(BLOCKS_TO_CONFIRM_TO_WIN_THE_GAME) - int256(block.number.sub(isFirstSinceBlock))

IRs:
TMP_168 = CONVERT BLOCKS_TO_CONFIRM_TO_WIN_THE_GAME to int256
TMP_169(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['block.number', 'isFirstSinceBlock'] 
TMP_170 = CONVERT TMP_169 to int256
TMP_171(int256) = TMP_168 - TMP_170
RETURN TMP_171""];
2[label=""Node Type: RETURN 2

EXPRESSION:
_numberOfBlocks

IRs:
RETURN _numberOfBlocks""];
}
",0,1,0,0,int256(BLOCKS_TO_CONFIRM_TO_WIN_THE_GAME) - int256(block.number.sub(isFirstSinceBlock));_numberOfBlocks
./0x2aaefbac989f8951436c36474c304af7bf31bb26_ext.sol,Broker.registerBroker,206,217,"TMP_169(bool) = vipBrokerNum > 0,TMP_170(None) = SOLIDITY_CALL require(bool)(TMP_169),TMP_171(bool) = msg.value >= vipBrokerFee,TMP_172(None) = SOLIDITY_CALL require(bool)(TMP_171),REF_11(bool) -> UserToIfBroker[msg.sender],TMP_173(bool) = REF_11 == False,TMP_174(None) = SOLIDITY_CALL require(bool)(TMP_173),REF_12(bool) -> UserToIfBroker[msg.sender],REF_12(bool) (->UserToIfBroker) := True(bool),TMP_175(uint256) := vipBrokerNum(uint256),vipBrokerNum(uint256) = vipBrokerNum - 1,TMP_176(uint256) = 1000 - vipBrokerNum,brokerId(uint256) := TMP_176(uint256),REF_13(address[]) -> BrokerIdToBrokers[brokerId],REF_15 -> LENGTH REF_13,TMP_178(uint256) := REF_15(uint256),TMP_179(uint256) = TMP_178 + 1,REF_15(uint256) (->BrokerIdToBrokers) := TMP_179(uint256),REF_16(address) -> REF_13[TMP_178],REF_16(address) (->BrokerIdToBrokers) := msg.sender(address),REF_17(uint256) -> BrokerIdToSpots[brokerId],REF_17(uint256) (->BrokerIdToSpots) := subBrokerNum(uint256),Emit BrokerRegistered(brokerId,msg.sender),RETURN brokerId","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(vipBrokerNum > 0)

IRs:
TMP_169(bool) = vipBrokerNum > 0
TMP_170(None) = SOLIDITY_CALL require(bool)(TMP_169)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.value >= vipBrokerFee)

IRs:
TMP_171(bool) = msg.value >= vipBrokerFee
TMP_172(None) = SOLIDITY_CALL require(bool)(TMP_171)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(UserToIfBroker[msg.sender] == false)

IRs:
REF_11(bool) -> UserToIfBroker[msg.sender]
TMP_173(bool) = REF_11 == False
TMP_174(None) = SOLIDITY_CALL require(bool)(TMP_173)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
UserToIfBroker[msg.sender] = true

IRs:
REF_12(bool) -> UserToIfBroker[msg.sender]
REF_12(bool) (->UserToIfBroker) := True(bool)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
vipBrokerNum --

IRs:
TMP_175(uint256) := vipBrokerNum(uint256)
vipBrokerNum(uint256) = vipBrokerNum - 1""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
brokerId = 1000 - vipBrokerNum

IRs:
TMP_176(uint256) = 1000 - vipBrokerNum
brokerId(uint256) := TMP_176(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
BrokerIdToBrokers[brokerId].push(msg.sender)

IRs:
REF_13(address[]) -> BrokerIdToBrokers[brokerId]
REF_15 -> LENGTH REF_13
TMP_178(uint256) := REF_15(uint256)
TMP_179(uint256) = TMP_178 + 1
REF_15(uint256) (->BrokerIdToBrokers) := TMP_179(uint256)
REF_16(address) -> REF_13[TMP_178]
REF_16(address) (->BrokerIdToBrokers) := msg.sender(address)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
BrokerIdToSpots[brokerId] = subBrokerNum

IRs:
REF_17(uint256) -> BrokerIdToSpots[brokerId]
REF_17(uint256) (->BrokerIdToSpots) := subBrokerNum(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
BrokerRegistered(brokerId,msg.sender)

IRs:
Emit BrokerRegistered(brokerId,msg.sender)""];
9->10;
10[label=""Node Type: RETURN 10

EXPRESSION:
brokerId

IRs:
RETURN brokerId""];
}
",0,1,0,0,"require(bool)(vipBrokerNum > 0);require(bool)(msg.value >= vipBrokerFee);require(bool)(UserToIfBroker[msg.sender] == false);UserToIfBroker[msg.sender] = true;vipBrokerNum --;brokerId = 1000 - vipBrokerNum;BrokerIdToBrokers[brokerId].push(msg.sender);BrokerIdToSpots[brokerId] = subBrokerNum;BrokerRegistered(brokerId,msg.sender);brokerId"
./0x5592a2704ba651f8af4cb6f330415f9877483ad2_ext.sol,NamiTrade._transfer,1339,1355,"TMP_464(bool) = _to != 0,TMP_465(None) = SOLIDITY_CALL require(bool)(TMP_464),REF_261(uint256) -> balanceOf[_from],TMP_466(bool) = REF_261 >= _value,TMP_467(None) = SOLIDITY_CALL require(bool)(TMP_466),REF_262(uint256) -> balanceOf[_to],TMP_468(uint256) = REF_262 + _value,REF_263(uint256) -> balanceOf[_to],TMP_469(bool) = TMP_468 >= REF_263,TMP_470(None) = SOLIDITY_CALL require(bool)(TMP_469),REF_264(uint256) -> balanceOf[_from],REF_265(uint256) -> balanceOf[_to],TMP_471(uint256) = REF_264 + REF_265,previousBalances(uint256) := TMP_471(uint256),REF_266(uint256) -> balanceOf[_from],REF_266(-> balanceOf) = REF_266 - _value,REF_267(uint256) -> balanceOf[_to],REF_267(-> balanceOf) = REF_267 + _value,Emit Transfer(_from,_to,_value),REF_268(uint256) -> balanceOf[_from],REF_269(uint256) -> balanceOf[_to],TMP_473(uint256) = REF_268 + REF_269,TMP_474(bool) = TMP_473 == previousBalances,TMP_475(None) = SOLIDITY_CALL assert(bool)(TMP_474)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_464(bool) = _to != 0
TMP_465(None) = SOLIDITY_CALL require(bool)(TMP_464)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_261(uint256) -> balanceOf[_from]
TMP_466(bool) = REF_261 >= _value
TMP_467(None) = SOLIDITY_CALL require(bool)(TMP_466)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_262(uint256) -> balanceOf[_to]
TMP_468(uint256) = REF_262 + _value
REF_263(uint256) -> balanceOf[_to]
TMP_469(bool) = TMP_468 >= REF_263
TMP_470(None) = SOLIDITY_CALL require(bool)(TMP_469)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_264(uint256) -> balanceOf[_from]
REF_265(uint256) -> balanceOf[_to]
TMP_471(uint256) = REF_264 + REF_265
previousBalances(uint256) := TMP_471(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_266(uint256) -> balanceOf[_from]
REF_266(-> balanceOf) = REF_266 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_267(uint256) -> balanceOf[_to]
REF_267(-> balanceOf) = REF_267 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_268(uint256) -> balanceOf[_from]
REF_269(uint256) -> balanceOf[_to]
TMP_473(uint256) = REF_268 + REF_269
TMP_474(bool) = TMP_473 == previousBalances
TMP_475(None) = SOLIDITY_CALL assert(bool)(TMP_474)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x518be1097f1b72e60f9e12247980f4c08b643809_ext.sol,Multiownable.deleteOperation,172,183,"REF_22(uint256) -> allOperationsIndicies[operation],index(uint256) := REF_22(uint256),REF_23 -> LENGTH allOperations,TMP_26(uint256) = REF_23 - 1,TMP_27(bool) = index < TMP_26,CONDITION TMP_27,REF_24(bytes32) -> allOperations[index],REF_25 -> LENGTH allOperations,TMP_28(uint256) = REF_25 - 1,REF_26(bytes32) -> allOperations[TMP_28],REF_24(bytes32) (->allOperations) := REF_26(bytes32),REF_27(bytes32) -> allOperations[index],REF_28(uint256) -> allOperationsIndicies[REF_27],REF_28(uint256) (->allOperationsIndicies) := index(uint256),REF_29 -> LENGTH allOperations,TMP_29(uint256) := REF_29(uint256),REF_29(-> allOperations) = REF_29 - 1,REF_30(uint256) -> votesMaskByOperation[operation],votesMaskByOperation = delete REF_30 ,REF_31(uint256) -> votesCountByOperation[operation],votesCountByOperation = delete REF_31 ,REF_32(uint256) -> allOperationsIndicies[operation],allOperationsIndicies = delete REF_32 ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
index = allOperationsIndicies[operation]

IRs:
REF_22(uint256) -> allOperationsIndicies[operation]
index(uint256) := REF_22(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
index < allOperations.length - 1

IRs:
REF_23 -> LENGTH allOperations
TMP_26(uint256) = REF_23 - 1
TMP_27(bool) = index < TMP_26
CONDITION TMP_27""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
allOperations[index] = allOperations[allOperations.length - 1]

IRs:
REF_24(bytes32) -> allOperations[index]
REF_25 -> LENGTH allOperations
TMP_28(uint256) = REF_25 - 1
REF_26(bytes32) -> allOperations[TMP_28]
REF_24(bytes32) (->allOperations) := REF_26(bytes32)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allOperationsIndicies[allOperations[index]] = index

IRs:
REF_27(bytes32) -> allOperations[index]
REF_28(uint256) -> allOperationsIndicies[REF_27]
REF_28(uint256) (->allOperationsIndicies) := index(uint256)""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allOperations.length --

IRs:
REF_29 -> LENGTH allOperations
TMP_29(uint256) := REF_29(uint256)
REF_29(-> allOperations) = REF_29 - 1""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
delete votesMaskByOperation[operation]

IRs:
REF_30(uint256) -> votesMaskByOperation[operation]
votesMaskByOperation = delete REF_30 ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
delete votesCountByOperation[operation]

IRs:
REF_31(uint256) -> votesCountByOperation[operation]
votesCountByOperation = delete REF_31 ""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
delete allOperationsIndicies[operation]

IRs:
REF_32(uint256) -> allOperationsIndicies[operation]
allOperationsIndicies = delete REF_32 ""];
}
",0,1,0,0,index = allOperationsIndicies[operation];index < allOperations.length - 1;allOperations[index] = allOperations[allOperations.length - 1];;allOperationsIndicies[allOperations[index]] = index;allOperations.length --;delete votesMaskByOperation[operation];delete votesCountByOperation[operation];delete allOperationsIndicies[operation]
./0x3f922acba2ee567a93933fa4392c2690e4706d42_ext.sol,TokenERC20.approveAndCall,55,61,"TMP_19 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_19(tokenRecipient),TMP_20(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value),CONDITION TMP_20,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_19 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_19(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_20(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value)
CONDITION TMP_20""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x850c430378909ba9ff2494d0a4df17928e99f8f4_ext.sol,BdpOwnershipStorage.decrementTokenIdsLength,698,700,"REF_197 -> LENGTH tokenIds,TMP_347(uint256) := REF_197(uint256),REF_197(-> tokenIds) = REF_197 - 1,MODIFIER_CALL, BdpBase.storageAccessControl()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
tokenIds.length --

IRs:
REF_197 -> LENGTH tokenIds
TMP_347(uint256) := REF_197(uint256)
REF_197(-> tokenIds) = REF_197 - 1""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
storageAccessControl()

IRs:
MODIFIER_CALL, BdpBase.storageAccessControl()()""];
2->1;
}
",0,1,0,0,storageAccessControl();tokenIds.length --
./0x129e719c424a7a6fbdeb7ca3d65186892d54ea8c_ext.sol,QUIZ_GAME.StartGame,11,21,"TMP_0(bool) = responseHash == 0,CONDITION TMP_0,TMP_1(bytes32) = SOLIDITY_CALL keccak256()(_response),responseHash(bytes32) := TMP_1(bytes32),Question(string) := _question(string),questionSender(address) := msg.sender(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
responseHash == 0x0

IRs:
TMP_0(bool) = responseHash == 0
CONDITION TMP_0""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
responseHash = keccak256()(_response)

IRs:
TMP_1(bytes32) = SOLIDITY_CALL keccak256()(_response)
responseHash(bytes32) := TMP_1(bytes32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Question = _question

IRs:
Question(string) := _question(string)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
questionSender = msg.sender

IRs:
questionSender(address) := msg.sender(address)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,1,0,0,responseHash == 0x0;responseHash = keccak256()(_response);;Question = _question;questionSender = msg.sender
./0x129e719c424a7a6fbdeb7ca3d65186892d54ea8c_ext.sol,QUIZ_GAME.NewQuestion,42,49,"TMP_12(bool) = msg.sender == questionSender,TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12),responseHash(bytes32) := _responseHash(bytes32),Question(string) := _question(string)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_12(bool) = msg.sender == questionSender
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
responseHash = _responseHash

IRs:
responseHash(bytes32) := _responseHash(bytes32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Question = _question

IRs:
Question(string) := _question(string)""];
}
",0,1,0,0,require(bool)(msg.sender == questionSender);responseHash = _responseHash;Question = _question
./0x4c1a8ba7d6fe281ea01b3cd69fcb6d82d5771996_ext.sol,TokenERC20.burn,176,182,"REF_27(uint256) -> balanceOf[msg.sender],TMP_47(bool) = REF_27 >= _value,TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47),REF_28(uint256) -> balanceOf[msg.sender],REF_28(-> balanceOf) = REF_28 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_27(uint256) -> balanceOf[msg.sender]
TMP_47(bool) = REF_27 >= _value
TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_28(uint256) -> balanceOf[msg.sender]
REF_28(-> balanceOf) = REF_28 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x6b78d47bfd2b391f2f34f31a128487e6768ab4f6_ext.sol,eduCash.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x2d50c2dd998aab26a666a5e9f15e7f32ad9e8ce1_ext.sol,VOCC_I073_20181211.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x5b2028602af2693d50b4157f4acf84d632ec8208_ext.sol,Savings.deposit,30,35,"TMP_4(bool) = msg.value >= 500000000000000000,CONDITION TMP_4,REF_0(uint256) -> deposits[msg.sender],REF_0(-> deposits) = REF_0 + msg.value,Emit Deposit(msg.sender,msg.value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value >= 500000000000000000

IRs:
TMP_4(bool) = msg.value >= 500000000000000000
CONDITION TMP_4""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
deposits[msg.sender] += msg.value

IRs:
REF_0(uint256) -> deposits[msg.sender]
REF_0(-> deposits) = REF_0 + msg.value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Deposit(msg.sender,msg.value)

IRs:
Emit Deposit(msg.sender,msg.value)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,"msg.value >= 500000000000000000;deposits[msg.sender] += msg.value;;Deposit(msg.sender,msg.value)"
./0x5192a95f79c83e1581574b90f75a28af79c871ff_ext.sol,DiscountPercentCoin.mintToken,271,276,"REF_85(uint256) -> balanceOf[target],REF_85(-> balanceOf) = REF_85 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, Authorizable.onlyAuthorized()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_85(uint256) -> balanceOf[target]
REF_85(-> balanceOf) = REF_85 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyAuthorized()

IRs:
MODIFIER_CALL, Authorizable.onlyAuthorized()()""];
5->1;
}
",0,1,0,0,"onlyAuthorized();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x77de6b2729baff72c220115fe03017c57b57baf5_ext.sol,Dancoin.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x3a7ebc138fd59ccce16b7968199c2ac7b013bbc0_ext.sol,NewToken.transferFrom,66,72,"REF_4(uint256) -> balances[_from],TMP_7(bool) = REF_4 >= _value,REF_5(mapping(address => uint256)) -> allowed[_from],REF_6(uint256) -> REF_5[msg.sender],TMP_8(bool) = REF_6 >= _value,TMP_9(bool) = TMP_7 && TMP_8,TMP_10(bool) = _value > 0,TMP_11(bool) = TMP_9 && TMP_10,TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11),REF_7(uint256) -> balances[_to],REF_7(-> balances) = REF_7 + _value,REF_8(uint256) -> balances[_from],REF_8(-> balances) = REF_8 - _value,REF_9(mapping(address => uint256)) -> allowed[_from],REF_10(uint256) -> REF_9[msg.sender],REF_10(-> allowed) = REF_10 - _value,Emit Transfer(_from,_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0)

IRs:
REF_4(uint256) -> balances[_from]
TMP_7(bool) = REF_4 >= _value
REF_5(mapping(address => uint256)) -> allowed[_from]
REF_6(uint256) -> REF_5[msg.sender]
TMP_8(bool) = REF_6 >= _value
TMP_9(bool) = TMP_7 && TMP_8
TMP_10(bool) = _value > 0
TMP_11(bool) = TMP_9 && TMP_10
TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_7(uint256) -> balances[_to]
REF_7(-> balances) = REF_7 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_8(uint256) -> balances[_from]
REF_8(-> balances) = REF_8 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_9(mapping(address => uint256)) -> allowed[_from]
REF_10(uint256) -> REF_9[msg.sender]
REF_10(-> allowed) = REF_10 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
}
",0,1,0,0,"require(bool)(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);balances[_to] += _value;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value)"
./0x64e99085fca7f908e1de0db94dae7449b90e97a5_ext.sol,EIP20.transferFrom,86,96,"REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],allowance(uint256) := REF_5(uint256),REF_6(uint256) -> balances[_from],TMP_3(bool) = REF_6 >= _value,TMP_4(bool) = allowance >= _value,TMP_5(bool) = TMP_3 && TMP_4,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_7(uint256) -> balances[_to],REF_7(-> balances) = REF_7 + _value,REF_8(uint256) -> balances[_from],REF_8(-> balances) = REF_8 - _value,TMP_7(bool) = allowance < MAX_UINT256,CONDITION TMP_7,REF_9(mapping(address => uint256)) -> allowed[_from],REF_10(uint256) -> REF_9[msg.sender],REF_10(-> allowed) = REF_10 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
allowance = allowed[_from][msg.sender]

IRs:
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
allowance(uint256) := REF_5(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] >= _value && allowance >= _value)

IRs:
REF_6(uint256) -> balances[_from]
TMP_3(bool) = REF_6 >= _value
TMP_4(bool) = allowance >= _value
TMP_5(bool) = TMP_3 && TMP_4
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_7(uint256) -> balances[_to]
REF_7(-> balances) = REF_7 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] -= _value

IRs:
REF_8(uint256) -> balances[_from]
REF_8(-> balances) = REF_8 - _value""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
allowance < MAX_UINT256

IRs:
TMP_7(bool) = allowance < MAX_UINT256
CONDITION TMP_7""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_9(mapping(address => uint256)) -> allowed[_from]
REF_10(uint256) -> REF_9[msg.sender]
REF_10(-> allowed) = REF_10 - _value""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: RETURN 10

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowance = allowed[_from][msg.sender];require(bool)(balances[_from] >= _value && allowance >= _value);balances[_to] += _value;balances[_from] -= _value;allowance < MAX_UINT256;allowed[_from][msg.sender] -= _value;;Transfer(_from,_to,_value);true;success"
./0x008d3c9e91f8abff45f39eb71b316a0606c6d378_ext.sol,TCN.burnFrom,140,148,"REF_19(uint256) -> balanceOf[_from],TMP_22(bool) = REF_19 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_24(bool) = _value <= REF_21,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_22(bool) = REF_19 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_24(bool) = _value <= REF_21
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x1c65557b72804569bcd25ce53575a9c712e2eff5_ext.sol,Play2LivePromo.transferFrom,90,96,"REF_4(uint256) -> balances[_from],REF_4(-> balances) = REF_4 - _amount,REF_5(mapping(address => uint256)) -> allowed[_from],REF_6(uint256) -> REF_5[msg.sender],REF_6(-> allowed) = REF_6 - _amount,REF_7(uint256) -> balances[_to],REF_7(-> balances) = REF_7 - _amount,Emit Transfer(_from,_to,_amount),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances[_from] -= _amount

IRs:
REF_4(uint256) -> balances[_from]
REF_4(-> balances) = REF_4 - _amount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
allowed[_from][msg.sender] -= _amount

IRs:
REF_5(mapping(address => uint256)) -> allowed[_from]
REF_6(uint256) -> REF_5[msg.sender]
REF_6(-> allowed) = REF_6 - _amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] -= _amount

IRs:
REF_7(uint256) -> balances[_to]
REF_7(-> balances) = REF_7 - _amount""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(_from,_to,_amount)

IRs:
Emit Transfer(_from,_to,_amount)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"balances[_from] -= _amount;allowed[_from][msg.sender] -= _amount;balances[_to] -= _amount;Transfer(_from,_to,_amount);true"
./0xa15b24b7b883aac6bc6582b0057c09d62a7a1b2c_ext.sol,Simply10.fallback,8,19,"sender(address) := msg.sender(address),REF_0(uint256) -> invests[sender],TMP_0(bool) = REF_0 != 0,CONDITION TMP_0,REF_1(uint256) -> invests[sender],TMP_1(uint256) = REF_1 / 100,TMP_2(uint256) = TMP_1 * 10,REF_2(uint256) -> dates[sender],TMP_3(uint256) = now - REF_2,TMP_4(uint256) = TMP_2 * TMP_3,TMP_5(uint256) = TMP_4 / 86400,payout(uint256) := TMP_5(uint256),TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),TMP_8(bool) = payout > TMP_7,CONDITION TMP_8,TMP_9 = CONVERT this to address,TMP_10(uint256) = SOLIDITY_CALL balance(address)(TMP_9),payout(uint256) := TMP_10(uint256),Transfer dest:sender value:payout,REF_4(uint256) -> dates[sender],REF_4(uint256) (->dates) := now(uint256),REF_5(uint256) -> invests[sender],REF_5(-> invests) = REF_5 + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
sender = msg.sender

IRs:
sender(address) := msg.sender(address)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
invests[sender] != 0

IRs:
REF_0(uint256) -> invests[sender]
TMP_0(bool) = REF_0 != 0
CONDITION TMP_0""];
2->3[label=""True""];
2->8[label=""False""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
payout = invests[sender] / 100 * 10 * (now - dates[sender]) / 86400

IRs:
REF_1(uint256) -> invests[sender]
TMP_1(uint256) = REF_1 / 100
TMP_2(uint256) = TMP_1 * 10
REF_2(uint256) -> dates[sender]
TMP_3(uint256) = now - REF_2
TMP_4(uint256) = TMP_2 * TMP_3
TMP_5(uint256) = TMP_4 / 86400
payout(uint256) := TMP_5(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
payout > address(this).balance

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
TMP_8(bool) = payout > TMP_7
CONDITION TMP_8""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
payout = address(this).balance

IRs:
TMP_9 = CONVERT this to address
TMP_10(uint256) = SOLIDITY_CALL balance(address)(TMP_9)
payout(uint256) := TMP_10(uint256)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
sender.transfer(payout)

IRs:
Transfer dest:sender value:payout""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
dates[sender] = now

IRs:
REF_4(uint256) -> dates[sender]
REF_4(uint256) (->dates) := now(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
invests[sender] += msg.value

IRs:
REF_5(uint256) -> invests[sender]
REF_5(-> invests) = REF_5 + msg.value""];
}
",0,1,0,0,sender = msg.sender;invests[sender] != 0;payout = invests[sender] / 100 * 10 * (now - dates[sender]) / 86400;;payout > address(this).balance;payout = address(this).balance;;sender.transfer(payout);dates[sender] = now;invests[sender] += msg.value
./0xbe407e7f8687965412c31f259eb16f75c44fc80b_ext.sol,BasicToken.transfer,149,187,"TMP_26 = CONVERT 0 to address,TMP_27(bool) = _to != TMP_26,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_0(uint256) -> balances[msg.sender],TMP_29(bool) = REF_0 >= _amount,TMP_30(bool) = _amount > 0,TMP_31(bool) = TMP_29 && TMP_30,REF_1(uint256) -> balances[_to],TMP_32(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_1', '_amount'] ,REF_3(uint256) -> balances[_to],TMP_33(bool) = TMP_32 > REF_3,TMP_34(bool) = TMP_31 && TMP_33,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),TMP_36 = UnaryType.BANG released ,CONDITION TMP_36,REF_4(BasicToken.Lockup) -> lockupParticipants[msg.sender],REF_5(BasicToken.LockupType) -> REF_4.lockType,REF_6(BasicToken.LockupType) -> LockupType.PARTNER,TMP_37(bool) = REF_5 == REF_6,TMP_38(bool) = msg.sender == ownerWallet,TMP_39(bool) = TMP_37 || TMP_38,CONDITION TMP_39,REF_7(uint256) -> balances[msg.sender],REF_8(uint256) -> balances[msg.sender],TMP_40(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_8', '_amount'] ,REF_7(uint256) (->balances) := TMP_40(uint256),REF_10(uint256) -> balances[_to],REF_11(uint256) -> balances[_to],TMP_41(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_11', '_amount'] ,REF_10(uint256) (->balances) := TMP_41(uint256),Emit Transfer(msg.sender,_to,_amount),RETURN True,RETURN False,REF_13(BasicToken.Lockup) -> lockupParticipants[msg.sender],REF_14(BasicToken.LockupType) -> REF_13.lockType,REF_15(BasicToken.LockupType) -> LockupType.BLACK,TMP_43(bool) = REF_14 == REF_15,CONDITION TMP_43,RETURN False,REF_16(BasicToken.Lockup) -> lockupParticipants[msg.sender],REF_17(uint256) -> REF_16.lockupAmount,TMP_44(bool) = REF_17 > 0,CONDITION TMP_44,TMP_45(uint256) = now - startTime,timePassed(uint256) := TMP_45(uint256),REF_18(BasicToken.Lockup) -> lockupParticipants[msg.sender],REF_19(uint256) -> REF_18.lockupTime,TMP_46(bool) = timePassed < REF_19,CONDITION TMP_46,REF_20(uint256) -> balances[msg.sender],TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_20', '_amount'] ,REF_22(BasicToken.Lockup) -> lockupParticipants[msg.sender],REF_23(uint256) -> REF_22.lockupAmount,TMP_48(bool) = TMP_47 >= REF_23,TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48),REF_24(uint256) -> balances[msg.sender],REF_25(uint256) -> balances[msg.sender],TMP_50(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_25', '_amount'] ,REF_24(uint256) (->balances) := TMP_50(uint256),REF_27(uint256) -> balances[_to],REF_28(uint256) -> balances[_to],TMP_51(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_28', '_amount'] ,REF_27(uint256) (->balances) := TMP_51(uint256),Emit Transfer(msg.sender,_to,_amount),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_26 = CONVERT 0 to address
TMP_27(bool) = _to != TMP_26
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[msg.sender] >= _amount && _amount > 0 && balances[_to].add(_amount) > balances[_to])

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_29(bool) = REF_0 >= _amount
TMP_30(bool) = _amount > 0
TMP_31(bool) = TMP_29 && TMP_30
REF_1(uint256) -> balances[_to]
TMP_32(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_1', '_amount'] 
REF_3(uint256) -> balances[_to]
TMP_33(bool) = TMP_32 > REF_3
TMP_34(bool) = TMP_31 && TMP_33
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
! released

IRs:
TMP_36 = UnaryType.BANG released 
CONDITION TMP_36""];
3->4[label=""True""];
3->11[label=""False""];
4[label=""Node Type: IF 4

EXPRESSION:
(lockupParticipants[msg.sender].lockType == LockupType.PARTNER) || (msg.sender == ownerWallet)

IRs:
REF_4(BasicToken.Lockup) -> lockupParticipants[msg.sender]
REF_5(BasicToken.LockupType) -> REF_4.lockType
REF_6(BasicToken.LockupType) -> LockupType.PARTNER
TMP_37(bool) = REF_5 == REF_6
TMP_38(bool) = msg.sender == ownerWallet
TMP_39(bool) = TMP_37 || TMP_38
CONDITION TMP_39""];
4->5[label=""True""];
4->9[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_amount)

IRs:
REF_7(uint256) -> balances[msg.sender]
REF_8(uint256) -> balances[msg.sender]
TMP_40(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_8', '_amount'] 
REF_7(uint256) (->balances) := TMP_40(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[_to] = balances[_to].add(_amount)

IRs:
REF_10(uint256) -> balances[_to]
REF_11(uint256) -> balances[_to]
TMP_41(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_11', '_amount'] 
REF_10(uint256) (->balances) := TMP_41(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(msg.sender,_to,_amount)

IRs:
Emit Transfer(msg.sender,_to,_amount)""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True""];
9[label=""Node Type: RETURN 9

EXPRESSION:
false

IRs:
RETURN False""];
11[label=""Node Type: IF 11

EXPRESSION:
lockupParticipants[msg.sender].lockType == LockupType.BLACK

IRs:
REF_13(BasicToken.Lockup) -> lockupParticipants[msg.sender]
REF_14(BasicToken.LockupType) -> REF_13.lockType
REF_15(BasicToken.LockupType) -> LockupType.BLACK
TMP_43(bool) = REF_14 == REF_15
CONDITION TMP_43""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: RETURN 12

EXPRESSION:
false

IRs:
RETURN False""];
13[label=""Node Type: IF 13

EXPRESSION:
lockupParticipants[msg.sender].lockupAmount > 0

IRs:
REF_16(BasicToken.Lockup) -> lockupParticipants[msg.sender]
REF_17(uint256) -> REF_16.lockupAmount
TMP_44(bool) = REF_17 > 0
CONDITION TMP_44""];
13->14[label=""True""];
13->22[label=""False""];
14[label=""Node Type: NEW VARIABLE 14

EXPRESSION:
timePassed = now - startTime

IRs:
TMP_45(uint256) = now - startTime
timePassed(uint256) := TMP_45(uint256)""];
14->15;
15[label=""Node Type: IF 15

EXPRESSION:
timePassed < lockupParticipants[msg.sender].lockupTime

IRs:
REF_18(BasicToken.Lockup) -> lockupParticipants[msg.sender]
REF_19(uint256) -> REF_18.lockupTime
TMP_46(bool) = timePassed < REF_19
CONDITION TMP_46""];
15->16[label=""True""];
15->17[label=""False""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
require(bool)(balances[msg.sender].sub(_amount) >= lockupParticipants[msg.sender].lockupAmount)

IRs:
REF_20(uint256) -> balances[msg.sender]
TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_20', '_amount'] 
REF_22(BasicToken.Lockup) -> lockupParticipants[msg.sender]
REF_23(uint256) -> REF_22.lockupAmount
TMP_48(bool) = TMP_47 >= REF_23
TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48)""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_amount)

IRs:
REF_24(uint256) -> balances[msg.sender]
REF_25(uint256) -> balances[msg.sender]
TMP_50(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_25', '_amount'] 
REF_24(uint256) (->balances) := TMP_50(uint256)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
balances[_to] = balances[_to].add(_amount)

IRs:
REF_27(uint256) -> balances[_to]
REF_28(uint256) -> balances[_to]
TMP_51(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_28', '_amount'] 
REF_27(uint256) (->balances) := TMP_51(uint256)""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
Transfer(msg.sender,_to,_amount)

IRs:
Emit Transfer(msg.sender,_to,_amount)""];
20->21;
21[label=""Node Type: RETURN 21

EXPRESSION:
true

IRs:
RETURN True""];
22[label=""Node Type: END_IF 22
""];
22->23;
23[label=""Node Type: END_IF 23
""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: RETURN 25

EXPRESSION:
false

IRs:
RETURN False""];
26[label=""Node Type: RETURN 26

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(_to != address(0));require(bool)(balances[msg.sender] >= _amount && _amount > 0 && balances[_to].add(_amount) > balances[_to]);! released;(lockupParticipants[msg.sender].lockType == LockupType.PARTNER) || (msg.sender == ownerWallet);lockupParticipants[msg.sender].lockType == LockupType.BLACK;balances[msg.sender] = balances[msg.sender].sub(_amount);false;balances[_to] = balances[_to].add(_amount);Transfer(msg.sender,_to,_amount);true;false;lockupParticipants[msg.sender].lockupAmount > 0;timePassed = now - startTime;;timePassed < lockupParticipants[msg.sender].lockupTime;require(bool)(balances[msg.sender].sub(_amount) >= lockupParticipants[msg.sender].lockupAmount);;balances[msg.sender] = balances[msg.sender].sub(_amount);balances[_to] = balances[_to].add(_amount);Transfer(msg.sender,_to,_amount);true;;;false;success"
./0x874d4a7a8bf2abda5489cdbd62bd785c23e5531f_ext.sol,token123.mintToken,50,55,"REF_1(uint256) -> balances[target],REF_1(-> balances) = REF_1 + mintedAmount,_totalSupply(uint256) = _totalSupply + mintedAmount,Emit Transfer(0,owner,mintedAmount),Emit Transfer(owner,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances[target] += mintedAmount

IRs:
REF_1(uint256) -> balances[target]
REF_1(-> balances) = REF_1 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_totalSupply += mintedAmount

IRs:
_totalSupply(uint256) = _totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0x0,owner,mintedAmount)

IRs:
Emit Transfer(0,owner,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(owner,target,mintedAmount)

IRs:
Emit Transfer(owner,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balances[target] += mintedAmount;_totalSupply += mintedAmount;Transfer(0x0,owner,mintedAmount);Transfer(owner,target,mintedAmount)"
./0x505d0c2061f124c0ae03f795c4aeddd7ff9d471e_ext.sol,StandardToken.transfer,45,56,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0xd76ababc8887a72453f5f48ea831b782e49c557a_ext.sol,PizzaCoin.mintToken,189,194,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x86c6a7ee4ec24d25456580d81f7e8f486186ec91_ext.sol,Coin.generateTokens,124,153,"TMP_26 = CONVERT this to address,REF_3(uint256) -> balances[TMP_26],TMP_27(uint256) = _amount - REF_3,de(uint256) := TMP_27(uint256),TMP_28(uint256) = _totalSupply + de,TMP_29(bool) = _maxSupply >= TMP_28,CONDITION TMP_29,TMP_30 = CONVERT this to address,TMP_31(bool) = _client == TMP_30,CONDITION TMP_31,TMP_32 = CONVERT this to address,REF_4(uint256) -> balances[TMP_32],REF_4(-> balances) = REF_4 + _amount,_totalSupply(uint256) = _totalSupply + _amount,TMP_33 = CONVERT this to address,REF_5(uint256) -> balances[TMP_33],TMP_34(bool) = REF_5 >= _amount,CONDITION TMP_34,TMP_35 = CONVERT this to address,TMP_36(bool) = INTERNAL_CALL, Coin.transferFrom(address,address,uint256)(TMP_35,_client,_amount),TMP_37 = CONVERT this to address,TMP_38 = CONVERT this to address,REF_6(uint256) -> balances[TMP_38],TMP_39(bool) = INTERNAL_CALL, Coin.transferFrom(address,address,uint256)(TMP_37,_client,REF_6),_totalSupply(uint256) = _totalSupply + de,REF_7(uint256) -> balances[_client],REF_7(-> balances) = REF_7 + de,Emit TokensSent(_client,_amount),RETURN True,RETURN False,MODIFIER_CALL, Coin.ownerAndCoin()(),MODIFIER_CALL, Coin.workingFlag()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->17;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
de = _amount - balances[address(this)]

IRs:
TMP_26 = CONVERT this to address
REF_3(uint256) -> balances[TMP_26]
TMP_27(uint256) = _amount - REF_3
de(uint256) := TMP_27(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
_maxSupply >= _totalSupply + de

IRs:
TMP_28(uint256) = _totalSupply + de
TMP_29(bool) = _maxSupply >= TMP_28
CONDITION TMP_29""];
2->3[label=""True""];
2->15[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
_client == address(this)

IRs:
TMP_30 = CONVERT this to address
TMP_31(bool) = _client == TMP_30
CONDITION TMP_31""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[address(this)] += _amount

IRs:
TMP_32 = CONVERT this to address
REF_4(uint256) -> balances[TMP_32]
REF_4(-> balances) = REF_4 + _amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_totalSupply += _amount

IRs:
_totalSupply(uint256) = _totalSupply + _amount""];
5->12;
6[label=""Node Type: IF 6

EXPRESSION:
balances[address(this)] >= _amount

IRs:
TMP_33 = CONVERT this to address
REF_5(uint256) -> balances[TMP_33]
TMP_34(bool) = REF_5 >= _amount
CONDITION TMP_34""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
transferFrom(address(this),_client,_amount)

IRs:
TMP_35 = CONVERT this to address
TMP_36(bool) = INTERNAL_CALL, Coin.transferFrom(address,address,uint256)(TMP_35,_client,_amount)""];
7->11;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
transferFrom(address(this),_client,balances[address(this)])

IRs:
TMP_37 = CONVERT this to address
TMP_38 = CONVERT this to address
REF_6(uint256) -> balances[TMP_38]
TMP_39(bool) = INTERNAL_CALL, Coin.transferFrom(address,address,uint256)(TMP_37,_client,REF_6)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
_totalSupply += de

IRs:
_totalSupply(uint256) = _totalSupply + de""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
balances[_client] += de

IRs:
REF_7(uint256) -> balances[_client]
REF_7(-> balances) = REF_7 + de""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
TokensSent(_client,_amount)

IRs:
Emit TokensSent(_client,_amount)""];
13->14;
14[label=""Node Type: RETURN 14

EXPRESSION:
true

IRs:
RETURN True""];
15[label=""Node Type: RETURN 15

EXPRESSION:
false

IRs:
RETURN False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
ownerAndCoin()

IRs:
MODIFIER_CALL, Coin.ownerAndCoin()()""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
workingFlag()

IRs:
MODIFIER_CALL, Coin.workingFlag()()""];
18->1;
19[label=""Node Type: RETURN 19

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"ownerAndCoin();de = _amount - balances[address(this)];_maxSupply >= _totalSupply + de;_client == address(this);false;balances[address(this)] += _amount;balances[address(this)] >= _amount;_totalSupply += _amount;;transferFrom(address(this),_client,_amount);transferFrom(address(this),_client,balances[address(this)]);;_totalSupply += de;balances[_client] += de;TokensSent(_client,_amount);true;workingFlag();success"
./0xd0bd12a8d5ebca1e2fa46da59f1993ec51c3d75c_ext.sol,BKToken.burnFrom,138,146,"REF_19(uint256) -> balanceOf[_from],TMP_22(bool) = REF_19 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_24(bool) = _value <= REF_21,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_22(bool) = REF_19 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_24(bool) = _value <= REF_21
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x03ab35f764b00c4dec653cc6ceac35a3efcd3482_ext.sol,TokenERC20.burn,64,70,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xf0cc17aa0ce1c6595e56c9c60b19c1c546ade50d_ext.sol,Vault.deposit,62,68,"TMP_30(bool) = msg.value > 0,CONDITION TMP_30,TMP_31(uint256) = INTERNAL_CALL, Vault.MinimumDeposit()(),TMP_32(bool) = msg.value >= TMP_31,CONDITION TMP_32,REF_6(uint256) -> Deposits[msg.sender],REF_6(-> Deposits) = REF_6 + msg.value,Emit Deposit(msg.sender,msg.value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value > 0

IRs:
TMP_30(bool) = msg.value > 0
CONDITION TMP_30""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
msg.value >= MinimumDeposit()

IRs:
TMP_31(uint256) = INTERNAL_CALL, Vault.MinimumDeposit()()
TMP_32(bool) = msg.value >= TMP_31
CONDITION TMP_32""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Deposits[msg.sender] += msg.value

IRs:
REF_6(uint256) -> Deposits[msg.sender]
REF_6(-> Deposits) = REF_6 + msg.value""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Deposit(msg.sender,msg.value)

IRs:
Emit Deposit(msg.sender,msg.value)""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,1,0,0,"msg.value > 0;msg.value >= MinimumDeposit();;Deposits[msg.sender] += msg.value;;Deposit(msg.sender,msg.value)"
./0x300a0a820d8fb6e77850da5eaa8df64bbff5746d_ext.sol,BoomrCoinCrowdsale.isCrowdsalePhase4,611,613,"TMP_230(uint256) = startTime + presaleDuration,TMP_231(uint256) = TMP_230 + crowdsaleDuration1,TMP_232(uint256) = TMP_231 + crowdsaleDuration2,TMP_233(uint256) = TMP_232 + crowdsaleDuration3,TMP_234(bool) = TMP_233 < now,TMP_235(uint256) = startTime + presaleDuration,TMP_236(uint256) = TMP_235 + crowdsaleDuration1,TMP_237(uint256) = TMP_236 + crowdsaleDuration2,TMP_238(uint256) = TMP_237 + crowdsaleDuration3,TMP_239(uint256) = TMP_238 + crowdsaleDuration4,TMP_240(bool) = TMP_239 >= now,TMP_241(bool) = TMP_234 && TMP_240,TMP_242(bool) = INTERNAL_CALL, BoomrCoinCrowdsale.maxGoalReached()(),TMP_243 = UnaryType.BANG TMP_242 ,TMP_244(bool) = TMP_241 && TMP_243,RETURN TMP_244","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
(startTime + presaleDuration + crowdsaleDuration1 + crowdsaleDuration2 + crowdsaleDuration3) < now && (startTime + presaleDuration + crowdsaleDuration1 + crowdsaleDuration2 + crowdsaleDuration3 + crowdsaleDuration4) >= now && ! maxGoalReached()

IRs:
TMP_230(uint256) = startTime + presaleDuration
TMP_231(uint256) = TMP_230 + crowdsaleDuration1
TMP_232(uint256) = TMP_231 + crowdsaleDuration2
TMP_233(uint256) = TMP_232 + crowdsaleDuration3
TMP_234(bool) = TMP_233 < now
TMP_235(uint256) = startTime + presaleDuration
TMP_236(uint256) = TMP_235 + crowdsaleDuration1
TMP_237(uint256) = TMP_236 + crowdsaleDuration2
TMP_238(uint256) = TMP_237 + crowdsaleDuration3
TMP_239(uint256) = TMP_238 + crowdsaleDuration4
TMP_240(bool) = TMP_239 >= now
TMP_241(bool) = TMP_234 && TMP_240
TMP_242(bool) = INTERNAL_CALL, BoomrCoinCrowdsale.maxGoalReached()()
TMP_243 = UnaryType.BANG TMP_242 
TMP_244(bool) = TMP_241 && TMP_243
RETURN TMP_244""];
}
",0,1,0,0,(startTime + presaleDuration + crowdsaleDuration1 + crowdsaleDuration2 + crowdsaleDuration3) < now && (startTime + presaleDuration + crowdsaleDuration1 + crowdsaleDuration2 + crowdsaleDuration3 + crowdsaleDuration4) >= now && ! maxGoalReached()
./0xec193241dc1ca3bbe3165de6d37a793585b4504e_ext.sol,TokenERC20.burn,284,296,"REF_16(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_16 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_17(uint256) -> balanceOf[msg.sender],REF_17(-> balanceOf) = REF_17 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_16(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_16 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
REF_17(-> balanceOf) = REF_17 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x7895a43ae537e8e1ac97006ea9235807eea04cfa_ext.sol,YunMint.freeze,704,714,"REF_158(uint256) -> balances[msg.sender],TMP_290(bool) = REF_158 >= _value,TMP_291(None) = SOLIDITY_CALL require(bool)(TMP_290),TMP_292(bool) = _unFrozenTime > createTime,TMP_293(None) = SOLIDITY_CALL require(bool)(TMP_292),TMP_294(bool) = _unFrozenTime > block.timestamp,TMP_295(None) = SOLIDITY_CALL require(bool)(TMP_294),REF_159(uint256) -> balances[msg.sender],REF_160(uint256) -> balances[msg.sender],TMP_296(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_160', '_value'] ,REF_159(uint256) (->balances) := TMP_296(uint256),REF_162(YunMint.FrozenBalance) -> frozenBalances[frozenBalanceCount],TMP_297(YunMint.FrozenBalance) = new FrozenBalance(msg.sender,_value,_unFrozenTime),REF_162(YunMint.FrozenBalance) (->frozenBalances) := TMP_297(YunMint.FrozenBalance),TMP_298(uint256) := frozenBalanceCount(uint256),frozenBalanceCount(uint256) = frozenBalanceCount + 1,Emit Freeze(msg.sender,_value,_unFrozenTime),RETURN True,MODIFIER_CALL, ReentrancyGuard.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_158(uint256) -> balances[msg.sender]
TMP_290(bool) = REF_158 >= _value
TMP_291(None) = SOLIDITY_CALL require(bool)(TMP_290)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_unFrozenTime > createTime)

IRs:
TMP_292(bool) = _unFrozenTime > createTime
TMP_293(None) = SOLIDITY_CALL require(bool)(TMP_292)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_unFrozenTime > block.timestamp)

IRs:
TMP_294(bool) = _unFrozenTime > block.timestamp
TMP_295(None) = SOLIDITY_CALL require(bool)(TMP_294)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_159(uint256) -> balances[msg.sender]
REF_160(uint256) -> balances[msg.sender]
TMP_296(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_160', '_value'] 
REF_159(uint256) (->balances) := TMP_296(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
frozenBalances[frozenBalanceCount] = FrozenBalance({owner:msg.sender,value:_value,unFrozenTime:_unFrozenTime})

IRs:
REF_162(YunMint.FrozenBalance) -> frozenBalances[frozenBalanceCount]
TMP_297(YunMint.FrozenBalance) = new FrozenBalance(msg.sender,_value,_unFrozenTime)
REF_162(YunMint.FrozenBalance) (->frozenBalances) := TMP_297(YunMint.FrozenBalance)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
frozenBalanceCount ++

IRs:
TMP_298(uint256) := frozenBalanceCount(uint256)
frozenBalanceCount(uint256) = frozenBalanceCount + 1""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Freeze(msg.sender,_value,_unFrozenTime)

IRs:
Emit Freeze(msg.sender,_value,_unFrozenTime)""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, ReentrancyGuard.nonReentrant()()""];
9->1;
}
",0,1,0,0,"nonReentrant();require(bool)(balances[msg.sender] >= _value);require(bool)(_unFrozenTime > createTime);require(bool)(_unFrozenTime > block.timestamp);balances[msg.sender] = balances[msg.sender].sub(_value);frozenBalances[frozenBalanceCount] = FrozenBalance({owner:msg.sender,value:_value,unFrozenTime:_unFrozenTime});frozenBalanceCount ++;Freeze(msg.sender,_value,_unFrozenTime);true"
./0x4b5cd619741838cb3442831c3f268a78b7df859a_ext.sol,CryptoPeopleName.setName,11,13,"REF_0(string) -> nameOfAddress[msg.sender],REF_0(string) (->nameOfAddress) := name(string)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
nameOfAddress[msg.sender] = name

IRs:
REF_0(string) -> nameOfAddress[msg.sender]
REF_0(string) (->nameOfAddress) := name(string)""];
}
",0,1,0,0,nameOfAddress[msg.sender] = name
./0x5b202f04786e6e9c0a689b1506af229f095d2d0e_ext.sol,BenziToken.approveAndCall,202,207,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xf226b12c03514571c5a473b2627f5528da46d263_ext.sol,ECRecovery.recover,25,53,"REF_0 -> LENGTH sig,TMP_0(bool) = REF_0 != 65,CONDITION TMP_0,TMP_1 = CONVERT 0 to address,RETURN TMP_1,TMP_2(bool) = v < 27,CONDITION TMP_2,v(uint8) = v + 27,TMP_3(bool) = v != 27,TMP_4(bool) = v != 28,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,TMP_6 = CONVERT 0 to address,RETURN TMP_6,TMP_7(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(hash,v,r,s),RETURN TMP_7","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: NEW VARIABLE 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
sig.length != 65

IRs:
REF_0 -> LENGTH sig
TMP_0(bool) = REF_0 != 65
CONDITION TMP_0""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: RETURN 5

EXPRESSION:
(address(0))

IRs:
TMP_1 = CONVERT 0 to address
RETURN TMP_1""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: INLINE ASM 7
""];
7->8;
8[label=""Node Type: END INLINE ASM 8
""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
v < 27

IRs:
TMP_2(bool) = v < 27
CONDITION TMP_2""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
v += 27

IRs:
v(uint8) = v + 27""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
v != 27 && v != 28

IRs:
TMP_3(bool) = v != 27
TMP_4(bool) = v != 28
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: RETURN 13

EXPRESSION:
(address(0))

IRs:
TMP_6 = CONVERT 0 to address
RETURN TMP_6""];
14[label=""Node Type: RETURN 14

EXPRESSION:
ecrecover(bytes32,uint8,bytes32,bytes32)(hash,v,r,s)

IRs:
TMP_7(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(hash,v,r,s)
RETURN TMP_7""];
}
",0,1,0,0,";;;sig.length != 65;(address(0));;;;v < 27;v += 27;;v != 27 && v != 28;(address(0));ecrecover(bytes32,uint8,bytes32,bytes32)(hash,v,r,s)"
./0x1f002ba292d85239fee400a04b21bb3aa4777461_ext.sol,FLTTToken.amountBurned,204,206,"TMP_41(uint256) = _initialSupply - _currentSupply,RETURN TMP_41,RETURN amountBurned","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_initialSupply - _currentSupply

IRs:
TMP_41(uint256) = _initialSupply - _currentSupply
RETURN TMP_41""];
2[label=""Node Type: RETURN 2

EXPRESSION:
amountBurned

IRs:
RETURN amountBurned""];
}
",0,1,0,0,_initialSupply - _currentSupply;amountBurned
./0xbfaacfdecfbbcc7ea8c17e19c8f4f84c523267de_ext.sol,NokuConsumptionPlan.addService,323,332,"TMP_96(bool) = INTERNAL_CALL, NokuConsumptionPlan.isService(bytes32)(_serviceName),TMP_97 = UnaryType.BANG TMP_96 ,TMP_98(None) = SOLIDITY_CALL require(bool,string)(TMP_97,_serviceName already present),REF_11(NokuConsumptionPlan.NokuService) -> services[_serviceName],REF_12(uint256) -> REF_11.serviceFee,REF_12(uint256) (->services) := _serviceFee(uint256),REF_13(NokuConsumptionPlan.NokuService) -> services[_serviceName],REF_14(uint256) -> REF_13.index,REF_16 -> LENGTH serviceIndex,TMP_101(uint256) := REF_16(uint256),TMP_102(uint256) = TMP_101 + 1,REF_16(uint256) (->serviceIndex) := TMP_102(uint256),REF_17(bytes32) -> serviceIndex[TMP_101],REF_17(bytes32) (->serviceIndex) := _serviceName(bytes32),TMP_100(None) = TMP_99 - 1,REF_14(uint256) (->services) := TMP_100(None),REF_18 -> LENGTH serviceIndex,TMP_103(uint256) = REF_18 - 1,Emit LogServiceAdded(_serviceName,TMP_103,_serviceFee),REF_19 -> LENGTH serviceIndex,TMP_105(uint256) = REF_19 - 1,RETURN TMP_105,MODIFIER_CALL, Ownable.onlyOwner()(),RETURN index","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(! isService(_serviceName),_serviceName already present)

IRs:
TMP_96(bool) = INTERNAL_CALL, NokuConsumptionPlan.isService(bytes32)(_serviceName)
TMP_97 = UnaryType.BANG TMP_96 
TMP_98(None) = SOLIDITY_CALL require(bool,string)(TMP_97,_serviceName already present)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
services[_serviceName].serviceFee = _serviceFee

IRs:
REF_11(NokuConsumptionPlan.NokuService) -> services[_serviceName]
REF_12(uint256) -> REF_11.serviceFee
REF_12(uint256) (->services) := _serviceFee(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
services[_serviceName].index = serviceIndex.push(_serviceName) - 1

IRs:
REF_13(NokuConsumptionPlan.NokuService) -> services[_serviceName]
REF_14(uint256) -> REF_13.index
REF_16 -> LENGTH serviceIndex
TMP_101(uint256) := REF_16(uint256)
TMP_102(uint256) = TMP_101 + 1
REF_16(uint256) (->serviceIndex) := TMP_102(uint256)
REF_17(bytes32) -> serviceIndex[TMP_101]
REF_17(bytes32) (->serviceIndex) := _serviceName(bytes32)
TMP_100(None) = TMP_99 - 1
REF_14(uint256) (->services) := TMP_100(None)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
LogServiceAdded(_serviceName,serviceIndex.length - 1,_serviceFee)

IRs:
REF_18 -> LENGTH serviceIndex
TMP_103(uint256) = REF_18 - 1
Emit LogServiceAdded(_serviceName,TMP_103,_serviceFee)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
serviceIndex.length - 1

IRs:
REF_19 -> LENGTH serviceIndex
TMP_105(uint256) = REF_19 - 1
RETURN TMP_105""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
7[label=""Node Type: RETURN 7

EXPRESSION:
index

IRs:
RETURN index""];
}
",0,1,0,0,"onlyOwner();require(bool,string)(! isService(_serviceName),_serviceName already present);services[_serviceName].serviceFee = _serviceFee;services[_serviceName].index = serviceIndex.push(_serviceName) - 1;LogServiceAdded(_serviceName,serviceIndex.length - 1,_serviceFee);serviceIndex.length - 1;index"
./0xd0b13c1195f1c50be0d3be956ff32aaebb48e1e4_ext.sol,FccToken.issue,149,160,"TMP_56(bool) = _value >= 0,TMP_57(None) = SOLIDITY_CALL require(bool)(TMP_56),REF_39(uint256) -> balances[_recipient],REF_39(-> balances) = REF_39 + _value,totalSupply(uint256) = totalSupply + _value,Emit Transfer(0,owner,_value),Emit Transfer(owner,_recipient,_value),RETURN True,MODIFIER_CALL, Owned.onlyICO()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value >= 0)

IRs:
TMP_56(bool) = _value >= 0
TMP_57(None) = SOLIDITY_CALL require(bool)(TMP_56)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_recipient] += _value

IRs:
REF_39(uint256) -> balances[_recipient]
REF_39(-> balances) = REF_39 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply += _value

IRs:
totalSupply(uint256) = totalSupply + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(0,owner,_value)

IRs:
Emit Transfer(0,owner,_value)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(owner,_recipient,_value)

IRs:
Emit Transfer(owner,_recipient,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyICO()

IRs:
MODIFIER_CALL, Owned.onlyICO()()""];
7->1;
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"onlyICO();require(bool)(_value >= 0);balances[_recipient] += _value;totalSupply += _value;Transfer(0,owner,_value);Transfer(owner,_recipient,_value);true;success"
./0xbd11eae443ef0e96c1cc565db5c0b51f6c829c0b_ext.sol,AENToken.burn,49,55,"REF_16(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_16 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_17(uint256) -> balanceOf[msg.sender],REF_17(-> balanceOf) = REF_17 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_16(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_16 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
REF_17(-> balanceOf) = REF_17 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xe2fe5e7e206e7b46cad6a5146320e5b4b9a18e97_ext.sol,metahashtoken.burn,121,130,"REF_18(uint256) -> balance[msg.sender],TMP_19(bool) = REF_18 <= _value,CONDITION TMP_19,TMP_20(None) = SOLIDITY_CALL revert()(),REF_19(uint256) -> balance[msg.sender],REF_19(-> balance) = REF_19 - _value,totalTokens(uint256) = totalTokens - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balance[msg.sender] <= _value

IRs:
REF_18(uint256) -> balance[msg.sender]
TMP_19(bool) = REF_18 <= _value
CONDITION TMP_19""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_20(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balance[msg.sender] -= _value

IRs:
REF_19(uint256) -> balance[msg.sender]
REF_19(-> balance) = REF_19 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalTokens -= _value

IRs:
totalTokens(uint256) = totalTokens - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balance[msg.sender] <= _value;revert()();;balance[msg.sender] -= _value;totalTokens -= _value;Burn(msg.sender,_value);true;success"
./0x369d0db2c7d56b095d758379b75f64085953528a_ext.sol,CryptoLeu.mintToken,251,256,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x333b63f5c455f381bc2a13b1b8aa7da31fd1fc02_ext.sol,SafeMath.getRandomNumber,22,25,"TMP_14(uint256) = block.number - 1,TMP_15(uint256) = SOLIDITY_CALL blockhash(uint256)(TMP_14),TMP_16 = CONVERT TMP_15 to uint256,TMP_17 = CONVERT privateAddress to uint256,TMP_18(uint256) = TMP_16 + TMP_17,genNum(uint256) := TMP_18(uint256),TMP_19(uint16) = maxRandom - min,TMP_20(uint16) = TMP_19 + 1,TMP_21(uint256) = genNum % TMP_20,TMP_22(uint256) = TMP_21 + min,TMP_23 = CONVERT TMP_22 to uint8,RETURN TMP_23","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
genNum = uint256(block.blockhash(block.number - 1)) + uint256(privateAddress)

IRs:
TMP_14(uint256) = block.number - 1
TMP_15(uint256) = SOLIDITY_CALL blockhash(uint256)(TMP_14)
TMP_16 = CONVERT TMP_15 to uint256
TMP_17 = CONVERT privateAddress to uint256
TMP_18(uint256) = TMP_16 + TMP_17
genNum(uint256) := TMP_18(uint256)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
uint8(genNum % (maxRandom - min + 1) + min)

IRs:
TMP_19(uint16) = maxRandom - min
TMP_20(uint16) = TMP_19 + 1
TMP_21(uint256) = genNum % TMP_20
TMP_22(uint256) = TMP_21 + min
TMP_23 = CONVERT TMP_22 to uint8
RETURN TMP_23""];
}
",0,1,0,0,genNum = uint256(block.blockhash(block.number - 1)) + uint256(privateAddress);uint8(genNum % (maxRandom - min + 1) + min)
./0xf19903d8e5b7d604b62d2a210b39ba9e1e1f93ef_ext.sol,STASHToken.fallback,118,132,"TMP_42(uint256) = totalEthInWei + msg.value,totalEthInWei(uint256) := TMP_42(uint256),TMP_43(uint256) = msg.value * unitsOneEthCanBuy,amount(uint256) := TMP_43(uint256),REF_24(uint256) -> balances[fundsWallet],TMP_44(bool) = REF_24 < amount,CONDITION TMP_44,REF_25(uint256) -> balances[fundsWallet],REF_26(uint256) -> balances[fundsWallet],TMP_45(uint256) = REF_26 - amount,REF_25(uint256) (->balances) := TMP_45(uint256),REF_27(uint256) -> balances[msg.sender],REF_28(uint256) -> balances[msg.sender],TMP_46(uint256) = REF_28 + amount,REF_27(uint256) (->balances) := TMP_46(uint256),Emit Transfer(fundsWallet,msg.sender,amount),Transfer dest:fundsWallet value:msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
totalEthInWei = totalEthInWei + msg.value

IRs:
TMP_42(uint256) = totalEthInWei + msg.value
totalEthInWei(uint256) := TMP_42(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = msg.value * unitsOneEthCanBuy

IRs:
TMP_43(uint256) = msg.value * unitsOneEthCanBuy
amount(uint256) := TMP_43(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
balances[fundsWallet] < amount

IRs:
REF_24(uint256) -> balances[fundsWallet]
TMP_44(bool) = REF_24 < amount
CONDITION TMP_44""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: RETURN 4
""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[fundsWallet] = balances[fundsWallet] - amount

IRs:
REF_25(uint256) -> balances[fundsWallet]
REF_26(uint256) -> balances[fundsWallet]
TMP_45(uint256) = REF_26 - amount
REF_25(uint256) (->balances) := TMP_45(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[msg.sender] = balances[msg.sender] + amount

IRs:
REF_27(uint256) -> balances[msg.sender]
REF_28(uint256) -> balances[msg.sender]
TMP_46(uint256) = REF_28 + amount
REF_27(uint256) (->balances) := TMP_46(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(fundsWallet,msg.sender,amount)

IRs:
Emit Transfer(fundsWallet,msg.sender,amount)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
fundsWallet.transfer(msg.value)

IRs:
Transfer dest:fundsWallet value:msg.value""];
}
",0,1,0,0,"totalEthInWei = totalEthInWei + msg.value;amount = msg.value * unitsOneEthCanBuy;balances[fundsWallet] < amount;;;balances[fundsWallet] = balances[fundsWallet] - amount;balances[msg.sender] = balances[msg.sender] + amount;Transfer(fundsWallet,msg.sender,amount);fundsWallet.transfer(msg.value)"
./0x0dc35ce59014aed7babc16ef0831580a2327e697_ext.sol,PlatformTeamCoinVer01.mintToken,207,212,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0xd86dc5e1574491b3c4b68a30f0084d630a9ecc94_ext.sol,Token.burn,121,127,"REF_17(uint256) -> balanceOf[msg.sender],TMP_23(bool) = REF_17 >= _value,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_23(bool) = REF_17 >= _value
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x729e895e186b7fbd34485d496415bb2f42629b71_ext.sol,RequestCore.areAllBalanceNull,983,995,"REF_116(RequestCore.Request) -> requests[_requestId],REF_117(RequestCore.Payee) -> REF_116.payee,REF_118(int256) -> REF_117.balance,TMP_282(bool) = REF_118 == 0,isNull(bool) := TMP_282(bool),i(uint8) := 0(uint256),REF_119(RequestCore.Payee[256]) -> subPayees[_requestId],REF_120(RequestCore.Payee) -> REF_119[i],REF_121(address) -> REF_120.addr,TMP_283 = CONVERT 0 to address,TMP_284(bool) = REF_121 != TMP_283,TMP_285(bool) = isNull && TMP_284,CONDITION TMP_285,REF_122(RequestCore.Payee[256]) -> subPayees[_requestId],REF_123(RequestCore.Payee) -> REF_122[i],REF_124(int256) -> REF_123.balance,TMP_286(bool) = REF_124 == 0,isNull(bool) := TMP_286(bool),TMP_287(uint8) = LIBRARY_CALL, dest:SafeMathUint8, function:SafeMathUint8.add(uint8,uint8), arguments:['i', '1'] ,i(uint8) := TMP_287(uint8),RETURN isNull,RETURN isNull","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
isNull = requests[_requestId].payee.balance == 0

IRs:
REF_116(RequestCore.Request) -> requests[_requestId]
REF_117(RequestCore.Payee) -> REF_116.payee
REF_118(int256) -> REF_117.balance
TMP_282(bool) = REF_118 == 0
isNull(bool) := TMP_282(bool)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
3->8;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
isNull && subPayees[_requestId][i].addr != address(0)

IRs:
REF_119(RequestCore.Payee[256]) -> subPayees[_requestId]
REF_120(RequestCore.Payee) -> REF_119[i]
REF_121(address) -> REF_120.addr
TMP_283 = CONVERT 0 to address
TMP_284(bool) = REF_121 != TMP_283
TMP_285(bool) = isNull && TMP_284
CONDITION TMP_285""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
isNull = subPayees[_requestId][i].balance == 0

IRs:
REF_122(RequestCore.Payee[256]) -> subPayees[_requestId]
REF_123(RequestCore.Payee) -> REF_122[i]
REF_124(int256) -> REF_123.balance
TMP_286(bool) = REF_124 == 0
isNull(bool) := TMP_286(bool)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
i = i.add(1)

IRs:
TMP_287(uint8) = LIBRARY_CALL, dest:SafeMathUint8, function:SafeMathUint8.add(uint8,uint8), arguments:['i', '1'] 
i(uint8) := TMP_287(uint8)""];
7->5;
8[label=""Node Type: RETURN 8

EXPRESSION:
isNull

IRs:
RETURN isNull""];
9[label=""Node Type: RETURN 9

EXPRESSION:
isNull

IRs:
RETURN isNull""];
}
",0,1,0,0,isNull = requests[_requestId].payee.balance == 0;i = 0;;isNull && subPayees[_requestId][i].addr != address(0);;isNull;isNull = subPayees[_requestId][i].balance == 0;i = i.add(1);isNull
./0x887ed27475f60f2df56fefc1f18f3aa8da65fb22_ext.sol,ParkCoin.burn,63,69,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x1be34bec23ef52fca1b5bb9ce27da1277ca4eebd_ext.sol,TokenERC20._transfer,53,78,"TMP_0(bool) = _to != 0,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_1(uint256) -> balanceOf[_from],TMP_2(bool) = REF_1 >= _value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[_to],TMP_4(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_5(bool) = TMP_4 >= REF_3,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),i(uint256) := 0(uint256),REF_4 -> LENGTH lockupTime,l(uint256) := REF_4(uint256),TMP_7(bool) = i < l,CONDITION TMP_7,REF_5(uint256) -> lockupTime[i],TMP_8(bool) = now < REF_5,CONDITION TMP_8,TMP_9(uint256) := i(uint256),i(uint256) = i + 1,TMP_10(bool) = _from != owner,CONDITION TMP_10,TMP_11(bool) = _value <= maxAmount,TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11),REF_6(uint256) -> balanceOf[_from],REF_7(uint256) -> balanceOf[_to],TMP_13(uint256) = REF_6 + REF_7,previousBalances(uint256) := TMP_13(uint256),REF_8(uint256) -> balanceOf[_from],REF_8(-> balanceOf) = REF_8 - _value,REF_9(uint256) -> balanceOf[_to],REF_9(-> balanceOf) = REF_9 + _value,Emit Transfer(_from,_to,_value),REF_10(uint256) -> balanceOf[_from],REF_11(uint256) -> balanceOf[_to],TMP_15(uint256) = REF_10 + REF_11,TMP_16(bool) = TMP_15 == previousBalances,TMP_17(None) = SOLIDITY_CALL assert(bool)(TMP_16),TMP_18(bool) = i < 1,CONDITION TMP_18,maxAmount(uint256) := 0(uint256),REF_12 -> LENGTH lockupPercent,TMP_19(bool) = i >= REF_12,CONDITION TMP_19,REF_13(uint256) -> balanceOf[_from],maxAmount(uint256) := REF_13(uint256),REF_14(uint8) -> lockupPercent[i],REF_15(uint256) -> balanceOf[_from],TMP_20(uint8) = REF_14 * REF_15,TMP_21(uint8) = TMP_20 / 100,maxAmount(uint256) := TMP_21(uint8)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_0(bool) = _to != 0
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_2(bool) = REF_1 >= _value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_4(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_5(bool) = TMP_4 >= REF_3
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->7;
5[label=""Node Type: BEGIN_LOOP 5
""];
5->8;
6[label=""Node Type: END_LOOP 6
""];
6->22;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
l = lockupTime.length

IRs:
REF_4 -> LENGTH lockupTime
l(uint256) := REF_4(uint256)""];
7->5;
8[label=""Node Type: IF_LOOP 8

EXPRESSION:
i < l

IRs:
TMP_7(bool) = i < l
CONDITION TMP_7""];
8->9[label=""True""];
8->6[label=""False""];
9[label=""Node Type: IF 9

EXPRESSION:
now < lockupTime[i]

IRs:
REF_5(uint256) -> lockupTime[i]
TMP_8(bool) = now < REF_5
CONDITION TMP_8""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: BREAK 10
""];
10->6;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_9(uint256) := i(uint256)
i(uint256) = i + 1""];
12->8;
14[label=""Node Type: IF 14

EXPRESSION:
_from != owner

IRs:
TMP_10(bool) = _from != owner
CONDITION TMP_10""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
require(bool)(_value <= maxAmount)

IRs:
TMP_11(bool) = _value <= maxAmount
TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: NEW VARIABLE 17

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_7(uint256) -> balanceOf[_to]
TMP_13(uint256) = REF_6 + REF_7
previousBalances(uint256) := TMP_13(uint256)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_8(-> balanceOf) = REF_8 - _value""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_9(uint256) -> balanceOf[_to]
REF_9(-> balanceOf) = REF_9 + _value""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_10(uint256) -> balanceOf[_from]
REF_11(uint256) -> balanceOf[_to]
TMP_15(uint256) = REF_10 + REF_11
TMP_16(bool) = TMP_15 == previousBalances
TMP_17(None) = SOLIDITY_CALL assert(bool)(TMP_16)""];
22[label=""Node Type: IF 22

EXPRESSION:
(i < 1)

IRs:
TMP_18(bool) = i < 1
CONDITION TMP_18""];
22->23[label=""True""];
22->26[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
maxAmount = 0

IRs:
maxAmount(uint256) := 0(uint256)""];
23->25;
25[label=""Node Type: END_IF 25
""];
25->14;
26[label=""Node Type: IF 26

EXPRESSION:
(i >= lockupPercent.length)

IRs:
REF_12 -> LENGTH lockupPercent
TMP_19(bool) = i >= REF_12
CONDITION TMP_19""];
26->27[label=""True""];
26->28[label=""False""];
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
maxAmount = balanceOf[_from]

IRs:
REF_13(uint256) -> balanceOf[_from]
maxAmount(uint256) := REF_13(uint256)""];
27->29;
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
maxAmount = (lockupPercent[i] * balanceOf[_from] / 100)

IRs:
REF_14(uint8) -> lockupPercent[i]
REF_15(uint256) -> balanceOf[_from]
TMP_20(uint8) = REF_14 * REF_15
TMP_21(uint8) = TMP_20 / 100
maxAmount(uint256) := TMP_21(uint8)""];
28->29;
29[label=""Node Type: END_IF 29
""];
29->25;
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);i = 0;l = lockupTime.length;;i < l;;(i < 1);now < lockupTime[i];;;i ++;_from != owner;require(bool)(_value <= maxAmount);;previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances);maxAmount = 0;(i >= lockupPercent.length);;maxAmount = balanceOf[_from];maxAmount = (lockupPercent[i] * balanceOf[_from] / 100);"
./0xedf7eac72ff28dbcde6aa14322726a7d05739007_ext.sol,EasyInvest20.fallback,29,44,"REF_0(uint256) -> invested[msg.sender],TMP_0(bool) = REF_0 != 0,CONDITION TMP_0,REF_1(uint256) -> invested[msg.sender],TMP_1(uint256) = REF_1 * 20,TMP_2(uint256) = TMP_1 / 100,REF_2(uint256) -> atBlock[msg.sender],TMP_3(uint256) = block.number - REF_2,TMP_4(uint256) = TMP_2 * TMP_3,TMP_5(uint256) = TMP_4 / 5900,amount(uint256) := TMP_5(uint256),Transfer dest:msg.sender value:amount,REF_4(uint256) -> atBlock[msg.sender],REF_4(uint256) (->atBlock) := block.number(uint256),REF_5(uint256) -> invested[msg.sender],REF_5(-> invested) = REF_5 + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
invested[msg.sender] != 0

IRs:
REF_0(uint256) -> invested[msg.sender]
TMP_0(bool) = REF_0 != 0
CONDITION TMP_0""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = invested[msg.sender] * 20 / 100 * (block.number - atBlock[msg.sender]) / 5900

IRs:
REF_1(uint256) -> invested[msg.sender]
TMP_1(uint256) = REF_1 * 20
TMP_2(uint256) = TMP_1 / 100
REF_2(uint256) -> atBlock[msg.sender]
TMP_3(uint256) = block.number - REF_2
TMP_4(uint256) = TMP_2 * TMP_3
TMP_5(uint256) = TMP_4 / 5900
amount(uint256) := TMP_5(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
atBlock[msg.sender] = block.number

IRs:
REF_4(uint256) -> atBlock[msg.sender]
REF_4(uint256) (->atBlock) := block.number(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
invested[msg.sender] += msg.value

IRs:
REF_5(uint256) -> invested[msg.sender]
REF_5(-> invested) = REF_5 + msg.value""];
}
",0,1,0,0,invested[msg.sender] != 0;amount = invested[msg.sender] * 20 / 100 * (block.number - atBlock[msg.sender]) / 5900;;msg.sender.transfer(amount);atBlock[msg.sender] = block.number;invested[msg.sender] += msg.value
./0x57deefef435a069d95a1523ae8955c993b2b1201_ext.sol,pennyCoin.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xed51040da497901107870ece117f9ed8df4f4e52_ext.sol,TokenERC20.burnFrom,159,167,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x696be206174bea69e7a00b4deb1c6fddfa4786c9_ext.sol,RAZEN.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x186b32c1b89db762a8ffa317172a4926714e6336_ext.sol,TokenERC20.burnFrom,146,154,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x55e539fb53394851e8c541411d31c942b14b998e_ext.sol,URUGUAY_WINS.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x180d669e995ae5fbb7bfb06107546de625cd4f97_ext.sol,BallzToken.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x326ce88b27c196d0387f5df7ae085c1203185cb4_ext.sol,LoliCoin.mintToken,200,205,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x5438b0938fb88a979032f45b87d2d1aeffe5cc28_ext.sol,Gifto.fallback,118,129,"REF_0(uint256) -> deposit[msg.sender],TMP_0(bool) = REF_0 == 0,TMP_1(bool) = msg.value != 0,TMP_2(bool) = TMP_0 && TMP_1,CONDITION TMP_2,REF_2 -> LENGTH buyers,TMP_4(uint256) := REF_2(uint256),TMP_5(uint256) = TMP_4 + 1,REF_2(uint256) (->buyers) := TMP_5(uint256),REF_3(address) -> buyers[TMP_4],REF_3(address) (->buyers) := msg.sender(address),REF_4(uint256) -> deposit[msg.sender],REF_4(-> deposit) = REF_4 + msg.value,MODIFIER_CALL, Gifto.validValue()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
deposit[msg.sender] == 0 && msg.value != 0

IRs:
REF_0(uint256) -> deposit[msg.sender]
TMP_0(bool) = REF_0 == 0
TMP_1(bool) = msg.value != 0
TMP_2(bool) = TMP_0 && TMP_1
CONDITION TMP_2""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
buyers.push(msg.sender)

IRs:
REF_2 -> LENGTH buyers
TMP_4(uint256) := REF_2(uint256)
TMP_5(uint256) = TMP_4 + 1
REF_2(uint256) (->buyers) := TMP_5(uint256)
REF_3(address) -> buyers[TMP_4]
REF_3(address) (->buyers) := msg.sender(address)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
deposit[msg.sender] += msg.value

IRs:
REF_4(uint256) -> deposit[msg.sender]
REF_4(-> deposit) = REF_4 + msg.value""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
validValue()

IRs:
MODIFIER_CALL, Gifto.validValue()()""];
5->1;
}
",0,1,0,0,validValue();deposit[msg.sender] == 0 && msg.value != 0;buyers.push(msg.sender);;deposit[msg.sender] += msg.value
./0x7038c15f76ad2667837c438c8819fd969899cdbe_ext.sol,Airdrop.drop,8,12,"i(uint256) := 0(uint256),REF_0 -> LENGTH recipients,TMP_0(bool) = i < REF_0,CONDITION TMP_0,REF_2(address) -> recipients[i],REF_3(uint256) -> values[i],TMP_1(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['REF_2', 'REF_3']  ,TMP_2(uint256) := i(uint256),i(uint256) = i + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < recipients.length

IRs:
REF_0 -> LENGTH recipients
TMP_0(bool) = i < REF_0
CONDITION TMP_0""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
token.transfer(recipients[i],values[i])

IRs:
REF_2(address) -> recipients[i]
REF_3(uint256) -> values[i]
TMP_1(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['REF_2', 'REF_3']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_2(uint256) := i(uint256)
i(uint256) = i + 1""];
6->4;
}
",0,1,0,0,"i = 0;;i < recipients.length;;token.transfer(recipients[i],values[i]);i ++"
./0x0f00c8dd21da51bc6a6ac07f491a7dbe69746f16_ext.sol,ClapClapToken.approveAndCall,197,202,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x558c62533def5e9d77a7e555490c0e2889eacf3a_ext.sol,UTokenContract.UTTotalSupply,112,114,"TMP_16(uint256) = totalSupply - totalRemainSupply,RETURN TMP_16","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
totalSupply - totalRemainSupply

IRs:
TMP_16(uint256) = totalSupply - totalRemainSupply
RETURN TMP_16""];
}
",0,1,0,0,totalSupply - totalRemainSupply
./0x458c1987ba7cb7cd101cea17c4dfc0244ed7bd37_ext.sol,HOPE.burn,126,132,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x33c1aa1014e4ffd61c312671a42ecff8aef6201f_ext.sol,IndividualLockableToken.decreaseLockBalance,629,641,"TMP_310 = CONVERT 0 to address,TMP_311(bool) = _holder != TMP_310,TMP_312(None) = SOLIDITY_CALL require(bool)(TMP_311),TMP_313(bool) = _value > 0,TMP_314(None) = SOLIDITY_CALL require(bool)(TMP_313),REF_194(IndividualLockableToken.lockState) -> userLock[_holder],REF_195(uint256) -> REF_194.locked_balance,TMP_315(bool) = REF_195 >= _value,TMP_316(None) = SOLIDITY_CALL require(bool)(TMP_315),REF_196(IndividualLockableToken.lockState) -> userLock[_holder],REF_197(uint256) -> REF_196.locked_balance,REF_198(IndividualLockableToken.lockState) -> userLock[_holder],REF_199(uint256) -> REF_198.locked_balance,TMP_317(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_199', '_value'] ,REF_197(uint256) (->userLock) := TMP_317(uint256),REF_201(IndividualLockableToken.lockState) -> userLock[_holder],REF_202(uint256) -> REF_201.locked_balance,REF_203(IndividualLockableToken.lockState) -> userLock[_holder],REF_204(uint256) -> REF_203.release_time,Emit Locked(_holder,_value,REF_202,REF_204),RETURN True,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_holder != address(0))

IRs:
TMP_310 = CONVERT 0 to address
TMP_311(bool) = _holder != TMP_310
TMP_312(None) = SOLIDITY_CALL require(bool)(TMP_311)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_313(bool) = _value > 0
TMP_314(None) = SOLIDITY_CALL require(bool)(TMP_313)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(userLock[_holder].locked_balance >= _value)

IRs:
REF_194(IndividualLockableToken.lockState) -> userLock[_holder]
REF_195(uint256) -> REF_194.locked_balance
TMP_315(bool) = REF_195 >= _value
TMP_316(None) = SOLIDITY_CALL require(bool)(TMP_315)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
userLock[_holder].locked_balance = (userLock[_holder].locked_balance).sub(_value)

IRs:
REF_196(IndividualLockableToken.lockState) -> userLock[_holder]
REF_197(uint256) -> REF_196.locked_balance
REF_198(IndividualLockableToken.lockState) -> userLock[_holder]
REF_199(uint256) -> REF_198.locked_balance
TMP_317(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_199', '_value'] 
REF_197(uint256) (->userLock) := TMP_317(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Locked(_holder,_value,userLock[_holder].locked_balance,userLock[_holder].release_time)

IRs:
REF_201(IndividualLockableToken.lockState) -> userLock[_holder]
REF_202(uint256) -> REF_201.locked_balance
REF_203(IndividualLockableToken.lockState) -> userLock[_holder]
REF_204(uint256) -> REF_203.release_time
Emit Locked(_holder,_value,REF_202,REF_204)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->1;
}
",0,1,0,0,"onlyOwner();require(bool)(_holder != address(0));require(bool)(_value > 0);require(bool)(userLock[_holder].locked_balance >= _value);userLock[_holder].locked_balance = (userLock[_holder].locked_balance).sub(_value);Locked(_holder,_value,userLock[_holder].locked_balance,userLock[_holder].release_time);true"
./0x6c940a8d477922f1cffe012449321098e06db3f7_ext.sol,CryptoGain.search_winner_bid_address,99,119,"TMP_32(bool) = slot < 128,CONDITION TMP_32,i(uint8) := 0(uint256),REF_8 -> LENGTH bids,TMP_33(bool) = i < REF_8,CONDITION TMP_33,REF_9(CryptoGain.Bid) -> bids[i],REF_10(uint8) -> REF_9.slot_from,REF_11(CryptoGain.Bid) -> bids[i],REF_12(uint8) -> REF_11.slot_to,TMP_34(bool) = INTERNAL_CALL, CryptoGain.is_slot_in_bid(uint8,uint8,uint8)(REF_10,REF_12,slot),CONDITION TMP_34,REF_13(CryptoGain.Bid) -> bids[i],REF_14(address) -> REF_13.player,RETURN REF_14,TMP_35(uint8) := i(uint8),i(uint8) = i + 1,REF_15 -> LENGTH bids,TMP_36 = CONVERT REF_15 to uint8,TMP_37(uint8) = TMP_36 - 1,i(uint8) := TMP_37(uint8),TMP_38(bool) = i >= 0,CONDITION TMP_38,REF_16(CryptoGain.Bid) -> bids[i],REF_17(uint8) -> REF_16.slot_from,REF_18(CryptoGain.Bid) -> bids[i],REF_19(uint8) -> REF_18.slot_to,TMP_39(bool) = INTERNAL_CALL, CryptoGain.is_slot_in_bid(uint8,uint8,uint8)(REF_17,REF_19,slot),CONDITION TMP_39,REF_20(CryptoGain.Bid) -> bids[i],REF_21(address) -> REF_20.player,RETURN REF_21,TMP_40(uint8) := i(uint8),i(uint8) = i - 1,TMP_41(None) = SOLIDITY_CALL assert(bool)(False)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
slot < 128

IRs:
TMP_32(bool) = slot < 128
CONDITION TMP_32""];
2->5[label=""True""];
2->13[label=""False""];
3[label=""Node Type: BEGIN_LOOP 3
""];
3->6;
4[label=""Node Type: END_LOOP 4
""];
4->19;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)""];
5->3;
6[label=""Node Type: IF_LOOP 6

EXPRESSION:
i < bids.length

IRs:
REF_8 -> LENGTH bids
TMP_33(bool) = i < REF_8
CONDITION TMP_33""];
6->7[label=""True""];
6->4[label=""False""];
7[label=""Node Type: IF 7

EXPRESSION:
is_slot_in_bid(bids[i].slot_from,bids[i].slot_to,slot)

IRs:
REF_9(CryptoGain.Bid) -> bids[i]
REF_10(uint8) -> REF_9.slot_from
REF_11(CryptoGain.Bid) -> bids[i]
REF_12(uint8) -> REF_11.slot_to
TMP_34(bool) = INTERNAL_CALL, CryptoGain.is_slot_in_bid(uint8,uint8,uint8)(REF_10,REF_12,slot)
CONDITION TMP_34""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: RETURN 8

EXPRESSION:
bids[i].player

IRs:
REF_13(CryptoGain.Bid) -> bids[i]
REF_14(address) -> REF_13.player
RETURN REF_14""];
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
i ++

IRs:
TMP_35(uint8) := i(uint8)
i(uint8) = i + 1""];
10->6;
11[label=""Node Type: BEGIN_LOOP 11
""];
11->14;
12[label=""Node Type: END_LOOP 12
""];
12->19;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
i = uint8(bids.length) - 1

IRs:
REF_15 -> LENGTH bids
TMP_36 = CONVERT REF_15 to uint8
TMP_37(uint8) = TMP_36 - 1
i(uint8) := TMP_37(uint8)""];
13->11;
14[label=""Node Type: IF_LOOP 14

EXPRESSION:
i >= 0

IRs:
TMP_38(bool) = i >= 0
CONDITION TMP_38""];
14->15[label=""True""];
14->12[label=""False""];
15[label=""Node Type: IF 15

EXPRESSION:
is_slot_in_bid(bids[i].slot_from,bids[i].slot_to,slot)

IRs:
REF_16(CryptoGain.Bid) -> bids[i]
REF_17(uint8) -> REF_16.slot_from
REF_18(CryptoGain.Bid) -> bids[i]
REF_19(uint8) -> REF_18.slot_to
TMP_39(bool) = INTERNAL_CALL, CryptoGain.is_slot_in_bid(uint8,uint8,uint8)(REF_17,REF_19,slot)
CONDITION TMP_39""];
15->16[label=""True""];
15->17[label=""False""];
16[label=""Node Type: RETURN 16

EXPRESSION:
bids[i].player

IRs:
REF_20(CryptoGain.Bid) -> bids[i]
REF_21(address) -> REF_20.player
RETURN REF_21""];
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
i --

IRs:
TMP_40(uint8) := i(uint8)
i(uint8) = i - 1""];
18->14;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
assert(bool)(false)

IRs:
TMP_41(None) = SOLIDITY_CALL assert(bool)(False)""];
}
",0,1,0,0,";slot < 128;i = 0;i = uint8(bids.length) - 1;;i < bids.length;;;is_slot_in_bid(bids[i].slot_from,bids[i].slot_to,slot);bids[i].player;;i ++;;i >= 0;;is_slot_in_bid(bids[i].slot_from,bids[i].slot_to,slot);bids[i].player;;i --;assert(bool)(false)"
./0x749dab228c71e650addba8c9875b842ad460a3c2_ext.sol,KyberContributorWhitelist.listAddresses,60,65,"REF_1 -> LENGTH _users,REF_2 -> LENGTH _cap,TMP_10(bool) = REF_1 == REF_2,TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10),i(uint256) := 0(uint256),REF_3 -> LENGTH _users,TMP_12(bool) = i < REF_3,CONDITION TMP_12,REF_4(address) -> _users[i],REF_5(uint256) -> _cap[i],INTERNAL_CALL, KyberContributorWhitelist.listAddress(address,uint256)(REF_4,REF_5),TMP_14(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_users.length == _cap.length)

IRs:
REF_1 -> LENGTH _users
REF_2 -> LENGTH _cap
TMP_10(bool) = REF_1 == REF_2
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < _users.length

IRs:
REF_3 -> LENGTH _users
TMP_12(bool) = i < REF_3
CONDITION TMP_12""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
listAddress(_users[i],_cap[i])

IRs:
REF_4(address) -> _users[i]
REF_5(uint256) -> _cap[i]
INTERNAL_CALL, KyberContributorWhitelist.listAddress(address,uint256)(REF_4,REF_5)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_14(uint256) := i(uint256)
i(uint256) = i + 1""];
7->5;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
8->1;
}
",0,1,0,0,"onlyOwner();require(bool)(_users.length == _cap.length);i = 0;;i < _users.length;;listAddress(_users[i],_cap[i]);i ++"
./0x0305b4ccbfd603d92ca0d5eae752000273e26a60_ext.sol,TokenERC20._transfer,45,61,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x1d840cb510f084e6154c85d14d98cdc8f7a3b4d5_ext.sol,DYLC_ERC20Token.approveAndCall,94,100,"TMP_21 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_21(tokenRecipient),TMP_22(bool) = INTERNAL_CALL, DYLC_ERC20Token.approve(address,uint256)(_spender,_value),CONDITION TMP_22,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_21 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_21(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_22(bool) = INTERNAL_CALL, DYLC_ERC20Token.approve(address,uint256)(_spender,_value)
CONDITION TMP_22""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x28f379afad653336d200eec34be7558be455fa5d_ext.sol,AIWEBToken.approveAndCall,209,214,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_60 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_60(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_60 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_60(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xf208c7a5682d3835a58dadce8e249453ebd0ec0b_ext.sol,FOIN._transfer,44,60,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xdd89d6ab3aca67ed697492ba4de2f2763490224b_ext.sol,NFTYToken.transferFrom,34,48,"TMP_10 = CONVERT this to address,TMP_11(bool) = to != TMP_10,TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11),TMP_13(bool) = to != 0,TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13),REF_4(mapping(address => uint256)) -> allowance[from],REF_5(uint256) -> REF_4[msg.sender],allowanceMsgSender(uint256) := REF_5(uint256),TMP_15(bool) = allowanceMsgSender >= amount,TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15),TMP_17(bool) = allowanceMsgSender != MAX_UINT,CONDITION TMP_17,REF_6(mapping(address => uint256)) -> allowance[from],REF_7(uint256) -> REF_6[msg.sender],TMP_18(uint256) = allowanceMsgSender - amount,REF_7(uint256) (->allowance) := TMP_18(uint256),REF_8(uint256) -> balanceOf[from],balanceOfFrom(uint256) := REF_8(uint256),TMP_19(bool) = balanceOfFrom >= amount,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_9(uint256) -> balanceOf[from],TMP_21(uint256) = balanceOfFrom - amount,REF_9(uint256) (->balanceOf) := TMP_21(uint256),REF_10(uint256) -> balanceOf[to],REF_10(-> balanceOf) = REF_10 + amount,Emit Transfer(from,to,amount),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(to != address(this))

IRs:
TMP_10 = CONVERT this to address
TMP_11(bool) = to != TMP_10
TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(to != 0)

IRs:
TMP_13(bool) = to != 0
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
allowanceMsgSender = allowance[from][msg.sender]

IRs:
REF_4(mapping(address => uint256)) -> allowance[from]
REF_5(uint256) -> REF_4[msg.sender]
allowanceMsgSender(uint256) := REF_5(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(allowanceMsgSender >= amount)

IRs:
TMP_15(bool) = allowanceMsgSender >= amount
TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
allowanceMsgSender != MAX_UINT

IRs:
TMP_17(bool) = allowanceMsgSender != MAX_UINT
CONDITION TMP_17""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allowance[from][msg.sender] = allowanceMsgSender - amount

IRs:
REF_6(mapping(address => uint256)) -> allowance[from]
REF_7(uint256) -> REF_6[msg.sender]
TMP_18(uint256) = allowanceMsgSender - amount
REF_7(uint256) (->allowance) := TMP_18(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
balanceOfFrom = balanceOf[from]

IRs:
REF_8(uint256) -> balanceOf[from]
balanceOfFrom(uint256) := REF_8(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(balanceOfFrom >= amount)

IRs:
TMP_19(bool) = balanceOfFrom >= amount
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
balanceOf[from] = balanceOfFrom - amount

IRs:
REF_9(uint256) -> balanceOf[from]
TMP_21(uint256) = balanceOfFrom - amount
REF_9(uint256) (->balanceOf) := TMP_21(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
balanceOf[to] += amount

IRs:
REF_10(uint256) -> balanceOf[to]
REF_10(-> balanceOf) = REF_10 + amount""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
Transfer(from,to,amount)

IRs:
Emit Transfer(from,to,amount)""];
12->13;
13[label=""Node Type: RETURN 13

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(to != address(this));require(bool)(to != 0);allowanceMsgSender = allowance[from][msg.sender];require(bool)(allowanceMsgSender >= amount);allowanceMsgSender != MAX_UINT;allowance[from][msg.sender] = allowanceMsgSender - amount;;balanceOfFrom = balanceOf[from];require(bool)(balanceOfFrom >= amount);balanceOf[from] = balanceOfFrom - amount;balanceOf[to] += amount;Transfer(from,to,amount);true"
./0x400c73395bbc01d9e757f02f267925e1de0779f8_ext.sol,TokenDrop.multiTransfer,34,40,"i(uint256) := 0(uint256),REF_0 -> LENGTH _to,TMP_1(bool) = i < REF_0,CONDITION TMP_1,REF_2(address) -> _to[i],TMP_2(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['REF_2', '_value']  ,TMP_3(uint256) := i(uint256),i(uint256) = i + 1,RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
2->7;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _to.length

IRs:
REF_0 -> LENGTH _to
TMP_1(bool) = i < REF_0
CONDITION TMP_1""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
token.transfer(_to[i],_value)

IRs:
REF_2(address) -> _to[i]
TMP_2(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['REF_2', '_value']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_3(uint256) := i(uint256)
i(uint256) = i + 1""];
6->4;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"i = 0;;i < _to.length;;true;token.transfer(_to[i],_value);i ++"
./0x71402645d25196842b0434a1805726b7c0eef426_ext.sol,BlueChips.buy,158,225,"TMP_4(bool) = _card < totalCards,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),TMP_6(bool) = now >= ACTIVATION_TIME,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_52(uint256) -> cardPrice[_card],TMP_8(bool) = msg.value >= REF_52,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_53(address) -> cardOwner[_card],TMP_10(bool) = msg.sender != REF_53,TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10),REF_54(uint256) -> cardPrice[_card],TMP_12(bool) = msg.value > REF_54,CONDITION TMP_12,REF_56(uint256) -> cardPrice[_card],TMP_13(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.value', 'REF_56'] ,_excess(uint256) := TMP_13(uint256),REF_57(uint256) -> ownerAccounts[msg.sender],REF_57(-> ownerAccounts) = REF_57 + _excess,REF_58(uint256) -> cardPrice[_card],REF_59(uint256) -> cardPreviousPrice[_card],INTERNAL_CALL, BlueChips.addtotalCardValue(uint256,uint256)(REF_58,REF_59),REF_62(uint256) -> cardPrice[_card],TMP_15(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_62', 'cardPriceIncrement'] ,TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_15', '100'] ,_newPrice(uint256) := TMP_16(uint256),REF_64(uint256) -> cardPrice[_card],REF_65(uint256) -> cardPreviousPrice[_card],TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_64', 'REF_65'] ,_baseDividends(uint256) := TMP_17(uint256),TMP_18(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalDivsProduced', '_baseDividends'] ,totalDivsProduced(uint256) := TMP_18(uint256),TMP_19(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_baseDividends', 'blueDivRate'] ,TMP_20(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_19', '100'] ,_blueDividends(uint256) := TMP_20(uint256),TMP_21(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_baseDividends', 'ownerDivRate'] ,TMP_22(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_21', '100'] ,_ownerDividends(uint256) := TMP_22(uint256),REF_71(uint256) -> totalCardDivs[_card],REF_73(uint256) -> totalCardDivs[_card],TMP_23(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_73', '_ownerDividends'] ,REF_71(uint256) (->totalCardDivs) := TMP_23(uint256),REF_75(uint256) -> cardPreviousPrice[_card],TMP_24(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_ownerDividends', 'REF_75'] ,_ownerDividends(uint256) := TMP_24(uint256),TMP_25(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_baseDividends', 'distDivRate'] ,TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_25', '100'] ,_distDividends(uint256) := TMP_26(uint256),TMP_27(bool) = _referrer != msg.sender,CONDITION TMP_27,TMP_28(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_baseDividends', 'referralRate'] ,TMP_29(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_28', '100'] ,_referralDividends(uint256) := TMP_29(uint256),TMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_distDividends', '_referralDividends'] ,_distDividends(uint256) := TMP_30(uint256),TMP_31(bool) = _referrer == 0,CONDITION TMP_31,Transfer dest:blueDividendAddr value:_referralDividends,REF_82(uint256) -> ownerAccounts[_referrer],REF_84(uint256) -> ownerAccounts[_referrer],TMP_33(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_84', '_referralDividends'] ,REF_82(uint256) (->ownerAccounts) := TMP_33(uint256),REF_85(address) -> cardOwner[_card],_previousOwner(address) := REF_85(address),_newOwner(address) := msg.sender(address),REF_86(uint256) -> ownerAccounts[_previousOwner],REF_88(uint256) -> ownerAccounts[_previousOwner],TMP_34(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_88', '_ownerDividends'] ,REF_86(uint256) (->ownerAccounts) := TMP_34(uint256),Transfer dest:blueDividendAddr value:_blueDividends,INTERNAL_CALL, BlueChips.distributeDivs(uint256)(_distDividends),REF_90(uint256) -> cardPreviousPrice[_card],REF_91(uint256) -> cardPrice[_card],REF_90(uint256) (->cardPreviousPrice) := REF_91(uint256),REF_92(uint256) -> cardPrice[_card],REF_92(uint256) (->cardPrice) := _newPrice(uint256),REF_93(address) -> cardOwner[_card],REF_93(address) (->cardOwner) := _newOwner(address),REF_94(uint256) -> cardPreviousPrice[_card],Emit oncardPurchase(msg.sender,REF_94,_card,_newPrice)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_card < totalCards)

IRs:
TMP_4(bool) = _card < totalCards
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(now >= ACTIVATION_TIME)

IRs:
TMP_6(bool) = now >= ACTIVATION_TIME
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(msg.value >= cardPrice[_card])

IRs:
REF_52(uint256) -> cardPrice[_card]
TMP_8(bool) = msg.value >= REF_52
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(msg.sender != cardOwner[_card])

IRs:
REF_53(address) -> cardOwner[_card]
TMP_10(bool) = msg.sender != REF_53
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
msg.value > cardPrice[_card]

IRs:
REF_54(uint256) -> cardPrice[_card]
TMP_12(bool) = msg.value > REF_54
CONDITION TMP_12""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
_excess = SafeMath.sub(msg.value,cardPrice[_card])

IRs:
REF_56(uint256) -> cardPrice[_card]
TMP_13(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.value', 'REF_56'] 
_excess(uint256) := TMP_13(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
ownerAccounts[msg.sender] += _excess

IRs:
REF_57(uint256) -> ownerAccounts[msg.sender]
REF_57(-> ownerAccounts) = REF_57 + _excess""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
addtotalCardValue(cardPrice[_card],cardPreviousPrice[_card])

IRs:
REF_58(uint256) -> cardPrice[_card]
REF_59(uint256) -> cardPreviousPrice[_card]
INTERNAL_CALL, BlueChips.addtotalCardValue(uint256,uint256)(REF_58,REF_59)""];
9->10;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
_newPrice = SafeMath.div(SafeMath.mul(cardPrice[_card],cardPriceIncrement),100)

IRs:
REF_62(uint256) -> cardPrice[_card]
TMP_15(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_62', 'cardPriceIncrement'] 
TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_15', '100'] 
_newPrice(uint256) := TMP_16(uint256)""];
10->11;
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
_baseDividends = SafeMath.sub(cardPrice[_card],cardPreviousPrice[_card])

IRs:
REF_64(uint256) -> cardPrice[_card]
REF_65(uint256) -> cardPreviousPrice[_card]
TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_64', 'REF_65'] 
_baseDividends(uint256) := TMP_17(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
totalDivsProduced = SafeMath.add(totalDivsProduced,_baseDividends)

IRs:
TMP_18(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalDivsProduced', '_baseDividends'] 
totalDivsProduced(uint256) := TMP_18(uint256)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
_blueDividends = SafeMath.div(SafeMath.mul(_baseDividends,blueDivRate),100)

IRs:
TMP_19(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_baseDividends', 'blueDivRate'] 
TMP_20(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_19', '100'] 
_blueDividends(uint256) := TMP_20(uint256)""];
13->14;
14[label=""Node Type: NEW VARIABLE 14

EXPRESSION:
_ownerDividends = SafeMath.div(SafeMath.mul(_baseDividends,ownerDivRate),100)

IRs:
TMP_21(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_baseDividends', 'ownerDivRate'] 
TMP_22(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_21', '100'] 
_ownerDividends(uint256) := TMP_22(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
totalCardDivs[_card] = SafeMath.add(totalCardDivs[_card],_ownerDividends)

IRs:
REF_71(uint256) -> totalCardDivs[_card]
REF_73(uint256) -> totalCardDivs[_card]
TMP_23(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_73', '_ownerDividends'] 
REF_71(uint256) (->totalCardDivs) := TMP_23(uint256)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
_ownerDividends = SafeMath.add(_ownerDividends,cardPreviousPrice[_card])

IRs:
REF_75(uint256) -> cardPreviousPrice[_card]
TMP_24(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_ownerDividends', 'REF_75'] 
_ownerDividends(uint256) := TMP_24(uint256)""];
16->17;
17[label=""Node Type: NEW VARIABLE 17

EXPRESSION:
_distDividends = SafeMath.div(SafeMath.mul(_baseDividends,distDivRate),100)

IRs:
TMP_25(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_baseDividends', 'distDivRate'] 
TMP_26(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_25', '100'] 
_distDividends(uint256) := TMP_26(uint256)""];
17->18;
18[label=""Node Type: IF 18

EXPRESSION:
_referrer != msg.sender

IRs:
TMP_27(bool) = _referrer != msg.sender
CONDITION TMP_27""];
18->19[label=""True""];
18->25[label=""False""];
19[label=""Node Type: NEW VARIABLE 19

EXPRESSION:
_referralDividends = SafeMath.div(SafeMath.mul(_baseDividends,referralRate),100)

IRs:
TMP_28(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_baseDividends', 'referralRate'] 
TMP_29(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_28', '100'] 
_referralDividends(uint256) := TMP_29(uint256)""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
_distDividends = SafeMath.sub(_distDividends,_referralDividends)

IRs:
TMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_distDividends', '_referralDividends'] 
_distDividends(uint256) := TMP_30(uint256)""];
20->21;
21[label=""Node Type: IF 21

EXPRESSION:
_referrer == 0x0

IRs:
TMP_31(bool) = _referrer == 0
CONDITION TMP_31""];
21->22[label=""True""];
21->23[label=""False""];
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
blueDividendAddr.transfer(_referralDividends)

IRs:
Transfer dest:blueDividendAddr value:_referralDividends""];
22->24;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
ownerAccounts[_referrer] = SafeMath.add(ownerAccounts[_referrer],_referralDividends)

IRs:
REF_82(uint256) -> ownerAccounts[_referrer]
REF_84(uint256) -> ownerAccounts[_referrer]
TMP_33(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_84', '_referralDividends'] 
REF_82(uint256) (->ownerAccounts) := TMP_33(uint256)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->26;
26[label=""Node Type: NEW VARIABLE 26

EXPRESSION:
_previousOwner = cardOwner[_card]

IRs:
REF_85(address) -> cardOwner[_card]
_previousOwner(address) := REF_85(address)""];
26->27;
27[label=""Node Type: NEW VARIABLE 27

EXPRESSION:
_newOwner = msg.sender

IRs:
_newOwner(address) := msg.sender(address)""];
27->28;
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
ownerAccounts[_previousOwner] = SafeMath.add(ownerAccounts[_previousOwner],_ownerDividends)

IRs:
REF_86(uint256) -> ownerAccounts[_previousOwner]
REF_88(uint256) -> ownerAccounts[_previousOwner]
TMP_34(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_88', '_ownerDividends'] 
REF_86(uint256) (->ownerAccounts) := TMP_34(uint256)""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
blueDividendAddr.transfer(_blueDividends)

IRs:
Transfer dest:blueDividendAddr value:_blueDividends""];
29->30;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
distributeDivs(_distDividends)

IRs:
INTERNAL_CALL, BlueChips.distributeDivs(uint256)(_distDividends)""];
30->31;
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
cardPreviousPrice[_card] = cardPrice[_card]

IRs:
REF_90(uint256) -> cardPreviousPrice[_card]
REF_91(uint256) -> cardPrice[_card]
REF_90(uint256) (->cardPreviousPrice) := REF_91(uint256)""];
31->32;
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
cardPrice[_card] = _newPrice

IRs:
REF_92(uint256) -> cardPrice[_card]
REF_92(uint256) (->cardPrice) := _newPrice(uint256)""];
32->33;
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
cardOwner[_card] = _newOwner

IRs:
REF_93(address) -> cardOwner[_card]
REF_93(address) (->cardOwner) := _newOwner(address)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
oncardPurchase(msg.sender,cardPreviousPrice[_card],_card,_newPrice)

IRs:
REF_94(uint256) -> cardPreviousPrice[_card]
Emit oncardPurchase(msg.sender,REF_94,_card,_newPrice)""];
}
",0,1,0,0,"require(bool)(_card < totalCards);require(bool)(now >= ACTIVATION_TIME);require(bool)(msg.value >= cardPrice[_card]);require(bool)(msg.sender != cardOwner[_card]);msg.value > cardPrice[_card];_excess = SafeMath.sub(msg.value,cardPrice[_card]);;ownerAccounts[msg.sender] += _excess;addtotalCardValue(cardPrice[_card],cardPreviousPrice[_card]);_newPrice = SafeMath.div(SafeMath.mul(cardPrice[_card],cardPriceIncrement),100);_baseDividends = SafeMath.sub(cardPrice[_card],cardPreviousPrice[_card]);totalDivsProduced = SafeMath.add(totalDivsProduced,_baseDividends);_blueDividends = SafeMath.div(SafeMath.mul(_baseDividends,blueDivRate),100);_ownerDividends = SafeMath.div(SafeMath.mul(_baseDividends,ownerDivRate),100);totalCardDivs[_card] = SafeMath.add(totalCardDivs[_card],_ownerDividends);_ownerDividends = SafeMath.add(_ownerDividends,cardPreviousPrice[_card]);_distDividends = SafeMath.div(SafeMath.mul(_baseDividends,distDivRate),100);_referrer != msg.sender;_referralDividends = SafeMath.div(SafeMath.mul(_baseDividends,referralRate),100);;_distDividends = SafeMath.sub(_distDividends,_referralDividends);_referrer == 0x0;blueDividendAddr.transfer(_referralDividends);ownerAccounts[_referrer] = SafeMath.add(ownerAccounts[_referrer],_referralDividends);;_previousOwner = cardOwner[_card];_newOwner = msg.sender;ownerAccounts[_previousOwner] = SafeMath.add(ownerAccounts[_previousOwner],_ownerDividends);blueDividendAddr.transfer(_blueDividends);distributeDivs(_distDividends);cardPreviousPrice[_card] = cardPrice[_card];cardPrice[_card] = _newPrice;cardOwner[_card] = _newOwner;oncardPurchase(msg.sender,cardPreviousPrice[_card],_card,_newPrice)"
./0x282c3971f8041bf4ab8b0d2ad0875e94958f8940_ext.sol,RENAULT_301201.transferFrom,42,54,"REF_6(uint256) -> balanceOf[from],TMP_6(bool) = value <= REF_6,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_7(mapping(address => uint256)) -> allowance[from],REF_8(uint256) -> REF_7[msg.sender],TMP_8(bool) = value <= REF_8,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_9(uint256) -> balanceOf[from],REF_9(-> balanceOf) = REF_9 - value,REF_10(uint256) -> balanceOf[to],REF_10(-> balanceOf) = REF_10 + value,REF_11(mapping(address => uint256)) -> allowance[from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowance) = REF_12 - value,Emit Transfer(from,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(value <= balanceOf[from])

IRs:
REF_6(uint256) -> balanceOf[from]
TMP_6(bool) = value <= REF_6
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value <= allowance[from][msg.sender])

IRs:
REF_7(mapping(address => uint256)) -> allowance[from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_8(bool) = value <= REF_8
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[from] -= value

IRs:
REF_9(uint256) -> balanceOf[from]
REF_9(-> balanceOf) = REF_9 - value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[to] += value

IRs:
REF_10(uint256) -> balanceOf[to]
REF_10(-> balanceOf) = REF_10 + value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allowance[from][msg.sender] -= value

IRs:
REF_11(mapping(address => uint256)) -> allowance[from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowance) = REF_12 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(value <= balanceOf[from]);require(bool)(value <= allowance[from][msg.sender]);balanceOf[from] -= value;balanceOf[to] += value;allowance[from][msg.sender] -= value;Transfer(from,to,value);true;success"
./0x1d7b14967d103df9dbc16d408616da18c4ae83eb_ext.sol,TokenERC20.burnFrom,180,188,"REF_22(uint256) -> balanceOf[_from],TMP_39(bool) = REF_22 >= _value,TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39),REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],TMP_41(bool) = _value <= REF_24,TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41),REF_25(uint256) -> balanceOf[_from],REF_25(-> balanceOf) = REF_25 - _value,REF_26(mapping(address => uint256)) -> allowance[_from],REF_27(uint256) -> REF_26[msg.sender],REF_27(-> allowance) = REF_27 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_22(uint256) -> balanceOf[_from]
TMP_39(bool) = REF_22 >= _value
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
TMP_41(bool) = _value <= REF_24
TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_25(uint256) -> balanceOf[_from]
REF_25(-> balanceOf) = REF_25 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_26(mapping(address => uint256)) -> allowance[_from]
REF_27(uint256) -> REF_26[msg.sender]
REF_27(-> allowance) = REF_27 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xed710216da4b1416a78768790ca9aa3633ca110f_ext.sol,PLAY_AND_GAIN.StartGame,11,21,"TMP_0(bool) = responseHash == 0,CONDITION TMP_0,TMP_1(bytes32) = SOLIDITY_CALL keccak256()(_response),responseHash(bytes32) := TMP_1(bytes32),question(string) := _question(string),questionSender(address) := msg.sender(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
responseHash == 0x0

IRs:
TMP_0(bool) = responseHash == 0
CONDITION TMP_0""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
responseHash = keccak256()(_response)

IRs:
TMP_1(bytes32) = SOLIDITY_CALL keccak256()(_response)
responseHash(bytes32) := TMP_1(bytes32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
questionSender = msg.sender

IRs:
questionSender(address) := msg.sender(address)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,1,0,0,responseHash == 0x0;responseHash = keccak256()(_response);;question = _question;questionSender = msg.sender
./0x7895a43ae537e8e1ac97006ea9235807eea04cfa_ext.sol,DateTime.toTimestamp,221,271,"TMP_91(uint256) = INTERNAL_CALL, DateTime.toTimestamp(uint16,uint8,uint8,uint8,uint8,uint8)(year,month,day,0,0,0),RETURN TMP_91,RETURN timestamp","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
toTimestamp(year,month,day,0,0,0)

IRs:
TMP_91(uint256) = INTERNAL_CALL, DateTime.toTimestamp(uint16,uint8,uint8,uint8,uint8,uint8)(year,month,day,0,0,0)
RETURN TMP_91""];
2[label=""Node Type: RETURN 2

EXPRESSION:
timestamp

IRs:
RETURN timestamp""];
}
",0,1,0,0,"toTimestamp(year,month,day,0,0,0);timestamp"
./0x570581a21edb40d399b6d2f407a86506c4b7d663_ext.sol,EVO2.dividendsOf,402,408,"REF_32(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_64(uint256) = profitPerShare_ * REF_32,TMP_65 = CONVERT TMP_64 to int256,REF_33(int256) -> payoutsTo_[_customerAddress],TMP_66(int256) = TMP_65 - REF_33,TMP_67 = CONVERT TMP_66 to uint256,TMP_68(uint256) = TMP_67 / magnitude,RETURN TMP_68","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_32(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_64(uint256) = profitPerShare_ * REF_32
TMP_65 = CONVERT TMP_64 to int256
REF_33(int256) -> payoutsTo_[_customerAddress]
TMP_66(int256) = TMP_65 - REF_33
TMP_67 = CONVERT TMP_66 to uint256
TMP_68(uint256) = TMP_67 / magnitude
RETURN TMP_68""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x6b963f7b38980f5fbbd129fe98059eb2144076a7_ext.sol,BLV.burn,124,130,"REF_17(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_17 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_17 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x556241b90b4c55457a31e27eb612bdc11815d989_ext.sol,NemixToken.burnFrom,140,148,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x37810173b70e86b8435f8c28590e8faceff59044_ext.sol,SatoMotive.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xd0a024e4b057024f941051dc19220a3bab4b5d45_ext.sol,RelexLife.burn,125,131,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x52e0ea6f341663ed806b9e80d0c2890a9e49c8d7_ext.sol,HajjERC20.burn,150,156,"REF_17(uint256) -> balanceOf[msg.sender],TMP_28(bool) = REF_17 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_28(bool) = REF_17 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x1eeeaffe28d463dcf2c1898d19cf3871e9a17d7c_ext.sol,MultiTransfer.MultiTransaction,64,69,"TMP_42 = CONVERT _tokenAddress to SNOVToken,token(SNOVToken) := TMP_42(SNOVToken),i(uint256) := 0(uint256),REF_34 -> LENGTH _addresses,TMP_43(bool) = i < REF_34,CONDITION TMP_43,REF_36(address) -> _addresses[i],REF_37(uint256) -> _values[i],TMP_44(bool) = HIGH_LEVEL_CALL, dest:token(SNOVToken), function:transfer, arguments:['REF_36', 'REF_37']  ,TMP_45(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, MultiOwnable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
token = SNOVToken(_tokenAddress)

IRs:
TMP_42 = CONVERT _tokenAddress to SNOVToken
token(SNOVToken) := TMP_42(SNOVToken)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < _addresses.length

IRs:
REF_34 -> LENGTH _addresses
TMP_43(bool) = i < REF_34
CONDITION TMP_43""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
token.transfer(_addresses[i],_values[i])

IRs:
REF_36(address) -> _addresses[i]
REF_37(uint256) -> _values[i]
TMP_44(bool) = HIGH_LEVEL_CALL, dest:token(SNOVToken), function:transfer, arguments:['REF_36', 'REF_37']  ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_45(uint256) := i(uint256)
i(uint256) = i + 1""];
7->5;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwnable.onlyOwner()()""];
8->1;
}
",0,1,0,0,"onlyOwner();token = SNOVToken(_tokenAddress);i = 0;;i < _addresses.length;;token.transfer(_addresses[i],_values[i]);i ++"
./0x72d2da71d6ea20c63a4f23b888ea70dc044f6800_ext.sol,TokenERC20._transfer,33,49,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x53c2159fa4690ccaa773086a137fb1cd17f65f35_ext.sol,SafeMath.getRandomNumber,73,76,"TMP_25(uint256) = block.number - 1,TMP_26(uint256) = SOLIDITY_CALL blockhash(uint256)(TMP_25),TMP_27 = CONVERT TMP_26 to uint256,TMP_28 = CONVERT privateAddress to uint256,TMP_29(uint256) = TMP_27 + TMP_28,genNum(uint256) := TMP_29(uint256),TMP_30(uint16) = maxRandom - min,TMP_31(uint16) = TMP_30 + 1,TMP_32(uint256) = genNum % TMP_31,TMP_33(uint256) = TMP_32 + min,TMP_34 = CONVERT TMP_33 to uint8,RETURN TMP_34","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
genNum = uint256(block.blockhash(block.number - 1)) + uint256(privateAddress)

IRs:
TMP_25(uint256) = block.number - 1
TMP_26(uint256) = SOLIDITY_CALL blockhash(uint256)(TMP_25)
TMP_27 = CONVERT TMP_26 to uint256
TMP_28 = CONVERT privateAddress to uint256
TMP_29(uint256) = TMP_27 + TMP_28
genNum(uint256) := TMP_29(uint256)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
uint8(genNum % (maxRandom - min + 1) + min)

IRs:
TMP_30(uint16) = maxRandom - min
TMP_31(uint16) = TMP_30 + 1
TMP_32(uint256) = genNum % TMP_31
TMP_33(uint256) = TMP_32 + min
TMP_34 = CONVERT TMP_33 to uint8
RETURN TMP_34""];
}
",0,1,0,0,genNum = uint256(block.blockhash(block.number - 1)) + uint256(privateAddress);uint8(genNum % (maxRandom - min + 1) + min)
./0xc4c06df5c799bec6ee6e4652beec86e5cfc94778_ext.sol,BTF.totalSupply,112,114,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x1c307a39511c16f74783fcd0091a921ec29a0b51_ext.sol,EthVerifyCore.approveUsers,37,41,"i(uint256) := 0(uint256),REF_4 -> LENGTH addresses,TMP_4(bool) = i < REF_4,CONDITION TMP_4,REF_5(address) -> addresses[i],REF_6(bool) -> verifiedUsers[REF_5],REF_6(bool) (->verifiedUsers) := True(bool),TMP_5(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, EthVerifyCore.onlyAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addresses.length

IRs:
REF_4 -> LENGTH addresses
TMP_4(bool) = i < REF_4
CONDITION TMP_4""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
verifiedUsers[addresses[i]] = true

IRs:
REF_5(address) -> addresses[i]
REF_6(bool) -> verifiedUsers[REF_5]
REF_6(bool) (->verifiedUsers) := True(bool)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_5(uint256) := i(uint256)
i(uint256) = i + 1""];
6->4;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, EthVerifyCore.onlyAdmin()()""];
7->3;
}
",0,1,0,0,onlyAdmin();;i < addresses.length;;i = 0;verifiedUsers[addresses[i]] = true;i ++
./0xaa5eb02bdaf93190922365f4e6326e1131dde3e4_ext.sol,PublicBatchTransfer.batchTransfer,115,128,"TMP_65(bool) = msg.value >= fee,TMP_66(None) = SOLIDITY_CALL require(bool)(TMP_65),TMP_67 = CONVERT 0 to address,TMP_68(bool) = tokenAddress != TMP_67,TMP_69(None) = SOLIDITY_CALL require(bool)(TMP_68),REF_5 -> LENGTH beneficiaries,TMP_70(bool) = REF_5 > 0,REF_6 -> LENGTH beneficiaries,REF_7 -> LENGTH tokenAmount,TMP_71(bool) = REF_6 == REF_7,TMP_72(bool) = TMP_70 && TMP_71,TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72),TMP_74 = CONVERT tokenAddress to ERC20,ERC20Contract(ERC20) := TMP_74(ERC20),i(uint256) := 0(uint256),REF_8 -> LENGTH beneficiaries,TMP_75(bool) = i < REF_8,CONDITION TMP_75,REF_10(address) -> beneficiaries[i],REF_11(uint256) -> tokenAmount[i],LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(ERC20,address,address,uint256), arguments:['ERC20Contract', 'msg.sender', 'REF_10', 'REF_11'] ,TMP_77(uint256) := i(uint256),i(uint256) = i + 1,TMP_78 = UnaryType.BANG keepEth ,CONDITION TMP_78,Transfer dest:wallet value:msg.value,RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= fee)

IRs:
TMP_65(bool) = msg.value >= fee
TMP_66(None) = SOLIDITY_CALL require(bool)(TMP_65)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(tokenAddress != address(0))

IRs:
TMP_67 = CONVERT 0 to address
TMP_68(bool) = tokenAddress != TMP_67
TMP_69(None) = SOLIDITY_CALL require(bool)(TMP_68)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(beneficiaries.length > 0 && beneficiaries.length == tokenAmount.length)

IRs:
REF_5 -> LENGTH beneficiaries
TMP_70(bool) = REF_5 > 0
REF_6 -> LENGTH beneficiaries
REF_7 -> LENGTH tokenAmount
TMP_71(bool) = REF_6 == REF_7
TMP_72(bool) = TMP_70 && TMP_71
TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
ERC20Contract = ERC20(tokenAddress)

IRs:
TMP_74 = CONVERT tokenAddress to ERC20
ERC20Contract(ERC20) := TMP_74(ERC20)""];
4->7;
5[label=""Node Type: BEGIN_LOOP 5
""];
5->8;
6[label=""Node Type: END_LOOP 6
""];
6->11;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
7->5;
8[label=""Node Type: IF_LOOP 8

EXPRESSION:
i < beneficiaries.length

IRs:
REF_8 -> LENGTH beneficiaries
TMP_75(bool) = i < REF_8
CONDITION TMP_75""];
8->9[label=""True""];
8->6[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
ERC20Contract.safeTransferFrom(msg.sender,beneficiaries[i],tokenAmount[i])

IRs:
REF_10(address) -> beneficiaries[i]
REF_11(uint256) -> tokenAmount[i]
LIBRARY_CALL, dest:SafeERC20, function:SafeERC20.safeTransferFrom(ERC20,address,address,uint256), arguments:['ERC20Contract', 'msg.sender', 'REF_10', 'REF_11'] ""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
i ++

IRs:
TMP_77(uint256) := i(uint256)
i(uint256) = i + 1""];
10->8;
11[label=""Node Type: IF 11

EXPRESSION:
! keepEth

IRs:
TMP_78 = UnaryType.BANG keepEth 
CONDITION TMP_78""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
wallet.transfer(msg.value)

IRs:
Transfer dest:wallet value:msg.value""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: RETURN 14

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(msg.value >= fee);require(bool)(tokenAddress != address(0));require(bool)(beneficiaries.length > 0 && beneficiaries.length == tokenAmount.length);ERC20Contract = ERC20(tokenAddress);i = 0;;i < beneficiaries.length;;! keepEth;ERC20Contract.safeTransferFrom(msg.sender,beneficiaries[i],tokenAmount[i]);i ++;wallet.transfer(msg.value);;true"
./0x17fd666fa0784885fa1afec8ac624d9b7e72b752_ext.sol,FLiK.approveAndCall,91,98,"TMP_20 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_20(tokenRecipient),TMP_21(bool) = INTERNAL_CALL, FLiK.approve(address,uint256)(_spender,_value),CONDITION TMP_21,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_20 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_20(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_21(bool) = INTERNAL_CALL, FLiK.approve(address,uint256)(_spender,_value)
CONDITION TMP_21""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0xbca5b3524e2d52c38fd6ca6dd10233575baa8533_ext.sol,VOCC_I098_20181211.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x875ee23ab07f56476d9029720b43008c20477b38_ext.sol,FlowNet.transferFrom,44,52,"REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],allowance(uint256) := REF_5(uint256),REF_6(uint256) -> balances[_from],TMP_3(bool) = REF_6 >= _value,TMP_4(bool) = allowance >= _value,TMP_5(bool) = TMP_3 && TMP_4,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_7(uint256) -> balances[_to],REF_7(-> balances) = REF_7 + _value,REF_8(uint256) -> balances[_from],REF_8(-> balances) = REF_8 - _value,REF_9(mapping(address => uint256)) -> allowed[_from],REF_10(uint256) -> REF_9[msg.sender],REF_10(-> allowed) = REF_10 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
allowance = allowed[_from][msg.sender]

IRs:
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
allowance(uint256) := REF_5(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] >= _value && allowance >= _value)

IRs:
REF_6(uint256) -> balances[_from]
TMP_3(bool) = REF_6 >= _value
TMP_4(bool) = allowance >= _value
TMP_5(bool) = TMP_3 && TMP_4
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_7(uint256) -> balances[_to]
REF_7(-> balances) = REF_7 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] -= _value

IRs:
REF_8(uint256) -> balances[_from]
REF_8(-> balances) = REF_8 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_9(mapping(address => uint256)) -> allowed[_from]
REF_10(uint256) -> REF_9[msg.sender]
REF_10(-> allowed) = REF_10 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowance = allowed[_from][msg.sender];require(bool)(balances[_from] >= _value && allowance >= _value);balances[_to] += _value;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true;success"
./0x6c1a692ea7c92ae76cbfdda122830698c950f0ff_ext.sol,CursedToken.approveAndCall,84,89,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokencount(uint256),Emit Approval(msg.sender,spender,tokencount),TMP_28 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_28(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokencount', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokencount

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokencount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokencount)

IRs:
Emit Approval(msg.sender,spender,tokencount)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokencount,this,data)

IRs:
TMP_28 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_28(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokencount', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokencount;Approval(msg.sender,spender,tokencount);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokencount,this,data);true;success"
./0x6c605dafbb54c2bc2cbc8446b645a9835ed56cce_ext.sol,Botcash.transfer,53,64,"REF_8(uint256) -> balanceOf[msg.sender],TMP_21(bool) = REF_8 >= _value,REF_9(uint256) -> balanceOf[_to],TMP_22(uint256) = REF_9 + _value,REF_10(uint256) -> balanceOf[_to],TMP_23(bool) = TMP_22 >= REF_10,TMP_24(bool) = TMP_21 && TMP_23,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_11(uint256) -> balanceOf[msg.sender],REF_11(-> balanceOf) = REF_11 - _value,REF_12(uint256) -> balanceOf[_to],REF_12(-> balanceOf) = REF_12 + _value,REF_13(uint256) = SOLIDITY_CALL balance(address)(msg.sender),TMP_26(bool) = REF_13 < minBalanceForAccounts,CONDITION TMP_26,REF_14(uint256) = SOLIDITY_CALL balance(address)(msg.sender),TMP_27(uint256) = minBalanceForAccounts - REF_14,TMP_28(uint256) = TMP_27 / sellPrice,TMP_29(uint256) = INTERNAL_CALL, Botcash.sell(uint256)(TMP_28),Emit Transfer(msg.sender,_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_8(uint256) -> balanceOf[msg.sender]
TMP_21(bool) = REF_8 >= _value
REF_9(uint256) -> balanceOf[_to]
TMP_22(uint256) = REF_9 + _value
REF_10(uint256) -> balanceOf[_to]
TMP_23(bool) = TMP_22 >= REF_10
TMP_24(bool) = TMP_21 && TMP_23
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_11(uint256) -> balanceOf[msg.sender]
REF_11(-> balanceOf) = REF_11 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_12(uint256) -> balanceOf[_to]
REF_12(-> balanceOf) = REF_12 + _value""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
msg.sender.balance < minBalanceForAccounts

IRs:
REF_13(uint256) = SOLIDITY_CALL balance(address)(msg.sender)
TMP_26(bool) = REF_13 < minBalanceForAccounts
CONDITION TMP_26""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
sell((minBalanceForAccounts - msg.sender.balance) / sellPrice)

IRs:
REF_14(uint256) = SOLIDITY_CALL balance(address)(msg.sender)
TMP_27(uint256) = minBalanceForAccounts - REF_14
TMP_28(uint256) = TMP_27 / sellPrice
TMP_29(uint256) = INTERNAL_CALL, Botcash.sell(uint256)(TMP_28)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);balanceOf[msg.sender] -= _value;balanceOf[_to] += _value;msg.sender.balance < minBalanceForAccounts;sell((minBalanceForAccounts - msg.sender.balance) / sellPrice);;Transfer(msg.sender,_to,_value)"
./0x0cddd1094b8331b63191282f9b73cf609e139ac4_ext.sol,PWGLToken.burn,79,84,"REF_19(uint256) -> balanceOf[msg.sender],TMP_29(bool) = REF_19 >= _value,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),REF_20(uint256) -> balanceOf[msg.sender],REF_20(-> balanceOf) = REF_20 - _value,REF_21(uint256) -> balanceOf[0],REF_21(-> balanceOf) = REF_21 + _value,Emit Transfer(msg.sender,0,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_19(uint256) -> balanceOf[msg.sender]
TMP_29(bool) = REF_19 >= _value
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_20(uint256) -> balanceOf[msg.sender]
REF_20(-> balanceOf) = REF_20 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[0x0] += _value

IRs:
REF_21(uint256) -> balanceOf[0]
REF_21(-> balanceOf) = REF_21 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,0x0,_value)

IRs:
Emit Transfer(msg.sender,0,_value)""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;balanceOf[0x0] += _value;Transfer(msg.sender,0x0,_value)"
./0x6c558a4976e751391fb73dd61fa6a72c318d80b5_ext.sol,BitQ.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x77af8c290d10882f634267177128cc7d1e893785_ext.sol,GlobalTransportServices.burnFrom,125,133,"REF_16(uint256) -> balanceOf[_from],TMP_71(bool) = REF_16 >= _value,TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71),REF_17(mapping(address => uint256)) -> allowance[_from],REF_18(uint256) -> REF_17[msg.sender],TMP_73(bool) = _value <= REF_18,TMP_74(None) = SOLIDITY_CALL require(bool)(TMP_73),REF_19(uint256) -> balanceOf[_from],REF_19(-> balanceOf) = REF_19 - _value,REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],REF_21(-> allowance) = REF_21 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,MODIFIER_CALL, GlobalTransportServices.onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_16(uint256) -> balanceOf[_from]
TMP_71(bool) = REF_16 >= _value
TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_17(mapping(address => uint256)) -> allowance[_from]
REF_18(uint256) -> REF_17[msg.sender]
TMP_73(bool) = _value <= REF_18
TMP_74(None) = SOLIDITY_CALL require(bool)(TMP_73)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_19(uint256) -> balanceOf[_from]
REF_19(-> balanceOf) = REF_19 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
REF_21(-> allowance) = REF_21 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, GlobalTransportServices.onlyOwner()()""];
8->1;
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"onlyOwner();require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x34644911eeefd50877cca86562e673b94885048b_ext.sol,RUSS_PFVI_III_883.transferFrom,42,54,"REF_6(uint256) -> balanceOf[from],TMP_6(bool) = value <= REF_6,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_7(mapping(address => uint256)) -> allowance[from],REF_8(uint256) -> REF_7[msg.sender],TMP_8(bool) = value <= REF_8,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_9(uint256) -> balanceOf[from],REF_9(-> balanceOf) = REF_9 - value,REF_10(uint256) -> balanceOf[to],REF_10(-> balanceOf) = REF_10 + value,REF_11(mapping(address => uint256)) -> allowance[from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowance) = REF_12 - value,Emit Transfer(from,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(value <= balanceOf[from])

IRs:
REF_6(uint256) -> balanceOf[from]
TMP_6(bool) = value <= REF_6
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value <= allowance[from][msg.sender])

IRs:
REF_7(mapping(address => uint256)) -> allowance[from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_8(bool) = value <= REF_8
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[from] -= value

IRs:
REF_9(uint256) -> balanceOf[from]
REF_9(-> balanceOf) = REF_9 - value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[to] += value

IRs:
REF_10(uint256) -> balanceOf[to]
REF_10(-> balanceOf) = REF_10 + value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allowance[from][msg.sender] -= value

IRs:
REF_11(mapping(address => uint256)) -> allowance[from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowance) = REF_12 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(value <= balanceOf[from]);require(bool)(value <= allowance[from][msg.sender]);balanceOf[from] -= value;balanceOf[to] += value;allowance[from][msg.sender] -= value;Transfer(from,to,value);true;success"
./0x18bbc8d1ec4ee0414e24eceed8b6a0e1b509b5c4_ext.sol,MetToken.list_frozen_accounts,970,991,"REF_188 -> LENGTH holders_frozen,len(uint256) := REF_188(uint256),num_of_frozen_holders(uint256) := 0(uint256),TMP_337(bool) = _max_num_of_items_to_display == 0,CONDITION TMP_337,_max_num_of_items_to_display(uint256) := 1(uint256),TMP_338(uint256) = len - 1,i(uint256) := TMP_338(uint256),TMP_339(bool) = i >= 0,CONDITION TMP_339,REF_189(address) -> holders_frozen[i],REF_190(uint256) -> account_frozen_time[REF_189],TMP_340(bool) = REF_190 > 0,CONDITION TMP_340,TMP_341(uint256) := num_of_frozen_holders(uint256),num_of_frozen_holders(uint256) = num_of_frozen_holders + 1,TMP_342(bool) = _max_num_of_items_to_display == num_of_frozen_holders,CONDITION TMP_342,TMP_343(uint256) := i(uint256),i(uint256) = i - 1,TMP_345(address[])  = new address[](num_of_frozen_holders),_frozen_holders(address[]) = ['TMP_345(address[])'],TMP_347(uint256[])  = new uint256[](num_of_frozen_holders),_whens(uint256[]) = ['TMP_347(uint256[])'],_num(uint256) := 0(uint256),TMP_348(uint256) = len - 1,j(uint256) := TMP_348(uint256),TMP_349(bool) = j >= 0,TMP_350(bool) = num_of_frozen_holders > _num,TMP_351(bool) = TMP_349 && TMP_350,CONDITION TMP_351,REF_191(address) -> holders_frozen[j],addr(address) := REF_191(address),REF_192(uint256) -> account_frozen_time[addr],when(uint256) := REF_192(uint256),TMP_352(bool) = when == 0,CONDITION TMP_352,REF_193(address) -> _frozen_holders[_num],REF_193(address) (->_frozen_holders) := addr(address),REF_194(uint256) -> _whens[_num],REF_194(uint256) (->_whens) := when(uint256),TMP_353(uint256) := _num(uint256),_num(uint256) = _num + 1,TMP_354(uint256) := j(uint256),j(uint256) = j - 1,RETURN _num,_frozen_holders,_whens","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
len = holders_frozen.length

IRs:
REF_188 -> LENGTH holders_frozen
len(uint256) := REF_188(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
num_of_frozen_holders = 0

IRs:
num_of_frozen_holders(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_max_num_of_items_to_display == 0

IRs:
TMP_337(bool) = _max_num_of_items_to_display == 0
CONDITION TMP_337""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
_max_num_of_items_to_display = 1

IRs:
_max_num_of_items_to_display(uint256) := 1(uint256)""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->8;
6[label=""Node Type: BEGIN_LOOP 6
""];
6->9;
7[label=""Node Type: END_LOOP 7
""];
7->17;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
i = len - 1

IRs:
TMP_338(uint256) = len - 1
i(uint256) := TMP_338(uint256)""];
8->6;
9[label=""Node Type: IF_LOOP 9

EXPRESSION:
i >= 0

IRs:
TMP_339(bool) = i >= 0
CONDITION TMP_339""];
9->10[label=""True""];
9->7[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
account_frozen_time[holders_frozen[i]] > 0x0

IRs:
REF_189(address) -> holders_frozen[i]
REF_190(uint256) -> account_frozen_time[REF_189]
TMP_340(bool) = REF_190 > 0
CONDITION TMP_340""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
num_of_frozen_holders ++

IRs:
TMP_341(uint256) := num_of_frozen_holders(uint256)
num_of_frozen_holders(uint256) = num_of_frozen_holders + 1""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
_max_num_of_items_to_display == num_of_frozen_holders

IRs:
TMP_342(bool) = _max_num_of_items_to_display == num_of_frozen_holders
CONDITION TMP_342""];
13->14[label=""True""];
13->15[label=""False""];
14[label=""Node Type: BREAK 14
""];
14->7;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
i --

IRs:
TMP_343(uint256) := i(uint256)
i(uint256) = i - 1""];
16->9;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
_frozen_holders = new address[](num_of_frozen_holders)

IRs:
TMP_345(address[])  = new address[](num_of_frozen_holders)
_frozen_holders(address[]) = ['TMP_345(address[])']""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
_whens = new uint256[](num_of_frozen_holders)

IRs:
TMP_347(uint256[])  = new uint256[](num_of_frozen_holders)
_whens(uint256[]) = ['TMP_347(uint256[])']""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
_num = 0

IRs:
_num(uint256) := 0(uint256)""];
19->22;
20[label=""Node Type: BEGIN_LOOP 20
""];
20->23;
21[label=""Node Type: END_LOOP 21
""];
21->33;
22[label=""Node Type: NEW VARIABLE 22

EXPRESSION:
j = len - 1

IRs:
TMP_348(uint256) = len - 1
j(uint256) := TMP_348(uint256)""];
22->20;
23[label=""Node Type: IF_LOOP 23

EXPRESSION:
j >= 0 && num_of_frozen_holders > _num

IRs:
TMP_349(bool) = j >= 0
TMP_350(bool) = num_of_frozen_holders > _num
TMP_351(bool) = TMP_349 && TMP_350
CONDITION TMP_351""];
23->24[label=""True""];
23->21[label=""False""];
24[label=""Node Type: NEW VARIABLE 24

EXPRESSION:
addr = holders_frozen[j]

IRs:
REF_191(address) -> holders_frozen[j]
addr(address) := REF_191(address)""];
24->25;
25[label=""Node Type: NEW VARIABLE 25

EXPRESSION:
when = account_frozen_time[addr]

IRs:
REF_192(uint256) -> account_frozen_time[addr]
when(uint256) := REF_192(uint256)""];
25->26;
26[label=""Node Type: IF 26

EXPRESSION:
when == 0x0

IRs:
TMP_352(bool) = when == 0
CONDITION TMP_352""];
26->27[label=""True""];
26->28[label=""False""];
27[label=""Node Type: CONTINUE 27
""];
27->32;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
_frozen_holders[_num] = addr

IRs:
REF_193(address) -> _frozen_holders[_num]
REF_193(address) (->_frozen_holders) := addr(address)""];
29->30;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
_whens[_num] = when

IRs:
REF_194(uint256) -> _whens[_num]
REF_194(uint256) (->_whens) := when(uint256)""];
30->31;
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
_num ++

IRs:
TMP_353(uint256) := _num(uint256)
_num(uint256) = _num + 1""];
31->32;
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
j --

IRs:
TMP_354(uint256) := j(uint256)
j(uint256) = j - 1""];
32->23;
33[label=""Node Type: RETURN 33

EXPRESSION:
(_num,_frozen_holders,_whens)

IRs:
RETURN _num,_frozen_holders,_whens""];
}
",0,1,0,0,"len = holders_frozen.length;num_of_frozen_holders = 0;_max_num_of_items_to_display == 0;_max_num_of_items_to_display = 1;;i = len - 1;;i >= 0;;_frozen_holders = new address[](num_of_frozen_holders);account_frozen_time[holders_frozen[i]] > 0x0;num_of_frozen_holders ++;;_max_num_of_items_to_display == num_of_frozen_holders;;;i --;_whens = new uint256[](num_of_frozen_holders);_num = 0;j = len - 1;;j >= 0 && num_of_frozen_holders > _num;;(_num,_frozen_holders,_whens);addr = holders_frozen[j];when = account_frozen_time[addr];when == 0x0;;;j --;_frozen_holders[_num] = addr;_whens[_num] = when;_num ++"
./0x35ced9349943292f8a3b2e0a96fec76d7877ac4e_ext.sol,BancorKillerContract.get_amount_buy,199,209,"REF_19(uint256) -> token_balance[base_token],base_token_balance_(uint256) := REF_19(uint256),REF_20(uint256) -> token_balance[traded_token],traded_token_balance_(uint256) := REF_20(uint256),TMP_53(uint256) = base_token_balance_ + _amount,base_token_balance_plus_amount_(uint256) := TMP_53(uint256),TMP_54(uint256) = _amount * traded_token_balance_,TMP_55(uint256) = base_token_balance_plus_amount_ + base_token_balance_,TMP_56(uint256) = TMP_54 * TMP_55,TMP_57(uint256) = 2 * base_token_balance_plus_amount_,TMP_58(uint256) = TMP_57 * base_token_balance_,TMP_59(uint256) = TMP_56 / TMP_58,RETURN TMP_59","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
base_token_balance_ = token_balance[base_token]

IRs:
REF_19(uint256) -> token_balance[base_token]
base_token_balance_(uint256) := REF_19(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
traded_token_balance_ = token_balance[traded_token]

IRs:
REF_20(uint256) -> token_balance[traded_token]
traded_token_balance_(uint256) := REF_20(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
base_token_balance_plus_amount_ = base_token_balance_ + _amount

IRs:
TMP_53(uint256) = base_token_balance_ + _amount
base_token_balance_plus_amount_(uint256) := TMP_53(uint256)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
(_amount * traded_token_balance_ * (base_token_balance_plus_amount_ + base_token_balance_)) / (2 * base_token_balance_plus_amount_ * base_token_balance_)

IRs:
TMP_54(uint256) = _amount * traded_token_balance_
TMP_55(uint256) = base_token_balance_plus_amount_ + base_token_balance_
TMP_56(uint256) = TMP_54 * TMP_55
TMP_57(uint256) = 2 * base_token_balance_plus_amount_
TMP_58(uint256) = TMP_57 * base_token_balance_
TMP_59(uint256) = TMP_56 / TMP_58
RETURN TMP_59""];
}
",0,1,0,0,base_token_balance_ = token_balance[base_token];traded_token_balance_ = token_balance[traded_token];base_token_balance_plus_amount_ = base_token_balance_ + _amount;(_amount * traded_token_balance_ * (base_token_balance_plus_amount_ + base_token_balance_)) / (2 * base_token_balance_plus_amount_ * base_token_balance_)
./0x2a790479cd47f686804fe570b903f3b6cf08599d_ext.sol,ChainmonstersShop.setPrice,614,620,"REF_41(ChainmonstersShop.Package) -> packages[_packageId],REF_42(uint256) -> REF_41.price,TMP_492(bool) = REF_42 > 0,TMP_493(None) = SOLIDITY_CALL require(bool)(TMP_492),REF_43(ChainmonstersShop.Package) -> packages[_packageId],REF_44(uint256) -> REF_43.price,REF_44(uint256) (->packages) := _newPrice(uint256),MODIFIER_CALL, ChainmonstersShop.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(packages[_packageId].price > 0)

IRs:
REF_41(ChainmonstersShop.Package) -> packages[_packageId]
REF_42(uint256) -> REF_41.price
TMP_492(bool) = REF_42 > 0
TMP_493(None) = SOLIDITY_CALL require(bool)(TMP_492)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
packages[_packageId].price = _newPrice

IRs:
REF_43(ChainmonstersShop.Package) -> packages[_packageId]
REF_44(uint256) -> REF_43.price
REF_44(uint256) (->packages) := _newPrice(uint256)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ChainmonstersShop.onlyOwner()()""];
3->1;
}
",0,1,0,0,onlyOwner();require(bool)(packages[_packageId].price > 0);packages[_packageId].price = _newPrice
./0x0d67440946949fe293b45c52efd8a9b3d51e2522_ext.sol,MultipleArbitrableTransaction.executeRuling,659,679,"REF_208(MultipleArbitrableTransaction.Transaction) -> transactions[_transactionID],transaction(MultipleArbitrableTransaction.Transaction) := REF_208(MultipleArbitrableTransaction.Transaction),TMP_227(bool) = _ruling <= AMOUNT_OF_CHOICES,TMP_228(None) = SOLIDITY_CALL require(bool,string)(TMP_227,Invalid ruling.),TMP_229(bool) = _ruling == SENDER_WINS,CONDITION TMP_229,REF_209(address) -> transaction.sender,REF_211(uint256) -> transaction.senderFee,REF_212(uint256) -> transaction.amount,TMP_230(uint256) = REF_211 + REF_212,TMP_231 = SEND dest:REF_209 value:TMP_230,TMP_232(bool) = _ruling == RECEIVER_WINS,CONDITION TMP_232,REF_213(address) -> transaction.receiver,REF_215(uint256) -> transaction.receiverFee,REF_216(uint256) -> transaction.amount,TMP_233(uint256) = REF_215 + REF_216,TMP_234 = SEND dest:REF_213 value:TMP_233,REF_217(uint256) -> transaction.senderFee,REF_218(uint256) -> transaction.amount,TMP_235(uint256) = REF_217 + REF_218,TMP_236(uint256) = TMP_235 / 2,split_amount(uint256) := TMP_236(uint256),REF_219(address) -> transaction.sender,TMP_237 = SEND dest:REF_219 value:split_amount,REF_221(address) -> transaction.receiver,TMP_238 = SEND dest:REF_221 value:split_amount,REF_223(uint256) -> transaction.amount,REF_223(uint256) (->transaction) := 0(uint256),REF_224(uint256) -> transaction.senderFee,REF_224(uint256) (->transaction) := 0(uint256),REF_225(uint256) -> transaction.receiverFee,REF_225(uint256) (->transaction) := 0(uint256),REF_226(MultipleArbitrableTransaction.Status) -> transaction.status,REF_227(MultipleArbitrableTransaction.Status) -> Status.Resolved,REF_226(MultipleArbitrableTransaction.Status) (->transaction) := REF_227(MultipleArbitrableTransaction.Status)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
transaction = transactions[_transactionID]

IRs:
REF_208(MultipleArbitrableTransaction.Transaction) -> transactions[_transactionID]
transaction(MultipleArbitrableTransaction.Transaction) := REF_208(MultipleArbitrableTransaction.Transaction)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(_ruling <= AMOUNT_OF_CHOICES,Invalid ruling.)

IRs:
TMP_227(bool) = _ruling <= AMOUNT_OF_CHOICES
TMP_228(None) = SOLIDITY_CALL require(bool,string)(TMP_227,Invalid ruling.)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_ruling == SENDER_WINS

IRs:
TMP_229(bool) = _ruling == SENDER_WINS
CONDITION TMP_229""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
transaction.sender.send(transaction.senderFee + transaction.amount)

IRs:
REF_209(address) -> transaction.sender
REF_211(uint256) -> transaction.senderFee
REF_212(uint256) -> transaction.amount
TMP_230(uint256) = REF_211 + REF_212
TMP_231 = SEND dest:REF_209 value:TMP_230""];
4->11;
5[label=""Node Type: IF 5

EXPRESSION:
_ruling == RECEIVER_WINS

IRs:
TMP_232(bool) = _ruling == RECEIVER_WINS
CONDITION TMP_232""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
transaction.receiver.send(transaction.receiverFee + transaction.amount)

IRs:
REF_213(address) -> transaction.receiver
REF_215(uint256) -> transaction.receiverFee
REF_216(uint256) -> transaction.amount
TMP_233(uint256) = REF_215 + REF_216
TMP_234 = SEND dest:REF_213 value:TMP_233""];
6->10;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
split_amount = (transaction.senderFee + transaction.amount) / 2

IRs:
REF_217(uint256) -> transaction.senderFee
REF_218(uint256) -> transaction.amount
TMP_235(uint256) = REF_217 + REF_218
TMP_236(uint256) = TMP_235 / 2
split_amount(uint256) := TMP_236(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
transaction.sender.send(split_amount)

IRs:
REF_219(address) -> transaction.sender
TMP_237 = SEND dest:REF_219 value:split_amount""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
transaction.receiver.send(split_amount)

IRs:
REF_221(address) -> transaction.receiver
TMP_238 = SEND dest:REF_221 value:split_amount""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
transaction.amount = 0

IRs:
REF_223(uint256) -> transaction.amount
REF_223(uint256) (->transaction) := 0(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
transaction.senderFee = 0

IRs:
REF_224(uint256) -> transaction.senderFee
REF_224(uint256) (->transaction) := 0(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
transaction.receiverFee = 0

IRs:
REF_225(uint256) -> transaction.receiverFee
REF_225(uint256) (->transaction) := 0(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
transaction.status = Status.Resolved

IRs:
REF_226(MultipleArbitrableTransaction.Status) -> transaction.status
REF_227(MultipleArbitrableTransaction.Status) -> Status.Resolved
REF_226(MultipleArbitrableTransaction.Status) (->transaction) := REF_227(MultipleArbitrableTransaction.Status)""];
}
",0,1,1,0,"transaction = transactions[_transactionID];require(bool,string)(_ruling <= AMOUNT_OF_CHOICES,Invalid ruling.);_ruling == SENDER_WINS;transaction.sender.send(transaction.senderFee + transaction.amount);_ruling == RECEIVER_WINS;;transaction.receiver.send(transaction.receiverFee + transaction.amount);split_amount = (transaction.senderFee + transaction.amount) / 2;;transaction.sender.send(split_amount);transaction.receiver.send(split_amount);transaction.amount = 0;transaction.senderFee = 0;transaction.receiverFee = 0;transaction.status = Status.Resolved"
./0x6f796ed01c70c796d8378bfbc616a158ea5065c6_ext.sol,WELTCOIN.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xf2d4dcfe87430ae9d1e0235edaa7cd3d445e2378_ext.sol,OPCToken.burn,128,134,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x0747af71e2034bc2d2fcad388a264f5ccdff505c_ext.sol,BlockVentureCoin.burn,309,321,"REF_24(uint256) -> balanceOf[msg.sender],TMP_20(bool) = REF_24 < _value,CONDITION TMP_20,REF_25(uint256) -> balanceOf[msg.sender],REF_25(-> balanceOf) = REF_25 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balanceOf[msg.sender] < _value

IRs:
REF_24(uint256) -> balanceOf[msg.sender]
TMP_20(bool) = REF_24 < _value
CONDITION TMP_20""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_25(uint256) -> balanceOf[msg.sender]
REF_25(-> balanceOf) = REF_25 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balanceOf[msg.sender] < _value;;;balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x945f171de4ea81a213dcc7a1e8c4f6feb3b4b806_ext.sol,ECP_Token.sendToMultipleAccount,59,77,"i(uint256) := 0(uint256),REF_1 -> LENGTH dests,TMP_0(bool) = i < REF_1,CONDITION TMP_0,TMP_1(bool) = remaining > 0,CONDITION TMP_1,REF_2(address) -> dests[i],REF_3(uint256) -> values[i],INTERNAL_CALL, ECP_Token._transfer(address,address,uint256)(owner,REF_2,REF_3),REF_4(address) -> dests[i],REF_5(uint256) -> values[i],Emit TokenTransferEvent(owner,REF_4,REF_5,MultipleAccount),TMP_4(None) = SOLIDITY_CALL revert()(),i(uint256) = i + 1,RETURN i,MODIFIER_CALL, ECP_Token.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->3;
3[label=""Node Type: IF_LOOP 3

EXPRESSION:
i < dests.length

IRs:
REF_1 -> LENGTH dests
TMP_0(bool) = i < REF_1
CONDITION TMP_0""];
3->4[label=""True""];
3->10[label=""False""];
4[label=""Node Type: IF 4

EXPRESSION:
remaining > 0

IRs:
TMP_1(bool) = remaining > 0
CONDITION TMP_1""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_transfer(owner,dests[i],values[i])

IRs:
REF_2(address) -> dests[i]
REF_3(uint256) -> values[i]
INTERNAL_CALL, ECP_Token._transfer(address,address,uint256)(owner,REF_2,REF_3)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
TokenTransferEvent(owner,dests[i],values[i],MultipleAccount)

IRs:
REF_4(address) -> dests[i]
REF_5(uint256) -> values[i]
Emit TokenTransferEvent(owner,REF_4,REF_5,MultipleAccount)""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
revert()()

IRs:
TMP_4(None) = SOLIDITY_CALL revert()()""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
i += 1

IRs:
i(uint256) = i + 1""];
9->3;
10[label=""Node Type: END_LOOP 10
""];
10->11;
11[label=""Node Type: RETURN 11

EXPRESSION:
(i)

IRs:
RETURN i""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ECP_Token.onlyOwner()()""];
12->1;
}
",0,1,0,0,"onlyOwner();i = 0;;i < dests.length;remaining > 0;;_transfer(owner,dests[i],values[i]);revert()();TokenTransferEvent(owner,dests[i],values[i],MultipleAccount);;i += 1;(i)"
./0x4159e265fdfa4e581e9b0b2988346ee7db4f0b7e_ext.sol,BANK_III_PFI_883.transferFrom,42,54,"REF_6(uint256) -> balanceOf[from],TMP_6(bool) = value <= REF_6,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_7(mapping(address => uint256)) -> allowance[from],REF_8(uint256) -> REF_7[msg.sender],TMP_8(bool) = value <= REF_8,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_9(uint256) -> balanceOf[from],REF_9(-> balanceOf) = REF_9 - value,REF_10(uint256) -> balanceOf[to],REF_10(-> balanceOf) = REF_10 + value,REF_11(mapping(address => uint256)) -> allowance[from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowance) = REF_12 - value,Emit Transfer(from,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(value <= balanceOf[from])

IRs:
REF_6(uint256) -> balanceOf[from]
TMP_6(bool) = value <= REF_6
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value <= allowance[from][msg.sender])

IRs:
REF_7(mapping(address => uint256)) -> allowance[from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_8(bool) = value <= REF_8
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[from] -= value

IRs:
REF_9(uint256) -> balanceOf[from]
REF_9(-> balanceOf) = REF_9 - value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[to] += value

IRs:
REF_10(uint256) -> balanceOf[to]
REF_10(-> balanceOf) = REF_10 + value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allowance[from][msg.sender] -= value

IRs:
REF_11(mapping(address => uint256)) -> allowance[from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowance) = REF_12 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(value <= balanceOf[from]);require(bool)(value <= allowance[from][msg.sender]);balanceOf[from] -= value;balanceOf[to] += value;allowance[from][msg.sender] -= value;Transfer(from,to,value);true;success"
./0x585847041ecea75bb8bfe7f2019181978f363dae_ext.sol,TokenERC20.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x2dd09c71d951148bba0f25be7f76ba401fe8ef84_ext.sol,GoTokenDutchAuction.calcTokenPrice,774,798,"REF_129(GoTokenDutchAuction.Stages) -> Stages.AuctionDeployed,TMP_250(bool) = stage == REF_129,REF_130(GoTokenDutchAuction.Stages) -> Stages.AuctionSetUp,TMP_251(bool) = stage == REF_130,TMP_252(bool) = TMP_250 || TMP_251,CONDITION TMP_252,RETURN price_start,REF_131(GoTokenDutchAuction.Stages) -> Stages.AuctionStarted,TMP_253(bool) = stage == REF_131,CONDITION TMP_253,TMP_254(uint256) = now - auction_start_time,elapsed(uint256) := TMP_254(uint256),TMP_255(bool) = now >= auction_start_time,TMP_256(uint256) = auction_start_time + CURVE_CUTOFF_DURATION,TMP_257(bool) = now < TMP_256,TMP_258(bool) = TMP_255 && TMP_257,CONDITION TMP_258,TMP_259(uint256) = elapsed ** price_exponent1,TMP_260(uint256) = TMP_259 / price_constant1,decay_rate1(uint256) := TMP_260(uint256),TMP_261(uint256) = 1 + elapsed,TMP_262(uint256) = price_start * TMP_261,TMP_263(uint256) = 1 + elapsed,TMP_264(uint256) = TMP_263 + decay_rate1,TMP_265(uint256) = TMP_262 / TMP_264,RETURN TMP_265,TMP_266(bool) = now >= auction_start_time,TMP_267(uint256) = auction_start_time + CURVE_CUTOFF_DURATION,TMP_268(bool) = now >= TMP_267,TMP_269(bool) = TMP_266 && TMP_268,CONDITION TMP_269,TMP_270(uint256) = elapsed ** price_exponent2,TMP_271(uint256) = TMP_270 / price_constant2,decay_rate2(uint256) := TMP_271(uint256),TMP_272(uint256) = 1 + elapsed,TMP_273(uint256) = price_start * TMP_272,TMP_274(uint256) = 1 + elapsed,TMP_275(uint256) = TMP_274 + decay_rate2,TMP_276(uint256) = TMP_273 / TMP_275,RETURN TMP_276,RETURN price_start","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: NEW VARIABLE 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
stage == Stages.AuctionDeployed || stage == Stages.AuctionSetUp

IRs:
REF_129(GoTokenDutchAuction.Stages) -> Stages.AuctionDeployed
TMP_250(bool) = stage == REF_129
REF_130(GoTokenDutchAuction.Stages) -> Stages.AuctionSetUp
TMP_251(bool) = stage == REF_130
TMP_252(bool) = TMP_250 || TMP_251
CONDITION TMP_252""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: RETURN 5

EXPRESSION:
price_start

IRs:
RETURN price_start""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
stage == Stages.AuctionStarted

IRs:
REF_131(GoTokenDutchAuction.Stages) -> Stages.AuctionStarted
TMP_253(bool) = stage == REF_131
CONDITION TMP_253""];
7->8[label=""True""];
7->18[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
elapsed = now - auction_start_time

IRs:
TMP_254(uint256) = now - auction_start_time
elapsed(uint256) := TMP_254(uint256)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
now >= auction_start_time && now < auction_start_time + CURVE_CUTOFF_DURATION

IRs:
TMP_255(bool) = now >= auction_start_time
TMP_256(uint256) = auction_start_time + CURVE_CUTOFF_DURATION
TMP_257(bool) = now < TMP_256
TMP_258(bool) = TMP_255 && TMP_257
CONDITION TMP_258""];
9->10[label=""True""];
9->12[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
decay_rate1 = elapsed ** price_exponent1 / price_constant1

IRs:
TMP_259(uint256) = elapsed ** price_exponent1
TMP_260(uint256) = TMP_259 / price_constant1
decay_rate1(uint256) := TMP_260(uint256)""];
10->11;
11[label=""Node Type: RETURN 11

EXPRESSION:
price_start * (1 + elapsed) / (1 + elapsed + decay_rate1)

IRs:
TMP_261(uint256) = 1 + elapsed
TMP_262(uint256) = price_start * TMP_261
TMP_263(uint256) = 1 + elapsed
TMP_264(uint256) = TMP_263 + decay_rate1
TMP_265(uint256) = TMP_262 / TMP_264
RETURN TMP_265""];
12[label=""Node Type: IF 12

EXPRESSION:
now >= auction_start_time && now >= auction_start_time + CURVE_CUTOFF_DURATION

IRs:
TMP_266(bool) = now >= auction_start_time
TMP_267(uint256) = auction_start_time + CURVE_CUTOFF_DURATION
TMP_268(bool) = now >= TMP_267
TMP_269(bool) = TMP_266 && TMP_268
CONDITION TMP_269""];
12->13[label=""True""];
12->15[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
decay_rate2 = elapsed ** price_exponent2 / price_constant2

IRs:
TMP_270(uint256) = elapsed ** price_exponent2
TMP_271(uint256) = TMP_270 / price_constant2
decay_rate2(uint256) := TMP_271(uint256)""];
13->14;
14[label=""Node Type: RETURN 14

EXPRESSION:
price_start * (1 + elapsed) / (1 + elapsed + decay_rate2)

IRs:
TMP_272(uint256) = 1 + elapsed
TMP_273(uint256) = price_start * TMP_272
TMP_274(uint256) = 1 + elapsed
TMP_275(uint256) = TMP_274 + decay_rate2
TMP_276(uint256) = TMP_273 / TMP_275
RETURN TMP_276""];
15[label=""Node Type: RETURN 15

EXPRESSION:
price_start

IRs:
RETURN price_start""];
18[label=""Node Type: END_IF 18
""];
}
",0,1,0,0,;;;stage == Stages.AuctionDeployed || stage == Stages.AuctionSetUp;price_start;;stage == Stages.AuctionStarted;elapsed = now - auction_start_time;;now >= auction_start_time && now < auction_start_time + CURVE_CUTOFF_DURATION;decay_rate1 = elapsed ** price_exponent1 / price_constant1;now >= auction_start_time && now >= auction_start_time + CURVE_CUTOFF_DURATION;price_start * (1 + elapsed) / (1 + elapsed + decay_rate1);decay_rate2 = elapsed ** price_exponent2 / price_constant2;price_start;price_start * (1 + elapsed) / (1 + elapsed + decay_rate2)
./0x6d402b714df85f7fa3d257f1e6a86b62d099a4f3_ext.sol,BWCToken.burn,147,155,"REF_24(uint256) -> balances[msg.sender],TMP_51(bool) = _value <= REF_24,TMP_52(None) = SOLIDITY_CALL require(bool)(TMP_51),REF_25(uint256) -> balances[msg.sender],REF_26(uint256) -> balances[msg.sender],TMP_53(uint256) = REF_26 - _value,REF_25(uint256) (->balances) := TMP_53(uint256),TMP_54(uint256) = totalSupply - _value,totalSupply(uint256) := TMP_54(uint256),Emit Burn(msg.sender,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_24(uint256) -> balances[msg.sender]
TMP_51(bool) = _value <= REF_24
TMP_52(None) = SOLIDITY_CALL require(bool)(TMP_51)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] = balances[msg.sender] - _value

IRs:
REF_25(uint256) -> balances[msg.sender]
REF_26(uint256) -> balances[msg.sender]
TMP_53(uint256) = REF_26 - _value
REF_25(uint256) (->balances) := TMP_53(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply = totalSupply - _value

IRs:
TMP_54(uint256) = totalSupply - _value
totalSupply(uint256) := TMP_54(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(_value <= balances[msg.sender]);balances[msg.sender] = balances[msg.sender] - _value;totalSupply = totalSupply - _value;Burn(msg.sender,_value);true"
./0xb619e84adddd3e336c5dda1e1b40719c846d9030_ext.sol,WorldByEth.update,103,121,"TMP_32(bool) = now > timeleft,CONDITION TMP_32,REF_47(uint256) -> pot_[rID_],TMP_33(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_47', '6'] ,TMP_34(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_33', '10'] ,Transfer dest:lastplayer value:TMP_34,lastwinner(address) := lastplayer(address),REF_50(uint256) -> pot_[rID_],TMP_36(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['REF_50', '10'] ,com_(uint256) = com_ + TMP_36,TMP_37(uint256) = rID_ + 1,REF_52(uint256) -> pot_[TMP_37],REF_53(uint256) -> pot_[rID_],TMP_38(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_53', '3'] ,TMP_39(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_38', '10'] ,REF_52(-> pot_) = REF_52 + TMP_39,TMP_40(uint256) = now + 86400,timeleft(uint256) := TMP_40(uint256),RETURN False,timeleft(uint256) = timeleft + gap,TMP_41(uint256) = now + 86400,TMP_42(bool) = timeleft > TMP_41,CONDITION TMP_42,TMP_43(uint256) = now + 86400,timeleft(uint256) := TMP_43(uint256),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
now > timeleft

IRs:
TMP_32(bool) = now > timeleft
CONDITION TMP_32""];
1->2[label=""True""];
1->8[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
lastplayer.transfer(pot_[rID_].mul(6).div(10))

IRs:
REF_47(uint256) -> pot_[rID_]
TMP_33(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_47', '6'] 
TMP_34(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_33', '10'] 
Transfer dest:lastplayer value:TMP_34""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
lastwinner = lastplayer

IRs:
lastwinner(address) := lastplayer(address)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
com_ += pot_[rID_].div(10)

IRs:
REF_50(uint256) -> pot_[rID_]
TMP_36(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['REF_50', '10'] 
com_(uint256) = com_ + TMP_36""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
pot_[rID_ + 1] += pot_[rID_].mul(3).div(10)

IRs:
TMP_37(uint256) = rID_ + 1
REF_52(uint256) -> pot_[TMP_37]
REF_53(uint256) -> pot_[rID_]
TMP_38(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_53', '3'] 
TMP_39(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_38', '10'] 
REF_52(-> pot_) = REF_52 + TMP_39""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
timeleft = now + 86400

IRs:
TMP_40(uint256) = now + 86400
timeleft(uint256) := TMP_40(uint256)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
timeleft += gap

IRs:
timeleft(uint256) = timeleft + gap""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
timeleft > now + 86400

IRs:
TMP_41(uint256) = now + 86400
TMP_42(bool) = timeleft > TMP_41
CONDITION TMP_42""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
timeleft = now + 86400

IRs:
TMP_43(uint256) = now + 86400
timeleft(uint256) := TMP_43(uint256)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: RETURN 13

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,now > timeleft;lastplayer.transfer(pot_[rID_].mul(6).div(10));;lastwinner = lastplayer;com_ += pot_[rID_].div(10);pot_[rID_ + 1] += pot_[rID_].mul(3).div(10);timeleft = now + 86400;false;timeleft += gap;timeleft > now + 86400;timeleft = now + 86400;;true
./0x6bacca3cce57a46fd0822df7c07afbf9d81d96d9_ext.sol,Jiggs.dividendsOf,305,311,"REF_31(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_50(uint256) = profitPerShare_ * REF_31,TMP_51 = CONVERT TMP_50 to int256,REF_32(int256) -> payoutsTo_[_customerAddress],TMP_52(int256) = TMP_51 - REF_32,TMP_53 = CONVERT TMP_52 to uint256,TMP_54(uint256) = TMP_53 / magnitude,RETURN TMP_54","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_31(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_50(uint256) = profitPerShare_ * REF_31
TMP_51 = CONVERT TMP_50 to int256
REF_32(int256) -> payoutsTo_[_customerAddress]
TMP_52(int256) = TMP_51 - REF_32
TMP_53 = CONVERT TMP_52 to uint256
TMP_54(uint256) = TMP_53 / magnitude
RETURN TMP_54""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x7439655b739c936147475a7390f2040282da4766_ext.sol,Token.transferFrom,57,67,"REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],allowance(uint256) := REF_5(uint256),REF_6(uint256) -> balances[_from],TMP_5(bool) = REF_6 >= _value,TMP_6(bool) = allowance >= _value,TMP_7(bool) = TMP_5 && TMP_6,TMP_8(None) = SOLIDITY_CALL require(bool)(TMP_7),REF_7(uint256) -> balances[_to],REF_7(-> balances) = REF_7 + _value,REF_8(uint256) -> balances[_from],REF_8(-> balances) = REF_8 - _value,TMP_9(bool) = allowance < MAX_UINT256,CONDITION TMP_9,REF_9(mapping(address => uint256)) -> allowed[_from],REF_10(uint256) -> REF_9[msg.sender],REF_10(-> allowed) = REF_10 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
allowance = allowed[_from][msg.sender]

IRs:
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
allowance(uint256) := REF_5(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] >= _value && allowance >= _value)

IRs:
REF_6(uint256) -> balances[_from]
TMP_5(bool) = REF_6 >= _value
TMP_6(bool) = allowance >= _value
TMP_7(bool) = TMP_5 && TMP_6
TMP_8(None) = SOLIDITY_CALL require(bool)(TMP_7)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_7(uint256) -> balances[_to]
REF_7(-> balances) = REF_7 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] -= _value

IRs:
REF_8(uint256) -> balances[_from]
REF_8(-> balances) = REF_8 - _value""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
allowance < MAX_UINT256

IRs:
TMP_9(bool) = allowance < MAX_UINT256
CONDITION TMP_9""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_9(mapping(address => uint256)) -> allowed[_from]
REF_10(uint256) -> REF_9[msg.sender]
REF_10(-> allowed) = REF_10 - _value""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: RETURN 10

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowance = allowed[_from][msg.sender];require(bool)(balances[_from] >= _value && allowance >= _value);balances[_to] += _value;balances[_from] -= _value;allowance < MAX_UINT256;allowed[_from][msg.sender] -= _value;;Transfer(_from,_to,_value);true;success"
./0x537607e30d7a4343fe555d3087ec4762f9002a2c_ext.sol,StandardToken.transferFrom,56,66,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x72a3678da1e6683ebb58f006888903496d4e97ab_ext.sol,ENC.transferFrom,140,157,"REF_9(uint256) -> balances[_from],TMP_7(bool) = REF_9 >= _amount,TMP_8(bool) = _amount > 0,TMP_9(bool) = TMP_7 && TMP_8,REF_10(mapping(address => uint256)) -> allowed[_from],REF_11(uint256) -> REF_10[msg.sender],TMP_10(bool) = REF_11 >= _amount,TMP_11(bool) = TMP_9 && TMP_10,CONDITION TMP_11,REF_12(uint256) -> balances[_from],REF_12(-> balances) = REF_12 - _amount,REF_13(mapping(address => uint256)) -> allowed[_from],REF_14(uint256) -> REF_13[msg.sender],REF_14(-> allowed) = REF_14 - _amount,REF_15(uint256) -> balances[_to],REF_15(-> balances) = REF_15 + _amount,Emit Transfer(_from,_to,_amount),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[_from] >= _amount && _amount > 0 && allowed[_from][msg.sender] >= _amount

IRs:
REF_9(uint256) -> balances[_from]
TMP_7(bool) = REF_9 >= _amount
TMP_8(bool) = _amount > 0
TMP_9(bool) = TMP_7 && TMP_8
REF_10(mapping(address => uint256)) -> allowed[_from]
REF_11(uint256) -> REF_10[msg.sender]
TMP_10(bool) = REF_11 >= _amount
TMP_11(bool) = TMP_9 && TMP_10
CONDITION TMP_11""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_from] -= _amount

IRs:
REF_12(uint256) -> balances[_from]
REF_12(-> balances) = REF_12 - _amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
allowed[_from][msg.sender] -= _amount

IRs:
REF_13(mapping(address => uint256)) -> allowed[_from]
REF_14(uint256) -> REF_13[msg.sender]
REF_14(-> allowed) = REF_14 - _amount""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] += _amount

IRs:
REF_15(uint256) -> balances[_to]
REF_15(-> balances) = REF_15 + _amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_amount)

IRs:
Emit Transfer(_from,_to,_amount)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[_from] >= _amount && _amount > 0 && allowed[_from][msg.sender] >= _amount;balances[_from] -= _amount;false;allowed[_from][msg.sender] -= _amount;balances[_to] += _amount;Transfer(_from,_to,_amount);true;success"
./0x048f616fcc4dd825f4a0a3b095d2ef70046b30c3_ext.sol,Bablorub.register,130,146,"REF_42(Storage.User) -> user[msg.sender],REF_43(uint256) -> REF_42.balance,TMP_32(bool) = REF_43 == 0,CONDITION TMP_32,REF_44(Storage.User) -> user[msg.sender],REF_45(uint256) -> REF_44.timestamp,REF_45(uint256) (->user) := now(uint256),TMP_33(uint256) := countInvestors(uint256),countInvestors(uint256) = countInvestors + 1,TMP_34(address) = INTERNAL_CALL, Bablorub.bytesToAddress(bytes)(msg.data),referrer(address) := TMP_34(address),REF_46(Storage.User) -> user[referrer],REF_47(uint256) -> REF_46.balance,TMP_35(bool) = REF_47 > 0,TMP_36(bool) = referrer != msg.sender,TMP_37(bool) = TMP_35 && TMP_36,CONDITION TMP_37,REF_48(Storage.User) -> user[msg.sender],REF_49(address) -> REF_48.referrer,REF_49(address) (->user) := referrer(address),REF_50(Storage.User) -> user[referrer],REF_51(uint256) -> REF_50.countReferrals,TMP_38(uint256) := REF_51(uint256),REF_51(-> user) = REF_51 + 1,TMP_39(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', 'bonusReferral'] ,TMP_40(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_39', '100'] ,INTERNAL_CALL, Bablorub.transfer(address,uint256)(msg.sender,TMP_40),MODIFIER_CALL, Bablorub.withDeposit()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: IF 1

EXPRESSION:
user[msg.sender].balance == 0

IRs:
REF_42(Storage.User) -> user[msg.sender]
REF_43(uint256) -> REF_42.balance
TMP_32(bool) = REF_43 == 0
CONDITION TMP_32""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
user[msg.sender].timestamp = now

IRs:
REF_44(Storage.User) -> user[msg.sender]
REF_45(uint256) -> REF_44.timestamp
REF_45(uint256) (->user) := now(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
countInvestors ++

IRs:
TMP_33(uint256) := countInvestors(uint256)
countInvestors(uint256) = countInvestors + 1""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
referrer = bytesToAddress(msg.data)

IRs:
TMP_34(address) = INTERNAL_CALL, Bablorub.bytesToAddress(bytes)(msg.data)
referrer(address) := TMP_34(address)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
user[referrer].balance > 0 && referrer != msg.sender

IRs:
REF_46(Storage.User) -> user[referrer]
REF_47(uint256) -> REF_46.balance
TMP_35(bool) = REF_47 > 0
TMP_36(bool) = referrer != msg.sender
TMP_37(bool) = TMP_35 && TMP_36
CONDITION TMP_37""];
5->6[label=""True""];
5->9[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
user[msg.sender].referrer = referrer

IRs:
REF_48(Storage.User) -> user[msg.sender]
REF_49(address) -> REF_48.referrer
REF_49(address) (->user) := referrer(address)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
user[referrer].countReferrals ++

IRs:
REF_50(Storage.User) -> user[referrer]
REF_51(uint256) -> REF_50.countReferrals
TMP_38(uint256) := REF_51(uint256)
REF_51(-> user) = REF_51 + 1""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
transfer(msg.sender,msg.value.mul(bonusReferral).div(100))

IRs:
TMP_39(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', 'bonusReferral'] 
TMP_40(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_39', '100'] 
INTERNAL_CALL, Bablorub.transfer(address,uint256)(msg.sender,TMP_40)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: END_IF 10
""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
withDeposit()

IRs:
MODIFIER_CALL, Bablorub.withDeposit()()""];
11->1;
}
",0,1,0,0,"withDeposit();user[msg.sender].balance == 0;user[msg.sender].timestamp = now;;countInvestors ++;referrer = bytesToAddress(msg.data);user[referrer].balance > 0 && referrer != msg.sender;user[msg.sender].referrer = referrer;;user[referrer].countReferrals ++;transfer(msg.sender,msg.value.mul(bonusReferral).div(100))"
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.fallback,2,2,"REF_103(bool) -> blacklist[msg.sender],TMP_159 = UnaryType.BANG REF_103 ,TMP_160(None) = SOLIDITY_CALL require(bool)(TMP_159),TMP_161(bool) = payoutNow == 0,CONDITION TMP_161,TMP_162(None) = SOLIDITY_CALL require(bool)(allowsSignup),INTERNAL_CALL, KahnDistributionCentre.singleUserSignUp(address)(msg.sender),TMP_164(bool) = payoutNow == 1,CONDITION TMP_164,TMP_165(None) = SOLIDITY_CALL require(bool)(allowsSignup),TMP_166(bool) = payoutNow == 2,CONDITION TMP_166,INTERNAL_CALL, KahnDistributionCentre.claimTokens(address)(msg.sender),TMP_168(bool) = payoutNow == 3,CONDITION TMP_168,INTERNAL_CALL, KahnDistributionCentre.claimImmediateTokens(address)(msg.sender),MODIFIER_CALL, KahnDistributionCentre.ifNotStartExp()(),MODIFIER_CALL, KahnDistributionCentre.ifNotPaused()(),MODIFIER_CALL, KahnDistributionCentre.ifNotBlacklisted()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->15;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! blacklist[msg.sender])

IRs:
REF_103(bool) -> blacklist[msg.sender]
TMP_159 = UnaryType.BANG REF_103 
TMP_160(None) = SOLIDITY_CALL require(bool)(TMP_159)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
payoutNow == 0

IRs:
TMP_161(bool) = payoutNow == 0
CONDITION TMP_161""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(allowsSignup)

IRs:
TMP_162(None) = SOLIDITY_CALL require(bool)(allowsSignup)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
singleUserSignUp(msg.sender)

IRs:
INTERNAL_CALL, KahnDistributionCentre.singleUserSignUp(address)(msg.sender)""];
4->14;
5[label=""Node Type: IF 5

EXPRESSION:
payoutNow == 1

IRs:
TMP_164(bool) = payoutNow == 1
CONDITION TMP_164""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(allowsSignup)

IRs:
TMP_165(None) = SOLIDITY_CALL require(bool)(allowsSignup)""];
6->13;
7[label=""Node Type: IF 7

EXPRESSION:
payoutNow == 2

IRs:
TMP_166(bool) = payoutNow == 2
CONDITION TMP_166""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
claimTokens(msg.sender)

IRs:
INTERNAL_CALL, KahnDistributionCentre.claimTokens(address)(msg.sender)""];
8->12;
9[label=""Node Type: IF 9

EXPRESSION:
payoutNow == 3

IRs:
TMP_168(bool) = payoutNow == 3
CONDITION TMP_168""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
claimImmediateTokens(msg.sender)

IRs:
INTERNAL_CALL, KahnDistributionCentre.claimImmediateTokens(address)(msg.sender)""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: END_IF 14
""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
ifNotStartExp()

IRs:
MODIFIER_CALL, KahnDistributionCentre.ifNotStartExp()()""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
ifNotPaused()

IRs:
MODIFIER_CALL, KahnDistributionCentre.ifNotPaused()()""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
ifNotBlacklisted()

IRs:
MODIFIER_CALL, KahnDistributionCentre.ifNotBlacklisted()()""];
17->1;
}
",0,1,1,0,ifNotStartExp();require(bool)(! blacklist[msg.sender]);payoutNow == 0;require(bool)(allowsSignup);payoutNow == 1;singleUserSignUp(msg.sender);;require(bool)(allowsSignup);payoutNow == 2;;claimTokens(msg.sender);payoutNow == 3;;claimImmediateTokens(msg.sender);;ifNotPaused();ifNotBlacklisted()
./0x0051d363a60bd98d8a10927d10708e5ef853b306_ext.sol,StandardToken.transferFrom,56,66,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x9c731584b4422c9f7f7cfd6909b36a72b76ae115_ext.sol,company_funding.withdraw,13,21,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2),TMP_4(bool) = keyHash == TMP_3,CONDITION TMP_4,TMP_5(bool) = msg.value > 400000000000000000,CONDITION TMP_5,TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),Transfer dest:msg.sender value:TMP_7","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
keyHash == keccak256()(abi.encodePacked(key))

IRs:
TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2)
TMP_4(bool) = keyHash == TMP_3
CONDITION TMP_4""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
msg.value > 400000000000000000

IRs:
TMP_5(bool) = msg.value > 400000000000000000
CONDITION TMP_5""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
Transfer dest:msg.sender value:TMP_7""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,1,0,0,require(bool)(msg.sender == tx.origin);keyHash == keccak256()(abi.encodePacked(key));msg.value > 400000000000000000;;msg.sender.transfer(address(this).balance);
./0x05b075b00cd4779e53dd646759b3c1087b37986a_ext.sol,TriLionToken.burnFrom,85,92,"REF_23(uint256) -> balances[_from],TMP_17(bool) = REF_23 < _value,CONDITION TMP_17,RETURN False,REF_24(mapping(address => uint256)) -> allowances[_from],REF_25(uint256) -> REF_24[msg.sender],TMP_18(bool) = _value > REF_25,CONDITION TMP_18,RETURN False,REF_26(uint256) -> balances[_from],REF_26(-> balances) = REF_26 - _value,_totalSupply(uint256) = _totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[_from] < _value

IRs:
REF_23(uint256) -> balances[_from]
TMP_17(bool) = REF_23 < _value
CONDITION TMP_17""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
_value > allowances[_from][msg.sender]

IRs:
REF_24(mapping(address => uint256)) -> allowances[_from]
REF_25(uint256) -> REF_24[msg.sender]
TMP_18(bool) = _value > REF_25
CONDITION TMP_18""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: RETURN 5

EXPRESSION:
false

IRs:
RETURN False""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[_from] -= _value

IRs:
REF_26(uint256) -> balances[_from]
REF_26(-> balances) = REF_26 - _value""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
_totalSupply -= _value

IRs:
_totalSupply(uint256) = _totalSupply - _value""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
9->10;
10[label=""Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True""];
11[label=""Node Type: RETURN 11

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[_from] < _value;false;;_value > allowances[_from][msg.sender];false;;balances[_from] -= _value;_totalSupply -= _value;Burn(_from,_value);true;success"
./0x474b4642fa37528652e907a2a3ef7ded8fec8cc8_ext.sol,Cyberminer.mintToken,207,212,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x5838f878000fe44b6f6c677bbf839e12f097c147_ext.sol,Q_GAME.NewQuestion,34,39,"TMP_12(bool) = msg.sender == questionSender,CONDITION TMP_12,question(string) := _question(string),responseHash(bytes32) := _responseHash(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == questionSender

IRs:
TMP_12(bool) = msg.sender == questionSender
CONDITION TMP_12""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
responseHash = _responseHash

IRs:
responseHash(bytes32) := _responseHash(bytes32)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,msg.sender == questionSender;question = _question;;responseHash = _responseHash
./0x1ba2626b5753b7a6cfe785ed9e28fb1c85793fa6_ext.sol,SLUTZToken.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x5304a4b788946f534088e9d8975ca8c1a3ded913_ext.sol,Ozcar.approveAndCall,141,146,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x2f664dccaef62d345d78b62a8095acc828e67e4c_ext.sol,FriendsFingersToken.approveAndCall,404,415,"TMP_172(bool) = INTERNAL_CALL, StandardToken.approve(address,uint256)(_spender,_amount),TMP_173(None) = SOLIDITY_CALL require(bool)(TMP_172),TMP_174 = CONVERT _spender to ContractReceiverInterface,HIGH_LEVEL_CALL, dest:TMP_174(ContractReceiverInterface), function:receiveApproval, arguments:['msg.sender', '_amount', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(approve(_spender,_amount))

IRs:
TMP_172(bool) = INTERNAL_CALL, StandardToken.approve(address,uint256)(_spender,_amount)
TMP_173(None) = SOLIDITY_CALL require(bool)(TMP_172)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ContractReceiverInterface(_spender).receiveApproval(msg.sender,_amount,this,_extraData)

IRs:
TMP_174 = CONVERT _spender to ContractReceiverInterface
HIGH_LEVEL_CALL, dest:TMP_174(ContractReceiverInterface), function:receiveApproval, arguments:['msg.sender', '_amount', 'this', '_extraData']  ""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
4[label=""Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(approve(_spender,_amount));ContractReceiverInterface(_spender).receiveApproval(msg.sender,_amount,this,_extraData);true;success"
./0xd38f3c46d20aa7021e486290a24e25eba1491909_ext.sol,IVNTToken.approveAndCall,217,222,"REF_23(mapping(address => uint256)) -> allowed[msg.sender],REF_24(uint256) -> REF_23[spender],REF_24(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_69 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_69(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_23(mapping(address => uint256)) -> allowed[msg.sender]
REF_24(uint256) -> REF_23[spender]
REF_24(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_69 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_69(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x7982a79ee90eb3682dcee66e47ba79c1cba44062_ext.sol,FlowerBase._transfer,170,178,"REF_9(uint256) -> ownerFlowersCount[_to],TMP_62(uint256) := REF_9(uint256),REF_9(-> ownerFlowersCount) = REF_9 + 1,REF_10(address) -> flowerIndexToOwner[_flowerId],REF_10(address) (->flowerIndexToOwner) := _to(address),TMP_63 = CONVERT 0 to address,TMP_64(bool) = _from != TMP_63,CONDITION TMP_64,REF_11(uint256) -> ownerFlowersCount[_from],TMP_65(uint256) := REF_11(uint256),REF_11(-> ownerFlowersCount) = REF_11 - 1,REF_12(address) -> flowerIndexToApproved[_flowerId],flowerIndexToApproved = delete REF_12 ,Emit Transfer(_from,_to,_flowerId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownerFlowersCount[_to] ++

IRs:
REF_9(uint256) -> ownerFlowersCount[_to]
TMP_62(uint256) := REF_9(uint256)
REF_9(-> ownerFlowersCount) = REF_9 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
flowerIndexToOwner[_flowerId] = _to

IRs:
REF_10(address) -> flowerIndexToOwner[_flowerId]
REF_10(address) (->flowerIndexToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_63 = CONVERT 0 to address
TMP_64(bool) = _from != TMP_63
CONDITION TMP_64""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownerFlowersCount[_from] --

IRs:
REF_11(uint256) -> ownerFlowersCount[_from]
TMP_65(uint256) := REF_11(uint256)
REF_11(-> ownerFlowersCount) = REF_11 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete flowerIndexToApproved[_flowerId]

IRs:
REF_12(address) -> flowerIndexToApproved[_flowerId]
flowerIndexToApproved = delete REF_12 ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_flowerId)

IRs:
Emit Transfer(_from,_to,_flowerId)""];
}
",0,1,0,0,"ownerFlowersCount[_to] ++;flowerIndexToOwner[_flowerId] = _to;_from != address(0);ownerFlowersCount[_from] --;;delete flowerIndexToApproved[_flowerId];Transfer(_from,_to,_flowerId)"
./0x920231a0e58d685f29ca3838777093fad88f665f_ext.sol,Moongang.blacklist_addys,172,176,"i(uint256) := 0(uint256),REF_36 -> LENGTH _addys,TMP_52(bool) = i < REF_36,CONDITION TMP_52,REF_37(address) -> _addys[i],REF_38(bool) -> whitelist[REF_37],REF_38(bool) (->whitelist) := False(bool),TMP_53(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Moongang.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _addys.length

IRs:
REF_36 -> LENGTH _addys
TMP_52(bool) = i < REF_36
CONDITION TMP_52""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
whitelist[_addys[i]] = false

IRs:
REF_37(address) -> _addys[i]
REF_38(bool) -> whitelist[REF_37]
REF_38(bool) (->whitelist) := False(bool)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_53(uint256) := i(uint256)
i(uint256) = i + 1""];
6->4;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Moongang.onlyOwner()()""];
7->3;
}
",0,1,0,0,onlyOwner();;i < _addys.length;;i = 0;whitelist[_addys[i]] = false;i ++
./0x51d9e05775bde1b3c12d781d2f847b1ab93e3c3d_ext.sol,EthAnte.fund,41,53,"TMP_1(bool) = msg.value >= 1000000000000000,TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1),TMP_3(bool) = timeOut <= now,CONDITION TMP_3,TMP_4 = CONVERT this to address,TMP_5(uint256) = SOLIDITY_CALL balance(address)(TMP_4),TMP_6(uint256) = TMP_5 - msg.value,TMP_7(uint256) = TMP_6 / feeRate,Transfer dest:TechnicalRise value:TMP_7,TMP_9 = CONVERT this to address,TMP_10(uint256) = SOLIDITY_CALL balance(address)(TMP_9),TMP_11(uint256) = TMP_10 - msg.value,TMP_12 = CONVERT this to address,TMP_13(uint256) = SOLIDITY_CALL balance(address)(TMP_12),TMP_14(uint256) = TMP_13 / feeRate,TMP_15(uint256) = TMP_11 - TMP_14,Transfer dest:lastBidder value:TMP_15,TMP_17(uint256) = now + 3600,timeOut(uint256) := TMP_17(uint256),lastBidder(address) := msg.sender(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= 1000000000000000)

IRs:
TMP_1(bool) = msg.value >= 1000000000000000
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
timeOut <= now

IRs:
TMP_3(bool) = timeOut <= now
CONDITION TMP_3""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
TechnicalRise.transfer((address(this).balance - msg.value) / feeRate)

IRs:
TMP_4 = CONVERT this to address
TMP_5(uint256) = SOLIDITY_CALL balance(address)(TMP_4)
TMP_6(uint256) = TMP_5 - msg.value
TMP_7(uint256) = TMP_6 / feeRate
Transfer dest:TechnicalRise value:TMP_7""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
lastBidder.transfer((address(this).balance - msg.value) - address(this).balance / feeRate)

IRs:
TMP_9 = CONVERT this to address
TMP_10(uint256) = SOLIDITY_CALL balance(address)(TMP_9)
TMP_11(uint256) = TMP_10 - msg.value
TMP_12 = CONVERT this to address
TMP_13(uint256) = SOLIDITY_CALL balance(address)(TMP_12)
TMP_14(uint256) = TMP_13 / feeRate
TMP_15(uint256) = TMP_11 - TMP_14
Transfer dest:lastBidder value:TMP_15""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
timeOut = now + 3600

IRs:
TMP_17(uint256) = now + 3600
timeOut(uint256) := TMP_17(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
lastBidder = msg.sender

IRs:
lastBidder(address) := msg.sender(address)""];
}
",0,1,0,0,require(bool)(msg.value >= 1000000000000000);timeOut <= now;TechnicalRise.transfer((address(this).balance - msg.value) / feeRate);;lastBidder.transfer((address(this).balance - msg.value) - address(this).balance / feeRate);timeOut = now + 3600;lastBidder = msg.sender
./0x446f174bc64cbca8b9fe81087798a156cfb863b7_ext.sol,Voting2018.getFile,68,74,"REF_20 -> LENGTH files,TMP_10(bool) = fileId < REF_20,CONDITION TMP_10,REF_21(Voting2018.File) -> files[fileId],REF_22(string) -> REF_21.content,REF_23(Voting2018.File) -> files[fileId],REF_24(string) -> REF_23.contentTime,REF_25(Voting2018.File) -> files[fileId],REF_26(string) -> REF_25.md5,REF_27(Voting2018.File) -> files[fileId],REF_28(string) -> REF_27.sha256,REF_29(Voting2018.File) -> files[fileId],REF_30(string) -> REF_29.sha1,REF_31(Voting2018.File) -> files[fileId],REF_32(string) -> REF_31.hashTime,RETURN REF_22,REF_24,REF_26,REF_28,REF_30,REF_32,RETURN ,,,,,,RETURN content,contentTime,_md5,_sha256,_sha1,hashTime","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
fileId < files.length

IRs:
REF_20 -> LENGTH files
TMP_10(bool) = fileId < REF_20
CONDITION TMP_10""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
(files[fileId].content,files[fileId].contentTime,files[fileId].md5,files[fileId].sha256,files[fileId].sha1,files[fileId].hashTime)

IRs:
REF_21(Voting2018.File) -> files[fileId]
REF_22(string) -> REF_21.content
REF_23(Voting2018.File) -> files[fileId]
REF_24(string) -> REF_23.contentTime
REF_25(Voting2018.File) -> files[fileId]
REF_26(string) -> REF_25.md5
REF_27(Voting2018.File) -> files[fileId]
REF_28(string) -> REF_27.sha256
REF_29(Voting2018.File) -> files[fileId]
REF_30(string) -> REF_29.sha1
REF_31(Voting2018.File) -> files[fileId]
REF_32(string) -> REF_31.hashTime
RETURN REF_22,REF_24,REF_26,REF_28,REF_30,REF_32""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
(,,,,,)

IRs:
RETURN ,,,,,""];
5[label=""Node Type: RETURN 5

EXPRESSION:
(content,contentTime,_md5,_sha256,_sha1,hashTime)

IRs:
RETURN content,contentTime,_md5,_sha256,_sha1,hashTime""];
}
",0,1,0,0,"fileId < files.length;(files[fileId].content,files[fileId].contentTime,files[fileId].md5,files[fileId].sha256,files[fileId].sha1,files[fileId].hashTime);;(,,,,,);(content,contentTime,_md5,_sha256,_sha1,hashTime)"
./0x00c2982959f852abbdb0f5ec023609ea1ca579e8_ext.sol,GAC._transfer,44,60,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xa3021edfceb3ae86ff67bf92b0d87f71a4eb0219_ext.sol,CrowdsaleToken.getBonuses,385,401,"TMP_150(bool) = now >= preIcoStartDate,TMP_151(bool) = now <= preIcoEndDate,TMP_152(bool) = TMP_150 && TMP_151,CONDITION TMP_152,TMP_153(bool) = _tokens >= bonusLimit1,CONDITION TMP_153,RETURN 30,TMP_154(bool) = _tokens >= bonusLimit2,CONDITION TMP_154,RETURN 25,TMP_155(bool) = _tokens >= bonusLimit3,CONDITION TMP_155,RETURN 20,TMP_156(bool) = _tokens >= bonusLimit4,CONDITION TMP_156,RETURN 15,TMP_157(bool) = _tokens >= bonusLimit5,CONDITION TMP_157,RETURN 10,TMP_158(bool) = now >= icoStartDate,TMP_159(bool) = now <= icoEndDate,TMP_160(bool) = TMP_158 && TMP_159,CONDITION TMP_160,TMP_161(uint256) = icoStartDate + bonusPeriod,TMP_162(bool) = now <= TMP_161,CONDITION TMP_162,RETURN 25,TMP_163(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['bonusPeriod', '2'] ,TMP_164(uint256) = icoStartDate + TMP_163,TMP_165(bool) = now <= TMP_164,CONDITION TMP_165,RETURN 20,TMP_166(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['bonusPeriod', '3'] ,TMP_167(uint256) = icoStartDate + TMP_166,TMP_168(bool) = now <= TMP_167,CONDITION TMP_168,RETURN 15,TMP_169(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['bonusPeriod', '4'] ,TMP_170(uint256) = icoStartDate + TMP_169,TMP_171(bool) = now <= TMP_170,CONDITION TMP_171,RETURN 10,RETURN 5,RETURN 0","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
now >= preIcoStartDate && now <= preIcoEndDate

IRs:
TMP_150(bool) = now >= preIcoStartDate
TMP_151(bool) = now <= preIcoEndDate
TMP_152(bool) = TMP_150 && TMP_151
CONDITION TMP_152""];
1->2[label=""True""];
1->17[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
_tokens >= bonusLimit1

IRs:
TMP_153(bool) = _tokens >= bonusLimit1
CONDITION TMP_153""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3

EXPRESSION:
30

IRs:
RETURN 30""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
_tokens >= bonusLimit2

IRs:
TMP_154(bool) = _tokens >= bonusLimit2
CONDITION TMP_154""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: RETURN 6

EXPRESSION:
25

IRs:
RETURN 25""];
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
_tokens >= bonusLimit3

IRs:
TMP_155(bool) = _tokens >= bonusLimit3
CONDITION TMP_155""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
20

IRs:
RETURN 20""];
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
_tokens >= bonusLimit4

IRs:
TMP_156(bool) = _tokens >= bonusLimit4
CONDITION TMP_156""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: RETURN 12

EXPRESSION:
15

IRs:
RETURN 15""];
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
_tokens >= bonusLimit5

IRs:
TMP_157(bool) = _tokens >= bonusLimit5
CONDITION TMP_157""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: RETURN 15

EXPRESSION:
10

IRs:
RETURN 10""];
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: IF 18

EXPRESSION:
now >= icoStartDate && now <= icoEndDate

IRs:
TMP_158(bool) = now >= icoStartDate
TMP_159(bool) = now <= icoEndDate
TMP_160(bool) = TMP_158 && TMP_159
CONDITION TMP_160""];
18->19[label=""True""];
18->32[label=""False""];
19[label=""Node Type: IF 19

EXPRESSION:
now <= icoStartDate + bonusPeriod

IRs:
TMP_161(uint256) = icoStartDate + bonusPeriod
TMP_162(bool) = now <= TMP_161
CONDITION TMP_162""];
19->20[label=""True""];
19->21[label=""False""];
20[label=""Node Type: RETURN 20

EXPRESSION:
25

IRs:
RETURN 25""];
21[label=""Node Type: END_IF 21
""];
21->22;
22[label=""Node Type: IF 22

EXPRESSION:
now <= icoStartDate + bonusPeriod.mul(2)

IRs:
TMP_163(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['bonusPeriod', '2'] 
TMP_164(uint256) = icoStartDate + TMP_163
TMP_165(bool) = now <= TMP_164
CONDITION TMP_165""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: RETURN 23

EXPRESSION:
20

IRs:
RETURN 20""];
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: IF 25

EXPRESSION:
now <= icoStartDate + bonusPeriod.mul(3)

IRs:
TMP_166(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['bonusPeriod', '3'] 
TMP_167(uint256) = icoStartDate + TMP_166
TMP_168(bool) = now <= TMP_167
CONDITION TMP_168""];
25->26[label=""True""];
25->27[label=""False""];
26[label=""Node Type: RETURN 26

EXPRESSION:
15

IRs:
RETURN 15""];
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: IF 28

EXPRESSION:
now <= icoStartDate + bonusPeriod.mul(4)

IRs:
TMP_169(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['bonusPeriod', '4'] 
TMP_170(uint256) = icoStartDate + TMP_169
TMP_171(bool) = now <= TMP_170
CONDITION TMP_171""];
28->29[label=""True""];
28->30[label=""False""];
29[label=""Node Type: RETURN 29

EXPRESSION:
10

IRs:
RETURN 10""];
30[label=""Node Type: END_IF 30
""];
30->31;
31[label=""Node Type: RETURN 31

EXPRESSION:
5

IRs:
RETURN 5""];
32[label=""Node Type: END_IF 32
""];
32->33;
33[label=""Node Type: RETURN 33

EXPRESSION:
0

IRs:
RETURN 0""];
}
",0,1,0,0,now >= preIcoStartDate && now <= preIcoEndDate;_tokens >= bonusLimit1;;30;;_tokens >= bonusLimit2;25;;_tokens >= bonusLimit3;20;;_tokens >= bonusLimit4;15;;_tokens >= bonusLimit5;10;;now >= icoStartDate && now <= icoEndDate;now <= icoStartDate + bonusPeriod;;25;;now <= icoStartDate + bonusPeriod.mul(2);20;;now <= icoStartDate + bonusPeriod.mul(3);15;;now <= icoStartDate + bonusPeriod.mul(4);10;;5;0
./0x2d50c2dd998aab26a666a5e9f15e7f32ad9e8ce1_ext.sol,VOCC_I073_20181211.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x28577a6d31559bd265ce3adb62d0458550f7b8a7_ext.sol,CCCToken.burn,110,116,"REF_13(uint256) -> balanceOf[msg.sender],TMP_15(bool) = REF_13 >= _value,TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15),REF_14(uint256) -> balanceOf[msg.sender],REF_14(-> balanceOf) = REF_14 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_13(uint256) -> balanceOf[msg.sender]
TMP_15(bool) = REF_13 >= _value
TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_14(uint256) -> balanceOf[msg.sender]
REF_14(-> balanceOf) = REF_14 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xecab747bebdbc679ae03349ae325399b0ad7092c_ext.sol,VOCC_I012_20181211.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x06df6fdbf7629c71aee3f468ba1ab702fa0abec9_ext.sol,CustodyStorage.removeCustody,303,320,"REF_10(address) -> custodiesArray[_arrayIndex],TMP_87(bool) = REF_10 == _custodyAddress,TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87),TMP_89(uint256) = custodyCounter - 1,TMP_90(bool) = _arrayIndex == TMP_89,CONDITION TMP_90,REF_11(bool) -> custodiesMap[_custodyAddress],REF_11(bool) (->custodiesMap) := False(bool),Emit CustodyRemoved(_custodyAddress),TMP_92(uint256) := custodyCounter(uint256),custodyCounter(uint256) = custodyCounter - 1,REF_12(bool) -> custodiesMap[_custodyAddress],REF_12(bool) (->custodiesMap) := False(bool),REF_13(address) -> custodiesArray[_arrayIndex],TMP_93(uint256) = custodyCounter - 1,REF_14(address) -> custodiesArray[TMP_93],REF_13(address) (->custodiesArray) := REF_14(address),TMP_94(uint256) := custodyCounter(uint256),custodyCounter(uint256) = custodyCounter - 1,Emit CustodyRemoved(_custodyAddress),MODIFIER_CALL, CustodyStorage.onlyManager()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(custodiesArray[_arrayIndex] == _custodyAddress)

IRs:
REF_10(address) -> custodiesArray[_arrayIndex]
TMP_87(bool) = REF_10 == _custodyAddress
TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
_arrayIndex == custodyCounter - 1

IRs:
TMP_89(uint256) = custodyCounter - 1
TMP_90(bool) = _arrayIndex == TMP_89
CONDITION TMP_90""];
2->3[label=""True""];
2->7[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
custodiesMap[_custodyAddress] = false

IRs:
REF_11(bool) -> custodiesMap[_custodyAddress]
REF_11(bool) (->custodiesMap) := False(bool)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
CustodyRemoved(_custodyAddress)

IRs:
Emit CustodyRemoved(_custodyAddress)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
custodyCounter --

IRs:
TMP_92(uint256) := custodyCounter(uint256)
custodyCounter(uint256) = custodyCounter - 1""];
5->6;
6[label=""Node Type: RETURN 6
""];
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
custodiesMap[_custodyAddress] = false

IRs:
REF_12(bool) -> custodiesMap[_custodyAddress]
REF_12(bool) (->custodiesMap) := False(bool)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
custodiesArray[_arrayIndex] = custodiesArray[custodyCounter - 1]

IRs:
REF_13(address) -> custodiesArray[_arrayIndex]
TMP_93(uint256) = custodyCounter - 1
REF_14(address) -> custodiesArray[TMP_93]
REF_13(address) (->custodiesArray) := REF_14(address)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
custodyCounter --

IRs:
TMP_94(uint256) := custodyCounter(uint256)
custodyCounter(uint256) = custodyCounter - 1""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
CustodyRemoved(_custodyAddress)

IRs:
Emit CustodyRemoved(_custodyAddress)""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyManager()

IRs:
MODIFIER_CALL, CustodyStorage.onlyManager()()""];
12->1;
}
",0,1,0,0,onlyManager();require(bool)(custodiesArray[_arrayIndex] == _custodyAddress);_arrayIndex == custodyCounter - 1;custodiesMap[_custodyAddress] = false;;CustodyRemoved(_custodyAddress);custodyCounter --;;custodiesMap[_custodyAddress] = false;custodiesArray[_arrayIndex] = custodiesArray[custodyCounter - 1];custodyCounter --;CustodyRemoved(_custodyAddress)
./0x5c13a9ad2601eeec34672c655d2ca994a360c4a0_ext.sol,GalacticX.mintToken,208,213,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0xce4726859edc21f0acd5acf8f852f42a1a2dd54b_ext.sol,StandardToken.transferFrom,56,66,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x17633a41ab9af8b78317a1bd92a985f8482677f9_ext.sol,PrivateSocialPlatform.burnFrom,79,86,"REF_20(uint256) -> balanceOf[_from],TMP_26(bool) = REF_20 < _value,CONDITION TMP_26,TMP_27(None) = SOLIDITY_CALL revert()(),REF_21(mapping(address => uint256)) -> allowance[_from],REF_22(uint256) -> REF_21[msg.sender],TMP_28(bool) = _value > REF_22,CONDITION TMP_28,TMP_29(None) = SOLIDITY_CALL revert()(),REF_23(uint256) -> balanceOf[_from],REF_23(-> balanceOf) = REF_23 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balanceOf[_from] < _value

IRs:
REF_20(uint256) -> balanceOf[_from]
TMP_26(bool) = REF_20 < _value
CONDITION TMP_26""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_27(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
_value > allowance[_from][msg.sender]

IRs:
REF_21(mapping(address => uint256)) -> allowance[_from]
REF_22(uint256) -> REF_21[msg.sender]
TMP_28(bool) = _value > REF_22
CONDITION TMP_28""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
revert()()

IRs:
TMP_29(None) = SOLIDITY_CALL revert()()""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_23(uint256) -> balanceOf[_from]
REF_23(-> balanceOf) = REF_23 - _value""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
9->10;
10[label=""Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True""];
11[label=""Node Type: RETURN 11

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balanceOf[_from] < _value;revert()();;_value > allowance[_from][msg.sender];revert()();;balanceOf[_from] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x6f328f0a7cd638cda9fed876abf71423ca109fe1_ext.sol,TokenERC20.burnFrom,176,184,"REF_26(uint256) -> balanceOf[_from],TMP_41(bool) = REF_26 >= _value,TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41),REF_27(mapping(address => uint256)) -> allowance[_from],REF_28(uint256) -> REF_27[msg.sender],TMP_43(bool) = _value <= REF_28,TMP_44(None) = SOLIDITY_CALL require(bool)(TMP_43),REF_29(uint256) -> balanceOf[_from],REF_29(-> balanceOf) = REF_29 - _value,REF_30(mapping(address => uint256)) -> allowance[_from],REF_31(uint256) -> REF_30[msg.sender],REF_31(-> allowance) = REF_31 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_26(uint256) -> balanceOf[_from]
TMP_41(bool) = REF_26 >= _value
TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_27(mapping(address => uint256)) -> allowance[_from]
REF_28(uint256) -> REF_27[msg.sender]
TMP_43(bool) = _value <= REF_28
TMP_44(None) = SOLIDITY_CALL require(bool)(TMP_43)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_29(uint256) -> balanceOf[_from]
REF_29(-> balanceOf) = REF_29 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_30(mapping(address => uint256)) -> allowance[_from]
REF_31(uint256) -> REF_30[msg.sender]
REF_31(-> allowance) = REF_31 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xf084d5bc3e35e3d903260267ebd545c49c6013d0_ext.sol,DimonCoin.distributeFUD,42,51,"i(uint256) := 0(uint256),REF_1 -> LENGTH addresses,TMP_2(bool) = i < REF_1,CONDITION TMP_2,REF_2(address) -> addresses[i],TMP_3(uint256) = INTERNAL_CALL, DimonCoin.getEthBalance(address)(REF_2),TMP_4(bool) = TMP_3 < _ethbal,CONDITION TMP_4,REF_3(uint256) -> balances[owner],REF_3(-> balances) = REF_3 - _value,REF_4(address) -> addresses[i],REF_5(uint256) -> balances[REF_4],REF_5(-> balances) = REF_5 + _value,REF_6(address) -> addresses[i],Emit Transfer(owner,REF_6,_value),TMP_6(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, DimonCoin.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addresses.length

IRs:
REF_1 -> LENGTH addresses
TMP_2(bool) = i < REF_1
CONDITION TMP_2""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
getEthBalance(addresses[i]) < _ethbal

IRs:
REF_2(address) -> addresses[i]
TMP_3(uint256) = INTERNAL_CALL, DimonCoin.getEthBalance(address)(REF_2)
TMP_4(bool) = TMP_3 < _ethbal
CONDITION TMP_4""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: CONTINUE 6
""];
6->11;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[owner] -= _value

IRs:
REF_3(uint256) -> balances[owner]
REF_3(-> balances) = REF_3 - _value""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
balances[addresses[i]] += _value

IRs:
REF_4(address) -> addresses[i]
REF_5(uint256) -> balances[REF_4]
REF_5(-> balances) = REF_5 + _value""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Transfer(owner,addresses[i],_value)

IRs:
REF_6(address) -> addresses[i]
Emit Transfer(owner,REF_6,_value)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_6(uint256) := i(uint256)
i(uint256) = i + 1""];
11->4;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, DimonCoin.onlyOwner()()""];
12->3;
}
",0,1,0,0,"onlyOwner();;i < addresses.length;;i = 0;getEthBalance(addresses[i]) < _ethbal;;;i ++;balances[owner] -= _value;balances[addresses[i]] += _value;Transfer(owner,addresses[i],_value)"
./0x0e7d77bf4c468b6b626b07be5aa1c8222eb08324_ext.sol,Proof.dividendsOf,307,309,"REF_34(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_63(uint256) = profitPerShare_ * REF_34,TMP_64 = CONVERT TMP_63 to int256,REF_35(int256) -> payoutsTo_[_customerAddress],TMP_65(int256) = TMP_64 - REF_35,TMP_66 = CONVERT TMP_65 to uint256,TMP_67(uint256) = TMP_66 / magnitude,RETURN TMP_67","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_34(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_63(uint256) = profitPerShare_ * REF_34
TMP_64 = CONVERT TMP_63 to int256
REF_35(int256) -> payoutsTo_[_customerAddress]
TMP_65(int256) = TMP_64 - REF_35
TMP_66 = CONVERT TMP_65 to uint256
TMP_67(uint256) = TMP_66 / magnitude
RETURN TMP_67""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0xf2249b2f36a21185ab97f83214cd8fc5802bb8a0_ext.sol,BLCToken.transferFrom,28,36,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x7830cda4a9a2e8fb28b5250d72ede4536b9ff4a0_ext.sol,LLTokenBTB._transfer,45,61,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xdb5e04dc9c94bc8310e8885c85a4d0666ccaecae_ext.sol,EtherBrand._transfer,325,331,"REF_201(EtherBrand.Brand) -> brands[_brand_id],REF_202(address) -> REF_201.owner,REF_202(address) (->brands) := _to(address),REF_203(EtherBrand.Brand) -> brands[_brand_id],REF_204(address) -> REF_203.approve_transfer_to,TMP_211 = CONVERT 0 to address,REF_204(address) (->brands) := TMP_211(address),REF_205(uint256) -> ownerCount[_from],REF_205(-> ownerCount) = REF_205 - 1,REF_206(uint256) -> ownerCount[_to],REF_206(-> ownerCount) = REF_206 + 1,Emit Transfer(_from,_to,_brand_id)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
brands[_brand_id].owner = _to

IRs:
REF_201(EtherBrand.Brand) -> brands[_brand_id]
REF_202(address) -> REF_201.owner
REF_202(address) (->brands) := _to(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
brands[_brand_id].approve_transfer_to = address(0)

IRs:
REF_203(EtherBrand.Brand) -> brands[_brand_id]
REF_204(address) -> REF_203.approve_transfer_to
TMP_211 = CONVERT 0 to address
REF_204(address) (->brands) := TMP_211(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ownerCount[_from] -= 1

IRs:
REF_205(uint256) -> ownerCount[_from]
REF_205(-> ownerCount) = REF_205 - 1""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownerCount[_to] += 1

IRs:
REF_206(uint256) -> ownerCount[_to]
REF_206(-> ownerCount) = REF_206 + 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_brand_id)

IRs:
Emit Transfer(_from,_to,_brand_id)""];
}
",0,1,0,0,"brands[_brand_id].owner = _to;brands[_brand_id].approve_transfer_to = address(0);ownerCount[_from] -= 1;ownerCount[_to] += 1;Transfer(_from,_to,_brand_id)"
./0xf3e6264475f63d771ca562a5176fb9a9b79acd67_ext.sol,Celer.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x0305b4ccbfd603d92ca0d5eae752000273e26a60_ext.sol,TokenERC20.burnFrom,149,157,"REF_19(uint256) -> balanceOf[_from],TMP_26(bool) = REF_19 >= _value,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_28(bool) = _value <= REF_21,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_26(bool) = REF_19 >= _value
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_28(bool) = _value <= REF_21
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x50fb2403b415c4ce2c94c7bf7cbfa36145fc5cbf_ext.sol,SCCC._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x1f313e1015d362a50a16a479f857637bbb36a353_ext.sol,LineOfTransfers.addData,56,63,"REF_5 -> LENGTH _accounts,REF_6 -> LENGTH _values,TMP_8(bool) = REF_5 == REF_6,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),i(uint256) := 0(uint256),REF_7 -> LENGTH _accounts,TMP_10(bool) = i < REF_7,CONDITION TMP_10,REF_9(address) -> _accounts[i],REF_10 -> LENGTH accounts,TMP_12(uint256) := REF_10(uint256),TMP_13(uint256) = TMP_12 + 1,REF_10(uint256) (->accounts) := TMP_13(uint256),REF_11(address) -> accounts[TMP_12],REF_11(address) (->accounts) := REF_9(address),REF_13(uint256) -> _values[i],REF_14 -> LENGTH values,TMP_15(uint256) := REF_14(uint256),TMP_16(uint256) = TMP_15 + 1,REF_14(uint256) (->values) := TMP_16(uint256),REF_15(uint256) -> values[TMP_15],REF_15(uint256) (->values) := REF_13(uint256),TMP_17(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, LineOfTransfers.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_accounts.length == _values.length)

IRs:
REF_5 -> LENGTH _accounts
REF_6 -> LENGTH _values
TMP_8(bool) = REF_5 == REF_6
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < _accounts.length

IRs:
REF_7 -> LENGTH _accounts
TMP_10(bool) = i < REF_7
CONDITION TMP_10""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
accounts.push(_accounts[i])

IRs:
REF_9(address) -> _accounts[i]
REF_10 -> LENGTH accounts
TMP_12(uint256) := REF_10(uint256)
TMP_13(uint256) = TMP_12 + 1
REF_10(uint256) (->accounts) := TMP_13(uint256)
REF_11(address) -> accounts[TMP_12]
REF_11(address) (->accounts) := REF_9(address)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
values.push(_values[i])

IRs:
REF_13(uint256) -> _values[i]
REF_14 -> LENGTH values
TMP_15(uint256) := REF_14(uint256)
TMP_16(uint256) = TMP_15 + 1
REF_14(uint256) (->values) := TMP_16(uint256)
REF_15(uint256) -> values[TMP_15]
REF_15(uint256) (->values) := REF_13(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_17(uint256) := i(uint256)
i(uint256) = i + 1""];
8->5;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, LineOfTransfers.onlyOwner()()""];
9->1;
}
",0,1,0,0,onlyOwner();require(bool)(_accounts.length == _values.length);i = 0;;i < _accounts.length;;accounts.push(_accounts[i]);values.push(_values[i]);i ++
./0x1d2196207512665ad3beb7c3641f7db409dc7beb_ext.sol,BitcoinBLUE.burn,125,131,"REF_17(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_17 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_17 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x1c3a7bafd90133756ac63fee437844c47f707420_ext.sol,ZenswapDistribution.distributeToken,44,54,"REF_0 -> LENGTH _addresses,addressCount(uint256) := REF_0(uint256),REF_1 -> LENGTH _amount,amountCount(uint256) := REF_1(uint256),TMP_5(bool) = addressCount == amountCount,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),i(uint256) := 0(uint256),TMP_7(bool) = i < addressCount,CONDITION TMP_7,REF_2(uint256) -> _amount[i],TMP_8 = CONVERT 18 to uint256,TMP_9(uint256) = 10 ** TMP_8,TMP_10(uint256) = REF_2 * TMP_9,_tokensAmount(uint256) := TMP_10(uint256),REF_4(address) -> _addresses[i],HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['REF_4', '_tokensAmount']  ,TMP_12(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
addressCount = _addresses.length

IRs:
REF_0 -> LENGTH _addresses
addressCount(uint256) := REF_0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amountCount = _amount.length

IRs:
REF_1 -> LENGTH _amount
amountCount(uint256) := REF_1(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(addressCount == amountCount)

IRs:
TMP_5(bool) = addressCount == amountCount
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
3->6;
4[label=""Node Type: BEGIN_LOOP 4
""];
4->7;
5[label=""Node Type: END_LOOP 5
""];
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
6->4;
7[label=""Node Type: IF_LOOP 7

EXPRESSION:
i < addressCount

IRs:
TMP_7(bool) = i < addressCount
CONDITION TMP_7""];
7->8[label=""True""];
7->5[label=""False""];
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
_tokensAmount = _amount[i] * 10 ** uint256(18)

IRs:
REF_2(uint256) -> _amount[i]
TMP_8 = CONVERT 18 to uint256
TMP_9(uint256) = 10 ** TMP_8
TMP_10(uint256) = REF_2 * TMP_9
_tokensAmount(uint256) := TMP_10(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
tokenReward.transfer(_addresses[i],_tokensAmount)

IRs:
REF_4(address) -> _addresses[i]
HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['REF_4', '_tokensAmount']  ""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
i ++

IRs:
TMP_12(uint256) := i(uint256)
i(uint256) = i + 1""];
10->7;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
11->1;
}
",0,1,0,0,"onlyOwner();addressCount = _addresses.length;amountCount = _amount.length;require(bool)(addressCount == amountCount);i = 0;;i < addressCount;;_tokensAmount = _amount[i] * 10 ** uint256(18);tokenReward.transfer(_addresses[i],_tokensAmount);i ++"
./0x17987e621eb8c09f62bc10c90204238cc8cbbe94_ext.sol,coc._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x4c7c98c4d64c29ef8103b005eeccf5145cfdf8c1_ext.sol,Savings.deposit,30,35,"TMP_4(bool) = msg.value >= 1000000000000000000,CONDITION TMP_4,REF_0(uint256) -> deposits[msg.sender],REF_0(-> deposits) = REF_0 + msg.value,Emit Deposit(msg.sender,msg.value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value >= 1000000000000000000

IRs:
TMP_4(bool) = msg.value >= 1000000000000000000
CONDITION TMP_4""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
deposits[msg.sender] += msg.value

IRs:
REF_0(uint256) -> deposits[msg.sender]
REF_0(-> deposits) = REF_0 + msg.value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Deposit(msg.sender,msg.value)

IRs:
Emit Deposit(msg.sender,msg.value)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,"msg.value >= 1000000000000000000;deposits[msg.sender] += msg.value;;Deposit(msg.sender,msg.value)"
./0xa19118ddbabbf3d538db6a46578f3260e26b89b9_ext.sol,Vault.withdraw,12,20,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2),TMP_4(bool) = keyHash == TMP_3,CONDITION TMP_4,TMP_5(bool) = msg.value > 500000000000000000,CONDITION TMP_5,TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),Transfer dest:msg.sender value:TMP_7","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
keyHash == keccak256()(abi.encodePacked(key))

IRs:
TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2)
TMP_4(bool) = keyHash == TMP_3
CONDITION TMP_4""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
msg.value > 500000000000000000

IRs:
TMP_5(bool) = msg.value > 500000000000000000
CONDITION TMP_5""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
Transfer dest:msg.sender value:TMP_7""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,1,0,0,require(bool)(msg.sender == tx.origin);keyHash == keccak256()(abi.encodePacked(key));msg.value > 500000000000000000;;msg.sender.transfer(address(this).balance);
./0x1eae15d9f4fa16f5278d02d2f8bda8b0dcd31f71_ext.sol,ExceedIOToken._transfer,41,57,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x1c9be00d799132986edcd2d099b9f28e5757677c_ext.sol,_0xEtherToken.approveAndCall,308,313,"REF_41(mapping(address => uint256)) -> allowed[msg.sender],REF_42(uint256) -> REF_41[spender],REF_42(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_78 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_78(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_41(mapping(address => uint256)) -> allowed[msg.sender]
REF_42(uint256) -> REF_41[spender]
REF_42(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_78 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_78(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x334eec1482109bd802d9e72a447848de3bcc1063_ext.sol,AirDropToken.transferFrom,69,82,"REF_7(mapping(address => uint256)) -> _allowed[from],REF_8(uint256) -> REF_7[msg.sender],TMP_4(bool) = REF_8 < amount,REF_9(uint256) -> _balances[from],TMP_5(bool) = REF_9 < amount,TMP_6(bool) = TMP_4 || TMP_5,CONDITION TMP_6,RETURN False,REF_10(uint256) -> _balances[from],REF_10(-> _balances) = REF_10 - amount,REF_11(mapping(address => uint256)) -> _allowed[from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> _allowed) = REF_12 - amount,REF_13(uint256) -> _balances[to],REF_13(-> _balances) = REF_13 + amount,Emit Transfer(from,to,amount),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_allowed[from][msg.sender] < amount || _balances[from] < amount

IRs:
REF_7(mapping(address => uint256)) -> _allowed[from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_4(bool) = REF_8 < amount
REF_9(uint256) -> _balances[from]
TMP_5(bool) = REF_9 < amount
TMP_6(bool) = TMP_4 || TMP_5
CONDITION TMP_6""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
_balances[from] -= amount

IRs:
REF_10(uint256) -> _balances[from]
REF_10(-> _balances) = REF_10 - amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_allowed[from][msg.sender] -= amount

IRs:
REF_11(mapping(address => uint256)) -> _allowed[from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> _allowed) = REF_12 - amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
_balances[to] += amount

IRs:
REF_13(uint256) -> _balances[to]
REF_13(-> _balances) = REF_13 + amount""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(from,to,amount)

IRs:
Emit Transfer(from,to,amount)""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"_allowed[from][msg.sender] < amount || _balances[from] < amount;false;;_balances[from] -= amount;_allowed[from][msg.sender] -= amount;_balances[to] += amount;Transfer(from,to,amount);true;success"
./0xec8e410316bd8d45cf660fdfd1fbd9eeafe9ed6c_ext.sol,MonsterBase._transfer,1573,1589,"REF_124(uint256) -> ownershipTokenCount[_to],TMP_1156(uint256) := REF_124(uint256),REF_124(-> ownershipTokenCount) = REF_124 + 1,REF_125(address) -> monsterIndexToOwner[_tokenId],REF_125(address) (->monsterIndexToOwner) := _to(address),TMP_1157 = CONVERT 0 to address,TMP_1158(bool) = _from != TMP_1157,CONDITION TMP_1158,REF_126(uint256) -> ownershipTokenCount[_from],TMP_1159(uint256) := REF_126(uint256),REF_126(-> ownershipTokenCount) = REF_126 - 1,REF_127(address) -> sireAllowedToAddress[_tokenId],sireAllowedToAddress = delete REF_127 ,REF_128(address) -> monsterIndexToApproved[_tokenId],monsterIndexToApproved = delete REF_128 ,Emit Transfer(_from,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownershipTokenCount[_to] ++

IRs:
REF_124(uint256) -> ownershipTokenCount[_to]
TMP_1156(uint256) := REF_124(uint256)
REF_124(-> ownershipTokenCount) = REF_124 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
monsterIndexToOwner[_tokenId] = _to

IRs:
REF_125(address) -> monsterIndexToOwner[_tokenId]
REF_125(address) (->monsterIndexToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_1157 = CONVERT 0 to address
TMP_1158(bool) = _from != TMP_1157
CONDITION TMP_1158""];
3->4[label=""True""];
3->7[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownershipTokenCount[_from] --

IRs:
REF_126(uint256) -> ownershipTokenCount[_from]
TMP_1159(uint256) := REF_126(uint256)
REF_126(-> ownershipTokenCount) = REF_126 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete sireAllowedToAddress[_tokenId]

IRs:
REF_127(address) -> sireAllowedToAddress[_tokenId]
sireAllowedToAddress = delete REF_127 ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
delete monsterIndexToApproved[_tokenId]

IRs:
REF_128(address) -> monsterIndexToApproved[_tokenId]
monsterIndexToApproved = delete REF_128 ""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
}
",0,1,0,0,"ownershipTokenCount[_to] ++;monsterIndexToOwner[_tokenId] = _to;_from != address(0);ownershipTokenCount[_from] --;;delete sireAllowedToAddress[_tokenId];delete monsterIndexToApproved[_tokenId];Transfer(_from,_to,_tokenId)"
./0x35027a992a3c232dd7a350bb75004ad8567561b2_ext.sol,EasyInvestForever.fallback,34,55,"TMP_0(bool) = block.number >= nextBlock,CONDITION TMP_0,TMP_1 = CONVERT this to address,TMP_2(uint256) = SOLIDITY_CALL balance(address)(TMP_1),currentBalance(uint256) := TMP_2(uint256),TMP_3(bool) = currentBalance < previousBalance,CONDITION TMP_3,currentBalance(uint256) := previousBalance(uint256),TMP_4(uint256) = currentBalance - previousBalance,TMP_5(uint256) = TMP_4 / 10000000000000000000,TMP_6(uint256) = TMP_5 + 1,interestRate(uint256) := TMP_6(uint256),previousBalance(uint256) := currentBalance(uint256),TMP_7(uint256) = block.number - nextBlock,TMP_8(uint256) = TMP_7 / 5900,TMP_9(uint256) = TMP_8 + 1,TMP_10(uint256) = 5900 * TMP_9,nextBlock(uint256) = nextBlock + TMP_10,REF_0(uint256) -> invested[msg.sender],TMP_11(bool) = REF_0 != 0,CONDITION TMP_11,REF_1(uint256) -> invested[msg.sender],TMP_12(uint256) = REF_1 * interestRate,TMP_13(uint256) = TMP_12 / 100,REF_2(uint256) -> atBlock[msg.sender],TMP_14(uint256) = block.number - REF_2,TMP_15(uint256) = TMP_13 * TMP_14,TMP_16(uint256) = TMP_15 / 5900,amount(uint256) := TMP_16(uint256),Transfer dest:msg.sender value:amount,REF_4(uint256) -> atBlock[msg.sender],REF_4(uint256) (->atBlock) := block.number(uint256),REF_5(uint256) -> invested[msg.sender],REF_5(-> invested) = REF_5 + msg.value,TMP_18(bool) = interestRate > 10,CONDITION TMP_18,interestRate(uint256) := 10(uint256),REF_6(uint256) -> invested[msg.sender],TMP_19(uint256) = REF_6 / 10,TMP_20(bool) = amount > TMP_19,CONDITION TMP_20,REF_7(uint256) -> invested[msg.sender],TMP_21(uint256) = REF_7 / 10,amount(uint256) := TMP_21(uint256),amount(uint256) := amount(uint256),TMP_22(bool) = interestRate < 1,CONDITION TMP_22,interestRate(uint256) := 1(uint256),interestRate(uint256) := interestRate(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
block.number >= nextBlock

IRs:
TMP_0(bool) = block.number >= nextBlock
CONDITION TMP_0""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
currentBalance = address(this).balance

IRs:
TMP_1 = CONVERT this to address
TMP_2(uint256) = SOLIDITY_CALL balance(address)(TMP_1)
currentBalance(uint256) := TMP_2(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
currentBalance < previousBalance

IRs:
TMP_3(bool) = currentBalance < previousBalance
CONDITION TMP_3""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
currentBalance = previousBalance

IRs:
currentBalance(uint256) := previousBalance(uint256)""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
interestRate = (currentBalance - previousBalance) / 10e18 + 1

IRs:
TMP_4(uint256) = currentBalance - previousBalance
TMP_5(uint256) = TMP_4 / 10000000000000000000
TMP_6(uint256) = TMP_5 + 1
interestRate(uint256) := TMP_6(uint256)""];
6->18;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
previousBalance = currentBalance

IRs:
previousBalance(uint256) := currentBalance(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
nextBlock += 5900 * ((block.number - nextBlock) / 5900 + 1)

IRs:
TMP_7(uint256) = block.number - nextBlock
TMP_8(uint256) = TMP_7 / 5900
TMP_9(uint256) = TMP_8 + 1
TMP_10(uint256) = 5900 * TMP_9
nextBlock(uint256) = nextBlock + TMP_10""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
invested[msg.sender] != 0

IRs:
REF_0(uint256) -> invested[msg.sender]
TMP_11(bool) = REF_0 != 0
CONDITION TMP_11""];
11->12[label=""True""];
11->15[label=""False""];
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
amount = invested[msg.sender] * interestRate / 100 * (block.number - atBlock[msg.sender]) / 5900

IRs:
REF_1(uint256) -> invested[msg.sender]
TMP_12(uint256) = REF_1 * interestRate
TMP_13(uint256) = TMP_12 / 100
REF_2(uint256) -> atBlock[msg.sender]
TMP_14(uint256) = block.number - REF_2
TMP_15(uint256) = TMP_13 * TMP_14
TMP_16(uint256) = TMP_15 / 5900
amount(uint256) := TMP_16(uint256)""];
12->22;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
atBlock[msg.sender] = block.number

IRs:
REF_4(uint256) -> atBlock[msg.sender]
REF_4(uint256) (->atBlock) := block.number(uint256)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
invested[msg.sender] += msg.value

IRs:
REF_5(uint256) -> invested[msg.sender]
REF_5(-> invested) = REF_5 + msg.value""];
18[label=""Node Type: IF 18

EXPRESSION:
(interestRate > 10)

IRs:
TMP_18(bool) = interestRate > 10
CONDITION TMP_18""];
18->19[label=""True""];
18->26[label=""False""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
interestRate = 10

IRs:
interestRate(uint256) := 10(uint256)""];
19->21;
21[label=""Node Type: END_IF 21
""];
21->8;
22[label=""Node Type: IF 22

EXPRESSION:
(amount > invested[msg.sender] / 10)

IRs:
REF_6(uint256) -> invested[msg.sender]
TMP_19(uint256) = REF_6 / 10
TMP_20(bool) = amount > TMP_19
CONDITION TMP_20""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
amount = invested[msg.sender] / 10

IRs:
REF_7(uint256) -> invested[msg.sender]
TMP_21(uint256) = REF_7 / 10
amount(uint256) := TMP_21(uint256)""];
23->25;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
amount = amount

IRs:
amount(uint256) := amount(uint256)""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->14;
26[label=""Node Type: IF 26

EXPRESSION:
(interestRate < 1)

IRs:
TMP_22(bool) = interestRate < 1
CONDITION TMP_22""];
26->27[label=""True""];
26->28[label=""False""];
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
interestRate = 1

IRs:
interestRate(uint256) := 1(uint256)""];
27->29;
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
interestRate = interestRate

IRs:
interestRate(uint256) := interestRate(uint256)""];
28->29;
29[label=""Node Type: END_IF 29
""];
29->21;
}
",0,1,0,0,block.number >= nextBlock;currentBalance = address(this).balance;;currentBalance < previousBalance;currentBalance = previousBalance;;interestRate = (currentBalance - previousBalance) / 10e18 + 1;(interestRate > 10);previousBalance = currentBalance;nextBlock += 5900 * ((block.number - nextBlock) / 5900 + 1);invested[msg.sender] != 0;amount = invested[msg.sender] * interestRate / 100 * (block.number - atBlock[msg.sender]) / 5900;;(amount > invested[msg.sender] / 10);msg.sender.transfer(amount);atBlock[msg.sender] = block.number;invested[msg.sender] += msg.value;interestRate = 10;(interestRate < 1);;amount = invested[msg.sender] / 10;amount = amount;;interestRate = 1;interestRate = interestRate;
./0x330b37346f0e759ad29af0221d249f5227876ac4_ext.sol,ERC20Token.transferFrom,90,109,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0xf297a0806f24dbc96794af54c8c3691874c430f4_ext.sol,ForestEcosphere.transferFrom,119,135,"REF_5(mapping(address => uint256)) -> allowed[_from],REF_6(uint256) -> REF_5[msg.sender],allowance(uint256) := REF_6(uint256),REF_7(uint256) -> balances[_from],TMP_29(bool) = REF_7 >= _value,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),TMP_31(bool) = _from == _to,REF_8(uint256) -> balances[_to],TMP_32(uint256) = MAX_UINT256 - _value,TMP_33(bool) = REF_8 <= TMP_32,TMP_34(bool) = TMP_31 || TMP_33,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),TMP_36(bool) = allowance >= _value,TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36),REF_9(uint256) -> balances[_from],REF_9(-> balances) = REF_9 - _value,REF_10(uint256) -> balances[_to],REF_10(-> balances) = REF_10 + _value,TMP_38(bool) = allowance < MAX_UINT256,CONDITION TMP_38,REF_11(mapping(address => uint256)) -> allowed[_from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowed) = REF_12 - _value,Emit Transfer(_from,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
allowance = allowed[_from][msg.sender]

IRs:
REF_5(mapping(address => uint256)) -> allowed[_from]
REF_6(uint256) -> REF_5[msg.sender]
allowance(uint256) := REF_6(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] >= _value)

IRs:
REF_7(uint256) -> balances[_from]
TMP_29(bool) = REF_7 >= _value
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_from == _to || balances[_to] <= MAX_UINT256 - _value)

IRs:
TMP_31(bool) = _from == _to
REF_8(uint256) -> balances[_to]
TMP_32(uint256) = MAX_UINT256 - _value
TMP_33(bool) = REF_8 <= TMP_32
TMP_34(bool) = TMP_31 || TMP_33
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(allowance >= _value)

IRs:
TMP_36(bool) = allowance >= _value
TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[_from] -= _value

IRs:
REF_9(uint256) -> balances[_from]
REF_9(-> balances) = REF_9 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[_to] += _value

IRs:
REF_10(uint256) -> balances[_to]
REF_10(-> balances) = REF_10 + _value""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
allowance < MAX_UINT256

IRs:
TMP_38(bool) = allowance < MAX_UINT256
CONDITION TMP_38""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_11(mapping(address => uint256)) -> allowed[_from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowed) = REF_12 - _value""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
10->11;
11[label=""Node Type: RETURN 11

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"allowance = allowed[_from][msg.sender];require(bool)(balances[_from] >= _value);require(bool)(_from == _to || balances[_to] <= MAX_UINT256 - _value);require(bool)(allowance >= _value);balances[_from] -= _value;balances[_to] += _value;allowance < MAX_UINT256;allowed[_from][msg.sender] -= _value;;Transfer(_from,_to,_value);true"
./0xe2fe5e7e206e7b46cad6a5146320e5b4b9a18e97_ext.sol,metahashtoken.transferFrom,68,85,"REF_8(mapping(address => uint256)) -> allowed[_from],REF_9(uint256) -> REF_8[msg.sender],_allowance(uint256) := REF_9(uint256),TMP_7(bool) = _allowance < _value,CONDITION TMP_7,TMP_8(None) = SOLIDITY_CALL revert()(),REF_10(uint256) -> balance[_from],TMP_9(bool) = REF_10 < _value,CONDITION TMP_9,TMP_10(None) = SOLIDITY_CALL revert()(),REF_11(uint256) -> balance[_to],REF_11(-> balance) = REF_11 + _value,REF_12(uint256) -> balance[_from],REF_12(-> balance) = REF_12 - _value,REF_13(mapping(address => uint256)) -> allowed[_from],REF_14(uint256) -> REF_13[msg.sender],TMP_11(uint256) = _allowance - _value,REF_14(uint256) (->allowed) := TMP_11(uint256),Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_allowance = allowed[_from][msg.sender]

IRs:
REF_8(mapping(address => uint256)) -> allowed[_from]
REF_9(uint256) -> REF_8[msg.sender]
_allowance(uint256) := REF_9(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
_allowance < _value

IRs:
TMP_7(bool) = _allowance < _value
CONDITION TMP_7""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
revert()()

IRs:
TMP_8(None) = SOLIDITY_CALL revert()()""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
balance[_from] < _value

IRs:
REF_10(uint256) -> balance[_from]
TMP_9(bool) = REF_10 < _value
CONDITION TMP_9""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
revert()()

IRs:
TMP_10(None) = SOLIDITY_CALL revert()()""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balance[_to] += _value

IRs:
REF_11(uint256) -> balance[_to]
REF_11(-> balance) = REF_11 + _value""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
balance[_from] -= _value

IRs:
REF_12(uint256) -> balance[_from]
REF_12(-> balance) = REF_12 - _value""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
allowed[_from][msg.sender] = _allowance - _value

IRs:
REF_13(mapping(address => uint256)) -> allowed[_from]
REF_14(uint256) -> REF_13[msg.sender]
TMP_11(uint256) = _allowance - _value
REF_14(uint256) (->allowed) := TMP_11(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
11->12;
12[label=""Node Type: RETURN 12

EXPRESSION:
true

IRs:
RETURN True""];
13[label=""Node Type: RETURN 13

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"_allowance = allowed[_from][msg.sender];_allowance < _value;revert()();;balance[_from] < _value;revert()();;balance[_to] += _value;balance[_from] -= _value;allowed[_from][msg.sender] = _allowance - _value;Transfer(_from,_to,_value);true;success"
./0x3395465cb04b8ebd2ae2647cf37bcb2384d71d49_ext.sol,Beneficial.setOfficialUrl,112,114,"officialUrl(string) := _newOfficialUrl(string),MODIFIER_CALL, Base.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
officialUrl = _newOfficialUrl

IRs:
officialUrl(string) := _newOfficialUrl(string)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Base.onlyOwner()()""];
2->1;
}
",0,1,0,0,onlyOwner();officialUrl = _newOfficialUrl
./0x319fe5e87a37967a70c21598090c1f19ace5d1f2_ext.sol,BICKCOIN.burn,133,139,"REF_17(uint256) -> balanceOf[msg.sender],TMP_23(bool) = REF_17 >= _value,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_23(bool) = REF_17 >= _value
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x6c4de8424a6184c830234b996f7dba9720dc9306_ext.sol,XKnockoutHamster.checkRemaining,201,250,"TMP_71(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['timeRemaining', 'startedAt'] ,TMP_72(bool) = now >= TMP_71,CONDITION TMP_72,REF_125 -> LENGTH vipList,TMP_73(bool) = REF_125 > 0,CONDITION TMP_73,REF_126 -> LENGTH vipList,TMP_74(uint256) = REF_126 - 1,limit(uint256) := TMP_74(uint256),l(uint256) := limit(uint256),TMP_75(bool) = l >= 0,CONDITION TMP_75,REF_127(address) -> vipList[l],TMP_76 = CONVERT 0 to address,TMP_77(bool) = REF_127 != TMP_76,CONDITION TMP_77,REF_128(address) -> vipList[l],REF_129(XKnockoutHamster.EntityStruct) -> entityStructs[REF_128],REF_130(bool) -> REF_129.active,REF_130(bool) (->entityStructs) := False(bool),REF_131(address) -> vipList[l],REF_132(XKnockoutHamster.EntityStruct) -> entityStructs[REF_131],REF_133(bool) -> REF_132.vip,REF_133(bool) (->entityStructs) := False(bool),REF_134(address) -> vipList[l],REF_135(XKnockoutHamster.EntityStruct) -> entityStructs[REF_134],REF_136(uint256) -> REF_135.date,REF_136(uint256) (->entityStructs) := 0(uint256),TMP_78(uint256) := l(uint256),l(uint256) = l - 1,REF_137 -> LENGTH entityList,TMP_79(uint256) = REF_137 - 1,TMP_80(bool) = shift < TMP_79,CONDITION TMP_80,r(uint256) := shift(uint256),REF_138 -> LENGTH entityList,TMP_81(uint256) = REF_138 - 1,TMP_82(bool) = r < TMP_81,CONDITION TMP_82,REF_139(address) -> entityList[r],REF_140(XKnockoutHamster.EntityStruct) -> entityStructs[REF_139],REF_141(bool) -> REF_140.active,REF_141(bool) (->entityStructs) := False(bool),REF_142(address) -> entityList[r],REF_143(XKnockoutHamster.EntityStruct) -> entityStructs[REF_142],REF_144(uint256) -> REF_143.date,REF_144(uint256) (->entityStructs) := 0(uint256),TMP_83(uint256) := r(uint256),r(uint256) = r + 1,INTERNAL_CALL, XKnockoutHamster.rewardDev()(),TMP_85 = CONVERT this to address,TMP_86(uint256) = SOLIDITY_CALL balance(address)(TMP_85),TMP_87(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_86', 'devreward'] ,TMP_88(bool) = TMP_87 > 0,CONDITION TMP_88,TMP_89(uint256) = INTERNAL_CALL, XKnockoutHamster.lastVIPkey()(),TMP_90(bool) = TMP_89 != 9999,CONDITION TMP_90,TMP_91(uint256) = INTERNAL_CALL, XKnockoutHamster.lastVIPkey()(),REF_146(address) -> vipList[TMP_91],TMP_92 = CONVERT this to address,TMP_93(uint256) = SOLIDITY_CALL balance(address)(TMP_92),Transfer dest:REF_146 value:TMP_93,REF_148 -> LENGTH vipList,REF_148(uint256) (->vipList) := 0(uint256),REF_149 -> LENGTH entityList,REF_149(uint256) (->entityList) := 0(uint256),shift(uint256) := 0(uint256),startedAt(uint256) := now(uint256),timeRemaining(uint256) := 86400(uint256),timetoRegular(bool) := True(bool),TMP_95(uint256) := round(uint256),round(uint256) = round + 1,RETURN True,TMP_96(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['joined', 'exited'] ,TMP_97(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_96', '100'] ,range(uint256) := TMP_97(uint256),TMP_98(bool) = range != 0,CONDITION TMP_98,TMP_99(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['range', '2'] ,TMP_100(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['timeRemaining', 'TMP_99'] ,timeRemaining(uint256) := TMP_100(uint256),RETURN False","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
now >= timeRemaining.add(startedAt)

IRs:
TMP_71(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['timeRemaining', 'startedAt'] 
TMP_72(bool) = now >= TMP_71
CONDITION TMP_72""];
1->2[label=""True""];
1->38[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
vipList.length > 0

IRs:
REF_125 -> LENGTH vipList
TMP_73(bool) = REF_125 > 0
CONDITION TMP_73""];
2->3[label=""True""];
2->14[label=""False""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
limit = vipList.length - 1

IRs:
REF_126 -> LENGTH vipList
TMP_74(uint256) = REF_126 - 1
limit(uint256) := TMP_74(uint256)""];
3->6;
4[label=""Node Type: BEGIN_LOOP 4
""];
4->7;
5[label=""Node Type: END_LOOP 5
""];
5->14;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
l = limit

IRs:
l(uint256) := limit(uint256)""];
6->4;
7[label=""Node Type: IF_LOOP 7

EXPRESSION:
l >= 0

IRs:
TMP_75(bool) = l >= 0
CONDITION TMP_75""];
7->8[label=""True""];
7->5[label=""False""];
8[label=""Node Type: IF 8

EXPRESSION:
vipList[l] != address(0)

IRs:
REF_127(address) -> vipList[l]
TMP_76 = CONVERT 0 to address
TMP_77(bool) = REF_127 != TMP_76
CONDITION TMP_77""];
8->9[label=""True""];
8->12[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
entityStructs[vipList[l]].active = false

IRs:
REF_128(address) -> vipList[l]
REF_129(XKnockoutHamster.EntityStruct) -> entityStructs[REF_128]
REF_130(bool) -> REF_129.active
REF_130(bool) (->entityStructs) := False(bool)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
entityStructs[vipList[l]].vip = false

IRs:
REF_131(address) -> vipList[l]
REF_132(XKnockoutHamster.EntityStruct) -> entityStructs[REF_131]
REF_133(bool) -> REF_132.vip
REF_133(bool) (->entityStructs) := False(bool)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
entityStructs[vipList[l]].date = 0

IRs:
REF_134(address) -> vipList[l]
REF_135(XKnockoutHamster.EntityStruct) -> entityStructs[REF_134]
REF_136(uint256) -> REF_135.date
REF_136(uint256) (->entityStructs) := 0(uint256)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
l --

IRs:
TMP_78(uint256) := l(uint256)
l(uint256) = l - 1""];
13->7;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: IF 15

EXPRESSION:
shift < entityList.length - 1

IRs:
REF_137 -> LENGTH entityList
TMP_79(uint256) = REF_137 - 1
TMP_80(bool) = shift < TMP_79
CONDITION TMP_80""];
15->18[label=""True""];
15->23[label=""False""];
16[label=""Node Type: BEGIN_LOOP 16
""];
16->19;
17[label=""Node Type: END_LOOP 17
""];
17->23;
18[label=""Node Type: NEW VARIABLE 18

EXPRESSION:
r = shift

IRs:
r(uint256) := shift(uint256)""];
18->16;
19[label=""Node Type: IF_LOOP 19

EXPRESSION:
r < entityList.length - 1

IRs:
REF_138 -> LENGTH entityList
TMP_81(uint256) = REF_138 - 1
TMP_82(bool) = r < TMP_81
CONDITION TMP_82""];
19->20[label=""True""];
19->17[label=""False""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
entityStructs[entityList[r]].active = false

IRs:
REF_139(address) -> entityList[r]
REF_140(XKnockoutHamster.EntityStruct) -> entityStructs[REF_139]
REF_141(bool) -> REF_140.active
REF_141(bool) (->entityStructs) := False(bool)""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
entityStructs[entityList[r]].date = 0

IRs:
REF_142(address) -> entityList[r]
REF_143(XKnockoutHamster.EntityStruct) -> entityStructs[REF_142]
REF_144(uint256) -> REF_143.date
REF_144(uint256) (->entityStructs) := 0(uint256)""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
r ++

IRs:
TMP_83(uint256) := r(uint256)
r(uint256) = r + 1""];
22->19;
23[label=""Node Type: END_IF 23
""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
rewardDev()

IRs:
INTERNAL_CALL, XKnockoutHamster.rewardDev()()""];
24->25;
25[label=""Node Type: IF 25

EXPRESSION:
address(this).balance.sub(devreward) > 0

IRs:
TMP_85 = CONVERT this to address
TMP_86(uint256) = SOLIDITY_CALL balance(address)(TMP_85)
TMP_87(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_86', 'devreward'] 
TMP_88(bool) = TMP_87 > 0
CONDITION TMP_88""];
25->26[label=""True""];
25->29[label=""False""];
26[label=""Node Type: IF 26

EXPRESSION:
lastVIPkey() != 9999

IRs:
TMP_89(uint256) = INTERNAL_CALL, XKnockoutHamster.lastVIPkey()()
TMP_90(bool) = TMP_89 != 9999
CONDITION TMP_90""];
26->27[label=""True""];
26->28[label=""False""];
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
vipList[lastVIPkey()].transfer(address(this).balance)

IRs:
TMP_91(uint256) = INTERNAL_CALL, XKnockoutHamster.lastVIPkey()()
REF_146(address) -> vipList[TMP_91]
TMP_92 = CONVERT this to address
TMP_93(uint256) = SOLIDITY_CALL balance(address)(TMP_92)
Transfer dest:REF_146 value:TMP_93""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: END_IF 29
""];
29->30;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
vipList.length = 0

IRs:
REF_148 -> LENGTH vipList
REF_148(uint256) (->vipList) := 0(uint256)""];
30->31;
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
entityList.length = 0

IRs:
REF_149 -> LENGTH entityList
REF_149(uint256) (->entityList) := 0(uint256)""];
31->32;
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
shift = 0

IRs:
shift(uint256) := 0(uint256)""];
32->33;
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
startedAt = now

IRs:
startedAt(uint256) := now(uint256)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
timeRemaining = 86400

IRs:
timeRemaining(uint256) := 86400(uint256)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
timetoRegular = true

IRs:
timetoRegular(bool) := True(bool)""];
35->36;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
round ++

IRs:
TMP_95(uint256) := round(uint256)
round(uint256) = round + 1""];
36->37;
37[label=""Node Type: RETURN 37

EXPRESSION:
true

IRs:
RETURN True""];
38[label=""Node Type: END_IF 38
""];
38->39;
39[label=""Node Type: NEW VARIABLE 39

EXPRESSION:
range = joined.sub(exited).div(100)

IRs:
TMP_96(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['joined', 'exited'] 
TMP_97(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_96', '100'] 
range(uint256) := TMP_97(uint256)""];
39->40;
40[label=""Node Type: IF 40

EXPRESSION:
range != 0

IRs:
TMP_98(bool) = range != 0
CONDITION TMP_98""];
40->41[label=""True""];
40->42[label=""False""];
41[label=""Node Type: EXPRESSION 41

EXPRESSION:
timeRemaining = timeRemaining.div(range.mul(2))

IRs:
TMP_99(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['range', '2'] 
TMP_100(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['timeRemaining', 'TMP_99'] 
timeRemaining(uint256) := TMP_100(uint256)""];
41->42;
42[label=""Node Type: END_IF 42
""];
42->43;
43[label=""Node Type: RETURN 43

EXPRESSION:
false

IRs:
RETURN False""];
}
",0,1,0,0,now >= timeRemaining.add(startedAt);vipList.length > 0;;limit = vipList.length - 1;;l = limit;;l >= 0;;vipList[l] != address(0);entityStructs[vipList[l]].active = false;;entityStructs[vipList[l]].vip = false;entityStructs[vipList[l]].date = 0;l --;shift < entityList.length - 1;r = shift;;;r < entityList.length - 1;;entityStructs[entityList[r]].active = false;entityStructs[entityList[r]].date = 0;r ++;rewardDev();address(this).balance.sub(devreward) > 0;lastVIPkey() != 9999;;vipList[lastVIPkey()].transfer(address(this).balance);;vipList.length = 0;entityList.length = 0;shift = 0;startedAt = now;timeRemaining = 86400;timetoRegular = true;round ++;true;range = joined.sub(exited).div(100);range != 0;timeRemaining = timeRemaining.div(range.mul(2));;false
./0xf354b2e5ea679a726d0348a974971cb4697bf508_ext.sol,TokenERC20.burn,122,128,"REF_17(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_17 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_17 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x1c76457f18230dc1c83d3376ca663ca7312f86d8_ext.sol,ETR.approveAndCall,197,202,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xa48d3b79f43477224933e492e42f5cacf4091ecc_ext.sol,TokenERC20.burn,150,156,"REF_17(uint256) -> balanceOf[msg.sender],TMP_28(bool) = REF_17 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_28(bool) = REF_17 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x25be312868aed68afaf5ac75aed062f4d4c78ce3_ext.sol,RAIOCO.burn,94,99,"REF_17(uint256) -> balanceOf[msg.sender],TMP_34(bool) = REF_17 >= _value,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_34(bool) = REF_17 >= _value
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xb3ed21d5475817134c8f086d46dd1b5f6c49de0a_ext.sol,ZethrDice.getRollResults,988,1011,"TMP_254(uint256) = block.number - _blockNumber,TMP_255(bool) = TMP_254 > 255,CONDITION TMP_255,TMP_256(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '_numRolls'] ,lossAmount(uint256) := TMP_256(uint256),TMP_257(uint256) = INTERNAL_CALL, ZethrDice.calculateProfit(uint256,uint256)(_tokenValue,_rollUnder),profit(uint256) := TMP_257(uint256),i(uint256) := 0(uint256),TMP_258(bool) = i < _numRolls,CONDITION TMP_258,TMP_259(uint256) = INTERNAL_CALL, ZethrGame.random(uint256,uint256,address,uint256)(100,_blockNumber,_target,i),TMP_260(uint256) = TMP_259 + 1,output(uint256) := TMP_260(uint256),TMP_261(bool) = output < _rollUnder,CONDITION TMP_261,TMP_262(uint256) = profit + _tokenValue,winAmount(uint256) = winAmount + TMP_262,lossAmount(uint256) = lossAmount + _tokenValue,TMP_263(uint256) := i(uint256),i(uint256) = i + 1,RETURN winAmount,lossAmount,RETURN winAmount,lossAmount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
block.number - _blockNumber > 255

IRs:
TMP_254(uint256) = block.number - _blockNumber
TMP_255(bool) = TMP_254 > 255
CONDITION TMP_255""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
lossAmount = _tokenValue.mul(_numRolls)

IRs:
TMP_256(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '_numRolls'] 
lossAmount(uint256) := TMP_256(uint256)""];
2->14;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
profit = calculateProfit(_tokenValue,_rollUnder)

IRs:
TMP_257(uint256) = INTERNAL_CALL, ZethrDice.calculateProfit(uint256,uint256)(_tokenValue,_rollUnder)
profit(uint256) := TMP_257(uint256)""];
3->6;
4[label=""Node Type: BEGIN_LOOP 4
""];
4->7;
5[label=""Node Type: END_LOOP 5
""];
5->14;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
6->4;
7[label=""Node Type: IF_LOOP 7

EXPRESSION:
i < _numRolls

IRs:
TMP_258(bool) = i < _numRolls
CONDITION TMP_258""];
7->8[label=""True""];
7->5[label=""False""];
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
output = random(100,_blockNumber,_target,i) + 1

IRs:
TMP_259(uint256) = INTERNAL_CALL, ZethrGame.random(uint256,uint256,address,uint256)(100,_blockNumber,_target,i)
TMP_260(uint256) = TMP_259 + 1
output(uint256) := TMP_260(uint256)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
output < _rollUnder

IRs:
TMP_261(bool) = output < _rollUnder
CONDITION TMP_261""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
winAmount += profit + _tokenValue

IRs:
TMP_262(uint256) = profit + _tokenValue
winAmount(uint256) = winAmount + TMP_262""];
10->12;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
lossAmount += _tokenValue

IRs:
lossAmount(uint256) = lossAmount + _tokenValue""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
i ++

IRs:
TMP_263(uint256) := i(uint256)
i(uint256) = i + 1""];
13->7;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: RETURN 15

EXPRESSION:
(winAmount,lossAmount)

IRs:
RETURN winAmount,lossAmount""];
16[label=""Node Type: RETURN 16

EXPRESSION:
(winAmount,lossAmount)

IRs:
RETURN winAmount,lossAmount""];
}
",0,1,0,0,"block.number - _blockNumber > 255;lossAmount = _tokenValue.mul(_numRolls);profit = calculateProfit(_tokenValue,_rollUnder);;i = 0;;i < _numRolls;;output = random(100,_blockNumber,_target,i) + 1;output < _rollUnder;winAmount += profit + _tokenValue;lossAmount += _tokenValue;;i ++;(winAmount,lossAmount);(winAmount,lossAmount)"
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.ownerUpdateOthers,2,2,"maxSignup(uint256) := _maxno(uint256),contractbacklist(bool) := _isBacklisted(bool),mineth(uint256) := _min_eth(uint256),minsignupeth(uint256) := _minsignupeth(uint256),paidversion(bool) := _paidversion(bool),MODIFIER_CALL, KahnDistributionCentre.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
maxSignup = _maxno

IRs:
maxSignup(uint256) := _maxno(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
contractbacklist = _isBacklisted

IRs:
contractbacklist(bool) := _isBacklisted(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
mineth = _min_eth

IRs:
mineth(uint256) := _min_eth(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
minsignupeth = _minsignupeth

IRs:
minsignupeth(uint256) := _minsignupeth(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
paidversion = _paidversion

IRs:
paidversion(bool) := _paidversion(bool)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyOwner()()""];
6->1;
}
",0,1,1,0,onlyOwner();maxSignup = _maxno;contractbacklist = _isBacklisted;mineth = _min_eth;minsignupeth = _minsignupeth;paidversion = _paidversion
./0x00c8decc1ca373a99f1c2a341be50f03d35e03e7_ext.sol,BurnToken.burn,48,54,"REF_30(uint256) -> balanceOf[msg.sender],TMP_34(bool) = REF_30 >= _value,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),REF_31(uint256) -> balanceOf[msg.sender],REF_31(-> balanceOf) = REF_31 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_30(uint256) -> balanceOf[msg.sender]
TMP_34(bool) = REF_30 >= _value
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_31(uint256) -> balanceOf[msg.sender]
REF_31(-> balanceOf) = REF_31 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x77b3106417d4cf3138882cc21d4710c71183b707_ext.sol,Brave3d.overStage,301,360,"REF_65(uint256) -> _currentMap[rate],curStageIndex(uint256) := REF_65(uint256),REF_66(uint256) -> _finishMap[rate],finishStageIndex(uint256) := REF_66(uint256),TMP_88(bool) = curStageIndex >= finishStageIndex,TMP_89(None) = SOLIDITY_CALL assert(bool)(TMP_88),TMP_90(bool) = curStageIndex == finishStageIndex,CONDITION TMP_90,REF_67(mapping(uint256 => Brave3d.Stage)) -> _stageMap[rate],REF_68(Brave3d.Stage) -> REF_67[finishStageIndex],finishStage(Brave3d.Stage) := REF_68(Brave3d.Stage),REF_69(bool) -> finishStage.isFinish,TMP_91 = UnaryType.BANG REF_69 ,TMP_92(None) = SOLIDITY_CALL assert(bool)(TMP_91),REF_70(uint8) -> finishStage.cnt,TMP_93(bool) = REF_70 < MAX_PLAYERS,CONDITION TMP_93,REF_71(uint256) -> finishStage.blocknumber,TMP_94(bool) = REF_71 != 0,TMP_95(None) = SOLIDITY_CALL assert(bool)(TMP_94),TMP_96(uint256) = block.number - 256,REF_72(uint256) -> finishStage.blocknumber,TMP_97(bool) = TMP_96 <= REF_72,CONDITION TMP_97,REF_73(uint256) -> finishStage.blocknumber,TMP_98(bool) = block.number == REF_73,CONDITION TMP_98,REF_74(uint256) -> finishStage.blocknumber,TMP_99(uint256) = SOLIDITY_CALL blockhash(uint256)(REF_74),TMP_100 = CONVERT TMP_99 to uint8,TMP_101(uint8) = TMP_100 % MAX_PLAYERS,deadIndex(uint8) := TMP_101(uint8),REF_75(mapping(uint8 => address)) -> finishStage.playerMap,REF_76(address) -> REF_75[deadIndex],deadPlayer(address) := REF_76(address),Emit BraveDeadPlayer(deadPlayer,finishStageIndex,deadIndex,rate),REF_77(uint8) -> finishStage.deadIndex,REF_77(uint8) (->finishStage) := deadIndex(uint8),i(uint8) := 0(uint256),TMP_103(bool) = i < MAX_PLAYERS,CONDITION TMP_103,REF_78(mapping(uint8 => address)) -> finishStage.playerMap,REF_79(address) -> REF_78[i],player(address) := REF_79(address),TMP_104(bool) = deadIndex != i,CONDITION TMP_104,REF_80(uint256) -> _valueMap[player],TMP_105(uint256) = WIN_VALUE * rate,REF_80(-> _valueMap) = REF_80 + TMP_105,REF_81(address) -> _addressMap[player],referee(address) := REF_81(address),REF_82(uint256) -> _valueMap[referee],TMP_106(uint256) = REFEREE_VALUE * rate,REF_82(-> _valueMap) = REF_82 + TMP_106,REF_83(uint256) -> _referredMap[referee],TMP_107(uint256) = REFEREE_VALUE * rate,REF_83(-> _referredMap) = REF_83 + TMP_107,TMP_108(uint8) := i(uint8),i(uint8) = i + 1,TMP_109(uint256) = HIGH_LEVEL_CALL, dest:p3dContract(HourglassInterface), function:myDividends, arguments:['True']  ,dividends(uint256) := TMP_109(uint256),TMP_110(bool) = dividends > 0,CONDITION TMP_110,HIGH_LEVEL_CALL, dest:p3dContract(HourglassInterface), function:withdraw, arguments:[]  ,REF_86(uint256) -> _valueMap[deadPlayer],REF_86(-> _valueMap) = REF_86 + dividends,TMP_112(uint256) = P3D_VALUE * rate,TMP_114 = CONVERT OFFICIAL_P3D to address,TMP_115(uint256) = HIGH_LEVEL_CALL, dest:p3dContract(HourglassInterface), function:buy, arguments:['TMP_114'] value:TMP_112 ,j(uint8) := 0(uint256),TMP_116(bool) = j < MAX_PLAYERS,CONDITION TMP_116,REF_89(mapping(uint8 => address)) -> finishStage.playerMap,REF_90(address) -> REF_89[j],REF_91(uint256) -> _valueMap[REF_90],TMP_117(uint256) = PRICE * rate,REF_91(-> _valueMap) = REF_91 + TMP_117,TMP_118(uint8) := j(uint8),j(uint8) = j + 1,Emit BraveInvalidateStage(finishStageIndex,rate),REF_92(bool) -> finishStage.isFinish,REF_92(bool) (->finishStage) := True(bool),TMP_120(uint256) := finishStageIndex(uint256),finishStageIndex(uint256) = finishStageIndex + 1,REF_93(uint256) -> _finishMap[rate],REF_93(uint256) (->_finishMap) := finishStageIndex(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
curStageIndex = _currentMap[rate]

IRs:
REF_65(uint256) -> _currentMap[rate]
curStageIndex(uint256) := REF_65(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
finishStageIndex = _finishMap[rate]

IRs:
REF_66(uint256) -> _finishMap[rate]
finishStageIndex(uint256) := REF_66(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
assert(bool)(curStageIndex >= finishStageIndex)

IRs:
TMP_88(bool) = curStageIndex >= finishStageIndex
TMP_89(None) = SOLIDITY_CALL assert(bool)(TMP_88)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
curStageIndex == finishStageIndex

IRs:
TMP_90(bool) = curStageIndex == finishStageIndex
CONDITION TMP_90""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: RETURN 5
""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
finishStage = _stageMap[rate][finishStageIndex]

IRs:
REF_67(mapping(uint256 => Brave3d.Stage)) -> _stageMap[rate]
REF_68(Brave3d.Stage) -> REF_67[finishStageIndex]
finishStage(Brave3d.Stage) := REF_68(Brave3d.Stage)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(! finishStage.isFinish)

IRs:
REF_69(bool) -> finishStage.isFinish
TMP_91 = UnaryType.BANG REF_69 
TMP_92(None) = SOLIDITY_CALL assert(bool)(TMP_91)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
finishStage.cnt < MAX_PLAYERS

IRs:
REF_70(uint8) -> finishStage.cnt
TMP_93(bool) = REF_70 < MAX_PLAYERS
CONDITION TMP_93""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: RETURN 10
""];
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
assert(bool)(finishStage.blocknumber != 0)

IRs:
REF_71(uint256) -> finishStage.blocknumber
TMP_94(bool) = REF_71 != 0
TMP_95(None) = SOLIDITY_CALL assert(bool)(TMP_94)""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
block.number - 256 <= finishStage.blocknumber

IRs:
TMP_96(uint256) = block.number - 256
REF_72(uint256) -> finishStage.blocknumber
TMP_97(bool) = TMP_96 <= REF_72
CONDITION TMP_97""];
13->14[label=""True""];
13->41[label=""False""];
14[label=""Node Type: IF 14

EXPRESSION:
block.number == finishStage.blocknumber

IRs:
REF_73(uint256) -> finishStage.blocknumber
TMP_98(bool) = block.number == REF_73
CONDITION TMP_98""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: RETURN 15
""];
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: NEW VARIABLE 17

EXPRESSION:
deadIndex = uint8(blockhash(uint256)(finishStage.blocknumber)) % MAX_PLAYERS

IRs:
REF_74(uint256) -> finishStage.blocknumber
TMP_99(uint256) = SOLIDITY_CALL blockhash(uint256)(REF_74)
TMP_100 = CONVERT TMP_99 to uint8
TMP_101(uint8) = TMP_100 % MAX_PLAYERS
deadIndex(uint8) := TMP_101(uint8)""];
17->18;
18[label=""Node Type: NEW VARIABLE 18

EXPRESSION:
deadPlayer = finishStage.playerMap[deadIndex]

IRs:
REF_75(mapping(uint8 => address)) -> finishStage.playerMap
REF_76(address) -> REF_75[deadIndex]
deadPlayer(address) := REF_76(address)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
BraveDeadPlayer(deadPlayer,finishStageIndex,deadIndex,rate)

IRs:
Emit BraveDeadPlayer(deadPlayer,finishStageIndex,deadIndex,rate)""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
finishStage.deadIndex = deadIndex

IRs:
REF_77(uint8) -> finishStage.deadIndex
REF_77(uint8) (->finishStage) := deadIndex(uint8)""];
20->23;
21[label=""Node Type: BEGIN_LOOP 21
""];
21->24;
22[label=""Node Type: END_LOOP 22
""];
22->33;
23[label=""Node Type: NEW VARIABLE 23

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)""];
23->21;
24[label=""Node Type: IF_LOOP 24

EXPRESSION:
i < MAX_PLAYERS

IRs:
TMP_103(bool) = i < MAX_PLAYERS
CONDITION TMP_103""];
24->25[label=""True""];
24->22[label=""False""];
25[label=""Node Type: NEW VARIABLE 25

EXPRESSION:
player = finishStage.playerMap[i]

IRs:
REF_78(mapping(uint8 => address)) -> finishStage.playerMap
REF_79(address) -> REF_78[i]
player(address) := REF_79(address)""];
25->26;
26[label=""Node Type: IF 26

EXPRESSION:
deadIndex != i

IRs:
TMP_104(bool) = deadIndex != i
CONDITION TMP_104""];
26->27[label=""True""];
26->28[label=""False""];
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
_valueMap[player] += WIN_VALUE * rate

IRs:
REF_80(uint256) -> _valueMap[player]
TMP_105(uint256) = WIN_VALUE * rate
REF_80(-> _valueMap) = REF_80 + TMP_105""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: NEW VARIABLE 29

EXPRESSION:
referee = _addressMap[player]

IRs:
REF_81(address) -> _addressMap[player]
referee(address) := REF_81(address)""];
29->30;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
_valueMap[referee] += REFEREE_VALUE * rate

IRs:
REF_82(uint256) -> _valueMap[referee]
TMP_106(uint256) = REFEREE_VALUE * rate
REF_82(-> _valueMap) = REF_82 + TMP_106""];
30->31;
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
_referredMap[referee] += REFEREE_VALUE * rate

IRs:
REF_83(uint256) -> _referredMap[referee]
TMP_107(uint256) = REFEREE_VALUE * rate
REF_83(-> _referredMap) = REF_83 + TMP_107""];
31->32;
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
i ++

IRs:
TMP_108(uint8) := i(uint8)
i(uint8) = i + 1""];
32->24;
33[label=""Node Type: NEW VARIABLE 33

EXPRESSION:
dividends = p3dContract.myDividends(true)

IRs:
TMP_109(uint256) = HIGH_LEVEL_CALL, dest:p3dContract(HourglassInterface), function:myDividends, arguments:['True']  
dividends(uint256) := TMP_109(uint256)""];
33->34;
34[label=""Node Type: IF 34

EXPRESSION:
dividends > 0

IRs:
TMP_110(bool) = dividends > 0
CONDITION TMP_110""];
34->35[label=""True""];
34->37[label=""False""];
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
p3dContract.withdraw()

IRs:
HIGH_LEVEL_CALL, dest:p3dContract(HourglassInterface), function:withdraw, arguments:[]  ""];
35->36;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
_valueMap[deadPlayer] += dividends

IRs:
REF_86(uint256) -> _valueMap[deadPlayer]
REF_86(-> _valueMap) = REF_86 + dividends""];
36->37;
37[label=""Node Type: END_IF 37
""];
37->38;
38[label=""Node Type: EXPRESSION 38

EXPRESSION:
p3dContract.buy.value(P3D_VALUE * rate)(address(OFFICIAL_P3D))

IRs:
TMP_112(uint256) = P3D_VALUE * rate
TMP_114 = CONVERT OFFICIAL_P3D to address
TMP_115(uint256) = HIGH_LEVEL_CALL, dest:p3dContract(HourglassInterface), function:buy, arguments:['TMP_114'] value:TMP_112 ""];
38->46;
39[label=""Node Type: BEGIN_LOOP 39
""];
39->42;
40[label=""Node Type: END_LOOP 40
""];
40->45;
41[label=""Node Type: NEW VARIABLE 41

EXPRESSION:
j = 0

IRs:
j(uint8) := 0(uint256)""];
41->39;
42[label=""Node Type: IF_LOOP 42

EXPRESSION:
j < MAX_PLAYERS

IRs:
TMP_116(bool) = j < MAX_PLAYERS
CONDITION TMP_116""];
42->43[label=""True""];
42->40[label=""False""];
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
_valueMap[finishStage.playerMap[j]] += PRICE * rate

IRs:
REF_89(mapping(uint8 => address)) -> finishStage.playerMap
REF_90(address) -> REF_89[j]
REF_91(uint256) -> _valueMap[REF_90]
TMP_117(uint256) = PRICE * rate
REF_91(-> _valueMap) = REF_91 + TMP_117""];
43->44;
44[label=""Node Type: EXPRESSION 44

EXPRESSION:
j ++

IRs:
TMP_118(uint8) := j(uint8)
j(uint8) = j + 1""];
44->42;
45[label=""Node Type: EXPRESSION 45

EXPRESSION:
BraveInvalidateStage(finishStageIndex,rate)

IRs:
Emit BraveInvalidateStage(finishStageIndex,rate)""];
45->46;
46[label=""Node Type: END_IF 46
""];
46->47;
47[label=""Node Type: EXPRESSION 47

EXPRESSION:
finishStage.isFinish = true

IRs:
REF_92(bool) -> finishStage.isFinish
REF_92(bool) (->finishStage) := True(bool)""];
47->48;
48[label=""Node Type: EXPRESSION 48

EXPRESSION:
finishStageIndex ++

IRs:
TMP_120(uint256) := finishStageIndex(uint256)
finishStageIndex(uint256) = finishStageIndex + 1""];
48->49;
49[label=""Node Type: EXPRESSION 49

EXPRESSION:
_finishMap[rate] = finishStageIndex

IRs:
REF_93(uint256) -> _finishMap[rate]
REF_93(uint256) (->_finishMap) := finishStageIndex(uint256)""];
}
",0,1,0,0,"curStageIndex = _currentMap[rate];finishStageIndex = _finishMap[rate];assert(bool)(curStageIndex >= finishStageIndex);curStageIndex == finishStageIndex;;;finishStage = _stageMap[rate][finishStageIndex];assert(bool)(! finishStage.isFinish);finishStage.cnt < MAX_PLAYERS;;;assert(bool)(finishStage.blocknumber != 0);block.number - 256 <= finishStage.blocknumber;block.number == finishStage.blocknumber;j = 0;;;deadIndex = uint8(blockhash(uint256)(finishStage.blocknumber)) % MAX_PLAYERS;deadPlayer = finishStage.playerMap[deadIndex];BraveDeadPlayer(deadPlayer,finishStageIndex,deadIndex,rate);finishStage.deadIndex = deadIndex;i = 0;;i < MAX_PLAYERS;;dividends = p3dContract.myDividends(true);player = finishStage.playerMap[i];deadIndex != i;_valueMap[player] += WIN_VALUE * rate;;referee = _addressMap[player];_valueMap[referee] += REFEREE_VALUE * rate;_referredMap[referee] += REFEREE_VALUE * rate;i ++;dividends > 0;p3dContract.withdraw();;_valueMap[deadPlayer] += dividends;p3dContract.buy.value(P3D_VALUE * rate)(address(OFFICIAL_P3D));;;j < MAX_PLAYERS;;BraveInvalidateStage(finishStageIndex,rate);_valueMap[finishStage.playerMap[j]] += PRICE * rate;j ++;finishStage.isFinish = true;finishStageIndex ++;_finishMap[rate] = finishStageIndex"
./0x5046e860ff274fb8c66106b0ffb8155849fb0787_ext.sol,JavaScriptToken.distributeJST,72,81,"i(uint256) := 0(uint256),REF_1 -> LENGTH addresses,TMP_2(bool) = i < REF_1,CONDITION TMP_2,REF_2(address) -> addresses[i],TMP_3(uint256) = INTERNAL_CALL, JavaScriptToken.getEthBalance(address)(REF_2),TMP_4(bool) = TMP_3 < _ethbal,CONDITION TMP_4,REF_3(uint256) -> balances[owner],REF_3(-> balances) = REF_3 - _value,REF_4(address) -> addresses[i],REF_5(uint256) -> balances[REF_4],REF_5(-> balances) = REF_5 + _value,REF_6(address) -> addresses[i],Emit Transfer(owner,REF_6,_value),TMP_6(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, JavaScriptToken.onlyOwner()(),MODIFIER_CALL, JavaScriptToken.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addresses.length

IRs:
REF_1 -> LENGTH addresses
TMP_2(bool) = i < REF_1
CONDITION TMP_2""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
getEthBalance(addresses[i]) < _ethbal

IRs:
REF_2(address) -> addresses[i]
TMP_3(uint256) = INTERNAL_CALL, JavaScriptToken.getEthBalance(address)(REF_2)
TMP_4(bool) = TMP_3 < _ethbal
CONDITION TMP_4""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: CONTINUE 6
""];
6->11;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[owner] -= _value

IRs:
REF_3(uint256) -> balances[owner]
REF_3(-> balances) = REF_3 - _value""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
balances[addresses[i]] += _value

IRs:
REF_4(address) -> addresses[i]
REF_5(uint256) -> balances[REF_4]
REF_5(-> balances) = REF_5 + _value""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Transfer(owner,addresses[i],_value)

IRs:
REF_6(address) -> addresses[i]
Emit Transfer(owner,REF_6,_value)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_6(uint256) := i(uint256)
i(uint256) = i + 1""];
11->4;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, JavaScriptToken.onlyOwner()()""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, JavaScriptToken.canDistr()()""];
13->3;
}
",0,1,0,0,"onlyOwner();;i < addresses.length;;i = 0;getEthBalance(addresses[i]) < _ethbal;;;i ++;balances[owner] -= _value;balances[addresses[i]] += _value;Transfer(owner,addresses[i],_value);canDistr()"
./0x838df5c03147f0b038c24b18af5bb5dee1ffd446_ext.sol,Edgecoin.confirmAndExecuteWithdrawal,468,489,"REF_141(bool) -> isConfirmed[msg.sender],REF_141(bool) (->isConfirmed) := True(bool),i(uint256) := 0(uint256),TMP_419(bool) = i < threshold,CONDITION TMP_419,REF_142(address) -> ownersArr[i],REF_143(bool) -> isConfirmed[REF_142],CONDITION REF_143,TMP_420(uint256) := confirmedTimesByOwners(uint256),confirmedTimesByOwners(uint256) = confirmedTimesByOwners + 1,TMP_421(uint256) := i(uint256),i(uint256) = i + 1,TMP_422(uint256) = threshold - 1,TMP_423(bool) = confirmedTimesByOwners >= TMP_422,CONDITION TMP_423,TMP_424(uint256) = nonce + 1,nonce(uint256) := TMP_424(uint256),Transfer dest:pendingAddress value:pendingAmount,pendingAmount(uint256) := 0(uint256),pendingAddress(address) := 0(uint256),confirmedTimesByOwners(uint256) := 0(uint256),j(uint256) := 0(uint256),TMP_426(bool) = j < threshold,CONDITION TMP_426,REF_145(address) -> ownersArr[j],REF_146(bool) -> isConfirmed[REF_145],REF_146(bool) (->isConfirmed) := False(bool),TMP_427(uint256) := j(uint256),j(uint256) = j + 1,MODIFIER_CALL, Edgecoin.onlyOwners()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->23;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
isConfirmed[msg.sender] = true

IRs:
REF_141(bool) -> isConfirmed[msg.sender]
REF_141(bool) (->isConfirmed) := True(bool)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
3->10;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < threshold

IRs:
TMP_419(bool) = i < threshold
CONDITION TMP_419""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: IF 6

EXPRESSION:
isConfirmed[ownersArr[i]]

IRs:
REF_142(address) -> ownersArr[i]
REF_143(bool) -> isConfirmed[REF_142]
CONDITION REF_143""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
confirmedTimesByOwners ++

IRs:
TMP_420(uint256) := confirmedTimesByOwners(uint256)
confirmedTimesByOwners(uint256) = confirmedTimesByOwners + 1""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_421(uint256) := i(uint256)
i(uint256) = i + 1""];
9->5;
10[label=""Node Type: IF 10

EXPRESSION:
confirmedTimesByOwners >= (threshold - 1)

IRs:
TMP_422(uint256) = threshold - 1
TMP_423(bool) = confirmedTimesByOwners >= TMP_422
CONDITION TMP_423""];
10->11[label=""True""];
10->22[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
nonce = nonce + 1

IRs:
TMP_424(uint256) = nonce + 1
nonce(uint256) := TMP_424(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
pendingAddress.transfer(pendingAmount)

IRs:
Transfer dest:pendingAddress value:pendingAmount""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
pendingAmount = 0

IRs:
pendingAmount(uint256) := 0(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
pendingAddress = 0x0

IRs:
pendingAddress(address) := 0(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
confirmedTimesByOwners = 0

IRs:
confirmedTimesByOwners(uint256) := 0(uint256)""];
15->18;
16[label=""Node Type: BEGIN_LOOP 16
""];
16->19;
17[label=""Node Type: END_LOOP 17
""];
17->22;
18[label=""Node Type: NEW VARIABLE 18

EXPRESSION:
j = 0

IRs:
j(uint256) := 0(uint256)""];
18->16;
19[label=""Node Type: IF_LOOP 19

EXPRESSION:
j < threshold

IRs:
TMP_426(bool) = j < threshold
CONDITION TMP_426""];
19->20[label=""True""];
19->17[label=""False""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
isConfirmed[ownersArr[j]] = false

IRs:
REF_145(address) -> ownersArr[j]
REF_146(bool) -> isConfirmed[REF_145]
REF_146(bool) (->isConfirmed) := False(bool)""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
j ++

IRs:
TMP_427(uint256) := j(uint256)
j(uint256) = j + 1""];
21->19;
22[label=""Node Type: END_IF 22
""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
onlyOwners()

IRs:
MODIFIER_CALL, Edgecoin.onlyOwners()()""];
23->1;
}
",0,1,0,0,onlyOwners();isConfirmed[msg.sender] = true;i = 0;;i < threshold;;confirmedTimesByOwners >= (threshold - 1);isConfirmed[ownersArr[i]];confirmedTimesByOwners ++;;i ++;nonce = nonce + 1;;pendingAddress.transfer(pendingAmount);pendingAmount = 0;pendingAddress = 0x0;confirmedTimesByOwners = 0;j = 0;;j < threshold;;isConfirmed[ownersArr[j]] = false;j ++
./0x03684715e3a614ec80d1b31b62987e0b25925999_ext.sol,GWGFPLUS._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xf317f4acfc0d70ccc79a2f24cfbbd7ebc02cfa2e_ext.sol,CryptoStrategiesIntelligence.approveAndCallcode,149,154,"REF_68(mapping(address => uint256)) -> allowed[msg.sender],REF_69(uint256) -> REF_68[_spender],REF_69(uint256) (->allowed) := _value(uint256),Emit Approval(msg.sender,_spender,_value),TMP_80(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['_extraData']  ,TMP_81 = UnaryType.BANG TMP_80 ,CONDITION TMP_81,TMP_82(None) = SOLIDITY_CALL revert()(),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_68(mapping(address => uint256)) -> allowed[msg.sender]
REF_69(uint256) -> REF_68[_spender]
REF_69(uint256) (->allowed) := _value(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
! _spender.call(_extraData)

IRs:
TMP_80(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['_extraData']  
TMP_81 = UnaryType.BANG TMP_80 
CONDITION TMP_81""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
revert()()

IRs:
TMP_82(None) = SOLIDITY_CALL revert()()""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][_spender] = _value;Approval(msg.sender,_spender,_value);! _spender.call(_extraData);revert()();;true;success"
./0xf2d32cfa422a4a5b7074050651ca380eb0cf0a8c_ext.sol,EasyStockExchange.buyDepo,81,112,"REF_11(bool) -> isSale[_depo],TMP_12(bool) = REF_11 == True,TMP_13(None) = SOLIDITY_CALL require(bool,string)(TMP_12,So sorry, but this deposit is not for sale.),REF_12(bool) -> isSale[_depo],REF_12(bool) (->isSale) := False(bool),REF_13(uint256) -> forSale[_depo],TMP_14(bool) = REF_13 == msg.value,TMP_15(None) = SOLIDITY_CALL require(bool,string)(TMP_14,Summ for buying deposit is incorrect.),seller(address) := _depo(address),REF_14(uint256) -> invested[_depo],TMP_16(uint256) = REF_14 * 4,TMP_17(uint256) = TMP_16 / 100,REF_15(uint256) -> atBlock[_depo],TMP_18(uint256) = block.number - REF_15,TMP_19(uint256) = TMP_17 * TMP_18,TMP_20(uint256) = TMP_19 / 5900,amount(uint256) := TMP_20(uint256),REF_16(uint256) -> invested[_depo],REF_16(-> invested) = REF_16 + amount,REF_17(uint256) -> invested[msg.sender],TMP_21(bool) = REF_17 > 0,CONDITION TMP_21,REF_18(uint256) -> invested[msg.sender],TMP_22(uint256) = REF_18 * 4,TMP_23(uint256) = TMP_22 / 100,REF_19(uint256) -> atBlock[msg.sender],TMP_24(uint256) = block.number - REF_19,TMP_25(uint256) = TMP_23 * TMP_24,TMP_26(uint256) = TMP_25 / 5900,amount(uint256) := TMP_26(uint256),REF_20(uint256) -> invested[msg.sender],REF_20(-> invested) = REF_20 + amount,REF_21(uint256) -> invested[msg.sender],REF_22(uint256) -> invested[_depo],REF_21(-> invested) = REF_21 + REF_22,REF_23(uint256) -> atBlock[msg.sender],REF_23(uint256) (->atBlock) := block.number(uint256),REF_24(uint256) -> invested[_depo],REF_24(uint256) (->invested) := 0(uint256),REF_25(uint256) -> atBlock[_depo],REF_25(uint256) (->atBlock) := block.number(uint256),REF_26(bool) -> isSale[_depo],REF_26(bool) (->isSale) := False(bool),TMP_27(uint256) = msg.value * 9,TMP_28(uint256) = TMP_27 / 10,Transfer dest:seller value:TMP_28,Emit Deals(_depo,msg.sender,msg.value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(isSale[_depo] == true,So sorry, but this deposit is not for sale.)

IRs:
REF_11(bool) -> isSale[_depo]
TMP_12(bool) = REF_11 == True
TMP_13(None) = SOLIDITY_CALL require(bool,string)(TMP_12,So sorry, but this deposit is not for sale.)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isSale[_depo] = false

IRs:
REF_12(bool) -> isSale[_depo]
REF_12(bool) (->isSale) := False(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool,string)(forSale[_depo] == msg.value,Summ for buying deposit is incorrect.)

IRs:
REF_13(uint256) -> forSale[_depo]
TMP_14(bool) = REF_13 == msg.value
TMP_15(None) = SOLIDITY_CALL require(bool,string)(TMP_14,Summ for buying deposit is incorrect.)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
seller = _depo

IRs:
seller(address) := _depo(address)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
amount = invested[_depo] * 4 / 100 * (block.number - atBlock[_depo]) / 5900

IRs:
REF_14(uint256) -> invested[_depo]
TMP_16(uint256) = REF_14 * 4
TMP_17(uint256) = TMP_16 / 100
REF_15(uint256) -> atBlock[_depo]
TMP_18(uint256) = block.number - REF_15
TMP_19(uint256) = TMP_17 * TMP_18
TMP_20(uint256) = TMP_19 / 5900
amount(uint256) := TMP_20(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
invested[_depo] += amount

IRs:
REF_16(uint256) -> invested[_depo]
REF_16(-> invested) = REF_16 + amount""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
invested[msg.sender] > 0

IRs:
REF_17(uint256) -> invested[msg.sender]
TMP_21(bool) = REF_17 > 0
CONDITION TMP_21""];
7->8[label=""True""];
7->10[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
amount = invested[msg.sender] * 4 / 100 * (block.number - atBlock[msg.sender]) / 5900

IRs:
REF_18(uint256) -> invested[msg.sender]
TMP_22(uint256) = REF_18 * 4
TMP_23(uint256) = TMP_22 / 100
REF_19(uint256) -> atBlock[msg.sender]
TMP_24(uint256) = block.number - REF_19
TMP_25(uint256) = TMP_23 * TMP_24
TMP_26(uint256) = TMP_25 / 5900
amount(uint256) := TMP_26(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
invested[msg.sender] += amount

IRs:
REF_20(uint256) -> invested[msg.sender]
REF_20(-> invested) = REF_20 + amount""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
invested[msg.sender] += invested[_depo]

IRs:
REF_21(uint256) -> invested[msg.sender]
REF_22(uint256) -> invested[_depo]
REF_21(-> invested) = REF_21 + REF_22""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
atBlock[msg.sender] = block.number

IRs:
REF_23(uint256) -> atBlock[msg.sender]
REF_23(uint256) (->atBlock) := block.number(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
invested[_depo] = 0

IRs:
REF_24(uint256) -> invested[_depo]
REF_24(uint256) (->invested) := 0(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
atBlock[_depo] = block.number

IRs:
REF_25(uint256) -> atBlock[_depo]
REF_25(uint256) (->atBlock) := block.number(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
isSale[_depo] = false

IRs:
REF_26(bool) -> isSale[_depo]
REF_26(bool) (->isSale) := False(bool)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
seller.transfer(msg.value * 9 / 10)

IRs:
TMP_27(uint256) = msg.value * 9
TMP_28(uint256) = TMP_27 / 10
Transfer dest:seller value:TMP_28""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
Deals(_depo,msg.sender,msg.value)

IRs:
Emit Deals(_depo,msg.sender,msg.value)""];
}
",0,1,0,0,"require(bool,string)(isSale[_depo] == true,So sorry, but this deposit is not for sale.);isSale[_depo] = false;require(bool,string)(forSale[_depo] == msg.value,Summ for buying deposit is incorrect.);seller = _depo;amount = invested[_depo] * 4 / 100 * (block.number - atBlock[_depo]) / 5900;invested[_depo] += amount;invested[msg.sender] > 0;amount = invested[msg.sender] * 4 / 100 * (block.number - atBlock[msg.sender]) / 5900;;invested[msg.sender] += amount;invested[msg.sender] += invested[_depo];atBlock[msg.sender] = block.number;invested[_depo] = 0;atBlock[_depo] = block.number;isSale[_depo] = false;seller.transfer(msg.value * 9 / 10);Deals(_depo,msg.sender,msg.value)"
./0xdb8ea10793899f6323ecd6b2cd510c005f14b116_ext.sol,ENYCOIN._transfer,41,57,"TMP_6(bool) = _to != 0,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_1(uint256) -> balanceOf[_from],TMP_8(bool) = REF_1 >= _value,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_2(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_11(bool) = TMP_10 >= REF_3,TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_13(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_13(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_15(uint256) = REF_8 + REF_9,TMP_16(bool) = TMP_15 == previousBalances,TMP_17(None) = SOLIDITY_CALL assert(bool)(TMP_16)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_6(bool) = _to != 0
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_8(bool) = REF_1 >= _value
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_11(bool) = TMP_10 >= REF_3
TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_13(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_13(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_15(uint256) = REF_8 + REF_9
TMP_16(bool) = TMP_15 == previousBalances
TMP_17(None) = SOLIDITY_CALL assert(bool)(TMP_16)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xf2861ad8dd602269c21eddd4d18255903cca47c7_ext.sol,ZethrBigWheel.getSpinOutput,2879,2959,"TMP_774(uint40[5]) = INTERNAL_CALL, ZethrBigWheel.uintToBetsArray(uint256)(_bets_notconverted),_bets(uint40[5]) = ['TMP_774(uint40[5])'],TMP_775(uint256) = block.number - _blockNumber,TMP_776(bool) = TMP_775 > 255,CONDITION TMP_776,result(uint256) := 999997(uint256),TMP_777(uint256) = INTERNAL_CALL, ZethrBigWheel.random(uint256,uint256,address,uint256)(999996,_blockNumber,_target,0),TMP_778(uint256) = TMP_777 + 1,result(uint256) := TMP_778(uint256),REF_366(uint256) -> betsMul[0],REF_367(uint40) -> _bets[0],TMP_779 = CONVERT REF_367 to uint256,TMP_780(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_779', '100000000000000'] ,REF_366(uint256) (->betsMul) := TMP_780(uint256),REF_369(uint256) -> betsMul[1],REF_370(uint40) -> _bets[1],TMP_781 = CONVERT REF_370 to uint256,TMP_782(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_781', '100000000000000'] ,REF_369(uint256) (->betsMul) := TMP_782(uint256),REF_372(uint256) -> betsMul[2],REF_373(uint40) -> _bets[2],TMP_783 = CONVERT REF_373 to uint256,TMP_784(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_783', '100000000000000'] ,REF_372(uint256) (->betsMul) := TMP_784(uint256),REF_375(uint256) -> betsMul[3],REF_376(uint40) -> _bets[3],TMP_785 = CONVERT REF_376 to uint256,TMP_786(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_785', '100000000000000'] ,REF_375(uint256) (->betsMul) := TMP_786(uint256),REF_378(uint256) -> betsMul[4],REF_379(uint40) -> _bets[4],TMP_787 = CONVERT REF_379 to uint256,TMP_788(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_787', '100000000000000'] ,REF_378(uint256) (->betsMul) := TMP_788(uint256),REF_381(uint256) -> betsMul[0],REF_382(uint256) -> betsMul[1],TMP_789(uint256) = REF_381 + REF_382,REF_383(uint256) -> betsMul[2],TMP_790(uint256) = TMP_789 + REF_383,REF_384(uint256) -> betsMul[3],TMP_791(uint256) = TMP_790 + REF_384,REF_385(uint256) -> betsMul[4],TMP_792(uint256) = TMP_791 + REF_385,lossAmount(uint256) := TMP_792(uint256),_winCategory(uint256) := 0(uint256),TMP_793(bool) = result < 2,CONDITION TMP_793,TMP_794(uint256) := jackpotWins(uint256),jackpotWins(uint256) = jackpotWins + 1,_winCategory(uint256) := 99(uint256),TMP_795(bool) = result < 27028,CONDITION TMP_795,REF_386(uint256) -> betsMul[4],TMP_796(bool) = REF_386 > 0,CONDITION TMP_796,_winCategory(uint256) := 25(uint256),REF_388(uint256) -> betsMul[4],TMP_797(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_388', '25'] ,winAmount(uint256) := TMP_797(uint256),REF_389(uint256) -> betsMul[4],lossAmount(uint256) = lossAmount - REF_389,TMP_798(bool) = result < 108108,CONDITION TMP_798,REF_390(uint256) -> betsMul[3],TMP_799(bool) = REF_390 > 0,CONDITION TMP_799,_winCategory(uint256) := 10(uint256),REF_392(uint256) -> betsMul[3],TMP_800(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_392', '10'] ,winAmount(uint256) := TMP_800(uint256),REF_393(uint256) -> betsMul[3],lossAmount(uint256) = lossAmount - REF_393,TMP_801(bool) = result < 270269,CONDITION TMP_801,REF_394(uint256) -> betsMul[2],TMP_802(bool) = REF_394 > 0,CONDITION TMP_802,_winCategory(uint256) := 6(uint256),REF_396(uint256) -> betsMul[2],TMP_803(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_396', '6'] ,winAmount(uint256) := TMP_803(uint256),REF_397(uint256) -> betsMul[2],lossAmount(uint256) = lossAmount - REF_397,TMP_804(bool) = result < 513512,CONDITION TMP_804,REF_398(uint256) -> betsMul[1],TMP_805(bool) = REF_398 > 0,CONDITION TMP_805,_winCategory(uint256) := 4(uint256),REF_400(uint256) -> betsMul[1],TMP_806(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_400', '4'] ,winAmount(uint256) := TMP_806(uint256),REF_401(uint256) -> betsMul[1],lossAmount(uint256) = lossAmount - REF_401,TMP_807(bool) = result < 999997,CONDITION TMP_807,REF_402(uint256) -> betsMul[0],TMP_808(bool) = REF_402 > 0,CONDITION TMP_808,_winCategory(uint256) := 2(uint256),REF_404(uint256) -> betsMul[0],TMP_809(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_404', '2'] ,winAmount(uint256) := TMP_809(uint256),REF_405(uint256) -> betsMul[0],lossAmount(uint256) = lossAmount - REF_405,TMP_810(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['lossAmount', '100'] ,jackpotAmount(uint256) := TMP_810(uint256),lossAmount(uint256) = lossAmount - jackpotAmount,Emit WheelResult(_blockNumber,_target,_bets,winAmount,lossAmount,_winCategory),RETURN winAmount,lossAmount,jackpotAmount,jackpotWins,result,RETURN winAmount,lossAmount,jackpotAmount,jackpotWins,output","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_bets = uintToBetsArray(_bets_notconverted)

IRs:
TMP_774(uint40[5]) = INTERNAL_CALL, ZethrBigWheel.uintToBetsArray(uint256)(_bets_notconverted)
_bets(uint40[5]) = ['TMP_774(uint40[5])']""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
block.number - _blockNumber > 255

IRs:
TMP_775(uint256) = block.number - _blockNumber
TMP_776(bool) = TMP_775 > 255
CONDITION TMP_776""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
result = 999997

IRs:
result(uint256) := 999997(uint256)""];
4->6;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
result = random(999996,_blockNumber,_target,0) + 1

IRs:
TMP_777(uint256) = INTERNAL_CALL, ZethrBigWheel.random(uint256,uint256,address,uint256)(999996,_blockNumber,_target,0)
TMP_778(uint256) = TMP_777 + 1
result(uint256) := TMP_778(uint256)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: NEW VARIABLE 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
betsMul[0] = uint256(_bets[0]).mul(1e14)

IRs:
REF_366(uint256) -> betsMul[0]
REF_367(uint40) -> _bets[0]
TMP_779 = CONVERT REF_367 to uint256
TMP_780(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_779', '100000000000000'] 
REF_366(uint256) (->betsMul) := TMP_780(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
betsMul[1] = uint256(_bets[1]).mul(1e14)

IRs:
REF_369(uint256) -> betsMul[1]
REF_370(uint40) -> _bets[1]
TMP_781 = CONVERT REF_370 to uint256
TMP_782(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_781', '100000000000000'] 
REF_369(uint256) (->betsMul) := TMP_782(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
betsMul[2] = uint256(_bets[2]).mul(1e14)

IRs:
REF_372(uint256) -> betsMul[2]
REF_373(uint40) -> _bets[2]
TMP_783 = CONVERT REF_373 to uint256
TMP_784(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_783', '100000000000000'] 
REF_372(uint256) (->betsMul) := TMP_784(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
betsMul[3] = uint256(_bets[3]).mul(1e14)

IRs:
REF_375(uint256) -> betsMul[3]
REF_376(uint40) -> _bets[3]
TMP_785 = CONVERT REF_376 to uint256
TMP_786(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_785', '100000000000000'] 
REF_375(uint256) (->betsMul) := TMP_786(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
betsMul[4] = uint256(_bets[4]).mul(1e14)

IRs:
REF_378(uint256) -> betsMul[4]
REF_379(uint40) -> _bets[4]
TMP_787 = CONVERT REF_379 to uint256
TMP_788(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_787', '100000000000000'] 
REF_378(uint256) (->betsMul) := TMP_788(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
lossAmount = betsMul[0] + betsMul[1] + betsMul[2] + betsMul[3] + betsMul[4]

IRs:
REF_381(uint256) -> betsMul[0]
REF_382(uint256) -> betsMul[1]
TMP_789(uint256) = REF_381 + REF_382
REF_383(uint256) -> betsMul[2]
TMP_790(uint256) = TMP_789 + REF_383
REF_384(uint256) -> betsMul[3]
TMP_791(uint256) = TMP_790 + REF_384
REF_385(uint256) -> betsMul[4]
TMP_792(uint256) = TMP_791 + REF_385
lossAmount(uint256) := TMP_792(uint256)""];
13->14;
14[label=""Node Type: NEW VARIABLE 14

EXPRESSION:
_winCategory = 0

IRs:
_winCategory(uint256) := 0(uint256)""];
14->15;
15[label=""Node Type: IF 15

EXPRESSION:
result < 2

IRs:
TMP_793(bool) = result < 2
CONDITION TMP_793""];
15->16[label=""True""];
15->18[label=""False""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
jackpotWins ++

IRs:
TMP_794(uint256) := jackpotWins(uint256)
jackpotWins(uint256) = jackpotWins + 1""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
_winCategory = 99

IRs:
_winCategory(uint256) := 99(uint256)""];
17->55;
18[label=""Node Type: IF 18

EXPRESSION:
result < 27028

IRs:
TMP_795(bool) = result < 27028
CONDITION TMP_795""];
18->19[label=""True""];
18->24[label=""False""];
19[label=""Node Type: IF 19

EXPRESSION:
betsMul[4] > 0

IRs:
REF_386(uint256) -> betsMul[4]
TMP_796(bool) = REF_386 > 0
CONDITION TMP_796""];
19->20[label=""True""];
19->23[label=""False""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
_winCategory = 25

IRs:
_winCategory(uint256) := 25(uint256)""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
winAmount = SafeMath.mul(betsMul[4],25)

IRs:
REF_388(uint256) -> betsMul[4]
TMP_797(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_388', '25'] 
winAmount(uint256) := TMP_797(uint256)""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
lossAmount -= betsMul[4]

IRs:
REF_389(uint256) -> betsMul[4]
lossAmount(uint256) = lossAmount - REF_389""];
22->23;
23[label=""Node Type: END_IF 23
""];
23->52;
24[label=""Node Type: IF 24

EXPRESSION:
result < 108108

IRs:
TMP_798(bool) = result < 108108
CONDITION TMP_798""];
24->25[label=""True""];
24->30[label=""False""];
25[label=""Node Type: IF 25

EXPRESSION:
betsMul[3] > 0

IRs:
REF_390(uint256) -> betsMul[3]
TMP_799(bool) = REF_390 > 0
CONDITION TMP_799""];
25->26[label=""True""];
25->29[label=""False""];
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
_winCategory = 10

IRs:
_winCategory(uint256) := 10(uint256)""];
26->27;
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
winAmount = SafeMath.mul(betsMul[3],10)

IRs:
REF_392(uint256) -> betsMul[3]
TMP_800(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_392', '10'] 
winAmount(uint256) := TMP_800(uint256)""];
27->28;
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
lossAmount -= betsMul[3]

IRs:
REF_393(uint256) -> betsMul[3]
lossAmount(uint256) = lossAmount - REF_393""];
28->29;
29[label=""Node Type: END_IF 29
""];
29->51;
30[label=""Node Type: IF 30

EXPRESSION:
result < 270269

IRs:
TMP_801(bool) = result < 270269
CONDITION TMP_801""];
30->31[label=""True""];
30->36[label=""False""];
31[label=""Node Type: IF 31

EXPRESSION:
betsMul[2] > 0

IRs:
REF_394(uint256) -> betsMul[2]
TMP_802(bool) = REF_394 > 0
CONDITION TMP_802""];
31->32[label=""True""];
31->35[label=""False""];
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
_winCategory = 6

IRs:
_winCategory(uint256) := 6(uint256)""];
32->33;
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
winAmount = SafeMath.mul(betsMul[2],6)

IRs:
REF_396(uint256) -> betsMul[2]
TMP_803(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_396', '6'] 
winAmount(uint256) := TMP_803(uint256)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
lossAmount -= betsMul[2]

IRs:
REF_397(uint256) -> betsMul[2]
lossAmount(uint256) = lossAmount - REF_397""];
34->35;
35[label=""Node Type: END_IF 35
""];
35->50;
36[label=""Node Type: IF 36

EXPRESSION:
result < 513512

IRs:
TMP_804(bool) = result < 513512
CONDITION TMP_804""];
36->37[label=""True""];
36->42[label=""False""];
37[label=""Node Type: IF 37

EXPRESSION:
betsMul[1] > 0

IRs:
REF_398(uint256) -> betsMul[1]
TMP_805(bool) = REF_398 > 0
CONDITION TMP_805""];
37->38[label=""True""];
37->41[label=""False""];
38[label=""Node Type: EXPRESSION 38

EXPRESSION:
_winCategory = 4

IRs:
_winCategory(uint256) := 4(uint256)""];
38->39;
39[label=""Node Type: EXPRESSION 39

EXPRESSION:
winAmount = SafeMath.mul(betsMul[1],4)

IRs:
REF_400(uint256) -> betsMul[1]
TMP_806(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_400', '4'] 
winAmount(uint256) := TMP_806(uint256)""];
39->40;
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
lossAmount -= betsMul[1]

IRs:
REF_401(uint256) -> betsMul[1]
lossAmount(uint256) = lossAmount - REF_401""];
40->41;
41[label=""Node Type: END_IF 41
""];
41->49;
42[label=""Node Type: IF 42

EXPRESSION:
result < 999997

IRs:
TMP_807(bool) = result < 999997
CONDITION TMP_807""];
42->43[label=""True""];
42->48[label=""False""];
43[label=""Node Type: IF 43

EXPRESSION:
betsMul[0] > 0

IRs:
REF_402(uint256) -> betsMul[0]
TMP_808(bool) = REF_402 > 0
CONDITION TMP_808""];
43->44[label=""True""];
43->47[label=""False""];
44[label=""Node Type: EXPRESSION 44

EXPRESSION:
_winCategory = 2

IRs:
_winCategory(uint256) := 2(uint256)""];
44->45;
45[label=""Node Type: EXPRESSION 45

EXPRESSION:
winAmount = SafeMath.mul(betsMul[0],2)

IRs:
REF_404(uint256) -> betsMul[0]
TMP_809(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_404', '2'] 
winAmount(uint256) := TMP_809(uint256)""];
45->46;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
lossAmount -= betsMul[0]

IRs:
REF_405(uint256) -> betsMul[0]
lossAmount(uint256) = lossAmount - REF_405""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: END_IF 49
""];
49->50;
50[label=""Node Type: END_IF 50
""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: END_IF 52
""];
52->53;
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
jackpotAmount = lossAmount.div(100)

IRs:
TMP_810(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['lossAmount', '100'] 
jackpotAmount(uint256) := TMP_810(uint256)""];
53->54;
54[label=""Node Type: EXPRESSION 54

EXPRESSION:
lossAmount -= jackpotAmount

IRs:
lossAmount(uint256) = lossAmount - jackpotAmount""];
54->55;
55[label=""Node Type: END_IF 55
""];
55->56;
56[label=""Node Type: EXPRESSION 56

EXPRESSION:
WheelResult(_blockNumber,_target,_bets,winAmount,lossAmount,_winCategory)

IRs:
Emit WheelResult(_blockNumber,_target,_bets,winAmount,lossAmount,_winCategory)""];
56->57;
57[label=""Node Type: RETURN 57

EXPRESSION:
(winAmount,lossAmount,jackpotAmount,jackpotWins,result)

IRs:
RETURN winAmount,lossAmount,jackpotAmount,jackpotWins,result""];
58[label=""Node Type: RETURN 58

EXPRESSION:
(winAmount,lossAmount,jackpotAmount,jackpotWins,output)

IRs:
RETURN winAmount,lossAmount,jackpotAmount,jackpotWins,output""];
}
",0,1,0,0,"_bets = uintToBetsArray(_bets_notconverted);;block.number - _blockNumber > 255;result = 999997;result = random(999996,_blockNumber,_target,0) + 1;;;betsMul[0] = uint256(_bets[0]).mul(1e14);betsMul[1] = uint256(_bets[1]).mul(1e14);betsMul[2] = uint256(_bets[2]).mul(1e14);betsMul[3] = uint256(_bets[3]).mul(1e14);betsMul[4] = uint256(_bets[4]).mul(1e14);lossAmount = betsMul[0] + betsMul[1] + betsMul[2] + betsMul[3] + betsMul[4];_winCategory = 0;result < 2;jackpotWins ++;result < 27028;_winCategory = 99;;betsMul[4] > 0;result < 108108;_winCategory = 25;;winAmount = SafeMath.mul(betsMul[4],25);lossAmount -= betsMul[4];;betsMul[3] > 0;result < 270269;_winCategory = 10;;winAmount = SafeMath.mul(betsMul[3],10);lossAmount -= betsMul[3];;betsMul[2] > 0;result < 513512;_winCategory = 6;;winAmount = SafeMath.mul(betsMul[2],6);lossAmount -= betsMul[2];;betsMul[1] > 0;result < 999997;_winCategory = 4;;winAmount = SafeMath.mul(betsMul[1],4);lossAmount -= betsMul[1];;betsMul[0] > 0;;_winCategory = 2;;winAmount = SafeMath.mul(betsMul[0],2);lossAmount -= betsMul[0];jackpotAmount = lossAmount.div(100);lossAmount -= jackpotAmount;WheelResult(_blockNumber,_target,_bets,winAmount,lossAmount,_winCategory);(winAmount,lossAmount,jackpotAmount,jackpotWins,result);(winAmount,lossAmount,jackpotAmount,jackpotWins,output)"
./0xc5b106f17246b2f5c0c658dbd6e8d168695806ab_ext.sol,SIEToken.burn,111,116,"REF_19(uint256) -> balanceOf[msg.sender],TMP_45(bool) = REF_19 >= _value,TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45),REF_20(uint256) -> balanceOf[msg.sender],REF_20(-> balanceOf) = REF_20 - _value,REF_21(uint256) -> balanceOf[0],REF_21(-> balanceOf) = REF_21 + _value,Emit Transfer(msg.sender,0,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_19(uint256) -> balanceOf[msg.sender]
TMP_45(bool) = REF_19 >= _value
TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_20(uint256) -> balanceOf[msg.sender]
REF_20(-> balanceOf) = REF_20 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[0x0] += _value

IRs:
REF_21(uint256) -> balanceOf[0]
REF_21(-> balanceOf) = REF_21 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,0x0,_value)

IRs:
Emit Transfer(msg.sender,0,_value)""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;balanceOf[0x0] += _value;Transfer(msg.sender,0x0,_value)"
./0x5b5d0fbbd75d4501e5cdc854c445fb0eabcb0afc_ext.sol,EmrCrowdfund.burnFrom,69,75,"REF_8(uint256) -> balanceOf[_from],TMP_25(bool) = REF_8 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_9(uint256) -> balanceOf[_from],REF_9(-> balanceOf) = REF_9 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,MODIFIER_CALL, owned.onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_8(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_8 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_9(uint256) -> balanceOf[_from]
REF_9(-> balanceOf) = REF_9 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
6->1;
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"onlyOwner();require(bool)(balanceOf[_from] >= _value);balanceOf[_from] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x0d67440946949fe293b45c52efd8a9b3d51e2522_ext.sol,MultipleArbitrableTransaction.executeRuling,659,679,"REF_208(MultipleArbitrableTransaction.Transaction) -> transactions[_transactionID],transaction(MultipleArbitrableTransaction.Transaction) := REF_208(MultipleArbitrableTransaction.Transaction),TMP_227(bool) = _ruling <= AMOUNT_OF_CHOICES,TMP_228(None) = SOLIDITY_CALL require(bool,string)(TMP_227,Invalid ruling.),TMP_229(bool) = _ruling == SENDER_WINS,CONDITION TMP_229,REF_209(address) -> transaction.sender,REF_211(uint256) -> transaction.senderFee,REF_212(uint256) -> transaction.amount,TMP_230(uint256) = REF_211 + REF_212,TMP_231 = SEND dest:REF_209 value:TMP_230,TMP_232(bool) = _ruling == RECEIVER_WINS,CONDITION TMP_232,REF_213(address) -> transaction.receiver,REF_215(uint256) -> transaction.receiverFee,REF_216(uint256) -> transaction.amount,TMP_233(uint256) = REF_215 + REF_216,TMP_234 = SEND dest:REF_213 value:TMP_233,REF_217(uint256) -> transaction.senderFee,REF_218(uint256) -> transaction.amount,TMP_235(uint256) = REF_217 + REF_218,TMP_236(uint256) = TMP_235 / 2,split_amount(uint256) := TMP_236(uint256),REF_219(address) -> transaction.sender,TMP_237 = SEND dest:REF_219 value:split_amount,REF_221(address) -> transaction.receiver,TMP_238 = SEND dest:REF_221 value:split_amount,REF_223(uint256) -> transaction.amount,REF_223(uint256) (->transaction) := 0(uint256),REF_224(uint256) -> transaction.senderFee,REF_224(uint256) (->transaction) := 0(uint256),REF_225(uint256) -> transaction.receiverFee,REF_225(uint256) (->transaction) := 0(uint256),REF_226(MultipleArbitrableTransaction.Status) -> transaction.status,REF_227(MultipleArbitrableTransaction.Status) -> Status.Resolved,REF_226(MultipleArbitrableTransaction.Status) (->transaction) := REF_227(MultipleArbitrableTransaction.Status)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
transaction = transactions[_transactionID]

IRs:
REF_208(MultipleArbitrableTransaction.Transaction) -> transactions[_transactionID]
transaction(MultipleArbitrableTransaction.Transaction) := REF_208(MultipleArbitrableTransaction.Transaction)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(_ruling <= AMOUNT_OF_CHOICES,Invalid ruling.)

IRs:
TMP_227(bool) = _ruling <= AMOUNT_OF_CHOICES
TMP_228(None) = SOLIDITY_CALL require(bool,string)(TMP_227,Invalid ruling.)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_ruling == SENDER_WINS

IRs:
TMP_229(bool) = _ruling == SENDER_WINS
CONDITION TMP_229""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
transaction.sender.send(transaction.senderFee + transaction.amount)

IRs:
REF_209(address) -> transaction.sender
REF_211(uint256) -> transaction.senderFee
REF_212(uint256) -> transaction.amount
TMP_230(uint256) = REF_211 + REF_212
TMP_231 = SEND dest:REF_209 value:TMP_230""];
4->11;
5[label=""Node Type: IF 5

EXPRESSION:
_ruling == RECEIVER_WINS

IRs:
TMP_232(bool) = _ruling == RECEIVER_WINS
CONDITION TMP_232""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
transaction.receiver.send(transaction.receiverFee + transaction.amount)

IRs:
REF_213(address) -> transaction.receiver
REF_215(uint256) -> transaction.receiverFee
REF_216(uint256) -> transaction.amount
TMP_233(uint256) = REF_215 + REF_216
TMP_234 = SEND dest:REF_213 value:TMP_233""];
6->10;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
split_amount = (transaction.senderFee + transaction.amount) / 2

IRs:
REF_217(uint256) -> transaction.senderFee
REF_218(uint256) -> transaction.amount
TMP_235(uint256) = REF_217 + REF_218
TMP_236(uint256) = TMP_235 / 2
split_amount(uint256) := TMP_236(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
transaction.sender.send(split_amount)

IRs:
REF_219(address) -> transaction.sender
TMP_237 = SEND dest:REF_219 value:split_amount""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
transaction.receiver.send(split_amount)

IRs:
REF_221(address) -> transaction.receiver
TMP_238 = SEND dest:REF_221 value:split_amount""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
transaction.amount = 0

IRs:
REF_223(uint256) -> transaction.amount
REF_223(uint256) (->transaction) := 0(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
transaction.senderFee = 0

IRs:
REF_224(uint256) -> transaction.senderFee
REF_224(uint256) (->transaction) := 0(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
transaction.receiverFee = 0

IRs:
REF_225(uint256) -> transaction.receiverFee
REF_225(uint256) (->transaction) := 0(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
transaction.status = Status.Resolved

IRs:
REF_226(MultipleArbitrableTransaction.Status) -> transaction.status
REF_227(MultipleArbitrableTransaction.Status) -> Status.Resolved
REF_226(MultipleArbitrableTransaction.Status) (->transaction) := REF_227(MultipleArbitrableTransaction.Status)""];
}
",0,1,1,0,"transaction = transactions[_transactionID];require(bool,string)(_ruling <= AMOUNT_OF_CHOICES,Invalid ruling.);_ruling == SENDER_WINS;transaction.sender.send(transaction.senderFee + transaction.amount);_ruling == RECEIVER_WINS;;transaction.receiver.send(transaction.receiverFee + transaction.amount);split_amount = (transaction.senderFee + transaction.amount) / 2;;transaction.sender.send(split_amount);transaction.receiver.send(split_amount);transaction.amount = 0;transaction.senderFee = 0;transaction.receiverFee = 0;transaction.status = Status.Resolved"
./0x40d612fe5ebef1a539e5b4a6bfcab8d09aee223f_ext.sol,POTJ.dividendsOf,464,470,"REF_36(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_68(uint256) = profitPerShare_ * REF_36,TMP_69 = CONVERT TMP_68 to int256,REF_37(int256) -> payoutsTo_[_customerAddress],TMP_70(int256) = TMP_69 - REF_37,TMP_71 = CONVERT TMP_70 to uint256,TMP_72(uint256) = TMP_71 / magnitude,RETURN TMP_72","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_36(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_68(uint256) = profitPerShare_ * REF_36
TMP_69 = CONVERT TMP_68 to int256
REF_37(int256) -> payoutsTo_[_customerAddress]
TMP_70(int256) = TMP_69 - REF_37
TMP_71 = CONVERT TMP_70 to uint256
TMP_72(uint256) = TMP_71 / magnitude
RETURN TMP_72""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x3a1237d38d0fb94513f85d61679cad7f38507242_ext.sol,MindexcoinToken.mintToken,208,213,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x40489719e489782959486a04b765e1e93e5b221a_ext.sol,SGEToken.burnFrom,57,65,"REF_18(uint256) -> balanceOf[_from],TMP_22(bool) = REF_18 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_19(mapping(address => uint256)) -> allowance[_from],REF_20(uint256) -> REF_19[msg.sender],TMP_24(bool) = _value <= REF_20,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_21(uint256) -> balanceOf[_from],REF_21(-> balanceOf) = REF_21 - _value,REF_22(mapping(address => uint256)) -> allowance[_from],REF_23(uint256) -> REF_22[msg.sender],REF_23(-> allowance) = REF_23 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_18(uint256) -> balanceOf[_from]
TMP_22(bool) = REF_18 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_19(mapping(address => uint256)) -> allowance[_from]
REF_20(uint256) -> REF_19[msg.sender]
TMP_24(bool) = _value <= REF_20
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_21(uint256) -> balanceOf[_from]
REF_21(-> balanceOf) = REF_21 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_22(mapping(address => uint256)) -> allowance[_from]
REF_23(uint256) -> REF_22[msg.sender]
REF_23(-> allowance) = REF_23 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x33286518eff61b810b9796cf847d84be65160147_ext.sol,XCAToken.burn,128,134,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x26fa4ab937bf885d06cfb3eabb89eeef9af1978a_ext.sol,digithothToken.approveAndCall,206,211,"REF_18(mapping(address => uint256)) -> allowed[msg.sender],REF_19(uint256) -> REF_18[spender],REF_19(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_56 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_56(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_18(mapping(address => uint256)) -> allowed[msg.sender]
REF_19(uint256) -> REF_18[spender]
REF_19(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_56 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_56(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x1a94fdf6d0bf45d298557789550bb2d7e359ca2d_ext.sol,CrossChainEntertainmentTokenE.transferFrom,111,127,"REF_5(mapping(address => uint256)) -> allowed[_from],REF_6(uint256) -> REF_5[msg.sender],allowance(uint256) := REF_6(uint256),REF_7(uint256) -> balances[_from],TMP_29(bool) = REF_7 >= _value,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),TMP_31(bool) = _from == _to,REF_8(uint256) -> balances[_to],TMP_32(uint256) = MAX_UINT256 - _value,TMP_33(bool) = REF_8 <= TMP_32,TMP_34(bool) = TMP_31 || TMP_33,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),TMP_36(bool) = allowance >= _value,TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36),REF_9(uint256) -> balances[_from],REF_9(-> balances) = REF_9 - _value,REF_10(uint256) -> balances[_to],REF_10(-> balances) = REF_10 + _value,TMP_38(bool) = allowance < MAX_UINT256,CONDITION TMP_38,REF_11(mapping(address => uint256)) -> allowed[_from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowed) = REF_12 - _value,Emit Transfer(_from,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
allowance = allowed[_from][msg.sender]

IRs:
REF_5(mapping(address => uint256)) -> allowed[_from]
REF_6(uint256) -> REF_5[msg.sender]
allowance(uint256) := REF_6(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] >= _value)

IRs:
REF_7(uint256) -> balances[_from]
TMP_29(bool) = REF_7 >= _value
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_from == _to || balances[_to] <= MAX_UINT256 - _value)

IRs:
TMP_31(bool) = _from == _to
REF_8(uint256) -> balances[_to]
TMP_32(uint256) = MAX_UINT256 - _value
TMP_33(bool) = REF_8 <= TMP_32
TMP_34(bool) = TMP_31 || TMP_33
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(allowance >= _value)

IRs:
TMP_36(bool) = allowance >= _value
TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[_from] -= _value

IRs:
REF_9(uint256) -> balances[_from]
REF_9(-> balances) = REF_9 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[_to] += _value

IRs:
REF_10(uint256) -> balances[_to]
REF_10(-> balances) = REF_10 + _value""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
allowance < MAX_UINT256

IRs:
TMP_38(bool) = allowance < MAX_UINT256
CONDITION TMP_38""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_11(mapping(address => uint256)) -> allowed[_from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowed) = REF_12 - _value""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
10->11;
11[label=""Node Type: RETURN 11

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"allowance = allowed[_from][msg.sender];require(bool)(balances[_from] >= _value);require(bool)(_from == _to || balances[_to] <= MAX_UINT256 - _value);require(bool)(allowance >= _value);balances[_from] -= _value;balances[_to] += _value;allowance < MAX_UINT256;allowed[_from][msg.sender] -= _value;;Transfer(_from,_to,_value);true"
./0x6d402b714df85f7fa3d257f1e6a86b62d099a4f3_ext.sol,BWCToken.burn,147,155,"REF_24(uint256) -> balances[msg.sender],TMP_51(bool) = _value <= REF_24,TMP_52(None) = SOLIDITY_CALL require(bool)(TMP_51),REF_25(uint256) -> balances[msg.sender],REF_26(uint256) -> balances[msg.sender],TMP_53(uint256) = REF_26 - _value,REF_25(uint256) (->balances) := TMP_53(uint256),TMP_54(uint256) = totalSupply - _value,totalSupply(uint256) := TMP_54(uint256),Emit Burn(msg.sender,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_24(uint256) -> balances[msg.sender]
TMP_51(bool) = _value <= REF_24
TMP_52(None) = SOLIDITY_CALL require(bool)(TMP_51)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] = balances[msg.sender] - _value

IRs:
REF_25(uint256) -> balances[msg.sender]
REF_26(uint256) -> balances[msg.sender]
TMP_53(uint256) = REF_26 - _value
REF_25(uint256) (->balances) := TMP_53(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply = totalSupply - _value

IRs:
TMP_54(uint256) = totalSupply - _value
totalSupply(uint256) := TMP_54(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(_value <= balances[msg.sender]);balances[msg.sender] = balances[msg.sender] - _value;totalSupply = totalSupply - _value;Burn(msg.sender,_value);true"
./0x6e7a61fbe11873f4c7d0983c79683aad5c0788bd_ext.sol,ERC20Receive.tokenFallback,75,84,"REF_0(address) -> tkn.sender,REF_0(address) (->tkn) := _from(address),REF_1(uint256) -> tkn.value,REF_1(uint256) (->tkn) := _value(uint256),REF_2(bytes) -> tkn.data,REF_2(bytes) (->tkn) := _data(bytes),REF_3(None) -> _data[3],TMP_12 = CONVERT REF_3 to uint32,REF_4(None) -> _data[2],TMP_13 = CONVERT REF_4 to uint32,TMP_14(uint32) = TMP_13 << 8,TMP_15(uint32) = TMP_12 + TMP_14,REF_5(None) -> _data[1],TMP_16 = CONVERT REF_5 to uint32,TMP_17(uint32) = TMP_16 << 16,TMP_18(uint32) = TMP_15 + TMP_17,REF_6(None) -> _data[0],TMP_19 = CONVERT REF_6 to uint32,TMP_20(uint32) = TMP_19 << 24,TMP_21(uint32) = TMP_18 + TMP_20,u(uint32) := TMP_21(uint32),REF_7(bytes4) -> tkn.sig,TMP_22 = CONVERT u to bytes4,REF_7(bytes4) (->tkn) := TMP_22(bytes4)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
tkn.sender = _from

IRs:
REF_0(address) -> tkn.sender
REF_0(address) (->tkn) := _from(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tkn.value = _value

IRs:
REF_1(uint256) -> tkn.value
REF_1(uint256) (->tkn) := _value(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
tkn.data = _data

IRs:
REF_2(bytes) -> tkn.data
REF_2(bytes) (->tkn) := _data(bytes)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24)

IRs:
REF_3(None) -> _data[3]
TMP_12 = CONVERT REF_3 to uint32
REF_4(None) -> _data[2]
TMP_13 = CONVERT REF_4 to uint32
TMP_14(uint32) = TMP_13 << 8
TMP_15(uint32) = TMP_12 + TMP_14
REF_5(None) -> _data[1]
TMP_16 = CONVERT REF_5 to uint32
TMP_17(uint32) = TMP_16 << 16
TMP_18(uint32) = TMP_15 + TMP_17
REF_6(None) -> _data[0]
TMP_19 = CONVERT REF_6 to uint32
TMP_20(uint32) = TMP_19 << 24
TMP_21(uint32) = TMP_18 + TMP_20
u(uint32) := TMP_21(uint32)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tkn.sig = bytes4(u)

IRs:
REF_7(bytes4) -> tkn.sig
TMP_22 = CONVERT u to bytes4
REF_7(bytes4) (->tkn) := TMP_22(bytes4)""];
}
",0,1,0,0,;tkn.sender = _from;tkn.value = _value;tkn.data = _data;u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);tkn.sig = bytes4(u)
./0x72bd9e034a034796d77b080bb3d477333c651be4_ext.sol,StandardToken.transferFrom,58,68,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0xa35f8ec479ba1f8113b27636f1dfa3ae30c3eeae_ext.sol,BaseToken._transfer,15,24,"TMP_0(bool) = _to != 0,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_0(uint256) -> balanceOf[_from],TMP_2(bool) = REF_0 >= _value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_1(uint256) -> balanceOf[_to],TMP_4(uint256) = REF_1 + _value,REF_2(uint256) -> balanceOf[_to],TMP_5(bool) = TMP_4 > REF_2,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_3(uint256) -> balanceOf[_from],REF_4(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_3 + REF_4,previousBalances(uint256) := TMP_7(uint256),REF_5(uint256) -> balanceOf[_from],REF_5(-> balanceOf) = REF_5 - _value,REF_6(uint256) -> balanceOf[_to],REF_6(-> balanceOf) = REF_6 + _value,REF_7(uint256) -> balanceOf[_from],REF_8(uint256) -> balanceOf[_to],TMP_8(uint256) = REF_7 + REF_8,TMP_9(bool) = TMP_8 == previousBalances,TMP_10(None) = SOLIDITY_CALL assert(bool)(TMP_9),Emit Transfer(_from,_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_0(bool) = _to != 0
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_0(uint256) -> balanceOf[_from]
TMP_2(bool) = REF_0 >= _value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value > balanceOf[_to])

IRs:
REF_1(uint256) -> balanceOf[_to]
TMP_4(uint256) = REF_1 + _value
REF_2(uint256) -> balanceOf[_to]
TMP_5(bool) = TMP_4 > REF_2
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_3(uint256) -> balanceOf[_from]
REF_4(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_3 + REF_4
previousBalances(uint256) := TMP_7(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_5(uint256) -> balanceOf[_from]
REF_5(-> balanceOf) = REF_5 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_6(uint256) -> balanceOf[_to]
REF_6(-> balanceOf) = REF_6 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_7(uint256) -> balanceOf[_from]
REF_8(uint256) -> balanceOf[_to]
TMP_8(uint256) = REF_7 + REF_8
TMP_9(bool) = TMP_8 == previousBalances
TMP_10(None) = SOLIDITY_CALL assert(bool)(TMP_9)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value > balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances);Transfer(_from,_to,_value)"
./0x69b3d13bb1d2542c85f0dfc6cba4c0ba8d919ec6_ext.sol,JYBToken.burnFrom,71,79,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x41de5b7cf63c8d028daa2626d9aeaf02cad8c6c3_ext.sol,queue.queueSize,63,65,"REF_0(uint256) -> q.back,REF_1(uint256) -> q.front,TMP_15(uint256) = REF_0 - REF_1,r(uint256) := TMP_15(uint256),RETURN r","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
r = q.back - q.front

IRs:
REF_0(uint256) -> q.back
REF_1(uint256) -> q.front
TMP_15(uint256) = REF_0 - REF_1
r(uint256) := TMP_15(uint256)""];
1->2;
2[label=""Node Type: RETURN 2

EXPRESSION:
r

IRs:
RETURN r""];
}
",0,1,0,0,r = q.back - q.front;r
./0x1e05efba2fd19cc48a123a9e38afa6a9ffc18f41_ext.sol,TwentyOneMillionToken.mintToken,345,350,"REF_140(uint256) -> balances[target],REF_140(-> balances) = REF_140 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances[target] += mintedAmount

IRs:
REF_140(uint256) -> balances[target]
REF_140(-> balances) = REF_140 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balances[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x025abad9e518516fdaafbdcdb9701b37fb7ef0fa_ext.sol,StandardMintableToken.burnFrom,142,153,"REF_26(bool) -> frozenAccount[msg.sender],CONDITION REF_26,REF_27(bool) -> frozenAccount[_from],CONDITION REF_27,TMP_22(bool) = _value == 0,CONDITION TMP_22,RETURN False,REF_28(uint256) -> balanceOf[_from],TMP_23(bool) = REF_28 < _value,CONDITION TMP_23,RETURN False,REF_29(mapping(address => uint256)) -> allowance[_from],REF_30(uint256) -> REF_29[msg.sender],TMP_24(bool) = _value > REF_30,CONDITION TMP_24,REF_31(uint256) -> balanceOf[_from],REF_31(-> balanceOf) = REF_31 - _value,totalSupply(uint256) = totalSupply - _value,REF_32(mapping(address => uint256)) -> allowance[_from],REF_33(uint256) -> REF_32[msg.sender],REF_33(-> allowance) = REF_33 - _value,Emit Transfer(_from,0,_value),RETURN True,MODIFIER_CALL, owned.onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->21;
1[label=""Node Type: IF 1

EXPRESSION:
frozenAccount[msg.sender]

IRs:
REF_26(bool) -> frozenAccount[msg.sender]
CONDITION REF_26""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
frozenAccount[_from]

IRs:
REF_27(bool) -> frozenAccount[_from]
CONDITION REF_27""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: THROW 5
""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
_value == 0

IRs:
TMP_22(bool) = _value == 0
CONDITION TMP_22""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
balanceOf[_from] < _value

IRs:
REF_28(uint256) -> balanceOf[_from]
TMP_23(bool) = REF_28 < _value
CONDITION TMP_23""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: RETURN 11

EXPRESSION:
false

IRs:
RETURN False""];
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
_value > allowance[_from][msg.sender]

IRs:
REF_29(mapping(address => uint256)) -> allowance[_from]
REF_30(uint256) -> REF_29[msg.sender]
TMP_24(bool) = _value > REF_30
CONDITION TMP_24""];
13->14[label=""True""];
13->15[label=""False""];
14[label=""Node Type: THROW 14
""];
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_31(uint256) -> balanceOf[_from]
REF_31(-> balanceOf) = REF_31 - _value""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_32(mapping(address => uint256)) -> allowance[_from]
REF_33(uint256) -> REF_32[msg.sender]
REF_33(-> allowance) = REF_33 - _value""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
Transfer(_from,0,_value)

IRs:
Emit Transfer(_from,0,_value)""];
19->20;
20[label=""Node Type: RETURN 20

EXPRESSION:
true

IRs:
RETURN True""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
21->1;
22[label=""Node Type: RETURN 22

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"onlyOwner();frozenAccount[msg.sender];;;frozenAccount[_from];;;_value == 0;false;;balanceOf[_from] < _value;false;;_value > allowance[_from][msg.sender];;;balanceOf[_from] -= _value;totalSupply -= _value;allowance[_from][msg.sender] -= _value;Transfer(_from,0,_value);true;success"
./0xdfb9e87ff81cb089484ef8150a21be80f6cdd401_ext.sol,CRYPTOPOKER._transfer,41,57,"TMP_6(bool) = _to != 0,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_1(uint256) -> balanceOf[_from],TMP_8(bool) = REF_1 >= _value,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_2(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_11(bool) = TMP_10 >= REF_3,TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_13(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_13(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_15(uint256) = REF_8 + REF_9,TMP_16(bool) = TMP_15 == previousBalances,TMP_17(None) = SOLIDITY_CALL assert(bool)(TMP_16)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_6(bool) = _to != 0
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_8(bool) = REF_1 >= _value
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_11(bool) = TMP_10 >= REF_3
TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_13(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_13(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_15(uint256) = REF_8 + REF_9
TMP_16(bool) = TMP_15 == previousBalances
TMP_17(None) = SOLIDITY_CALL assert(bool)(TMP_16)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x27369e8f43f44c26853a46da7e6cb52d203b59ce_ext.sol,AgileICOWithAssistance.fallback,338,361,"TMP_114(bool) = msg.value > minimumInvestment,TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114),i(uint256) := 0(uint256),REF_92 -> LENGTH roundPrices,TMP_116(bool) = i < REF_92,CONDITION TMP_116,REF_93(AgileICOWithAssistance.FundingRound) -> roundPrices[i],REF_94(uint256) -> REF_93.startTime,TMP_117(bool) = now > REF_94,REF_95(AgileICOWithAssistance.FundingRound) -> roundPrices[i],REF_96(uint256) -> REF_95.endTime,TMP_118(bool) = now < REF_96,TMP_119(bool) = TMP_117 && TMP_118,CONDITION TMP_119,REF_97(AgileICOWithAssistance.FundingRound) -> roundPrices[i],REF_98(uint256) -> REF_97.rate,rate(uint256) := REF_98(uint256),REF_99(AgileICOWithAssistance.FundingRound) -> roundPrices[i],REF_100(bool) -> REF_99.hasWhitelist,TMP_120(bool) = REF_100 == True,CONDITION TMP_120,REF_101(mapping(address => bool)) -> whitelist[i],REF_102(bool) -> REF_101[msg.sender],TMP_121(bool) = REF_102 == True,TMP_122(None) = SOLIDITY_CALL require(bool)(TMP_121),TMP_123(uint256) := i(uint256),i(uint256) = i + 1,REF_103(mapping(uint256 => AgileICOWithAssistance.Offer)) -> offers[msg.sender],REF_104(AgileICOWithAssistance.Offer) -> REF_103[0],REF_105(uint256) -> REF_104.numberOfDeals,dealNumber(uint256) := REF_105(uint256),REF_106(mapping(uint256 => AgileICOWithAssistance.Offer)) -> offers[msg.sender],REF_107(AgileICOWithAssistance.Offer) -> REF_106[dealNumber],REF_108(uint256) -> REF_107.etherAmount,REF_108(uint256) (->offers) := msg.value(uint256),REF_109(mapping(uint256 => AgileICOWithAssistance.Offer)) -> offers[msg.sender],REF_110(AgileICOWithAssistance.Offer) -> REF_109[dealNumber],REF_111(uint256) -> REF_110.tokenAmount,TMP_124(uint256) = msg.value * rate,REF_111(uint256) (->offers) := TMP_124(uint256),REF_112(mapping(uint256 => AgileICOWithAssistance.Offer)) -> offers[msg.sender],REF_113(AgileICOWithAssistance.Offer) -> REF_112[0],REF_114(uint256) -> REF_113.numberOfDeals,REF_114(-> offers) = REF_114 + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value > minimumInvestment)

IRs:
TMP_114(bool) = msg.value > minimumInvestment
TMP_115(None) = SOLIDITY_CALL require(bool)(TMP_114)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
3->13;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < roundPrices.length

IRs:
REF_92 -> LENGTH roundPrices
TMP_116(bool) = i < REF_92
CONDITION TMP_116""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: IF 6

EXPRESSION:
now > roundPrices[i].startTime && now < roundPrices[i].endTime

IRs:
REF_93(AgileICOWithAssistance.FundingRound) -> roundPrices[i]
REF_94(uint256) -> REF_93.startTime
TMP_117(bool) = now > REF_94
REF_95(AgileICOWithAssistance.FundingRound) -> roundPrices[i]
REF_96(uint256) -> REF_95.endTime
TMP_118(bool) = now < REF_96
TMP_119(bool) = TMP_117 && TMP_118
CONDITION TMP_119""];
6->7[label=""True""];
6->11[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
rate = roundPrices[i].rate

IRs:
REF_97(AgileICOWithAssistance.FundingRound) -> roundPrices[i]
REF_98(uint256) -> REF_97.rate
rate(uint256) := REF_98(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
roundPrices[i].hasWhitelist == true

IRs:
REF_99(AgileICOWithAssistance.FundingRound) -> roundPrices[i]
REF_100(bool) -> REF_99.hasWhitelist
TMP_120(bool) = REF_100 == True
CONDITION TMP_120""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(whitelist[i][msg.sender] == true)

IRs:
REF_101(mapping(address => bool)) -> whitelist[i]
REF_102(bool) -> REF_101[msg.sender]
TMP_121(bool) = REF_102 == True
TMP_122(None) = SOLIDITY_CALL require(bool)(TMP_121)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_123(uint256) := i(uint256)
i(uint256) = i + 1""];
12->5;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
dealNumber = offers[msg.sender][0].numberOfDeals

IRs:
REF_103(mapping(uint256 => AgileICOWithAssistance.Offer)) -> offers[msg.sender]
REF_104(AgileICOWithAssistance.Offer) -> REF_103[0]
REF_105(uint256) -> REF_104.numberOfDeals
dealNumber(uint256) := REF_105(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
offers[msg.sender][dealNumber].etherAmount = msg.value

IRs:
REF_106(mapping(uint256 => AgileICOWithAssistance.Offer)) -> offers[msg.sender]
REF_107(AgileICOWithAssistance.Offer) -> REF_106[dealNumber]
REF_108(uint256) -> REF_107.etherAmount
REF_108(uint256) (->offers) := msg.value(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
offers[msg.sender][dealNumber].tokenAmount = msg.value * rate

IRs:
REF_109(mapping(uint256 => AgileICOWithAssistance.Offer)) -> offers[msg.sender]
REF_110(AgileICOWithAssistance.Offer) -> REF_109[dealNumber]
REF_111(uint256) -> REF_110.tokenAmount
TMP_124(uint256) = msg.value * rate
REF_111(uint256) (->offers) := TMP_124(uint256)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
offers[msg.sender][0].numberOfDeals += 1

IRs:
REF_112(mapping(uint256 => AgileICOWithAssistance.Offer)) -> offers[msg.sender]
REF_113(AgileICOWithAssistance.Offer) -> REF_112[0]
REF_114(uint256) -> REF_113.numberOfDeals
REF_114(-> offers) = REF_114 + 1""];
}
",0,1,0,0,require(bool)(msg.value > minimumInvestment);i = 0;;i < roundPrices.length;;dealNumber = offers[msg.sender][0].numberOfDeals;now > roundPrices[i].startTime && now < roundPrices[i].endTime;rate = roundPrices[i].rate;;roundPrices[i].hasWhitelist == true;require(bool)(whitelist[i][msg.sender] == true);;i ++;offers[msg.sender][dealNumber].etherAmount = msg.value;offers[msg.sender][dealNumber].tokenAmount = msg.value * rate;offers[msg.sender][0].numberOfDeals += 1
./0x6b775965ff81583429ee39f4f6a5fb6889ab61eb_ext.sol,ZTKDIGITALTOKEN.approveAndCall,197,202,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x471407f224b99bb3347de2609bc117dad367f889_ext.sol,BasicToken.transfer,28,36,"TMP_0 = CONVERT 0 to address,TMP_1(bool) = _to != TMP_0,TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1),REF_0(uint256) -> balances[msg.sender],TMP_3(bool) = _value <= REF_0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balances[msg.sender],REF_2(uint256) -> balances[msg.sender],TMP_5(uint256) = REF_2 - _value,REF_1(uint256) (->balances) := TMP_5(uint256),REF_3(uint256) -> balances[_to],REF_4(uint256) -> balances[_to],TMP_6(uint256) = REF_4 + _value,REF_3(uint256) (->balances) := TMP_6(uint256),Emit Transfer(msg.sender,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_0 = CONVERT 0 to address
TMP_1(bool) = _to != TMP_0
TMP_2(None) = SOLIDITY_CALL require(bool)(TMP_1)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_3(bool) = _value <= REF_0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender] - _value

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_2(uint256) -> balances[msg.sender]
TMP_5(uint256) = REF_2 - _value
REF_1(uint256) (->balances) := TMP_5(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] = balances[_to] + _value

IRs:
REF_3(uint256) -> balances[_to]
REF_4(uint256) -> balances[_to]
TMP_6(uint256) = REF_4 + _value
REF_3(uint256) (->balances) := TMP_6(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(_to != address(0));require(bool)(_value <= balances[msg.sender]);balances[msg.sender] = balances[msg.sender] - _value;balances[_to] = balances[_to] + _value;Transfer(msg.sender,_to,_value);true"
./0xa19118ddbabbf3d538db6a46578f3260e26b89b9_ext.sol,Vault.withdraw,12,20,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2),TMP_4(bool) = keyHash == TMP_3,CONDITION TMP_4,TMP_5(bool) = msg.value > 500000000000000000,CONDITION TMP_5,TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),Transfer dest:msg.sender value:TMP_7","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
keyHash == keccak256()(abi.encodePacked(key))

IRs:
TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2)
TMP_4(bool) = keyHash == TMP_3
CONDITION TMP_4""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
msg.value > 500000000000000000

IRs:
TMP_5(bool) = msg.value > 500000000000000000
CONDITION TMP_5""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
Transfer dest:msg.sender value:TMP_7""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,1,0,0,require(bool)(msg.sender == tx.origin);keyHash == keccak256()(abi.encodePacked(key));msg.value > 500000000000000000;;msg.sender.transfer(address(this).balance);
./0xaf6dbf545cc245c00b425d02e545b6ecc1527f3d_ext.sol,LSCKcoin.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x048f616fcc4dd825f4a0a3b095d2ef70046b30c3_ext.sol,Bablorub.register,130,146,"REF_42(Storage.User) -> user[msg.sender],REF_43(uint256) -> REF_42.balance,TMP_32(bool) = REF_43 == 0,CONDITION TMP_32,REF_44(Storage.User) -> user[msg.sender],REF_45(uint256) -> REF_44.timestamp,REF_45(uint256) (->user) := now(uint256),TMP_33(uint256) := countInvestors(uint256),countInvestors(uint256) = countInvestors + 1,TMP_34(address) = INTERNAL_CALL, Bablorub.bytesToAddress(bytes)(msg.data),referrer(address) := TMP_34(address),REF_46(Storage.User) -> user[referrer],REF_47(uint256) -> REF_46.balance,TMP_35(bool) = REF_47 > 0,TMP_36(bool) = referrer != msg.sender,TMP_37(bool) = TMP_35 && TMP_36,CONDITION TMP_37,REF_48(Storage.User) -> user[msg.sender],REF_49(address) -> REF_48.referrer,REF_49(address) (->user) := referrer(address),REF_50(Storage.User) -> user[referrer],REF_51(uint256) -> REF_50.countReferrals,TMP_38(uint256) := REF_51(uint256),REF_51(-> user) = REF_51 + 1,TMP_39(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', 'bonusReferral'] ,TMP_40(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_39', '100'] ,INTERNAL_CALL, Bablorub.transfer(address,uint256)(msg.sender,TMP_40),MODIFIER_CALL, Bablorub.withDeposit()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: IF 1

EXPRESSION:
user[msg.sender].balance == 0

IRs:
REF_42(Storage.User) -> user[msg.sender]
REF_43(uint256) -> REF_42.balance
TMP_32(bool) = REF_43 == 0
CONDITION TMP_32""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
user[msg.sender].timestamp = now

IRs:
REF_44(Storage.User) -> user[msg.sender]
REF_45(uint256) -> REF_44.timestamp
REF_45(uint256) (->user) := now(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
countInvestors ++

IRs:
TMP_33(uint256) := countInvestors(uint256)
countInvestors(uint256) = countInvestors + 1""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
referrer = bytesToAddress(msg.data)

IRs:
TMP_34(address) = INTERNAL_CALL, Bablorub.bytesToAddress(bytes)(msg.data)
referrer(address) := TMP_34(address)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
user[referrer].balance > 0 && referrer != msg.sender

IRs:
REF_46(Storage.User) -> user[referrer]
REF_47(uint256) -> REF_46.balance
TMP_35(bool) = REF_47 > 0
TMP_36(bool) = referrer != msg.sender
TMP_37(bool) = TMP_35 && TMP_36
CONDITION TMP_37""];
5->6[label=""True""];
5->9[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
user[msg.sender].referrer = referrer

IRs:
REF_48(Storage.User) -> user[msg.sender]
REF_49(address) -> REF_48.referrer
REF_49(address) (->user) := referrer(address)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
user[referrer].countReferrals ++

IRs:
REF_50(Storage.User) -> user[referrer]
REF_51(uint256) -> REF_50.countReferrals
TMP_38(uint256) := REF_51(uint256)
REF_51(-> user) = REF_51 + 1""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
transfer(msg.sender,msg.value.mul(bonusReferral).div(100))

IRs:
TMP_39(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', 'bonusReferral'] 
TMP_40(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_39', '100'] 
INTERNAL_CALL, Bablorub.transfer(address,uint256)(msg.sender,TMP_40)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: END_IF 10
""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
withDeposit()

IRs:
MODIFIER_CALL, Bablorub.withDeposit()()""];
11->1;
}
",0,1,0,0,"withDeposit();user[msg.sender].balance == 0;user[msg.sender].timestamp = now;;countInvestors ++;referrer = bytesToAddress(msg.data);user[referrer].balance > 0 && referrer != msg.sender;user[msg.sender].referrer = referrer;;user[referrer].countReferrals ++;transfer(msg.sender,msg.value.mul(bonusReferral).div(100))"
./0x5314dd28de3f215647b64ccb3701e6098a80d080_ext.sol,CaData._transfer,211,218,"REF_42(CaData.Atom) -> atoms[_tokenId],REF_43(uint128) -> REF_42.isBuy,REF_43(uint128) (->atoms) := 0(uint256),REF_44(CaData.Atom) -> atoms[_tokenId],REF_45(uint128) -> REF_44.isRent,REF_45(uint128) (->atoms) := 0(uint256),REF_46(uint256) -> ownerAtomsCount[_to],TMP_89(uint256) := REF_46(uint256),REF_46(-> ownerAtomsCount) = REF_46 + 1,REF_47(uint256) -> ownerAtomsCount[_from],TMP_90(uint256) := REF_47(uint256),REF_47(-> ownerAtomsCount) = REF_47 - 1,REF_48(address) -> atomOwner[_tokenId],REF_48(address) (->atomOwner) := _to(address),Emit Transfer(_from,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
atoms[_tokenId].isBuy = 0

IRs:
REF_42(CaData.Atom) -> atoms[_tokenId]
REF_43(uint128) -> REF_42.isBuy
REF_43(uint128) (->atoms) := 0(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
atoms[_tokenId].isRent = 0

IRs:
REF_44(CaData.Atom) -> atoms[_tokenId]
REF_45(uint128) -> REF_44.isRent
REF_45(uint128) (->atoms) := 0(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ownerAtomsCount[_to] ++

IRs:
REF_46(uint256) -> ownerAtomsCount[_to]
TMP_89(uint256) := REF_46(uint256)
REF_46(-> ownerAtomsCount) = REF_46 + 1""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownerAtomsCount[_from] --

IRs:
REF_47(uint256) -> ownerAtomsCount[_from]
TMP_90(uint256) := REF_47(uint256)
REF_47(-> ownerAtomsCount) = REF_47 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
atomOwner[_tokenId] = _to

IRs:
REF_48(address) -> atomOwner[_tokenId]
REF_48(address) (->atomOwner) := _to(address)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
}
",0,1,0,0,"atoms[_tokenId].isBuy = 0;atoms[_tokenId].isRent = 0;ownerAtomsCount[_to] ++;ownerAtomsCount[_from] --;atomOwner[_tokenId] = _to;Transfer(_from,_to,_tokenId)"
./0x01d174f95cd17d0b5b24f1f89a35cfdb37929b30_ext.sol,X_wallet.setup_key,23,28,"TMP_9(bool) = keyHash == 0,CONDITION TMP_9,TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10),keyHash(bytes32) := TMP_11(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
keyHash == 0x0

IRs:
TMP_9(bool) = keyHash == 0
CONDITION TMP_9""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
keyHash = keccak256()(abi.encodePacked(key))

IRs:
TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10)
keyHash(bytes32) := TMP_11(bytes32)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,1,0,0,keyHash == 0x0;keyHash = keccak256()(abi.encodePacked(key));
./0xd3cdc4e75750dc1e59f8342200742b6b29490e70_ext.sol,Decurian.approveAndCall,143,148,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x7220e734c524e8938a1553ae18e3c68aec8bf955_ext.sol,SmsCertifier.getAddress,77,77,"REF_18(SmsCertifier.Certification) -> certs[_who],REF_19(mapping(string => bytes32)) -> REF_18.meta,REF_20(bytes32) -> REF_19[_field],TMP_19 = CONVERT REF_20 to address,RETURN TMP_19","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
address(certs[_who].meta[_field])

IRs:
REF_18(SmsCertifier.Certification) -> certs[_who]
REF_19(mapping(string => bytes32)) -> REF_18.meta
REF_20(bytes32) -> REF_19[_field]
TMP_19 = CONVERT REF_20 to address
RETURN TMP_19""];
}
",0,1,0,0,address(certs[_who].meta[_field])
./0x6fc2a418d752e4b26dc372ccd766696f9c462e30_ext.sol,HTG.burnFrom,140,148,"REF_19(uint256) -> balanceOf[_from],TMP_22(bool) = REF_19 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_24(bool) = _value <= REF_21,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_22(bool) = REF_19 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_24(bool) = _value <= REF_21
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x20d88cfc6d23d06c98d7661aded19043e9ee5aa0_ext.sol,TokenERC20.approveAndCall,78,86,"TMP_24 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_24(tokenRecipient),TMP_25(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value),CONDITION TMP_25,TMP_26 = CONVERT this to address,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'TMP_26', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_24 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_24(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_25(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value)
CONDITION TMP_25""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,address(this),_extraData)

IRs:
TMP_26 = CONVERT this to address
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'TMP_26', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,address(this),_extraData);;true;success"
./0x39e743fee400a5d9b36f1167b70c10e8f06440e5_ext.sol,TNCGroupToken.burn,141,148,"REF_17(uint256) -> balanceOf[msg.sender],TMP_28(bool) = REF_17 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),TMP_31 = CONVERT 0 to address,Emit Transfer(msg.sender,TMP_31,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_28(bool) = REF_17 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,address(0x0),_value)

IRs:
TMP_31 = CONVERT 0 to address
Emit Transfer(msg.sender,TMP_31,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);Transfer(msg.sender,address(0x0),_value);true;success"
./0x32c62c965db5fdac0f94e6276d6884070068d4be_ext.sol,MyAdvancedToken.mint,71,75,"REF_16(uint256) -> balances_[who],REF_16(-> balances_) = REF_16 + val,totalSupply_(uint256) = totalSupply_ + val,Emit Transfer(0,who,val),MODIFIER_CALL, MyAdvancedToken.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances_[who] += val

IRs:
REF_16(uint256) -> balances_[who]
REF_16(-> balances_) = REF_16 + val""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply_ += val

IRs:
totalSupply_(uint256) = totalSupply_ + val""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,who,val)

IRs:
Emit Transfer(0,who,val)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, MyAdvancedToken.whenNotPaused()()""];
4->1;
}
",1,1,0,0,"whenNotPaused();balances_[who] += val;totalSupply_ += val;Transfer(0,who,val)"
./0x27718f6f920781f551082e7b61bd5d046f394400_ext.sol,StandardToken.transferFrom,53,62,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0xdd6eef0507f10d21f716e36d8b1aae76a4fa3f62_ext.sol,CashexGlobalCoin.distributeCXGC,69,78,"i(uint256) := 0(uint256),REF_1 -> LENGTH addresses,TMP_2(bool) = i < REF_1,CONDITION TMP_2,REF_2(address) -> addresses[i],TMP_3(uint256) = INTERNAL_CALL, CashexGlobalCoin.getEthBalance(address)(REF_2),TMP_4(bool) = TMP_3 < _ethbal,CONDITION TMP_4,REF_3(uint256) -> balances[owner],REF_3(-> balances) = REF_3 - _value,REF_4(address) -> addresses[i],REF_5(uint256) -> balances[REF_4],REF_5(-> balances) = REF_5 + _value,REF_6(address) -> addresses[i],Emit Transfer(owner,REF_6,_value),TMP_6(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, CashexGlobalCoin.onlyOwner()(),MODIFIER_CALL, CashexGlobalCoin.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addresses.length

IRs:
REF_1 -> LENGTH addresses
TMP_2(bool) = i < REF_1
CONDITION TMP_2""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
getEthBalance(addresses[i]) < _ethbal

IRs:
REF_2(address) -> addresses[i]
TMP_3(uint256) = INTERNAL_CALL, CashexGlobalCoin.getEthBalance(address)(REF_2)
TMP_4(bool) = TMP_3 < _ethbal
CONDITION TMP_4""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: CONTINUE 6
""];
6->11;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[owner] -= _value

IRs:
REF_3(uint256) -> balances[owner]
REF_3(-> balances) = REF_3 - _value""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
balances[addresses[i]] += _value

IRs:
REF_4(address) -> addresses[i]
REF_5(uint256) -> balances[REF_4]
REF_5(-> balances) = REF_5 + _value""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Transfer(owner,addresses[i],_value)

IRs:
REF_6(address) -> addresses[i]
Emit Transfer(owner,REF_6,_value)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_6(uint256) := i(uint256)
i(uint256) = i + 1""];
11->4;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, CashexGlobalCoin.onlyOwner()()""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, CashexGlobalCoin.canDistr()()""];
13->3;
}
",0,1,0,0,"onlyOwner();;i < addresses.length;;i = 0;getEthBalance(addresses[i]) < _ethbal;;;i ++;balances[owner] -= _value;balances[addresses[i]] += _value;Transfer(owner,addresses[i],_value);canDistr()"
./0x20900587e569e3d0b2609bca6fb3469765ed0920_ext.sol,Bitpoint.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xa48d3b79f43477224933e492e42f5cacf4091ecc_ext.sol,AdvancedCOINSToken.mintToken,213,218,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,TMP_84 = CONVERT 0 to address,TMP_85 = CONVERT this to address,Emit Transfer(TMP_84,TMP_85,mintedAmount),TMP_87 = CONVERT this to address,Emit Transfer(TMP_87,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(address(0),address(this),mintedAmount)

IRs:
TMP_84 = CONVERT 0 to address
TMP_85 = CONVERT this to address
Emit Transfer(TMP_84,TMP_85,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(address(this),target,mintedAmount)

IRs:
TMP_87 = CONVERT this to address
Emit Transfer(TMP_87,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(address(0),address(this),mintedAmount);Transfer(address(this),target,mintedAmount)"
./0xf0cfbff3ed2d09ff731148bc96726e77ce18d649_ext.sol,AIMT.transfer,96,106,"REF_1(uint256) -> balances[msg.sender],TMP_21(bool) = REF_1 >= _value,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),TMP_23(bool) = msg.sender == _to,REF_2(uint256) -> balances[_to],TMP_24(uint256) = MAX_UINT256 - _value,TMP_25(bool) = REF_2 <= TMP_24,TMP_26(bool) = TMP_23 || TMP_25,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_3(uint256) -> balances[msg.sender],REF_3(-> balances) = REF_3 - _value,REF_4(uint256) -> balances[_to],REF_4(-> balances) = REF_4 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_21(bool) = REF_1 >= _value
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == _to || balances[_to] <= MAX_UINT256 - _value)

IRs:
TMP_23(bool) = msg.sender == _to
REF_2(uint256) -> balances[_to]
TMP_24(uint256) = MAX_UINT256 - _value
TMP_25(bool) = REF_2 <= TMP_24
TMP_26(bool) = TMP_23 || TMP_25
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_3(uint256) -> balances[msg.sender]
REF_3(-> balances) = REF_3 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] += _value

IRs:
REF_4(uint256) -> balances[_to]
REF_4(-> balances) = REF_4 + _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);require(bool)(msg.sender == _to || balances[_to] <= MAX_UINT256 - _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true"
./0x1d9be4a5681374c54b1821d0beac3a678ad128a4_ext.sol,StringMover.stringToBytes32,65,71,RETURN out,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: INLINE ASM 2
""];
2->3;
3[label=""Node Type: END INLINE ASM 3
""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
out

IRs:
RETURN out""];
}
",0,1,0,0,;;;out
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.adminUpdateStartEndTime,2,2,"TMP_73(bool) = _startTimes > 0,TMP_74(None) = SOLIDITY_CALL require(bool)(TMP_73),TMP_75(bool) = _endTimes > 0,TMP_76(None) = SOLIDITY_CALL require(bool)(TMP_75),startTimes(uint256) := _startTimes(uint256),endTimes(uint256) := _endTimes(uint256),Emit eUpdateStartEndTime(startTimes,endTimes,msg.sender),MODIFIER_CALL, KahnDistributionCentre.onlyAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_startTimes > 0)

IRs:
TMP_73(bool) = _startTimes > 0
TMP_74(None) = SOLIDITY_CALL require(bool)(TMP_73)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_endTimes > 0)

IRs:
TMP_75(bool) = _endTimes > 0
TMP_76(None) = SOLIDITY_CALL require(bool)(TMP_75)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
startTimes = _startTimes

IRs:
startTimes(uint256) := _startTimes(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
endTimes = _endTimes

IRs:
endTimes(uint256) := _endTimes(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
eUpdateStartEndTime(startTimes,endTimes,msg.sender)

IRs:
Emit eUpdateStartEndTime(startTimes,endTimes,msg.sender)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyAdmin()()""];
6->1;
}
",0,1,1,0,"onlyAdmin();require(bool)(_startTimes > 0);require(bool)(_endTimes > 0);startTimes = _startTimes;endTimes = _endTimes;eUpdateStartEndTime(startTimes,endTimes,msg.sender)"
./0x73c9275c3a2dd84b5741fd59aebf102c91eb033f_ext.sol,BTRS.totalSupply,103,105,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0xe1dbbce4570b815b6ce3434bb3097dc9f453c565_ext.sol,MobiusRED.estimateReturns,245,261,"REF_2(MobiusRED.MobiusRound) -> rounds[roundID],rnd(MobiusRED.MobiusRound) := REF_2(MobiusRED.MobiusRound),REF_3 -> LENGTH rounds,TMP_105(bool) = REF_3 > 1,CONDITION TMP_105,TMP_106(uint256) = roundID - 1,TMP_107(bool) = INTERNAL_CALL, MobiusRED.hasReturns(address,uint256)(investor,TMP_106),CONDITION TMP_107,TMP_108(uint256) = roundID - 1,REF_4(MobiusRED.MobiusRound) -> rounds[TMP_108],prevRnd(MobiusRED.MobiusRound) := REF_4(MobiusRED.MobiusRound),TMP_109(uint256) = INTERNAL_CALL, MobiusRED._outstandingReturns(address,MobiusRED.MobiusRound)(investor,prevRnd),outstanding(uint256) := TMP_109(uint256),TMP_110(uint256) = INTERNAL_CALL, MobiusRED._outstandingReturns(address,MobiusRED.MobiusRound)(investor,rnd),outstanding(uint256) = outstanding + TMP_110,REF_5(MobiusRED.Vault) -> vaults[investor],REF_6(uint256) -> REF_5.totalReturns,TMP_111(uint256) = REF_6 + outstanding,totalReturns(uint256) := TMP_111(uint256),REF_7(MobiusRED.Vault) -> vaults[investor],REF_8(uint256) -> REF_7.refReturns,refReturns(uint256) := REF_8(uint256),RETURN totalReturns,refReturns","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
rnd = rounds[roundID]

IRs:
REF_2(MobiusRED.MobiusRound) -> rounds[roundID]
rnd(MobiusRED.MobiusRound) := REF_2(MobiusRED.MobiusRound)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
rounds.length > 1

IRs:
REF_3 -> LENGTH rounds
TMP_105(bool) = REF_3 > 1
CONDITION TMP_105""];
3->4[label=""True""];
3->8[label=""False""];
4[label=""Node Type: IF 4

EXPRESSION:
hasReturns(investor,roundID - 1)

IRs:
TMP_106(uint256) = roundID - 1
TMP_107(bool) = INTERNAL_CALL, MobiusRED.hasReturns(address,uint256)(investor,TMP_106)
CONDITION TMP_107""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
prevRnd = rounds[roundID - 1]

IRs:
TMP_108(uint256) = roundID - 1
REF_4(MobiusRED.MobiusRound) -> rounds[TMP_108]
prevRnd(MobiusRED.MobiusRound) := REF_4(MobiusRED.MobiusRound)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
outstanding = _outstandingReturns(investor,prevRnd)

IRs:
TMP_109(uint256) = INTERNAL_CALL, MobiusRED._outstandingReturns(address,MobiusRED.MobiusRound)(investor,prevRnd)
outstanding(uint256) := TMP_109(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
outstanding += _outstandingReturns(investor,rnd)

IRs:
TMP_110(uint256) = INTERNAL_CALL, MobiusRED._outstandingReturns(address,MobiusRED.MobiusRound)(investor,rnd)
outstanding(uint256) = outstanding + TMP_110""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
totalReturns = vaults[investor].totalReturns + outstanding

IRs:
REF_5(MobiusRED.Vault) -> vaults[investor]
REF_6(uint256) -> REF_5.totalReturns
TMP_111(uint256) = REF_6 + outstanding
totalReturns(uint256) := TMP_111(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
refReturns = vaults[investor].refReturns

IRs:
REF_7(MobiusRED.Vault) -> vaults[investor]
REF_8(uint256) -> REF_7.refReturns
refReturns(uint256) := REF_8(uint256)""];
11->12;
12[label=""Node Type: RETURN 12

EXPRESSION:
(totalReturns,refReturns)

IRs:
RETURN totalReturns,refReturns""];
}
",0,1,0,0,"rnd = rounds[roundID];;rounds.length > 1;hasReturns(investor,roundID - 1);;prevRnd = rounds[roundID - 1];;outstanding = _outstandingReturns(investor,prevRnd);outstanding += _outstandingReturns(investor,rnd);totalReturns = vaults[investor].totalReturns + outstanding;refReturns = vaults[investor].refReturns;(totalReturns,refReturns)"
./0x9283df9554419641f2cab66af4876f9de8526e4c_ext.sol,KikkeliToken.approveAndCall,291,302,"REF_142(mapping(address => uint256)) -> allowed[msg.sender],REF_143(uint256) -> REF_142[_spender],REF_143(uint256) (->allowed) := _value(uint256),Emit Approval(msg.sender,_spender,_value),TMP_144(bytes32) = SOLIDITY_CALL keccak256()(receiveApproval(address,uint256,address,bytes)),TMP_145 = CONVERT TMP_144 to bytes32,TMP_146 = CONVERT TMP_145 to bytes4,TMP_147(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_146', 'msg.sender', '_value', 'this', '_extraData']  ,TMP_148(None) = SOLIDITY_CALL require(bool)(TMP_147),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_142(mapping(address => uint256)) -> allowed[msg.sender]
REF_143(uint256) -> REF_142[_spender]
REF_143(uint256) (->allowed) := _value(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_spender.call(bytes4(bytes32(keccak256()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData))

IRs:
TMP_144(bytes32) = SOLIDITY_CALL keccak256()(receiveApproval(address,uint256,address,bytes))
TMP_145 = CONVERT TMP_144 to bytes32
TMP_146 = CONVERT TMP_145 to bytes4
TMP_147(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_146', 'msg.sender', '_value', 'this', '_extraData']  
TMP_148(None) = SOLIDITY_CALL require(bool)(TMP_147)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][_spender] = _value;Approval(msg.sender,_spender,_value);require(bool)(_spender.call(bytes4(bytes32(keccak256()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData));true;success"
./0x2fe3538f247b0152583f9eedf87aa922aebba6d2_ext.sol,DistributedInvestmentOperationPlatformToken.transferFrom,300,302,"TMP_142(bool) = INTERNAL_CALL, StandardToken.transferFrom(address,address,uint256)(_from,_to,_value),TMP_143(None) = SOLIDITY_CALL require(bool)(TMP_142),TMP_144(bool) = INTERNAL_CALL, Standard223Token.isContract(address)(_to),CONDITION TMP_144,TMP_145(bool) = INTERNAL_CALL, Standard223Token.contractFallback(address,address,uint256,bytes)(_from,_to,_value,_data),RETURN TMP_145,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(super.transferFrom(_from,_to,_value))

IRs:
TMP_142(bool) = INTERNAL_CALL, StandardToken.transferFrom(address,address,uint256)(_from,_to,_value)
TMP_143(None) = SOLIDITY_CALL require(bool)(TMP_142)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
isContract(_to)

IRs:
TMP_144(bool) = INTERNAL_CALL, Standard223Token.isContract(address)(_to)
CONDITION TMP_144""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3

EXPRESSION:
contractFallback(_from,_to,_value,_data)

IRs:
TMP_145(bool) = INTERNAL_CALL, Standard223Token.contractFallback(address,address,uint256,bytes)(_from,_to,_value,_data)
RETURN TMP_145""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(super.transferFrom(_from,_to,_value));isContract(_to);contractFallback(_from,_to,_value,_data);;true;success"
./0x570581a21edb40d399b6d2f407a86506c4b7d663_ext.sol,EVO2.dividendsOf,402,408,"REF_32(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_64(uint256) = profitPerShare_ * REF_32,TMP_65 = CONVERT TMP_64 to int256,REF_33(int256) -> payoutsTo_[_customerAddress],TMP_66(int256) = TMP_65 - REF_33,TMP_67 = CONVERT TMP_66 to uint256,TMP_68(uint256) = TMP_67 / magnitude,RETURN TMP_68","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_32(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_64(uint256) = profitPerShare_ * REF_32
TMP_65 = CONVERT TMP_64 to int256
REF_33(int256) -> payoutsTo_[_customerAddress]
TMP_66(int256) = TMP_65 - REF_33
TMP_67 = CONVERT TMP_66 to uint256
TMP_68(uint256) = TMP_67 / magnitude
RETURN TMP_68""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x18b70ebdbca93c0299c87b594676dfed54a1b88d_ext.sol,Timecoin.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x1a0a9a3b8064bf8c3e8cae6e6e595695067c7df2_ext.sol,Poge._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xd64e5b228561225b437dc38b81891c15fe98cfee_ext.sol,NYXAccount.withdrawByResque,124,142,"REF_7(NYXAccount.Stages) -> Stages.ResqueRequested,TMP_15(bool) = stage != REF_7,CONDITION TMP_15,resqueRequestTime(uint256) := now(uint256),REF_8(NYXAccount.Stages) -> Stages.ResqueRequested,stage(NYXAccount.Stages) := REF_8(NYXAccount.Stages),TMP_16(uint256) = resqueRequestTime + 60,TMP_17(bool) = now <= TMP_16,CONDITION TMP_17,REF_9(NYXAccount.Stages) -> Stages.ResqueRequested,TMP_18(bool) = stage == REF_9,TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18),REF_11(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_11,MODIFIER_CALL, NYXAccount.onlyByResque()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: IF 1

EXPRESSION:
stage != Stages.ResqueRequested

IRs:
REF_7(NYXAccount.Stages) -> Stages.ResqueRequested
TMP_15(bool) = stage != REF_7
CONDITION TMP_15""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
resqueRequestTime = now

IRs:
resqueRequestTime(uint256) := now(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
stage = Stages.ResqueRequested

IRs:
REF_8(NYXAccount.Stages) -> Stages.ResqueRequested
stage(NYXAccount.Stages) := REF_8(NYXAccount.Stages)""];
3->4;
4[label=""Node Type: RETURN 4
""];
5[label=""Node Type: IF 5

EXPRESSION:
now <= resqueRequestTime + 60

IRs:
TMP_16(uint256) = resqueRequestTime + 60
TMP_17(bool) = now <= TMP_16
CONDITION TMP_17""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: RETURN 6
""];
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(stage == Stages.ResqueRequested)

IRs:
REF_9(NYXAccount.Stages) -> Stages.ResqueRequested
TMP_18(bool) = stage == REF_9
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_11(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_11""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
onlyByResque()

IRs:
MODIFIER_CALL, NYXAccount.onlyByResque()()""];
11->1;
}
",0,1,1,0,onlyByResque();stage != Stages.ResqueRequested;resqueRequestTime = now;now <= resqueRequestTime + 60;stage = Stages.ResqueRequested;;;;;require(bool)(stage == Stages.ResqueRequested);msg.sender.transfer(this.balance)
./0x53ef8e6cb3a7c96d7aecf39b2d4d09c166269c34_ext.sol,AUX1418.totalSupply,127,129,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x8a96115b0fdc06ab845cf7d5196c80d8ebec4130_ext.sol,StandardToken.transferFrom,56,66,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x1db45a09efcdd8955b1c3bb855b5a8d333446bff_ext.sol,Share.transferHolds,136,152,"REF_9(uint256) -> holds[from],TMP_19(bool) = REF_9 >= amount,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),TMP_21(bool) = amount > 0,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),REF_10(uint256) -> fullfilled[from],TMP_23(uint256) = watermark - REF_10,TMP_24(uint256) = TMP_23 * amount,fromBonus(uint256) := TMP_24(uint256),REF_11(uint256) -> fullfilled[to],TMP_25(uint256) = watermark - REF_11,REF_12(uint256) -> holds[to],TMP_26(uint256) = TMP_25 * REF_12,toBonus(uint256) := TMP_26(uint256),REF_13(uint256) -> holds[from],REF_13(-> holds) = REF_13 - amount,REF_14(uint256) -> holds[to],REF_14(-> holds) = REF_14 + amount,REF_15(uint256) -> fullfilled[to],REF_16(uint256) -> holds[to],TMP_27(uint256) = toBonus / REF_16,TMP_28(uint256) = watermark - TMP_27,REF_15(uint256) (->fullfilled) := TMP_28(uint256),Transfer dest:from value:fromBonus,Emit SHARE_TRANSFER(from,to,amount),Emit WITHDRAWAL(from,fromBonus)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(holds[from] >= amount)

IRs:
REF_9(uint256) -> holds[from]
TMP_19(bool) = REF_9 >= amount
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_21(bool) = amount > 0
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
fromBonus = (watermark - fullfilled[from]) * amount

IRs:
REF_10(uint256) -> fullfilled[from]
TMP_23(uint256) = watermark - REF_10
TMP_24(uint256) = TMP_23 * amount
fromBonus(uint256) := TMP_24(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
toBonus = (watermark - fullfilled[to]) * holds[to]

IRs:
REF_11(uint256) -> fullfilled[to]
TMP_25(uint256) = watermark - REF_11
REF_12(uint256) -> holds[to]
TMP_26(uint256) = TMP_25 * REF_12
toBonus(uint256) := TMP_26(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
holds[from] -= amount

IRs:
REF_13(uint256) -> holds[from]
REF_13(-> holds) = REF_13 - amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
holds[to] += amount

IRs:
REF_14(uint256) -> holds[to]
REF_14(-> holds) = REF_14 + amount""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
fullfilled[to] = watermark - toBonus / holds[to]

IRs:
REF_15(uint256) -> fullfilled[to]
REF_16(uint256) -> holds[to]
TMP_27(uint256) = toBonus / REF_16
TMP_28(uint256) = watermark - TMP_27
REF_15(uint256) (->fullfilled) := TMP_28(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
from.transfer(fromBonus)

IRs:
Transfer dest:from value:fromBonus""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
SHARE_TRANSFER(from,to,amount)

IRs:
Emit SHARE_TRANSFER(from,to,amount)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
WITHDRAWAL(from,fromBonus)

IRs:
Emit WITHDRAWAL(from,fromBonus)""];
}
",0,1,0,0,"require(bool)(holds[from] >= amount);require(bool)(amount > 0);fromBonus = (watermark - fullfilled[from]) * amount;toBonus = (watermark - fullfilled[to]) * holds[to];holds[from] -= amount;holds[to] += amount;fullfilled[to] = watermark - toBonus / holds[to];from.transfer(fromBonus);SHARE_TRANSFER(from,to,amount);WITHDRAWAL(from,fromBonus)"
./0x564a47b92be4d4070f3488112c6dd4ed757ad4c7_ext.sol,StandardToken.transfer,32,41,"REF_0(uint256) -> balances[msg.sender],TMP_0(bool) = REF_0 >= _value,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_1(uint256) -> balances[msg.sender],REF_1(-> balances) = REF_1 - _value,REF_2(uint256) -> balances[_to],REF_2(-> balances) = REF_2 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_0(bool) = REF_0 >= _value
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_1(-> balances) = REF_1 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_2(uint256) -> balances[_to]
REF_2(-> balances) = REF_2 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0xc6689eb9a6d724b8d7b1d923ffd65b7005da1b62_ext.sol,SECToken.mintToken,232,237,"REF_58(uint256) -> balanceOf[target],REF_58(-> balanceOf) = REF_58 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_58(uint256) -> balanceOf[target]
REF_58(-> balanceOf) = REF_58 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x27e06500263d6b27a3f8b7be636aabc7adc186be_ext.sol,EasyInvestForeverNeverending.fallback,36,64,"investedTotal(uint256) = investedTotal + msg.value,TMP_0(bool) = block.number >= nextBlock,CONDITION TMP_0,TMP_1 = CONVERT this to address,TMP_2(uint256) = SOLIDITY_CALL balance(address)(TMP_1),currentBalance(uint256) := TMP_2(uint256),TMP_3(bool) = currentBalance < previousBalance,CONDITION TMP_3,currentBalance(uint256) := previousBalance(uint256),calculatedLow(uint256) := 0(uint256),TMP_4(uint256) = currentBalance - previousBalance,TMP_5(uint256) = TMP_4 / 100000000000000000,TMP_6(uint256) = TMP_5 + 100,interestRate(uint256) := TMP_6(uint256),previousBalance(uint256) := currentBalance(uint256),TMP_7(bool) = calculatedLow == 0,CONDITION TMP_7,TMP_8(uint256) = investedTotal * interestRate,TMP_9(uint256) = TMP_8 / 10000,TMP_10(uint256) = currentBalance - TMP_9,calculatedLow(uint256) := TMP_10(uint256),currentGrowth(uint256) := 0(uint256),TMP_11 = CONVERT this to address,TMP_12(uint256) = SOLIDITY_CALL balance(address)(TMP_11),currentBalance(uint256) := TMP_12(uint256),TMP_13(bool) = currentBalance > calculatedLow,CONDITION TMP_13,TMP_14(uint256) = currentBalance - calculatedLow,currentGrowth(uint256) := TMP_14(uint256),TMP_15(bool) = interestRate == 100,CONDITION TMP_15,TMP_16(uint256) = 100 * currentGrowth,TMP_17(uint256) = previousBalance - calculatedLow,TMP_18(uint256) = TMP_17 + 1,TMP_19(uint256) = TMP_16 / TMP_18,interestRate(uint256) := TMP_19(uint256),TMP_20(uint256) = block.number - nextBlock,TMP_21(uint256) = TMP_20 / 5900,TMP_22(uint256) = TMP_21 + 1,TMP_23(uint256) = 5900 * TMP_22,nextBlock(uint256) = nextBlock + TMP_23,REF_0(uint256) -> invested[msg.sender],TMP_24(bool) = REF_0 != 0,CONDITION TMP_24,REF_1(uint256) -> invested[msg.sender],TMP_25(uint256) = REF_1 * interestRate,TMP_26(uint256) = TMP_25 / 10000,REF_2(uint256) -> atBlock[msg.sender],TMP_27(uint256) = block.number - REF_2,TMP_28(uint256) = TMP_26 * TMP_27,TMP_29(uint256) = TMP_28 / 5900,amount(uint256) := TMP_29(uint256),Transfer dest:msg.sender value:amount,REF_4(uint256) -> atBlock[msg.sender],REF_4(uint256) (->atBlock) := block.number(uint256),REF_5(uint256) -> invested[msg.sender],REF_5(-> invested) = REF_5 + msg.value,TMP_31(bool) = interestRate > 1000,CONDITION TMP_31,interestRate(uint256) := 1000(uint256),interestRate(uint256) := interestRate(uint256),TMP_32(bool) = interestRate < 5,CONDITION TMP_32,interestRate(uint256) := 5(uint256),interestRate(uint256) := interestRate(uint256),REF_6(uint256) -> invested[msg.sender],TMP_33(uint256) = REF_6 / 10,TMP_34(bool) = amount > TMP_33,CONDITION TMP_34,REF_7(uint256) -> invested[msg.sender],TMP_35(uint256) = REF_7 / 10,amount(uint256) := TMP_35(uint256),amount(uint256) := amount(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
investedTotal += msg.value

IRs:
investedTotal(uint256) = investedTotal + msg.value""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
block.number >= nextBlock

IRs:
TMP_0(bool) = block.number >= nextBlock
CONDITION TMP_0""];
2->3[label=""True""];
2->24[label=""False""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
currentBalance = address(this).balance

IRs:
TMP_1 = CONVERT this to address
TMP_2(uint256) = SOLIDITY_CALL balance(address)(TMP_1)
currentBalance(uint256) := TMP_2(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
currentBalance < previousBalance

IRs:
TMP_3(bool) = currentBalance < previousBalance
CONDITION TMP_3""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
currentBalance = previousBalance

IRs:
currentBalance(uint256) := previousBalance(uint256)""];
5->7;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
calculatedLow = 0

IRs:
calculatedLow(uint256) := 0(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
interestRate = (currentBalance - previousBalance) / 10e16 + 100

IRs:
TMP_4(uint256) = currentBalance - previousBalance
TMP_5(uint256) = TMP_4 / 100000000000000000
TMP_6(uint256) = TMP_5 + 100
interestRate(uint256) := TMP_6(uint256)""];
8->32;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
previousBalance = currentBalance

IRs:
previousBalance(uint256) := currentBalance(uint256)""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
calculatedLow == 0

IRs:
TMP_7(bool) = calculatedLow == 0
CONDITION TMP_7""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
calculatedLow = currentBalance - (investedTotal * interestRate / 10000)

IRs:
TMP_8(uint256) = investedTotal * interestRate
TMP_9(uint256) = TMP_8 / 10000
TMP_10(uint256) = currentBalance - TMP_9
calculatedLow(uint256) := TMP_10(uint256)""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: NEW VARIABLE 14

EXPRESSION:
currentGrowth = 0

IRs:
currentGrowth(uint256) := 0(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
currentBalance = address(this).balance

IRs:
TMP_11 = CONVERT this to address
TMP_12(uint256) = SOLIDITY_CALL balance(address)(TMP_11)
currentBalance(uint256) := TMP_12(uint256)""];
15->16;
16[label=""Node Type: IF 16

EXPRESSION:
currentBalance > calculatedLow

IRs:
TMP_13(bool) = currentBalance > calculatedLow
CONDITION TMP_13""];
16->17[label=""True""];
16->18[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
currentGrowth = currentBalance - calculatedLow

IRs:
TMP_14(uint256) = currentBalance - calculatedLow
currentGrowth(uint256) := TMP_14(uint256)""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: IF 19

EXPRESSION:
interestRate == 100

IRs:
TMP_15(bool) = interestRate == 100
CONDITION TMP_15""];
19->20[label=""True""];
19->21[label=""False""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
interestRate = 100 * currentGrowth / (previousBalance - calculatedLow + 1)

IRs:
TMP_16(uint256) = 100 * currentGrowth
TMP_17(uint256) = previousBalance - calculatedLow
TMP_18(uint256) = TMP_17 + 1
TMP_19(uint256) = TMP_16 / TMP_18
interestRate(uint256) := TMP_19(uint256)""];
20->21;
21[label=""Node Type: END_IF 21
""];
21->36;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
nextBlock += 5900 * ((block.number - nextBlock) / 5900 + 1)

IRs:
TMP_20(uint256) = block.number - nextBlock
TMP_21(uint256) = TMP_20 / 5900
TMP_22(uint256) = TMP_21 + 1
TMP_23(uint256) = 5900 * TMP_22
nextBlock(uint256) = nextBlock + TMP_23""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: IF 25

EXPRESSION:
invested[msg.sender] != 0

IRs:
REF_0(uint256) -> invested[msg.sender]
TMP_24(bool) = REF_0 != 0
CONDITION TMP_24""];
25->26[label=""True""];
25->29[label=""False""];
26[label=""Node Type: NEW VARIABLE 26

EXPRESSION:
amount = invested[msg.sender] * interestRate / 10000 * (block.number - atBlock[msg.sender]) / 5900

IRs:
REF_1(uint256) -> invested[msg.sender]
TMP_25(uint256) = REF_1 * interestRate
TMP_26(uint256) = TMP_25 / 10000
REF_2(uint256) -> atBlock[msg.sender]
TMP_27(uint256) = block.number - REF_2
TMP_28(uint256) = TMP_26 * TMP_27
TMP_29(uint256) = TMP_28 / 5900
amount(uint256) := TMP_29(uint256)""];
26->40;
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
28->29;
29[label=""Node Type: END_IF 29
""];
29->30;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
atBlock[msg.sender] = block.number

IRs:
REF_4(uint256) -> atBlock[msg.sender]
REF_4(uint256) (->atBlock) := block.number(uint256)""];
30->31;
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
invested[msg.sender] += msg.value

IRs:
REF_5(uint256) -> invested[msg.sender]
REF_5(-> invested) = REF_5 + msg.value""];
32[label=""Node Type: IF 32

EXPRESSION:
(interestRate > 1000)

IRs:
TMP_31(bool) = interestRate > 1000
CONDITION TMP_31""];
32->33[label=""True""];
32->34[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
interestRate = 1000

IRs:
interestRate(uint256) := 1000(uint256)""];
33->35;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
interestRate = interestRate

IRs:
interestRate(uint256) := interestRate(uint256)""];
34->35;
35[label=""Node Type: END_IF 35
""];
35->10;
36[label=""Node Type: IF 36

EXPRESSION:
(interestRate < 5)

IRs:
TMP_32(bool) = interestRate < 5
CONDITION TMP_32""];
36->37[label=""True""];
36->38[label=""False""];
37[label=""Node Type: EXPRESSION 37

EXPRESSION:
interestRate = 5

IRs:
interestRate(uint256) := 5(uint256)""];
37->39;
38[label=""Node Type: EXPRESSION 38

EXPRESSION:
interestRate = interestRate

IRs:
interestRate(uint256) := interestRate(uint256)""];
38->39;
39[label=""Node Type: END_IF 39
""];
39->23;
40[label=""Node Type: IF 40

EXPRESSION:
(amount > invested[msg.sender] / 10)

IRs:
REF_6(uint256) -> invested[msg.sender]
TMP_33(uint256) = REF_6 / 10
TMP_34(bool) = amount > TMP_33
CONDITION TMP_34""];
40->41[label=""True""];
40->42[label=""False""];
41[label=""Node Type: EXPRESSION 41

EXPRESSION:
amount = invested[msg.sender] / 10

IRs:
REF_7(uint256) -> invested[msg.sender]
TMP_35(uint256) = REF_7 / 10
amount(uint256) := TMP_35(uint256)""];
41->43;
42[label=""Node Type: EXPRESSION 42

EXPRESSION:
amount = amount

IRs:
amount(uint256) := amount(uint256)""];
42->43;
43[label=""Node Type: END_IF 43
""];
43->28;
}
",0,1,0,0,investedTotal += msg.value;block.number >= nextBlock;currentBalance = address(this).balance;;currentBalance < previousBalance;currentBalance = previousBalance;calculatedLow = 0;;interestRate = (currentBalance - previousBalance) / 10e16 + 100;(interestRate > 1000);previousBalance = currentBalance;calculatedLow == 0;calculatedLow = currentBalance - (investedTotal * interestRate / 10000);;currentGrowth = 0;currentBalance = address(this).balance;currentBalance > calculatedLow;currentGrowth = currentBalance - calculatedLow;;interestRate == 100;interestRate = 100 * currentGrowth / (previousBalance - calculatedLow + 1);;(interestRate < 5);nextBlock += 5900 * ((block.number - nextBlock) / 5900 + 1);invested[msg.sender] != 0;amount = invested[msg.sender] * interestRate / 10000 * (block.number - atBlock[msg.sender]) / 5900;;(amount > invested[msg.sender] / 10);msg.sender.transfer(amount);atBlock[msg.sender] = block.number;invested[msg.sender] += msg.value;interestRate = 1000;interestRate = interestRate;;interestRate = 5;interestRate = interestRate;;amount = invested[msg.sender] / 10;amount = amount;
./0xa575aea29bcf52afa55113b3b1b9e3813143d10d_ext.sol,TokenLingERC20._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x17aeb3c181365bc4a386d8dc6ecbe2a96a379088_ext.sol,CipherPlayToken.burn,79,84,"REF_19(uint256) -> balanceOf[msg.sender],TMP_29(bool) = REF_19 >= _value,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),REF_20(uint256) -> balanceOf[msg.sender],REF_20(-> balanceOf) = REF_20 - _value,REF_21(uint256) -> balanceOf[0],REF_21(-> balanceOf) = REF_21 + _value,Emit Transfer(msg.sender,0,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_19(uint256) -> balanceOf[msg.sender]
TMP_29(bool) = REF_19 >= _value
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_20(uint256) -> balanceOf[msg.sender]
REF_20(-> balanceOf) = REF_20 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[0x0] += _value

IRs:
REF_21(uint256) -> balanceOf[0]
REF_21(-> balanceOf) = REF_21 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,0x0,_value)

IRs:
Emit Transfer(msg.sender,0,_value)""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;balanceOf[0x0] += _value;Transfer(msg.sender,0x0,_value)"
./0x581a653c16ed7ae3f3fa86b549aba090abd42e8b_ext.sol,BYB.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x129e719c424a7a6fbdeb7ca3d65186892d54ea8c_ext.sol,QUIZ_GAME.NewQuestion,42,49,"TMP_12(bool) = msg.sender == questionSender,TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12),responseHash(bytes32) := _responseHash(bytes32),Question(string) := _question(string)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_12(bool) = msg.sender == questionSender
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
responseHash = _responseHash

IRs:
responseHash(bytes32) := _responseHash(bytes32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Question = _question

IRs:
Question(string) := _question(string)""];
}
",0,1,0,0,require(bool)(msg.sender == questionSender);responseHash = _responseHash;Question = _question
./0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb_ext.sol,OrganizeFunds.getTotalPctx10,130,135,"_totalPctx10(uint256) := 0(uint256),i(uint256) := 0(uint256),TMP_15(bool) = i < activityCount,CONDITION TMP_15,REF_21(OrganizeFunds.ActivityAccount) -> activityAccounts[i],REF_22(uint256) -> REF_21.pctx10,_totalPctx10(uint256) = _totalPctx10 + REF_22,TMP_16(uint256) := i(uint256),i(uint256) = i + 1,RETURN _totalPctx10","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_totalPctx10 = 0

IRs:
_totalPctx10(uint256) := 0(uint256)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
3->8;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < activityCount

IRs:
TMP_15(bool) = i < activityCount
CONDITION TMP_15""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
_totalPctx10 += activityAccounts[i].pctx10

IRs:
REF_21(OrganizeFunds.ActivityAccount) -> activityAccounts[i]
REF_22(uint256) -> REF_21.pctx10
_totalPctx10(uint256) = _totalPctx10 + REF_22""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_16(uint256) := i(uint256)
i(uint256) = i + 1""];
7->5;
8[label=""Node Type: RETURN 8

EXPRESSION:
_totalPctx10

IRs:
RETURN _totalPctx10""];
}
",0,1,0,0,_totalPctx10 = 0;i = 0;;i < activityCount;;_totalPctx10;_totalPctx10 += activityAccounts[i].pctx10;i ++
./0x1ebda9b505ad2c6ccee86bfc18f58035dcfdc26a_ext.sol,StandardToken.transferFrom,56,66,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x5592a2704ba651f8af4cb6f330415f9877483ad2_ext.sol,NamiTrade._transfer,1339,1355,"TMP_464(bool) = _to != 0,TMP_465(None) = SOLIDITY_CALL require(bool)(TMP_464),REF_261(uint256) -> balanceOf[_from],TMP_466(bool) = REF_261 >= _value,TMP_467(None) = SOLIDITY_CALL require(bool)(TMP_466),REF_262(uint256) -> balanceOf[_to],TMP_468(uint256) = REF_262 + _value,REF_263(uint256) -> balanceOf[_to],TMP_469(bool) = TMP_468 >= REF_263,TMP_470(None) = SOLIDITY_CALL require(bool)(TMP_469),REF_264(uint256) -> balanceOf[_from],REF_265(uint256) -> balanceOf[_to],TMP_471(uint256) = REF_264 + REF_265,previousBalances(uint256) := TMP_471(uint256),REF_266(uint256) -> balanceOf[_from],REF_266(-> balanceOf) = REF_266 - _value,REF_267(uint256) -> balanceOf[_to],REF_267(-> balanceOf) = REF_267 + _value,Emit Transfer(_from,_to,_value),REF_268(uint256) -> balanceOf[_from],REF_269(uint256) -> balanceOf[_to],TMP_473(uint256) = REF_268 + REF_269,TMP_474(bool) = TMP_473 == previousBalances,TMP_475(None) = SOLIDITY_CALL assert(bool)(TMP_474)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_464(bool) = _to != 0
TMP_465(None) = SOLIDITY_CALL require(bool)(TMP_464)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_261(uint256) -> balanceOf[_from]
TMP_466(bool) = REF_261 >= _value
TMP_467(None) = SOLIDITY_CALL require(bool)(TMP_466)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_262(uint256) -> balanceOf[_to]
TMP_468(uint256) = REF_262 + _value
REF_263(uint256) -> balanceOf[_to]
TMP_469(bool) = TMP_468 >= REF_263
TMP_470(None) = SOLIDITY_CALL require(bool)(TMP_469)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_264(uint256) -> balanceOf[_from]
REF_265(uint256) -> balanceOf[_to]
TMP_471(uint256) = REF_264 + REF_265
previousBalances(uint256) := TMP_471(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_266(uint256) -> balanceOf[_from]
REF_266(-> balanceOf) = REF_266 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_267(uint256) -> balanceOf[_to]
REF_267(-> balanceOf) = REF_267 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_268(uint256) -> balanceOf[_from]
REF_269(uint256) -> balanceOf[_to]
TMP_473(uint256) = REF_268 + REF_269
TMP_474(bool) = TMP_473 == previousBalances
TMP_475(None) = SOLIDITY_CALL assert(bool)(TMP_474)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x70e6718a025dfaa44159f1c9a9cc20f575f3cdf0_ext.sol,Payreum.fallback,94,102,"TMP_70(uint256) = ethInWei + msg.value,ethInWei(uint256) := TMP_70(uint256),TMP_71(uint256) = msg.value * PYRToEth,amount(uint256) := TMP_71(uint256),REF_93(uint256) -> balances[devWallet],TMP_72(bool) = REF_93 < amount,CONDITION TMP_72,REF_94(uint256) -> balances[devWallet],REF_95(uint256) -> balances[devWallet],TMP_73(uint256) = REF_95 - amount,REF_94(uint256) (->balances) := TMP_73(uint256),REF_96(uint256) -> balances[msg.sender],REF_97(uint256) -> balances[msg.sender],TMP_74(uint256) = REF_97 + amount,REF_96(uint256) (->balances) := TMP_74(uint256),Emit Transfer(devWallet,msg.sender,amount),TMP_76 = SEND dest:devWallet value:msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ethInWei = ethInWei + msg.value

IRs:
TMP_70(uint256) = ethInWei + msg.value
ethInWei(uint256) := TMP_70(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = msg.value * PYRToEth

IRs:
TMP_71(uint256) = msg.value * PYRToEth
amount(uint256) := TMP_71(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
balances[devWallet] < amount

IRs:
REF_93(uint256) -> balances[devWallet]
TMP_72(bool) = REF_93 < amount
CONDITION TMP_72""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: RETURN 4
""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[devWallet] = balances[devWallet] - amount

IRs:
REF_94(uint256) -> balances[devWallet]
REF_95(uint256) -> balances[devWallet]
TMP_73(uint256) = REF_95 - amount
REF_94(uint256) (->balances) := TMP_73(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[msg.sender] = balances[msg.sender] + amount

IRs:
REF_96(uint256) -> balances[msg.sender]
REF_97(uint256) -> balances[msg.sender]
TMP_74(uint256) = REF_97 + amount
REF_96(uint256) (->balances) := TMP_74(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(devWallet,msg.sender,amount)

IRs:
Emit Transfer(devWallet,msg.sender,amount)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
devWallet.send(msg.value)

IRs:
TMP_76 = SEND dest:devWallet value:msg.value""];
}
",0,1,0,0,"ethInWei = ethInWei + msg.value;amount = msg.value * PYRToEth;balances[devWallet] < amount;;;balances[devWallet] = balances[devWallet] - amount;balances[msg.sender] = balances[msg.sender] + amount;Transfer(devWallet,msg.sender,amount);devWallet.send(msg.value)"
./0x6cabf1b590ee8daa30a1c76ff5dd21284d8681d8_ext.sol,HCHToken.burn,131,137,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xc59cb23295e2deeb66bd090acb6b02be8d30a11f_ext.sol,Utils.safeAdd,38,42,"TMP_0(uint256) = _x + _y,z(uint256) := TMP_0(uint256),TMP_1(bool) = z >= _x,TMP_2(None) = SOLIDITY_CALL assert(bool)(TMP_1),RETURN z","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
z = _x + _y

IRs:
TMP_0(uint256) = _x + _y
z(uint256) := TMP_0(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(z >= _x)

IRs:
TMP_1(bool) = z >= _x
TMP_2(None) = SOLIDITY_CALL assert(bool)(TMP_1)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
z

IRs:
RETURN z""];
}
",0,1,0,0,z = _x + _y;assert(bool)(z >= _x);z
./0x6d358ad6eca1461f092659797e8dceb2d5150fa6_ext.sol,EthereumPrivate.burn,137,143,"REF_18(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_18 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_19(uint256) -> balanceOf[msg.sender],REF_19(-> balanceOf) = REF_19 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_18 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_19(uint256) -> balanceOf[msg.sender]
REF_19(-> balanceOf) = REF_19 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x34770f06ae8a9a7b44fd8d636af6a3fec2a58b98_ext.sol,StdToken._burn,90,97,"TMP_23(bool) = _value > 0,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),REF_14(uint256) -> balances[_burner],TMP_25(bool) = REF_14 > 0,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_15(uint256) -> balances[_burner],REF_15(-> balances) = REF_15 - _value,supply(uint256) = supply - _value,Emit Burn(_burner,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_23(bool) = _value > 0
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_burner] > 0)

IRs:
REF_14(uint256) -> balances[_burner]
TMP_25(bool) = REF_14 > 0
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_burner] -= _value

IRs:
REF_15(uint256) -> balances[_burner]
REF_15(-> balances) = REF_15 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
supply -= _value

IRs:
supply(uint256) = supply - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Burn(_burner,_value)

IRs:
Emit Burn(_burner,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(_value > 0);require(bool)(balances[_burner] > 0);balances[_burner] -= _value;supply -= _value;Burn(_burner,_value);true"
./0x033d46d15ad9b5653cbe61be97371023acb11f94_ext.sol,OChain.approveAndCall,49,56,"TMP_10 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_10(tokenRecipient),TMP_11(bool) = INTERNAL_CALL, OChain.approve(address,uint256)(_spender,_value),CONDITION TMP_11,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_10 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_10(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_11(bool) = INTERNAL_CALL, OChain.approve(address,uint256)(_spender,_value)
CONDITION TMP_11""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x17e65b46ad1ebfb8f9cacde8e274b377831a1253_ext.sol,BigbomToken.freezeAccount,321,341,"TMP_82 = UnaryType.BANG freeze ,CONDITION TMP_82,REF_67(uint256) -> frozenTime[target],frozenEndTime(uint256) := REF_67(uint256),TMP_83(bool) = now >= frozenEndTime,TMP_84(None) = SOLIDITY_CALL require(bool)(TMP_83),REF_68(bool) -> frozenAccount[target],REF_68(bool) (->frozenAccount) := freeze(bool),_seconds(uint256) := 0(uint256),REF_69(bool) -> frozenAccount[target],REF_69(bool) (->frozenAccount) := freeze(bool),REF_70(uint256) -> frozenTime[target],TMP_85(uint256) = now + _seconds,REF_70(uint256) (->frozenTime) := TMP_85(uint256),Emit FrozenFunds(target,freeze,_seconds),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: IF 1

EXPRESSION:
! freeze

IRs:
TMP_82 = UnaryType.BANG freeze 
CONDITION TMP_82""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
frozenEndTime = frozenTime[target]

IRs:
REF_67(uint256) -> frozenTime[target]
frozenEndTime(uint256) := REF_67(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(now >= frozenEndTime)

IRs:
TMP_83(bool) = now >= frozenEndTime
TMP_84(None) = SOLIDITY_CALL require(bool)(TMP_83)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
frozenAccount[target] = freeze

IRs:
REF_68(bool) -> frozenAccount[target]
REF_68(bool) (->frozenAccount) := freeze(bool)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_seconds = 0

IRs:
_seconds(uint256) := 0(uint256)""];
5->7;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
frozenAccount[target] = freeze

IRs:
REF_69(bool) -> frozenAccount[target]
REF_69(bool) (->frozenAccount) := freeze(bool)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
frozenTime[target] = now + _seconds

IRs:
REF_70(uint256) -> frozenTime[target]
TMP_85(uint256) = now + _seconds
REF_70(uint256) (->frozenTime) := TMP_85(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
FrozenFunds(target,freeze,_seconds)

IRs:
Emit FrozenFunds(target,freeze,_seconds)""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
10->1;
}
",0,1,0,0,"onlyOwner();! freeze;frozenEndTime = frozenTime[target];frozenAccount[target] = freeze;require(bool)(now >= frozenEndTime);frozenAccount[target] = freeze;_seconds = 0;;frozenTime[target] = now + _seconds;FrozenFunds(target,freeze,_seconds)"
./0x5573cb8589a2ed0ca4029202739bfc251932201f_ext.sol,STRATCO._transfer,45,61,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x036a98e540599dae4a9778335ffabe6ca01ca705_ext.sol,cwallet.withdraw,13,21,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2),TMP_4(bool) = keyHash == TMP_3,CONDITION TMP_4,TMP_5(bool) = msg.value > 400000000000000000,CONDITION TMP_5,TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),Transfer dest:msg.sender value:TMP_7","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
keyHash == keccak256()(abi.encodePacked(key))

IRs:
TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2)
TMP_4(bool) = keyHash == TMP_3
CONDITION TMP_4""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
msg.value > 400000000000000000

IRs:
TMP_5(bool) = msg.value > 400000000000000000
CONDITION TMP_5""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
Transfer dest:msg.sender value:TMP_7""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,1,0,0,require(bool)(msg.sender == tx.origin);keyHash == keccak256()(abi.encodePacked(key));msg.value > 400000000000000000;;msg.sender.transfer(address(this).balance);
./0xc729c50c19d3b2f0049c9eec809b5cc175dbf489_ext.sol,PDGToken._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x4c7c98c4d64c29ef8103b005eeccf5145cfdf8c1_ext.sol,Savings.deposit,30,35,"TMP_4(bool) = msg.value >= 1000000000000000000,CONDITION TMP_4,REF_0(uint256) -> deposits[msg.sender],REF_0(-> deposits) = REF_0 + msg.value,Emit Deposit(msg.sender,msg.value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value >= 1000000000000000000

IRs:
TMP_4(bool) = msg.value >= 1000000000000000000
CONDITION TMP_4""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
deposits[msg.sender] += msg.value

IRs:
REF_0(uint256) -> deposits[msg.sender]
REF_0(-> deposits) = REF_0 + msg.value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Deposit(msg.sender,msg.value)

IRs:
Emit Deposit(msg.sender,msg.value)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,"msg.value >= 1000000000000000000;deposits[msg.sender] += msg.value;;Deposit(msg.sender,msg.value)"
./0x35e44051799bd7cea091c4fad2cba9b37e364c5b_ext.sol,myPreICO.fallback,47,52,"TMP_14(bool) = msg.value > 0,TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14),REF_5 -> LENGTH holders,TMP_17(uint256) := REF_5(uint256),TMP_18(uint256) = TMP_17 + 1,REF_5(uint256) (->holders) := TMP_18(uint256),REF_6(address) -> holders[TMP_17],REF_6(address) (->holders) := msg.sender(address),REF_7(uint256) -> holder_balance[msg.sender],REF_7(-> holder_balance) = REF_7 + msg.value,ETHRaised(uint256) = ETHRaised + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value > 0)

IRs:
TMP_14(bool) = msg.value > 0
TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
holders.push(msg.sender)

IRs:
REF_5 -> LENGTH holders
TMP_17(uint256) := REF_5(uint256)
TMP_18(uint256) = TMP_17 + 1
REF_5(uint256) (->holders) := TMP_18(uint256)
REF_6(address) -> holders[TMP_17]
REF_6(address) (->holders) := msg.sender(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
holder_balance[msg.sender] += msg.value

IRs:
REF_7(uint256) -> holder_balance[msg.sender]
REF_7(-> holder_balance) = REF_7 + msg.value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ETHRaised += msg.value

IRs:
ETHRaised(uint256) = ETHRaised + msg.value""];
}
",0,1,0,0,require(bool)(msg.value > 0);holders.push(msg.sender);holder_balance[msg.sender] += msg.value;ETHRaised += msg.value
./0xeae08961bf8bfe92879b1455c96893e313c8d858_ext.sol,WarToken.getFashionsAttrs,627,649,"REF_142 -> LENGTH _tokens,length(uint256) := REF_142(uint256),TMP_223(bool) = length <= 64,TMP_224(None) = SOLIDITY_CALL require(bool)(TMP_223),TMP_226(uint256) = length * 11,TMP_227(uint16[])  = new uint16[](TMP_226),attrs(uint16[]) = ['TMP_227(uint16[])'],i(uint256) := 0(uint256),TMP_228(bool) = i < length,CONDITION TMP_228,REF_143(uint256) -> _tokens[i],tokenId(uint256) := REF_143(uint256),REF_144(address) -> fashionIdToOwner[tokenId],TMP_229 = CONVERT 0 to address,TMP_230(bool) = REF_144 != TMP_229,CONDITION TMP_230,TMP_231(uint256) = i * 11,index(uint256) := TMP_231(uint256),REF_145(WarToken.Fashion) -> fashionArray[tokenId],fs(WarToken.Fashion) := REF_145(WarToken.Fashion),REF_146(uint16) -> attrs[index],REF_147(uint16) -> fs.health,REF_146(uint16) (->attrs) := REF_147(uint16),TMP_232(uint256) = index + 1,REF_148(uint16) -> attrs[TMP_232],REF_149(uint16) -> fs.atkMin,REF_148(uint16) (->attrs) := REF_149(uint16),TMP_233(uint256) = index + 2,REF_150(uint16) -> attrs[TMP_233],REF_151(uint16) -> fs.atkMax,REF_150(uint16) (->attrs) := REF_151(uint16),TMP_234(uint256) = index + 3,REF_152(uint16) -> attrs[TMP_234],REF_153(uint16) -> fs.defence,REF_152(uint16) (->attrs) := REF_153(uint16),TMP_235(uint256) = index + 4,REF_154(uint16) -> attrs[TMP_235],REF_155(uint16) -> fs.crit,REF_154(uint16) (->attrs) := REF_155(uint16),TMP_236(uint256) = index + 5,REF_156(uint16) -> attrs[TMP_236],REF_157(uint16) -> fs.isPercent,REF_156(uint16) (->attrs) := REF_157(uint16),TMP_237(uint256) = index + 6,REF_158(uint16) -> attrs[TMP_237],REF_159(uint16) -> fs.attrExt1,REF_158(uint16) (->attrs) := REF_159(uint16),TMP_238(uint256) = index + 7,REF_160(uint16) -> attrs[TMP_238],REF_161(uint16) -> fs.attrExt2,REF_160(uint16) (->attrs) := REF_161(uint16),TMP_239(uint256) = index + 8,REF_162(uint16) -> attrs[TMP_239],REF_163(uint16) -> fs.attrExt3,REF_162(uint16) (->attrs) := REF_163(uint16),i(uint256) = i + 1,RETURN attrs","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
length = _tokens.length

IRs:
REF_142 -> LENGTH _tokens
length(uint256) := REF_142(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(length <= 64)

IRs:
TMP_223(bool) = length <= 64
TMP_224(None) = SOLIDITY_CALL require(bool)(TMP_223)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
attrs = new uint16[](length * 11)

IRs:
TMP_226(uint256) = length * 11
TMP_227(uint16[])  = new uint16[](TMP_226)
attrs(uint16[]) = ['TMP_227(uint16[])']""];
3->4;
4[label=""Node Type: NEW VARIABLE 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5
""];
5->8;
6[label=""Node Type: BEGIN_LOOP 6
""];
6->9;
7[label=""Node Type: END_LOOP 7
""];
7->25;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
8->6;
9[label=""Node Type: IF_LOOP 9

EXPRESSION:
i < length

IRs:
TMP_228(bool) = i < length
CONDITION TMP_228""];
9->10[label=""True""];
9->7[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
tokenId = _tokens[i]

IRs:
REF_143(uint256) -> _tokens[i]
tokenId(uint256) := REF_143(uint256)""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
fashionIdToOwner[tokenId] != address(0)

IRs:
REF_144(address) -> fashionIdToOwner[tokenId]
TMP_229 = CONVERT 0 to address
TMP_230(bool) = REF_144 != TMP_229
CONDITION TMP_230""];
11->12[label=""True""];
11->23[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
index = i * 11

IRs:
TMP_231(uint256) = i * 11
index(uint256) := TMP_231(uint256)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
fs = fashionArray[tokenId]

IRs:
REF_145(WarToken.Fashion) -> fashionArray[tokenId]
fs(WarToken.Fashion) := REF_145(WarToken.Fashion)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
attrs[index] = fs.health

IRs:
REF_146(uint16) -> attrs[index]
REF_147(uint16) -> fs.health
REF_146(uint16) (->attrs) := REF_147(uint16)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
attrs[index + 1] = fs.atkMin

IRs:
TMP_232(uint256) = index + 1
REF_148(uint16) -> attrs[TMP_232]
REF_149(uint16) -> fs.atkMin
REF_148(uint16) (->attrs) := REF_149(uint16)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
attrs[index + 2] = fs.atkMax

IRs:
TMP_233(uint256) = index + 2
REF_150(uint16) -> attrs[TMP_233]
REF_151(uint16) -> fs.atkMax
REF_150(uint16) (->attrs) := REF_151(uint16)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
attrs[index + 3] = fs.defence

IRs:
TMP_234(uint256) = index + 3
REF_152(uint16) -> attrs[TMP_234]
REF_153(uint16) -> fs.defence
REF_152(uint16) (->attrs) := REF_153(uint16)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
attrs[index + 4] = fs.crit

IRs:
TMP_235(uint256) = index + 4
REF_154(uint16) -> attrs[TMP_235]
REF_155(uint16) -> fs.crit
REF_154(uint16) (->attrs) := REF_155(uint16)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
attrs[index + 5] = fs.isPercent

IRs:
TMP_236(uint256) = index + 5
REF_156(uint16) -> attrs[TMP_236]
REF_157(uint16) -> fs.isPercent
REF_156(uint16) (->attrs) := REF_157(uint16)""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
attrs[index + 6] = fs.attrExt1

IRs:
TMP_237(uint256) = index + 6
REF_158(uint16) -> attrs[TMP_237]
REF_159(uint16) -> fs.attrExt1
REF_158(uint16) (->attrs) := REF_159(uint16)""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
attrs[index + 7] = fs.attrExt2

IRs:
TMP_238(uint256) = index + 7
REF_160(uint16) -> attrs[TMP_238]
REF_161(uint16) -> fs.attrExt2
REF_160(uint16) (->attrs) := REF_161(uint16)""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
attrs[index + 8] = fs.attrExt3

IRs:
TMP_239(uint256) = index + 8
REF_162(uint16) -> attrs[TMP_239]
REF_163(uint16) -> fs.attrExt3
REF_162(uint16) (->attrs) := REF_163(uint16)""];
22->23;
23[label=""Node Type: END_IF 23
""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
++ i

IRs:
i(uint256) = i + 1""];
24->9;
25[label=""Node Type: RETURN 25

EXPRESSION:
attrs

IRs:
RETURN attrs""];
}
",0,1,0,0,length = _tokens.length;require(bool)(length <= 64);attrs = new uint16[](length * 11);;;i = 0;;i < length;;attrs;tokenId = _tokens[i];fashionIdToOwner[tokenId] != address(0);index = i * 11;;fs = fashionArray[tokenId];attrs[index] = fs.health;attrs[index + 1] = fs.atkMin;attrs[index + 2] = fs.atkMax;attrs[index + 3] = fs.defence;attrs[index + 4] = fs.crit;attrs[index + 5] = fs.isPercent;attrs[index + 6] = fs.attrExt1;attrs[index + 7] = fs.attrExt2;attrs[index + 8] = fs.attrExt3;++ i
./0x56c388df7f4e0947014705f7d61bdc6ebb128ad0_ext.sol,StandardToken.transferFrom,62,72,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0xd6f79a8ba756cc7babdc04c6715d65af297ce50d_ext.sol,SimpleEscrow.fallback,58,64,"TMP_13 = CONVERT 0 to address,TMP_14(bool) = customerWallet == TMP_13,TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14),customerWallet(address) := msg.sender(address),started(uint256) := now(uint256),TMP_16(uint256) = started + PERIOD,orderLastDate(uint256) := TMP_16(uint256),TMP_17(uint256) = orderLastDate + SAFE_PERIOD,safeLastDate(uint256) := TMP_17(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(customerWallet == address(0x0))

IRs:
TMP_13 = CONVERT 0 to address
TMP_14(bool) = customerWallet == TMP_13
TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
customerWallet = msg.sender

IRs:
customerWallet(address) := msg.sender(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
started = now

IRs:
started(uint256) := now(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
orderLastDate = started + PERIOD

IRs:
TMP_16(uint256) = started + PERIOD
orderLastDate(uint256) := TMP_16(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
safeLastDate = orderLastDate + SAFE_PERIOD

IRs:
TMP_17(uint256) = orderLastDate + SAFE_PERIOD
safeLastDate(uint256) := TMP_17(uint256)""];
}
",0,1,0,0,require(bool)(customerWallet == address(0x0));customerWallet = msg.sender;started = now;orderLastDate = started + PERIOD;safeLastDate = orderLastDate + SAFE_PERIOD
./0x53088104b7a9a04e52d8b884571634c815bce666_ext.sol,ALONY_HETZ_20230515.transferFrom,42,54,"REF_6(uint256) -> balanceOf[from],TMP_6(bool) = value <= REF_6,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_7(mapping(address => uint256)) -> allowance[from],REF_8(uint256) -> REF_7[msg.sender],TMP_8(bool) = value <= REF_8,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_9(uint256) -> balanceOf[from],REF_9(-> balanceOf) = REF_9 - value,REF_10(uint256) -> balanceOf[to],REF_10(-> balanceOf) = REF_10 + value,REF_11(mapping(address => uint256)) -> allowance[from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowance) = REF_12 - value,Emit Transfer(from,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(value <= balanceOf[from])

IRs:
REF_6(uint256) -> balanceOf[from]
TMP_6(bool) = value <= REF_6
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value <= allowance[from][msg.sender])

IRs:
REF_7(mapping(address => uint256)) -> allowance[from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_8(bool) = value <= REF_8
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[from] -= value

IRs:
REF_9(uint256) -> balanceOf[from]
REF_9(-> balanceOf) = REF_9 - value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[to] += value

IRs:
REF_10(uint256) -> balanceOf[to]
REF_10(-> balanceOf) = REF_10 + value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allowance[from][msg.sender] -= value

IRs:
REF_11(mapping(address => uint256)) -> allowance[from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowance) = REF_12 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(value <= balanceOf[from]);require(bool)(value <= allowance[from][msg.sender]);balanceOf[from] -= value;balanceOf[to] += value;allowance[from][msg.sender] -= value;Transfer(from,to,value);true;success"
./0xa52d89b535b68e955a516a49c5fa3f6f501ead6e_ext.sol,BasicToken.transfer,73,82,"TMP_9 = CONVERT 0 to address,TMP_10(bool) = _to != TMP_9,TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10),REF_0(uint256) -> balances[msg.sender],TMP_12(bool) = _value <= REF_0,TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12),REF_1(uint256) -> balances[msg.sender],REF_2(uint256) -> balances[msg.sender],TMP_14(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] ,REF_1(uint256) (->balances) := TMP_14(uint256),REF_4(uint256) -> balances[_to],REF_4(-> balances) = REF_4 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_9 = CONVERT 0 to address
TMP_10(bool) = _to != TMP_9
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[msg.sender])

IRs:
REF_0(uint256) -> balances[msg.sender]
TMP_12(bool) = _value <= REF_0
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_2(uint256) -> balances[msg.sender]
TMP_14(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_2', '_value'] 
REF_1(uint256) (->balances) := TMP_14(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] += _value

IRs:
REF_4(uint256) -> balances[_to]
REF_4(-> balances) = REF_4 + _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(_to != address(0));require(bool)(_value <= balances[msg.sender]);balances[msg.sender] = balances[msg.sender].sub(_value);balances[_to] += _value;Transfer(msg.sender,_to,_value);true"
./0x5b25b78751126e3a8feffe784d4e2b456c1071a9_ext.sol,GESCrowdsale.sendTokensToRecipients,105,115,"REF_0 -> LENGTH _recipients,REF_1 -> LENGTH _values,TMP_25(bool) = REF_0 == REF_1,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),i(uint256) := 0(uint256),REF_2 -> LENGTH _recipients,TMP_27(bool) = i < REF_2,CONDITION TMP_27,REF_3(uint256) -> _values[i],TMP_28(bool) = REF_3 > 0,CONDITION TMP_28,TMP_29 = CONVERT token to StandardToken,REF_5(address) -> _recipients[i],REF_6(uint256) -> _values[i],TMP_30(bool) = HIGH_LEVEL_CALL, dest:TMP_29(StandardToken), function:transfer, arguments:['REF_5', 'REF_6']  ,i(uint256) = i + 1,RETURN True,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_recipients.length == _values.length)

IRs:
REF_0 -> LENGTH _recipients
REF_1 -> LENGTH _values
TMP_25(bool) = REF_0 == REF_1
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: BEGIN_LOOP 3
""];
3->4;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _recipients.length

IRs:
REF_2 -> LENGTH _recipients
TMP_27(bool) = i < REF_2
CONDITION TMP_27""];
4->5[label=""True""];
4->9[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
_values[i] > 0

IRs:
REF_3(uint256) -> _values[i]
TMP_28(bool) = REF_3 > 0
CONDITION TMP_28""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
StandardToken(token).transfer(_recipients[i],_values[i])

IRs:
TMP_29 = CONVERT token to StandardToken
REF_5(address) -> _recipients[i]
REF_6(uint256) -> _values[i]
TMP_30(bool) = HIGH_LEVEL_CALL, dest:TMP_29(StandardToken), function:transfer, arguments:['REF_5', 'REF_6']  ""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
i += 1

IRs:
i(uint256) = i + 1""];
8->4;
9[label=""Node Type: END_LOOP 9
""];
9->10;
10[label=""Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
11->1;
}
",0,1,0,0,"onlyOwner();require(bool)(_recipients.length == _values.length);i = 0;;i < _recipients.length;_values[i] > 0;;StandardToken(token).transfer(_recipients[i],_values[i]);;i += 1;true"
./0x6f328f0a7cd638cda9fed876abf71423ca109fe1_ext.sol,TokenERC20.mintToken,189,194,"REF_32(uint256) -> balanceOf[target],REF_32(-> balanceOf) = REF_32 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_32(uint256) -> balanceOf[target]
REF_32(-> balanceOf) = REF_32 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x20900587e569e3d0b2609bca6fb3469765ed0920_ext.sol,Bitpoint.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xdb5e04dc9c94bc8310e8885c85a4d0666ccaecae_ext.sol,EtherBrand._transfer,325,331,"REF_201(EtherBrand.Brand) -> brands[_brand_id],REF_202(address) -> REF_201.owner,REF_202(address) (->brands) := _to(address),REF_203(EtherBrand.Brand) -> brands[_brand_id],REF_204(address) -> REF_203.approve_transfer_to,TMP_211 = CONVERT 0 to address,REF_204(address) (->brands) := TMP_211(address),REF_205(uint256) -> ownerCount[_from],REF_205(-> ownerCount) = REF_205 - 1,REF_206(uint256) -> ownerCount[_to],REF_206(-> ownerCount) = REF_206 + 1,Emit Transfer(_from,_to,_brand_id)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
brands[_brand_id].owner = _to

IRs:
REF_201(EtherBrand.Brand) -> brands[_brand_id]
REF_202(address) -> REF_201.owner
REF_202(address) (->brands) := _to(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
brands[_brand_id].approve_transfer_to = address(0)

IRs:
REF_203(EtherBrand.Brand) -> brands[_brand_id]
REF_204(address) -> REF_203.approve_transfer_to
TMP_211 = CONVERT 0 to address
REF_204(address) (->brands) := TMP_211(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ownerCount[_from] -= 1

IRs:
REF_205(uint256) -> ownerCount[_from]
REF_205(-> ownerCount) = REF_205 - 1""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownerCount[_to] += 1

IRs:
REF_206(uint256) -> ownerCount[_to]
REF_206(-> ownerCount) = REF_206 + 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_brand_id)

IRs:
Emit Transfer(_from,_to,_brand_id)""];
}
",0,1,0,0,"brands[_brand_id].owner = _to;brands[_brand_id].approve_transfer_to = address(0);ownerCount[_from] -= 1;ownerCount[_to] += 1;Transfer(_from,_to,_brand_id)"
./0xeae08961bf8bfe92879b1455c96893e313c8d858_ext.sol,ActionAuction.getAuctionTotal,999,1001,"REF_275 -> LENGTH auctionArray,TMP_471(uint256) = REF_275 - 1,RETURN TMP_471","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
auctionArray.length - 1

IRs:
REF_275 -> LENGTH auctionArray
TMP_471(uint256) = REF_275 - 1
RETURN TMP_471""];
}
",0,1,0,0,auctionArray.length - 1
./0xf4702b0918a8a89dfc38459ce42198834818f26b_ext.sol,multiowned.revoke,68,79,"TMP_8 = CONVERT msg.sender to uint256,REF_8(uint256) -> m_ownerIndex[TMP_8],ownerIndex(uint256) := REF_8(uint256),TMP_9(bool) = ownerIndex == 0,CONDITION TMP_9,TMP_10(uint256) = 2 ** ownerIndex,ownerIndexBit(uint256) := TMP_10(uint256),REF_9(multiowned.PendingState) -> m_pending[_operation],pending(multiowned.PendingState) := REF_9(multiowned.PendingState),REF_10(uint256) -> pending.ownersDone,TMP_11(uint256) = REF_10 & ownerIndexBit,TMP_12(bool) = TMP_11 > 0,CONDITION TMP_12,REF_11(uint256) -> pending.yetNeeded,TMP_13(uint256) := REF_11(uint256),REF_11(-> pending) = REF_11 + 1,REF_12(uint256) -> pending.ownersDone,REF_12(-> pending) = REF_12 - ownerIndexBit,Emit Revoke(msg.sender,_operation)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
ownerIndex = m_ownerIndex[uint256(msg.sender)]

IRs:
TMP_8 = CONVERT msg.sender to uint256
REF_8(uint256) -> m_ownerIndex[TMP_8]
ownerIndex(uint256) := REF_8(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
ownerIndex == 0

IRs:
TMP_9(bool) = ownerIndex == 0
CONDITION TMP_9""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
ownerIndexBit = 2 ** ownerIndex

IRs:
TMP_10(uint256) = 2 ** ownerIndex
ownerIndexBit(uint256) := TMP_10(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
pending = m_pending[_operation]

IRs:
REF_9(multiowned.PendingState) -> m_pending[_operation]
pending(multiowned.PendingState) := REF_9(multiowned.PendingState)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
pending.ownersDone & ownerIndexBit > 0

IRs:
REF_10(uint256) -> pending.ownersDone
TMP_11(uint256) = REF_10 & ownerIndexBit
TMP_12(bool) = TMP_11 > 0
CONDITION TMP_12""];
7->8[label=""True""];
7->11[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
pending.yetNeeded ++

IRs:
REF_11(uint256) -> pending.yetNeeded
TMP_13(uint256) := REF_11(uint256)
REF_11(-> pending) = REF_11 + 1""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
pending.ownersDone -= ownerIndexBit

IRs:
REF_12(uint256) -> pending.ownersDone
REF_12(-> pending) = REF_12 - ownerIndexBit""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Revoke(msg.sender,_operation)

IRs:
Emit Revoke(msg.sender,_operation)""];
10->11;
11[label=""Node Type: END_IF 11
""];
}
",0,1,0,0,"ownerIndex = m_ownerIndex[uint256(msg.sender)];ownerIndex == 0;;;ownerIndexBit = 2 ** ownerIndex;pending = m_pending[_operation];pending.ownersDone & ownerIndexBit > 0;pending.yetNeeded ++;;pending.ownersDone -= ownerIndexBit;Revoke(msg.sender,_operation)"
./0x2b93194d0984201ab0220a3ec6b80d9a0bd49ed7_ext.sol,RewardsGiftToken.burn,49,55,"REF_16(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_16 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_17(uint256) -> balanceOf[msg.sender],REF_17(-> balanceOf) = REF_17 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_16(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_16 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
REF_17(-> balanceOf) = REF_17 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x405d44c9ed3d2d80e375b2360ed0713b71c6b811_ext.sol,Criplos.process2,101,158,"TMP_15(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokens', '6'] ,TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_15', '5'] ,mine(uint256) := TMP_16(uint256),TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalMining_', 'mine'] ,totalMining_(uint256) := TMP_17(uint256),TMP_18(bool) = techBuff_ > 0,CONDITION TMP_18,TMP_19(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokens', 'techBuff_'] ,tokens(uint256) := TMP_19(uint256),techBuff_(uint256) := 0(uint256),REF_28(Criplos.Record) -> info[msg.sender],REF_29(uint256) -> REF_28.level,TMP_20(bool) = REF_29 == 0,CONDITION TMP_20,TMP_21(uint256) := totalMiners_(uint256),totalMiners_(uint256) = totalMiners_ + 1,REF_31 -> LENGTH recordAccts,TMP_24(uint256) := REF_31(uint256),TMP_25(uint256) = TMP_24 + 1,REF_31(uint256) (->recordAccts) := TMP_25(uint256),REF_32(address) -> recordAccts[TMP_24],REF_32(address) (->recordAccts) := msg.sender(address),TMP_23(None) = TMP_22 - 1,REF_33(Criplos.Record) -> info[master],REF_34(uint256) -> REF_33.level,TMP_26(bool) = REF_34 > 0,CONDITION TMP_26,REF_35(Criplos.Record) -> info[msg.sender],REF_36(address) -> REF_35.master,REF_36(address) (->info) := master(address),REF_37(Criplos.Record) -> info[msg.sender],REF_38(address) -> REF_37.master,REF_38(address) (->info) := advance(address),REF_39(Criplos.Record) -> info[memeber],REF_40(uint256) -> REF_39.level,TMP_27(bool) = REF_40 == 1,CONDITION TMP_27,REF_41(Criplos.Record) -> info[memeber],REF_42(uint256) -> REF_41.level,REF_42(uint256) (->info) := 0(uint256),REF_43(Criplos.Record) -> info[memeber],REF_44(uint256) -> REF_43.volume,REF_45(Criplos.Record) -> info[memeber],REF_46(uint256) -> REF_45.volume,TMP_28(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_46', 'mine'] ,REF_44(uint256) (->info) := TMP_28(uint256),REF_48(Criplos.Record) -> info[memeber],REF_49(uint256) -> REF_48.level,REF_50(Criplos.Record) -> info[memeber],REF_51(uint256) -> REF_50.level,TMP_29(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_51', 'mine'] ,REF_49(uint256) (->info) := TMP_29(uint256),TMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokens', '21'] ,TMP_31(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_30', '25'] ,publicTokens(uint256) := TMP_31(uint256),TMP_32(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokens', '9'] ,TMP_33(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_32', '100'] ,advanceTokens(uint256) := TMP_33(uint256),TMP_34(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokens', '7'] ,TMP_35(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_34', '100'] ,masterTokens(uint256) := TMP_35(uint256),i(uint256) := 0(uint256),TMP_36(bool) = i < totalMiners_,CONDITION TMP_36,REF_59(address) -> recordAccts[i],REF_60(Criplos.Record) -> info[REF_59],REF_61(uint256) -> REF_60.level,TMP_37(bool) = REF_61 > 1,CONDITION TMP_37,REF_63(address) -> recordAccts[i],REF_64(Criplos.Record) -> info[REF_63],REF_65(uint256) -> REF_64.level,TMP_38(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['publicTokens', 'REF_65'] ,TMP_39(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_38', 'totalMining_'] ,checkTokens(uint256) := TMP_39(uint256),REF_67(address) -> recordAccts[i],REF_68(Criplos.Record) -> info[REF_67],REF_69(uint256) -> REF_68.volume,TMP_40(bool) = checkTokens < REF_69,CONDITION TMP_40,REF_70(address) -> recordAccts[i],REF_71(Criplos.Record) -> info[REF_70],REF_72(uint256) -> REF_71.volume,REF_73(address) -> recordAccts[i],REF_74(Criplos.Record) -> info[REF_73],REF_75(uint256) -> REF_74.volume,TMP_41(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_75', 'checkTokens'] ,REF_72(uint256) (->info) := TMP_41(uint256),REF_77(address) -> recordAccts[i],REF_78(Criplos.Record) -> info[REF_77],REF_79(uint256) -> REF_78.balance,REF_80(address) -> recordAccts[i],REF_81(Criplos.Record) -> info[REF_80],REF_82(uint256) -> REF_81.balance,TMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_82', 'checkTokens'] ,REF_79(uint256) (->info) := TMP_42(uint256),REF_84(address) -> recordAccts[i],Emit Transfer(owner,REF_84,checkTokens),REF_85(address) -> recordAccts[i],REF_86(Criplos.Record) -> info[REF_85],REF_87(uint256) -> REF_86.balance,REF_88(address) -> recordAccts[i],REF_89(Criplos.Record) -> info[REF_88],REF_90(uint256) -> REF_89.balance,REF_92(address) -> recordAccts[i],REF_93(Criplos.Record) -> info[REF_92],REF_94(uint256) -> REF_93.volume,TMP_44(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_90', 'REF_94'] ,REF_87(uint256) (->info) := TMP_44(uint256),REF_95(address) -> recordAccts[i],REF_96(address) -> recordAccts[i],REF_97(Criplos.Record) -> info[REF_96],REF_98(uint256) -> REF_97.volume,Emit Transfer(owner,REF_95,REF_98),REF_101(address) -> recordAccts[i],REF_102(Criplos.Record) -> info[REF_101],REF_103(uint256) -> REF_102.volume,TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['checkTokens', 'REF_103'] ,TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['techBuff_', 'TMP_46'] ,techBuff_(uint256) := TMP_47(uint256),REF_104(address) -> recordAccts[i],REF_105(Criplos.Record) -> info[REF_104],REF_106(uint256) -> REF_105.volume,REF_106(uint256) (->info) := 0(uint256),REF_107(address) -> recordAccts[i],REF_108(Criplos.Record) -> info[REF_107],REF_109(uint256) -> REF_108.level,REF_109(uint256) (->info) := 1(uint256),TMP_48(uint256) := i(uint256),i(uint256) = i + 1,REF_110(Criplos.Record) -> info[advance],REF_111(uint256) -> REF_110.balance,REF_112(Criplos.Record) -> info[advance],REF_113(uint256) -> REF_112.balance,TMP_49(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_113', 'advanceTokens'] ,REF_111(uint256) (->info) := TMP_49(uint256),Emit Transfer(owner,advance,advanceTokens),REF_115(Criplos.Record) -> info[memeber],REF_116(address) -> REF_115.master,REF_117(Criplos.Record) -> info[REF_116],REF_118(uint256) -> REF_117.balance,REF_119(Criplos.Record) -> info[memeber],REF_120(address) -> REF_119.master,REF_121(Criplos.Record) -> info[REF_120],REF_122(uint256) -> REF_121.balance,TMP_51(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_122', 'masterTokens'] ,REF_118(uint256) (->info) := TMP_51(uint256),REF_124(Criplos.Record) -> info[memeber],REF_125(address) -> REF_124.master,Emit Transfer(owner,REF_125,masterTokens)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
mine = tokens.mul(6).div(5)

IRs:
TMP_15(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokens', '6'] 
TMP_16(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_15', '5'] 
mine(uint256) := TMP_16(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalMining_ = totalMining_.add(mine)

IRs:
TMP_17(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalMining_', 'mine'] 
totalMining_(uint256) := TMP_17(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
techBuff_ > 0

IRs:
TMP_18(bool) = techBuff_ > 0
CONDITION TMP_18""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
tokens = tokens.add(techBuff_)

IRs:
TMP_19(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['tokens', 'techBuff_'] 
tokens(uint256) := TMP_19(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
techBuff_ = 0

IRs:
techBuff_(uint256) := 0(uint256)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
info[msg.sender].level == 0

IRs:
REF_28(Criplos.Record) -> info[msg.sender]
REF_29(uint256) -> REF_28.level
TMP_20(bool) = REF_29 == 0
CONDITION TMP_20""];
7->8[label=""True""];
7->14[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
totalMiners_ ++

IRs:
TMP_21(uint256) := totalMiners_(uint256)
totalMiners_(uint256) = totalMiners_ + 1""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
recordAccts.push(msg.sender) - 1

IRs:
REF_31 -> LENGTH recordAccts
TMP_24(uint256) := REF_31(uint256)
TMP_25(uint256) = TMP_24 + 1
REF_31(uint256) (->recordAccts) := TMP_25(uint256)
REF_32(address) -> recordAccts[TMP_24]
REF_32(address) (->recordAccts) := msg.sender(address)
TMP_23(None) = TMP_22 - 1""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
info[master].level > 0

IRs:
REF_33(Criplos.Record) -> info[master]
REF_34(uint256) -> REF_33.level
TMP_26(bool) = REF_34 > 0
CONDITION TMP_26""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
info[msg.sender].master = master

IRs:
REF_35(Criplos.Record) -> info[msg.sender]
REF_36(address) -> REF_35.master
REF_36(address) (->info) := master(address)""];
11->13;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
info[msg.sender].master = advance

IRs:
REF_37(Criplos.Record) -> info[msg.sender]
REF_38(address) -> REF_37.master
REF_38(address) (->info) := advance(address)""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: IF 15

EXPRESSION:
info[memeber].level == 1

IRs:
REF_39(Criplos.Record) -> info[memeber]
REF_40(uint256) -> REF_39.level
TMP_27(bool) = REF_40 == 1
CONDITION TMP_27""];
15->16[label=""True""];
15->17[label=""False""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
info[memeber].level = 0

IRs:
REF_41(Criplos.Record) -> info[memeber]
REF_42(uint256) -> REF_41.level
REF_42(uint256) (->info) := 0(uint256)""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
info[memeber].volume = info[memeber].volume.add(mine)

IRs:
REF_43(Criplos.Record) -> info[memeber]
REF_44(uint256) -> REF_43.volume
REF_45(Criplos.Record) -> info[memeber]
REF_46(uint256) -> REF_45.volume
TMP_28(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_46', 'mine'] 
REF_44(uint256) (->info) := TMP_28(uint256)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
info[memeber].level = info[memeber].level.add(mine)

IRs:
REF_48(Criplos.Record) -> info[memeber]
REF_49(uint256) -> REF_48.level
REF_50(Criplos.Record) -> info[memeber]
REF_51(uint256) -> REF_50.level
TMP_29(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_51', 'mine'] 
REF_49(uint256) (->info) := TMP_29(uint256)""];
19->20;
20[label=""Node Type: NEW VARIABLE 20

EXPRESSION:
publicTokens = tokens.mul(21).div(25)

IRs:
TMP_30(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokens', '21'] 
TMP_31(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_30', '25'] 
publicTokens(uint256) := TMP_31(uint256)""];
20->21;
21[label=""Node Type: NEW VARIABLE 21

EXPRESSION:
advanceTokens = tokens.mul(9).div(100)

IRs:
TMP_32(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokens', '9'] 
TMP_33(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_32', '100'] 
advanceTokens(uint256) := TMP_33(uint256)""];
21->22;
22[label=""Node Type: NEW VARIABLE 22

EXPRESSION:
masterTokens = tokens.mul(7).div(100)

IRs:
TMP_34(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokens', '7'] 
TMP_35(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_34', '100'] 
masterTokens(uint256) := TMP_35(uint256)""];
22->23;
23[label=""Node Type: NEW VARIABLE 23
""];
23->26;
24[label=""Node Type: BEGIN_LOOP 24
""];
24->27;
25[label=""Node Type: END_LOOP 25
""];
25->42;
26[label=""Node Type: NEW VARIABLE 26

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
26->24;
27[label=""Node Type: IF_LOOP 27

EXPRESSION:
i < totalMiners_

IRs:
TMP_36(bool) = i < totalMiners_
CONDITION TMP_36""];
27->28[label=""True""];
27->25[label=""False""];
28[label=""Node Type: IF 28

EXPRESSION:
info[recordAccts[i]].level > 1

IRs:
REF_59(address) -> recordAccts[i]
REF_60(Criplos.Record) -> info[REF_59]
REF_61(uint256) -> REF_60.level
TMP_37(bool) = REF_61 > 1
CONDITION TMP_37""];
28->29[label=""True""];
28->40[label=""False""];
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
checkTokens = publicTokens.mul(info[recordAccts[i]].level).div(totalMining_)

IRs:
REF_63(address) -> recordAccts[i]
REF_64(Criplos.Record) -> info[REF_63]
REF_65(uint256) -> REF_64.level
TMP_38(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['publicTokens', 'REF_65'] 
TMP_39(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_38', 'totalMining_'] 
checkTokens(uint256) := TMP_39(uint256)""];
29->30;
30[label=""Node Type: IF 30

EXPRESSION:
checkTokens < info[recordAccts[i]].volume

IRs:
REF_67(address) -> recordAccts[i]
REF_68(Criplos.Record) -> info[REF_67]
REF_69(uint256) -> REF_68.volume
TMP_40(bool) = checkTokens < REF_69
CONDITION TMP_40""];
30->31[label=""True""];
30->34[label=""False""];
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
info[recordAccts[i]].volume = info[recordAccts[i]].volume.sub(checkTokens)

IRs:
REF_70(address) -> recordAccts[i]
REF_71(Criplos.Record) -> info[REF_70]
REF_72(uint256) -> REF_71.volume
REF_73(address) -> recordAccts[i]
REF_74(Criplos.Record) -> info[REF_73]
REF_75(uint256) -> REF_74.volume
TMP_41(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_75', 'checkTokens'] 
REF_72(uint256) (->info) := TMP_41(uint256)""];
31->32;
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
info[recordAccts[i]].balance = info[recordAccts[i]].balance.add(checkTokens)

IRs:
REF_77(address) -> recordAccts[i]
REF_78(Criplos.Record) -> info[REF_77]
REF_79(uint256) -> REF_78.balance
REF_80(address) -> recordAccts[i]
REF_81(Criplos.Record) -> info[REF_80]
REF_82(uint256) -> REF_81.balance
TMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_82', 'checkTokens'] 
REF_79(uint256) (->info) := TMP_42(uint256)""];
32->33;
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
Transfer(owner,recordAccts[i],checkTokens)

IRs:
REF_84(address) -> recordAccts[i]
Emit Transfer(owner,REF_84,checkTokens)""];
33->39;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
info[recordAccts[i]].balance = info[recordAccts[i]].balance.add(info[recordAccts[i]].volume)

IRs:
REF_85(address) -> recordAccts[i]
REF_86(Criplos.Record) -> info[REF_85]
REF_87(uint256) -> REF_86.balance
REF_88(address) -> recordAccts[i]
REF_89(Criplos.Record) -> info[REF_88]
REF_90(uint256) -> REF_89.balance
REF_92(address) -> recordAccts[i]
REF_93(Criplos.Record) -> info[REF_92]
REF_94(uint256) -> REF_93.volume
TMP_44(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_90', 'REF_94'] 
REF_87(uint256) (->info) := TMP_44(uint256)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
Transfer(owner,recordAccts[i],info[recordAccts[i]].volume)

IRs:
REF_95(address) -> recordAccts[i]
REF_96(address) -> recordAccts[i]
REF_97(Criplos.Record) -> info[REF_96]
REF_98(uint256) -> REF_97.volume
Emit Transfer(owner,REF_95,REF_98)""];
35->36;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
techBuff_ = techBuff_.add(checkTokens.sub(info[recordAccts[i]].volume))

IRs:
REF_101(address) -> recordAccts[i]
REF_102(Criplos.Record) -> info[REF_101]
REF_103(uint256) -> REF_102.volume
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['checkTokens', 'REF_103'] 
TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['techBuff_', 'TMP_46'] 
techBuff_(uint256) := TMP_47(uint256)""];
36->37;
37[label=""Node Type: EXPRESSION 37

EXPRESSION:
info[recordAccts[i]].volume = 0

IRs:
REF_104(address) -> recordAccts[i]
REF_105(Criplos.Record) -> info[REF_104]
REF_106(uint256) -> REF_105.volume
REF_106(uint256) (->info) := 0(uint256)""];
37->38;
38[label=""Node Type: EXPRESSION 38

EXPRESSION:
info[recordAccts[i]].level = 1

IRs:
REF_107(address) -> recordAccts[i]
REF_108(Criplos.Record) -> info[REF_107]
REF_109(uint256) -> REF_108.level
REF_109(uint256) (->info) := 1(uint256)""];
38->39;
39[label=""Node Type: END_IF 39
""];
39->40;
40[label=""Node Type: END_IF 40
""];
40->41;
41[label=""Node Type: EXPRESSION 41

EXPRESSION:
i ++

IRs:
TMP_48(uint256) := i(uint256)
i(uint256) = i + 1""];
41->27;
42[label=""Node Type: EXPRESSION 42

EXPRESSION:
info[advance].balance = info[advance].balance.add(advanceTokens)

IRs:
REF_110(Criplos.Record) -> info[advance]
REF_111(uint256) -> REF_110.balance
REF_112(Criplos.Record) -> info[advance]
REF_113(uint256) -> REF_112.balance
TMP_49(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_113', 'advanceTokens'] 
REF_111(uint256) (->info) := TMP_49(uint256)""];
42->43;
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
Transfer(owner,advance,advanceTokens)

IRs:
Emit Transfer(owner,advance,advanceTokens)""];
43->44;
44[label=""Node Type: EXPRESSION 44

EXPRESSION:
info[info[memeber].master].balance = info[info[memeber].master].balance.add(masterTokens)

IRs:
REF_115(Criplos.Record) -> info[memeber]
REF_116(address) -> REF_115.master
REF_117(Criplos.Record) -> info[REF_116]
REF_118(uint256) -> REF_117.balance
REF_119(Criplos.Record) -> info[memeber]
REF_120(address) -> REF_119.master
REF_121(Criplos.Record) -> info[REF_120]
REF_122(uint256) -> REF_121.balance
TMP_51(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_122', 'masterTokens'] 
REF_118(uint256) (->info) := TMP_51(uint256)""];
44->45;
45[label=""Node Type: EXPRESSION 45

EXPRESSION:
Transfer(owner,info[memeber].master,masterTokens)

IRs:
REF_124(Criplos.Record) -> info[memeber]
REF_125(address) -> REF_124.master
Emit Transfer(owner,REF_125,masterTokens)""];
}
",0,1,0,0,"mine = tokens.mul(6).div(5);totalMining_ = totalMining_.add(mine);techBuff_ > 0;tokens = tokens.add(techBuff_);;techBuff_ = 0;info[msg.sender].level == 0;totalMiners_ ++;;recordAccts.push(msg.sender) - 1;info[master].level > 0;info[msg.sender].master = master;info[msg.sender].master = advance;;info[memeber].level == 1;info[memeber].level = 0;;info[memeber].volume = info[memeber].volume.add(mine);info[memeber].level = info[memeber].level.add(mine);publicTokens = tokens.mul(21).div(25);advanceTokens = tokens.mul(9).div(100);masterTokens = tokens.mul(7).div(100);;i = 0;;i < totalMiners_;;info[advance].balance = info[advance].balance.add(advanceTokens);info[recordAccts[i]].level > 1;checkTokens = publicTokens.mul(info[recordAccts[i]].level).div(totalMining_);;checkTokens < info[recordAccts[i]].volume;info[recordAccts[i]].volume = info[recordAccts[i]].volume.sub(checkTokens);info[recordAccts[i]].balance = info[recordAccts[i]].balance.add(info[recordAccts[i]].volume);info[recordAccts[i]].balance = info[recordAccts[i]].balance.add(checkTokens);Transfer(owner,recordAccts[i],checkTokens);;Transfer(owner,recordAccts[i],info[recordAccts[i]].volume);techBuff_ = techBuff_.add(checkTokens.sub(info[recordAccts[i]].volume));info[recordAccts[i]].volume = 0;info[recordAccts[i]].level = 1;i ++;Transfer(owner,advance,advanceTokens);info[info[memeber].master].balance = info[info[memeber].master].balance.add(masterTokens);Transfer(owner,info[memeber].master,masterTokens)"
./0x35bfd2cfe27ef7af2029d584b9b6c2ca27d9b3c7_ext.sol,EasyEthProfit.getInvestorDividend,48,50,"REF_5(uint256) -> invested[addr],TMP_12(uint256) = REF_5 * FEE,TMP_13(uint256) = TMP_12 / 100,REF_6(uint256) -> dateInvest[addr],TMP_14(uint256) = now - REF_6,TMP_15(uint256) = TMP_13 * TMP_14,TMP_16(uint256) = TMP_15 / 86400,RETURN TMP_16","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
invested[addr] * FEE / 100 * (now - dateInvest[addr]) / 86400

IRs:
REF_5(uint256) -> invested[addr]
TMP_12(uint256) = REF_5 * FEE
TMP_13(uint256) = TMP_12 / 100
REF_6(uint256) -> dateInvest[addr]
TMP_14(uint256) = now - REF_6
TMP_15(uint256) = TMP_13 * TMP_14
TMP_16(uint256) = TMP_15 / 86400
RETURN TMP_16""];
}
",0,1,0,0,invested[addr] * FEE / 100 * (now - dateInvest[addr]) / 86400
./0x86d4bc8aebee12a65c376539cd92e42d60c260d0_ext.sol,PublicBank.mintToken,200,205,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0xf2d4dcfe87430ae9d1e0235edaa7cd3d445e2378_ext.sol,OPCToken.burn,128,134,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x211f01e59b425253c0a0e9a7bf612605b42ce82c_ext.sol,BlockHashRNG.contribute,630,630,"REF_60(uint256) -> reward[_block],REF_60(-> reward) = REF_60 + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
reward[_block] += msg.value

IRs:
REF_60(uint256) -> reward[_block]
REF_60(-> reward) = REF_60 + msg.value""];
}
",0,1,0,0,reward[_block] += msg.value
./0x01d5d0108589f3c52fcce6e65503bb6515e66698_ext.sol,DcorpProxy.propose,636,643,"TMP_44(bool) = INTERNAL_CALL, DcorpProxy.isProposed(address)(_proposedAddress),TMP_45 = UnaryType.BANG TMP_44 ,TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45),REF_27(DcorpProxy.Proposal) -> proposals[_proposedAddress],p(DcorpProxy.Proposal) := REF_27(DcorpProxy.Proposal),REF_28(uint256) -> p.createdTimestamp,REF_28(uint256) (->p) := now(uint256),REF_29(uint256) -> p.index,REF_31 -> LENGTH proposalIndex,TMP_49(uint256) := REF_31(uint256),TMP_50(uint256) = TMP_49 + 1,REF_31(uint256) (->proposalIndex) := TMP_50(uint256),REF_32(address) -> proposalIndex[TMP_49],REF_32(address) (->proposalIndex) := _proposedAddress(address),TMP_48(None) = TMP_47 - 1,REF_29(uint256) (->p) := TMP_48(None),MODIFIER_CALL, Ownership.only_owner()(),REF_33(DcorpProxy.Stages) -> Stages.Deployed,MODIFIER_CALL, DcorpProxy.only_at_stage(DcorpProxy.Stages)(REF_33)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isProposed(_proposedAddress))

IRs:
TMP_44(bool) = INTERNAL_CALL, DcorpProxy.isProposed(address)(_proposedAddress)
TMP_45 = UnaryType.BANG TMP_44 
TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
p = proposals[_proposedAddress]

IRs:
REF_27(DcorpProxy.Proposal) -> proposals[_proposedAddress]
p(DcorpProxy.Proposal) := REF_27(DcorpProxy.Proposal)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
p.createdTimestamp = now

IRs:
REF_28(uint256) -> p.createdTimestamp
REF_28(uint256) (->p) := now(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
p.index = proposalIndex.push(_proposedAddress) - 1

IRs:
REF_29(uint256) -> p.index
REF_31 -> LENGTH proposalIndex
TMP_49(uint256) := REF_31(uint256)
TMP_50(uint256) = TMP_49 + 1
REF_31(uint256) (->proposalIndex) := TMP_50(uint256)
REF_32(address) -> proposalIndex[TMP_49]
REF_32(address) (->proposalIndex) := _proposedAddress(address)
TMP_48(None) = TMP_47 - 1
REF_29(uint256) (->p) := TMP_48(None)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
only_owner()

IRs:
MODIFIER_CALL, Ownership.only_owner()()""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
only_at_stage(Stages.Deployed)

IRs:
REF_33(DcorpProxy.Stages) -> Stages.Deployed
MODIFIER_CALL, DcorpProxy.only_at_stage(DcorpProxy.Stages)(REF_33)""];
6->1;
}
",0,1,0,0,only_owner();require(bool)(! isProposed(_proposedAddress));p = proposals[_proposedAddress];p.createdTimestamp = now;p.index = proposalIndex.push(_proposedAddress) - 1;only_at_stage(Stages.Deployed)
./0xf024628c7bf1ffec7ca184026cd0764ac11ba22f_ext.sol,ClickGemTokenERC20._transfer,36,52,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x40ef62929748b3e045fd2036322880ef486e4454_ext.sol,IQ_GAME.NewQuestion,42,49,"TMP_12(bool) = msg.sender == questionSender,TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12),question(string) := _question(string),responseHash(bytes32) := _responseHash(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_12(bool) = msg.sender == questionSender
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
question = _question

IRs:
question(string) := _question(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
responseHash = _responseHash

IRs:
responseHash(bytes32) := _responseHash(bytes32)""];
}
",0,1,0,0,require(bool)(msg.sender == questionSender);question = _question;responseHash = _responseHash
./0x5aebcc44588feabb4a87076d17f3aa8c950a28e1_ext.sol,SafeOpt.sub,20,25,"TMP_11(uint256) = a - b,c(uint256) := TMP_11(uint256),TMP_12(bool) = b <= a,TMP_13(None) = SOLIDITY_CALL assert(bool)(TMP_12),TMP_14(uint256) = c + b,TMP_15(bool) = a == TMP_14,TMP_16(None) = SOLIDITY_CALL assert(bool)(TMP_15),RETURN c","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
c = a - b

IRs:
TMP_11(uint256) = a - b
c(uint256) := TMP_11(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(b <= a)

IRs:
TMP_12(bool) = b <= a
TMP_13(None) = SOLIDITY_CALL assert(bool)(TMP_12)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
assert(bool)(a == c + b)

IRs:
TMP_14(uint256) = c + b
TMP_15(bool) = a == TMP_14
TMP_16(None) = SOLIDITY_CALL assert(bool)(TMP_15)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
c

IRs:
RETURN c""];
}
",0,1,0,0,c = a - b;assert(bool)(b <= a);assert(bool)(a == c + b);c
./0xc6567b2be42c208bc6875b9ae6b07d0618738c39_ext.sol,DrunkCoin.fallback,52,86,"TMP_12(None) = SOLIDITY_CALL require(bool)(icoRunning),TMP_13(bool) = msg.value > 0,TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13),etherRaised(uint256) = etherRaised + msg.value,TMP_15(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', 'rate'] ,tokens(uint256) := TMP_15(uint256),TMP_16(uint256) = 50 * 1000000000000000000,TMP_17(bool) = drunkness < TMP_16,CONDITION TMP_17,TMP_18(uint256) = 20 * 1000000000000000000,TMP_19(bool) = drunkness < TMP_18,CONDITION TMP_19,TMP_20(uint256) = msg.value * 20,drunkness(uint256) = drunkness + TMP_20,TMP_21(uint256) = 20 * 1000000000000000000,TMP_22(bool) = drunkness > TMP_21,CONDITION TMP_22,TMP_23(uint256) = 20 * 1000000000000000000,drunkness(uint256) := TMP_23(uint256),TMP_24(uint256) = msg.value * 2,drunkness(uint256) = drunkness + TMP_24,TMP_25(uint256) = 50 * 1000000000000000000,TMP_26(bool) = drunkness > TMP_25,CONDITION TMP_26,TMP_27(uint256) = 50 * 1000000000000000000,drunkness(uint256) := TMP_27(uint256),TMP_28(uint256) = drunkness / 1000000000000000000,TMP_29(uint256) = TMP_28 + 1,max_perc_deviation(uint256) := TMP_29(uint256),TMP_30(uint256) = block.number - 1,TMP_31(uint256) = SOLIDITY_CALL blockhash(uint256)(TMP_30),TMP_32 = CONVERT TMP_31 to uint256,currentHash(uint256) := TMP_32(uint256),TMP_33(uint256) = currentHash % 2,TMP_34(bool) = TMP_33 == 0,CONDITION TMP_34,TMP_35(uint256) = currentHash % max_perc_deviation,TMP_36(uint256) = 100 - TMP_35,tokens(uint256) = tokens * TMP_36,TMP_37(uint256) = max_perc_deviation * 4,TMP_38(uint256) = currentHash % TMP_37,TMP_39(uint256) = 100 + TMP_38,tokens(uint256) = tokens * TMP_39,tokens(uint256) = tokens / 100,TMP_40(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_totalSupply', 'tokens'] ,_totalSupply(uint256) := TMP_40(uint256),REF_2(uint256) -> balances[msg.sender],REF_3(uint256) -> balances[msg.sender],TMP_41(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_3', 'tokens'] ,REF_2(uint256) (->balances) := TMP_41(uint256),Transfer dest:owner value:msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(icoRunning)

IRs:
TMP_12(None) = SOLIDITY_CALL require(bool)(icoRunning)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.value > 0)

IRs:
TMP_13(bool) = msg.value > 0
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
etherRaised += msg.value

IRs:
etherRaised(uint256) = etherRaised + msg.value""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
tokens = msg.value.mul(rate)

IRs:
TMP_15(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', 'rate'] 
tokens(uint256) := TMP_15(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
drunkness < 50 * 1000000000000000000

IRs:
TMP_16(uint256) = 50 * 1000000000000000000
TMP_17(bool) = drunkness < TMP_16
CONDITION TMP_17""];
5->6[label=""True""];
5->13[label=""False""];
6[label=""Node Type: IF 6

EXPRESSION:
drunkness < 20 * 1000000000000000000

IRs:
TMP_18(uint256) = 20 * 1000000000000000000
TMP_19(bool) = drunkness < TMP_18
CONDITION TMP_19""];
6->7[label=""True""];
6->11[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
drunkness += msg.value * 20

IRs:
TMP_20(uint256) = msg.value * 20
drunkness(uint256) = drunkness + TMP_20""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
drunkness > 20 * 1000000000000000000

IRs:
TMP_21(uint256) = 20 * 1000000000000000000
TMP_22(bool) = drunkness > TMP_21
CONDITION TMP_22""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
drunkness = 20 * 1000000000000000000

IRs:
TMP_23(uint256) = 20 * 1000000000000000000
drunkness(uint256) := TMP_23(uint256)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
drunkness += msg.value * 2

IRs:
TMP_24(uint256) = msg.value * 2
drunkness(uint256) = drunkness + TMP_24""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
drunkness > 50 * 1000000000000000000

IRs:
TMP_25(uint256) = 50 * 1000000000000000000
TMP_26(bool) = drunkness > TMP_25
CONDITION TMP_26""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
drunkness = 50 * 1000000000000000000

IRs:
TMP_27(uint256) = 50 * 1000000000000000000
drunkness(uint256) := TMP_27(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: NEW VARIABLE 17

EXPRESSION:
max_perc_deviation = drunkness / 1000000000000000000 + 1

IRs:
TMP_28(uint256) = drunkness / 1000000000000000000
TMP_29(uint256) = TMP_28 + 1
max_perc_deviation(uint256) := TMP_29(uint256)""];
17->18;
18[label=""Node Type: NEW VARIABLE 18

EXPRESSION:
currentHash = uint256(block.blockhash(block.number - 1))

IRs:
TMP_30(uint256) = block.number - 1
TMP_31(uint256) = SOLIDITY_CALL blockhash(uint256)(TMP_30)
TMP_32 = CONVERT TMP_31 to uint256
currentHash(uint256) := TMP_32(uint256)""];
18->19;
19[label=""Node Type: IF 19

EXPRESSION:
currentHash % 2 == 0

IRs:
TMP_33(uint256) = currentHash % 2
TMP_34(bool) = TMP_33 == 0
CONDITION TMP_34""];
19->20[label=""True""];
19->21[label=""False""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
tokens *= 100 - (currentHash % max_perc_deviation)

IRs:
TMP_35(uint256) = currentHash % max_perc_deviation
TMP_36(uint256) = 100 - TMP_35
tokens(uint256) = tokens * TMP_36""];
20->22;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
tokens *= 100 + (currentHash % (max_perc_deviation * 4))

IRs:
TMP_37(uint256) = max_perc_deviation * 4
TMP_38(uint256) = currentHash % TMP_37
TMP_39(uint256) = 100 + TMP_38
tokens(uint256) = tokens * TMP_39""];
21->22;
22[label=""Node Type: END_IF 22
""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
tokens /= 100

IRs:
tokens(uint256) = tokens / 100""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
_totalSupply = _totalSupply.add(tokens)

IRs:
TMP_40(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_totalSupply', 'tokens'] 
_totalSupply(uint256) := TMP_40(uint256)""];
24->25;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
balances[msg.sender] = balances[msg.sender].add(tokens)

IRs:
REF_2(uint256) -> balances[msg.sender]
REF_3(uint256) -> balances[msg.sender]
TMP_41(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_3', 'tokens'] 
REF_2(uint256) (->balances) := TMP_41(uint256)""];
25->26;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
owner.transfer(msg.value)

IRs:
Transfer dest:owner value:msg.value""];
}
",0,1,0,0,require(bool)(icoRunning);require(bool)(msg.value > 0);etherRaised += msg.value;tokens = msg.value.mul(rate);drunkness < 50 * 1000000000000000000;drunkness < 20 * 1000000000000000000;;drunkness += msg.value * 20;;drunkness > 20 * 1000000000000000000;drunkness = 20 * 1000000000000000000;;drunkness += msg.value * 2;drunkness > 50 * 1000000000000000000;drunkness = 50 * 1000000000000000000;;max_perc_deviation = drunkness / 1000000000000000000 + 1;currentHash = uint256(block.blockhash(block.number - 1));currentHash % 2 == 0;tokens *= 100 - (currentHash % max_perc_deviation);tokens *= 100 + (currentHash % (max_perc_deviation * 4));;tokens /= 100;_totalSupply = _totalSupply.add(tokens);balances[msg.sender] = balances[msg.sender].add(tokens);owner.transfer(msg.value)
./0x868f77e4758776afa2cc2e46ce972e2043ca8e00_ext.sol,YumeGorilla.transfer,23,32,"TMP_1 = CONVERT this to address,TMP_2(bool) = to != TMP_1,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),TMP_4(bool) = to != 0,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_1(uint256) -> balanceOf[msg.sender],balanceOfMsgSender(uint256) := REF_1(uint256),TMP_6(bool) = balanceOfMsgSender >= amount,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_2(uint256) -> balanceOf[msg.sender],TMP_8(uint256) = balanceOfMsgSender - amount,REF_2(uint256) (->balanceOf) := TMP_8(uint256),REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + amount,Emit Transfer(msg.sender,to,amount),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(to != address(this))

IRs:
TMP_1 = CONVERT this to address
TMP_2(bool) = to != TMP_1
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(to != 0)

IRs:
TMP_4(bool) = to != 0
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
balanceOfMsgSender = balanceOf[msg.sender]

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
balanceOfMsgSender(uint256) := REF_1(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(balanceOfMsgSender >= amount)

IRs:
TMP_6(bool) = balanceOfMsgSender >= amount
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[msg.sender] = balanceOfMsgSender - amount

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
TMP_8(uint256) = balanceOfMsgSender - amount
REF_2(uint256) (->balanceOf) := TMP_8(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[to] += amount

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + amount""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(msg.sender,to,amount)

IRs:
Emit Transfer(msg.sender,to,amount)""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(to != address(this));require(bool)(to != 0);balanceOfMsgSender = balanceOf[msg.sender];require(bool)(balanceOfMsgSender >= amount);balanceOf[msg.sender] = balanceOfMsgSender - amount;balanceOf[to] += amount;Transfer(msg.sender,to,amount);true"
./0x00430f32b8e77a456d0ab7e6f1dc1b84f4ae62e0_ext.sol,MyToken.burn,134,140,"REF_13(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_13 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_14(uint256) -> balanceOf[msg.sender],REF_14(-> balanceOf) = REF_14 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_13(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_13 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_14(uint256) -> balanceOf[msg.sender]
REF_14(-> balanceOf) = REF_14 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x8516b43a9b547e4692433340ca9f0a13b5d25d7f_ext.sol,TheInternetCoin.burn,79,85,"REF_19(uint256) -> balanceOf[msg.sender],TMP_29(bool) = REF_19 >= _value,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),REF_20(uint256) -> balanceOf[msg.sender],REF_20(-> balanceOf) = REF_20 - _value,REF_21(uint256) -> balanceOf[0],REF_21(-> balanceOf) = REF_21 + _value,Emit Transfer(msg.sender,0,_value),TMP_32(uint256) = totalSupply - _value,totalSupply(uint256) := TMP_32(uint256),MODIFIER_CALL, TheInternetCoin.isOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_19(uint256) -> balanceOf[msg.sender]
TMP_29(bool) = REF_19 >= _value
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_20(uint256) -> balanceOf[msg.sender]
REF_20(-> balanceOf) = REF_20 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[0x0] += _value

IRs:
REF_21(uint256) -> balanceOf[0]
REF_21(-> balanceOf) = REF_21 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,0x0,_value)

IRs:
Emit Transfer(msg.sender,0,_value)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply = totalSupply - _value

IRs:
TMP_32(uint256) = totalSupply - _value
totalSupply(uint256) := TMP_32(uint256)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
isOwner()

IRs:
MODIFIER_CALL, TheInternetCoin.isOwner()()""];
6->1;
}
",0,1,0,0,"isOwner();require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;balanceOf[0x0] += _value;Transfer(msg.sender,0x0,_value);totalSupply = totalSupply - _value"
./0xda0b84a81662ec19ba06b8e902f22964dd69e13d_ext.sol,KRT.burnFrom,140,148,"REF_19(uint256) -> balanceOf[_from],TMP_22(bool) = REF_19 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_24(bool) = _value <= REF_21,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_22(bool) = REF_19 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_24(bool) = _value <= REF_21
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x207c92740ccbe446ac2e2f43fe1da52651cd8d3c_ext.sol,TJK.transfer,32,37,"REF_2(uint256) -> balances[msg.sender],TMP_2(bool) = REF_2 >= _value,TMP_3(bool) = _value > 0,TMP_4(bool) = TMP_2 && TMP_3,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_3(uint256) -> balances[msg.sender],REF_3(-> balances) = REF_3 - _value,REF_4(uint256) -> balances[_recipient],REF_4(-> balances) = REF_4 + _value,Emit Transfer(msg.sender,_recipient,_value),TMP_7(uint256) = 2 * 32,MODIFIER_CALL, TJK.onlyPayloadSize(uint256)(TMP_7)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value && _value > 0)

IRs:
REF_2(uint256) -> balances[msg.sender]
TMP_2(bool) = REF_2 >= _value
TMP_3(bool) = _value > 0
TMP_4(bool) = TMP_2 && TMP_3
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_3(uint256) -> balances[msg.sender]
REF_3(-> balances) = REF_3 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_recipient] += _value

IRs:
REF_4(uint256) -> balances[_recipient]
REF_4(-> balances) = REF_4 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_recipient,_value)

IRs:
Emit Transfer(msg.sender,_recipient,_value)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyPayloadSize(2 * 32)

IRs:
TMP_7(uint256) = 2 * 32
MODIFIER_CALL, TJK.onlyPayloadSize(uint256)(TMP_7)""];
5->1;
}
",0,1,0,0,"onlyPayloadSize(2 * 32);require(bool)(balances[msg.sender] >= _value && _value > 0);balances[msg.sender] -= _value;balances[_recipient] += _value;Transfer(msg.sender,_recipient,_value)"
./0x17d30c85376bc2c39edc1da179162d308559a3c4_ext.sol,KFCToken.burn,95,100,"REF_19(uint256) -> balanceOf[msg.sender],TMP_30(bool) = REF_19 >= _value,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_20(uint256) -> balanceOf[msg.sender],REF_20(-> balanceOf) = REF_20 - _value,REF_21(uint256) -> balanceOf[0],REF_21(-> balanceOf) = REF_21 + _value,Emit Transfer(msg.sender,0,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_19(uint256) -> balanceOf[msg.sender]
TMP_30(bool) = REF_19 >= _value
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_20(uint256) -> balanceOf[msg.sender]
REF_20(-> balanceOf) = REF_20 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[0x0] += _value

IRs:
REF_21(uint256) -> balanceOf[0]
REF_21(-> balanceOf) = REF_21 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,0x0,_value)

IRs:
Emit Transfer(msg.sender,0,_value)""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;balanceOf[0x0] += _value;Transfer(msg.sender,0x0,_value)"
./0x17633a41ab9af8b78317a1bd92a985f8482677f9_ext.sol,PrivateSocialPlatform.burnFrom,79,86,"REF_20(uint256) -> balanceOf[_from],TMP_26(bool) = REF_20 < _value,CONDITION TMP_26,TMP_27(None) = SOLIDITY_CALL revert()(),REF_21(mapping(address => uint256)) -> allowance[_from],REF_22(uint256) -> REF_21[msg.sender],TMP_28(bool) = _value > REF_22,CONDITION TMP_28,TMP_29(None) = SOLIDITY_CALL revert()(),REF_23(uint256) -> balanceOf[_from],REF_23(-> balanceOf) = REF_23 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balanceOf[_from] < _value

IRs:
REF_20(uint256) -> balanceOf[_from]
TMP_26(bool) = REF_20 < _value
CONDITION TMP_26""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_27(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
_value > allowance[_from][msg.sender]

IRs:
REF_21(mapping(address => uint256)) -> allowance[_from]
REF_22(uint256) -> REF_21[msg.sender]
TMP_28(bool) = _value > REF_22
CONDITION TMP_28""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
revert()()

IRs:
TMP_29(None) = SOLIDITY_CALL revert()()""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_23(uint256) -> balanceOf[_from]
REF_23(-> balanceOf) = REF_23 - _value""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
9->10;
10[label=""Node Type: RETURN 10

EXPRESSION:
true

IRs:
RETURN True""];
11[label=""Node Type: RETURN 11

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balanceOf[_from] < _value;revert()();;_value > allowance[_from][msg.sender];revert()();;balanceOf[_from] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xcd76b5a4a5fa96149ff02bf3a193f1113c502d95_ext.sol,LaiBiToken.burn,132,138,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x556b7a8e1e842625844de6a08669cd20523ce131_ext.sol,StandardToken.transfer,45,56,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x292ee80f00e83faa51a793a87503024f36f3a1dc_ext.sol,Futurescoin.approveAndCall,203,208,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x693f915802b6f2bf47e97bf28ac118042278c9fa_ext.sol,DynamicToken.issue,99,112,"REF_3(uint256) -> balances[_to],TMP_4(uint256) = REF_3 + _amount,REF_4(uint256) -> balances[_to],TMP_5(bool) = TMP_4 < REF_4,CONDITION TMP_5,TMP_6(None) = SOLIDITY_CALL revert()(),TMP_7(uint256) = totalSupply + _amount,TMP_8(bool) = TMP_7 < totalSupply,CONDITION TMP_8,TMP_9(None) = SOLIDITY_CALL revert()(),REF_5(bool) -> proofIdExists[_proofId],CONDITION REF_5,RETURN False,TMP_10(uint256) = totalSupply + _amount,TMP_11(bool) = TMP_10 > maxSupply,CONDITION TMP_11,RETURN False,REF_6(uint256) -> balances[_to],REF_6(-> balances) = REF_6 + _amount,totalSupply(uint256) = totalSupply + _amount,TMP_12(bool) = INTERNAL_CALL, DynamicToken._indexAccount(address)(_to),TMP_13(bool) = INTERNAL_CALL, DynamicToken._indexProofId(string)(_proofId),Emit Issue(msg.sender,_to,_amount,_proofId),RETURN True,MODIFIER_CALL, DynamicToken.notClosed()(),MODIFIER_CALL, DynamicToken.onlyContractOwner()(),MODIFIER_CALL, DynamicToken.noEther()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->19;
1[label=""Node Type: IF 1

EXPRESSION:
balances[_to] + _amount < balances[_to]

IRs:
REF_3(uint256) -> balances[_to]
TMP_4(uint256) = REF_3 + _amount
REF_4(uint256) -> balances[_to]
TMP_5(bool) = TMP_4 < REF_4
CONDITION TMP_5""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_6(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
totalSupply + _amount < totalSupply

IRs:
TMP_7(uint256) = totalSupply + _amount
TMP_8(bool) = TMP_7 < totalSupply
CONDITION TMP_8""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
revert()()

IRs:
TMP_9(None) = SOLIDITY_CALL revert()()""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
proofIdExists[_proofId]

IRs:
REF_5(bool) -> proofIdExists[_proofId]
CONDITION REF_5""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
totalSupply + _amount > maxSupply

IRs:
TMP_10(uint256) = totalSupply + _amount
TMP_11(bool) = TMP_10 > maxSupply
CONDITION TMP_11""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: RETURN 11

EXPRESSION:
false

IRs:
RETURN False""];
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
balances[_to] += _amount

IRs:
REF_6(uint256) -> balances[_to]
REF_6(-> balances) = REF_6 + _amount""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
totalSupply += _amount

IRs:
totalSupply(uint256) = totalSupply + _amount""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
_indexAccount(_to)

IRs:
TMP_12(bool) = INTERNAL_CALL, DynamicToken._indexAccount(address)(_to)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
_indexProofId(_proofId)

IRs:
TMP_13(bool) = INTERNAL_CALL, DynamicToken._indexProofId(string)(_proofId)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
Issue(msg.sender,_to,_amount,_proofId)

IRs:
Emit Issue(msg.sender,_to,_amount,_proofId)""];
17->18;
18[label=""Node Type: RETURN 18

EXPRESSION:
true

IRs:
RETURN True""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
notClosed()

IRs:
MODIFIER_CALL, DynamicToken.notClosed()()""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
onlyContractOwner()

IRs:
MODIFIER_CALL, DynamicToken.onlyContractOwner()()""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
noEther()

IRs:
MODIFIER_CALL, DynamicToken.noEther()()""];
21->1;
22[label=""Node Type: RETURN 22

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"notClosed();balances[_to] + _amount < balances[_to];revert()();;totalSupply + _amount < totalSupply;revert()();;proofIdExists[_proofId];false;;totalSupply + _amount > maxSupply;false;;balances[_to] += _amount;totalSupply += _amount;_indexAccount(_to);_indexProofId(_proofId);Issue(msg.sender,_to,_amount,_proofId);true;onlyContractOwner();noEther();success"
./0x01628c3308f798362f89886bdac1506e0b33a045_ext.sol,CBC.mintToken,206,211,"REF_29(uint256) -> balances[target],REF_29(-> balances) = REF_29 + mintedAmount,_totalSupply(uint256) = _totalSupply + mintedAmount,Emit Transfer(0,owner,mintedAmount),Emit Transfer(owner,target,mintedAmount),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances[target] += mintedAmount

IRs:
REF_29(uint256) -> balances[target]
REF_29(-> balances) = REF_29 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_totalSupply += mintedAmount

IRs:
_totalSupply(uint256) = _totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,owner,mintedAmount)

IRs:
Emit Transfer(0,owner,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(owner,target,mintedAmount)

IRs:
Emit Transfer(owner,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balances[target] += mintedAmount;_totalSupply += mintedAmount;Transfer(0,owner,mintedAmount);Transfer(owner,target,mintedAmount)"
./0x8495332b80411cf5114b6c3ecc81deeb65b3951d_ext.sol,SUPERBANK.getInvestorDividend,39,41,"REF_8(uint256) -> invested[addr],TMP_22(uint256) = REF_8 * FEE,TMP_23(uint256) = TMP_22 / 100,REF_9(uint256) -> dateInvest[addr],TMP_24(uint256) = now - REF_9,TMP_25(uint256) = TMP_23 * TMP_24,TMP_26(uint256) = TMP_25 / 86400,RETURN TMP_26","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
invested[addr] * FEE / 100 * (now - dateInvest[addr]) / 86400

IRs:
REF_8(uint256) -> invested[addr]
TMP_22(uint256) = REF_8 * FEE
TMP_23(uint256) = TMP_22 / 100
REF_9(uint256) -> dateInvest[addr]
TMP_24(uint256) = now - REF_9
TMP_25(uint256) = TMP_23 * TMP_24
TMP_26(uint256) = TMP_25 / 86400
RETURN TMP_26""];
}
",0,1,0,0,invested[addr] * FEE / 100 * (now - dateInvest[addr]) / 86400
./0x17fd666fa0784885fa1afec8ac624d9b7e72b752_ext.sol,FLiK.approveAndCall,91,98,"TMP_20 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_20(tokenRecipient),TMP_21(bool) = INTERNAL_CALL, FLiK.approve(address,uint256)(_spender,_value),CONDITION TMP_21,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_20 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_20(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_21(bool) = INTERNAL_CALL, FLiK.approve(address,uint256)(_spender,_value)
CONDITION TMP_21""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0xc48e4349d482296c32bb7ca430466f324c694d34_ext.sol,RozowkaCoin.burn,128,134,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x753e7389ecc2566264587522a3e96e12d7a442c9_ext.sol,BKKToken.burnFrom,138,146,"REF_19(uint256) -> balanceOf[_from],TMP_22(bool) = REF_19 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_24(bool) = _value <= REF_21,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_22(bool) = REF_19 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_24(bool) = _value <= REF_21
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xcdcbb474268703da1b6744c540500e8a2a39e8dc_ext.sol,knf.Award,213,219,"TMP_31 = CONVERT 0 to address,TMP_32(bool) = _to != TMP_31,TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32),REF_45(uint256) -> balances[owner],TMP_34(bool) = _v <= REF_45,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),REF_46(uint256) -> balances[_to],REF_46(-> balances) = REF_46 + _v,REF_47(uint256) -> balances[owner],REF_47(-> balances) = REF_47 - _v,INTERNAL_CALL, knf.RecordTransfer(address,address,uint256)(owner,_to,_v),MODIFIER_CALL, knf.onlyControl()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_31 = CONVERT 0 to address
TMP_32(bool) = _to != TMP_31
TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_v <= balances[owner])

IRs:
REF_45(uint256) -> balances[owner]
TMP_34(bool) = _v <= REF_45
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _v

IRs:
REF_46(uint256) -> balances[_to]
REF_46(-> balances) = REF_46 + _v""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[owner] -= _v

IRs:
REF_47(uint256) -> balances[owner]
REF_47(-> balances) = REF_47 - _v""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
RecordTransfer(owner,_to,_v)

IRs:
INTERNAL_CALL, knf.RecordTransfer(address,address,uint256)(owner,_to,_v)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyControl()

IRs:
MODIFIER_CALL, knf.onlyControl()()""];
6->1;
}
",0,1,0,0,"onlyControl();require(bool)(_to != address(0));require(bool)(_v <= balances[owner]);balances[_to] += _v;balances[owner] -= _v;RecordTransfer(owner,_to,_v)"
./0x5af9ec6df6edea0761fa841ce56c2e4deb000b31_ext.sol,ZebiMainCrowdsale.validPurchase,1088,1100,"TMP_500(bool) = transStartTime >= startTime,TMP_501(bool) = transStartTime <= endTime,TMP_502(bool) = TMP_500 && TMP_501,withinPeriod(bool) := TMP_502(bool),TMP_503(bool) = msg.value >= minTransAmount,validAmount(bool) := TMP_503(bool),TMP_504(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['ethCap', 'mainWeiRaised'] ,TMP_505(bool) = TMP_504 > 0,withinEthCap(bool) := TMP_505(bool),goldPeriodValid(bool) := True(bool),TMP_506(uint256) = startTime + goldListPeriod,TMP_507(bool) = transStartTime <= TMP_506,CONDITION TMP_507,REF_301(bool) -> goldList[msg.sender],REF_302(uint256) -> goldListContribution[msg.sender],TMP_508(uint256) = REF_302 + msg.value,TMP_509(bool) = TMP_508 <= goldPeriodCap,TMP_510(bool) = REF_301 && TMP_509,goldPeriodValid(bool) := TMP_510(bool),goldListPeriodFlag(bool) := True(bool),TMP_511(bool) = withinPeriod && validAmount,TMP_512(bool) = TMP_511 && withinEthCap,TMP_513(bool) = TMP_512 && goldPeriodValid,RETURN TMP_513","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
withinPeriod = transStartTime >= startTime && transStartTime <= endTime

IRs:
TMP_500(bool) = transStartTime >= startTime
TMP_501(bool) = transStartTime <= endTime
TMP_502(bool) = TMP_500 && TMP_501
withinPeriod(bool) := TMP_502(bool)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
validAmount = msg.value >= minTransAmount

IRs:
TMP_503(bool) = msg.value >= minTransAmount
validAmount(bool) := TMP_503(bool)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
withinEthCap = ((ethCap.sub(mainWeiRaised)) > 0)

IRs:
TMP_504(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['ethCap', 'mainWeiRaised'] 
TMP_505(bool) = TMP_504 > 0
withinEthCap(bool) := TMP_505(bool)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
goldPeriodValid = true

IRs:
goldPeriodValid(bool) := True(bool)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
transStartTime <= (startTime + goldListPeriod)

IRs:
TMP_506(uint256) = startTime + goldListPeriod
TMP_507(bool) = transStartTime <= TMP_506
CONDITION TMP_507""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
goldPeriodValid = (goldList[msg.sender]) && (goldListContribution[msg.sender] + msg.value <= goldPeriodCap)

IRs:
REF_301(bool) -> goldList[msg.sender]
REF_302(uint256) -> goldListContribution[msg.sender]
TMP_508(uint256) = REF_302 + msg.value
TMP_509(bool) = TMP_508 <= goldPeriodCap
TMP_510(bool) = REF_301 && TMP_509
goldPeriodValid(bool) := TMP_510(bool)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
goldListPeriodFlag = true

IRs:
goldListPeriodFlag(bool) := True(bool)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
withinPeriod && validAmount && withinEthCap && goldPeriodValid

IRs:
TMP_511(bool) = withinPeriod && validAmount
TMP_512(bool) = TMP_511 && withinEthCap
TMP_513(bool) = TMP_512 && goldPeriodValid
RETURN TMP_513""];
}
",0,1,0,0,withinPeriod = transStartTime >= startTime && transStartTime <= endTime;validAmount = msg.value >= minTransAmount;withinEthCap = ((ethCap.sub(mainWeiRaised)) > 0);goldPeriodValid = true;transStartTime <= (startTime + goldListPeriod);goldPeriodValid = (goldList[msg.sender]) && (goldListContribution[msg.sender] + msg.value <= goldPeriodCap);;goldListPeriodFlag = true;withinPeriod && validAmount && withinEthCap && goldPeriodValid
./0x211f01e59b425253c0a0e9a7bf612605b42ce82c_ext.sol,BlockHashRNG.contribute,630,630,"REF_60(uint256) -> reward[_block],REF_60(-> reward) = REF_60 + msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
reward[_block] += msg.value

IRs:
REF_60(uint256) -> reward[_block]
REF_60(-> reward) = REF_60 + msg.value""];
}
",0,1,0,0,reward[_block] += msg.value
./0x6e9d4b330aad2f414fa7ae1074afa266b6469364_ext.sol,AetherClockAuction.averageSalePrice,573,579,"sum(uint256) := 0(uint256),i(uint256) := 0(uint256),TMP_280(bool) = i < 5,CONDITION TMP_280,REF_85(uint256) -> lastSalePrices[i],sum(uint256) = sum + REF_85,TMP_281(uint256) := i(uint256),i(uint256) = i + 1,TMP_282(uint256) = sum / 5,RETURN TMP_282","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
sum = 0

IRs:
sum(uint256) := 0(uint256)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
3->8;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < 5

IRs:
TMP_280(bool) = i < 5
CONDITION TMP_280""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
sum += lastSalePrices[i]

IRs:
REF_85(uint256) -> lastSalePrices[i]
sum(uint256) = sum + REF_85""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_281(uint256) := i(uint256)
i(uint256) = i + 1""];
7->5;
8[label=""Node Type: RETURN 8

EXPRESSION:
sum / 5

IRs:
TMP_282(uint256) = sum / 5
RETURN TMP_282""];
}
",0,1,0,0,sum = 0;i = 0;;i < 5;;sum / 5;sum += lastSalePrices[i];i ++
./0xed3ce5919656b9988ab33c04a0e684ec94043f5b_ext.sol,UltraVioletToken.approveAndCall,203,208,"REF_24(mapping(address => uint256)) -> allowed[msg.sender],REF_25(uint256) -> REF_24[spender],REF_25(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_43 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_43(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_24(mapping(address => uint256)) -> allowed[msg.sender]
REF_25(uint256) -> REF_24[spender]
REF_25(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_43 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_43(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xf208c7a5682d3835a58dadce8e249453ebd0ec0b_ext.sol,FOIN.burn,113,119,"REF_16(uint256) -> balanceOf[msg.sender],TMP_20(bool) = REF_16 >= _value,TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20),REF_17(uint256) -> balanceOf[msg.sender],REF_17(-> balanceOf) = REF_17 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_16(uint256) -> balanceOf[msg.sender]
TMP_20(bool) = REF_16 >= _value
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
REF_17(-> balanceOf) = REF_17 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xf3bfe4b73faa6393f84f59354ebd71b1c4db53fc_ext.sol,TVToken.mint,81,85,"totalSupply(uint256) = totalSupply + _amount,REF_19(uint256) -> balanceOf[msg.sender],REF_19(-> balanceOf) = REF_19 + _amount,RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
totalSupply += _amount

IRs:
totalSupply(uint256) = totalSupply + _amount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] += _amount

IRs:
REF_19(uint256) -> balanceOf[msg.sender]
REF_19(-> balanceOf) = REF_19 + _amount""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,totalSupply += _amount;balanceOf[msg.sender] += _amount;true
./0xa177916265c6f647c8e0bfbed396aec1596d6af8_ext.sol,AOS.transferFrom,138,158,"TMP_14 = CONVERT 0 to address,TMP_15(bool) = _to != TMP_14,TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15),REF_10(uint256) -> balances[msg.sender],TMP_17(bool) = _amount <= REF_10,TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17),TMP_19(bool) = _amount >= 0,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_11(uint256) -> balances[_from],TMP_21(bool) = REF_11 >= _amount,TMP_22(bool) = _amount > 0,TMP_23(bool) = TMP_21 && TMP_22,REF_12(mapping(address => uint256)) -> allowed[_from],REF_13(uint256) -> REF_12[msg.sender],TMP_24(bool) = REF_13 >= _amount,TMP_25(bool) = TMP_23 && TMP_24,CONDITION TMP_25,REF_14(uint256) -> balances[_from],REF_14(-> balances) = REF_14 - _amount,REF_15(mapping(address => uint256)) -> allowed[_from],REF_16(uint256) -> REF_15[msg.sender],REF_16(-> allowed) = REF_16 - _amount,REF_17(uint256) -> balances[_to],REF_17(-> balances) = REF_17 + _amount,Emit Transfer(_from,_to,_amount),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_14 = CONVERT 0 to address
TMP_15(bool) = _to != TMP_14
TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amount <= balances[msg.sender])

IRs:
REF_10(uint256) -> balances[msg.sender]
TMP_17(bool) = _amount <= REF_10
TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_amount >= 0)

IRs:
TMP_19(bool) = _amount >= 0
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
balances[_from] >= _amount && _amount > 0 && allowed[_from][msg.sender] >= _amount

IRs:
REF_11(uint256) -> balances[_from]
TMP_21(bool) = REF_11 >= _amount
TMP_22(bool) = _amount > 0
TMP_23(bool) = TMP_21 && TMP_22
REF_12(mapping(address => uint256)) -> allowed[_from]
REF_13(uint256) -> REF_12[msg.sender]
TMP_24(bool) = REF_13 >= _amount
TMP_25(bool) = TMP_23 && TMP_24
CONDITION TMP_25""];
4->5[label=""True""];
4->10[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[_from] -= _amount

IRs:
REF_14(uint256) -> balances[_from]
REF_14(-> balances) = REF_14 - _amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] -= _amount

IRs:
REF_15(mapping(address => uint256)) -> allowed[_from]
REF_16(uint256) -> REF_15[msg.sender]
REF_16(-> allowed) = REF_16 - _amount""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[_to] += _amount

IRs:
REF_17(uint256) -> balances[_to]
REF_17(-> balances) = REF_17 + _amount""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transfer(_from,_to,_amount)

IRs:
Emit Transfer(_from,_to,_amount)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: RETURN 10

EXPRESSION:
false

IRs:
RETURN False""];
12[label=""Node Type: RETURN 12

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(_to != address(0));require(bool)(_amount <= balances[msg.sender]);require(bool)(_amount >= 0);balances[_from] >= _amount && _amount > 0 && allowed[_from][msg.sender] >= _amount;balances[_from] -= _amount;false;allowed[_from][msg.sender] -= _amount;balances[_to] += _amount;Transfer(_from,_to,_amount);true;success"
./0x178381837f84a7a636f57a3f2946cda512e5caab_ext.sol,TreasureToken.burn,79,84,"REF_19(uint256) -> balanceOf[msg.sender],TMP_29(bool) = REF_19 >= _value,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),REF_20(uint256) -> balanceOf[msg.sender],REF_20(-> balanceOf) = REF_20 - _value,REF_21(uint256) -> balanceOf[0],REF_21(-> balanceOf) = REF_21 + _value,Emit Transfer(msg.sender,0,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_19(uint256) -> balanceOf[msg.sender]
TMP_29(bool) = REF_19 >= _value
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_20(uint256) -> balanceOf[msg.sender]
REF_20(-> balanceOf) = REF_20 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[0x0] += _value

IRs:
REF_21(uint256) -> balanceOf[0]
REF_21(-> balanceOf) = REF_21 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,0x0,_value)

IRs:
Emit Transfer(msg.sender,0,_value)""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;balanceOf[0x0] += _value;Transfer(msg.sender,0x0,_value)"
./0x6b9d6a0bc491f2a6f57fd1eff9acbbaf8d21417b_ext.sol,multifunding.withdraw,13,21,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2),TMP_4(bool) = keyHash == TMP_3,CONDITION TMP_4,TMP_5(bool) = msg.value > 400000000000000000,CONDITION TMP_5,TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),Transfer dest:msg.sender value:TMP_7","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
keyHash == keccak256()(abi.encodePacked(key))

IRs:
TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2)
TMP_4(bool) = keyHash == TMP_3
CONDITION TMP_4""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
msg.value > 400000000000000000

IRs:
TMP_5(bool) = msg.value > 400000000000000000
CONDITION TMP_5""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
Transfer dest:msg.sender value:TMP_7""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,1,0,0,require(bool)(msg.sender == tx.origin);keyHash == keccak256()(abi.encodePacked(key));msg.value > 400000000000000000;;msg.sender.transfer(address(this).balance);
./0x520308ffce2feaf394be1f23997312dede3ef541_ext.sol,StandardToken.transferFrom,55,65,"REF_3(uint256) -> balances[_from],TMP_18(bool) = REF_3 >= _value,REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],TMP_19(bool) = REF_5 >= _value,TMP_20(bool) = TMP_18 && TMP_19,TMP_21(bool) = _value > 0,TMP_22(bool) = TMP_20 && TMP_21,CONDITION TMP_22,REF_6(uint256) -> balances[_to],REF_6(-> balances) = REF_6 + _value,REF_7(uint256) -> balances[_from],REF_7(-> balances) = REF_7 - _value,REF_8(mapping(address => uint256)) -> allowed[_from],REF_9(uint256) -> REF_8[msg.sender],REF_9(-> allowed) = REF_9 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0

IRs:
REF_3(uint256) -> balances[_from]
TMP_18(bool) = REF_3 >= _value
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
TMP_19(bool) = REF_5 >= _value
TMP_20(bool) = TMP_18 && TMP_19
TMP_21(bool) = _value > 0
TMP_22(bool) = TMP_20 && TMP_21
CONDITION TMP_22""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_6(uint256) -> balances[_to]
REF_6(-> balances) = REF_6 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_7(uint256) -> balances[_from]
REF_7(-> balances) = REF_7 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_8(mapping(address => uint256)) -> allowed[_from]
REF_9(uint256) -> REF_8[msg.sender]
REF_9(-> allowed) = REF_9 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0;balances[_to] += _value;false;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true;success"
./0x39e568276531f17da3c76d54400cfd8300201652_ext.sol,CSC.makeCoin,67,72,"TMP_21(bool) = msg.sender == owner,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),totalSupply(uint256) = totalSupply + _value,REF_27(uint256) -> balances[owner],REF_27(-> balances) = REF_27 + _value,RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_21(bool) = msg.sender == owner
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += _value

IRs:
totalSupply(uint256) = totalSupply + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[owner] += _value

IRs:
REF_27(uint256) -> balances[owner]
REF_27(-> balances) = REF_27 + _value""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,require(bool)(msg.sender == owner);totalSupply += _value;balances[owner] += _value;true
./0x9283df9554419641f2cab66af4876f9de8526e4c_ext.sol,KikkeliToken.approveAndCall,291,302,"REF_142(mapping(address => uint256)) -> allowed[msg.sender],REF_143(uint256) -> REF_142[_spender],REF_143(uint256) (->allowed) := _value(uint256),Emit Approval(msg.sender,_spender,_value),TMP_144(bytes32) = SOLIDITY_CALL keccak256()(receiveApproval(address,uint256,address,bytes)),TMP_145 = CONVERT TMP_144 to bytes32,TMP_146 = CONVERT TMP_145 to bytes4,TMP_147(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_146', 'msg.sender', '_value', 'this', '_extraData']  ,TMP_148(None) = SOLIDITY_CALL require(bool)(TMP_147),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_142(mapping(address => uint256)) -> allowed[msg.sender]
REF_143(uint256) -> REF_142[_spender]
REF_143(uint256) (->allowed) := _value(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_spender.call(bytes4(bytes32(keccak256()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData))

IRs:
TMP_144(bytes32) = SOLIDITY_CALL keccak256()(receiveApproval(address,uint256,address,bytes))
TMP_145 = CONVERT TMP_144 to bytes32
TMP_146 = CONVERT TMP_145 to bytes4
TMP_147(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_146', 'msg.sender', '_value', 'this', '_extraData']  
TMP_148(None) = SOLIDITY_CALL require(bool)(TMP_147)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][_spender] = _value;Approval(msg.sender,_spender,_value);require(bool)(_spender.call(bytes4(bytes32(keccak256()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData));true;success"
./0x280daacbd812725baf46e273b84426b1e10ab410_ext.sol,CBEXTOKEN.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x08b4c866ae9d1be56a06e0c302054b4ffe067b43_ext.sol,BitCar.transferFrom,111,120,"REF_4(uint256) -> balances[_from],TMP_5(bool) = REF_4 >= _value,REF_5(mapping(address => uint256)) -> allowed[_from],REF_6(uint256) -> REF_5[msg.sender],TMP_6(bool) = REF_6 >= _value,TMP_7(bool) = TMP_5 && TMP_6,CONDITION TMP_7,REF_7(uint256) -> balances[_from],REF_7(-> balances) = REF_7 - _value,REF_8(mapping(address => uint256)) -> allowed[_from],REF_9(uint256) -> REF_8[msg.sender],REF_9(-> allowed) = REF_9 - _value,REF_10(uint256) -> balances[_to],REF_10(-> balances) = REF_10 + _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN False","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[_from] >= _value && allowed[_from][msg.sender] >= _value

IRs:
REF_4(uint256) -> balances[_from]
TMP_5(bool) = REF_4 >= _value
REF_5(mapping(address => uint256)) -> allowed[_from]
REF_6(uint256) -> REF_5[msg.sender]
TMP_6(bool) = REF_6 >= _value
TMP_7(bool) = TMP_5 && TMP_6
CONDITION TMP_7""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_from] -= _value

IRs:
REF_7(uint256) -> balances[_from]
REF_7(-> balances) = REF_7 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_8(mapping(address => uint256)) -> allowed[_from]
REF_9(uint256) -> REF_8[msg.sender]
REF_9(-> allowed) = REF_9 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] += _value

IRs:
REF_10(uint256) -> balances[_to]
REF_10(-> balances) = REF_10 + _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False""];
}
",0,1,0,0,"balances[_from] >= _value && allowed[_from][msg.sender] >= _value;balances[_from] -= _value;;allowed[_from][msg.sender] -= _value;balances[_to] += _value;Transfer(_from,_to,_value);true;false"
./0x27054b13b1b798b345b591a4d22e6562d47ea75a_ext.sol,AirSwapToken.lockBalance,246,260,"REF_40(AirSwapToken.BalanceLock) -> balanceLocks[msg.sender],REF_41(uint256) -> REF_40.unlockDate,TMP_69(bool) = REF_41 > now,CONDITION TMP_69,REF_42(AirSwapToken.BalanceLock) -> balanceLocks[msg.sender],REF_43(uint256) -> REF_42.amount,TMP_70(bool) = _value >= REF_43,TMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70),REF_44(uint256) -> balances[msg.sender],TMP_72(bool) = REF_44 >= _value,TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72),TMP_74(uint256) = now + lockingPeriod,_expiry(uint256) := TMP_74(uint256),REF_45(AirSwapToken.BalanceLock) -> balanceLocks[msg.sender],REF_46(uint256) -> REF_45.amount,Emit BalanceLocked(msg.sender,REF_46,_value,_expiry),REF_47(AirSwapToken.BalanceLock) -> balanceLocks[msg.sender],TMP_76(AirSwapToken.BalanceLock) = new BalanceLock(_value,_expiry),REF_47(AirSwapToken.BalanceLock) (->balanceLocks) := TMP_76(AirSwapToken.BalanceLock)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balanceLocks[msg.sender].unlockDate > now

IRs:
REF_40(AirSwapToken.BalanceLock) -> balanceLocks[msg.sender]
REF_41(uint256) -> REF_40.unlockDate
TMP_69(bool) = REF_41 > now
CONDITION TMP_69""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value >= balanceLocks[msg.sender].amount)

IRs:
REF_42(AirSwapToken.BalanceLock) -> balanceLocks[msg.sender]
REF_43(uint256) -> REF_42.amount
TMP_70(bool) = _value >= REF_43
TMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_44(uint256) -> balances[msg.sender]
TMP_72(bool) = REF_44 >= _value
TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
_expiry = now + lockingPeriod

IRs:
TMP_74(uint256) = now + lockingPeriod
_expiry(uint256) := TMP_74(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
BalanceLocked(msg.sender,balanceLocks[msg.sender].amount,_value,_expiry)

IRs:
REF_45(AirSwapToken.BalanceLock) -> balanceLocks[msg.sender]
REF_46(uint256) -> REF_45.amount
Emit BalanceLocked(msg.sender,REF_46,_value,_expiry)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balanceLocks[msg.sender] = BalanceLock(_value,_expiry)

IRs:
REF_47(AirSwapToken.BalanceLock) -> balanceLocks[msg.sender]
TMP_76(AirSwapToken.BalanceLock) = new BalanceLock(_value,_expiry)
REF_47(AirSwapToken.BalanceLock) (->balanceLocks) := TMP_76(AirSwapToken.BalanceLock)""];
}
",0,1,0,0,"balanceLocks[msg.sender].unlockDate > now;require(bool)(_value >= balanceLocks[msg.sender].amount);;require(bool)(balances[msg.sender] >= _value);_expiry = now + lockingPeriod;BalanceLocked(msg.sender,balanceLocks[msg.sender].amount,_value,_expiry);balanceLocks[msg.sender] = BalanceLock(_value,_expiry)"
./0x410804f20daf6498ec564a20132985b8da401c2e_ext.sol,MultiSend.multiSendEth,33,37,"i(uint256) := 0(uint256),REF_5 -> LENGTH addresses,TMP_6(bool) = i < REF_5,CONDITION TMP_6,REF_6(address) -> addresses[i],REF_8(uint256) -> counts[i],Transfer dest:REF_6 value:REF_8,TMP_8(uint256) := i(uint256),i(uint256) = i + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addresses.length

IRs:
REF_5 -> LENGTH addresses
TMP_6(bool) = i < REF_5
CONDITION TMP_6""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
addresses[i].transfer(counts[i])

IRs:
REF_6(address) -> addresses[i]
REF_8(uint256) -> counts[i]
Transfer dest:REF_6 value:REF_8""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_8(uint256) := i(uint256)
i(uint256) = i + 1""];
6->4;
}
",0,1,0,0,i = 0;;i < addresses.length;;addresses[i].transfer(counts[i]);i ++
./0xd7faef6fd3d3e22037619a756221e38f7f2c9c62_ext.sol,Blogger.donate,44,54,"TMP_6(uint256) := donationCount(uint256),donationCount(uint256) = donationCount + 1,REF_3(bool) -> didGive[msg.sender],REF_3(bool) (->didGive) := True(bool),TMP_7(Blogger.Donate) = new Donate(msg.sender,msg.value),newDonation(Blogger.Donate) := TMP_7(Blogger.Donate),REF_4(Blogger.Donate) -> donationRecords[msg.sender],REF_4(Blogger.Donate) (->donationRecords) := newDonation(Blogger.Donate)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
donationCount ++

IRs:
TMP_6(uint256) := donationCount(uint256)
donationCount(uint256) = donationCount + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
didGive[msg.sender] = true

IRs:
REF_3(bool) -> didGive[msg.sender]
REF_3(bool) (->didGive) := True(bool)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
newDonation = Donate({funder:msg.sender,value:msg.value})

IRs:
TMP_7(Blogger.Donate) = new Donate(msg.sender,msg.value)
newDonation(Blogger.Donate) := TMP_7(Blogger.Donate)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
donationRecords[msg.sender] = newDonation

IRs:
REF_4(Blogger.Donate) -> donationRecords[msg.sender]
REF_4(Blogger.Donate) (->donationRecords) := newDonation(Blogger.Donate)""];
}
",0,1,0,0,"donationCount ++;didGive[msg.sender] = true;newDonation = Donate({funder:msg.sender,value:msg.value});donationRecords[msg.sender] = newDonation"
./0x3a5f32732d6be576d5dec48354b2377e14675eca_ext.sol,BCTToken.batchTransfer,424,430,"REF_135 -> LENGTH _to,REF_136 -> LENGTH value,TMP_174(bool) = REF_135 == REF_136,TMP_175(None) = SOLIDITY_CALL require(bool)(TMP_174),i(uint256) := 0(uint256),REF_137 -> LENGTH _to,TMP_176(bool) = i < REF_137,CONDITION TMP_176,REF_138(address) -> _to[i],REF_139(uint256) -> value[i],TMP_177(bool) = INTERNAL_CALL, PausableToken.transfer(address,uint256)(REF_138,REF_139),TMP_178(uint256) := i(uint256),i(uint256) = i + 1,RETURN True,MODIFIER_CALL, Pausable.whenNotPaused()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to.length == value.length)

IRs:
REF_135 -> LENGTH _to
REF_136 -> LENGTH value
TMP_174(bool) = REF_135 == REF_136
TMP_175(None) = SOLIDITY_CALL require(bool)(TMP_174)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
3->8;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < _to.length

IRs:
REF_137 -> LENGTH _to
TMP_176(bool) = i < REF_137
CONDITION TMP_176""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
transfer(_to[i],value[i])

IRs:
REF_138(address) -> _to[i]
REF_139(uint256) -> value[i]
TMP_177(bool) = INTERNAL_CALL, PausableToken.transfer(address,uint256)(REF_138,REF_139)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_178(uint256) := i(uint256)
i(uint256) = i + 1""];
7->5;
8[label=""Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
9->1;
10[label=""Node Type: RETURN 10

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"whenNotPaused();require(bool)(_to.length == value.length);i = 0;;i < _to.length;;true;transfer(_to[i],value[i]);i ++;success"
./0x5347bfbec9803c6850dfd55d797e9ecf8689b688_ext.sol,ContractReceiver.tokenFallback,12,20,"REF_0(address) -> tkn.sender,REF_0(address) (->tkn) := _from(address),REF_1(uint256) -> tkn.value,REF_1(uint256) (->tkn) := _value(uint256),REF_2(bytes) -> tkn.data,REF_2(bytes) (->tkn) := _data(bytes),REF_3(None) -> _data[3],TMP_0 = CONVERT REF_3 to uint32,REF_4(None) -> _data[2],TMP_1 = CONVERT REF_4 to uint32,TMP_2(uint32) = TMP_1 << 8,TMP_3(uint32) = TMP_0 + TMP_2,REF_5(None) -> _data[1],TMP_4 = CONVERT REF_5 to uint32,TMP_5(uint32) = TMP_4 << 16,TMP_6(uint32) = TMP_3 + TMP_5,REF_6(None) -> _data[0],TMP_7 = CONVERT REF_6 to uint32,TMP_8(uint32) = TMP_7 << 24,TMP_9(uint32) = TMP_6 + TMP_8,u(uint32) := TMP_9(uint32),REF_7(bytes4) -> tkn.sig,TMP_10 = CONVERT u to bytes4,REF_7(bytes4) (->tkn) := TMP_10(bytes4)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
tkn.sender = _from

IRs:
REF_0(address) -> tkn.sender
REF_0(address) (->tkn) := _from(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tkn.value = _value

IRs:
REF_1(uint256) -> tkn.value
REF_1(uint256) (->tkn) := _value(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
tkn.data = _data

IRs:
REF_2(bytes) -> tkn.data
REF_2(bytes) (->tkn) := _data(bytes)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24)

IRs:
REF_3(None) -> _data[3]
TMP_0 = CONVERT REF_3 to uint32
REF_4(None) -> _data[2]
TMP_1 = CONVERT REF_4 to uint32
TMP_2(uint32) = TMP_1 << 8
TMP_3(uint32) = TMP_0 + TMP_2
REF_5(None) -> _data[1]
TMP_4 = CONVERT REF_5 to uint32
TMP_5(uint32) = TMP_4 << 16
TMP_6(uint32) = TMP_3 + TMP_5
REF_6(None) -> _data[0]
TMP_7 = CONVERT REF_6 to uint32
TMP_8(uint32) = TMP_7 << 24
TMP_9(uint32) = TMP_6 + TMP_8
u(uint32) := TMP_9(uint32)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tkn.sig = bytes4(u)

IRs:
REF_7(bytes4) -> tkn.sig
TMP_10 = CONVERT u to bytes4
REF_7(bytes4) (->tkn) := TMP_10(bytes4)""];
}
",0,1,0,0,;tkn.sender = _from;tkn.value = _value;tkn.data = _data;u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);tkn.sig = bytes4(u)
./0x88c1f00df493673f72aa0481187a0ff8c5ad0e14_ext.sol,ByteConvert.bytesToBytes2,7,13,"i(uint256) := 0(uint256),TMP_0(bool) = i < 2,CONDITION TMP_0,REF_0(None) -> b[i],TMP_1(None) = REF_0 & 255,TMP_2 = CONVERT TMP_1 to bytes2,TMP_3(uint256) = i * 8,TMP_4(bytes2) = TMP_2 >> TMP_3,out(bytes2) = out | TMP_4,TMP_5(uint256) := i(uint256),i(uint256) = i + 1,RETURN out","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
3->8;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < 2

IRs:
TMP_0(bool) = i < 2
CONDITION TMP_0""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
out |= bytes2(b[i] & 0xFF) >> (i * 8)

IRs:
REF_0(None) -> b[i]
TMP_1(None) = REF_0 & 255
TMP_2 = CONVERT TMP_1 to bytes2
TMP_3(uint256) = i * 8
TMP_4(bytes2) = TMP_2 >> TMP_3
out(bytes2) = out | TMP_4""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
i ++

IRs:
TMP_5(uint256) := i(uint256)
i(uint256) = i + 1""];
7->5;
8[label=""Node Type: RETURN 8

EXPRESSION:
out

IRs:
RETURN out""];
}
",0,1,0,0,;i = 0;;i < 2;;out;out |= bytes2(b[i] & 0xFF) >> (i * 8);i ++
./0xa13034912eca36ddb8a0b62bc86251006d8296d6_ext.sol,LightAirdrop.performDifferent,91,100,"TMP_9 = CONVERT tokenAddress to EIP20Interface,tokenContract(EIP20Interface) := TMP_9(EIP20Interface),i(uint256) := 0(uint256),REF_3 -> LENGTH tos,n(uint256) := REF_3(uint256),TMP_10(bool) = i < n,CONDITION TMP_10,REF_5(address) -> tos[i],REF_6(uint256) -> amounts[i],TMP_11(bool) = HIGH_LEVEL_CALL, dest:tokenContract(EIP20Interface), function:transfer, arguments:['REF_5', 'REF_6']  ,TMP_12(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, OwnableContract.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokenContract = EIP20Interface(tokenAddress)

IRs:
TMP_9 = CONVERT tokenAddress to EIP20Interface
tokenContract(EIP20Interface) := TMP_9(EIP20Interface)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
n = tos.length

IRs:
REF_3 -> LENGTH tos
n(uint256) := REF_3(uint256)""];
3->4;
4[label=""Node Type: BEGIN_LOOP 4
""];
4->6;
5[label=""Node Type: END_LOOP 5
""];
6[label=""Node Type: IF_LOOP 6

EXPRESSION:
i < n

IRs:
TMP_10(bool) = i < n
CONDITION TMP_10""];
6->7[label=""True""];
6->5[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokenContract.transfer(tos[i],amounts[i])

IRs:
REF_5(address) -> tos[i]
REF_6(uint256) -> amounts[i]
TMP_11(bool) = HIGH_LEVEL_CALL, dest:tokenContract(EIP20Interface), function:transfer, arguments:['REF_5', 'REF_6']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
i ++

IRs:
TMP_12(uint256) := i(uint256)
i(uint256) = i + 1""];
8->6;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, OwnableContract.onlyOwner()()""];
9->1;
}
",0,1,0,0,"onlyOwner();tokenContract = EIP20Interface(tokenAddress);i = 0;n = tos.length;;i < n;;tokenContract.transfer(tos[i],amounts[i]);i ++"
./0x8bbb3375d2401da181711032f658c52252b03275_ext.sol,online_wallet.setup_key,23,28,"TMP_9(bool) = keyHash == 0,CONDITION TMP_9,TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10),keyHash(bytes32) := TMP_11(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
keyHash == 0x0

IRs:
TMP_9(bool) = keyHash == 0
CONDITION TMP_9""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
keyHash = keccak256()(abi.encodePacked(key))

IRs:
TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10)
keyHash(bytes32) := TMP_11(bytes32)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,1,0,0,keyHash == 0x0;keyHash = keccak256()(abi.encodePacked(key));
./0x0e16923571c50a48b4f9b3b8319606ef8d6106ae_ext.sol,online_wallet.setup_key,23,28,"TMP_9(bool) = keyHash == 0,CONDITION TMP_9,TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10),keyHash(bytes32) := TMP_11(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
keyHash == 0x0

IRs:
TMP_9(bool) = keyHash == 0
CONDITION TMP_9""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
keyHash = keccak256()(abi.encodePacked(key))

IRs:
TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10)
keyHash(bytes32) := TMP_11(bytes32)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,1,0,0,keyHash == 0x0;keyHash = keccak256()(abi.encodePacked(key));
./0x5ab35ca26d56cf6a25162042daf8ab183687844c_ext.sol,StandardToken.transferFrom,56,66,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x55100b6e3e1cc3018881a4a68edf229a80bac944_ext.sol,MintingERC20.mint,208,227,"TMP_67(bool) = locked == True,CONDITION TMP_67,TMP_68 = CONVERT 0 to uint256,RETURN TMP_68,TMP_69 = CONVERT 0 to uint256,TMP_70(bool) = _amount == TMP_69,CONDITION TMP_70,TMP_71 = CONVERT 0 to uint256,RETURN TMP_71,TMP_72(uint256) = initialSupply + _amount,TMP_73(bool) = TMP_72 <= initialSupply,CONDITION TMP_73,TMP_74 = CONVERT 0 to uint256,RETURN TMP_74,TMP_75(uint256) = initialSupply + _amount,TMP_76(bool) = TMP_75 > maxSupply,CONDITION TMP_76,TMP_77 = CONVERT 0 to uint256,RETURN TMP_77,initialSupply(uint256) = initialSupply + _amount,REF_32(uint256) -> balances[_addr],REF_32(-> balances) = REF_32 + _amount,Emit Transfer(this,_addr,_amount),RETURN _amount,MODIFIER_CALL, MintingERC20.onlyMinters()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->17;
1[label=""Node Type: IF 1

EXPRESSION:
locked == true

IRs:
TMP_67(bool) = locked == True
CONDITION TMP_67""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
uint256(0)

IRs:
TMP_68 = CONVERT 0 to uint256
RETURN TMP_68""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
_amount == uint256(0)

IRs:
TMP_69 = CONVERT 0 to uint256
TMP_70(bool) = _amount == TMP_69
CONDITION TMP_70""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: RETURN 5

EXPRESSION:
uint256(0)

IRs:
TMP_71 = CONVERT 0 to uint256
RETURN TMP_71""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
initialSupply + _amount <= initialSupply

IRs:
TMP_72(uint256) = initialSupply + _amount
TMP_73(bool) = TMP_72 <= initialSupply
CONDITION TMP_73""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: RETURN 8

EXPRESSION:
uint256(0)

IRs:
TMP_74 = CONVERT 0 to uint256
RETURN TMP_74""];
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
initialSupply + _amount > maxSupply

IRs:
TMP_75(uint256) = initialSupply + _amount
TMP_76(bool) = TMP_75 > maxSupply
CONDITION TMP_76""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: RETURN 11

EXPRESSION:
uint256(0)

IRs:
TMP_77 = CONVERT 0 to uint256
RETURN TMP_77""];
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
initialSupply += _amount

IRs:
initialSupply(uint256) = initialSupply + _amount""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
balances[_addr] += _amount

IRs:
REF_32(uint256) -> balances[_addr]
REF_32(-> balances) = REF_32 + _amount""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
Transfer(this,_addr,_amount)

IRs:
Emit Transfer(this,_addr,_amount)""];
15->16;
16[label=""Node Type: RETURN 16

EXPRESSION:
_amount

IRs:
RETURN _amount""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
onlyMinters()

IRs:
MODIFIER_CALL, MintingERC20.onlyMinters()()""];
17->1;
}
",0,1,0,0,"onlyMinters();locked == true;uint256(0);;_amount == uint256(0);uint256(0);;initialSupply + _amount <= initialSupply;uint256(0);;initialSupply + _amount > maxSupply;uint256(0);;initialSupply += _amount;balances[_addr] += _amount;Transfer(this,_addr,_amount);_amount"
./0x5c88e93b5feae72f0fbe787c7f1b96ce3f29ee6a_ext.sol,BWW_ERC20.burn,235,241,"REF_21(uint256) -> balanceOf[msg.sender],TMP_44(bool) = REF_21 >= _value,TMP_45(None) = SOLIDITY_CALL require(bool)(TMP_44),REF_22(uint256) -> balanceOf[msg.sender],REF_22(-> balanceOf) = REF_22 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,MODIFIER_CALL, owned.onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_21(uint256) -> balanceOf[msg.sender]
TMP_44(bool) = REF_21 >= _value
TMP_45(None) = SOLIDITY_CALL require(bool)(TMP_44)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_22(uint256) -> balanceOf[msg.sender]
REF_22(-> balanceOf) = REF_22 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
6->1;
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"onlyOwner();require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x57cbbf9b3f6c03c1e6b3aab1152c588d05fec5bc_ext.sol,CoinwareToken.totalSupply,129,131,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x64c36b4cec69ee9041b48b950dfd0fc59a849f68_ext.sol,SafeMath.add,27,31,"TMP_10(uint256) = a + b,c(uint256) := TMP_10(uint256),TMP_11(bool) = c >= a,TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11),RETURN c","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_10(uint256) = a + b
c(uint256) := TMP_10(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_11(bool) = c >= a
TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c""];
}
",0,1,0,0,c = a + b;assert(bool)(c >= a);c
./0x2919336f7a427de135dc515fc5004b083d171ba4_ext.sol,CryptoPokerMarket.createSaleCardToPlayer,205,220,"TMP_84 = CONVERT 0 to address,TMP_85(bool) = _address != TMP_84,TMP_86(None) = SOLIDITY_CALL require(bool)(TMP_85),i(uint256) := 0(uint256),REF_33 -> LENGTH ids,TMP_87(bool) = i < REF_33,CONDITION TMP_87,REF_34(uint256) -> ids[i],REF_35(address) -> cardToOwer[REF_34],TMP_88 = CONVERT 0 to address,TMP_89(bool) = REF_35 == TMP_88,CONDITION TMP_89,REF_37(uint256) -> ids[i],REF_38(CryptoPokerBase.CardStatus) -> CardStatus.Tradable,TMP_90(CryptoPokerBase.Card) = new Card(REF_37,0,REF_38,upIndex),REF_39 -> LENGTH allCards,TMP_92(uint256) := REF_39(uint256),TMP_93(uint256) = TMP_92 + 1,REF_39(uint256) (->allCards) := TMP_93(uint256),REF_40(CryptoPokerBase.Card) -> allCards[TMP_92],REF_40(CryptoPokerBase.Card) (->allCards) := TMP_90(CryptoPokerBase.Card),REF_41(uint256) -> ids[i],REF_42(uint256) -> idToCardIndex[REF_41],REF_43 -> LENGTH allCards,TMP_94(uint256) = REF_43 - 1,REF_42(uint256) (->idToCardIndex) := TMP_94(uint256),REF_44(uint256) -> ids[i],REF_45(address) -> cardToOwer[REF_44],REF_45(address) (->cardToOwer) := _address(address),REF_46(uint256) -> ownerCardCount[_address],REF_47(uint256) -> ownerCardCount[_address],TMP_95(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_47', '1'] ,REF_46(uint256) (->ownerCardCount) := TMP_95(uint256),TMP_96(uint256) := i(uint256),i(uint256) = i + 1,Emit createSaleCardEvent(_address),MODIFIER_CALL, CryptoPokerBase.isWorker()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_address != address(0))

IRs:
TMP_84 = CONVERT 0 to address
TMP_85(bool) = _address != TMP_84
TMP_86(None) = SOLIDITY_CALL require(bool)(TMP_85)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
3->13;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < ids.length

IRs:
REF_33 -> LENGTH ids
TMP_87(bool) = i < REF_33
CONDITION TMP_87""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: IF 6

EXPRESSION:
cardToOwer[ids[i]] == address(0)

IRs:
REF_34(uint256) -> ids[i]
REF_35(address) -> cardToOwer[REF_34]
TMP_88 = CONVERT 0 to address
TMP_89(bool) = REF_35 == TMP_88
CONDITION TMP_89""];
6->7[label=""True""];
6->11[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
allCards.push(Card(ids[i],0,CardStatus.Tradable,upIndex))

IRs:
REF_37(uint256) -> ids[i]
REF_38(CryptoPokerBase.CardStatus) -> CardStatus.Tradable
TMP_90(CryptoPokerBase.Card) = new Card(REF_37,0,REF_38,upIndex)
REF_39 -> LENGTH allCards
TMP_92(uint256) := REF_39(uint256)
TMP_93(uint256) = TMP_92 + 1
REF_39(uint256) (->allCards) := TMP_93(uint256)
REF_40(CryptoPokerBase.Card) -> allCards[TMP_92]
REF_40(CryptoPokerBase.Card) (->allCards) := TMP_90(CryptoPokerBase.Card)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
idToCardIndex[ids[i]] = allCards.length - 1

IRs:
REF_41(uint256) -> ids[i]
REF_42(uint256) -> idToCardIndex[REF_41]
REF_43 -> LENGTH allCards
TMP_94(uint256) = REF_43 - 1
REF_42(uint256) (->idToCardIndex) := TMP_94(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
cardToOwer[ids[i]] = _address

IRs:
REF_44(uint256) -> ids[i]
REF_45(address) -> cardToOwer[REF_44]
REF_45(address) (->cardToOwer) := _address(address)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
ownerCardCount[_address] = ownerCardCount[_address].add(1)

IRs:
REF_46(uint256) -> ownerCardCount[_address]
REF_47(uint256) -> ownerCardCount[_address]
TMP_95(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_47', '1'] 
REF_46(uint256) (->ownerCardCount) := TMP_95(uint256)""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_96(uint256) := i(uint256)
i(uint256) = i + 1""];
12->5;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
createSaleCardEvent(_address)

IRs:
Emit createSaleCardEvent(_address)""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
isWorker()

IRs:
MODIFIER_CALL, CryptoPokerBase.isWorker()()""];
14->1;
}
",0,1,0,0,"isWorker();require(bool)(_address != address(0));i = 0;;i < ids.length;;createSaleCardEvent(_address);cardToOwer[ids[i]] == address(0);allCards.push(Card(ids[i],0,CardStatus.Tradable,upIndex));;idToCardIndex[ids[i]] = allCards.length - 1;cardToOwer[ids[i]] = _address;ownerCardCount[_address] = ownerCardCount[_address].add(1);i ++"
./0xeecdfead2d05f0708450db0ddd65cd513a9b1eea_ext.sol,DiscoverToken.totalSupply,86,88,"TMP_44 = CONVERT 53782656699277583331156680339589267958022985751 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0x096BB29EcE37BF54a2EbDaFd8f7B981bc9e6d817)]

IRs:
TMP_44 = CONVERT 53782656699277583331156680339589267958022985751 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0x096BB29EcE37BF54a2EbDaFd8f7B981bc9e6d817)]
./0x0e44c40162b29f5252db58a7f46b8cabe2c0867f_ext.sol,TokenERC20.burn,100,106,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x32df1ab2161317adbeafd47bcb30a2f1a806ccfb_ext.sol,TokenBaseAsset.removeToken,22,25,"TMP_2(bool) = msg.sender == mOwner,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_1(string) -> mTokens[pDocumentHash],REF_1(string) (->mTokens) := (string)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == mOwner)

IRs:
TMP_2(bool) = msg.sender == mOwner
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
mTokens[pDocumentHash] = 

IRs:
REF_1(string) -> mTokens[pDocumentHash]
REF_1(string) (->mTokens) := (string)""];
}
",0,1,0,0,require(bool)(msg.sender == mOwner);mTokens[pDocumentHash] =
./0x88d4f99341de4afdd94cfb7c1c67c885b79ba6bc_ext.sol,Deed.closeDeed,708,713,"active(bool) := False(bool),TMP_225(uint256) = 1000 - refundRatio,REF_91(uint256) = SOLIDITY_CALL balance(address)(this),TMP_226(uint256) = TMP_225 * REF_91,TMP_227(uint256) = TMP_226 / 1000,TMP_228 = SEND dest:burn value:TMP_227,TMP_229(None) = SOLIDITY_CALL require(bool)(TMP_228),Emit DeedClosed(),INTERNAL_CALL, Deed.destroyDeed()(),MODIFIER_CALL, Deed.onlyRegistrar()(),MODIFIER_CALL, Deed.onlyActive()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
active = false

IRs:
active(bool) := False(bool)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(burn.send(((1000 - refundRatio) * this.balance) / 1000))

IRs:
TMP_225(uint256) = 1000 - refundRatio
REF_91(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_226(uint256) = TMP_225 * REF_91
TMP_227(uint256) = TMP_226 / 1000
TMP_228 = SEND dest:burn value:TMP_227
TMP_229(None) = SOLIDITY_CALL require(bool)(TMP_228)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
DeedClosed()

IRs:
Emit DeedClosed()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
destroyDeed()

IRs:
INTERNAL_CALL, Deed.destroyDeed()()""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyRegistrar()

IRs:
MODIFIER_CALL, Deed.onlyRegistrar()()""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyActive()

IRs:
MODIFIER_CALL, Deed.onlyActive()()""];
6->1;
}
",0,1,0,0,onlyRegistrar();active = false;require(bool)(burn.send(((1000 - refundRatio) * this.balance) / 1000));DeedClosed();destroyDeed();onlyActive()
./0x2d1fbbd6f82738ca00b09024a81e12a8816a22bc_ext.sol,TokenERC20.burn,145,151,"REF_17(uint256) -> balanceOf[msg.sender],TMP_25(bool) = REF_17 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_25(bool) = REF_17 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xcffd73396e6f4dae2fd43da7eeb2536b50b695a1_ext.sol,VirtualGift.getAllGiftTemplateIds,254,272,"REF_43 -> LENGTH giftTemplateStorageArry,TMP_49(bool) = REF_43 > 1,CONDITION TMP_49,REF_44 -> LENGTH giftTemplateStorageArry,TMP_50(uint256) = REF_44 - 1,theLength(uint256) := TMP_50(uint256),TMP_52(uint256[])  = new uint256[](theLength),resultTempIds(uint256[]) = ['TMP_52(uint256[])'],resultIndex(uint256) := 0(uint256),i(uint256) := 1(uint256),TMP_53(bool) = i <= theLength,CONDITION TMP_53,REF_45(uint256) -> resultTempIds[resultIndex],REF_45(uint256) (->resultTempIds) := i(uint256),TMP_54(uint256) := resultIndex(uint256),resultIndex(uint256) = resultIndex + 1,TMP_55(uint256) := i(uint256),i(uint256) = i + 1,RETURN resultTempIds,REF_46 -> LENGTH giftTemplateStorageArry,TMP_56(bool) = REF_46 > 1,TMP_57(None) = SOLIDITY_CALL require(bool)(TMP_56)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
giftTemplateStorageArry.length > 1

IRs:
REF_43 -> LENGTH giftTemplateStorageArry
TMP_49(bool) = REF_43 > 1
CONDITION TMP_49""];
1->2[label=""True""];
1->13[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
theLength = giftTemplateStorageArry.length - 1

IRs:
REF_44 -> LENGTH giftTemplateStorageArry
TMP_50(uint256) = REF_44 - 1
theLength(uint256) := TMP_50(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
resultTempIds = new uint256[](theLength)

IRs:
TMP_52(uint256[])  = new uint256[](theLength)
resultTempIds(uint256[]) = ['TMP_52(uint256[])']""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
resultIndex = 0

IRs:
resultIndex(uint256) := 0(uint256)""];
4->7;
5[label=""Node Type: BEGIN_LOOP 5
""];
5->8;
6[label=""Node Type: END_LOOP 6
""];
6->12;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
i = 1

IRs:
i(uint256) := 1(uint256)""];
7->5;
8[label=""Node Type: IF_LOOP 8

EXPRESSION:
i <= theLength

IRs:
TMP_53(bool) = i <= theLength
CONDITION TMP_53""];
8->9[label=""True""];
8->6[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
resultTempIds[resultIndex] = i

IRs:
REF_45(uint256) -> resultTempIds[resultIndex]
REF_45(uint256) (->resultTempIds) := i(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
resultIndex ++

IRs:
TMP_54(uint256) := resultIndex(uint256)
resultIndex(uint256) = resultIndex + 1""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_55(uint256) := i(uint256)
i(uint256) = i + 1""];
11->8;
12[label=""Node Type: RETURN 12

EXPRESSION:
resultTempIds

IRs:
RETURN resultTempIds""];
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
require(bool)(giftTemplateStorageArry.length > 1)

IRs:
REF_46 -> LENGTH giftTemplateStorageArry
TMP_56(bool) = REF_46 > 1
TMP_57(None) = SOLIDITY_CALL require(bool)(TMP_56)""];
}
",0,1,0,0,giftTemplateStorageArry.length > 1;theLength = giftTemplateStorageArry.length - 1;;resultTempIds = new uint256[](theLength);resultIndex = 0;i = 1;;i <= theLength;;resultTempIds;resultTempIds[resultIndex] = i;resultIndex ++;i ++;require(bool)(giftTemplateStorageArry.length > 1)
./0xa2d8fa4a15943f32f1bda104308519d33ad894ec_ext.sol,MyAdvancedToken.mintToken,209,214,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0xdbc36b40a83c86c1b3c24c55a8c0ab32419ae0c0_ext.sol,TokenERC20._transfer,27,36,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 > REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value > balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 > REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value > balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x28863b9534af2a4c3d912e9a3b76b0b7b4fe2046_ext.sol,ViberateBuyer.withdraw,99,138,"TMP_26(uint256) = earliest_buy_time + 3600,TMP_27(bool) = now > TMP_26,TMP_28(bool) = bought_tokens || TMP_27,TMP_29(bool) = TMP_28 || kill_switch,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),REF_11(uint256) -> balances[user],TMP_31(bool) = REF_11 == 0,CONDITION TMP_31,TMP_32 = UnaryType.BANG bought_tokens ,CONDITION TMP_32,REF_12(uint256) -> balances[user],eth_to_withdraw(uint256) := REF_12(uint256),REF_13(uint256) -> balances[user],REF_13(uint256) (->balances) := 0(uint256),Transfer dest:user value:eth_to_withdraw,TMP_34 = CONVERT this to address,TMP_35(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['TMP_34']  ,contract_token_balance(uint256) := TMP_35(uint256),TMP_36(bool) = contract_token_balance != 0,TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36),REF_16(uint256) -> balances[user],TMP_38(uint256) = REF_16 * contract_token_balance,TMP_39(uint256) = TMP_38 / contract_eth_value,tokens_to_withdraw(uint256) := TMP_39(uint256),REF_17(uint256) -> balances[user],contract_eth_value(uint256) = contract_eth_value - REF_17,REF_18(uint256) -> balances[user],REF_18(uint256) (->balances) := 0(uint256),TMP_40(uint256) = tokens_to_withdraw / 100,fee(uint256) := TMP_40(uint256),TMP_41(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['developer', 'fee']  ,TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41),TMP_43(uint256) = tokens_to_withdraw - fee,TMP_44(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['user', 'TMP_43']  ,TMP_45(None) = SOLIDITY_CALL require(bool)(TMP_44),TMP_46(uint256) = withdraw_bounty / 100,claimed_bounty(uint256) := TMP_46(uint256),withdraw_bounty(uint256) = withdraw_bounty - claimed_bounty,Transfer dest:msg.sender value:claimed_bounty","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(bought_tokens || now > earliest_buy_time + 3600 || kill_switch)

IRs:
TMP_26(uint256) = earliest_buy_time + 3600
TMP_27(bool) = now > TMP_26
TMP_28(bool) = bought_tokens || TMP_27
TMP_29(bool) = TMP_28 || kill_switch
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
balances[user] == 0

IRs:
REF_11(uint256) -> balances[user]
TMP_31(bool) = REF_11 == 0
CONDITION TMP_31""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
! bought_tokens

IRs:
TMP_32 = UnaryType.BANG bought_tokens 
CONDITION TMP_32""];
5->6[label=""True""];
5->9[label=""False""];
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
eth_to_withdraw = balances[user]

IRs:
REF_12(uint256) -> balances[user]
eth_to_withdraw(uint256) := REF_12(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[user] = 0

IRs:
REF_13(uint256) -> balances[user]
REF_13(uint256) (->balances) := 0(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
user.transfer(eth_to_withdraw)

IRs:
Transfer dest:user value:eth_to_withdraw""];
8->17;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
contract_token_balance = token.balanceOf(address(this))

IRs:
TMP_34 = CONVERT this to address
TMP_35(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['TMP_34']  
contract_token_balance(uint256) := TMP_35(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(contract_token_balance != 0)

IRs:
TMP_36(bool) = contract_token_balance != 0
TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)""];
10->11;
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
tokens_to_withdraw = (balances[user] * contract_token_balance) / contract_eth_value

IRs:
REF_16(uint256) -> balances[user]
TMP_38(uint256) = REF_16 * contract_token_balance
TMP_39(uint256) = TMP_38 / contract_eth_value
tokens_to_withdraw(uint256) := TMP_39(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
contract_eth_value -= balances[user]

IRs:
REF_17(uint256) -> balances[user]
contract_eth_value(uint256) = contract_eth_value - REF_17""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
balances[user] = 0

IRs:
REF_18(uint256) -> balances[user]
REF_18(uint256) (->balances) := 0(uint256)""];
13->14;
14[label=""Node Type: NEW VARIABLE 14

EXPRESSION:
fee = tokens_to_withdraw / 100

IRs:
TMP_40(uint256) = tokens_to_withdraw / 100
fee(uint256) := TMP_40(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
require(bool)(token.transfer(developer,fee))

IRs:
TMP_41(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['developer', 'fee']  
TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
require(bool)(token.transfer(user,tokens_to_withdraw - fee))

IRs:
TMP_43(uint256) = tokens_to_withdraw - fee
TMP_44(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['user', 'TMP_43']  
TMP_45(None) = SOLIDITY_CALL require(bool)(TMP_44)""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: NEW VARIABLE 18

EXPRESSION:
claimed_bounty = withdraw_bounty / 100

IRs:
TMP_46(uint256) = withdraw_bounty / 100
claimed_bounty(uint256) := TMP_46(uint256)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
withdraw_bounty -= claimed_bounty

IRs:
withdraw_bounty(uint256) = withdraw_bounty - claimed_bounty""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
msg.sender.transfer(claimed_bounty)

IRs:
Transfer dest:msg.sender value:claimed_bounty""];
}
",0,1,0,0,"require(bool)(bought_tokens || now > earliest_buy_time + 3600 || kill_switch);balances[user] == 0;;;! bought_tokens;eth_to_withdraw = balances[user];contract_token_balance = token.balanceOf(address(this));balances[user] = 0;user.transfer(eth_to_withdraw);;require(bool)(contract_token_balance != 0);tokens_to_withdraw = (balances[user] * contract_token_balance) / contract_eth_value;contract_eth_value -= balances[user];balances[user] = 0;fee = tokens_to_withdraw / 100;require(bool)(token.transfer(developer,fee));require(bool)(token.transfer(user,tokens_to_withdraw - fee));claimed_bounty = withdraw_bounty / 100;withdraw_bounty -= claimed_bounty;msg.sender.transfer(claimed_bounty)"
./0x0dfb8da77a4067bd45f229e0e5185d8123a2dc7f_ext.sol,HEART.burnFrom,102,109,"REF_19(uint256) -> balanceOf[_from],TMP_37(bool) = REF_19 >= _value,TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_39(bool) = _value <= REF_21,TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_37(bool) = REF_19 >= _value
TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_39(bool) = _value <= REF_21
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xee7477b1c42d173c0791cecf2592f6a8a4c16b0a_ext.sol,BiddingCustom.bid,257,302,"REF_45(BiddingCustom.Auction) -> auctions[auctionIndex],auction(BiddingCustom.Auction) := REF_45(BiddingCustom.Auction),REF_46(address) -> auction.highestBidder,prevBidder(address) := REF_46(address),REF_47(uint128) -> auction.highestBid,returnValue(uint256) := REF_47(uint128),REF_48(uint256) -> pendingReturns[msg.sender],TMP_118(bool) = useFromPendingReturn <= REF_48,TMP_119(None) = SOLIDITY_CALL require(bool)(TMP_118),bank(uint256) := useFromPendingReturn(uint256),REF_49(uint256) -> pendingReturns[msg.sender],REF_49(-> pendingReturns) = REF_49 - bank,totalReturns(uint256) = totalReturns - bank,TMP_120(uint256) = bank + msg.value,currentBid(uint256) := TMP_120(uint256),REF_50(uint128) -> auction.highestBid,TMP_121(uint128) = REF_50 + minBid,TMP_122(bool) = currentBid >= TMP_121,REF_51(uint128) -> auction.highestBid,TMP_123(bool) = currentBid >= REF_51,TMP_124 = CONVERT 0 to address,TMP_125(bool) = prevBidder == TMP_124,TMP_126(bool) = TMP_123 && TMP_125,TMP_127(bool) = TMP_122 || TMP_126,TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127),TMP_129(bool) = INTERNAL_CALL, BiddingCustom.isActive(uint16)(auctionIndex),TMP_130(None) = SOLIDITY_CALL require(bool)(TMP_129),REF_52(uint128) -> auction.highestBid,TMP_131 = CONVERT currentBid to uint128,REF_52(uint128) (->auction) := TMP_131(uint128),REF_53(address) -> auction.highestBidder,REF_53(address) (->auction) := msg.sender(address),REF_54(uint40) -> auction.lastBidTime,TMP_132 = CONVERT now to uint40,REF_54(uint40) (->auction) := TMP_132(uint40),i(uint16) := 0(uint256),REF_55 -> LENGTH auctions,TMP_133(bool) = i < REF_55,CONDITION TMP_133,TMP_134(bool) = INTERNAL_CALL, BiddingCustom.isActive(uint16)(i),REF_56(BiddingCustom.Auction) -> auctions[i],REF_57(uint40) -> REF_56.timeEnd,TMP_135(uint256) = now + minTime,TMP_136(bool) = REF_57 < TMP_135,TMP_137(bool) = TMP_134 && TMP_136,CONDITION TMP_137,REF_58(BiddingCustom.Auction) -> auctions[i],REF_59(uint40) -> REF_58.timeEnd,TMP_138 = CONVERT now to uint40,TMP_139(uint40) = TMP_138 + minTime,REF_59(uint40) (->auctions) := TMP_139(uint40),TMP_140(uint16) := i(uint16),i(uint16) = i + 1,TMP_141(uint256) = currentBid - returnValue,Emit Bid(msg.sender,prevBidder,currentBid,TMP_141,auctionIndex),TMP_143 = CONVERT 0 to address,TMP_144(bool) = prevBidder != TMP_143,CONDITION TMP_144,TMP_145(bool) = INTERNAL_CALL, BiddingBase.isContract(address)(prevBidder),TMP_146 = UnaryType.BANG TMP_145 ,CONDITION TMP_146,TMP_147 = SEND dest:prevBidder value:returnValue,CONDITION TMP_147,REF_61(uint256) -> pendingReturns[prevBidder],REF_61(-> pendingReturns) = REF_61 + returnValue,totalReturns(uint256) = totalReturns + returnValue,MODIFIER_CALL, Pausable.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->32;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
auction = auctions[auctionIndex]

IRs:
REF_45(BiddingCustom.Auction) -> auctions[auctionIndex]
auction(BiddingCustom.Auction) := REF_45(BiddingCustom.Auction)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
prevBidder = auction.highestBidder

IRs:
REF_46(address) -> auction.highestBidder
prevBidder(address) := REF_46(address)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
returnValue = auction.highestBid

IRs:
REF_47(uint128) -> auction.highestBid
returnValue(uint256) := REF_47(uint128)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(useFromPendingReturn <= pendingReturns[msg.sender])

IRs:
REF_48(uint256) -> pendingReturns[msg.sender]
TMP_118(bool) = useFromPendingReturn <= REF_48
TMP_119(None) = SOLIDITY_CALL require(bool)(TMP_118)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bank = useFromPendingReturn

IRs:
bank(uint256) := useFromPendingReturn(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
pendingReturns[msg.sender] -= bank

IRs:
REF_49(uint256) -> pendingReturns[msg.sender]
REF_49(-> pendingReturns) = REF_49 - bank""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
totalReturns -= bank

IRs:
totalReturns(uint256) = totalReturns - bank""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
currentBid = bank + msg.value

IRs:
TMP_120(uint256) = bank + msg.value
currentBid(uint256) := TMP_120(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(currentBid >= auction.highestBid + minBid || currentBid >= auction.highestBid && prevBidder == address(0))

IRs:
REF_50(uint128) -> auction.highestBid
TMP_121(uint128) = REF_50 + minBid
TMP_122(bool) = currentBid >= TMP_121
REF_51(uint128) -> auction.highestBid
TMP_123(bool) = currentBid >= REF_51
TMP_124 = CONVERT 0 to address
TMP_125(bool) = prevBidder == TMP_124
TMP_126(bool) = TMP_123 && TMP_125
TMP_127(bool) = TMP_122 || TMP_126
TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
require(bool)(isActive(auctionIndex))

IRs:
TMP_129(bool) = INTERNAL_CALL, BiddingCustom.isActive(uint16)(auctionIndex)
TMP_130(None) = SOLIDITY_CALL require(bool)(TMP_129)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
auction.highestBid = uint128(currentBid)

IRs:
REF_52(uint128) -> auction.highestBid
TMP_131 = CONVERT currentBid to uint128
REF_52(uint128) (->auction) := TMP_131(uint128)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
auction.highestBidder = msg.sender

IRs:
REF_53(address) -> auction.highestBidder
REF_53(address) (->auction) := msg.sender(address)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
auction.lastBidTime = uint40(now)

IRs:
REF_54(uint40) -> auction.lastBidTime
TMP_132 = CONVERT now to uint40
REF_54(uint40) (->auction) := TMP_132(uint40)""];
13->16;
14[label=""Node Type: BEGIN_LOOP 14
""];
14->17;
15[label=""Node Type: END_LOOP 15
""];
15->22;
16[label=""Node Type: NEW VARIABLE 16

EXPRESSION:
i = 0

IRs:
i(uint16) := 0(uint256)""];
16->14;
17[label=""Node Type: IF_LOOP 17

EXPRESSION:
i < auctions.length

IRs:
REF_55 -> LENGTH auctions
TMP_133(bool) = i < REF_55
CONDITION TMP_133""];
17->18[label=""True""];
17->15[label=""False""];
18[label=""Node Type: IF 18

EXPRESSION:
isActive(i) && auctions[i].timeEnd < now + minTime

IRs:
TMP_134(bool) = INTERNAL_CALL, BiddingCustom.isActive(uint16)(i)
REF_56(BiddingCustom.Auction) -> auctions[i]
REF_57(uint40) -> REF_56.timeEnd
TMP_135(uint256) = now + minTime
TMP_136(bool) = REF_57 < TMP_135
TMP_137(bool) = TMP_134 && TMP_136
CONDITION TMP_137""];
18->19[label=""True""];
18->20[label=""False""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
auctions[i].timeEnd = uint40(now) + minTime

IRs:
REF_58(BiddingCustom.Auction) -> auctions[i]
REF_59(uint40) -> REF_58.timeEnd
TMP_138 = CONVERT now to uint40
TMP_139(uint40) = TMP_138 + minTime
REF_59(uint40) (->auctions) := TMP_139(uint40)""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
i ++

IRs:
TMP_140(uint16) := i(uint16)
i(uint16) = i + 1""];
21->17;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
Bid(msg.sender,prevBidder,currentBid,currentBid - returnValue,auctionIndex)

IRs:
TMP_141(uint256) = currentBid - returnValue
Emit Bid(msg.sender,prevBidder,currentBid,TMP_141,auctionIndex)""];
22->23;
23[label=""Node Type: IF 23

EXPRESSION:
prevBidder != address(0)

IRs:
TMP_143 = CONVERT 0 to address
TMP_144(bool) = prevBidder != TMP_143
CONDITION TMP_144""];
23->24[label=""True""];
23->31[label=""False""];
24[label=""Node Type: IF 24

EXPRESSION:
! isContract(prevBidder)

IRs:
TMP_145(bool) = INTERNAL_CALL, BiddingBase.isContract(address)(prevBidder)
TMP_146 = UnaryType.BANG TMP_145 
CONDITION TMP_146""];
24->25[label=""True""];
24->28[label=""False""];
25[label=""Node Type: IF 25

EXPRESSION:
prevBidder.send(returnValue)

IRs:
TMP_147 = SEND dest:prevBidder value:returnValue
CONDITION TMP_147""];
25->26[label=""True""];
25->27[label=""False""];
26[label=""Node Type: RETURN 26
""];
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
pendingReturns[prevBidder] += returnValue

IRs:
REF_61(uint256) -> pendingReturns[prevBidder]
REF_61(-> pendingReturns) = REF_61 + returnValue""];
29->30;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
totalReturns += returnValue

IRs:
totalReturns(uint256) = totalReturns + returnValue""];
30->31;
31[label=""Node Type: END_IF 31
""];
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
32->1;
}
",0,1,0,0,"whenNotPaused();auction = auctions[auctionIndex];prevBidder = auction.highestBidder;returnValue = auction.highestBid;require(bool)(useFromPendingReturn <= pendingReturns[msg.sender]);bank = useFromPendingReturn;pendingReturns[msg.sender] -= bank;totalReturns -= bank;currentBid = bank + msg.value;require(bool)(currentBid >= auction.highestBid + minBid || currentBid >= auction.highestBid && prevBidder == address(0));require(bool)(isActive(auctionIndex));auction.highestBid = uint128(currentBid);auction.highestBidder = msg.sender;auction.lastBidTime = uint40(now);i = 0;;i < auctions.length;;Bid(msg.sender,prevBidder,currentBid,currentBid - returnValue,auctionIndex);isActive(i) && auctions[i].timeEnd < now + minTime;auctions[i].timeEnd = uint40(now) + minTime;;i ++;prevBidder != address(0);! isContract(prevBidder);;prevBidder.send(returnValue);;;;pendingReturns[prevBidder] += returnValue;totalReturns += returnValue"
./0xf0552ae7f174e43479159f87a66417cca31eb54b_ext.sol,VOCC_I054_20181211.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x6b31a898f7e711b323a6212eac4ae250e0d6624f_ext.sol,EthLendToken.changeNameSymbol,37,44,"TMP_0(bool) = msg.sender == owner,TMP_1(bool) = msg.value >= howManyEtherInWeiToChangeSymbolName,TMP_2(bool) = TMP_0 || TMP_1,CONDITION TMP_2,name(string) := _name(string),symbol(string) := _symbol(string)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == owner || msg.value >= howManyEtherInWeiToChangeSymbolName

IRs:
TMP_0(bool) = msg.sender == owner
TMP_1(bool) = msg.value >= howManyEtherInWeiToChangeSymbolName
TMP_2(bool) = TMP_0 || TMP_1
CONDITION TMP_2""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
name = _name

IRs:
name(string) := _name(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
symbol = _symbol

IRs:
symbol(string) := _symbol(string)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,msg.sender == owner || msg.value >= howManyEtherInWeiToChangeSymbolName;name = _name;;symbol = _symbol
./0x74956d3e06b9edfab13f91ac45d8d22420545fd9_ext.sol,TEGTY.burn,194,200,"REF_29(uint256) -> balanceOf[msg.sender],TMP_94(bool) = REF_29 >= _value,TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94),REF_30(uint256) -> balanceOf[msg.sender],REF_30(-> balanceOf) = REF_30 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_29(uint256) -> balanceOf[msg.sender]
TMP_94(bool) = REF_29 >= _value
TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_30(uint256) -> balanceOf[msg.sender]
REF_30(-> balanceOf) = REF_30 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xf442c2f7f9f91bd482fac07ed599ece40ffcc283_ext.sol,HeelToken.burn,121,127,"REF_17(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_17 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_17 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x53ce47cbe7f2be0aecd086a70182a98c907d024d_ext.sol,EasyMineIco.buyTokens,396,438,"TMP_127(bool) = msg.value > 0,TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127),amountRemaining(uint256) := msg.value(uint256),tokensToReceive(uint256) := 0(uint256),i(uint8) := 0(uint256),REF_53 -> LENGTH priceThresholds,TMP_129(bool) = i < REF_53,CONDITION TMP_129,REF_54(EasyMineIco.PriceThreshold) -> priceThresholds[i],REF_55(uint256) -> REF_54.tokenCount,REF_56(EasyMineIco.PriceThreshold) -> priceThresholds[i],REF_57(uint256) -> REF_56.tokensSold,TMP_130(uint256) = REF_55 - REF_57,tokensAvailable(uint256) := TMP_130(uint256),TMP_131(uint256) = 10 ** 18,TMP_132(uint256) = amountRemaining * TMP_131,REF_58(EasyMineIco.PriceThreshold) -> priceThresholds[i],REF_59(uint256) -> REF_58.price,TMP_133(uint256) = TMP_132 / REF_59,maxTokensByAmount(uint256) := TMP_133(uint256),TMP_134(bool) = maxTokensByAmount > tokensAvailable,CONDITION TMP_134,tokens(uint256) := tokensAvailable(uint256),REF_60(EasyMineIco.PriceThreshold) -> priceThresholds[i],REF_61(uint256) -> REF_60.price,TMP_135(uint256) = REF_61 * tokens,TMP_136(uint256) = 10 ** 18,TMP_137(uint256) = TMP_135 / TMP_136,amountRemaining(uint256) = amountRemaining - TMP_137,tokens(uint256) := maxTokensByAmount(uint256),amountRemaining(uint256) := 0(uint256),REF_62(EasyMineIco.PriceThreshold) -> priceThresholds[i],REF_63(uint256) -> REF_62.tokensSold,REF_63(-> priceThresholds) = REF_63 + tokens,tokensToReceive(uint256) = tokensToReceive + tokens,TMP_138(uint8) := i(uint8),i(uint8) = i + 1,TMP_139(bool) = tokensToReceive > 0,TMP_140(None) = SOLIDITY_CALL assert(bool)(TMP_139),TMP_141(bool) = amountRemaining != 0,CONDITION TMP_141,TMP_142 = SEND dest:msg.sender value:amountRemaining,TMP_143(None) = SOLIDITY_CALL assert(bool)(TMP_142),TMP_144(uint256) = msg.value - amountRemaining,TMP_145 = SEND dest:wallet value:TMP_144,TMP_146(None) = SOLIDITY_CALL assert(bool)(TMP_145),TMP_147(bool) = HIGH_LEVEL_CALL, dest:easyMineToken(EasyMineToken), function:transfer, arguments:['msg.sender', 'tokensToReceive']  ,TMP_148(None) = SOLIDITY_CALL assert(bool)(TMP_147),TMP_149(uint256) = INTERNAL_CALL, EasyMineIco.totalTokensSold()(),TMP_150(uint256) = INTERNAL_CALL, EasyMineIco.maxTokensSold()(),TMP_151(bool) = TMP_149 == TMP_150,CONDITION TMP_151,INTERNAL_CALL, EasyMineIco.finalize()(),Emit TokensSold(msg.sender,tokensToReceive),MODIFIER_CALL, EasyMineIco.isValidPayload()(),MODIFIER_CALL, EasyMineIco.timedTransitions()(),REF_67(EasyMineIco.Stages) -> Stages.Started,MODIFIER_CALL, EasyMineIco.atStage(EasyMineIco.Stages)(REF_67)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->30;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value > 0)

IRs:
TMP_127(bool) = msg.value > 0
TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amountRemaining = msg.value

IRs:
amountRemaining(uint256) := msg.value(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
tokensToReceive = 0

IRs:
tokensToReceive(uint256) := 0(uint256)""];
3->6;
4[label=""Node Type: BEGIN_LOOP 4
""];
4->7;
5[label=""Node Type: END_LOOP 5
""];
5->20;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)""];
6->4;
7[label=""Node Type: IF_LOOP 7

EXPRESSION:
i < priceThresholds.length

IRs:
REF_53 -> LENGTH priceThresholds
TMP_129(bool) = i < REF_53
CONDITION TMP_129""];
7->8[label=""True""];
7->5[label=""False""];
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
tokensAvailable = priceThresholds[i].tokenCount - priceThresholds[i].tokensSold

IRs:
REF_54(EasyMineIco.PriceThreshold) -> priceThresholds[i]
REF_55(uint256) -> REF_54.tokenCount
REF_56(EasyMineIco.PriceThreshold) -> priceThresholds[i]
REF_57(uint256) -> REF_56.tokensSold
TMP_130(uint256) = REF_55 - REF_57
tokensAvailable(uint256) := TMP_130(uint256)""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
maxTokensByAmount = amountRemaining * 10 ** 18 / priceThresholds[i].price

IRs:
TMP_131(uint256) = 10 ** 18
TMP_132(uint256) = amountRemaining * TMP_131
REF_58(EasyMineIco.PriceThreshold) -> priceThresholds[i]
REF_59(uint256) -> REF_58.price
TMP_133(uint256) = TMP_132 / REF_59
maxTokensByAmount(uint256) := TMP_133(uint256)""];
9->10;
10[label=""Node Type: NEW VARIABLE 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
maxTokensByAmount > tokensAvailable

IRs:
TMP_134(bool) = maxTokensByAmount > tokensAvailable
CONDITION TMP_134""];
11->12[label=""True""];
11->14[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
tokens = tokensAvailable

IRs:
tokens(uint256) := tokensAvailable(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
amountRemaining -= (priceThresholds[i].price * tokens) / 10 ** 18

IRs:
REF_60(EasyMineIco.PriceThreshold) -> priceThresholds[i]
REF_61(uint256) -> REF_60.price
TMP_135(uint256) = REF_61 * tokens
TMP_136(uint256) = 10 ** 18
TMP_137(uint256) = TMP_135 / TMP_136
amountRemaining(uint256) = amountRemaining - TMP_137""];
13->16;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
tokens = maxTokensByAmount

IRs:
tokens(uint256) := maxTokensByAmount(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
amountRemaining = 0

IRs:
amountRemaining(uint256) := 0(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
priceThresholds[i].tokensSold += tokens

IRs:
REF_62(EasyMineIco.PriceThreshold) -> priceThresholds[i]
REF_63(uint256) -> REF_62.tokensSold
REF_63(-> priceThresholds) = REF_63 + tokens""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
tokensToReceive += tokens

IRs:
tokensToReceive(uint256) = tokensToReceive + tokens""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
i ++

IRs:
TMP_138(uint8) := i(uint8)
i(uint8) = i + 1""];
19->7;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
assert(bool)(tokensToReceive > 0)

IRs:
TMP_139(bool) = tokensToReceive > 0
TMP_140(None) = SOLIDITY_CALL assert(bool)(TMP_139)""];
20->21;
21[label=""Node Type: IF 21

EXPRESSION:
amountRemaining != 0

IRs:
TMP_141(bool) = amountRemaining != 0
CONDITION TMP_141""];
21->22[label=""True""];
21->23[label=""False""];
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
assert(bool)(msg.sender.send(amountRemaining))

IRs:
TMP_142 = SEND dest:msg.sender value:amountRemaining
TMP_143(None) = SOLIDITY_CALL assert(bool)(TMP_142)""];
22->23;
23[label=""Node Type: END_IF 23
""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
assert(bool)(wallet.send(msg.value - amountRemaining))

IRs:
TMP_144(uint256) = msg.value - amountRemaining
TMP_145 = SEND dest:wallet value:TMP_144
TMP_146(None) = SOLIDITY_CALL assert(bool)(TMP_145)""];
24->25;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
assert(bool)(easyMineToken.transfer(msg.sender,tokensToReceive))

IRs:
TMP_147(bool) = HIGH_LEVEL_CALL, dest:easyMineToken(EasyMineToken), function:transfer, arguments:['msg.sender', 'tokensToReceive']  
TMP_148(None) = SOLIDITY_CALL assert(bool)(TMP_147)""];
25->26;
26[label=""Node Type: IF 26

EXPRESSION:
totalTokensSold() == maxTokensSold()

IRs:
TMP_149(uint256) = INTERNAL_CALL, EasyMineIco.totalTokensSold()()
TMP_150(uint256) = INTERNAL_CALL, EasyMineIco.maxTokensSold()()
TMP_151(bool) = TMP_149 == TMP_150
CONDITION TMP_151""];
26->27[label=""True""];
26->28[label=""False""];
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
finalize()

IRs:
INTERNAL_CALL, EasyMineIco.finalize()()""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
TokensSold(msg.sender,tokensToReceive)

IRs:
Emit TokensSold(msg.sender,tokensToReceive)""];
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
isValidPayload()

IRs:
MODIFIER_CALL, EasyMineIco.isValidPayload()()""];
30->31;
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
timedTransitions()

IRs:
MODIFIER_CALL, EasyMineIco.timedTransitions()()""];
31->32;
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
atStage(Stages.Started)

IRs:
REF_67(EasyMineIco.Stages) -> Stages.Started
MODIFIER_CALL, EasyMineIco.atStage(EasyMineIco.Stages)(REF_67)""];
32->1;
}
",0,1,0,0,"isValidPayload();require(bool)(msg.value > 0);amountRemaining = msg.value;tokensToReceive = 0;i = 0;;i < priceThresholds.length;;assert(bool)(tokensToReceive > 0);tokensAvailable = priceThresholds[i].tokenCount - priceThresholds[i].tokensSold;maxTokensByAmount = amountRemaining * 10 ** 18 / priceThresholds[i].price;;maxTokensByAmount > tokensAvailable;tokens = tokensAvailable;tokens = maxTokensByAmount;amountRemaining -= (priceThresholds[i].price * tokens) / 10 ** 18;;amountRemaining = 0;priceThresholds[i].tokensSold += tokens;tokensToReceive += tokens;i ++;amountRemaining != 0;assert(bool)(msg.sender.send(amountRemaining));;assert(bool)(wallet.send(msg.value - amountRemaining));assert(bool)(easyMineToken.transfer(msg.sender,tokensToReceive));totalTokensSold() == maxTokensSold();finalize();;TokensSold(msg.sender,tokensToReceive);timedTransitions();atStage(Stages.Started)"
./0x01e53a2e7122a63845b1c329d4fce8124dda5b06_ext.sol,Loan.CheckProfit,152,158,"REF_6(Loan.Creditor) -> Creditors[addr],REF_7(uint256) -> REF_6.Invested,TMP_46(uint256) = REF_7 / 100,TMP_47(uint256) = TMP_46 * prcntRate,REF_8(Loan.Creditor) -> Creditors[addr],REF_9(uint256) -> REF_8.Time,TMP_48(uint256) = now - REF_9,TMP_49(uint256) = TMP_48 / 86400,TMP_50(uint256) = TMP_47 * TMP_49,RETURN TMP_50","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
((Creditors[addr].Invested / 100) * prcntRate) * ((now - Creditors[addr].Time) / 86400)

IRs:
REF_6(Loan.Creditor) -> Creditors[addr]
REF_7(uint256) -> REF_6.Invested
TMP_46(uint256) = REF_7 / 100
TMP_47(uint256) = TMP_46 * prcntRate
REF_8(Loan.Creditor) -> Creditors[addr]
REF_9(uint256) -> REF_8.Time
TMP_48(uint256) = now - REF_9
TMP_49(uint256) = TMP_48 / 86400
TMP_50(uint256) = TMP_47 * TMP_49
RETURN TMP_50""];
}
",0,1,0,0,((Creditors[addr].Invested / 100) * prcntRate) * ((now - Creditors[addr].Time) / 86400)
./0xeed30721320b6372128e47dc48122fc2c65c1baa_ext.sol,TestPausedToken.transferFrom,48,64,"TMP_7 = CONVERT 0 to address,TMP_8(bool) = _to == TMP_7,CONDITION TMP_8,RETURN False,REF_7(uint256) -> balances[_from],TMP_9(bool) = _value > REF_7,CONDITION TMP_9,RETURN False,REF_8(mapping(address => uint256)) -> allowed[_from],REF_9(uint256) -> REF_8[msg.sender],TMP_10(bool) = _value > REF_9,CONDITION TMP_10,RETURN False,REF_10(uint256) -> balances[_from],REF_11(uint256) -> balances[_from],TMP_11(uint256) = REF_11 - _value,REF_10(uint256) (->balances) := TMP_11(uint256),REF_12(uint256) -> balances[_to],REF_13(uint256) -> balances[_to],TMP_12(uint256) = REF_13 + _value,REF_12(uint256) (->balances) := TMP_12(uint256),REF_14(mapping(address => uint256)) -> allowed[_from],REF_15(uint256) -> REF_14[msg.sender],REF_16(mapping(address => uint256)) -> allowed[_from],REF_17(uint256) -> REF_16[msg.sender],TMP_13(uint256) = REF_17 + _value,REF_15(uint256) (->allowed) := TMP_13(uint256),Emit Transfer(_from,_to,_value),RETURN True,MODIFIER_CALL, TestPausedToken.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->15;
1[label=""Node Type: IF 1

EXPRESSION:
_to == address(0)

IRs:
TMP_7 = CONVERT 0 to address
TMP_8(bool) = _to == TMP_7
CONDITION TMP_8""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
false

IRs:
RETURN False""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
_value > balances[_from]

IRs:
REF_7(uint256) -> balances[_from]
TMP_9(bool) = _value > REF_7
CONDITION TMP_9""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: RETURN 5

EXPRESSION:
false

IRs:
RETURN False""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
_value > allowed[_from][msg.sender]

IRs:
REF_8(mapping(address => uint256)) -> allowed[_from]
REF_9(uint256) -> REF_8[msg.sender]
TMP_10(bool) = _value > REF_9
CONDITION TMP_10""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: RETURN 8

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
balances[_from] = balances[_from] - _value

IRs:
REF_10(uint256) -> balances[_from]
REF_11(uint256) -> balances[_from]
TMP_11(uint256) = REF_11 - _value
REF_10(uint256) (->balances) := TMP_11(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
balances[_to] = balances[_to] + _value

IRs:
REF_12(uint256) -> balances[_to]
REF_13(uint256) -> balances[_to]
TMP_12(uint256) = REF_13 + _value
REF_12(uint256) (->balances) := TMP_12(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
allowed[_from][msg.sender] = allowed[_from][msg.sender] + _value

IRs:
REF_14(mapping(address => uint256)) -> allowed[_from]
REF_15(uint256) -> REF_14[msg.sender]
REF_16(mapping(address => uint256)) -> allowed[_from]
REF_17(uint256) -> REF_16[msg.sender]
TMP_13(uint256) = REF_17 + _value
REF_15(uint256) (->allowed) := TMP_13(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
13->14;
14[label=""Node Type: RETURN 14

EXPRESSION:
true

IRs:
RETURN True""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, TestPausedToken.whenNotPaused()()""];
15->1;
}
",0,1,0,0,"whenNotPaused();_to == address(0);false;;_value > balances[_from];false;;_value > allowed[_from][msg.sender];false;;balances[_from] = balances[_from] - _value;balances[_to] = balances[_to] + _value;allowed[_from][msg.sender] = allowed[_from][msg.sender] + _value;Transfer(_from,_to,_value);true"
./0xee278a3543afbe4c1639b430774537995c6bd995_ext.sol,PDAToken.burn,136,145,"REF_17(uint256) -> balanceOf[msg.sender],TMP_25(bool) = REF_17 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_25(bool) = REF_17 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x7038c15f76ad2667837c438c8819fd969899cdbe_ext.sol,Airdrop.drop,8,12,"i(uint256) := 0(uint256),REF_0 -> LENGTH recipients,TMP_0(bool) = i < REF_0,CONDITION TMP_0,REF_2(address) -> recipients[i],REF_3(uint256) -> values[i],TMP_1(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['REF_2', 'REF_3']  ,TMP_2(uint256) := i(uint256),i(uint256) = i + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < recipients.length

IRs:
REF_0 -> LENGTH recipients
TMP_0(bool) = i < REF_0
CONDITION TMP_0""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
token.transfer(recipients[i],values[i])

IRs:
REF_2(address) -> recipients[i]
REF_3(uint256) -> values[i]
TMP_1(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['REF_2', 'REF_3']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_2(uint256) := i(uint256)
i(uint256) = i + 1""];
6->4;
}
",0,1,0,0,"i = 0;;i < recipients.length;;token.transfer(recipients[i],values[i]);i ++"
./0x57cbbf9b3f6c03c1e6b3aab1152c588d05fec5bc_ext.sol,CoinwareToken.approveAndCall,202,207,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xbd91b8e4d0afb1b7fc19bca93a74a1c531bd125c_ext.sol,IscmToken.approveAndCall,83,89,"REF_31(mapping(address => uint256)) -> allowed[msg.sender],REF_32(uint256) -> REF_31[_spender],REF_32(uint256) (->allowed) := _value(uint256),Emit Approval(msg.sender,_spender,_value),TMP_26(bytes32) = SOLIDITY_CALL sha3()(receiveApproval(address,uint256,address,bytes)),TMP_27 = CONVERT TMP_26 to bytes32,TMP_28 = CONVERT TMP_27 to bytes4,TMP_29(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_28', 'msg.sender', '_value', 'this', '_extraData']  ,TMP_30 = UnaryType.BANG TMP_29 ,CONDITION TMP_30,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][_spender] = _value

IRs:
REF_31(mapping(address => uint256)) -> allowed[msg.sender]
REF_32(uint256) -> REF_31[_spender]
REF_32(uint256) (->allowed) := _value(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,_spender,_value)

IRs:
Emit Approval(msg.sender,_spender,_value)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
! _spender.call(bytes4(bytes32(sha3()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData)

IRs:
TMP_26(bytes32) = SOLIDITY_CALL sha3()(receiveApproval(address,uint256,address,bytes))
TMP_27 = CONVERT TMP_26 to bytes32
TMP_28 = CONVERT TMP_27 to bytes4
TMP_29(bool) = LOW_LEVEL_CALL, dest:_spender, function:call, arguments:['TMP_28', 'msg.sender', '_value', 'this', '_extraData']  
TMP_30 = UnaryType.BANG TMP_29 
CONDITION TMP_30""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: THROW 4
""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][_spender] = _value;Approval(msg.sender,_spender,_value);! _spender.call(bytes4(bytes32(sha3()(receiveApproval(address,uint256,address,bytes)))),msg.sender,_value,this,_extraData);;;true;success"
./0x5744155b0891e09b36d871daf35c04a0f0ef4b9c_ext.sol,StandardToken.transfer,44,51,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x87b9d30c83317d1c07f49c7583bef7e8eea24107_ext.sol,SecurityTokenZhiFu.transfer,109,119,"REF_1(uint256) -> balances[msg.sender],TMP_21(bool) = REF_1 >= _value,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),TMP_23(bool) = msg.sender == _to,REF_2(uint256) -> balances[_to],TMP_24(uint256) = MAX_UINT256 - _value,TMP_25(bool) = REF_2 <= TMP_24,TMP_26(bool) = TMP_23 || TMP_25,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_3(uint256) -> balances[msg.sender],REF_3(-> balances) = REF_3 - _value,REF_4(uint256) -> balances[_to],REF_4(-> balances) = REF_4 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_21(bool) = REF_1 >= _value
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == _to || balances[_to] <= MAX_UINT256 - _value)

IRs:
TMP_23(bool) = msg.sender == _to
REF_2(uint256) -> balances[_to]
TMP_24(uint256) = MAX_UINT256 - _value
TMP_25(bool) = REF_2 <= TMP_24
TMP_26(bool) = TMP_23 || TMP_25
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_3(uint256) -> balances[msg.sender]
REF_3(-> balances) = REF_3 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] += _value

IRs:
REF_4(uint256) -> balances[_to]
REF_4(-> balances) = REF_4 + _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);require(bool)(msg.sender == _to || balances[_to] <= MAX_UINT256 - _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true"
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.getReward,2,2,"rtnVal(uint256) := 0(uint256),TMP_247(bool) = payStyle == 0,CONDITION TMP_247,TMP_248(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  ,taBal(uint256) := TMP_248(uint256),TMP_249(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['taBal', 'userSignupCount'] ,rtnVal(uint256) := TMP_249(uint256),TMP_250(bool) = payStyle == 1,CONDITION TMP_250,rtnVal(uint256) := fixPayAmt(uint256),TMP_251(bool) = payStyle == 2,CONDITION TMP_251,REF_140(KahnDistributionCentre.User) -> bounties[_address],REF_141(uint256) -> REF_140.reward_amount,rtnVal(uint256) := REF_141(uint256),RETURN rtnVal","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
rtnVal = 0

IRs:
rtnVal(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
payStyle == 0

IRs:
TMP_247(bool) = payStyle == 0
CONDITION TMP_247""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
taBal = token.balanceOf(this)

IRs:
TMP_248(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  
taBal(uint256) := TMP_248(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
rtnVal = taBal.div(userSignupCount)

IRs:
TMP_249(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['taBal', 'userSignupCount'] 
rtnVal(uint256) := TMP_249(uint256)""];
4->11;
5[label=""Node Type: IF 5

EXPRESSION:
payStyle == 1

IRs:
TMP_250(bool) = payStyle == 1
CONDITION TMP_250""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
rtnVal = fixPayAmt

IRs:
rtnVal(uint256) := fixPayAmt(uint256)""];
6->10;
7[label=""Node Type: IF 7

EXPRESSION:
payStyle == 2

IRs:
TMP_251(bool) = payStyle == 2
CONDITION TMP_251""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
rtnVal = bounties[_address].reward_amount

IRs:
REF_140(KahnDistributionCentre.User) -> bounties[_address]
REF_141(uint256) -> REF_140.reward_amount
rtnVal(uint256) := REF_141(uint256)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: RETURN 12

EXPRESSION:
rtnVal

IRs:
RETURN rtnVal""];
}
",0,1,1,0,rtnVal = 0;payStyle == 0;taBal = token.balanceOf(this);payStyle == 1;rtnVal = taBal.div(userSignupCount);;rtnVal = fixPayAmt;payStyle == 2;;rtnVal = bounties[_address].reward_amount;;rtnVal
./0x65731ac534bc0d3fdf3f4bdd2b09cf05044920bc_ext.sol,MetadollarFund.dividendsOf,423,429,"REF_33(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_65(uint256) = profitPerShare_ * REF_33,TMP_66 = CONVERT TMP_65 to int256,REF_34(int256) -> payoutsTo_[_customerAddress],TMP_67(int256) = TMP_66 - REF_34,TMP_68 = CONVERT TMP_67 to uint256,TMP_69(uint256) = TMP_68 / magnitude,RETURN TMP_69","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_33(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_65(uint256) = profitPerShare_ * REF_33
TMP_66 = CONVERT TMP_65 to int256
REF_34(int256) -> payoutsTo_[_customerAddress]
TMP_67(int256) = TMP_66 - REF_34
TMP_68 = CONVERT TMP_67 to uint256
TMP_69(uint256) = TMP_68 / magnitude
RETURN TMP_69""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x77fa1d1ded3f4bed737e9ae870a6f3605445df9c_ext.sol,CryptoPokemon.setPokemon,216,223,"REF_49(CryptoPokemon.Pokemon) -> pokemons[_pokemonId],REF_50(address) -> REF_49.ownerAddress,REF_50(address) (->pokemons) := _ownerAddress(address),REF_51(CryptoPokemon.Pokemon) -> pokemons[_pokemonId],REF_52(string) -> REF_51.pokemonName,REF_52(string) (->pokemons) := _pokemonName(string),REF_53(CryptoPokemon.Pokemon) -> pokemons[_pokemonId],REF_54(uint256) -> REF_53.currentPrice,REF_54(uint256) (->pokemons) := _currentPrice(uint256),REF_55(uint256) -> levels[_pokemonId],REF_55(uint256) (->levels) := _levels(uint256),REF_56(bool) -> lock[_pokemonId],REF_56(bool) (->lock) := False(bool),MODIFIER_CALL, CryptoPokemon.onlyContractCreator()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
pokemons[_pokemonId].ownerAddress = _ownerAddress

IRs:
REF_49(CryptoPokemon.Pokemon) -> pokemons[_pokemonId]
REF_50(address) -> REF_49.ownerAddress
REF_50(address) (->pokemons) := _ownerAddress(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
pokemons[_pokemonId].pokemonName = _pokemonName

IRs:
REF_51(CryptoPokemon.Pokemon) -> pokemons[_pokemonId]
REF_52(string) -> REF_51.pokemonName
REF_52(string) (->pokemons) := _pokemonName(string)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
pokemons[_pokemonId].currentPrice = _currentPrice

IRs:
REF_53(CryptoPokemon.Pokemon) -> pokemons[_pokemonId]
REF_54(uint256) -> REF_53.currentPrice
REF_54(uint256) (->pokemons) := _currentPrice(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
levels[_pokemonId] = _levels

IRs:
REF_55(uint256) -> levels[_pokemonId]
REF_55(uint256) (->levels) := _levels(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
lock[_pokemonId] = false

IRs:
REF_56(bool) -> lock[_pokemonId]
REF_56(bool) (->lock) := False(bool)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyContractCreator()

IRs:
MODIFIER_CALL, CryptoPokemon.onlyContractCreator()()""];
6->1;
}
",0,1,0,0,onlyContractCreator();pokemons[_pokemonId].ownerAddress = _ownerAddress;pokemons[_pokemonId].pokemonName = _pokemonName;pokemons[_pokemonId].currentPrice = _currentPrice;levels[_pokemonId] = _levels;lock[_pokemonId] = false
./0x1fab9d2996767db0ca6af12fd92c1f2aab2675a0_ext.sol,ZethrSlots.getSpinOutput,2886,2930,"TMP_776(uint256[])  = new uint256[](_numSpins),output(uint256[]) = ['TMP_776(uint256[])'],TMP_777(uint256) = block.number - _blockNumber,TMP_778(bool) = TMP_777 > 255,CONDITION TMP_778,TMP_779(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '_numSpins'] ,TMP_780(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_779', '99'] ,TMP_781(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_780', '100'] ,lossAmount(uint256) := TMP_781(uint256),TMP_782(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '_numSpins'] ,TMP_783(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_782', '100'] ,jackpotAmount(uint256) := TMP_783(uint256),i(uint256) := 0(uint256),TMP_784(bool) = i < _numSpins,CONDITION TMP_784,REF_373(uint256) -> output[i],TMP_785(uint256) = INTERNAL_CALL, ZethrSlots.random(uint256,uint256,address,uint256)(1000000,_blockNumber,_target,i),TMP_786(uint256) = TMP_785 + 1,REF_373(uint256) (->output) := TMP_786(uint256),REF_374(uint256) -> output[i],TMP_787(bool) = REF_374 < 2,CONDITION TMP_787,TMP_788(uint256) := jackpotWins(uint256),jackpotWins(uint256) = jackpotWins + 1,lossAmount(uint256) = lossAmount + _tokenValue,REF_375(uint256) -> output[i],TMP_789(bool) = REF_375 > 506856,CONDITION TMP_789,TMP_790(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '99'] ,TMP_791(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_790', '100'] ,lossAmount(uint256) = lossAmount + TMP_791,TMP_792(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_tokenValue', '100'] ,jackpotAmount(uint256) = jackpotAmount + TMP_792,index(uint256) := 0(uint256),REF_379 -> LENGTH MULTIPLIER_BOUNDARIES,TMP_793(bool) = index < REF_379,CONDITION TMP_793,REF_380(uint256) -> output[i],REF_381(uint256) -> MULTIPLIER_BOUNDARIES[index],TMP_794(bool) = REF_380 < REF_381,CONDITION TMP_794,TMP_795(uint256) := index(uint256),index(uint256) = index + 1,REF_383(uint256) -> MULTIPLIERS[index],TMP_796(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', 'REF_383'] ,TMP_797(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_796', '100'] ,winAmount(uint256) = winAmount + TMP_797,TMP_798(uint256) := i(uint256),i(uint256) = i + 1,Emit SlotsResult(_blockNumber,_target,_numSpins,_tokenValue,winAmount,lossAmount,output),RETURN winAmount,lossAmount,jackpotAmount,jackpotWins,output,RETURN winAmount,lossAmount,jackpotAmount,jackpotWins,output","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
output = new uint256[](_numSpins)

IRs:
TMP_776(uint256[])  = new uint256[](_numSpins)
output(uint256[]) = ['TMP_776(uint256[])']""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
block.number - _blockNumber > 255

IRs:
TMP_777(uint256) = block.number - _blockNumber
TMP_778(bool) = TMP_777 > 255
CONDITION TMP_778""];
2->3[label=""True""];
2->7[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
lossAmount = (_tokenValue.mul(_numSpins).mul(99)).div(100)

IRs:
TMP_779(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '_numSpins'] 
TMP_780(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_779', '99'] 
TMP_781(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_780', '100'] 
lossAmount(uint256) := TMP_781(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
jackpotAmount = _tokenValue.mul(_numSpins).div(100)

IRs:
TMP_782(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '_numSpins'] 
TMP_783(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_782', '100'] 
jackpotAmount(uint256) := TMP_783(uint256)""];
4->29;
5[label=""Node Type: BEGIN_LOOP 5
""];
5->8;
6[label=""Node Type: END_LOOP 6
""];
6->29;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
7->5;
8[label=""Node Type: IF_LOOP 8

EXPRESSION:
i < _numSpins

IRs:
TMP_784(bool) = i < _numSpins
CONDITION TMP_784""];
8->9[label=""True""];
8->6[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
output[i] = random(1000000,_blockNumber,_target,i) + 1

IRs:
REF_373(uint256) -> output[i]
TMP_785(uint256) = INTERNAL_CALL, ZethrSlots.random(uint256,uint256,address,uint256)(1000000,_blockNumber,_target,i)
TMP_786(uint256) = TMP_785 + 1
REF_373(uint256) (->output) := TMP_786(uint256)""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
output[i] < 2

IRs:
REF_374(uint256) -> output[i]
TMP_787(bool) = REF_374 < 2
CONDITION TMP_787""];
10->11[label=""True""];
10->13[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
jackpotWins ++

IRs:
TMP_788(uint256) := jackpotWins(uint256)
jackpotWins(uint256) = jackpotWins + 1""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
lossAmount += _tokenValue

IRs:
lossAmount(uint256) = lossAmount + _tokenValue""];
12->27;
13[label=""Node Type: IF 13

EXPRESSION:
output[i] > 506856

IRs:
REF_375(uint256) -> output[i]
TMP_789(bool) = REF_375 > 506856
CONDITION TMP_789""];
13->14[label=""True""];
13->16[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
lossAmount += (_tokenValue.mul(99)).div(100)

IRs:
TMP_790(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', '99'] 
TMP_791(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_790', '100'] 
lossAmount(uint256) = lossAmount + TMP_791""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
jackpotAmount += _tokenValue.div(100)

IRs:
TMP_792(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['_tokenValue', '100'] 
jackpotAmount(uint256) = jackpotAmount + TMP_792""];
15->26;
16[label=""Node Type: NEW VARIABLE 16
""];
16->19;
17[label=""Node Type: BEGIN_LOOP 17
""];
17->20;
18[label=""Node Type: END_LOOP 18
""];
18->25;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
index = 0

IRs:
index(uint256) := 0(uint256)""];
19->17;
20[label=""Node Type: IF_LOOP 20

EXPRESSION:
index < MULTIPLIER_BOUNDARIES.length

IRs:
REF_379 -> LENGTH MULTIPLIER_BOUNDARIES
TMP_793(bool) = index < REF_379
CONDITION TMP_793""];
20->21[label=""True""];
20->18[label=""False""];
21[label=""Node Type: IF 21

EXPRESSION:
output[i] < MULTIPLIER_BOUNDARIES[index]

IRs:
REF_380(uint256) -> output[i]
REF_381(uint256) -> MULTIPLIER_BOUNDARIES[index]
TMP_794(bool) = REF_380 < REF_381
CONDITION TMP_794""];
21->22[label=""True""];
21->23[label=""False""];
22[label=""Node Type: BREAK 22
""];
22->18;
23[label=""Node Type: END_IF 23
""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
index ++

IRs:
TMP_795(uint256) := index(uint256)
index(uint256) = index + 1""];
24->20;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
winAmount += _tokenValue.mul(MULTIPLIERS[index]).div(100)

IRs:
REF_383(uint256) -> MULTIPLIERS[index]
TMP_796(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['_tokenValue', 'REF_383'] 
TMP_797(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_796', '100'] 
winAmount(uint256) = winAmount + TMP_797""];
25->26;
26[label=""Node Type: END_IF 26
""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
i ++

IRs:
TMP_798(uint256) := i(uint256)
i(uint256) = i + 1""];
28->8;
29[label=""Node Type: END_IF 29
""];
29->30;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
SlotsResult(_blockNumber,_target,_numSpins,_tokenValue,winAmount,lossAmount,output)

IRs:
Emit SlotsResult(_blockNumber,_target,_numSpins,_tokenValue,winAmount,lossAmount,output)""];
30->31;
31[label=""Node Type: RETURN 31

EXPRESSION:
(winAmount,lossAmount,jackpotAmount,jackpotWins,output)

IRs:
RETURN winAmount,lossAmount,jackpotAmount,jackpotWins,output""];
32[label=""Node Type: RETURN 32

EXPRESSION:
(winAmount,lossAmount,jackpotAmount,jackpotWins,output)

IRs:
RETURN winAmount,lossAmount,jackpotAmount,jackpotWins,output""];
}
",0,1,0,0,"output = new uint256[](_numSpins);block.number - _blockNumber > 255;lossAmount = (_tokenValue.mul(_numSpins).mul(99)).div(100);i = 0;jackpotAmount = _tokenValue.mul(_numSpins).div(100);;;i < _numSpins;;output[i] = random(1000000,_blockNumber,_target,i) + 1;output[i] < 2;jackpotWins ++;output[i] > 506856;lossAmount += _tokenValue;;lossAmount += (_tokenValue.mul(99)).div(100);;jackpotAmount += _tokenValue.div(100);;index = 0;;index < MULTIPLIER_BOUNDARIES.length;;winAmount += _tokenValue.mul(MULTIPLIERS[index]).div(100);output[i] < MULTIPLIER_BOUNDARIES[index];;;index ++;i ++;SlotsResult(_blockNumber,_target,_numSpins,_tokenValue,winAmount,lossAmount,output);(winAmount,lossAmount,jackpotAmount,jackpotWins,output);(winAmount,lossAmount,jackpotAmount,jackpotWins,output)"
./0x4159e265fdfa4e581e9b0b2988346ee7db4f0b7e_ext.sol,BANK_III_PFI_883.transferFrom,42,54,"REF_6(uint256) -> balanceOf[from],TMP_6(bool) = value <= REF_6,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_7(mapping(address => uint256)) -> allowance[from],REF_8(uint256) -> REF_7[msg.sender],TMP_8(bool) = value <= REF_8,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_9(uint256) -> balanceOf[from],REF_9(-> balanceOf) = REF_9 - value,REF_10(uint256) -> balanceOf[to],REF_10(-> balanceOf) = REF_10 + value,REF_11(mapping(address => uint256)) -> allowance[from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowance) = REF_12 - value,Emit Transfer(from,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(value <= balanceOf[from])

IRs:
REF_6(uint256) -> balanceOf[from]
TMP_6(bool) = value <= REF_6
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value <= allowance[from][msg.sender])

IRs:
REF_7(mapping(address => uint256)) -> allowance[from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_8(bool) = value <= REF_8
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[from] -= value

IRs:
REF_9(uint256) -> balanceOf[from]
REF_9(-> balanceOf) = REF_9 - value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[to] += value

IRs:
REF_10(uint256) -> balanceOf[to]
REF_10(-> balanceOf) = REF_10 + value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allowance[from][msg.sender] -= value

IRs:
REF_11(mapping(address => uint256)) -> allowance[from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowance) = REF_12 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(value <= balanceOf[from]);require(bool)(value <= allowance[from][msg.sender]);balanceOf[from] -= value;balanceOf[to] += value;allowance[from][msg.sender] -= value;Transfer(from,to,value);true;success"
./0x74028170d74751878228cda221fd0ac42a830921_ext.sol,TokenERC20.burnFrom,104,112,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xd532375971258953263218994966e2a0a3d5c18a_ext.sol,ZethrDividendCards._transfer,480,497,"REF_49(uint256) -> ownershipDivCardCount[_to],TMP_85(uint256) := REF_49(uint256),REF_49(-> ownershipDivCardCount) = REF_49 + 1,REF_50(address) -> divCardIndexToOwner[_divCardId],REF_50(address) (->divCardIndexToOwner) := _to(address),TMP_86 = CONVERT 0 to address,TMP_87(bool) = _from != TMP_86,CONDITION TMP_87,REF_51(uint256) -> ownershipDivCardCount[_from],TMP_88(uint256) := REF_51(uint256),REF_51(-> ownershipDivCardCount) = REF_51 - 1,REF_52(address) -> divCardIndexToApproved[_divCardId],divCardIndexToApproved = delete REF_52 ,Emit Transfer(_from,_to,_divCardId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownershipDivCardCount[_to] ++

IRs:
REF_49(uint256) -> ownershipDivCardCount[_to]
TMP_85(uint256) := REF_49(uint256)
REF_49(-> ownershipDivCardCount) = REF_49 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
divCardIndexToOwner[_divCardId] = _to

IRs:
REF_50(address) -> divCardIndexToOwner[_divCardId]
REF_50(address) (->divCardIndexToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_86 = CONVERT 0 to address
TMP_87(bool) = _from != TMP_86
CONDITION TMP_87""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownershipDivCardCount[_from] --

IRs:
REF_51(uint256) -> ownershipDivCardCount[_from]
TMP_88(uint256) := REF_51(uint256)
REF_51(-> ownershipDivCardCount) = REF_51 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete divCardIndexToApproved[_divCardId]

IRs:
REF_52(address) -> divCardIndexToApproved[_divCardId]
divCardIndexToApproved = delete REF_52 ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_divCardId)

IRs:
Emit Transfer(_from,_to,_divCardId)""];
}
",0,1,0,0,"ownershipDivCardCount[_to] ++;divCardIndexToOwner[_divCardId] = _to;_from != address(0);ownershipDivCardCount[_from] --;;delete divCardIndexToApproved[_divCardId];Transfer(_from,_to,_divCardId)"
./0x6ba2cdf1838f95c3cebc42c0b9b94a9d0173d555_ext.sol,Bointt._transfer,60,76,"TMP_7(bool) = _to != 0,TMP_8(None) = SOLIDITY_CALL require(bool)(TMP_7),REF_1(uint256) -> balanceOf[_from],TMP_9(bool) = REF_1 >= _value,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_2(uint256) -> balanceOf[_to],TMP_11(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_12(bool) = TMP_11 >= REF_3,TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_14(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_14(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_16(uint256) = REF_8 + REF_9,TMP_17(bool) = TMP_16 == previousBalances,TMP_18(None) = SOLIDITY_CALL assert(bool)(TMP_17)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_7(bool) = _to != 0
TMP_8(None) = SOLIDITY_CALL require(bool)(TMP_7)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_9(bool) = REF_1 >= _value
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_11(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_12(bool) = TMP_11 >= REF_3
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_14(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_14(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_16(uint256) = REF_8 + REF_9
TMP_17(bool) = TMP_16 == previousBalances
TMP_18(None) = SOLIDITY_CALL assert(bool)(TMP_17)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x013bf75820343cccc2cffda666bf4d5f7891e35c_ext.sol,NEWTOKEN.approveAndCall,46,54,"TMP_19 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_19(tokenRecipient),TMP_20(bool) = INTERNAL_CALL, NEWTOKEN.approve(address,uint256)(_spender,_value),CONDITION TMP_20,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_19 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_19(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_20(bool) = INTERNAL_CALL, NEWTOKEN.approve(address,uint256)(_spender,_value)
CONDITION TMP_20""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0xdc0c33a4c10dfdca03e583107eb5520555c86f9e_ext.sol,CryptoProfit.dividendsOf,173,175,"REF_34(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_63(uint256) = profitPerShare_ * REF_34,TMP_64 = CONVERT TMP_63 to int256,REF_35(int256) -> payoutsTo_[_customerAddress],TMP_65(int256) = TMP_64 - REF_35,TMP_66 = CONVERT TMP_65 to uint256,TMP_67(uint256) = TMP_66 / magnitude,RETURN TMP_67","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_34(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_63(uint256) = profitPerShare_ * REF_34
TMP_64 = CONVERT TMP_63 to int256
REF_35(int256) -> payoutsTo_[_customerAddress]
TMP_65(int256) = TMP_64 - REF_35
TMP_66 = CONVERT TMP_65 to uint256
TMP_67(uint256) = TMP_66 / magnitude
RETURN TMP_67""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0x83a611488d53cfcda749c2239c1516ab1c514fe7_ext.sol,PICC_301201.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0xf211128cc6d925a3a328647cf78b322b51429c53_ext.sol,F2m.getTotalVolume,680,686,"TMP_219(uint256) = totalBuyVolume + totalSellVolume,RETURN TMP_219","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
totalBuyVolume + totalSellVolume

IRs:
TMP_219(uint256) = totalBuyVolume + totalSellVolume
RETURN TMP_219""];
}
",0,1,0,0,totalBuyVolume + totalSellVolume
./0x18bbc8d1ec4ee0414e24eceed8b6a0e1b509b5c4_ext.sol,MetToken.list_active_holders_and_balances,872,891,"REF_154 -> LENGTH holders,len(uint256) := REF_154(uint256),_num_of_active_holders(uint256) := 0(uint256),TMP_278(bool) = _max_num_of_items_to_display == 0,CONDITION TMP_278,_max_num_of_items_to_display(uint256) := 1(uint256),TMP_279(uint256) = len - 1,i(uint256) := TMP_279(uint256),TMP_280(bool) = i >= 0,CONDITION TMP_280,REF_155(address) -> holders[i],REF_156(uint256) -> balances[REF_155],TMP_281(bool) = REF_156 != 0,CONDITION TMP_281,TMP_282(uint256) := _num_of_active_holders(uint256),_num_of_active_holders(uint256) = _num_of_active_holders + 1,TMP_283(bool) = _max_num_of_items_to_display == _num_of_active_holders,CONDITION TMP_283,TMP_284(uint256) := i(uint256),i(uint256) = i - 1,TMP_286(address[])  = new address[](_num_of_active_holders),_active_holders(address[]) = ['TMP_286(address[])'],TMP_288(uint256[])  = new uint256[](_num_of_active_holders),_token_balances(uint256[]) = ['TMP_288(uint256[])'],num(uint256) := 0(uint256),TMP_289(uint256) = len - 1,j(uint256) := TMP_289(uint256),TMP_290(bool) = j >= 0,TMP_291(bool) = _num_of_active_holders > num,TMP_292(bool) = TMP_290 && TMP_291,CONDITION TMP_292,REF_157(address) -> holders[j],addr(address) := REF_157(address),REF_158(uint256) -> balances[addr],TMP_293(bool) = REF_158 == 0,CONDITION TMP_293,REF_159(address) -> _active_holders[num],REF_159(address) (->_active_holders) := addr(address),REF_160(uint256) -> _token_balances[num],REF_161(uint256) -> balances[addr],REF_160(uint256) (->_token_balances) := REF_161(uint256),TMP_294(uint256) := num(uint256),num(uint256) = num + 1,TMP_295(uint256) := j(uint256),j(uint256) = j - 1,RETURN _num_of_active_holders,_active_holders,_token_balances","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
len = holders.length

IRs:
REF_154 -> LENGTH holders
len(uint256) := REF_154(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_num_of_active_holders = 0

IRs:
_num_of_active_holders(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_max_num_of_items_to_display == 0

IRs:
TMP_278(bool) = _max_num_of_items_to_display == 0
CONDITION TMP_278""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
_max_num_of_items_to_display = 1

IRs:
_max_num_of_items_to_display(uint256) := 1(uint256)""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->8;
6[label=""Node Type: BEGIN_LOOP 6
""];
6->9;
7[label=""Node Type: END_LOOP 7
""];
7->17;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
i = len - 1

IRs:
TMP_279(uint256) = len - 1
i(uint256) := TMP_279(uint256)""];
8->6;
9[label=""Node Type: IF_LOOP 9

EXPRESSION:
i >= 0

IRs:
TMP_280(bool) = i >= 0
CONDITION TMP_280""];
9->10[label=""True""];
9->7[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
balances[holders[i]] != 0x0

IRs:
REF_155(address) -> holders[i]
REF_156(uint256) -> balances[REF_155]
TMP_281(bool) = REF_156 != 0
CONDITION TMP_281""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
_num_of_active_holders ++

IRs:
TMP_282(uint256) := _num_of_active_holders(uint256)
_num_of_active_holders(uint256) = _num_of_active_holders + 1""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
_max_num_of_items_to_display == _num_of_active_holders

IRs:
TMP_283(bool) = _max_num_of_items_to_display == _num_of_active_holders
CONDITION TMP_283""];
13->14[label=""True""];
13->15[label=""False""];
14[label=""Node Type: BREAK 14
""];
14->7;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
i --

IRs:
TMP_284(uint256) := i(uint256)
i(uint256) = i - 1""];
16->9;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
_active_holders = new address[](_num_of_active_holders)

IRs:
TMP_286(address[])  = new address[](_num_of_active_holders)
_active_holders(address[]) = ['TMP_286(address[])']""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
_token_balances = new uint256[](_num_of_active_holders)

IRs:
TMP_288(uint256[])  = new uint256[](_num_of_active_holders)
_token_balances(uint256[]) = ['TMP_288(uint256[])']""];
18->19;
19[label=""Node Type: NEW VARIABLE 19

EXPRESSION:
num = 0

IRs:
num(uint256) := 0(uint256)""];
19->22;
20[label=""Node Type: BEGIN_LOOP 20
""];
20->23;
21[label=""Node Type: END_LOOP 21
""];
21->32;
22[label=""Node Type: NEW VARIABLE 22

EXPRESSION:
j = len - 1

IRs:
TMP_289(uint256) = len - 1
j(uint256) := TMP_289(uint256)""];
22->20;
23[label=""Node Type: IF_LOOP 23

EXPRESSION:
j >= 0 && _num_of_active_holders > num

IRs:
TMP_290(bool) = j >= 0
TMP_291(bool) = _num_of_active_holders > num
TMP_292(bool) = TMP_290 && TMP_291
CONDITION TMP_292""];
23->24[label=""True""];
23->21[label=""False""];
24[label=""Node Type: NEW VARIABLE 24

EXPRESSION:
addr = holders[j]

IRs:
REF_157(address) -> holders[j]
addr(address) := REF_157(address)""];
24->25;
25[label=""Node Type: IF 25

EXPRESSION:
balances[addr] == 0x0

IRs:
REF_158(uint256) -> balances[addr]
TMP_293(bool) = REF_158 == 0
CONDITION TMP_293""];
25->26[label=""True""];
25->27[label=""False""];
26[label=""Node Type: CONTINUE 26
""];
26->31;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
_active_holders[num] = addr

IRs:
REF_159(address) -> _active_holders[num]
REF_159(address) (->_active_holders) := addr(address)""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
_token_balances[num] = balances[addr]

IRs:
REF_160(uint256) -> _token_balances[num]
REF_161(uint256) -> balances[addr]
REF_160(uint256) (->_token_balances) := REF_161(uint256)""];
29->30;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
num ++

IRs:
TMP_294(uint256) := num(uint256)
num(uint256) = num + 1""];
30->31;
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
j --

IRs:
TMP_295(uint256) := j(uint256)
j(uint256) = j - 1""];
31->23;
32[label=""Node Type: RETURN 32

EXPRESSION:
(_num_of_active_holders,_active_holders,_token_balances)

IRs:
RETURN _num_of_active_holders,_active_holders,_token_balances""];
}
",0,1,0,0,"len = holders.length;_num_of_active_holders = 0;_max_num_of_items_to_display == 0;_max_num_of_items_to_display = 1;;i = len - 1;;i >= 0;;_active_holders = new address[](_num_of_active_holders);balances[holders[i]] != 0x0;_num_of_active_holders ++;;_max_num_of_items_to_display == _num_of_active_holders;;;i --;_token_balances = new uint256[](_num_of_active_holders);num = 0;j = len - 1;;j >= 0 && _num_of_active_holders > num;;(_num_of_active_holders,_active_holders,_token_balances);addr = holders[j];balances[addr] == 0x0;;;j --;_active_holders[num] = addr;_token_balances[num] = balances[addr];num ++"
./0x861a174d677946d8c2bea8f9636a53fde1668215_ext.sol,ExchangeRate.getRate,533,535,"TMP_173(bytes32) = SOLIDITY_CALL keccak256()(_symbol),REF_116(uint256) -> rates[TMP_173],RETURN REF_116","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
rates[keccak256()(_symbol)]

IRs:
TMP_173(bytes32) = SOLIDITY_CALL keccak256()(_symbol)
REF_116(uint256) -> rates[TMP_173]
RETURN REF_116""];
}
",0,1,0,0,rates[keccak256()(_symbol)]
./0x680ec9492d8372662dd439294bff2bd373e96309_ext.sol,MyEtherHODL.partyTo,134,162,"REF_38(uint256) -> balanceOf[hodler],value(uint256) := REF_38(uint256),TMP_32(bool) = value > 0,TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32),REF_39(uint256) -> balanceOf[hodler],REF_39(uint256) (->balanceOf) := 0(uint256),REF_40(uint256) -> lockedUntil[hodler],TMP_34(bool) = now < REF_40,CONDITION TMP_34,TMP_35(bool) = msg.sender == hodler,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),TMP_37(uint256) = value * 10,TMP_38(uint256) = TMP_37 / 100,fee(uint256) := TMP_38(uint256),Transfer dest:owner value:fee,value(uint256) = value - fee,REF_42(uint256) -> lockedUntil[hodler],TMP_40(uint256) = REF_42 - now,Emit Fee(hodler,fee,TMP_40),Transfer dest:hodler value:value,REF_44(uint256) -> lockedFor[hodler],Emit Party(hodler,value,REF_44),REF_45(uint256) -> indexOfHodler[hodler],index(uint256) := REF_45(uint256),TMP_44(bool) = index > 0,TMP_45(None) = SOLIDITY_CALL require(bool)(TMP_44),TMP_46(uint256) = index + 1,REF_46 -> LENGTH hodlers,TMP_47(bool) = TMP_46 < REF_46,CONDITION TMP_47,TMP_48(uint256) = index - 1,REF_47(address) -> hodlers[TMP_48],REF_48 -> LENGTH hodlers,TMP_49(uint256) = REF_48 - 1,REF_49(address) -> hodlers[TMP_49],REF_47(address) (->hodlers) := REF_49(address),TMP_50(uint256) = index - 1,REF_50(address) -> hodlers[TMP_50],REF_51(uint256) -> indexOfHodler[REF_50],REF_51(uint256) (->indexOfHodler) := index(uint256),REF_52 -> LENGTH hodlers,TMP_51(uint256) := REF_52(uint256),REF_52(-> hodlers) = REF_52 - 1,REF_53(uint256) -> balanceOf[hodler],balanceOf = delete REF_53 ,REF_54(uint256) -> lockedUntil[hodler],lockedUntil = delete REF_54 ,REF_55(uint256) -> lockedFor[hodler],lockedFor = delete REF_55 ,REF_56(uint256) -> indexOfHodler[hodler],indexOfHodler = delete REF_56 ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
value = balanceOf[hodler]

IRs:
REF_38(uint256) -> balanceOf[hodler]
value(uint256) := REF_38(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value > 0)

IRs:
TMP_32(bool) = value > 0
TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[hodler] = 0

IRs:
REF_39(uint256) -> balanceOf[hodler]
REF_39(uint256) (->balanceOf) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
now < lockedUntil[hodler]

IRs:
REF_40(uint256) -> lockedUntil[hodler]
TMP_34(bool) = now < REF_40
CONDITION TMP_34""];
4->5[label=""True""];
4->10[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(msg.sender == hodler)

IRs:
TMP_35(bool) = msg.sender == hodler
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
fee = value * 10 / 100

IRs:
TMP_37(uint256) = value * 10
TMP_38(uint256) = TMP_37 / 100
fee(uint256) := TMP_38(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
owner.transfer(fee)

IRs:
Transfer dest:owner value:fee""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
value -= fee

IRs:
value(uint256) = value - fee""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
Fee(hodler,fee,lockedUntil[hodler] - now)

IRs:
REF_42(uint256) -> lockedUntil[hodler]
TMP_40(uint256) = REF_42 - now
Emit Fee(hodler,fee,TMP_40)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
hodler.transfer(value)

IRs:
Transfer dest:hodler value:value""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
Party(hodler,value,lockedFor[hodler])

IRs:
REF_44(uint256) -> lockedFor[hodler]
Emit Party(hodler,value,REF_44)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
index = indexOfHodler[hodler]

IRs:
REF_45(uint256) -> indexOfHodler[hodler]
index(uint256) := REF_45(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
require(bool)(index > 0)

IRs:
TMP_44(bool) = index > 0
TMP_45(None) = SOLIDITY_CALL require(bool)(TMP_44)""];
14->15;
15[label=""Node Type: IF 15

EXPRESSION:
index + 1 < hodlers.length

IRs:
TMP_46(uint256) = index + 1
REF_46 -> LENGTH hodlers
TMP_47(bool) = TMP_46 < REF_46
CONDITION TMP_47""];
15->16[label=""True""];
15->18[label=""False""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
hodlers[index - 1] = hodlers[hodlers.length - 1]

IRs:
TMP_48(uint256) = index - 1
REF_47(address) -> hodlers[TMP_48]
REF_48 -> LENGTH hodlers
TMP_49(uint256) = REF_48 - 1
REF_49(address) -> hodlers[TMP_49]
REF_47(address) (->hodlers) := REF_49(address)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
indexOfHodler[hodlers[index - 1]] = index

IRs:
TMP_50(uint256) = index - 1
REF_50(address) -> hodlers[TMP_50]
REF_51(uint256) -> indexOfHodler[REF_50]
REF_51(uint256) (->indexOfHodler) := index(uint256)""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
hodlers.length --

IRs:
REF_52 -> LENGTH hodlers
TMP_51(uint256) := REF_52(uint256)
REF_52(-> hodlers) = REF_52 - 1""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
delete balanceOf[hodler]

IRs:
REF_53(uint256) -> balanceOf[hodler]
balanceOf = delete REF_53 ""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
delete lockedUntil[hodler]

IRs:
REF_54(uint256) -> lockedUntil[hodler]
lockedUntil = delete REF_54 ""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
delete lockedFor[hodler]

IRs:
REF_55(uint256) -> lockedFor[hodler]
lockedFor = delete REF_55 ""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
delete indexOfHodler[hodler]

IRs:
REF_56(uint256) -> indexOfHodler[hodler]
indexOfHodler = delete REF_56 ""];
}
",0,1,1,0,"value = balanceOf[hodler];require(bool)(value > 0);balanceOf[hodler] = 0;now < lockedUntil[hodler];require(bool)(msg.sender == hodler);;fee = value * 10 / 100;owner.transfer(fee);value -= fee;Fee(hodler,fee,lockedUntil[hodler] - now);hodler.transfer(value);Party(hodler,value,lockedFor[hodler]);index = indexOfHodler[hodler];require(bool)(index > 0);index + 1 < hodlers.length;hodlers[index - 1] = hodlers[hodlers.length - 1];;indexOfHodler[hodlers[index - 1]] = index;hodlers.length --;delete balanceOf[hodler];delete lockedUntil[hodler];delete lockedFor[hodler];delete indexOfHodler[hodler]"
./0x5a086708501251d2c948d767a88379f0b8d8c300_ext.sol,WeduToken.tokenBurn,346,355,"REF_137(WeduToken.BalanceType) -> balanceValue[owner],REF_138(uint256) -> REF_137.unlocked,TMP_132(bool) = _value <= REF_138,TMP_133(None) = SOLIDITY_CALL require(bool,string)(TMP_132,Unsufficient balance),oldTokenNum(uint256) := totalSupplyValue(uint256),totalSupplyValue(uint256) = totalSupplyValue - _value,REF_139(WeduToken.BalanceType) -> balanceValue[owner],REF_140(uint256) -> REF_139.unlocked,REF_140(-> balanceValue) = REF_140 - _value,Emit ChangeNumberofToken(oldTokenNum,totalSupplyValue),RETURN True,MODIFIER_CALL, WeduToken.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(_value <= balanceValue[owner].unlocked,Unsufficient balance)

IRs:
REF_137(WeduToken.BalanceType) -> balanceValue[owner]
REF_138(uint256) -> REF_137.unlocked
TMP_132(bool) = _value <= REF_138
TMP_133(None) = SOLIDITY_CALL require(bool,string)(TMP_132,Unsufficient balance)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
oldTokenNum = totalSupplyValue

IRs:
oldTokenNum(uint256) := totalSupplyValue(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupplyValue -= _value

IRs:
totalSupplyValue(uint256) = totalSupplyValue - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceValue[owner].unlocked -= _value

IRs:
REF_139(WeduToken.BalanceType) -> balanceValue[owner]
REF_140(uint256) -> REF_139.unlocked
REF_140(-> balanceValue) = REF_140 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
ChangeNumberofToken(oldTokenNum,totalSupplyValue)

IRs:
Emit ChangeNumberofToken(oldTokenNum,totalSupplyValue)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, WeduToken.onlyOwner()()""];
7->1;
}
",0,1,0,0,"onlyOwner();require(bool,string)(_value <= balanceValue[owner].unlocked,Unsufficient balance);oldTokenNum = totalSupplyValue;totalSupplyValue -= _value;balanceValue[owner].unlocked -= _value;ChangeNumberofToken(oldTokenNum,totalSupplyValue);true"
./0xaf6dbf545cc245c00b425d02e545b6ecc1527f3d_ext.sol,LSCKcoin.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.ownerUpdateOthers,2,2,"maxSignup(uint256) := _maxno(uint256),contractbacklist(bool) := _isBacklisted(bool),mineth(uint256) := _min_eth(uint256),minsignupeth(uint256) := _minsignupeth(uint256),paidversion(bool) := _paidversion(bool),MODIFIER_CALL, KahnDistributionCentre.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
maxSignup = _maxno

IRs:
maxSignup(uint256) := _maxno(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
contractbacklist = _isBacklisted

IRs:
contractbacklist(bool) := _isBacklisted(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
mineth = _min_eth

IRs:
mineth(uint256) := _min_eth(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
minsignupeth = _minsignupeth

IRs:
minsignupeth(uint256) := _minsignupeth(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
paidversion = _paidversion

IRs:
paidversion(bool) := _paidversion(bool)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyOwner()()""];
6->1;
}
",0,1,1,0,onlyOwner();maxSignup = _maxno;contractbacklist = _isBacklisted;mineth = _min_eth;minsignupeth = _minsignupeth;paidversion = _paidversion
./0x73307e983f8843d3e09d320dd4c35cf2783f71f6_ext.sol,CDonToken.totalSupply,120,122,"TMP_32 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_32],TMP_33(uint256) = _totalSupply - REF_1,RETURN TMP_33","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_32 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_32]
TMP_33(uint256) = _totalSupply - REF_1
RETURN TMP_33""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x1e200a9af1ab6a0d74cd44c489bf65744bc7d961_ext.sol,BountyBG.createBounty,114,128,"TMP_34(uint256) = minBounty + bountyFee,TMP_35(bool) = msg.value >= TMP_34,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),REF_28(BountyBG.Bounty) -> bountyAt[_bountyId],bounty(BountyBG.Bounty) := REF_28(BountyBG.Bounty),REF_29(uint256) -> bounty.id,TMP_37(bool) = REF_29 == 0,TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37),TMP_39(uint256) := bountyCount(uint256),bountyCount(uint256) = bountyCount + 1,REF_30(uint256) -> bounty.id,REF_30(uint256) (->bounty) := _bountyId(uint256),REF_31(uint256) -> bounty.bounty,TMP_40(uint256) = msg.value - bountyFee,REF_31(uint256) (->bounty) := TMP_40(uint256),REF_32(uint256) -> bounty.remainingBounty,REF_33(uint256) -> bounty.bounty,REF_32(uint256) (->bounty) := REF_33(uint256),bountyFeeCount(uint256) = bountyFeeCount + bountyFee,REF_34(uint256) -> bounty.startTime,REF_34(uint256) (->bounty) := block.timestamp(uint256),REF_35(address) -> bounty.owner,REF_35(address) (->bounty) := msg.sender(address),REF_36(uint256) -> bounty.id,Emit BountyStatus(Bounty submitted,REF_36,msg.sender,msg.value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= minBounty + bountyFee)

IRs:
TMP_34(uint256) = minBounty + bountyFee
TMP_35(bool) = msg.value >= TMP_34
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bounty = bountyAt[_bountyId]

IRs:
REF_28(BountyBG.Bounty) -> bountyAt[_bountyId]
bounty(BountyBG.Bounty) := REF_28(BountyBG.Bounty)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(bounty.id == 0)

IRs:
REF_29(uint256) -> bounty.id
TMP_37(bool) = REF_29 == 0
TMP_38(None) = SOLIDITY_CALL require(bool)(TMP_37)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
bountyCount ++

IRs:
TMP_39(uint256) := bountyCount(uint256)
bountyCount(uint256) = bountyCount + 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
bounty.id = _bountyId

IRs:
REF_30(uint256) -> bounty.id
REF_30(uint256) (->bounty) := _bountyId(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
bounty.bounty = msg.value - bountyFee

IRs:
REF_31(uint256) -> bounty.bounty
TMP_40(uint256) = msg.value - bountyFee
REF_31(uint256) (->bounty) := TMP_40(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
bounty.remainingBounty = bounty.bounty

IRs:
REF_32(uint256) -> bounty.remainingBounty
REF_33(uint256) -> bounty.bounty
REF_32(uint256) (->bounty) := REF_33(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
bountyFeeCount += bountyFee

IRs:
bountyFeeCount(uint256) = bountyFeeCount + bountyFee""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
bounty.startTime = block.timestamp

IRs:
REF_34(uint256) -> bounty.startTime
REF_34(uint256) (->bounty) := block.timestamp(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
bounty.owner = msg.sender

IRs:
REF_35(address) -> bounty.owner
REF_35(address) (->bounty) := msg.sender(address)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
BountyStatus(Bounty submitted,bounty.id,msg.sender,msg.value)

IRs:
REF_36(uint256) -> bounty.id
Emit BountyStatus(Bounty submitted,REF_36,msg.sender,msg.value)""];
}
",0,1,0,0,"require(bool)(msg.value >= minBounty + bountyFee);bounty = bountyAt[_bountyId];require(bool)(bounty.id == 0);bountyCount ++;bounty.id = _bountyId;bounty.bounty = msg.value - bountyFee;bounty.remainingBounty = bounty.bounty;bountyFeeCount += bountyFee;bounty.startTime = block.timestamp;bounty.owner = msg.sender;BountyStatus(Bounty submitted,bounty.id,msg.sender,msg.value)"
./0xb39b66a7273b83bca1f2f618672302485b391f92_ext.sol,ANHUI_ANNUITY_DAO_33_c.transferFrom,42,54,"REF_6(uint256) -> balanceOf[from],TMP_6(bool) = value <= REF_6,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_7(mapping(address => uint256)) -> allowance[from],REF_8(uint256) -> REF_7[msg.sender],TMP_8(bool) = value <= REF_8,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_9(uint256) -> balanceOf[from],REF_9(-> balanceOf) = REF_9 - value,REF_10(uint256) -> balanceOf[to],REF_10(-> balanceOf) = REF_10 + value,REF_11(mapping(address => uint256)) -> allowance[from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowance) = REF_12 - value,Emit Transfer(from,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(value <= balanceOf[from])

IRs:
REF_6(uint256) -> balanceOf[from]
TMP_6(bool) = value <= REF_6
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value <= allowance[from][msg.sender])

IRs:
REF_7(mapping(address => uint256)) -> allowance[from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_8(bool) = value <= REF_8
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[from] -= value

IRs:
REF_9(uint256) -> balanceOf[from]
REF_9(-> balanceOf) = REF_9 - value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[to] += value

IRs:
REF_10(uint256) -> balanceOf[to]
REF_10(-> balanceOf) = REF_10 + value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allowance[from][msg.sender] -= value

IRs:
REF_11(mapping(address => uint256)) -> allowance[from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowance) = REF_12 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(value <= balanceOf[from]);require(bool)(value <= allowance[from][msg.sender]);balanceOf[from] -= value;balanceOf[to] += value;allowance[from][msg.sender] -= value;Transfer(from,to,value);true;success"
./0x01a922de9af2c1158dd947ea5b794f0dd995c7df_ext.sol,TokenERC20.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xd97579cea3fe2473682a4c42648134bb982433b9_ext.sol,LightCoinToken.transfer,38,45,"TMP_3(bool) = _value > 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_3(uint256) -> balances[msg.sender],TMP_5(bool) = REF_3 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_4(uint256) -> balances[msg.sender],REF_4(-> balances) = REF_4 - _value,REF_5(uint256) -> balances[_to],REF_5(-> balances) = REF_5 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_3(bool) = _value > 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_3(uint256) -> balances[msg.sender]
TMP_5(bool) = REF_3 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_4(uint256) -> balances[msg.sender]
REF_4(-> balances) = REF_4 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] += _value

IRs:
REF_5(uint256) -> balances[_to]
REF_5(-> balances) = REF_5 + _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(_value > 0);require(bool)(balances[msg.sender] >= _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0xdd5b1e55fd47c039e0d72cc96a216b828cd8f498_ext.sol,BeeBitGold.totalSupply,170,172,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0xb3ccb987036d9e93ea895aa78378e137f72a5e84_ext.sol,TokenERC20.burnFrom,126,134,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x17f93475d2a978f527c3f7c44abf44adfba60d5c_ext.sol,EtherCO2.mint,59,67,"TMP_17(bool) = amount > 0,CONDITION TMP_17,totalSupply(uint256) = totalSupply + amount,REF_16(uint256) -> balances[owner],REF_16(-> balances) = REF_16 + amount,Emit Mint(msg.sender,amount),RETURN True,RETURN False,MODIFIER_CALL, EtherCO2.onlyOwner()(),RETURN minted","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: IF 1

EXPRESSION:
amount > 0

IRs:
TMP_17(bool) = amount > 0
CONDITION TMP_17""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += amount

IRs:
totalSupply(uint256) = totalSupply + amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[owner] += amount

IRs:
REF_16(uint256) -> balances[owner]
REF_16(-> balances) = REF_16 + amount""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Mint(msg.sender,amount)

IRs:
Emit Mint(msg.sender,amount)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, EtherCO2.onlyOwner()()""];
8->1;
9[label=""Node Type: RETURN 9

EXPRESSION:
minted

IRs:
RETURN minted""];
}
",0,1,0,0,"onlyOwner();amount > 0;totalSupply += amount;;balances[owner] += amount;Mint(msg.sender,amount);true;false;minted"
./0x32d55157bd2ae652f4b6be48ee4a7a1686d28a3f_ext.sol,MyAdvancedToken.mintToken,208,213,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x572154643036f421e1f3c054eb9cfa36dd9de4b2_ext.sol,SFI._transfer,38,54,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0xdef5dce5781220efda3f5235cc6e5dd5a08e22bd_ext.sol,TokenERC20.burnFrom,104,112,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x4d6ec066345e3466d9e970caad4732983ae4bc2c_ext.sol,NicknameRegistrar.addresses,99,101,"TMP_31(bytes32) = INTERNAL_CALL, NicknameRegistrar.stringToBytes32(string)(name),REF_6(address) -> _addresses[TMP_31],RETURN REF_6","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_addresses[stringToBytes32(name)]

IRs:
TMP_31(bytes32) = INTERNAL_CALL, NicknameRegistrar.stringToBytes32(string)(name)
REF_6(address) -> _addresses[TMP_31]
RETURN REF_6""];
}
",0,1,0,0,_addresses[stringToBytes32(name)]
./0xdcb6622cb14e44213092a986d5654ad599e7ebfe_ext.sol,NOWToken.transferFrom,80,90,"TMP_40 = CONVERT 0 to address,TMP_41(bool) = _to != TMP_40,TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41),REF_41(uint256) -> balances[_from],TMP_43(bool) = _value <= REF_41,TMP_44(None) = SOLIDITY_CALL require(bool)(TMP_43),REF_42(mapping(address => uint256)) -> allowed[_from],REF_43(uint256) -> REF_42[msg.sender],TMP_45(bool) = _value <= REF_43,TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45),REF_44(uint256) -> balances[_from],REF_44(-> balances) = REF_44 - _value,REF_45(uint256) -> balances[_to],REF_45(-> balances) = REF_45 + _value,REF_46(mapping(address => uint256)) -> allowed[_from],REF_47(uint256) -> REF_46[msg.sender],REF_47(-> allowed) = REF_47 - _value,Emit Transfer(_from,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_40 = CONVERT 0 to address
TMP_41(bool) = _to != TMP_40
TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= balances[_from])

IRs:
REF_41(uint256) -> balances[_from]
TMP_43(bool) = _value <= REF_41
TMP_44(None) = SOLIDITY_CALL require(bool)(TMP_43)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_value <= allowed[_from][msg.sender])

IRs:
REF_42(mapping(address => uint256)) -> allowed[_from]
REF_43(uint256) -> REF_42[msg.sender]
TMP_45(bool) = _value <= REF_43
TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_from] -= _value

IRs:
REF_44(uint256) -> balances[_from]
REF_44(-> balances) = REF_44 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[_to] += _value

IRs:
REF_45(uint256) -> balances[_to]
REF_45(-> balances) = REF_45 + _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_46(mapping(address => uint256)) -> allowed[_from]
REF_47(uint256) -> REF_46[msg.sender]
REF_47(-> allowed) = REF_47 - _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: RETURN 8

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(_to != address(0));require(bool)(_value <= balances[_from]);require(bool)(_value <= allowed[_from][msg.sender]);balances[_from] -= _value;balances[_to] += _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true"
./0x582b2489710a4189ad558b6958641789587fcc27_ext.sol,PonziUnlimited.deposit,180,195,"TMP_10(bool) = msg.value <= 0,CONDITION TMP_10,lastDeposit(uint256) := block.timestamp(uint256),REF_19(PonziUnlimited.Deposit) -> depositsStack[numDeposits],TMP_11(PonziUnlimited.Deposit) = new Deposit(msg.sender,msg.value),REF_19(PonziUnlimited.Deposit) (->depositsStack) := TMP_11(PonziUnlimited.Deposit),totalDeposited(uint256) = totalDeposited + msg.value,INTERNAL_CALL, PonziUnlimited.checkIfReferee(address)(msg.sender),Emit FundsDeposited(msg.sender,msg.value),numDeposits(uint256) = numDeposits + 1,REF_20(uint256[]) -> addressPositions[msg.sender],REF_22 -> LENGTH REF_20,TMP_15(uint256) := REF_22(uint256),TMP_16(uint256) = TMP_15 + 1,REF_22(uint256) (->addressPositions) := TMP_16(uint256),REF_23(uint256) -> REF_20[TMP_15],REF_23(uint256) (->addressPositions) := numDeposits(uint256),CONDITION active,INTERNAL_CALL, PonziUnlimited.dispatchGains()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value <= 0

IRs:
TMP_10(bool) = msg.value <= 0
CONDITION TMP_10""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
lastDeposit = block.timestamp

IRs:
lastDeposit(uint256) := block.timestamp(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
depositsStack[numDeposits] = Deposit(msg.sender,msg.value)

IRs:
REF_19(PonziUnlimited.Deposit) -> depositsStack[numDeposits]
TMP_11(PonziUnlimited.Deposit) = new Deposit(msg.sender,msg.value)
REF_19(PonziUnlimited.Deposit) (->depositsStack) := TMP_11(PonziUnlimited.Deposit)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
totalDeposited += msg.value

IRs:
totalDeposited(uint256) = totalDeposited + msg.value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
checkIfReferee(msg.sender)

IRs:
INTERNAL_CALL, PonziUnlimited.checkIfReferee(address)(msg.sender)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
FundsDeposited(msg.sender,msg.value)

IRs:
Emit FundsDeposited(msg.sender,msg.value)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
++ numDeposits

IRs:
numDeposits(uint256) = numDeposits + 1""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
addressPositions[msg.sender].push(numDeposits)

IRs:
REF_20(uint256[]) -> addressPositions[msg.sender]
REF_22 -> LENGTH REF_20
TMP_15(uint256) := REF_22(uint256)
TMP_16(uint256) = TMP_15 + 1
REF_22(uint256) (->addressPositions) := TMP_16(uint256)
REF_23(uint256) -> REF_20[TMP_15]
REF_23(uint256) (->addressPositions) := numDeposits(uint256)""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
active

IRs:
CONDITION active""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
dispatchGains()

IRs:
INTERNAL_CALL, PonziUnlimited.dispatchGains()()""];
12->13;
13[label=""Node Type: END_IF 13
""];
}
",0,1,0,0,"msg.value <= 0;;;lastDeposit = block.timestamp;depositsStack[numDeposits] = Deposit(msg.sender,msg.value);totalDeposited += msg.value;checkIfReferee(msg.sender);FundsDeposited(msg.sender,msg.value);++ numDeposits;addressPositions[msg.sender].push(numDeposits);active;dispatchGains();"
./0x54f61b89a0bac15c88c6bddf41573ddc1ba5bf6d_ext.sol,LEF.transfer,58,64,"REF_8(bool) -> frozenAccount[msg.sender],TMP_18 = UnaryType.BANG REF_8 ,TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18),REF_9(uint256) = SOLIDITY_CALL balance(address)(msg.sender),TMP_20(bool) = REF_9 < minBalanceForAccounts,CONDITION TMP_20,REF_10(uint256) = SOLIDITY_CALL balance(address)(msg.sender),TMP_21(uint256) = minBalanceForAccounts - REF_10,TMP_22(uint256) = TMP_21 / sellPrice,TMP_23(uint256) = INTERNAL_CALL, LEF.sell(uint256)(TMP_22),INTERNAL_CALL, LEF._transfer(address,address,uint256)(msg.sender,_to,_value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! frozenAccount[msg.sender])

IRs:
REF_8(bool) -> frozenAccount[msg.sender]
TMP_18 = UnaryType.BANG REF_8 
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
msg.sender.balance < minBalanceForAccounts

IRs:
REF_9(uint256) = SOLIDITY_CALL balance(address)(msg.sender)
TMP_20(bool) = REF_9 < minBalanceForAccounts
CONDITION TMP_20""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
sell((minBalanceForAccounts - msg.sender.balance) / sellPrice)

IRs:
REF_10(uint256) = SOLIDITY_CALL balance(address)(msg.sender)
TMP_21(uint256) = minBalanceForAccounts - REF_10
TMP_22(uint256) = TMP_21 / sellPrice
TMP_23(uint256) = INTERNAL_CALL, LEF.sell(uint256)(TMP_22)""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_transfer(msg.sender,_to,_value)

IRs:
INTERNAL_CALL, LEF._transfer(address,address,uint256)(msg.sender,_to,_value)""];
}
",0,1,0,0,"require(bool)(! frozenAccount[msg.sender]);msg.sender.balance < minBalanceForAccounts;sell((minBalanceForAccounts - msg.sender.balance) / sellPrice);;_transfer(msg.sender,_to,_value)"
./0xa48bb4d1baff077e9c45dab5d70db59537e8ab79_ext.sol,Queue.getQueueLength,220,222,"REF_25 -> LENGTH queue,TMP_45(uint256) = REF_25 - currentReceiverIndex,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
queue.length - currentReceiverIndex

IRs:
REF_25 -> LENGTH queue
TMP_45(uint256) = REF_25 - currentReceiverIndex
RETURN TMP_45""];
}
",0,1,0,0,queue.length - currentReceiverIndex
./0xf64196754b5548eef6bfcc434465c0d218309914_ext.sol,RegularToken.transferFrom,90,109,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x37e3efe76ee6cec50559bc07565eaf36ddc05467_ext.sol,ControlledToken.transferFrom,121,138,"REF_5(mapping(address => uint256)) -> allowed[_from],REF_6(uint256) -> REF_5[msg.sender],allowance(uint256) := REF_6(uint256),REF_7(uint256) -> balances[_from],TMP_11(bool) = REF_7 >= _value,TMP_12(bool) = allowance >= _value,TMP_13(bool) = TMP_11 && TMP_12,TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13),TMP_15(bool) = INTERNAL_CALL, ControlledToken.isContract(address)(controller),CONDITION TMP_15,TMP_16 = CONVERT controller to TokenController,TMP_17(bool) = HIGH_LEVEL_CALL, dest:TMP_16(TokenController), function:onTransfer, arguments:['_from', '_to', '_value']  ,TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17),REF_9(uint256) -> balances[_to],REF_9(-> balances) = REF_9 + _value,REF_10(uint256) -> balances[_from],REF_10(-> balances) = REF_10 - _value,TMP_19(bool) = allowance < MAX_UINT256,CONDITION TMP_19,REF_11(mapping(address => uint256)) -> allowed[_from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowed) = REF_12 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
allowance = allowed[_from][msg.sender]

IRs:
REF_5(mapping(address => uint256)) -> allowed[_from]
REF_6(uint256) -> REF_5[msg.sender]
allowance(uint256) := REF_6(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[_from] >= _value && allowance >= _value)

IRs:
REF_7(uint256) -> balances[_from]
TMP_11(bool) = REF_7 >= _value
TMP_12(bool) = allowance >= _value
TMP_13(bool) = TMP_11 && TMP_12
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
isContract(controller)

IRs:
TMP_15(bool) = INTERNAL_CALL, ControlledToken.isContract(address)(controller)
CONDITION TMP_15""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(TokenController(controller).onTransfer(_from,_to,_value))

IRs:
TMP_16 = CONVERT controller to TokenController
TMP_17(bool) = HIGH_LEVEL_CALL, dest:TMP_16(TokenController), function:onTransfer, arguments:['_from', '_to', '_value']  
TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17)""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[_to] += _value

IRs:
REF_9(uint256) -> balances[_to]
REF_9(-> balances) = REF_9 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[_from] -= _value

IRs:
REF_10(uint256) -> balances[_from]
REF_10(-> balances) = REF_10 - _value""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
allowance < MAX_UINT256

IRs:
TMP_19(bool) = allowance < MAX_UINT256
CONDITION TMP_19""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_11(mapping(address => uint256)) -> allowed[_from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowed) = REF_12 - _value""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
11->12;
12[label=""Node Type: RETURN 12

EXPRESSION:
true

IRs:
RETURN True""];
13[label=""Node Type: RETURN 13

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowance = allowed[_from][msg.sender];require(bool)(balances[_from] >= _value && allowance >= _value);isContract(controller);require(bool)(TokenController(controller).onTransfer(_from,_to,_value));;balances[_to] += _value;balances[_from] -= _value;allowance < MAX_UINT256;allowed[_from][msg.sender] -= _value;;Transfer(_from,_to,_value);true;success"
./0x1db45a09efcdd8955b1c3bb855b5a8d333446bff_ext.sol,Share.bonus,105,107,"REF_1(uint256) -> fullfilled[msg.sender],TMP_10(uint256) = watermark - REF_1,REF_2(uint256) -> holds[msg.sender],TMP_11(uint256) = TMP_10 * REF_2,RETURN TMP_11","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
(watermark - fullfilled[msg.sender]) * holds[msg.sender]

IRs:
REF_1(uint256) -> fullfilled[msg.sender]
TMP_10(uint256) = watermark - REF_1
REF_2(uint256) -> holds[msg.sender]
TMP_11(uint256) = TMP_10 * REF_2
RETURN TMP_11""];
}
",0,1,0,0,(watermark - fullfilled[msg.sender]) * holds[msg.sender]
./0x2a46885f8e02ce11dd21209f3cbc3e91561cfc8a_ext.sol,TMToken.burnFrom,71,79,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xe3147bc1046fab87292e1b743c1e657b37262496_ext.sol,SafeMath.add,29,33,"TMP_10(uint256) = a + b,c(uint256) := TMP_10(uint256),TMP_11(bool) = c >= a,TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11),RETURN c","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_10(uint256) = a + b
c(uint256) := TMP_10(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_11(bool) = c >= a
TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c""];
}
",0,1,0,0,c = a + b;assert(bool)(c >= a);c
./0xa29e71cb2e30e8af956d64b025b88a5ca3d7ecd2_ext.sol,StandardToken.transfer,45,56,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x6cb9c98e8e6ab46790b088d29a881008675c23eb_ext.sol,TokenERC20.burn,124,130,"REF_17(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_17 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_17 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x4b3b99e956588b54f5841f2fb7c63721e6c7c392_ext.sol,CHOAM.buy_spice_melange,328,345,"TMP_118(bool) = msg.sender == tx.origin,TMP_119(None) = SOLIDITY_CALL require(bool)(TMP_118),TMP_120 = CONVERT 0 to address,TMP_121(bool) = msg.sender != TMP_120,TMP_122(None) = SOLIDITY_CALL require(bool)(TMP_121),TMP_123 = CONVERT this to address,TMP_124(bool) = msg.sender != TMP_123,TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124),TMP_126(bool) = msg.value > 0,TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126),REF_77(CHOAM.Player) -> players[msg.sender],REF_78(uint8) -> REF_77.state,TMP_128(bool) = REF_78 == 0,REF_79 -> LENGTH nodes,TMP_129(bool) = REF_79 > 0,TMP_130(bool) = TMP_128 && TMP_129,CONDITION TMP_130,TMP_131(uint256) = SOLIDITY_CALL blockhash(uint256)(11),TMP_132 = CONVERT TMP_131 to uint256,TMP_133 = CONVERT msg.sender to uint256,TMP_134(uint256) = TMP_132 + TMP_133,REF_81 -> LENGTH nodes,TMP_135 = CONVERT REF_81 to uint256,TMP_136(uint256) = TMP_134 + TMP_135,TMP_137(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_136),TMP_138(bytes32) = SOLIDITY_CALL keccak256()(TMP_137),hash(bytes32) := TMP_138(bytes32),REF_82(CHOAM.Player) -> players[msg.sender],REF_83(uint256) -> REF_82.position,TMP_139 = CONVERT hash to uint256,REF_84 -> LENGTH nodes,TMP_140(uint256) = TMP_139 % REF_84,REF_83(uint256) (->players) := TMP_140(uint256),REF_85(CHOAM.Player) -> players[msg.sender],REF_86(uint8) -> REF_85.state,REF_86(uint8) (->players) := 1(uint256),REF_87(CHOAM.Player) -> players[msg.sender],REF_88(uint256) -> REF_87.balance,REF_89(CHOAM.Player) -> players[msg.sender],REF_90(uint256) -> REF_89.balance,TMP_141(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_90', 'msg.value'] ,REF_88(uint256) (->players) := TMP_141(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_118(bool) = msg.sender == tx.origin
TMP_119(None) = SOLIDITY_CALL require(bool)(TMP_118)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender != address(0))

IRs:
TMP_120 = CONVERT 0 to address
TMP_121(bool) = msg.sender != TMP_120
TMP_122(None) = SOLIDITY_CALL require(bool)(TMP_121)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(msg.sender != address(this))

IRs:
TMP_123 = CONVERT this to address
TMP_124(bool) = msg.sender != TMP_123
TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(msg.value > 0)

IRs:
TMP_126(bool) = msg.value > 0
TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
players[msg.sender].state == 0 && nodes.length > 0

IRs:
REF_77(CHOAM.Player) -> players[msg.sender]
REF_78(uint8) -> REF_77.state
TMP_128(bool) = REF_78 == 0
REF_79 -> LENGTH nodes
TMP_129(bool) = REF_79 > 0
TMP_130(bool) = TMP_128 && TMP_129
CONDITION TMP_130""];
5->6[label=""True""];
5->9[label=""False""];
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
hash = keccak256()(abi.encodePacked(uint256(blockhash(uint256)(11)) + uint256(msg.sender) + uint256(nodes.length)))

IRs:
TMP_131(uint256) = SOLIDITY_CALL blockhash(uint256)(11)
TMP_132 = CONVERT TMP_131 to uint256
TMP_133 = CONVERT msg.sender to uint256
TMP_134(uint256) = TMP_132 + TMP_133
REF_81 -> LENGTH nodes
TMP_135 = CONVERT REF_81 to uint256
TMP_136(uint256) = TMP_134 + TMP_135
TMP_137(bytes) = SOLIDITY_CALL abi.encodePacked()(TMP_136)
TMP_138(bytes32) = SOLIDITY_CALL keccak256()(TMP_137)
hash(bytes32) := TMP_138(bytes32)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
players[msg.sender].position = uint256(hash) % nodes.length

IRs:
REF_82(CHOAM.Player) -> players[msg.sender]
REF_83(uint256) -> REF_82.position
TMP_139 = CONVERT hash to uint256
REF_84 -> LENGTH nodes
TMP_140(uint256) = TMP_139 % REF_84
REF_83(uint256) (->players) := TMP_140(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
players[msg.sender].state = 1

IRs:
REF_85(CHOAM.Player) -> players[msg.sender]
REF_86(uint8) -> REF_85.state
REF_86(uint8) (->players) := 1(uint256)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
players[msg.sender].balance = players[msg.sender].balance.add(msg.value)

IRs:
REF_87(CHOAM.Player) -> players[msg.sender]
REF_88(uint256) -> REF_87.balance
REF_89(CHOAM.Player) -> players[msg.sender]
REF_90(uint256) -> REF_89.balance
TMP_141(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_90', 'msg.value'] 
REF_88(uint256) (->players) := TMP_141(uint256)""];
}
",0,1,0,0,require(bool)(msg.sender == tx.origin);require(bool)(msg.sender != address(0));require(bool)(msg.sender != address(this));require(bool)(msg.value > 0);players[msg.sender].state == 0 && nodes.length > 0;hash = keccak256()(abi.encodePacked(uint256(blockhash(uint256)(11)) + uint256(msg.sender) + uint256(nodes.length)));;players[msg.sender].position = uint256(hash) % nodes.length;players[msg.sender].state = 1;players[msg.sender].balance = players[msg.sender].balance.add(msg.value)
./0x51696e028e0fe5416481c28cf1a2626d43680751_ext.sol,IngridIsAHorribleHumanCoin.transfer,53,59,"REF_1(uint256) -> balances[msg.sender],TMP_0(bool) = REF_1 >= _value,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_2(uint256) -> balances[msg.sender],REF_2(-> balances) = REF_2 - _value,REF_3(uint256) -> balances[_to],REF_3(-> balances) = REF_3 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_0(bool) = REF_1 >= _value
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_2(uint256) -> balances[msg.sender]
REF_2(-> balances) = REF_2 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_3(uint256) -> balances[_to]
REF_3(-> balances) = REF_3 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0xa5fd1a791c4dfcaacc963d4f73c6ae5824149ea7_ext.sol,Manageable.grantManagerPermission,290,302,"REF_5(mapping(string => bool)) -> managerPermissions[_manager],REF_6(bool) -> REF_5[_permissionName],TMP_64(bool) = REF_6 == False,TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64),REF_7(mapping(string => bool)) -> managerPermissions[_manager],REF_8(bool) -> REF_7[_permissionName],REF_8(bool) (->managerPermissions) := True(bool),Emit ManagerPermissionGrantedEvent(_manager,_permissionName),MODIFIER_CALL, OwnableInterface.onlyOwner()(),MODIFIER_CALL, Manageable.onlyValidManagerAddress(address)(_manager),MODIFIER_CALL, Manageable.onlyValidPermissionName(string)(_permissionName)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(managerPermissions[_manager][_permissionName] == false)

IRs:
REF_5(mapping(string => bool)) -> managerPermissions[_manager]
REF_6(bool) -> REF_5[_permissionName]
TMP_64(bool) = REF_6 == False
TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
managerPermissions[_manager][_permissionName] = true

IRs:
REF_7(mapping(string => bool)) -> managerPermissions[_manager]
REF_8(bool) -> REF_7[_permissionName]
REF_8(bool) (->managerPermissions) := True(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ManagerPermissionGrantedEvent(_manager,_permissionName)

IRs:
Emit ManagerPermissionGrantedEvent(_manager,_permissionName)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, OwnableInterface.onlyOwner()()""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyValidManagerAddress(_manager)

IRs:
MODIFIER_CALL, Manageable.onlyValidManagerAddress(address)(_manager)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyValidPermissionName(_permissionName)

IRs:
MODIFIER_CALL, Manageable.onlyValidPermissionName(string)(_permissionName)""];
6->1;
}
",0,1,0,0,"onlyOwner();require(bool)(managerPermissions[_manager][_permissionName] == false);managerPermissions[_manager][_permissionName] = true;ManagerPermissionGrantedEvent(_manager,_permissionName);onlyValidManagerAddress(_manager);onlyValidPermissionName(_permissionName)"
./0xce038523e278b6c1344d9e4f735f6064ad7a6032_ext.sol,TokenSwap.receiveApproval,322,325,"TMP_60 = CONVERT ndc to address,TMP_61(bool) = _tokenContract == TMP_60,TMP_62(None) = SOLIDITY_CALL require(bool)(TMP_61),TMP_63(bool) = LOW_LEVEL_CALL, dest:this, function:call, arguments:['_extraData']  ,TMP_64(None) = SOLIDITY_CALL assert(bool)(TMP_63)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_tokenContract == address(ndc))

IRs:
TMP_60 = CONVERT ndc to address
TMP_61(bool) = _tokenContract == TMP_60
TMP_62(None) = SOLIDITY_CALL require(bool)(TMP_61)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(this.call(_extraData))

IRs:
TMP_63(bool) = LOW_LEVEL_CALL, dest:this, function:call, arguments:['_extraData']  
TMP_64(None) = SOLIDITY_CALL assert(bool)(TMP_63)""];
}
",0,1,0,0,require(bool)(_tokenContract == address(ndc));assert(bool)(this.call(_extraData))
./0x27369e8f43f44c26853a46da7e6cb52d203b59ce_ext.sol,SafeMath.add,22,26,"TMP_10(uint256) = a + b,c(uint256) := TMP_10(uint256),TMP_11(bool) = c >= a,TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11),RETURN c","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
c = a + b

IRs:
TMP_10(uint256) = a + b
c(uint256) := TMP_10(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(c >= a)

IRs:
TMP_11(bool) = c >= a
TMP_12(None) = SOLIDITY_CALL assert(bool)(TMP_11)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
c

IRs:
RETURN c""];
}
",0,1,0,0,c = a + b;assert(bool)(c >= a);c
./0xe8d5a2fc2ff2d5de90c98daa6aaed8b250d7965b_ext.sol,TokenERC20.burn,144,150,"REF_16(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_16 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_17(uint256) -> balanceOf[msg.sender],REF_17(-> balanceOf) = REF_17 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_16(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_16 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
REF_17(-> balanceOf) = REF_17 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x334eec1482109bd802d9e72a447848de3bcc1063_ext.sol,AirDropToken.redeemPackage,98,126,"TMP_16(uint256) = index / 256,REF_17(uint256) -> _redeemed[TMP_16],redeemedBlock(uint256) := REF_17(uint256),TMP_17 = CONVERT 1 to uint256,TMP_18(uint256) = index % 256,TMP_19 = CONVERT TMP_18 to uint256,TMP_20(uint256) = TMP_17 << TMP_19,redeemedMask(uint256) := TMP_20(uint256),TMP_21(uint256) = redeemedBlock & redeemedMask,TMP_22(bool) = TMP_21 == 0,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),TMP_24(uint256) = index / 256,REF_18(uint256) -> _redeemed[TMP_24],TMP_25(uint256) = redeemedBlock | redeemedMask,REF_18(uint256) (->_redeemed) := TMP_25(uint256),TMP_26(bytes32) = SOLIDITY_CALL keccak256()(index,recipient,amount),node(bytes32) := TMP_26(bytes32),path(uint256) := index(uint256),i(uint16) := 0(uint256),REF_19 -> LENGTH merkleProof,TMP_27(bool) = i < REF_19,CONDITION TMP_27,TMP_28(uint256) = path & 1,TMP_29(bool) = TMP_28 == 1,CONDITION TMP_29,REF_20(bytes32) -> merkleProof[i],TMP_30(bytes32) = SOLIDITY_CALL keccak256()(REF_20,node),node(bytes32) := TMP_30(bytes32),REF_21(bytes32) -> merkleProof[i],TMP_31(bytes32) = SOLIDITY_CALL keccak256()(node,REF_21),node(bytes32) := TMP_31(bytes32),path(uint256) = path / 2,TMP_32(uint16) := i(uint16),i(uint16) = i + 1,TMP_33(bool) = node == _rootHash,TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33),REF_22(uint256) -> _balances[recipient],REF_22(-> _balances) = REF_22 + amount,_totalSupply(uint256) = _totalSupply + amount,Emit Transfer(0,recipient,amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
redeemedBlock = _redeemed[index / 256]

IRs:
TMP_16(uint256) = index / 256
REF_17(uint256) -> _redeemed[TMP_16]
redeemedBlock(uint256) := REF_17(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
redeemedMask = (uint256(1) << uint256(index % 256))

IRs:
TMP_17 = CONVERT 1 to uint256
TMP_18(uint256) = index % 256
TMP_19 = CONVERT TMP_18 to uint256
TMP_20(uint256) = TMP_17 << TMP_19
redeemedMask(uint256) := TMP_20(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)((redeemedBlock & redeemedMask) == 0)

IRs:
TMP_21(uint256) = redeemedBlock & redeemedMask
TMP_22(bool) = TMP_21 == 0
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
_redeemed[index / 256] = redeemedBlock | redeemedMask

IRs:
TMP_24(uint256) = index / 256
REF_18(uint256) -> _redeemed[TMP_24]
TMP_25(uint256) = redeemedBlock | redeemedMask
REF_18(uint256) (->_redeemed) := TMP_25(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
node = keccak256()(index,recipient,amount)

IRs:
TMP_26(bytes32) = SOLIDITY_CALL keccak256()(index,recipient,amount)
node(bytes32) := TMP_26(bytes32)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
path = index

IRs:
path(uint256) := index(uint256)""];
6->9;
7[label=""Node Type: BEGIN_LOOP 7
""];
7->10;
8[label=""Node Type: END_LOOP 8
""];
8->17;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
i = 0

IRs:
i(uint16) := 0(uint256)""];
9->7;
10[label=""Node Type: IF_LOOP 10

EXPRESSION:
i < merkleProof.length

IRs:
REF_19 -> LENGTH merkleProof
TMP_27(bool) = i < REF_19
CONDITION TMP_27""];
10->11[label=""True""];
10->8[label=""False""];
11[label=""Node Type: IF 11

EXPRESSION:
(path & 0x01) == 1

IRs:
TMP_28(uint256) = path & 1
TMP_29(bool) = TMP_28 == 1
CONDITION TMP_29""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
node = keccak256()(merkleProof[i],node)

IRs:
REF_20(bytes32) -> merkleProof[i]
TMP_30(bytes32) = SOLIDITY_CALL keccak256()(REF_20,node)
node(bytes32) := TMP_30(bytes32)""];
12->14;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
node = keccak256()(node,merkleProof[i])

IRs:
REF_21(bytes32) -> merkleProof[i]
TMP_31(bytes32) = SOLIDITY_CALL keccak256()(node,REF_21)
node(bytes32) := TMP_31(bytes32)""];
13->14;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
path /= 2

IRs:
path(uint256) = path / 2""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
i ++

IRs:
TMP_32(uint16) := i(uint16)
i(uint16) = i + 1""];
16->10;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
require(bool)(node == _rootHash)

IRs:
TMP_33(bool) = node == _rootHash
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
_balances[recipient] += amount

IRs:
REF_22(uint256) -> _balances[recipient]
REF_22(-> _balances) = REF_22 + amount""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
_totalSupply += amount

IRs:
_totalSupply(uint256) = _totalSupply + amount""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
Transfer(0,recipient,amount)

IRs:
Emit Transfer(0,recipient,amount)""];
}
",0,1,0,0,"redeemedBlock = _redeemed[index / 256];redeemedMask = (uint256(1) << uint256(index % 256));require(bool)((redeemedBlock & redeemedMask) == 0);_redeemed[index / 256] = redeemedBlock | redeemedMask;node = keccak256()(index,recipient,amount);path = index;i = 0;;i < merkleProof.length;;require(bool)(node == _rootHash);(path & 0x01) == 1;node = keccak256()(merkleProof[i],node);node = keccak256()(node,merkleProof[i]);;path /= 2;i ++;_balances[recipient] += amount;_totalSupply += amount;Transfer(0,recipient,amount)"
./0xec270e8f52b492dd0c2dcd43fc6f868e78f49f18_ext.sol,multiowned.removeOwner,212,230,"INTERNAL_CALL, multiowned.assertOwnersAreConsistent()(),INTERNAL_CALL, multiowned.clearPending()(),REF_14(uint256) -> m_ownerIndex[_owner],TMP_53(uint256) = INTERNAL_CALL, multiowned.checkOwnerIndex(uint256)(REF_14),ownerIndex(uint256) := TMP_53(uint256),REF_15(address) -> m_owners[ownerIndex],REF_15(address) (->m_owners) := 0(uint256),REF_16(uint256) -> m_ownerIndex[_owner],REF_16(uint256) (->m_ownerIndex) := 0(uint256),INTERNAL_CALL, multiowned.reorganizeOwners()(),INTERNAL_CALL, multiowned.assertOwnersAreConsistent()(),Emit OwnerRemoved(_owner),MODIFIER_CALL, multiowned.ownerExists(address)(_owner),TMP_58(uint256) = m_numOwners - 1,MODIFIER_CALL, multiowned.validNumOwners(uint256)(TMP_58),TMP_60(uint256) = m_numOwners - 1,MODIFIER_CALL, multiowned.multiOwnedValidRequirement(uint256,uint256)(m_multiOwnedRequired,TMP_60),TMP_62(bytes32) = SOLIDITY_CALL keccak256()(msg.data),MODIFIER_CALL, multiowned.onlymanyowners(bytes32)(TMP_62)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
assertOwnersAreConsistent()

IRs:
INTERNAL_CALL, multiowned.assertOwnersAreConsistent()()""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
clearPending()

IRs:
INTERNAL_CALL, multiowned.clearPending()()""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
ownerIndex = checkOwnerIndex(m_ownerIndex[_owner])

IRs:
REF_14(uint256) -> m_ownerIndex[_owner]
TMP_53(uint256) = INTERNAL_CALL, multiowned.checkOwnerIndex(uint256)(REF_14)
ownerIndex(uint256) := TMP_53(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
m_owners[ownerIndex] = 0

IRs:
REF_15(address) -> m_owners[ownerIndex]
REF_15(address) (->m_owners) := 0(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
m_ownerIndex[_owner] = 0

IRs:
REF_16(uint256) -> m_ownerIndex[_owner]
REF_16(uint256) (->m_ownerIndex) := 0(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
reorganizeOwners()

IRs:
INTERNAL_CALL, multiowned.reorganizeOwners()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
assertOwnersAreConsistent()

IRs:
INTERNAL_CALL, multiowned.assertOwnersAreConsistent()()""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
OwnerRemoved(_owner)

IRs:
Emit OwnerRemoved(_owner)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
ownerExists(_owner)

IRs:
MODIFIER_CALL, multiowned.ownerExists(address)(_owner)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
validNumOwners(m_numOwners - 1)

IRs:
TMP_58(uint256) = m_numOwners - 1
MODIFIER_CALL, multiowned.validNumOwners(uint256)(TMP_58)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
multiOwnedValidRequirement(m_multiOwnedRequired,m_numOwners - 1)

IRs:
TMP_60(uint256) = m_numOwners - 1
MODIFIER_CALL, multiowned.multiOwnedValidRequirement(uint256,uint256)(m_multiOwnedRequired,TMP_60)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlymanyowners(keccak256()(msg.data))

IRs:
TMP_62(bytes32) = SOLIDITY_CALL keccak256()(msg.data)
MODIFIER_CALL, multiowned.onlymanyowners(bytes32)(TMP_62)""];
12->1;
}
",0,1,0,0,"ownerExists(_owner);assertOwnersAreConsistent();clearPending();ownerIndex = checkOwnerIndex(m_ownerIndex[_owner]);m_owners[ownerIndex] = 0;m_ownerIndex[_owner] = 0;reorganizeOwners();assertOwnersAreConsistent();OwnerRemoved(_owner);validNumOwners(m_numOwners - 1);multiOwnedValidRequirement(m_multiOwnedRequired,m_numOwners - 1);onlymanyowners(keccak256()(msg.data))"
./0xdfccdbd82b578cfd862a9f9741b2ddcd2c9b1e22_ext.sol,TokenERC20.burnFrom,161,169,"REF_19(uint256) -> balanceOf[_from],TMP_28(bool) = REF_19 >= _value,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_30(bool) = _value <= REF_21,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_28(bool) = REF_19 >= _value
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_30(bool) = _value <= REF_21
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x6be98275cb30e4d64ebe6be942cd87268dfea3a5_ext.sol,BusinessAutomationUnion.totalSupply,128,130,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x5c6d8bb345f4299c76f24fc771ef04dd160c4d36_ext.sol,EthCrystal._currentPlayerAmountUnclaimed,277,288,"TMP_124(bool) = _RoundID == 0,CONDITION TMP_124,REF_279(EthCrystal.TowersInfoList) -> GameRounds[_TowerType],REF_280(uint256) -> REF_279.currentRoundID,_RoundID(uint256) := REF_280(uint256),REF_281(EthCrystal.PlayerInfo) -> players[_playerAddress],REF_282(mapping(uint256 => EthCrystal.TowersRoundInfo)) -> REF_281.TowersList,REF_283(EthCrystal.TowersRoundInfo) -> REF_282[_TowerType],REF_284(mapping(uint256 => EthCrystal.PlayerRoundInfo)) -> REF_283.RoundList,REF_285(EthCrystal.PlayerRoundInfo) -> REF_284[_RoundID],REF_286(uint256) -> REF_285.warriors,_warriors(uint256) := REF_286(uint256),REF_287(EthCrystal.TowersInfoList) -> GameRounds[_TowerType],REF_288(mapping(uint256 => EthCrystal.TowersInfo)) -> REF_287.RoundList,REF_289(EthCrystal.TowersInfo) -> REF_288[_RoundID],REF_290(uint256) -> REF_289.towerBalance,TMP_125(uint256) = _warriors * REF_290,REF_291(EthCrystal.TowersInfoList) -> GameRounds[_RoundID],REF_292(uint256) -> REF_291.dividendShare,TMP_126(uint256) = TMP_125 * REF_292,REF_293(EthCrystal.TowersInfoList) -> GameRounds[_TowerType],REF_294(mapping(uint256 => EthCrystal.TowersInfo)) -> REF_293.RoundList,REF_295(EthCrystal.TowersInfo) -> REF_294[_RoundID],REF_296(uint256) -> REF_295.totalWarriors,TMP_127(uint256) = TMP_126 / REF_296,TMP_128(uint256) = TMP_127 / 100,_totalForCashOut(uint256) := TMP_128(uint256),REF_297(EthCrystal.PlayerInfo) -> players[_playerAddress],REF_298(mapping(uint256 => EthCrystal.TowersRoundInfo)) -> REF_297.TowersList,REF_299(EthCrystal.TowersRoundInfo) -> REF_298[_TowerType],REF_300(mapping(uint256 => EthCrystal.PlayerRoundInfo)) -> REF_299.RoundList,REF_301(EthCrystal.PlayerRoundInfo) -> REF_300[_RoundID],REF_302(uint256) -> REF_301.cashedOut,TMP_129(uint256) = _totalForCashOut - REF_302,_unclaimedAmount(uint256) := TMP_129(uint256),RETURN _unclaimedAmount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_RoundID == 0

IRs:
TMP_124(bool) = _RoundID == 0
CONDITION TMP_124""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_RoundID = GameRounds[_TowerType].currentRoundID

IRs:
REF_279(EthCrystal.TowersInfoList) -> GameRounds[_TowerType]
REF_280(uint256) -> REF_279.currentRoundID
_RoundID(uint256) := REF_280(uint256)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
_warriors = players[_playerAddress].TowersList[_TowerType].RoundList[_RoundID].warriors

IRs:
REF_281(EthCrystal.PlayerInfo) -> players[_playerAddress]
REF_282(mapping(uint256 => EthCrystal.TowersRoundInfo)) -> REF_281.TowersList
REF_283(EthCrystal.TowersRoundInfo) -> REF_282[_TowerType]
REF_284(mapping(uint256 => EthCrystal.PlayerRoundInfo)) -> REF_283.RoundList
REF_285(EthCrystal.PlayerRoundInfo) -> REF_284[_RoundID]
REF_286(uint256) -> REF_285.warriors
_warriors(uint256) := REF_286(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
_totalForCashOut = (_warriors * GameRounds[_TowerType].RoundList[_RoundID].towerBalance * GameRounds[_RoundID].dividendShare / GameRounds[_TowerType].RoundList[_RoundID].totalWarriors / 100)

IRs:
REF_287(EthCrystal.TowersInfoList) -> GameRounds[_TowerType]
REF_288(mapping(uint256 => EthCrystal.TowersInfo)) -> REF_287.RoundList
REF_289(EthCrystal.TowersInfo) -> REF_288[_RoundID]
REF_290(uint256) -> REF_289.towerBalance
TMP_125(uint256) = _warriors * REF_290
REF_291(EthCrystal.TowersInfoList) -> GameRounds[_RoundID]
REF_292(uint256) -> REF_291.dividendShare
TMP_126(uint256) = TMP_125 * REF_292
REF_293(EthCrystal.TowersInfoList) -> GameRounds[_TowerType]
REF_294(mapping(uint256 => EthCrystal.TowersInfo)) -> REF_293.RoundList
REF_295(EthCrystal.TowersInfo) -> REF_294[_RoundID]
REF_296(uint256) -> REF_295.totalWarriors
TMP_127(uint256) = TMP_126 / REF_296
TMP_128(uint256) = TMP_127 / 100
_totalForCashOut(uint256) := TMP_128(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
_unclaimedAmount = _totalForCashOut - players[_playerAddress].TowersList[_TowerType].RoundList[_RoundID].cashedOut

IRs:
REF_297(EthCrystal.PlayerInfo) -> players[_playerAddress]
REF_298(mapping(uint256 => EthCrystal.TowersRoundInfo)) -> REF_297.TowersList
REF_299(EthCrystal.TowersRoundInfo) -> REF_298[_TowerType]
REF_300(mapping(uint256 => EthCrystal.PlayerRoundInfo)) -> REF_299.RoundList
REF_301(EthCrystal.PlayerRoundInfo) -> REF_300[_RoundID]
REF_302(uint256) -> REF_301.cashedOut
TMP_129(uint256) = _totalForCashOut - REF_302
_unclaimedAmount(uint256) := TMP_129(uint256)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
(_unclaimedAmount)

IRs:
RETURN _unclaimedAmount""];
}
",0,1,0,0,_RoundID == 0;_RoundID = GameRounds[_TowerType].currentRoundID;;_warriors = players[_playerAddress].TowersList[_TowerType].RoundList[_RoundID].warriors;_totalForCashOut = (_warriors * GameRounds[_TowerType].RoundList[_RoundID].towerBalance * GameRounds[_RoundID].dividendShare / GameRounds[_TowerType].RoundList[_RoundID].totalWarriors / 100);_unclaimedAmount = _totalForCashOut - players[_playerAddress].TowersList[_TowerType].RoundList[_RoundID].cashedOut;(_unclaimedAmount)
./0x848d015af507fb3840fee1078ad3a352e0aba055_ext.sol,PUNCToken.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xce7382bf7f277a2b661aaf71408ac65b287305a0_ext.sol,Maccabi.appendTokenHolders,94,102,"REF_3(uint256) -> balanceOf[tokenHolder],TMP_1(bool) = REF_3 == 0,CONDITION TMP_1,REF_4(address) -> accountIndex[accountCount],REF_4(address) (->accountIndex) := tokenHolder(address),TMP_2(uint256) := accountCount(uint256),accountCount(uint256) = accountCount + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balanceOf[tokenHolder] == 0

IRs:
REF_3(uint256) -> balanceOf[tokenHolder]
TMP_1(bool) = REF_3 == 0
CONDITION TMP_1""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
accountIndex[accountCount] = tokenHolder

IRs:
REF_4(address) -> accountIndex[accountCount]
REF_4(address) (->accountIndex) := tokenHolder(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
accountCount ++

IRs:
TMP_2(uint256) := accountCount(uint256)
accountCount(uint256) = accountCount + 1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,1,0,0,balanceOf[tokenHolder] == 0;accountIndex[accountCount] = tokenHolder;;accountCount ++
./0xc317e1a103b5ba8161614c4e69f2bc49165841b3_ext.sol,REALIDVerification.getOrgInfo,101,107,"REF_78(REALIDVerification.orgInfo) -> orgData[org],REF_79(string[]) -> REF_78.certificateAds,REF_80 -> LENGTH REF_79,TMP_32(bool) = REF_80 == 0,CONDITION TMP_32,REF_81(REALIDVerification.orgInfo) -> orgData[org],REF_82(string) -> REF_81.orgName,REF_83(REALIDVerification.orgInfo) -> orgData[org],REF_84(string) -> REF_83.website,REF_85(REALIDVerification.orgInfo) -> orgData[org],REF_86(uint256) -> REF_85.createTime,REF_87(REALIDVerification.orgInfo) -> orgData[org],REF_88(string) -> REF_87.country,REF_89(REALIDVerification.orgInfo) -> orgData[org],REF_90(uint8) -> REF_89.level,RETURN REF_82,REF_84,,REF_86,REF_88,REF_90,REF_91(REALIDVerification.orgInfo) -> orgData[org],REF_92(string) -> REF_91.orgName,REF_93(REALIDVerification.orgInfo) -> orgData[org],REF_94(string) -> REF_93.website,REF_95(REALIDVerification.orgInfo) -> orgData[org],REF_96(string[]) -> REF_95.certificateAds,REF_97(string) -> REF_96[0],REF_98(REALIDVerification.orgInfo) -> orgData[org],REF_99(uint256) -> REF_98.createTime,REF_100(REALIDVerification.orgInfo) -> orgData[org],REF_101(string) -> REF_100.country,REF_102(REALIDVerification.orgInfo) -> orgData[org],REF_103(uint8) -> REF_102.level,RETURN REF_92,REF_94,REF_97,REF_99,REF_101,REF_103","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
orgData[org].certificateAds.length == 0

IRs:
REF_78(REALIDVerification.orgInfo) -> orgData[org]
REF_79(string[]) -> REF_78.certificateAds
REF_80 -> LENGTH REF_79
TMP_32(bool) = REF_80 == 0
CONDITION TMP_32""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
(orgData[org].orgName,orgData[org].website,,orgData[org].createTime,orgData[org].country,orgData[org].level)

IRs:
REF_81(REALIDVerification.orgInfo) -> orgData[org]
REF_82(string) -> REF_81.orgName
REF_83(REALIDVerification.orgInfo) -> orgData[org]
REF_84(string) -> REF_83.website
REF_85(REALIDVerification.orgInfo) -> orgData[org]
REF_86(uint256) -> REF_85.createTime
REF_87(REALIDVerification.orgInfo) -> orgData[org]
REF_88(string) -> REF_87.country
REF_89(REALIDVerification.orgInfo) -> orgData[org]
REF_90(uint8) -> REF_89.level
RETURN REF_82,REF_84,,REF_86,REF_88,REF_90""];
3[label=""Node Type: RETURN 3

EXPRESSION:
(orgData[org].orgName,orgData[org].website,orgData[org].certificateAds[0],orgData[org].createTime,orgData[org].country,orgData[org].level)

IRs:
REF_91(REALIDVerification.orgInfo) -> orgData[org]
REF_92(string) -> REF_91.orgName
REF_93(REALIDVerification.orgInfo) -> orgData[org]
REF_94(string) -> REF_93.website
REF_95(REALIDVerification.orgInfo) -> orgData[org]
REF_96(string[]) -> REF_95.certificateAds
REF_97(string) -> REF_96[0]
REF_98(REALIDVerification.orgInfo) -> orgData[org]
REF_99(uint256) -> REF_98.createTime
REF_100(REALIDVerification.orgInfo) -> orgData[org]
REF_101(string) -> REF_100.country
REF_102(REALIDVerification.orgInfo) -> orgData[org]
REF_103(uint8) -> REF_102.level
RETURN REF_92,REF_94,REF_97,REF_99,REF_101,REF_103""];
}
",0,1,0,0,"orgData[org].certificateAds.length == 0;(orgData[org].orgName,orgData[org].website,,orgData[org].createTime,orgData[org].country,orgData[org].level);(orgData[org].orgName,orgData[org].website,orgData[org].certificateAds[0],orgData[org].createTime,orgData[org].country,orgData[org].level)"
./0x0d514c490640d6276b5bb5adc52d1453cf11c5a0_ext.sol,Token.mintToken,93,100,"TMP_27(bool) = msg.sender == mintableAddress,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_32(uint256) -> balances[this],TMP_29(bool) = REF_32 >= amount,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),REF_33(uint256) -> balances[this],REF_33(-> balances) = REF_33 - amount,REF_34(uint256) -> balances[to],REF_34(-> balances) = REF_34 + amount,Emit Transfer(this,to,amount),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == mintableAddress)

IRs:
TMP_27(bool) = msg.sender == mintableAddress
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[this] >= amount)

IRs:
REF_32(uint256) -> balances[this]
TMP_29(bool) = REF_32 >= amount
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[this] -= amount

IRs:
REF_33(uint256) -> balances[this]
REF_33(-> balances) = REF_33 - amount""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[to] += amount

IRs:
REF_34(uint256) -> balances[to]
REF_34(-> balances) = REF_34 + amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(this,to,amount)

IRs:
Emit Transfer(this,to,amount)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(msg.sender == mintableAddress);require(bool)(balances[this] >= amount);balances[this] -= amount;balances[to] += amount;Transfer(this,to,amount);true;success"
./0xf0d1a6dfcce7fb23fee76d8ed89e780c5a2c1885_ext.sol,ERC721._transfer,110,123,"REF_5(uint256) -> ownershipTokenCount[_to],TMP_14(uint256) := REF_5(uint256),REF_5(-> ownershipTokenCount) = REF_5 + 1,REF_6(address) -> tokenIndexToOwner[_tokenId],REF_6(address) (->tokenIndexToOwner) := _to(address),TMP_15 = CONVERT 0 to address,TMP_16(bool) = _from != TMP_15,CONDITION TMP_16,REF_7(uint256) -> ownershipTokenCount[_from],TMP_17(uint256) := REF_7(uint256),REF_7(-> ownershipTokenCount) = REF_7 - 1,REF_8(address) -> tokenIndexToApproved[_tokenId],tokenIndexToApproved = delete REF_8 ,Emit Transfer(_from,_to,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownershipTokenCount[_to] ++

IRs:
REF_5(uint256) -> ownershipTokenCount[_to]
TMP_14(uint256) := REF_5(uint256)
REF_5(-> ownershipTokenCount) = REF_5 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
tokenIndexToOwner[_tokenId] = _to

IRs:
REF_6(address) -> tokenIndexToOwner[_tokenId]
REF_6(address) (->tokenIndexToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_15 = CONVERT 0 to address
TMP_16(bool) = _from != TMP_15
CONDITION TMP_16""];
3->4[label=""True""];
3->7[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownershipTokenCount[_from] --

IRs:
REF_7(uint256) -> ownershipTokenCount[_from]
TMP_17(uint256) := REF_7(uint256)
REF_7(-> ownershipTokenCount) = REF_7 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete tokenIndexToApproved[_tokenId]

IRs:
REF_8(address) -> tokenIndexToApproved[_tokenId]
tokenIndexToApproved = delete REF_8 ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(_from,_to,_tokenId)

IRs:
Emit Transfer(_from,_to,_tokenId)""];
6->7;
7[label=""Node Type: END_IF 7
""];
}
",0,1,0,0,"ownershipTokenCount[_to] ++;tokenIndexToOwner[_tokenId] = _to;_from != address(0);ownershipTokenCount[_from] --;;delete tokenIndexToApproved[_tokenId];Transfer(_from,_to,_tokenId)"
./0x1a699c9d8a34f7a60328bf5f3a3dbf10a3ad5baf_ext.sol,SEAPORT_Portfolio_II_883.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x37eba68380f5a549532f658244f82619ac733c03_ext.sol,VOCC_I042_20181211.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0x6e5dce687b949b52dad8bb1cc467d0205cb4b6e3_ext.sol,CAC.getFreeBalances,406,418,"REF_151(uint256) -> balanceLocked[_addr],TMP_159(bool) = REF_151 > 0,CONDITION TMP_159,REF_152(uint256) -> lockAtTime[_addr],TMP_160(uint256) = REF_152 + 15552000,TMP_161(bool) = now > TMP_160,CONDITION TMP_161,REF_153(uint256) -> balances[_addr],RETURN REF_153,REF_154(uint256) -> lockAtTime[_addr],TMP_162(uint256) = REF_154 + 7776000,TMP_163(bool) = now > TMP_162,CONDITION TMP_163,REF_155(uint256) -> balances[_addr],REF_156(uint256) -> balanceLocked[_addr],TMP_164(uint256) = REF_156 / 10,TMP_165(uint256) = TMP_164 * 4,TMP_166(uint256) = REF_155 - TMP_165,RETURN TMP_166,REF_157(uint256) -> balances[_addr],REF_158(uint256) -> balanceLocked[_addr],TMP_167(uint256) = REF_158 / 10,TMP_168(uint256) = TMP_167 * 7,TMP_169(uint256) = REF_157 - TMP_168,RETURN TMP_169,REF_159(uint256) -> balances[_addr],RETURN REF_159","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balanceLocked[_addr] > 0

IRs:
REF_151(uint256) -> balanceLocked[_addr]
TMP_159(bool) = REF_151 > 0
CONDITION TMP_159""];
1->2[label=""True""];
1->9[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
now > lockAtTime[_addr] + 15552000

IRs:
REF_152(uint256) -> lockAtTime[_addr]
TMP_160(uint256) = REF_152 + 15552000
TMP_161(bool) = now > TMP_160
CONDITION TMP_161""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3

EXPRESSION:
balances[_addr]

IRs:
REF_153(uint256) -> balances[_addr]
RETURN REF_153""];
4[label=""Node Type: IF 4

EXPRESSION:
now > lockAtTime[_addr] + 7776000

IRs:
REF_154(uint256) -> lockAtTime[_addr]
TMP_162(uint256) = REF_154 + 7776000
TMP_163(bool) = now > TMP_162
CONDITION TMP_163""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: RETURN 5

EXPRESSION:
balances[_addr] - balanceLocked[_addr] / 10 * 4

IRs:
REF_155(uint256) -> balances[_addr]
REF_156(uint256) -> balanceLocked[_addr]
TMP_164(uint256) = REF_156 / 10
TMP_165(uint256) = TMP_164 * 4
TMP_166(uint256) = REF_155 - TMP_165
RETURN TMP_166""];
6[label=""Node Type: RETURN 6

EXPRESSION:
balances[_addr] - balanceLocked[_addr] / 10 * 7

IRs:
REF_157(uint256) -> balances[_addr]
REF_158(uint256) -> balanceLocked[_addr]
TMP_167(uint256) = REF_158 / 10
TMP_168(uint256) = TMP_167 * 7
TMP_169(uint256) = REF_157 - TMP_168
RETURN TMP_169""];
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: RETURN 10

EXPRESSION:
balances[_addr]

IRs:
REF_159(uint256) -> balances[_addr]
RETURN REF_159""];
}
",0,1,0,0,balanceLocked[_addr] > 0;now > lockAtTime[_addr] + 15552000;;balances[_addr];now > lockAtTime[_addr] + 7776000;balances[_addr] - balanceLocked[_addr] / 10 * 4;balances[_addr] - balanceLocked[_addr] / 10 * 7;balances[_addr]
./0x282c3971f8041bf4ab8b0d2ad0875e94958f8940_ext.sol,RENAULT_301201.transferFrom,42,54,"REF_6(uint256) -> balanceOf[from],TMP_6(bool) = value <= REF_6,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_7(mapping(address => uint256)) -> allowance[from],REF_8(uint256) -> REF_7[msg.sender],TMP_8(bool) = value <= REF_8,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_9(uint256) -> balanceOf[from],REF_9(-> balanceOf) = REF_9 - value,REF_10(uint256) -> balanceOf[to],REF_10(-> balanceOf) = REF_10 + value,REF_11(mapping(address => uint256)) -> allowance[from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowance) = REF_12 - value,Emit Transfer(from,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(value <= balanceOf[from])

IRs:
REF_6(uint256) -> balanceOf[from]
TMP_6(bool) = value <= REF_6
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value <= allowance[from][msg.sender])

IRs:
REF_7(mapping(address => uint256)) -> allowance[from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_8(bool) = value <= REF_8
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[from] -= value

IRs:
REF_9(uint256) -> balanceOf[from]
REF_9(-> balanceOf) = REF_9 - value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[to] += value

IRs:
REF_10(uint256) -> balanceOf[to]
REF_10(-> balanceOf) = REF_10 + value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allowance[from][msg.sender] -= value

IRs:
REF_11(mapping(address => uint256)) -> allowance[from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowance) = REF_12 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(value <= balanceOf[from]);require(bool)(value <= allowance[from][msg.sender]);balanceOf[from] -= value;balanceOf[to] += value;allowance[from][msg.sender] -= value;Transfer(from,to,value);true;success"
./0x52ccb8ebb0f55a592ce67dd49249f6cb0c64a129_ext.sol,Globglogabgalab.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x2118840b16aaf95a0f0027b7ac32f5986925d935_ext.sol,TokenERC20.approveAndCall,96,102,"TMP_32 = CONVERT _spender to TokenRecipient,spender(TokenRecipient) := TMP_32(TokenRecipient),TMP_33(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value),CONDITION TMP_33,HIGH_LEVEL_CALL, dest:spender(TokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = TokenRecipient(_spender)

IRs:
TMP_32 = CONVERT _spender to TokenRecipient
spender(TokenRecipient) := TMP_32(TokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_33(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value)
CONDITION TMP_33""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(TokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = TokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0xf1657ae4204d6fc6166833f29447048d0c3ff7e8_ext.sol,LXB.transfer,28,34,"REF_1(uint256) -> balances[msg.sender],TMP_0(bool) = REF_1 >= _value,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_2(uint256) -> balances[msg.sender],REF_2(-> balances) = REF_2 - _value,REF_3(uint256) -> balances[_to],REF_3(-> balances) = REF_3 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_0(bool) = REF_1 >= _value
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_2(uint256) -> balances[msg.sender]
REF_2(-> balances) = REF_2 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_3(uint256) -> balances[_to]
REF_3(-> balances) = REF_3 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0x0e16923571c50a48b4f9b3b8319606ef8d6106ae_ext.sol,online_wallet.withdraw,13,21,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2),TMP_4(bool) = keyHash == TMP_3,CONDITION TMP_4,TMP_5(bool) = msg.value >= 400000000000000000,CONDITION TMP_5,TMP_6 = CONVERT this to address,TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6),Transfer dest:msg.sender value:TMP_7","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
keyHash == keccak256()(abi.encodePacked(key))

IRs:
TMP_2(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_3(bytes32) = SOLIDITY_CALL keccak256()(TMP_2)
TMP_4(bool) = keyHash == TMP_3
CONDITION TMP_4""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
msg.value >= 400000000000000000

IRs:
TMP_5(bool) = msg.value >= 400000000000000000
CONDITION TMP_5""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_6 = CONVERT this to address
TMP_7(uint256) = SOLIDITY_CALL balance(address)(TMP_6)
Transfer dest:msg.sender value:TMP_7""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,1,0,0,require(bool)(msg.sender == tx.origin);keyHash == keccak256()(abi.encodePacked(key));msg.value >= 400000000000000000;;msg.sender.transfer(address(this).balance);
./0x419b8ed155180a8c9c64145e76dad49c0a4efb97_ext.sol,ApproveAndCallToken.approveAndCall,195,202,"TMP_70 = CONVERT _spender to TokenRecipient,spender(TokenRecipient) := TMP_70(TokenRecipient),TMP_71(bool) = INTERNAL_CALL, StandardToken.approve(address,uint256)(_spender,_value),CONDITION TMP_71,HIGH_LEVEL_CALL, dest:spender(TokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_data']  ,RETURN True,RETURN False","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = TokenRecipient(_spender)

IRs:
TMP_70 = CONVERT _spender to TokenRecipient
spender(TokenRecipient) := TMP_70(TokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_71(bool) = INTERNAL_CALL, StandardToken.approve(address,uint256)(_spender,_value)
CONDITION TMP_71""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_data)

IRs:
HIGH_LEVEL_CALL, dest:spender(TokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False""];
}
",0,1,0,0,"spender = TokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_data);;true;false"
./0x332e68dabba9ac8ac5f9a11423f7e72a8b648d1a_ext.sol,DTDToken.getPrice,213,222,"TMP_83(uint256) = _totalSupply - _tokenLeft,TMP_84(bool) = TMP_83 < _round1Limit,CONDITION TMP_84,RETURN 650,TMP_85(uint256) = _totalSupply - _tokenLeft,TMP_86(bool) = TMP_85 < _round2Limit,CONDITION TMP_86,RETURN 500,TMP_87(uint256) = _totalSupply - _tokenLeft,TMP_88(bool) = TMP_87 < _round3Limit,CONDITION TMP_88,RETURN 400,RETURN 0,RETURN result","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_totalSupply - _tokenLeft < _round1Limit

IRs:
TMP_83(uint256) = _totalSupply - _tokenLeft
TMP_84(bool) = TMP_83 < _round1Limit
CONDITION TMP_84""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2

EXPRESSION:
650

IRs:
RETURN 650""];
3[label=""Node Type: IF 3

EXPRESSION:
_totalSupply - _tokenLeft < _round2Limit

IRs:
TMP_85(uint256) = _totalSupply - _tokenLeft
TMP_86(bool) = TMP_85 < _round2Limit
CONDITION TMP_86""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: RETURN 4

EXPRESSION:
500

IRs:
RETURN 500""];
5[label=""Node Type: IF 5

EXPRESSION:
_totalSupply - _tokenLeft < _round3Limit

IRs:
TMP_87(uint256) = _totalSupply - _tokenLeft
TMP_88(bool) = TMP_87 < _round3Limit
CONDITION TMP_88""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: RETURN 6

EXPRESSION:
400

IRs:
RETURN 400""];
7[label=""Node Type: RETURN 7

EXPRESSION:
0

IRs:
RETURN 0""];
11[label=""Node Type: RETURN 11

EXPRESSION:
result

IRs:
RETURN result""];
}
",0,1,0,0,_totalSupply - _tokenLeft < _round1Limit;650;_totalSupply - _tokenLeft < _round2Limit;500;_totalSupply - _tokenLeft < _round3Limit;400;0;result
./0x7880ddfa13218bae0a42ea56902de21ff29a82ce_ext.sol,BlockGame.totalSupply,102,104,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0xaf7188dbaa4e9a25864827cc9b9a72f663017834_ext.sol,HammBones.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x5c89736e9454200141b80c37eb28eaceca2ce8cb_ext.sol,CherryToken.transferdata,274,285,"TMP_131(bool) = _value > 0,TMP_132(None) = SOLIDITY_CALL require(bool)(TMP_131),TMP_133(bool) = INTERNAL_CALL, CherryToken.isContract(address)(_to),CONDITION TMP_133,TMP_134 = CONVERT _to to ERC223ReceivingContract,receiver(ERC223ReceivingContract) := TMP_134(ERC223ReceivingContract),HIGH_LEVEL_CALL, dest:receiver(ERC223ReceivingContract), function:tokenFallback, arguments:['msg.sender', '_value', '_data']  ,REF_110(uint256) -> balances[msg.sender],REF_111(uint256) -> balances[msg.sender],TMP_136(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_111', '_value'] ,REF_110(uint256) (->balances) := TMP_136(uint256),REF_113(uint256) -> balances[_to],REF_114(uint256) -> balances[_to],TMP_137(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_114', '_value'] ,REF_113(uint256) (->balances) := TMP_137(uint256),Emit Transferdata(msg.sender,_to,_value,_data)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value > 0)

IRs:
TMP_131(bool) = _value > 0
TMP_132(None) = SOLIDITY_CALL require(bool)(TMP_131)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
isContract(_to)

IRs:
TMP_133(bool) = INTERNAL_CALL, CherryToken.isContract(address)(_to)
CONDITION TMP_133""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
receiver = ERC223ReceivingContract(_to)

IRs:
TMP_134 = CONVERT _to to ERC223ReceivingContract
receiver(ERC223ReceivingContract) := TMP_134(ERC223ReceivingContract)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
receiver.tokenFallback(msg.sender,_value,_data)

IRs:
HIGH_LEVEL_CALL, dest:receiver(ERC223ReceivingContract), function:tokenFallback, arguments:['msg.sender', '_value', '_data']  ""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[msg.sender] = balances[msg.sender].sub(_value)

IRs:
REF_110(uint256) -> balances[msg.sender]
REF_111(uint256) -> balances[msg.sender]
TMP_136(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_111', '_value'] 
REF_110(uint256) (->balances) := TMP_136(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[_to] = balances[_to].add(_value)

IRs:
REF_113(uint256) -> balances[_to]
REF_114(uint256) -> balances[_to]
TMP_137(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_114', '_value'] 
REF_113(uint256) (->balances) := TMP_137(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Transferdata(msg.sender,_to,_value,_data)

IRs:
Emit Transferdata(msg.sender,_to,_value,_data)""];
}
",1,1,0,0,"require(bool)(_value > 0);isContract(_to);receiver = ERC223ReceivingContract(_to);;receiver.tokenFallback(msg.sender,_value,_data);balances[msg.sender] = balances[msg.sender].sub(_value);balances[_to] = balances[_to].add(_value);Transferdata(msg.sender,_to,_value,_data)"
./0x6c61f6343b7420e142fb05f8b86afed3179eb0f0_ext.sol,StandardToken.transferFrom,66,76,"REF_3(uint256) -> balances[_from],TMP_19(bool) = REF_3 >= _value,REF_4(mapping(address => uint256)) -> allowed[_from],REF_5(uint256) -> REF_4[msg.sender],TMP_20(bool) = REF_5 >= _value,TMP_21(bool) = TMP_19 && TMP_20,TMP_22(bool) = _value > 0,TMP_23(bool) = TMP_21 && TMP_22,CONDITION TMP_23,REF_6(uint256) -> balances[_to],REF_6(-> balances) = REF_6 + _value,REF_7(uint256) -> balances[_from],REF_7(-> balances) = REF_7 - _value,REF_8(mapping(address => uint256)) -> allowed[_from],REF_9(uint256) -> REF_8[msg.sender],REF_9(-> allowed) = REF_9 - _value,Emit Transfer(_from,_to,_value),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0

IRs:
REF_3(uint256) -> balances[_from]
TMP_19(bool) = REF_3 >= _value
REF_4(mapping(address => uint256)) -> allowed[_from]
REF_5(uint256) -> REF_4[msg.sender]
TMP_20(bool) = REF_5 >= _value
TMP_21(bool) = TMP_19 && TMP_20
TMP_22(bool) = _value > 0
TMP_23(bool) = TMP_21 && TMP_22
CONDITION TMP_23""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_to] += _value

IRs:
REF_6(uint256) -> balances[_to]
REF_6(-> balances) = REF_6 + _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_from] -= _value

IRs:
REF_7(uint256) -> balances[_from]
REF_7(-> balances) = REF_7 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowed[_from][msg.sender] -= _value

IRs:
REF_8(mapping(address => uint256)) -> allowed[_from]
REF_9(uint256) -> REF_8[msg.sender]
REF_9(-> allowed) = REF_9 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0;balances[_to] += _value;false;balances[_from] -= _value;allowed[_from][msg.sender] -= _value;Transfer(_from,_to,_value);true;success"
./0x37f0137cb24c315d4f725473697e558d6ccaffaa_ext.sol,CROATIA_WINS.transfer,20,27,"REF_1(uint256) -> balanceOf[msg.sender],TMP_2(bool) = REF_1 >= value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[msg.sender],REF_2(-> balanceOf) = REF_2 - value,REF_3(uint256) -> balanceOf[to],REF_3(-> balanceOf) = REF_3 + value,Emit Transfer(msg.sender,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= value)

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
TMP_2(bool) = REF_1 >= value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= value

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
REF_2(-> balanceOf) = REF_2 - value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[to] += value

IRs:
REF_3(uint256) -> balanceOf[to]
REF_3(-> balanceOf) = REF_3 + value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,to,value)

IRs:
Emit Transfer(msg.sender,to,value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= value);balanceOf[msg.sender] -= value;balanceOf[to] += value;Transfer(msg.sender,to,value);true;success"
./0xc83355ef25a104938275b46cffd94bf9917d0691_ext.sol,FUTR.mint,167,191,"TMP_27(uint256) = _submitted + _value,total(uint256) := TMP_27(uint256),TMP_28(bool) = total > MAX_SUBMITTED,CONDITION TMP_28,TMP_29(uint256) = total - MAX_SUBMITTED,TMP_30(uint256) = TMP_29 - 1,refund(uint256) := TMP_30(uint256),TMP_31(uint256) = _value - refund,_value(uint256) := TMP_31(uint256),Transfer dest:_to value:refund,_submitted(uint256) = _submitted + _value,total(uint256) = total - refund,TMP_33(uint256) = INTERNAL_CALL, FUTR.calculateTokens(uint256,uint256)(total,_value),tokens(uint256) := TMP_33(uint256),REF_2(uint256) -> balances[_to],REF_2(-> balances) = REF_2 + tokens,_totalSupply(uint256) = _totalSupply + tokens,RETURN tokens","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
total = _submitted + _value

IRs:
TMP_27(uint256) = _submitted + _value
total(uint256) := TMP_27(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
total > MAX_SUBMITTED

IRs:
TMP_28(bool) = total > MAX_SUBMITTED
CONDITION TMP_28""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
refund = total - MAX_SUBMITTED - 1

IRs:
TMP_29(uint256) = total - MAX_SUBMITTED
TMP_30(uint256) = TMP_29 - 1
refund(uint256) := TMP_30(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
_value = _value - refund

IRs:
TMP_31(uint256) = _value - refund
_value(uint256) := TMP_31(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_to.transfer(refund)

IRs:
Transfer dest:_to value:refund""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
_submitted += _value

IRs:
_submitted(uint256) = _submitted + _value""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
total -= refund

IRs:
total(uint256) = total - refund""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
tokens = calculateTokens(total,_value)

IRs:
TMP_33(uint256) = INTERNAL_CALL, FUTR.calculateTokens(uint256,uint256)(total,_value)
tokens(uint256) := TMP_33(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
balances[_to] += tokens

IRs:
REF_2(uint256) -> balances[_to]
REF_2(-> balances) = REF_2 + tokens""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
_totalSupply += tokens

IRs:
_totalSupply(uint256) = _totalSupply + tokens""];
11->12;
12[label=""Node Type: RETURN 12

EXPRESSION:
tokens

IRs:
RETURN tokens""];
}
",0,1,0,0,"total = _submitted + _value;total > MAX_SUBMITTED;refund = total - MAX_SUBMITTED - 1;;_value = _value - refund;_to.transfer(refund);_submitted += _value;total -= refund;tokens = calculateTokens(total,_value);balances[_to] += tokens;_totalSupply += tokens;tokens"
./0xec9a75a532311b6102d91d439e1db055dc9414d9_ext.sol,PD88.win,246,259,"REF_78(uint256) -> RoundTime[Round],TMP_139(bool) = now > REF_78,REF_79(uint256) -> RoundTime[Round],TMP_140(bool) = REF_79 != 0,TMP_141(bool) = TMP_139 && TMP_140,TMP_142(None) = SOLIDITY_CALL require(bool)(TMP_141),Round_(uint256) := Round(uint256),TMP_143(uint256) := Round(uint256),Round(uint256) = Round + 1,REF_80(address) -> RoundLastDonationMan[Round_],REF_82(uint256) -> RoundETH[Round_],TMP_144(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_82', '80'] ,TMP_145(uint256) = TMP_144 / 100,Transfer dest:REF_80 value:TMP_145,REF_85(uint256) -> RoundETH[Round_],TMP_147(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_85', '20'] ,TMP_148(uint256) = TMP_147 / 100,Transfer dest:owner value:TMP_148,RoundIncrease(uint256) := 11(uint256),lasttimereduce(uint256) := now(uint256),REF_87(address) -> RoundLastDonationMan[Round_],REF_88(uint256) -> RoundETH[Round_],Emit winnerEvent(REF_87,REF_88,Round_),MODIFIER_CALL, PD88.isHuman()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now > RoundTime[Round] && RoundTime[Round] != 0)

IRs:
REF_78(uint256) -> RoundTime[Round]
TMP_139(bool) = now > REF_78
REF_79(uint256) -> RoundTime[Round]
TMP_140(bool) = REF_79 != 0
TMP_141(bool) = TMP_139 && TMP_140
TMP_142(None) = SOLIDITY_CALL require(bool)(TMP_141)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
Round_ = Round

IRs:
Round_(uint256) := Round(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Round ++

IRs:
TMP_143(uint256) := Round(uint256)
Round(uint256) = Round + 1""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
RoundLastDonationMan[Round_].transfer(RoundETH[Round_].mul(80) / 100)

IRs:
REF_80(address) -> RoundLastDonationMan[Round_]
REF_82(uint256) -> RoundETH[Round_]
TMP_144(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_82', '80'] 
TMP_145(uint256) = TMP_144 / 100
Transfer dest:REF_80 value:TMP_145""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
owner.transfer(RoundETH[Round_].mul(20) / 100)

IRs:
REF_85(uint256) -> RoundETH[Round_]
TMP_147(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_85', '20'] 
TMP_148(uint256) = TMP_147 / 100
Transfer dest:owner value:TMP_148""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
RoundIncrease = 11

IRs:
RoundIncrease(uint256) := 11(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
lasttimereduce = now

IRs:
lasttimereduce(uint256) := now(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
winnerEvent(RoundLastDonationMan[Round_],RoundETH[Round_],Round_)

IRs:
REF_87(address) -> RoundLastDonationMan[Round_]
REF_88(uint256) -> RoundETH[Round_]
Emit winnerEvent(REF_87,REF_88,Round_)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
isHuman()

IRs:
MODIFIER_CALL, PD88.isHuman()()""];
9->1;
}
",0,1,0,0,"isHuman();require(bool)(now > RoundTime[Round] && RoundTime[Round] != 0);Round_ = Round;Round ++;RoundLastDonationMan[Round_].transfer(RoundETH[Round_].mul(80) / 100);owner.transfer(RoundETH[Round_].mul(20) / 100);RoundIncrease = 11;lasttimereduce = now;winnerEvent(RoundLastDonationMan[Round_],RoundETH[Round_],Round_)"
./0xb39d10435d7d0f2ea26a1c86c42be0fd8a94f59b_ext.sol,TittyBase._transfer,36,48,"REF_0(uint256) -> ownerTittiesCount[_to],TMP_0(uint256) := REF_0(uint256),REF_0(-> ownerTittiesCount) = REF_0 + 1,REF_1(address) -> tittyIndexToOwner[_tittyId],REF_1(address) (->tittyIndexToOwner) := _to(address),TMP_1 = CONVERT 0 to address,TMP_2(bool) = _from != TMP_1,CONDITION TMP_2,REF_2(uint256) -> ownerTittiesCount[_from],TMP_3(uint256) := REF_2(uint256),REF_2(-> ownerTittiesCount) = REF_2 - 1,REF_3(address) -> tittyApproveIndex[_tittyId],tittyApproveIndex = delete REF_3 ,Emit Transfer(_from,_to)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownerTittiesCount[_to] ++

IRs:
REF_0(uint256) -> ownerTittiesCount[_to]
TMP_0(uint256) := REF_0(uint256)
REF_0(-> ownerTittiesCount) = REF_0 + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
tittyIndexToOwner[_tittyId] = _to

IRs:
REF_1(address) -> tittyIndexToOwner[_tittyId]
REF_1(address) (->tittyIndexToOwner) := _to(address)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_from != address(0)

IRs:
TMP_1 = CONVERT 0 to address
TMP_2(bool) = _from != TMP_1
CONDITION TMP_2""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownerTittiesCount[_from] --

IRs:
REF_2(uint256) -> ownerTittiesCount[_from]
TMP_3(uint256) := REF_2(uint256)
REF_2(-> ownerTittiesCount) = REF_2 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
delete tittyApproveIndex[_tittyId]

IRs:
REF_3(address) -> tittyApproveIndex[_tittyId]
tittyApproveIndex = delete REF_3 ""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to)

IRs:
Emit Transfer(_from,_to)""];
}
",0,1,0,0,"ownerTittiesCount[_to] ++;tittyIndexToOwner[_tittyId] = _to;_from != address(0);ownerTittiesCount[_from] --;;delete tittyApproveIndex[_tittyId];Transfer(_from,_to)"
./0x5c3d0012ff81bb9a19d13f8e512d3e72843f0848_ext.sol,RBAC.checkRole,17,22,"REF_0(Roles.Role) -> roles[_role],LIBRARY_CALL, dest:Roles, function:Roles.check(Roles.Role,address), arguments:['REF_0', '_operator'] ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
roles[_role].check(_operator)

IRs:
REF_0(Roles.Role) -> roles[_role]
LIBRARY_CALL, dest:Roles, function:Roles.check(Roles.Role,address), arguments:['REF_0', '_operator'] ""];
}
",0,1,0,0,roles[_role].check(_operator)
./0x0374b22e0727302e0d8db783726c7ec4989f88ad_ext.sol,GINI.approveAndCall,180,187,"TMP_90(bool) = INTERNAL_CALL, GINI.isContract(address)(_spender),TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),TMP_92 = CONVERT _spender to TokenRecipient,spender(TokenRecipient) := TMP_92(TokenRecipient),TMP_93(bool) = INTERNAL_CALL, GINI.approve(address,uint256)(_spender,_value),CONDITION TMP_93,HIGH_LEVEL_CALL, dest:spender(TokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isContract(_spender))

IRs:
TMP_90(bool) = INTERNAL_CALL, GINI.isContract(address)(_spender)
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
spender = TokenRecipient(_spender)

IRs:
TMP_92 = CONVERT _spender to TokenRecipient
spender(TokenRecipient) := TMP_92(TokenRecipient)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_93(bool) = INTERNAL_CALL, GINI.approve(address,uint256)(_spender,_value)
CONDITION TMP_93""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(TokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(isContract(_spender));spender = TokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x5abc07d28dcc3b60a164d57e4e3981a090c5d6de_ext.sol,BOMBBA.totalSupply,175,177,"TMP_53 = CONVERT 0 to address,REF_24(uint256) -> tokenBalances[TMP_53],TMP_54(uint256) = totalSupply - REF_24,RETURN TMP_54","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
totalSupply - tokenBalances[address(0)]

IRs:
TMP_53 = CONVERT 0 to address
REF_24(uint256) -> tokenBalances[TMP_53]
TMP_54(uint256) = totalSupply - REF_24
RETURN TMP_54""];
}
",0,1,0,0,totalSupply - tokenBalances[address(0)]
./0x882da60a19c67e481481bace4c0aa93080cde3d7_ext.sol,EthTranchePricing.getLastTranche,1427,1429,"TMP_755(uint256) = trancheCount - 1,REF_260(EthTranchePricing.Tranche) -> tranches[TMP_755],RETURN REF_260","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
tranches[trancheCount - 1]

IRs:
TMP_755(uint256) = trancheCount - 1
REF_260(EthTranchePricing.Tranche) -> tranches[TMP_755]
RETURN REF_260""];
}
",0,1,0,0,tranches[trancheCount - 1]
./0xaa6e73f27efdecb282baaba5914dc23a41fc233c_ext.sol,JILTOKEN.burnFrom,150,158,"REF_19(uint256) -> balanceOf[_from],TMP_26(bool) = REF_19 >= _value,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_28(bool) = _value <= REF_21,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_26(bool) = REF_19 >= _value
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_28(bool) = _value <= REF_21
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x6b0d7b8357bb851de9f1953199c39c7bc4675796_ext.sol,MyAdvancedToken.mintToken,208,213,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x7897ed74a2448c6d539b64c8b3c9b42fc19abc1f_ext.sol,Hourglass.dividendsOf,483,489,"REF_36(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_65(uint256) = profitPerShare_ * REF_36,TMP_66 = CONVERT TMP_65 to int256,REF_37(int256) -> payoutsTo_[_customerAddress],TMP_67(int256) = TMP_66 - REF_37,TMP_68 = CONVERT TMP_67 to uint256,TMP_69(uint256) = TMP_68 / magnitude,RETURN TMP_69","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_36(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_65(uint256) = profitPerShare_ * REF_36
TMP_66 = CONVERT TMP_65 to int256
REF_37(int256) -> payoutsTo_[_customerAddress]
TMP_67(int256) = TMP_66 - REF_37
TMP_68 = CONVERT TMP_67 to uint256
TMP_69(uint256) = TMP_68 / magnitude
RETURN TMP_69""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0xd0ffe3496101fd676b646ade429653d7df12edd2_ext.sol,ContractEFT.transferFrom,139,156,"REF_9(uint256) -> balances[_from],TMP_9(bool) = REF_9 >= _amount,TMP_10(bool) = _amount > 0,TMP_11(bool) = TMP_9 && TMP_10,REF_10(mapping(address => uint256)) -> allowed[_from],REF_11(uint256) -> REF_10[msg.sender],TMP_12(bool) = REF_11 >= _amount,TMP_13(bool) = TMP_11 && TMP_12,CONDITION TMP_13,REF_12(uint256) -> balances[_from],REF_12(-> balances) = REF_12 - _amount,REF_13(mapping(address => uint256)) -> allowed[_from],REF_14(uint256) -> REF_13[msg.sender],REF_14(-> allowed) = REF_14 - _amount,REF_15(uint256) -> balances[_to],REF_15(-> balances) = REF_15 + _amount,Emit Transfer(_from,_to,_amount),RETURN True,RETURN False,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balances[_from] >= _amount && _amount > 0 && allowed[_from][msg.sender] >= _amount

IRs:
REF_9(uint256) -> balances[_from]
TMP_9(bool) = REF_9 >= _amount
TMP_10(bool) = _amount > 0
TMP_11(bool) = TMP_9 && TMP_10
REF_10(mapping(address => uint256)) -> allowed[_from]
REF_11(uint256) -> REF_10[msg.sender]
TMP_12(bool) = REF_11 >= _amount
TMP_13(bool) = TMP_11 && TMP_12
CONDITION TMP_13""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[_from] -= _amount

IRs:
REF_12(uint256) -> balances[_from]
REF_12(-> balances) = REF_12 - _amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
allowed[_from][msg.sender] -= _amount

IRs:
REF_13(mapping(address => uint256)) -> allowed[_from]
REF_14(uint256) -> REF_13[msg.sender]
REF_14(-> allowed) = REF_14 - _amount""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] += _amount

IRs:
REF_15(uint256) -> balances[_to]
REF_15(-> balances) = REF_15 + _amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(_from,_to,_amount)

IRs:
Emit Transfer(_from,_to,_amount)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: RETURN 7

EXPRESSION:
false

IRs:
RETURN False""];
9[label=""Node Type: RETURN 9

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"balances[_from] >= _amount && _amount > 0 && allowed[_from][msg.sender] >= _amount;balances[_from] -= _amount;false;allowed[_from][msg.sender] -= _amount;balances[_to] += _amount;Transfer(_from,_to,_amount);true;success"
./0x51f4fcf219d79855341f749c0f1008c6066a2f1f_ext.sol,EQU.burnFrom,144,152,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x86d4bc8aebee12a65c376539cd92e42d60c260d0_ext.sol,PublicBank.mintToken,200,205,"REF_57(uint256) -> balanceOf[target],REF_57(-> balanceOf) = REF_57 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_57(uint256) -> balanceOf[target]
REF_57(-> balanceOf) = REF_57 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0xd3ac627abdc1ce6c27c04b37c86e368f754f2995_ext.sol,GradualPro.getQueueLength,178,180,"REF_33 -> LENGTH queue,TMP_50(uint256) = REF_33 - currentReceiverIndex,RETURN TMP_50","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
queue.length - currentReceiverIndex

IRs:
REF_33 -> LENGTH queue
TMP_50(uint256) = REF_33 - currentReceiverIndex
RETURN TMP_50""];
}
",0,1,0,0,queue.length - currentReceiverIndex
./0x5209647ee5d6247daddae470ccc6a282c642f6d8_ext.sol,ICOStartPromo.setSymbol,47,49,"symbol(string) := _symbol(string),MODIFIER_CALL, ICOStartPromo.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
symbol = _symbol

IRs:
symbol(string) := _symbol(string)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ICOStartPromo.onlyOwner()()""];
2->1;
}
",0,1,0,0,onlyOwner();symbol = _symbol
./0xf226b12c03514571c5a473b2627f5528da46d263_ext.sol,ECRecovery.recover,25,53,"REF_0 -> LENGTH sig,TMP_0(bool) = REF_0 != 65,CONDITION TMP_0,TMP_1 = CONVERT 0 to address,RETURN TMP_1,TMP_2(bool) = v < 27,CONDITION TMP_2,v(uint8) = v + 27,TMP_3(bool) = v != 27,TMP_4(bool) = v != 28,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,TMP_6 = CONVERT 0 to address,RETURN TMP_6,TMP_7(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(hash,v,r,s),RETURN TMP_7","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: NEW VARIABLE 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
sig.length != 65

IRs:
REF_0 -> LENGTH sig
TMP_0(bool) = REF_0 != 65
CONDITION TMP_0""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: RETURN 5

EXPRESSION:
(address(0))

IRs:
TMP_1 = CONVERT 0 to address
RETURN TMP_1""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: INLINE ASM 7
""];
7->8;
8[label=""Node Type: END INLINE ASM 8
""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
v < 27

IRs:
TMP_2(bool) = v < 27
CONDITION TMP_2""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
v += 27

IRs:
v(uint8) = v + 27""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
v != 27 && v != 28

IRs:
TMP_3(bool) = v != 27
TMP_4(bool) = v != 28
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: RETURN 13

EXPRESSION:
(address(0))

IRs:
TMP_6 = CONVERT 0 to address
RETURN TMP_6""];
14[label=""Node Type: RETURN 14

EXPRESSION:
ecrecover(bytes32,uint8,bytes32,bytes32)(hash,v,r,s)

IRs:
TMP_7(address) = SOLIDITY_CALL ecrecover(bytes32,uint8,bytes32,bytes32)(hash,v,r,s)
RETURN TMP_7""];
}
",0,1,0,0,";;;sig.length != 65;(address(0));;;;v < 27;v += 27;;v != 27 && v != 28;(address(0));ecrecover(bytes32,uint8,bytes32,bytes32)(hash,v,r,s)"
./0x9b481067ef9773d52efd0fb5b665a5dc0c8e1a68_ext.sol,ERCDDAToken.mintToken,65,68,"REF_11(uint256) -> balanceOf[target],REF_11(-> balanceOf) = REF_11 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,MODIFIER_CALL, ERCDDAToken.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_11(uint256) -> balanceOf[target]
REF_11(-> balanceOf) = REF_11 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ERCDDAToken.onlyOwner()()""];
3->1;
}
",0,1,0,0,onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount
./0xa5f1dbb0e55bc31f32c6d032bee330288490e722_ext.sol,DayByDayToken.totalSupply,124,126,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.getAllStaff,2,2,"RETURN staffaddress,MODIFIER_CALL, KahnDistributionCentre.onlyAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: RETURN 1

EXPRESSION:
staffaddress

IRs:
RETURN staffaddress""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyAdmin()()""];
2->1;
}
",0,1,1,0,onlyAdmin();staffaddress
./0x5c493a221ae9b49c3e45f2df8a3b34223855c1f4_ext.sol,ERC827Caller.makeCall,448,451,"TMP_128(bool) = LOW_LEVEL_CALL, dest:_target, function:call, arguments:['_data'] value:msg.value ,RETURN TMP_128","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_target.call.value(msg.value)(_data)

IRs:
TMP_128(bool) = LOW_LEVEL_CALL, dest:_target, function:call, arguments:['_data'] value:msg.value 
RETURN TMP_128""];
}
",0,1,0,0,_target.call.value(msg.value)(_data)
./0x361f5a02be315ed1241d8c2997d1fc35aaa27596_ext.sol,DinarETHCrypto.changeNameSymbol,227,230,"name(string) := _name(string),symbol(string) := _symbol(string),MODIFIER_CALL, DinarETHCrypto.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
name = _name

IRs:
name(string) := _name(string)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
symbol = _symbol

IRs:
symbol(string) := _symbol(string)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, DinarETHCrypto.onlyOwner()()""];
3->1;
}
",0,1,0,0,onlyOwner();name = _name;symbol = _symbol
./0x127a78da95f02d9139db64ea7d3f6de355975494_ext.sol,DACToken.airdrop,75,91,"REF_19 -> LENGTH _DACusers,TMP_29(bool) = REF_19 > 0,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),REF_20 -> LENGTH _DACusers,REF_21 -> LENGTH _values,TMP_31(bool) = REF_20 == REF_21,TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31),amount(uint256) := 0(uint256),i(uint256) := 0(uint256),i(uint256) := 0(uint256),REF_22 -> LENGTH _DACusers,TMP_33(bool) = i < REF_22,CONDITION TMP_33,REF_23(uint256) -> _values[i],TMP_34(uint256) = amount + REF_23,TMP_35(bool) = TMP_34 >= amount,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),REF_24(uint256) -> _values[i],amount(uint256) = amount + REF_24,TMP_37(uint256) := i(uint256),i(uint256) = i + 1,REF_25(uint256) -> balanceOf[msg.sender],TMP_38(bool) = REF_25 >= amount,TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38),REF_26(uint256) -> balanceOf[msg.sender],REF_26(-> balanceOf) = REF_26 - amount,i(uint256) := 0(uint256),REF_27 -> LENGTH _DACusers,TMP_40(bool) = i < REF_27,CONDITION TMP_40,REF_28(address) -> _DACusers[i],REF_29(uint256) -> balanceOf[REF_28],REF_30(uint256) -> _values[i],TMP_41(uint256) = REF_29 + REF_30,REF_31(address) -> _DACusers[i],REF_32(uint256) -> balanceOf[REF_31],TMP_42(bool) = TMP_41 >= REF_32,TMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42),REF_33(address) -> _DACusers[i],REF_34(uint256) -> balanceOf[REF_33],REF_35(uint256) -> _values[i],REF_34(-> balanceOf) = REF_34 + REF_35,REF_36(address) -> _DACusers[i],REF_37(uint256) -> _values[i],Emit Transfer(msg.sender,REF_36,REF_37),TMP_45(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, DACToken.isRunning()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->22;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_DACusers.length > 0)

IRs:
REF_19 -> LENGTH _DACusers
TMP_29(bool) = REF_19 > 0
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_DACusers.length == _values.length)

IRs:
REF_20 -> LENGTH _DACusers
REF_21 -> LENGTH _values
TMP_31(bool) = REF_20 == REF_21
TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
amount = 0

IRs:
amount(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->7;
5[label=""Node Type: BEGIN_LOOP 5
""];
5->8;
6[label=""Node Type: END_LOOP 6
""];
6->12;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
7->5;
8[label=""Node Type: IF_LOOP 8

EXPRESSION:
i < _DACusers.length

IRs:
REF_22 -> LENGTH _DACusers
TMP_33(bool) = i < REF_22
CONDITION TMP_33""];
8->9[label=""True""];
8->6[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(amount + _values[i] >= amount)

IRs:
REF_23(uint256) -> _values[i]
TMP_34(uint256) = amount + REF_23
TMP_35(bool) = TMP_34 >= amount
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
amount += _values[i]

IRs:
REF_24(uint256) -> _values[i]
amount(uint256) = amount + REF_24""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_37(uint256) := i(uint256)
i(uint256) = i + 1""];
11->8;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= amount)

IRs:
REF_25(uint256) -> balanceOf[msg.sender]
TMP_38(bool) = REF_25 >= amount
TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
balanceOf[msg.sender] -= amount

IRs:
REF_26(uint256) -> balanceOf[msg.sender]
REF_26(-> balanceOf) = REF_26 - amount""];
13->16;
14[label=""Node Type: BEGIN_LOOP 14
""];
14->17;
15[label=""Node Type: END_LOOP 15
""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
16->14;
17[label=""Node Type: IF_LOOP 17

EXPRESSION:
i < _DACusers.length

IRs:
REF_27 -> LENGTH _DACusers
TMP_40(bool) = i < REF_27
CONDITION TMP_40""];
17->18[label=""True""];
17->15[label=""False""];
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
require(bool)(balanceOf[_DACusers[i]] + _values[i] >= balanceOf[_DACusers[i]])

IRs:
REF_28(address) -> _DACusers[i]
REF_29(uint256) -> balanceOf[REF_28]
REF_30(uint256) -> _values[i]
TMP_41(uint256) = REF_29 + REF_30
REF_31(address) -> _DACusers[i]
REF_32(uint256) -> balanceOf[REF_31]
TMP_42(bool) = TMP_41 >= REF_32
TMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
balanceOf[_DACusers[i]] += _values[i]

IRs:
REF_33(address) -> _DACusers[i]
REF_34(uint256) -> balanceOf[REF_33]
REF_35(uint256) -> _values[i]
REF_34(-> balanceOf) = REF_34 + REF_35""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
Transfer(msg.sender,_DACusers[i],_values[i])

IRs:
REF_36(address) -> _DACusers[i]
REF_37(uint256) -> _values[i]
Emit Transfer(msg.sender,REF_36,REF_37)""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
i ++

IRs:
TMP_45(uint256) := i(uint256)
i(uint256) = i + 1""];
21->17;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
isRunning()

IRs:
MODIFIER_CALL, DACToken.isRunning()()""];
22->1;
}
",0,1,0,0,"isRunning();require(bool)(_DACusers.length > 0);require(bool)(_DACusers.length == _values.length);amount = 0;i = 0;i = 0;;i < _DACusers.length;;require(bool)(balanceOf[msg.sender] >= amount);require(bool)(amount + _values[i] >= amount);amount += _values[i];i ++;balanceOf[msg.sender] -= amount;i = 0;;i < _DACusers.length;;require(bool)(balanceOf[_DACusers[i]] + _values[i] >= balanceOf[_DACusers[i]]);balanceOf[_DACusers[i]] += _values[i];Transfer(msg.sender,_DACusers[i],_values[i]);i ++"
./0xdabd08643935a02fdf49cd6264f8d4de8e1feb69_ext.sol,DAX.burn,124,130,"REF_17(uint256) -> balanceOf[msg.sender],TMP_19(bool) = REF_17 >= _value,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_19(bool) = REF_17 >= _value
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x50c367245ae216e0e2699ba9b1d8e1645d8a7e6b_ext.sol,Data.subtrReferralDeposit,495,497,"REF_206(uint256) -> referralDeposits[_addr],REF_206(-> referralDeposits) = REF_206 - amount,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
referralDeposits[_addr] -= amount

IRs:
REF_206(uint256) -> referralDeposits[_addr]
REF_206(-> referralDeposits) = REF_206 - amount""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,1,0,0,onlyOwner();referralDeposits[_addr] -= amount
./0x126bba3aa97d9f6e98f56705f29ab02f7660b445_ext.sol,EducationTokens.symbol,98,100,"RETURN symbol,RETURN _symbol","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
symbol

IRs:
RETURN symbol""];
2[label=""Node Type: RETURN 2

EXPRESSION:
_symbol

IRs:
RETURN _symbol""];
}
",0,1,0,0,symbol;_symbol
./0xed462f6d5a89cc5cab505c0549c2a4e7bbd2522b_ext.sol,EVOLUTION2.dividendsOf,400,406,"REF_32(uint256) -> tokenBalanceLedger_[_customerAddress],TMP_64(uint256) = profitPerShare_ * REF_32,TMP_65 = CONVERT TMP_64 to int256,REF_33(int256) -> payoutsTo_[_customerAddress],TMP_66(int256) = TMP_65 - REF_33,TMP_67 = CONVERT TMP_66 to uint256,TMP_68(uint256) = TMP_67 / magnitude,RETURN TMP_68","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude

IRs:
REF_32(uint256) -> tokenBalanceLedger_[_customerAddress]
TMP_64(uint256) = profitPerShare_ * REF_32
TMP_65 = CONVERT TMP_64 to int256
REF_33(int256) -> payoutsTo_[_customerAddress]
TMP_66(int256) = TMP_65 - REF_33
TMP_67 = CONVERT TMP_66 to uint256
TMP_68(uint256) = TMP_67 / magnitude
RETURN TMP_68""];
}
",0,1,0,0,uint256(int256(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude
./0xf0d1a6dfcce7fb23fee76d8ed89e780c5a2c1885_ext.sol,CryptoSportZ.getUserTokens,384,399,"res(string) := (string),TMP_214(bool) = user != 0,TMP_215(None) = SOLIDITY_CALL require(bool)(TMP_214),findCount(uint32) := 0(uint256),TMP_216(uint256) = totalSupply - 1,i(uint256) := TMP_216(uint256),TMP_217(bool) = i >= 0,CONDITION TMP_217,TMP_218(bool) = i > totalSupply,CONDITION TMP_218,REF_103(address) -> tokenIndexToOwner[i],TMP_219(bool) = user == REF_103,CONDITION TMP_219,TMP_220(string) = INTERNAL_CALL, Functional.uint2str(uint256)(i),TMP_221(string) = INTERNAL_CALL, Functional.strConcat(string,string,string)(res,,,TMP_220),res(string) := TMP_221(string),TMP_222(uint32) := findCount(uint32),findCount(uint32) = findCount + 1,TMP_223(bool) = count != 0,TMP_224(bool) = findCount >= count,TMP_225(bool) = TMP_223 && TMP_224,CONDITION TMP_225,TMP_226(uint256) := i(uint256),i(uint256) = i - 1,RETURN res","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
res = 

IRs:
res(string) := (string)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(user != 0x0)

IRs:
TMP_214(bool) = user != 0
TMP_215(None) = SOLIDITY_CALL require(bool)(TMP_214)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
findCount = 0

IRs:
findCount(uint32) := 0(uint256)""];
3->6;
4[label=""Node Type: BEGIN_LOOP 4
""];
4->7;
5[label=""Node Type: END_LOOP 5
""];
5->19;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
i = totalSupply - 1

IRs:
TMP_216(uint256) = totalSupply - 1
i(uint256) := TMP_216(uint256)""];
6->4;
7[label=""Node Type: IF_LOOP 7

EXPRESSION:
i >= 0

IRs:
TMP_217(bool) = i >= 0
CONDITION TMP_217""];
7->8[label=""True""];
7->5[label=""False""];
8[label=""Node Type: IF 8

EXPRESSION:
i > totalSupply

IRs:
TMP_218(bool) = i > totalSupply
CONDITION TMP_218""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: BREAK 9
""];
9->5;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
user == tokenIndexToOwner[i]

IRs:
REF_103(address) -> tokenIndexToOwner[i]
TMP_219(bool) = user == REF_103
CONDITION TMP_219""];
11->12[label=""True""];
11->17[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
res = strConcat(res,,,uint2str(i))

IRs:
TMP_220(string) = INTERNAL_CALL, Functional.uint2str(uint256)(i)
TMP_221(string) = INTERNAL_CALL, Functional.strConcat(string,string,string)(res,,,TMP_220)
res(string) := TMP_221(string)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
findCount ++

IRs:
TMP_222(uint32) := findCount(uint32)
findCount(uint32) = findCount + 1""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
count != 0 && findCount >= count

IRs:
TMP_223(bool) = count != 0
TMP_224(bool) = findCount >= count
TMP_225(bool) = TMP_223 && TMP_224
CONDITION TMP_225""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: BREAK 15
""];
15->5;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
i --

IRs:
TMP_226(uint256) := i(uint256)
i(uint256) = i - 1""];
18->7;
19[label=""Node Type: RETURN 19

EXPRESSION:
res

IRs:
RETURN res""];
}
",0,1,0,0,"res =;require(bool)(user != 0x0);findCount = 0;i = totalSupply - 1;;i >= 0;;res;i > totalSupply;;;user == tokenIndexToOwner[i];res = strConcat(res,,,uint2str(i));;findCount ++;count != 0 && findCount >= count;;;i --"
./0x6faf33c051c0703ad2a6e86b373bb92bb30c8f5c_ext.sol,ClassSize.voteYes,19,22,"votesYes(uint16) = votesYes + 1,Emit VoteYes(note)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
votesYes += 1

IRs:
votesYes(uint16) = votesYes + 1""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
VoteYes(note)

IRs:
Emit VoteYes(note)""];
}
",0,1,0,0,votesYes += 1;VoteYes(note)
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.signupUserWhitelist,2,2,"REF_33 -> LENGTH _userlist,TMP_82(bool) = REF_33 > 0,TMP_83(None) = SOLIDITY_CALL require(bool)(TMP_82),REF_34 -> LENGTH _amount,TMP_84(bool) = REF_34 > 0,TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84),i(uint256) := 0(uint256),REF_35 -> LENGTH _userlist,TMP_86(bool) = i < REF_35,CONDITION TMP_86,REF_36(address) -> _userlist[i],baddr(address) := REF_36(address),REF_37(uint256) -> _amount[i],bval(uint256) := REF_37(uint256),TMP_87 = CONVERT 0 to address,TMP_88(bool) = baddr != TMP_87,TMP_89(bool) = userSignupCount <= maxSignup,TMP_90(bool) = TMP_88 && TMP_89,CONDITION TMP_90,REF_38(KahnDistributionCentre.User) -> bounties[baddr],REF_39(bool) -> REF_38.blacklisted,TMP_91 = UnaryType.BANG REF_39 ,REF_40(KahnDistributionCentre.User) -> bounties[baddr],REF_41(address) -> REF_40.user_address,TMP_92(bool) = REF_41 != baddr,TMP_93(bool) = TMP_91 && TMP_92,CONDITION TMP_93,REF_42(KahnDistributionCentre.User) -> bounties[baddr],TMP_94(KahnDistributionCentre.User) = new User(baddr,now,bval,False,0,0,True),REF_42(KahnDistributionCentre.User) (->bounties) := TMP_94(KahnDistributionCentre.User),REF_43(bool) -> signups[baddr],REF_43(bool) (->signups) := True(bool),REF_45 -> LENGTH bountyaddress,TMP_97(uint256) := REF_45(uint256),TMP_98(uint256) = TMP_97 + 1,REF_45(uint256) (->bountyaddress) := TMP_98(uint256),REF_46(address) -> bountyaddress[TMP_97],REF_46(address) (->bountyaddress) := baddr(address),TMP_96(None) = TMP_95 - 1,TMP_99(uint256) := userSignupCount(uint256),userSignupCount(uint256) = userSignupCount + 1,TMP_100(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, KahnDistributionCentre.onlyStaffs()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->18;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_userlist.length > 0)

IRs:
REF_33 -> LENGTH _userlist
TMP_82(bool) = REF_33 > 0
TMP_83(None) = SOLIDITY_CALL require(bool)(TMP_82)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amount.length > 0)

IRs:
REF_34 -> LENGTH _amount
TMP_84(bool) = REF_34 > 0
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)""];
2->5;
3[label=""Node Type: BEGIN_LOOP 3
""];
3->6;
4[label=""Node Type: END_LOOP 4
""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
5->3;
6[label=""Node Type: IF_LOOP 6

EXPRESSION:
i < _userlist.length

IRs:
REF_35 -> LENGTH _userlist
TMP_86(bool) = i < REF_35
CONDITION TMP_86""];
6->7[label=""True""];
6->4[label=""False""];
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
baddr = _userlist[i]

IRs:
REF_36(address) -> _userlist[i]
baddr(address) := REF_36(address)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
bval = _amount[i]

IRs:
REF_37(uint256) -> _amount[i]
bval(uint256) := REF_37(uint256)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
baddr != address(0) && userSignupCount <= maxSignup

IRs:
TMP_87 = CONVERT 0 to address
TMP_88(bool) = baddr != TMP_87
TMP_89(bool) = userSignupCount <= maxSignup
TMP_90(bool) = TMP_88 && TMP_89
CONDITION TMP_90""];
9->10[label=""True""];
9->16[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
! bounties[baddr].blacklisted && bounties[baddr].user_address != baddr

IRs:
REF_38(KahnDistributionCentre.User) -> bounties[baddr]
REF_39(bool) -> REF_38.blacklisted
TMP_91 = UnaryType.BANG REF_39 
REF_40(KahnDistributionCentre.User) -> bounties[baddr]
REF_41(address) -> REF_40.user_address
TMP_92(bool) = REF_41 != baddr
TMP_93(bool) = TMP_91 && TMP_92
CONDITION TMP_93""];
10->11[label=""True""];
10->15[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
bounties[baddr] = User(baddr,now,bval,false,0,0,true)

IRs:
REF_42(KahnDistributionCentre.User) -> bounties[baddr]
TMP_94(KahnDistributionCentre.User) = new User(baddr,now,bval,False,0,0,True)
REF_42(KahnDistributionCentre.User) (->bounties) := TMP_94(KahnDistributionCentre.User)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
signups[baddr] = true

IRs:
REF_43(bool) -> signups[baddr]
REF_43(bool) (->signups) := True(bool)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
bountyaddress.push(baddr) - 1

IRs:
REF_45 -> LENGTH bountyaddress
TMP_97(uint256) := REF_45(uint256)
TMP_98(uint256) = TMP_97 + 1
REF_45(uint256) (->bountyaddress) := TMP_98(uint256)
REF_46(address) -> bountyaddress[TMP_97]
REF_46(address) (->bountyaddress) := baddr(address)
TMP_96(None) = TMP_95 - 1""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
userSignupCount ++

IRs:
TMP_99(uint256) := userSignupCount(uint256)
userSignupCount(uint256) = userSignupCount + 1""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
i ++

IRs:
TMP_100(uint256) := i(uint256)
i(uint256) = i + 1""];
17->6;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
onlyStaffs()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyStaffs()()""];
18->1;
}
",0,1,1,0,"onlyStaffs();require(bool)(_userlist.length > 0);require(bool)(_amount.length > 0);i = 0;;i < _userlist.length;;baddr = _userlist[i];bval = _amount[i];baddr != address(0) && userSignupCount <= maxSignup;! bounties[baddr].blacklisted && bounties[baddr].user_address != baddr;;bounties[baddr] = User(baddr,now,bval,false,0,0,true);;signups[baddr] = true;bountyaddress.push(baddr) - 1;userSignupCount ++;i ++"
./0x5c65a8e333e5b0a932704bee2f28fdcc49d1e837_ext.sol,JawazToken.burn,128,134,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x184b8e35fea87e75498705ea96f2326db8ee2470_ext.sol,AirDrop.doAirDrop,69,80,"REF_0 -> LENGTH _address,count(uint256) := REF_0(uint256),i(uint256) := 0(uint256),TMP_13(bool) = i < count,CONDITION TMP_13,REF_2(address) -> _address[i],TMP_14(bool) = HIGH_LEVEL_CALL, dest:tokenInstance(Token), function:transfer, arguments:['REF_2', '_amount']  ,REF_3(address) -> _address[i],REF_4(uint256) = SOLIDITY_CALL balance(address)(REF_3),TMP_15(bool) = REF_4 == 0,REF_5(uint256) = SOLIDITY_CALL balance(address)(this),TMP_16(bool) = REF_5 >= _ethAmount,TMP_17(bool) = TMP_15 && TMP_16,CONDITION TMP_17,REF_6(address) -> _address[i],TMP_18 = SEND dest:REF_6 value:_ethAmount,TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18),TMP_20(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
count = _address.length

IRs:
REF_0 -> LENGTH _address
count(uint256) := REF_0(uint256)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < count

IRs:
TMP_13(bool) = i < count
CONDITION TMP_13""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tokenInstance.transfer(_address[i],_amount)

IRs:
REF_2(address) -> _address[i]
TMP_14(bool) = HIGH_LEVEL_CALL, dest:tokenInstance(Token), function:transfer, arguments:['REF_2', '_amount']  ""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
(_address[i].balance == 0) && (this.balance >= _ethAmount)

IRs:
REF_3(address) -> _address[i]
REF_4(uint256) = SOLIDITY_CALL balance(address)(REF_3)
TMP_15(bool) = REF_4 == 0
REF_5(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_16(bool) = REF_5 >= _ethAmount
TMP_17(bool) = TMP_15 && TMP_16
CONDITION TMP_17""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(_address[i].send(_ethAmount))

IRs:
REF_6(address) -> _address[i]
TMP_18 = SEND dest:REF_6 value:_ethAmount
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
i ++

IRs:
TMP_20(uint256) := i(uint256)
i(uint256) = i + 1""];
10->5;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
11->1;
}
",0,1,0,0,"onlyOwner();count = _address.length;i = 0;;i < count;;tokenInstance.transfer(_address[i],_amount);(_address[i].balance == 0) && (this.balance >= _ethAmount);require(bool)(_address[i].send(_ethAmount));;i ++"
./0x761341ca3b8186323e55c7e801ecbe9b5df41ad0_ext.sol,TokenERC20.approveAndCall,175,183,"TMP_70 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_70(tokenRecipient),TMP_71(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value),CONDITION TMP_71,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_70 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_70(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_71(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value)
CONDITION TMP_71""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0xf3bfe4b73faa6393f84f59354ebd71b1c4db53fc_ext.sol,TVToken.mint,81,85,"totalSupply(uint256) = totalSupply + _amount,REF_19(uint256) -> balanceOf[msg.sender],REF_19(-> balanceOf) = REF_19 + _amount,RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
totalSupply += _amount

IRs:
totalSupply(uint256) = totalSupply + _amount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] += _amount

IRs:
REF_19(uint256) -> balanceOf[msg.sender]
REF_19(-> balanceOf) = REF_19 + _amount""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,totalSupply += _amount;balanceOf[msg.sender] += _amount;true
./0x5cb654cdec88ee15f9e91c9b3a8cd4266f85c8f7_ext.sol,COINVR.totalSupply,124,126,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x4d66945d0b739574634b59190af51b4fe27858cc_ext.sol,MyToken.burnFrom,127,135,"REF_18(uint256) -> balanceOf[_from],TMP_29(bool) = REF_18 >= _value,TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29),REF_19(mapping(address => uint256)) -> allowance[_from],REF_20(uint256) -> REF_19[msg.sender],TMP_31(bool) = _value <= REF_20,TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31),REF_21(uint256) -> balanceOf[_from],REF_21(-> balanceOf) = REF_21 - _value,REF_22(mapping(address => uint256)) -> allowance[_from],REF_23(uint256) -> REF_22[msg.sender],REF_23(-> allowance) = REF_23 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_18(uint256) -> balanceOf[_from]
TMP_29(bool) = REF_18 >= _value
TMP_30(None) = SOLIDITY_CALL require(bool)(TMP_29)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_19(mapping(address => uint256)) -> allowance[_from]
REF_20(uint256) -> REF_19[msg.sender]
TMP_31(bool) = _value <= REF_20
TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_21(uint256) -> balanceOf[_from]
REF_21(-> balanceOf) = REF_21 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_22(mapping(address => uint256)) -> allowance[_from]
REF_23(uint256) -> REF_22[msg.sender]
REF_23(-> allowance) = REF_23 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x571df5a0b5571a3cc7dcbd8185b200426376845f_ext.sol,EBRK.burnFrom,140,148,"REF_19(uint256) -> balanceOf[_from],TMP_22(bool) = REF_19 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_24(bool) = _value <= REF_21,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_22(bool) = REF_19 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_24(bool) = _value <= REF_21
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0xd389c08bb987dd7daeb31f51fce1b5b73710b38e_ext.sol,MyAdvancedToken.mintToken,160,165,"REF_49(uint256) -> balanceOf[target],REF_49(-> balanceOf) = REF_49 + mintedAmount,totalSupply(uint256) = totalSupply + mintedAmount,Emit Transfer(0,this,mintedAmount),Emit Transfer(this,target,mintedAmount),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balanceOf[target] += mintedAmount

IRs:
REF_49(uint256) -> balanceOf[target]
REF_49(-> balanceOf) = REF_49 + mintedAmount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalSupply += mintedAmount

IRs:
totalSupply(uint256) = totalSupply + mintedAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(0,this,mintedAmount)

IRs:
Emit Transfer(0,this,mintedAmount)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(this,target,mintedAmount)

IRs:
Emit Transfer(this,target,mintedAmount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,1,0,0,"onlyOwner();balanceOf[target] += mintedAmount;totalSupply += mintedAmount;Transfer(0,this,mintedAmount);Transfer(this,target,mintedAmount)"
./0x0298d4d15bc4294386b05e5185d3833fc76924b3_ext.sol,ContractReceiver.tokenFallback,72,87,"REF_0(address) -> tkn.sender,REF_0(address) (->tkn) := _from(address),REF_1(uint256) -> tkn.value,REF_1(uint256) (->tkn) := _value(uint256),REF_2(bytes) -> tkn.data,REF_2(bytes) (->tkn) := _data(bytes),REF_3(None) -> _data[3],TMP_17 = CONVERT REF_3 to uint32,REF_4(None) -> _data[2],TMP_18 = CONVERT REF_4 to uint32,TMP_19(uint32) = TMP_18 << 8,TMP_20(uint32) = TMP_17 + TMP_19,REF_5(None) -> _data[1],TMP_21 = CONVERT REF_5 to uint32,TMP_22(uint32) = TMP_21 << 16,TMP_23(uint32) = TMP_20 + TMP_22,REF_6(None) -> _data[0],TMP_24 = CONVERT REF_6 to uint32,TMP_25(uint32) = TMP_24 << 24,TMP_26(uint32) = TMP_23 + TMP_25,u(uint32) := TMP_26(uint32),REF_7(bytes4) -> tkn.sig,TMP_27 = CONVERT u to bytes4,REF_7(bytes4) (->tkn) := TMP_27(bytes4)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
tkn.sender = _from

IRs:
REF_0(address) -> tkn.sender
REF_0(address) (->tkn) := _from(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tkn.value = _value

IRs:
REF_1(uint256) -> tkn.value
REF_1(uint256) (->tkn) := _value(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
tkn.data = _data

IRs:
REF_2(bytes) -> tkn.data
REF_2(bytes) (->tkn) := _data(bytes)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24)

IRs:
REF_3(None) -> _data[3]
TMP_17 = CONVERT REF_3 to uint32
REF_4(None) -> _data[2]
TMP_18 = CONVERT REF_4 to uint32
TMP_19(uint32) = TMP_18 << 8
TMP_20(uint32) = TMP_17 + TMP_19
REF_5(None) -> _data[1]
TMP_21 = CONVERT REF_5 to uint32
TMP_22(uint32) = TMP_21 << 16
TMP_23(uint32) = TMP_20 + TMP_22
REF_6(None) -> _data[0]
TMP_24 = CONVERT REF_6 to uint32
TMP_25(uint32) = TMP_24 << 24
TMP_26(uint32) = TMP_23 + TMP_25
u(uint32) := TMP_26(uint32)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tkn.sig = bytes4(u)

IRs:
REF_7(bytes4) -> tkn.sig
TMP_27 = CONVERT u to bytes4
REF_7(bytes4) (->tkn) := TMP_27(bytes4)""];
}
",0,1,0,0,;tkn.sender = _from;tkn.value = _value;tkn.data = _data;u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);tkn.sig = bytes4(u)
./0x5c0669c6718bf35112d4e643fe80bf7fb06dedeb_ext.sol,NOUR.transfer,95,105,"REF_1(uint256) -> balances[msg.sender],TMP_21(bool) = REF_1 >= _value,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),TMP_23(bool) = msg.sender == _to,REF_2(uint256) -> balances[_to],TMP_24(uint256) = MAX_UINT256 - _value,TMP_25(bool) = REF_2 <= TMP_24,TMP_26(bool) = TMP_23 || TMP_25,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),REF_3(uint256) -> balances[msg.sender],REF_3(-> balances) = REF_3 - _value,REF_4(uint256) -> balances[_to],REF_4(-> balances) = REF_4 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_21(bool) = REF_1 >= _value
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == _to || balances[_to] <= MAX_UINT256 - _value)

IRs:
TMP_23(bool) = msg.sender == _to
REF_2(uint256) -> balances[_to]
TMP_24(uint256) = MAX_UINT256 - _value
TMP_25(bool) = REF_2 <= TMP_24
TMP_26(bool) = TMP_23 || TMP_25
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_3(uint256) -> balances[msg.sender]
REF_3(-> balances) = REF_3 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[_to] += _value

IRs:
REF_4(uint256) -> balances[_to]
REF_4(-> balances) = REF_4 + _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);require(bool)(msg.sender == _to || balances[_to] <= MAX_UINT256 - _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true"
./0x4027c7262554ba72ccc3e346c6b71794299d3b99_ext.sol,CWT._transfer,42,58,"TMP_3(bool) = _to != 0,TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3),REF_1(uint256) -> balanceOf[_from],TMP_5(bool) = REF_1 >= _value,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_2(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_8(bool) = TMP_7 >= REF_3,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_10(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_10(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_12(uint256) = REF_8 + REF_9,TMP_13(bool) = TMP_12 == previousBalances,TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_3(bool) = _to != 0
TMP_4(None) = SOLIDITY_CALL require(bool)(TMP_3)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_5(bool) = REF_1 >= _value
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_8(bool) = TMP_7 >= REF_3
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_10(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_10(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_12(uint256) = REF_8 + REF_9
TMP_13(bool) = TMP_12 == previousBalances
TMP_14(None) = SOLIDITY_CALL assert(bool)(TMP_13)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x51257ce076e3b4a2c4de2763e442ea2bf2c61e2c_ext.sol,jiangguilong1.burnFrom,71,79,"REF_19(uint256) -> balanceOf[_from],TMP_25(bool) = REF_19 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_20(mapping(address => uint256)) -> allowance[_from],REF_21(uint256) -> REF_20[msg.sender],TMP_27(bool) = _value <= REF_21,TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27),REF_22(uint256) -> balanceOf[_from],REF_22(-> balanceOf) = REF_22 - _value,REF_23(mapping(address => uint256)) -> allowance[_from],REF_24(uint256) -> REF_23[msg.sender],REF_24(-> allowance) = REF_24 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_19(uint256) -> balanceOf[_from]
TMP_25(bool) = REF_19 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_20(mapping(address => uint256)) -> allowance[_from]
REF_21(uint256) -> REF_20[msg.sender]
TMP_27(bool) = _value <= REF_21
TMP_28(None) = SOLIDITY_CALL require(bool)(TMP_27)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_22(uint256) -> balanceOf[_from]
REF_22(-> balanceOf) = REF_22 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_23(mapping(address => uint256)) -> allowance[_from]
REF_24(uint256) -> REF_23[msg.sender]
REF_24(-> allowance) = REF_24 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x5575fb6f191ca376de2b36e023d1b1968d870ac9_ext.sol,AquaToken.totalSupply,130,132,"TMP_44 = CONVERT 0 to address,REF_1(uint256) -> balances[TMP_44],TMP_45(uint256) = _totalSupply - REF_1,RETURN TMP_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
_totalSupply - balances[address(0)]

IRs:
TMP_44 = CONVERT 0 to address
REF_1(uint256) -> balances[TMP_44]
TMP_45(uint256) = _totalSupply - REF_1
RETURN TMP_45""];
}
",0,1,0,0,_totalSupply - balances[address(0)]
./0x6ab4c5563213ea49d3475d8b53f6fec918871d90_ext.sol,DENMARK_WINS.transferFrom,42,54,"REF_6(uint256) -> balanceOf[from],TMP_6(bool) = value <= REF_6,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_7(mapping(address => uint256)) -> allowance[from],REF_8(uint256) -> REF_7[msg.sender],TMP_8(bool) = value <= REF_8,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_9(uint256) -> balanceOf[from],REF_9(-> balanceOf) = REF_9 - value,REF_10(uint256) -> balanceOf[to],REF_10(-> balanceOf) = REF_10 + value,REF_11(mapping(address => uint256)) -> allowance[from],REF_12(uint256) -> REF_11[msg.sender],REF_12(-> allowance) = REF_12 - value,Emit Transfer(from,to,value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(value <= balanceOf[from])

IRs:
REF_6(uint256) -> balanceOf[from]
TMP_6(bool) = value <= REF_6
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value <= allowance[from][msg.sender])

IRs:
REF_7(mapping(address => uint256)) -> allowance[from]
REF_8(uint256) -> REF_7[msg.sender]
TMP_8(bool) = value <= REF_8
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[from] -= value

IRs:
REF_9(uint256) -> balanceOf[from]
REF_9(-> balanceOf) = REF_9 - value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[to] += value

IRs:
REF_10(uint256) -> balanceOf[to]
REF_10(-> balanceOf) = REF_10 + value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
allowance[from][msg.sender] -= value

IRs:
REF_11(mapping(address => uint256)) -> allowance[from]
REF_12(uint256) -> REF_11[msg.sender]
REF_12(-> allowance) = REF_12 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(value <= balanceOf[from]);require(bool)(value <= allowance[from][msg.sender]);balanceOf[from] -= value;balanceOf[to] += value;allowance[from][msg.sender] -= value;Transfer(from,to,value);true;success"
./0xee6189995391e82bc48c8bed50285767c60d807f_ext.sol,TokenERC20.burn,61,67,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x4839e3de8737769e0f93f176d157dca5e48b7662_ext.sol,CPCToken.transfer,32,38,"REF_1(uint256) -> balances[msg.sender],TMP_0(bool) = REF_1 >= _value,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_2(uint256) -> balances[msg.sender],REF_2(-> balances) = REF_2 - _value,REF_3(uint256) -> balances[_to],REF_3(-> balances) = REF_3 + _value,Emit Transfer(msg.sender,_to,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] >= _value)

IRs:
REF_1(uint256) -> balances[msg.sender]
TMP_0(bool) = REF_1 >= _value
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= _value

IRs:
REF_2(uint256) -> balances[msg.sender]
REF_2(-> balances) = REF_2 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[_to] += _value

IRs:
REF_3(uint256) -> balances[_to]
REF_3(-> balances) = REF_3 + _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Transfer(msg.sender,_to,_value)

IRs:
Emit Transfer(msg.sender,_to,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balances[msg.sender] >= _value);balances[msg.sender] -= _value;balances[_to] += _value;Transfer(msg.sender,_to,_value);true;success"
./0x4b96090b1653ec92fd47337593e8a99b4cf902a1_ext.sol,RegularToken.transferFrom,90,109,RETURN success,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: RETURN 1

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,success
./0x3fcf5261c035c26fd2644955968bc940f1b1dc78_ext.sol,EdwinCToken._transfer,43,59,"TMP_0(bool) = _to != 0,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),REF_1(uint256) -> balanceOf[_from],TMP_2(bool) = REF_1 >= _value,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) -> balanceOf[_to],TMP_4(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_5(bool) = TMP_4 >= REF_3,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_7(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_7(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_9(uint256) = REF_8 + REF_9,TMP_10(bool) = TMP_9 == previousBalances,TMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_0(bool) = _to != 0
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_2(bool) = REF_1 >= _value
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_4(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_5(bool) = TMP_4 >= REF_3
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_7(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_7(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_9(uint256) = REF_8 + REF_9
TMP_10(bool) = TMP_9 == previousBalances
TMP_11(None) = SOLIDITY_CALL assert(bool)(TMP_10)""];
}
",0,1,0,0,"require(bool)(_to != 0x0);require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x480b94c1c794299157765988746cd97bea20a9b9_ext.sol,TasnimCoin._transfer,47,63,"TMP_3 = CONVERT 0 to address,TMP_4(bool) = _to != TMP_3,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_1(uint256) -> balanceOf[_from],TMP_6(bool) = REF_1 >= _value,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_2(uint256) -> balanceOf[_to],TMP_8(uint256) = REF_2 + _value,REF_3(uint256) -> balanceOf[_to],TMP_9(bool) = TMP_8 >= REF_3,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_4(uint256) -> balanceOf[_from],REF_5(uint256) -> balanceOf[_to],TMP_11(uint256) = REF_4 + REF_5,previousBalances(uint256) := TMP_11(uint256),REF_6(uint256) -> balanceOf[_from],REF_6(-> balanceOf) = REF_6 - _value,REF_7(uint256) -> balanceOf[_to],REF_7(-> balanceOf) = REF_7 + _value,Emit Transfer(_from,_to,_value),REF_8(uint256) -> balanceOf[_from],REF_9(uint256) -> balanceOf[_to],TMP_13(uint256) = REF_8 + REF_9,TMP_14(bool) = TMP_13 == previousBalances,TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0x0))

IRs:
TMP_3 = CONVERT 0 to address
TMP_4(bool) = _to != TMP_3
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_1(uint256) -> balanceOf[_from]
TMP_6(bool) = REF_1 >= _value
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(balanceOf[_to] + _value >= balanceOf[_to])

IRs:
REF_2(uint256) -> balanceOf[_to]
TMP_8(uint256) = REF_2 + _value
REF_3(uint256) -> balanceOf[_to]
TMP_9(bool) = TMP_8 >= REF_3
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalances = balanceOf[_from] + balanceOf[_to]

IRs:
REF_4(uint256) -> balanceOf[_from]
REF_5(uint256) -> balanceOf[_to]
TMP_11(uint256) = REF_4 + REF_5
previousBalances(uint256) := TMP_11(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_6(uint256) -> balanceOf[_from]
REF_6(-> balanceOf) = REF_6 - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[_to] += _value

IRs:
REF_7(uint256) -> balanceOf[_to]
REF_7(-> balanceOf) = REF_7 + _value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(_from,_to,_value)

IRs:
Emit Transfer(_from,_to,_value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)

IRs:
REF_8(uint256) -> balanceOf[_from]
REF_9(uint256) -> balanceOf[_to]
TMP_13(uint256) = REF_8 + REF_9
TMP_14(bool) = TMP_13 == previousBalances
TMP_15(None) = SOLIDITY_CALL assert(bool)(TMP_14)""];
}
",0,1,0,0,"require(bool)(_to != address(0x0));require(bool)(balanceOf[_from] >= _value);require(bool)(balanceOf[_to] + _value >= balanceOf[_to]);previousBalances = balanceOf[_from] + balanceOf[_to];balanceOf[_from] -= _value;balanceOf[_to] += _value;Transfer(_from,_to,_value);assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)"
./0x28b07e3fe42cd85177bcbbad8e4b60e9e19aac0e_ext.sol,TokenERC20.approveAndCall,130,138,"TMP_22 = CONVERT _spender to tokenRecipient,spender(tokenRecipient) := TMP_22(tokenRecipient),TMP_23(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value),CONDITION TMP_23,HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
spender = tokenRecipient(_spender)

IRs:
TMP_22 = CONVERT _spender to tokenRecipient
spender(tokenRecipient) := TMP_22(tokenRecipient)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
approve(_spender,_value)

IRs:
TMP_23(bool) = INTERNAL_CALL, TokenERC20.approve(address,uint256)(_spender,_value)
CONDITION TMP_23""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
spender.receiveApproval(msg.sender,_value,this,_extraData)

IRs:
HIGH_LEVEL_CALL, dest:spender(tokenRecipient), function:receiveApproval, arguments:['msg.sender', '_value', 'this', '_extraData']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"spender = tokenRecipient(_spender);approve(_spender,_value);spender.receiveApproval(msg.sender,_value,this,_extraData);;true;success"
./0x52a4b11b23587467b54a49ec0ccb47436526f714_ext.sol,DoacaoEvento.fallback,53,58,"TMP_18(bool) = msg.value > 0,REF_7(DoacaoEvento.StatusDoacao) -> StatusDoacao.ABERTO,TMP_19(bool) = statusDoacao == REF_7,TMP_20(bool) = TMP_18 && TMP_19,TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20),Emit LogDoacaoRecebida(msg.sender,msg.value),TMP_23(DoacaoEvento.Doador) = new Doador(msg.sender,msg.value,block.timestamp),d(DoacaoEvento.Doador) := TMP_23(DoacaoEvento.Doador),REF_9 -> LENGTH doadores,TMP_25(uint256) := REF_9(uint256),TMP_26(uint256) = TMP_25 + 1,REF_9(uint256) (->doadores) := TMP_26(uint256),REF_10(DoacaoEvento.Doador) -> doadores[TMP_25],REF_10(DoacaoEvento.Doador) (->doadores) := d(DoacaoEvento.Doador)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value > 0 && statusDoacao == StatusDoacao.ABERTO)

IRs:
TMP_18(bool) = msg.value > 0
REF_7(DoacaoEvento.StatusDoacao) -> StatusDoacao.ABERTO
TMP_19(bool) = statusDoacao == REF_7
TMP_20(bool) = TMP_18 && TMP_19
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
LogDoacaoRecebida(msg.sender,msg.value)

IRs:
Emit LogDoacaoRecebida(msg.sender,msg.value)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
d = Doador(msg.sender,msg.value,block.timestamp)

IRs:
TMP_23(DoacaoEvento.Doador) = new Doador(msg.sender,msg.value,block.timestamp)
d(DoacaoEvento.Doador) := TMP_23(DoacaoEvento.Doador)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
doadores.push(d)

IRs:
REF_9 -> LENGTH doadores
TMP_25(uint256) := REF_9(uint256)
TMP_26(uint256) = TMP_25 + 1
REF_9(uint256) (->doadores) := TMP_26(uint256)
REF_10(DoacaoEvento.Doador) -> doadores[TMP_25]
REF_10(DoacaoEvento.Doador) (->doadores) := d(DoacaoEvento.Doador)""];
}
",0,1,0,0,"require(bool)(msg.value > 0 && statusDoacao == StatusDoacao.ABERTO);LogDoacaoRecebida(msg.sender,msg.value);d = Doador(msg.sender,msg.value,block.timestamp);doadores.push(d)"
./0x268f03c41d3f33a697eed9c7f0632053556fae9e_ext.sol,BountyClaims.setGroupBounty,156,160,"i(uint256) := 0(uint256),REF_4 -> LENGTH _beneficiaries,TMP_34(bool) = i < REF_4,CONDITION TMP_34,REF_5(address) -> _beneficiaries[i],REF_6(uint256) -> bountyTokens[REF_5],REF_6(uint256) (->bountyTokens) := _amount(uint256),TMP_35(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _beneficiaries.length

IRs:
REF_4 -> LENGTH _beneficiaries
TMP_34(bool) = i < REF_4
CONDITION TMP_34""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
bountyTokens[_beneficiaries[i]] = _amount

IRs:
REF_5(address) -> _beneficiaries[i]
REF_6(uint256) -> bountyTokens[REF_5]
REF_6(uint256) (->bountyTokens) := _amount(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i ++

IRs:
TMP_35(uint256) := i(uint256)
i(uint256) = i + 1""];
6->4;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->3;
}
",0,1,0,0,onlyOwner();;i < _beneficiaries.length;;i = 0;bountyTokens[_beneficiaries[i]] = _amount;i ++
./0x52fe31c97e5c29ea63cbcfb045e1171427bb9248_ext.sol,NewRich.approveAndCall,200,205,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0x84148e0e8332e5a965ae33aacb84b6b1a3901dc5_ext.sol,TokenERC20.burn,157,163,"REF_17(uint256) -> balanceOf[msg.sender],TMP_25(bool) = REF_17 >= _value,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_25(bool) = REF_17 >= _value
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0xcf5a08af322e52bee93861341f7bd90eb3d65aa3_ext.sol,HeavyLitecoin.approveAndCall,201,206,"REF_19(mapping(address => uint256)) -> allowed[msg.sender],REF_20(uint256) -> REF_19[spender],REF_20(uint256) (->allowed) := tokens(uint256),Emit Approval(msg.sender,spender,tokens),TMP_55 = CONVERT spender to ApproveAndCallFallBack,HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ,RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
allowed[msg.sender][spender] = tokens

IRs:
REF_19(mapping(address => uint256)) -> allowed[msg.sender]
REF_20(uint256) -> REF_19[spender]
REF_20(uint256) (->allowed) := tokens(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Approval(msg.sender,spender,tokens)

IRs:
Emit Approval(msg.sender,spender,tokens)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data)

IRs:
TMP_55 = CONVERT spender to ApproveAndCallFallBack
HIGH_LEVEL_CALL, dest:TMP_55(ApproveAndCallFallBack), function:receiveApproval, arguments:['msg.sender', 'tokens', 'this', 'data']  ""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"allowed[msg.sender][spender] = tokens;Approval(msg.sender,spender,tokens);ApproveAndCallFallBack(spender).receiveApproval(msg.sender,tokens,this,data);true;success"
./0xcf5229653f1badd37ccedd1f96f6171715f28673_ext.sol,TMCToken.burn,84,90,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x4900320fe47208de0b79db1273a78ab8c8f3528d_ext.sol,Crowdsale.getRemainingTimeEthToken,155,183,"TMP_80(bool) = now < deadline,CONDITION TMP_80,TMP_81(uint256) = deadline - now,TMP_82(uint256) = TMP_81 / 86400,remain_days(uint256) := TMP_82(uint256),TMP_83(uint256) = deadline - now,TMP_84(uint256) = TMP_83 / 3600,remain_hours(uint256) := TMP_84(uint256),TMP_85(uint256) = deadline - now,TMP_86(uint256) = TMP_85 / 60,remain_minutes(uint256) := TMP_86(uint256),TMP_87(uint256) = deadline - now,TMP_88(uint256) = TMP_87 / 1,remain_seconds(uint256) := TMP_88(uint256),now_time(uint256) := now(uint256),now_deadline(uint256) := deadline(uint256),REF_16(uint256) = SOLIDITY_CALL balance(address)(this),TMP_89(uint256) = fundingGoal - REF_16,TMP_90(uint256) = TMP_89 / 1000000000000000000,remainEth(uint256) := TMP_90(uint256),TMP_91(uint256) = transferableToken - soldToken,remainToken(uint256) := TMP_91(uint256),REF_17(uint256) = SOLIDITY_CALL balance(address)(this),TMP_92([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E4231D90>]) = REF_17 / 1000000000000000000,getEth(uint256) := TMP_92([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E4231D90>]),TMP_93(uint256) = HIGH_LEVEL_CALL, dest:tokenReward(MontexToken), function:balanceOf, arguments:['this']  ,tokenReward_balance(uint256) := TMP_93(uint256),transferable_token(uint256) := transferableToken(uint256),RETURN now_time,now_deadline,remain_days,remain_hours,remain_minutes,remainEth,remainToken,remain_seconds,getEth,tokenReward_balance,transferable_token","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
now < deadline

IRs:
TMP_80(bool) = now < deadline
CONDITION TMP_80""];
1->2[label=""True""];
1->8[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
remain_days = (deadline - now) / (86400)

IRs:
TMP_81(uint256) = deadline - now
TMP_82(uint256) = TMP_81 / 86400
remain_days(uint256) := TMP_82(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
remain_hours = (deadline - now) / (3600)

IRs:
TMP_83(uint256) = deadline - now
TMP_84(uint256) = TMP_83 / 3600
remain_hours(uint256) := TMP_84(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
remain_minutes = (deadline - now) / (60)

IRs:
TMP_85(uint256) = deadline - now
TMP_86(uint256) = TMP_85 / 60
remain_minutes(uint256) := TMP_86(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
remain_seconds = (deadline - now) / (1)

IRs:
TMP_87(uint256) = deadline - now
TMP_88(uint256) = TMP_87 / 1
remain_seconds(uint256) := TMP_88(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
now_time = now

IRs:
now_time(uint256) := now(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
now_deadline = deadline

IRs:
now_deadline(uint256) := deadline(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
remainEth = (fundingGoal - this.balance) / (1000000000000000000)

IRs:
REF_16(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_89(uint256) = fundingGoal - REF_16
TMP_90(uint256) = TMP_89 / 1000000000000000000
remainEth(uint256) := TMP_90(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
remainToken = transferableToken - soldToken

IRs:
TMP_91(uint256) = transferableToken - soldToken
remainToken(uint256) := TMP_91(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
getEth = this.balance / (1000000000000000000)

IRs:
REF_17(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_92([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E4231D90>]) = REF_17 / 1000000000000000000
getEth(uint256) := TMP_92([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E4231D90>])""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
tokenReward_balance = tokenReward.balanceOf(this)

IRs:
TMP_93(uint256) = HIGH_LEVEL_CALL, dest:tokenReward(MontexToken), function:balanceOf, arguments:['this']  
tokenReward_balance(uint256) := TMP_93(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
transferable_token = transferableToken

IRs:
transferable_token(uint256) := transferableToken(uint256)""];
13->14;
14[label=""Node Type: RETURN 14

EXPRESSION:
(now_time,now_deadline,remain_days,remain_hours,remain_minutes,remainEth,remainToken,remain_seconds,getEth,tokenReward_balance,transferable_token)

IRs:
RETURN now_time,now_deadline,remain_days,remain_hours,remain_minutes,remainEth,remainToken,remain_seconds,getEth,tokenReward_balance,transferable_token""];
}
",0,1,0,0,"now < deadline;remain_days = (deadline - now) / (86400);;remain_hours = (deadline - now) / (3600);remain_minutes = (deadline - now) / (60);remain_seconds = (deadline - now) / (1);now_time = now;now_deadline = deadline;remainEth = (fundingGoal - this.balance) / (1000000000000000000);remainToken = transferableToken - soldToken;getEth = this.balance / (1000000000000000000);tokenReward_balance = tokenReward.balanceOf(this);transferable_token = transferableToken;(now_time,now_deadline,remain_days,remain_hours,remain_minutes,remainEth,remainToken,remain_seconds,getEth,tokenReward_balance,transferable_token)"
./0x006b4425ba57148466c0c54af1c484348a14a8a4_ext.sol,Crowdsale._handleTransaction,856,921,"TMP_155(bool) = now >= start,TMP_156(bool) = now <= crowdsaleEnd,TMP_157(bool) = TMP_155 && TMP_156,TMP_158(None) = SOLIDITY_CALL require(bool)(TMP_157),TMP_159(bool) = INTERNAL_CALL, Crowdsale.isAcceptedContributor(address)(_sender),TMP_160(None) = SOLIDITY_CALL require(bool)(TMP_159),TMP_161(bool) = INTERNAL_CALL, Crowdsale.isInPresalePhase()(),presalePhase(bool) := TMP_161(bool),TMP_162 = UnaryType.BANG presalePhase ,TMP_163(bool) = _received >= minAcceptedAmountPresale,TMP_164(bool) = TMP_162 || TMP_163,TMP_165(None) = SOLIDITY_CALL require(bool)(TMP_164),TMP_166 = UnaryType.BANG presalePhase ,TMP_167(bool) = raised < maxAmountPresale,TMP_168(bool) = TMP_166 || TMP_167,TMP_169(None) = SOLIDITY_CALL require(bool)(TMP_168),TMP_170(bool) = _received >= minAcceptedAmount,TMP_171(bool) = presalePhase || TMP_170,TMP_172(None) = SOLIDITY_CALL require(bool)(TMP_171),TMP_173(bool) = raised >= minAmountPresale,TMP_174(bool) = presalePhase || TMP_173,TMP_175(None) = SOLIDITY_CALL require(bool)(TMP_174),TMP_176(bool) = raised < maxAmount,TMP_177(bool) = presalePhase || TMP_176,TMP_178(None) = SOLIDITY_CALL require(bool)(TMP_177),TMP_179(uint256) = raised + _received,TMP_180(bool) = TMP_179 > maxAmountPresale,TMP_181(bool) = presalePhase && TMP_180,CONDITION TMP_181,TMP_182(uint256) = maxAmountPresale - raised,acceptedAmount(uint256) := TMP_182(uint256),TMP_183(uint256) = raised + _received,TMP_184(bool) = TMP_183 > maxAmount,CONDITION TMP_184,TMP_185(uint256) = maxAmount - raised,acceptedAmount(uint256) := TMP_185(uint256),acceptedAmount(uint256) := _received(uint256),raised(uint256) = raised + acceptedAmount,CONDITION presalePhase,INTERNAL_CALL, Crowdsale._allocateStakeholdersEth(uint256,uint256)(acceptedAmount,0),REF_134(uint256) -> balances[_sender],REF_134(-> balances) = REF_134 + acceptedAmount,tokensToIssue(uint256) := 0(uint256),TMP_187(uint256) = INTERNAL_CALL, Crowdsale.getCurrentPhase()(),phase(uint256) := TMP_187(uint256),TMP_188(uint256) = INTERNAL_CALL, Crowdsale.getRate(uint256,uint256)(phase,acceptedAmount),rate(uint256) := TMP_188(uint256),TUPLE_0(uint256[],uint256[]) = INTERNAL_CALL, Crowdsale.getDistributionData(uint256,uint256)(phase,acceptedAmount),volumes(uint256[1])= UNPACK TUPLE_0 index: 0 ,releaseDates(uint256[1])= UNPACK TUPLE_0 index: 1 ,i(uint256) := 0(uint256),REF_135 -> LENGTH volumes,TMP_189(bool) = i < REF_135,CONDITION TMP_189,REF_136(uint256) -> volumes[i],TMP_190(uint256) = INTERNAL_CALL, Crowdsale.toTokens(uint256,uint256)(REF_136,rate),tokensAtCurrentRate(uint256) := TMP_190(uint256),TMP_191(bool) = rate > baseRate,REF_137(uint256) -> releaseDates[i],TMP_192(bool) = REF_137 > now,TMP_193(bool) = TMP_191 && TMP_192,CONDITION TMP_193,TMP_194(uint256) = tokensAtCurrentRate / rate,TMP_195(uint256) = rate - baseRate,TMP_196(uint256) = TMP_194 * TMP_195,bonusTokens(uint256) := TMP_196(uint256),REF_138(uint256) -> releaseDates[i],INTERNAL_CALL, Crowdsale._allocateTokens(address,uint256,uint256)(_sender,bonusTokens,REF_138),TMP_198(uint256) = tokensAtCurrentRate - bonusTokens,tokensToIssue(uint256) = tokensToIssue + TMP_198,tokensToIssue(uint256) = tokensToIssue + tokensAtCurrentRate,TMP_199(uint256) := i(uint256),i(uint256) = i + 1,TMP_200(bool) = tokensToIssue > 0,TMP_201(bool) = HIGH_LEVEL_CALL, dest:token(IManagedToken), function:issue, arguments:['_sender', 'tokensToIssue']  ,TMP_202 = UnaryType.BANG TMP_201 ,TMP_203(bool) = TMP_200 && TMP_202,CONDITION TMP_203,TMP_204(None) = SOLIDITY_CALL revert()(),TMP_205(uint256) = _received - acceptedAmount,TMP_206(bool) = TMP_205 > 0,TMP_207(uint256) = _received - acceptedAmount,TMP_208 = SEND dest:_sender value:TMP_207,TMP_209 = UnaryType.BANG TMP_208 ,TMP_210(bool) = TMP_206 && TMP_209,CONDITION TMP_210,TMP_211(None) = SOLIDITY_CALL revert()(),REF_141(Crowdsale.Stages) -> Stages.InProgress,MODIFIER_CALL, Crowdsale.at_stage(Crowdsale.Stages)(REF_141)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->46;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now >= start && now <= crowdsaleEnd)

IRs:
TMP_155(bool) = now >= start
TMP_156(bool) = now <= crowdsaleEnd
TMP_157(bool) = TMP_155 && TMP_156
TMP_158(None) = SOLIDITY_CALL require(bool)(TMP_157)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(isAcceptedContributor(_sender))

IRs:
TMP_159(bool) = INTERNAL_CALL, Crowdsale.isAcceptedContributor(address)(_sender)
TMP_160(None) = SOLIDITY_CALL require(bool)(TMP_159)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
presalePhase = isInPresalePhase()

IRs:
TMP_161(bool) = INTERNAL_CALL, Crowdsale.isInPresalePhase()()
presalePhase(bool) := TMP_161(bool)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(! presalePhase || _received >= minAcceptedAmountPresale)

IRs:
TMP_162 = UnaryType.BANG presalePhase 
TMP_163(bool) = _received >= minAcceptedAmountPresale
TMP_164(bool) = TMP_162 || TMP_163
TMP_165(None) = SOLIDITY_CALL require(bool)(TMP_164)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(! presalePhase || raised < maxAmountPresale)

IRs:
TMP_166 = UnaryType.BANG presalePhase 
TMP_167(bool) = raised < maxAmountPresale
TMP_168(bool) = TMP_166 || TMP_167
TMP_169(None) = SOLIDITY_CALL require(bool)(TMP_168)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(presalePhase || _received >= minAcceptedAmount)

IRs:
TMP_170(bool) = _received >= minAcceptedAmount
TMP_171(bool) = presalePhase || TMP_170
TMP_172(None) = SOLIDITY_CALL require(bool)(TMP_171)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(presalePhase || raised >= minAmountPresale)

IRs:
TMP_173(bool) = raised >= minAmountPresale
TMP_174(bool) = presalePhase || TMP_173
TMP_175(None) = SOLIDITY_CALL require(bool)(TMP_174)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(presalePhase || raised < maxAmount)

IRs:
TMP_176(bool) = raised < maxAmount
TMP_177(bool) = presalePhase || TMP_176
TMP_178(None) = SOLIDITY_CALL require(bool)(TMP_177)""];
8->9;
9[label=""Node Type: NEW VARIABLE 9
""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
presalePhase && raised + _received > maxAmountPresale

IRs:
TMP_179(uint256) = raised + _received
TMP_180(bool) = TMP_179 > maxAmountPresale
TMP_181(bool) = presalePhase && TMP_180
CONDITION TMP_181""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
acceptedAmount = maxAmountPresale - raised

IRs:
TMP_182(uint256) = maxAmountPresale - raised
acceptedAmount(uint256) := TMP_182(uint256)""];
11->16;
12[label=""Node Type: IF 12

EXPRESSION:
raised + _received > maxAmount

IRs:
TMP_183(uint256) = raised + _received
TMP_184(bool) = TMP_183 > maxAmount
CONDITION TMP_184""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
acceptedAmount = maxAmount - raised

IRs:
TMP_185(uint256) = maxAmount - raised
acceptedAmount(uint256) := TMP_185(uint256)""];
13->15;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
acceptedAmount = _received

IRs:
acceptedAmount(uint256) := _received(uint256)""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
raised += acceptedAmount

IRs:
raised(uint256) = raised + acceptedAmount""];
17->18;
18[label=""Node Type: IF 18

EXPRESSION:
presalePhase

IRs:
CONDITION presalePhase""];
18->19[label=""True""];
18->20[label=""False""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
_allocateStakeholdersEth(acceptedAmount,0)

IRs:
INTERNAL_CALL, Crowdsale._allocateStakeholdersEth(uint256,uint256)(acceptedAmount,0)""];
19->21;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
balances[_sender] += acceptedAmount

IRs:
REF_134(uint256) -> balances[_sender]
REF_134(-> balances) = REF_134 + acceptedAmount""];
20->21;
21[label=""Node Type: END_IF 21
""];
21->22;
22[label=""Node Type: NEW VARIABLE 22

EXPRESSION:
tokensToIssue = 0

IRs:
tokensToIssue(uint256) := 0(uint256)""];
22->23;
23[label=""Node Type: NEW VARIABLE 23

EXPRESSION:
phase = getCurrentPhase()

IRs:
TMP_187(uint256) = INTERNAL_CALL, Crowdsale.getCurrentPhase()()
phase(uint256) := TMP_187(uint256)""];
23->24;
24[label=""Node Type: NEW VARIABLE 24

EXPRESSION:
rate = getRate(phase,acceptedAmount)

IRs:
TMP_188(uint256) = INTERNAL_CALL, Crowdsale.getRate(uint256,uint256)(phase,acceptedAmount)
rate(uint256) := TMP_188(uint256)""];
24->25;
25[label=""Node Type: NEW VARIABLE 25
""];
25->26;
26[label=""Node Type: NEW VARIABLE 26
""];
26->27;
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
(volumes,releaseDates) = getDistributionData(phase,acceptedAmount)

IRs:
TUPLE_0(uint256[],uint256[]) = INTERNAL_CALL, Crowdsale.getDistributionData(uint256,uint256)(phase,acceptedAmount)
volumes(uint256[1])= UNPACK TUPLE_0 index: 0 
releaseDates(uint256[1])= UNPACK TUPLE_0 index: 1 ""];
27->30;
28[label=""Node Type: BEGIN_LOOP 28
""];
28->31;
29[label=""Node Type: END_LOOP 29
""];
29->40;
30[label=""Node Type: NEW VARIABLE 30

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
30->28;
31[label=""Node Type: IF_LOOP 31

EXPRESSION:
i < volumes.length

IRs:
REF_135 -> LENGTH volumes
TMP_189(bool) = i < REF_135
CONDITION TMP_189""];
31->32[label=""True""];
31->29[label=""False""];
32[label=""Node Type: NEW VARIABLE 32

EXPRESSION:
tokensAtCurrentRate = toTokens(volumes[i],rate)

IRs:
REF_136(uint256) -> volumes[i]
TMP_190(uint256) = INTERNAL_CALL, Crowdsale.toTokens(uint256,uint256)(REF_136,rate)
tokensAtCurrentRate(uint256) := TMP_190(uint256)""];
32->33;
33[label=""Node Type: IF 33

EXPRESSION:
rate > baseRate && releaseDates[i] > now

IRs:
TMP_191(bool) = rate > baseRate
REF_137(uint256) -> releaseDates[i]
TMP_192(bool) = REF_137 > now
TMP_193(bool) = TMP_191 && TMP_192
CONDITION TMP_193""];
33->34[label=""True""];
33->37[label=""False""];
34[label=""Node Type: NEW VARIABLE 34

EXPRESSION:
bonusTokens = tokensAtCurrentRate / rate * (rate - baseRate)

IRs:
TMP_194(uint256) = tokensAtCurrentRate / rate
TMP_195(uint256) = rate - baseRate
TMP_196(uint256) = TMP_194 * TMP_195
bonusTokens(uint256) := TMP_196(uint256)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
_allocateTokens(_sender,bonusTokens,releaseDates[i])

IRs:
REF_138(uint256) -> releaseDates[i]
INTERNAL_CALL, Crowdsale._allocateTokens(address,uint256,uint256)(_sender,bonusTokens,REF_138)""];
35->36;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
tokensToIssue += tokensAtCurrentRate - bonusTokens

IRs:
TMP_198(uint256) = tokensAtCurrentRate - bonusTokens
tokensToIssue(uint256) = tokensToIssue + TMP_198""];
36->38;
37[label=""Node Type: EXPRESSION 37

EXPRESSION:
tokensToIssue += tokensAtCurrentRate

IRs:
tokensToIssue(uint256) = tokensToIssue + tokensAtCurrentRate""];
37->38;
38[label=""Node Type: END_IF 38
""];
38->39;
39[label=""Node Type: EXPRESSION 39

EXPRESSION:
i ++

IRs:
TMP_199(uint256) := i(uint256)
i(uint256) = i + 1""];
39->31;
40[label=""Node Type: IF 40

EXPRESSION:
tokensToIssue > 0 && ! token.issue(_sender,tokensToIssue)

IRs:
TMP_200(bool) = tokensToIssue > 0
TMP_201(bool) = HIGH_LEVEL_CALL, dest:token(IManagedToken), function:issue, arguments:['_sender', 'tokensToIssue']  
TMP_202 = UnaryType.BANG TMP_201 
TMP_203(bool) = TMP_200 && TMP_202
CONDITION TMP_203""];
40->41[label=""True""];
40->42[label=""False""];
41[label=""Node Type: EXPRESSION 41

EXPRESSION:
revert()()

IRs:
TMP_204(None) = SOLIDITY_CALL revert()()""];
41->42;
42[label=""Node Type: END_IF 42
""];
42->43;
43[label=""Node Type: IF 43

EXPRESSION:
_received - acceptedAmount > 0 && ! _sender.send(_received - acceptedAmount)

IRs:
TMP_205(uint256) = _received - acceptedAmount
TMP_206(bool) = TMP_205 > 0
TMP_207(uint256) = _received - acceptedAmount
TMP_208 = SEND dest:_sender value:TMP_207
TMP_209 = UnaryType.BANG TMP_208 
TMP_210(bool) = TMP_206 && TMP_209
CONDITION TMP_210""];
43->44[label=""True""];
43->45[label=""False""];
44[label=""Node Type: EXPRESSION 44

EXPRESSION:
revert()()

IRs:
TMP_211(None) = SOLIDITY_CALL revert()()""];
44->45;
45[label=""Node Type: END_IF 45
""];
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
at_stage(Stages.InProgress)

IRs:
REF_141(Crowdsale.Stages) -> Stages.InProgress
MODIFIER_CALL, Crowdsale.at_stage(Crowdsale.Stages)(REF_141)""];
46->1;
}
",0,1,0,0,"at_stage(Stages.InProgress);require(bool)(now >= start && now <= crowdsaleEnd);require(bool)(isAcceptedContributor(_sender));presalePhase = isInPresalePhase();require(bool)(! presalePhase || _received >= minAcceptedAmountPresale);require(bool)(! presalePhase || raised < maxAmountPresale);require(bool)(presalePhase || _received >= minAcceptedAmount);require(bool)(presalePhase || raised >= minAmountPresale);require(bool)(presalePhase || raised < maxAmount);;presalePhase && raised + _received > maxAmountPresale;acceptedAmount = maxAmountPresale - raised;raised + _received > maxAmount;;acceptedAmount = maxAmount - raised;acceptedAmount = _received;;raised += acceptedAmount;presalePhase;_allocateStakeholdersEth(acceptedAmount,0);balances[_sender] += acceptedAmount;;tokensToIssue = 0;phase = getCurrentPhase();rate = getRate(phase,acceptedAmount);;;(volumes,releaseDates) = getDistributionData(phase,acceptedAmount);i = 0;;i < volumes.length;;tokensToIssue > 0 && ! token.issue(_sender,tokensToIssue);tokensAtCurrentRate = toTokens(volumes[i],rate);rate > baseRate && releaseDates[i] > now;bonusTokens = tokensAtCurrentRate / rate * (rate - baseRate);tokensToIssue += tokensAtCurrentRate;_allocateTokens(_sender,bonusTokens,releaseDates[i]);tokensToIssue += tokensAtCurrentRate - bonusTokens;;i ++;revert()();;_received - acceptedAmount > 0 && ! _sender.send(_received - acceptedAmount);revert()();"
./0x025dce2d39a46296766db7cac8c322e8f59cd5d9_ext.sol,Reputation.change,18,21,"REF_1(bool) -> whitelist[msg.sender],TMP_2(None) = SOLIDITY_CALL require(bool)(REF_1),REF_2(int256) -> ratings[_userAddress],REF_2(-> ratings) = REF_2 + _delta","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(whitelist[msg.sender])

IRs:
REF_1(bool) -> whitelist[msg.sender]
TMP_2(None) = SOLIDITY_CALL require(bool)(REF_1)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ratings[_userAddress] += _delta

IRs:
REF_2(int256) -> ratings[_userAddress]
REF_2(-> ratings) = REF_2 + _delta""];
}
",0,1,0,0,require(bool)(whitelist[msg.sender]);ratings[_userAddress] += _delta
./0x185480332ee00c4a23422df11e022172dc10d5a9_ext.sol,NausiCoin._transfer,129,142,"TMP_33(bool) = to != 0,TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33),REF_22(uint256) -> _balanceOf[from],TMP_35(bool) = REF_22 >= value,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),REF_23(uint256) -> _balanceOf[to],TMP_37(uint256) = REF_23 + value,REF_24(uint256) -> _balanceOf[to],TMP_38(bool) = TMP_37 >= REF_24,TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38),REF_25(uint256) -> _balanceOf[from],REF_26(uint256) -> _balanceOf[to],TMP_40(uint256) = REF_25 + REF_26,previousBalance(uint256) := TMP_40(uint256),REF_27(uint256) -> _balanceOf[from],REF_27(-> _balanceOf) = REF_27 - value,REF_28(uint256) -> _balanceOf[to],REF_28(-> _balanceOf) = REF_28 + value,Emit Transfer(from,to,value),REF_29(uint256) -> _balanceOf[from],REF_30(uint256) -> _balanceOf[to],TMP_42(uint256) = REF_29 + REF_30,TMP_43(bool) = TMP_42 == previousBalance,TMP_44(None) = SOLIDITY_CALL assert(bool)(TMP_43)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(to != 0x0)

IRs:
TMP_33(bool) = to != 0
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_balanceOf[from] >= value)

IRs:
REF_22(uint256) -> _balanceOf[from]
TMP_35(bool) = REF_22 >= value
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_balanceOf[to] + value >= _balanceOf[to])

IRs:
REF_23(uint256) -> _balanceOf[to]
TMP_37(uint256) = REF_23 + value
REF_24(uint256) -> _balanceOf[to]
TMP_38(bool) = TMP_37 >= REF_24
TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
previousBalance = _balanceOf[from] + _balanceOf[to]

IRs:
REF_25(uint256) -> _balanceOf[from]
REF_26(uint256) -> _balanceOf[to]
TMP_40(uint256) = REF_25 + REF_26
previousBalance(uint256) := TMP_40(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_balanceOf[from] -= value

IRs:
REF_27(uint256) -> _balanceOf[from]
REF_27(-> _balanceOf) = REF_27 - value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
_balanceOf[to] += value

IRs:
REF_28(uint256) -> _balanceOf[to]
REF_28(-> _balanceOf) = REF_28 + value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(from,to,value)

IRs:
Emit Transfer(from,to,value)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(_balanceOf[from] + _balanceOf[to] == previousBalance)

IRs:
REF_29(uint256) -> _balanceOf[from]
REF_30(uint256) -> _balanceOf[to]
TMP_42(uint256) = REF_29 + REF_30
TMP_43(bool) = TMP_42 == previousBalance
TMP_44(None) = SOLIDITY_CALL assert(bool)(TMP_43)""];
}
",0,1,0,0,"require(bool)(to != 0x0);require(bool)(_balanceOf[from] >= value);require(bool)(_balanceOf[to] + value >= _balanceOf[to]);previousBalance = _balanceOf[from] + _balanceOf[to];_balanceOf[from] -= value;_balanceOf[to] += value;Transfer(from,to,value);assert(bool)(_balanceOf[from] + _balanceOf[to] == previousBalance)"
./0x6e6f819299e7809ce744f37fae9f84fe38d95f1c_ext.sol,CompanyFundsWallet.setup,22,27,"TMP_9(bool) = keyHash == 0,CONDITION TMP_9,TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key),TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10),keyHash(bytes32) := TMP_11(bytes32)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
keyHash == 0x0

IRs:
TMP_9(bool) = keyHash == 0
CONDITION TMP_9""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
keyHash = keccak256()(abi.encodePacked(key))

IRs:
TMP_10(bytes) = SOLIDITY_CALL abi.encodePacked()(key)
TMP_11(bytes32) = SOLIDITY_CALL keccak256()(TMP_10)
keyHash(bytes32) := TMP_11(bytes32)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,1,0,0,keyHash == 0x0;keyHash = keccak256()(abi.encodePacked(key));
./0x6cc07cb2d1d354f9e2042a26697e7fe9cec4656c_ext.sol,ERGCOIN.distributeERG,74,83,"i(uint256) := 0(uint256),REF_1 -> LENGTH addresses,TMP_2(bool) = i < REF_1,CONDITION TMP_2,REF_2(address) -> addresses[i],TMP_3(uint256) = INTERNAL_CALL, ERGCOIN.getEthBalance(address)(REF_2),TMP_4(bool) = TMP_3 < _ethbal,CONDITION TMP_4,REF_3(uint256) -> balances[owner],REF_3(-> balances) = REF_3 - _value,REF_4(address) -> addresses[i],REF_5(uint256) -> balances[REF_4],REF_5(-> balances) = REF_5 + _value,REF_6(address) -> addresses[i],Emit Transfer(owner,REF_6,_value),TMP_6(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, ERGCOIN.onlyOwner()(),MODIFIER_CALL, ERGCOIN.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < addresses.length

IRs:
REF_1 -> LENGTH addresses
TMP_2(bool) = i < REF_1
CONDITION TMP_2""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
getEthBalance(addresses[i]) < _ethbal

IRs:
REF_2(address) -> addresses[i]
TMP_3(uint256) = INTERNAL_CALL, ERGCOIN.getEthBalance(address)(REF_2)
TMP_4(bool) = TMP_3 < _ethbal
CONDITION TMP_4""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: CONTINUE 6
""];
6->11;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[owner] -= _value

IRs:
REF_3(uint256) -> balances[owner]
REF_3(-> balances) = REF_3 - _value""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
balances[addresses[i]] += _value

IRs:
REF_4(address) -> addresses[i]
REF_5(uint256) -> balances[REF_4]
REF_5(-> balances) = REF_5 + _value""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Transfer(owner,addresses[i],_value)

IRs:
REF_6(address) -> addresses[i]
Emit Transfer(owner,REF_6,_value)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_6(uint256) := i(uint256)
i(uint256) = i + 1""];
11->4;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ERGCOIN.onlyOwner()()""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, ERGCOIN.canDistr()()""];
13->3;
}
",0,1,0,0,"onlyOwner();;i < addresses.length;;i = 0;getEthBalance(addresses[i]) < _ethbal;;;i ++;balances[owner] -= _value;balances[addresses[i]] += _value;Transfer(owner,addresses[i],_value);canDistr()"
./0x1dc8c35fa368f6ec96e9b95d8c47834e20576cd6_ext.sol,HECFinalToken.burnFrom,135,143,"REF_21(uint256) -> balanceOf[_from],TMP_87(bool) = REF_21 >= _value,TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87),REF_22(mapping(address => uint256)) -> allowance[_from],REF_23(uint256) -> REF_22[msg.sender],TMP_89(bool) = _value <= REF_23,TMP_90(None) = SOLIDITY_CALL require(bool)(TMP_89),REF_24(uint256) -> balanceOf[_from],REF_24(-> balanceOf) = REF_24 - _value,REF_25(mapping(address => uint256)) -> allowance[_from],REF_26(uint256) -> REF_25[msg.sender],REF_26(-> allowance) = REF_26 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(_from,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[_from] >= _value)

IRs:
REF_21(uint256) -> balanceOf[_from]
TMP_87(bool) = REF_21 >= _value
TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_value <= allowance[_from][msg.sender])

IRs:
REF_22(mapping(address => uint256)) -> allowance[_from]
REF_23(uint256) -> REF_22[msg.sender]
TMP_89(bool) = _value <= REF_23
TMP_90(None) = SOLIDITY_CALL require(bool)(TMP_89)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[_from] -= _value

IRs:
REF_24(uint256) -> balanceOf[_from]
REF_24(-> balanceOf) = REF_24 - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowance[_from][msg.sender] -= _value

IRs:
REF_25(mapping(address => uint256)) -> allowance[_from]
REF_26(uint256) -> REF_25[msg.sender]
REF_26(-> allowance) = REF_26 - _value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Burn(_from,_value)

IRs:
Emit Burn(_from,_value)""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[_from] >= _value);require(bool)(_value <= allowance[_from][msg.sender]);balanceOf[_from] -= _value;allowance[_from][msg.sender] -= _value;totalSupply -= _value;Burn(_from,_value);true;success"
./0x30dc851be3c09af90c0c8a9dfdd7db85b9d8b304_ext.sol,Fpgcchain.burn,126,132,"REF_17(uint256) -> balanceOf[msg.sender],TMP_22(bool) = REF_17 >= _value,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_18(uint256) -> balanceOf[msg.sender],REF_18(-> balanceOf) = REF_18 - _value,totalSupply(uint256) = totalSupply - _value,Emit Burn(msg.sender,_value),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balanceOf[msg.sender] >= _value)

IRs:
REF_17(uint256) -> balanceOf[msg.sender]
TMP_22(bool) = REF_17 >= _value
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balanceOf[msg.sender] -= _value

IRs:
REF_18(uint256) -> balanceOf[msg.sender]
REF_18(-> balanceOf) = REF_18 - _value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalSupply -= _value

IRs:
totalSupply(uint256) = totalSupply - _value""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Burn(msg.sender,_value)

IRs:
Emit Burn(msg.sender,_value)""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,1,0,0,"require(bool)(balanceOf[msg.sender] >= _value);balanceOf[msg.sender] -= _value;totalSupply -= _value;Burn(msg.sender,_value);true;success"
./0x4bd3aac60b2e8893913b8398edda362e6b46dd98_ext.sol,CryptoPoliceOfficerToken.releaseLockedTokens,314,323,"TMP_138(bool) = releaseStartTime > 0,TMP_139(None) = SOLIDITY_CALL require(bool)(TMP_138),REF_36(CryptoPoliceOfficerToken.TokenLock) -> locks[idx],REF_37(bool) -> REF_36.released,TMP_140 = UnaryType.BANG REF_37 ,TMP_141(None) = SOLIDITY_CALL require(bool)(TMP_140),REF_38(CryptoPoliceOfficerToken.TokenLock) -> locks[idx],REF_39(uint256) -> REF_38.timespan,TMP_142(uint256) = releaseStartTime + REF_39,TMP_143(bool) = TMP_142 < now,TMP_144(None) = SOLIDITY_CALL require(bool)(TMP_143),REF_40(CryptoPoliceOfficerToken.TokenLock) -> locks[idx],REF_41(bool) -> REF_40.released,REF_41(bool) (->locks) := True(bool),REF_42(CryptoPoliceOfficerToken.TokenLock) -> locks[idx],REF_43(uint256) -> REF_42.amount,lockedAmount(uint256) = lockedAmount - REF_43,MODIFIER_CALL, Ownable.grantOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(releaseStartTime > 0)

IRs:
TMP_138(bool) = releaseStartTime > 0
TMP_139(None) = SOLIDITY_CALL require(bool)(TMP_138)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! locks[idx].released)

IRs:
REF_36(CryptoPoliceOfficerToken.TokenLock) -> locks[idx]
REF_37(bool) -> REF_36.released
TMP_140 = UnaryType.BANG REF_37 
TMP_141(None) = SOLIDITY_CALL require(bool)(TMP_140)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)((releaseStartTime + locks[idx].timespan) < now)

IRs:
REF_38(CryptoPoliceOfficerToken.TokenLock) -> locks[idx]
REF_39(uint256) -> REF_38.timespan
TMP_142(uint256) = releaseStartTime + REF_39
TMP_143(bool) = TMP_142 < now
TMP_144(None) = SOLIDITY_CALL require(bool)(TMP_143)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
locks[idx].released = true

IRs:
REF_40(CryptoPoliceOfficerToken.TokenLock) -> locks[idx]
REF_41(bool) -> REF_40.released
REF_41(bool) (->locks) := True(bool)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
lockedAmount -= locks[idx].amount

IRs:
REF_42(CryptoPoliceOfficerToken.TokenLock) -> locks[idx]
REF_43(uint256) -> REF_42.amount
lockedAmount(uint256) = lockedAmount - REF_43""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
grantOwner()

IRs:
MODIFIER_CALL, Ownable.grantOwner()()""];
6->1;
}
",0,1,0,0,grantOwner();require(bool)(releaseStartTime > 0);require(bool)(! locks[idx].released);require(bool)((releaseStartTime + locks[idx].timespan) < now);locks[idx].released = true;lockedAmount -= locks[idx].amount
