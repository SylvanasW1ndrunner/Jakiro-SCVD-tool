file,function,start,end,code,graph,RE,IO,TO,SAFE,expression
./0x6c1bcb34142bffd35f57db626e0ac427af616a4d_ext.sol,EnjinBuyer.withdraw,69,95,"TMP_33(bool) = bought_tokens || kill_switch,TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33),TMP_35(bool) = user != sale,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),REF_14(uint256) -> balances_after_buy[user],TMP_37(bool) = REF_14 > 0,TMP_38(bool) = user != sale,TMP_39(bool) = TMP_37 && TMP_38,CONDITION TMP_39,REF_15(uint256) -> balances_after_buy[user],eth_to_withdraw_after_buy(uint256) := REF_15(uint256),REF_16(uint256) -> balances_after_buy[user],REF_16(uint256) (->balances_after_buy) := 0(uint256),Transfer dest:user value:eth_to_withdraw_after_buy,REF_18(uint256) -> balances[user],TMP_41(bool) = REF_18 == 0,CONDITION TMP_41,TMP_42 = UnaryType.BANG bought_tokens ,TMP_43(bool) = TMP_42 || refunded,CONDITION TMP_43,REF_19(uint256) -> balances[user],eth_to_withdraw(uint256) := REF_19(uint256),REF_20(uint256) -> balances[user],REF_20(uint256) (->balances) := 0(uint256),Transfer dest:user value:eth_to_withdraw,TMP_45(None) = SOLIDITY_CALL require(bool)(token_set),TMP_46 = CONVERT this to address,TMP_47(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['TMP_46']  ,contract_token_balance(uint256) := TMP_47(uint256),TMP_48(bool) = contract_token_balance != 0,TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48),REF_23(uint256) -> balances[user],TMP_50(uint256) = REF_23 * contract_token_balance,TMP_51(uint256) = TMP_50 / contract_eth_value,tokens_to_withdraw(uint256) := TMP_51(uint256),REF_24(uint256) -> balances[user],contract_eth_value(uint256) = contract_eth_value - REF_24,REF_25(uint256) -> balances[user],REF_25(uint256) (->balances) := 0(uint256),TMP_52(uint256) = tokens_to_withdraw / 100,fee(uint256) := TMP_52(uint256),TMP_53(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['developer', 'fee']  ,TMP_54(None) = SOLIDITY_CALL require(bool)(TMP_53),TMP_55(uint256) = tokens_to_withdraw - fee,TMP_56(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['user', 'TMP_55']  ,TMP_57(None) = SOLIDITY_CALL require(bool)(TMP_56)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(bought_tokens || kill_switch)

IRs:
TMP_33(bool) = bought_tokens || kill_switch
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(user != sale)

IRs:
TMP_35(bool) = user != sale
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
balances_after_buy[user] > 0 && user != sale

IRs:
REF_14(uint256) -> balances_after_buy[user]
TMP_37(bool) = REF_14 > 0
TMP_38(bool) = user != sale
TMP_39(bool) = TMP_37 && TMP_38
CONDITION TMP_39""];
3->4[label=""True""];
3->7[label=""False""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
eth_to_withdraw_after_buy = balances_after_buy[user]

IRs:
REF_15(uint256) -> balances_after_buy[user]
eth_to_withdraw_after_buy(uint256) := REF_15(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances_after_buy[user] = 0

IRs:
REF_16(uint256) -> balances_after_buy[user]
REF_16(uint256) (->balances_after_buy) := 0(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
user.transfer(eth_to_withdraw_after_buy)

IRs:
Transfer dest:user value:eth_to_withdraw_after_buy""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
balances[user] == 0

IRs:
REF_18(uint256) -> balances[user]
TMP_41(bool) = REF_18 == 0
CONDITION TMP_41""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: RETURN 9
""];
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
! bought_tokens || refunded

IRs:
TMP_42 = UnaryType.BANG bought_tokens 
TMP_43(bool) = TMP_42 || refunded
CONDITION TMP_43""];
11->12[label=""True""];
11->15[label=""False""];
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
eth_to_withdraw = balances[user]

IRs:
REF_19(uint256) -> balances[user]
eth_to_withdraw(uint256) := REF_19(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
balances[user] = 0

IRs:
REF_20(uint256) -> balances[user]
REF_20(uint256) (->balances) := 0(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
user.transfer(eth_to_withdraw)

IRs:
Transfer dest:user value:eth_to_withdraw""];
14->24;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
require(bool)(token_set)

IRs:
TMP_45(None) = SOLIDITY_CALL require(bool)(token_set)""];
15->16;
16[label=""Node Type: NEW VARIABLE 16

EXPRESSION:
contract_token_balance = token.balanceOf(address(this))

IRs:
TMP_46 = CONVERT this to address
TMP_47(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['TMP_46']  
contract_token_balance(uint256) := TMP_47(uint256)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
require(bool)(contract_token_balance != 0)

IRs:
TMP_48(bool) = contract_token_balance != 0
TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48)""];
17->18;
18[label=""Node Type: NEW VARIABLE 18

EXPRESSION:
tokens_to_withdraw = (balances[user] * contract_token_balance) / contract_eth_value

IRs:
REF_23(uint256) -> balances[user]
TMP_50(uint256) = REF_23 * contract_token_balance
TMP_51(uint256) = TMP_50 / contract_eth_value
tokens_to_withdraw(uint256) := TMP_51(uint256)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
contract_eth_value -= balances[user]

IRs:
REF_24(uint256) -> balances[user]
contract_eth_value(uint256) = contract_eth_value - REF_24""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
balances[user] = 0

IRs:
REF_25(uint256) -> balances[user]
REF_25(uint256) (->balances) := 0(uint256)""];
20->21;
21[label=""Node Type: NEW VARIABLE 21

EXPRESSION:
fee = tokens_to_withdraw / 100

IRs:
TMP_52(uint256) = tokens_to_withdraw / 100
fee(uint256) := TMP_52(uint256)""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
require(bool)(token.transfer(developer,fee))

IRs:
TMP_53(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['developer', 'fee']  
TMP_54(None) = SOLIDITY_CALL require(bool)(TMP_53)""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
require(bool)(token.transfer(user,tokens_to_withdraw - fee))

IRs:
TMP_55(uint256) = tokens_to_withdraw - fee
TMP_56(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['user', 'TMP_55']  
TMP_57(None) = SOLIDITY_CALL require(bool)(TMP_56)""];
23->24;
24[label=""Node Type: END_IF 24
""];
}
",0,1,1,0,"require(bool)(bought_tokens || kill_switch);require(bool)(user != sale);balances_after_buy[user] > 0 && user != sale;eth_to_withdraw_after_buy = balances_after_buy[user];;balances_after_buy[user] = 0;user.transfer(eth_to_withdraw_after_buy);balances[user] == 0;;;! bought_tokens || refunded;eth_to_withdraw = balances[user];require(bool)(token_set);balances[user] = 0;user.transfer(eth_to_withdraw);;contract_token_balance = token.balanceOf(address(this));require(bool)(contract_token_balance != 0);tokens_to_withdraw = (balances[user] * contract_token_balance) / contract_eth_value;contract_eth_value -= balances[user];balances[user] = 0;fee = tokens_to_withdraw / 100;require(bool)(token.transfer(developer,fee));require(bool)(token.transfer(user,tokens_to_withdraw - fee))"
./0x0033fb5561719b8b697b604466d6d39308c58191_ext.sol,EncryptedToken.getEth,228,230,TMP_88 = SEND dest:owner value:num,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.send(num)

IRs:
TMP_88 = SEND dest:owner value:num""];
}
",0,0,1,0,owner.send(num)
./0x1847825ea569501ca50dee126d31ea95f6c62a87_ext.sol,LinCrowdSale.transferEthToOwner,640,654,"CONDITION SoftCapReached,Transfer dest:owner value:_amount,Emit SuccessEthToOwner(msg.sender,_amount,now),Emit FailEthToOwner(msg.sender,_amount,now),MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, LinCrowdSale.afterDeadline()(),MODIFIER_CALL, LinCrowdSale.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: IF 1

EXPRESSION:
SoftCapReached

IRs:
CONDITION SoftCapReached""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(_amount)

IRs:
Transfer dest:owner value:_amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
SuccessEthToOwner(msg.sender,_amount,now)

IRs:
Emit SuccessEthToOwner(msg.sender,_amount,now)""];
3->5;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
FailEthToOwner(msg.sender,_amount,now)

IRs:
Emit FailEthToOwner(msg.sender,_amount,now)""];
4->5;
5[label=""Node Type: END_IF 5
""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
afterDeadline()

IRs:
MODIFIER_CALL, LinCrowdSale.afterDeadline()()""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, LinCrowdSale.nonReentrant()()""];
8->1;
}
",0,0,1,0,"onlyOwner();SoftCapReached;owner.transfer(_amount);FailEthToOwner(msg.sender,_amount,now);SuccessEthToOwner(msg.sender,_amount,now);;afterDeadline();nonReentrant()"
./0x6543cde961213e82001594bf4c34706579ce34ec_ext.sol,ClinicAllRefundEscrow.withdraw,821,830,"TMP_428(bool) = INTERNAL_CALL, RefundEscrow.withdrawalAllowed(address)(_payee),TMP_429(None) = SOLIDITY_CALL require(bool)(TMP_428),INTERNAL_CALL, Escrow.withdraw(address)(_payee)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(withdrawalAllowed(_payee))

IRs:
TMP_428(bool) = INTERNAL_CALL, RefundEscrow.withdrawalAllowed(address)(_payee)
TMP_429(None) = SOLIDITY_CALL require(bool)(TMP_428)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
super.withdraw(_payee)

IRs:
INTERNAL_CALL, Escrow.withdraw(address)(_payee)""];
}
",0,0,1,0,require(bool)(withdrawalAllowed(_payee));super.withdraw(_payee)
./0xef511cd832613f77a6c6cc8ab5ce6a8b4181c9ba_ext.sol,ICOBuyer.buyWithAddress,59,63,"TMP_23(bool) = msg.sender == developer,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),TMP_25(bool) = _ICO != 0,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),REF_12(uint256) = SOLIDITY_CALL balance(address)(this),TMP_28(bool) = LOW_LEVEL_CALL, dest:_ICO, function:call, arguments:[] value:REF_12 ,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == developer)

IRs:
TMP_23(bool) = msg.sender == developer
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_ICO != 0x0)

IRs:
TMP_25(bool) = _ICO != 0
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_ICO.call.value(this.balance)())

IRs:
REF_12(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_28(bool) = LOW_LEVEL_CALL, dest:_ICO, function:call, arguments:[] value:REF_12 
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
}
",0,0,1,0,require(bool)(msg.sender == developer);require(bool)(_ICO != 0x0);require(bool)(_ICO.call.value(this.balance)())
./0x92dee36a50f66c603e15b9ac07338ec0046f902f_ext.sol,IRideLiquidityPool.kill,50,52,"TMP_7(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, IRideLiquidityPool.isCreator()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_7(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isCreator()

IRs:
MODIFIER_CALL, IRideLiquidityPool.isCreator()()""];
2->1;
}
",0,0,1,0,isCreator();selfdestruct(address)(owner)
./0xd1632efa392925089785b43410c529f8959a8d9a_ext.sol,MiniMeToken.fallback,522,525,"TMP_124(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller),TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124),TMP_126 = CONVERT controller to TokenController,TMP_128(bool) = HIGH_LEVEL_CALL, dest:TMP_126(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value ,TMP_129(None) = SOLIDITY_CALL require(bool)(TMP_128)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isContract(controller))

IRs:
TMP_124(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)
TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))

IRs:
TMP_126 = CONVERT controller to TokenController
TMP_128(bool) = HIGH_LEVEL_CALL, dest:TMP_126(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value 
TMP_129(None) = SOLIDITY_CALL require(bool)(TMP_128)""];
}
",0,0,1,0,require(bool)(isContract(controller));require(bool)(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))
./0x27a8e297fefa4f15e856aea59ba9336e0dbf3c74_ext.sol,GIGA.StopGame,29,32,"TMP_9(bool) = msg.sender == questionSender,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_9(bool) = msg.sender == questionSender
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0x35d76c3db8e826907d2a977500b54b3914ecc020_ext.sol,RefundVault.refund,225,231,"REF_28(RefundVault.State) -> State.Refunding,TMP_187(bool) = state == REF_28,TMP_188(None) = SOLIDITY_CALL require(bool)(TMP_187),REF_29(uint256) -> deposited[investor],depositedValue(uint256) := REF_29(uint256),REF_30(uint256) -> deposited[investor],REF_30(uint256) (->deposited) := 0(uint256),Transfer dest:investor value:depositedValue,Emit Refunded(investor,depositedValue)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Refunding)

IRs:
REF_28(RefundVault.State) -> State.Refunding
TMP_187(bool) = state == REF_28
TMP_188(None) = SOLIDITY_CALL require(bool)(TMP_187)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
depositedValue = deposited[investor]

IRs:
REF_29(uint256) -> deposited[investor]
depositedValue(uint256) := REF_29(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
deposited[investor] = 0

IRs:
REF_30(uint256) -> deposited[investor]
REF_30(uint256) (->deposited) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
investor.transfer(depositedValue)

IRs:
Transfer dest:investor value:depositedValue""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Refunded(investor,depositedValue)

IRs:
Emit Refunded(investor,depositedValue)""];
}
",0,0,1,0,"require(bool)(state == State.Refunding);depositedValue = deposited[investor];deposited[investor] = 0;investor.transfer(depositedValue);Refunded(investor,depositedValue)"
./0x1bd4e709a076fb71ea1014293a739f2b19ca565d_ext.sol,Labtorum.withdraw,280,283,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, Labtorum.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Labtorum.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x1bb0a576936bce5d983e676073ac48ba49f12e05_ext.sol,PullPayment.withdrawPayments,134,152,"payee(address) := msg.sender(address),REF_3(uint256) -> payments[payee],payment(uint256) := REF_3(uint256),TMP_38(bool) = payment == 0,CONDITION TMP_38,REF_4(uint256) = SOLIDITY_CALL balance(address)(this),TMP_39(bool) = REF_4 < payment,CONDITION TMP_39,REF_5(uint256) -> payments[payee],REF_5(uint256) (->payments) := 0(uint256),TMP_40 = SEND dest:payee value:payment,TMP_41 = UnaryType.BANG TMP_40 ,CONDITION TMP_41,Emit LogRefundETH(payee,payment)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
payee = msg.sender

IRs:
payee(address) := msg.sender(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
payment = payments[payee]

IRs:
REF_3(uint256) -> payments[payee]
payment(uint256) := REF_3(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
payment == 0

IRs:
TMP_38(bool) = payment == 0
CONDITION TMP_38""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: THROW 4
""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
this.balance < payment

IRs:
REF_4(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_39(bool) = REF_4 < payment
CONDITION TMP_39""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: THROW 7
""];
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
payments[payee] = 0

IRs:
REF_5(uint256) -> payments[payee]
REF_5(uint256) (->payments) := 0(uint256)""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
! payee.send(payment)

IRs:
TMP_40 = SEND dest:payee value:payment
TMP_41 = UnaryType.BANG TMP_40 
CONDITION TMP_41""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: THROW 11
""];
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
LogRefundETH(payee,payment)

IRs:
Emit LogRefundETH(payee,payment)""];
}
",0,0,1,0,"payee = msg.sender;payment = payments[payee];payment == 0;;;this.balance < payment;;;payments[payee] = 0;! payee.send(payment);;;LogRefundETH(payee,payment)"
./0x447b4ccab1b370afbe5ae2e68c0b700be913a585_ext.sol,AgileCycle.failSafe,794,804,"TMP_368(bool) = msg.sender == operator,CONDITION TMP_368,saveMe(bool) := True(bool),TMP_369(bool) = msg.sender == juryOperator,CONDITION TMP_369,TMP_370(bool) = saveMe == True,TMP_371(None) = SOLIDITY_CALL require(bool)(TMP_370),TMP_372 = CONVERT this to address,TMP_373(uint256) = SOLIDITY_CALL balance(address)(TMP_372),TMP_374 = SEND dest:juryOperator value:TMP_373,TMP_375(None) = SOLIDITY_CALL require(bool)(TMP_374),TMP_376(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:balanceOf, arguments:['this']  ,allTheLockedTokens(uint256) := TMP_376(uint256),TMP_377(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transfer, arguments:['juryOperator', 'allTheLockedTokens']  ,TMP_378(None) = SOLIDITY_CALL require(bool)(TMP_377)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == operator

IRs:
TMP_368(bool) = msg.sender == operator
CONDITION TMP_368""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
saveMe = true

IRs:
saveMe(bool) := True(bool)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
msg.sender == juryOperator

IRs:
TMP_369(bool) = msg.sender == juryOperator
CONDITION TMP_369""];
4->5[label=""True""];
4->9[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(saveMe == true)

IRs:
TMP_370(bool) = saveMe == True
TMP_371(None) = SOLIDITY_CALL require(bool)(TMP_370)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(juryOperator.send(address(this).balance))

IRs:
TMP_372 = CONVERT this to address
TMP_373(uint256) = SOLIDITY_CALL balance(address)(TMP_372)
TMP_374 = SEND dest:juryOperator value:TMP_373
TMP_375(None) = SOLIDITY_CALL require(bool)(TMP_374)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
allTheLockedTokens = token.balanceOf(this)

IRs:
TMP_376(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:balanceOf, arguments:['this']  
allTheLockedTokens(uint256) := TMP_376(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(token.transfer(juryOperator,allTheLockedTokens))

IRs:
TMP_377(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transfer, arguments:['juryOperator', 'allTheLockedTokens']  
TMP_378(None) = SOLIDITY_CALL require(bool)(TMP_377)""];
8->9;
9[label=""Node Type: END_IF 9
""];
}
",0,0,1,0,"msg.sender == operator;saveMe = true;;msg.sender == juryOperator;require(bool)(saveMe == true);;require(bool)(juryOperator.send(address(this).balance));allTheLockedTokens = token.balanceOf(this);require(bool)(token.transfer(juryOperator,allTheLockedTokens))"
./0x70bf9df6967dc96156e76cc43b928a7ef02e159a_ext.sol,X_GAME.Play,5,14,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0xe01ba6c593003b0edcd43b7839a7c36b00a44dfc_ext.sol,SBITokenCrowdsale.kill,449,463,"TMP_154(bool) = INTERNAL_CALL, SBITokenCrowdsale.isICOActive()(),TMP_155 = UnaryType.BANG TMP_154 ,TMP_156(None) = SOLIDITY_CALL require(bool)(TMP_155),TMP_157(uint256) = SOLIDITY_CALL balance(address)(crowdsaleAddress),TMP_158(bool) = TMP_157 > 0,CONDITION TMP_158,TMP_159(None) = SOLIDITY_CALL revert()(),TMP_160(bool) = now < preSaleStartDate,CONDITION TMP_160,TMP_161(None) = SOLIDITY_CALL selfdestruct(address)(owner),TMP_162(uint256) = HIGH_LEVEL_CALL, dest:token(SBIToken), function:balanceOf, arguments:['saleWalletAddress']  ,featureDevelopmentAmount(uint256) := TMP_162(uint256),REF_50(address) -> featureDevelopment.addr,TMP_163(bool) = HIGH_LEVEL_CALL, dest:token(SBIToken), function:transferFrom, arguments:['saleWalletAddress', 'REF_50', 'featureDevelopmentAmount']  ,TMP_164(uint256) = SOLIDITY_CALL balance(address)(crowdsaleAddress),Emit FundTransfer(crowdsaleAddress,msg.sender,TMP_164),TMP_166(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isICOActive())

IRs:
TMP_154(bool) = INTERNAL_CALL, SBITokenCrowdsale.isICOActive()()
TMP_155 = UnaryType.BANG TMP_154 
TMP_156(None) = SOLIDITY_CALL require(bool)(TMP_155)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
crowdsaleAddress.balance > 0

IRs:
TMP_157(uint256) = SOLIDITY_CALL balance(address)(crowdsaleAddress)
TMP_158(bool) = TMP_157 > 0
CONDITION TMP_158""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
revert()()

IRs:
TMP_159(None) = SOLIDITY_CALL revert()()""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
now < preSaleStartDate

IRs:
TMP_160(bool) = now < preSaleStartDate
CONDITION TMP_160""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_161(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
featureDevelopmentAmount = token.balanceOf(saleWalletAddress)

IRs:
TMP_162(uint256) = HIGH_LEVEL_CALL, dest:token(SBIToken), function:balanceOf, arguments:['saleWalletAddress']  
featureDevelopmentAmount(uint256) := TMP_162(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
token.transferFrom(saleWalletAddress,featureDevelopment.addr,featureDevelopmentAmount)

IRs:
REF_50(address) -> featureDevelopment.addr
TMP_163(bool) = HIGH_LEVEL_CALL, dest:token(SBIToken), function:transferFrom, arguments:['saleWalletAddress', 'REF_50', 'featureDevelopmentAmount']  ""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
FundTransfer(crowdsaleAddress,msg.sender,crowdsaleAddress.balance)

IRs:
TMP_164(uint256) = SOLIDITY_CALL balance(address)(crowdsaleAddress)
Emit FundTransfer(crowdsaleAddress,msg.sender,TMP_164)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_166(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
12->1;
}
",0,0,1,0,"onlyOwner();require(bool)(! isICOActive());crowdsaleAddress.balance > 0;revert()();;now < preSaleStartDate;selfdestruct(address)(owner);;featureDevelopmentAmount = token.balanceOf(saleWalletAddress);token.transferFrom(saleWalletAddress,featureDevelopment.addr,featureDevelopmentAmount);FundTransfer(crowdsaleAddress,msg.sender,crowdsaleAddress.balance);selfdestruct(address)(owner)"
./0xeafd8b734e32aec64c4b445e9da401427ef63a3a_ext.sol,CryptoBossWannaCry.upgrade,176,180,"TMP_35(bool) = msg.sender == administrator,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),TMP_37(None) = SOLIDITY_CALL selfdestruct(address)(addr)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == administrator)

IRs:
TMP_35(bool) = msg.sender == administrator
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(addr)

IRs:
TMP_37(None) = SOLIDITY_CALL selfdestruct(address)(addr)""];
}
",0,0,1,0,require(bool)(msg.sender == administrator);selfdestruct(address)(addr)
./0x6fff3806bbac52a20e0d79bc538d527f6a22c96b_ext.sol,Token.payout,464,467,"TMP_196 = CONVERT 0 to address,TMP_197(bool) = dst != TMP_196,TMP_198(None) = SOLIDITY_CALL require(bool)(TMP_197),REF_18(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:dst value:REF_18,MODIFIER_CALL, Auth.auth()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(dst != address(0))

IRs:
TMP_196 = CONVERT 0 to address
TMP_197(bool) = dst != TMP_196
TMP_198(None) = SOLIDITY_CALL require(bool)(TMP_197)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
dst.transfer(this.balance)

IRs:
REF_18(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:dst value:REF_18""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, Auth.auth()()""];
3->1;
}
",0,0,1,0,auth();require(bool)(dst != address(0));dst.transfer(this.balance)
./0x7275f61c3abfba3596ae71f7128bdc3b0fc01fa9_ext.sol,SignalsSociety.withdraw,79,85,"TMP_36(bool) = user == msg.sender,TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36),REF_7(uint256) -> balances[user],amount(uint256) := REF_7(uint256),REF_8(uint256) -> balances[user],REF_8(uint256) (->balances) := 0(uint256),Transfer dest:user value:amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(user == msg.sender)

IRs:
TMP_36(bool) = user == msg.sender
TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = balances[user]

IRs:
REF_7(uint256) -> balances[user]
amount(uint256) := REF_7(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[user] = 0

IRs:
REF_8(uint256) -> balances[user]
REF_8(uint256) (->balances) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
user.transfer(amount)

IRs:
Transfer dest:user value:amount""];
}
",0,0,1,0,require(bool)(user == msg.sender);amount = balances[user];balances[user] = 0;user.transfer(amount)
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.updUserBlackList,2,2,"REF_55 -> LENGTH _addlist,TMP_112(bool) = REF_55 > 0,CONDITION TMP_112,i(uint256) := 0(uint256),REF_56 -> LENGTH _addlist,TMP_113(bool) = i < REF_56,CONDITION TMP_113,REF_57(address) -> _addlist[i],baddr(address) := REF_57(address),TMP_114 = CONVERT 0 to address,TMP_115(bool) = baddr != TMP_114,REF_58(KahnDistributionCentre.User) -> bounties[baddr],REF_59(bool) -> REF_58.blacklisted,TMP_116 = UnaryType.BANG REF_59 ,TMP_117(bool) = TMP_115 && TMP_116,CONDITION TMP_117,REF_60(KahnDistributionCentre.User) -> bounties[baddr],REF_61(bool) -> REF_60.blacklisted,REF_61(bool) (->bounties) := True(bool),REF_62(bool) -> blacklist[baddr],REF_62(bool) (->blacklist) := True(bool),TMP_118(uint256) := i(uint256),i(uint256) = i + 1,REF_63 -> LENGTH _removelist,TMP_119(bool) = REF_63 > 0,CONDITION TMP_119,INTERNAL_CALL, KahnDistributionCentre.removeUserFromBlackList(address[])(_removelist),MODIFIER_CALL, KahnDistributionCentre.onlyStaffs()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->16;
1[label=""Node Type: IF 1

EXPRESSION:
_addlist.length > 0

IRs:
REF_55 -> LENGTH _addlist
TMP_112(bool) = REF_55 > 0
CONDITION TMP_112""];
1->4[label=""True""];
1->12[label=""False""];
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
3->12;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < _addlist.length

IRs:
REF_56 -> LENGTH _addlist
TMP_113(bool) = i < REF_56
CONDITION TMP_113""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
baddr = _addlist[i]

IRs:
REF_57(address) -> _addlist[i]
baddr(address) := REF_57(address)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
baddr != address(0) && ! bounties[baddr].blacklisted

IRs:
TMP_114 = CONVERT 0 to address
TMP_115(bool) = baddr != TMP_114
REF_58(KahnDistributionCentre.User) -> bounties[baddr]
REF_59(bool) -> REF_58.blacklisted
TMP_116 = UnaryType.BANG REF_59 
TMP_117(bool) = TMP_115 && TMP_116
CONDITION TMP_117""];
7->8[label=""True""];
7->10[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
bounties[baddr].blacklisted = true

IRs:
REF_60(KahnDistributionCentre.User) -> bounties[baddr]
REF_61(bool) -> REF_60.blacklisted
REF_61(bool) (->bounties) := True(bool)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
blacklist[baddr] = true

IRs:
REF_62(bool) -> blacklist[baddr]
REF_62(bool) (->blacklist) := True(bool)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_118(uint256) := i(uint256)
i(uint256) = i + 1""];
11->5;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
_removelist.length > 0

IRs:
REF_63 -> LENGTH _removelist
TMP_119(bool) = REF_63 > 0
CONDITION TMP_119""];
13->14[label=""True""];
13->15[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
removeUserFromBlackList(_removelist)

IRs:
INTERNAL_CALL, KahnDistributionCentre.removeUserFromBlackList(address[])(_removelist)""];
14->15;
15[label=""Node Type: END_IF 15
""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
onlyStaffs()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyStaffs()()""];
16->1;
}
",0,1,1,0,onlyStaffs();_addlist.length > 0;i = 0;;;i < _addlist.length;;baddr = _addlist[i];baddr != address(0) && ! bounties[baddr].blacklisted;bounties[baddr].blacklisted = true;;blacklist[baddr] = true;i ++;_removelist.length > 0;removeUserFromBlackList(_removelist);
./0x03347abb58cc3071fdbba7f7bd7cca03c8e04229_ext.sol,CompanyShare.destroy,127,130,"TMP_27(bool) = msg.sender == 712920905666496987636814255501069080873662409712,TMP_28(None) = SOLIDITY_CALL require(bool,string)(TMP_27,sorry not the admin),TMP_29(None) = SOLIDITY_CALL suicide(address)(712920905666496987636814255501069080873662409712)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(msg.sender == 0x7ce07aa2fc356fa52f622c1f4df1e8eaad7febf0,sorry not the admin)

IRs:
TMP_27(bool) = msg.sender == 712920905666496987636814255501069080873662409712
TMP_28(None) = SOLIDITY_CALL require(bool,string)(TMP_27,sorry not the admin)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
suicide(address)(0x7ce07aa2fc356fa52f622c1f4df1e8eaad7febf0)

IRs:
TMP_29(None) = SOLIDITY_CALL suicide(address)(712920905666496987636814255501069080873662409712)""];
}
",0,0,1,0,"require(bool,string)(msg.sender == 0x7ce07aa2fc356fa52f622c1f4df1e8eaad7febf0,sorry not the admin);suicide(address)(0x7ce07aa2fc356fa52f622c1f4df1e8eaad7febf0)"
./0x0de197dc289d680e734ccab866d529505b2638db_ext.sol,CryptoMiningWar.upgrade,613,617,"TMP_307(bool) = msg.sender == administrator,TMP_308(None) = SOLIDITY_CALL require(bool)(TMP_307),TMP_309(None) = SOLIDITY_CALL selfdestruct(address)(addr)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == administrator)

IRs:
TMP_307(bool) = msg.sender == administrator
TMP_308(None) = SOLIDITY_CALL require(bool)(TMP_307)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(addr)

IRs:
TMP_309(None) = SOLIDITY_CALL selfdestruct(address)(addr)""];
}
",0,0,1,0,require(bool)(msg.sender == administrator);selfdestruct(address)(addr)
./0x5cac5ac21b93095490f736205df600fb4449aee1_ext.sol,FazBitsCrowdsale.safeWithdrawal,91,103,"TMP_33 = UnaryType.BANG minimumTargetReached ,TMP_34(bool) = TMP_33 && crowdsaleClosed,CONDITION TMP_34,REF_6(uint256) -> balanceOf[msg.sender],amount(uint256) := REF_6(uint256),REF_7(uint256) -> balanceOf[msg.sender],REF_7(uint256) (->balanceOf) := 0(uint256),TMP_35(bool) = amount > 0,CONDITION TMP_35,TMP_36 = SEND dest:msg.sender value:amount,CONDITION TMP_36,Emit FundTransfer(msg.sender,amount,False),REF_9(uint256) -> balanceOf[msg.sender],REF_9(uint256) (->balanceOf) := amount(uint256),MODIFIER_CALL, FazBitsCrowdsale.afterDeadline()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: IF 1

EXPRESSION:
! minimumTargetReached && crowdsaleClosed

IRs:
TMP_33 = UnaryType.BANG minimumTargetReached 
TMP_34(bool) = TMP_33 && crowdsaleClosed
CONDITION TMP_34""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = balanceOf[msg.sender]

IRs:
REF_6(uint256) -> balanceOf[msg.sender]
amount(uint256) := REF_6(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[msg.sender] = 0

IRs:
REF_7(uint256) -> balanceOf[msg.sender]
REF_7(uint256) (->balanceOf) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
amount > 0

IRs:
TMP_35(bool) = amount > 0
CONDITION TMP_35""];
4->5[label=""True""];
4->9[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
msg.sender.send(amount)

IRs:
TMP_36 = SEND dest:msg.sender value:amount
CONDITION TMP_36""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
FundTransfer(msg.sender,amount,false)

IRs:
Emit FundTransfer(msg.sender,amount,False)""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balanceOf[msg.sender] = amount

IRs:
REF_9(uint256) -> balanceOf[msg.sender]
REF_9(uint256) (->balanceOf) := amount(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: END_IF 10
""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
afterDeadline()

IRs:
MODIFIER_CALL, FazBitsCrowdsale.afterDeadline()()""];
11->1;
}
",0,0,1,0,"afterDeadline();! minimumTargetReached && crowdsaleClosed;amount = balanceOf[msg.sender];;balanceOf[msg.sender] = 0;amount > 0;msg.sender.send(amount);;FundTransfer(msg.sender,amount,false);balanceOf[msg.sender] = amount;"
./0xf2d54d17d3dc3810a0d62042a0b381df122ed162_ext.sol,BeercoinICO.claimFunds,181,186,"TMP_52 = CONVERT this to address,TMP_53(uint256) = SOLIDITY_CALL balance(address)(TMP_52),etherAmount(uint256) := TMP_53(uint256),Transfer dest:owner value:etherAmount,Emit FundTransfer(owner,etherAmount,False),MODIFIER_CALL, GuardedBeercoinICO.onlyOwner()(),MODIFIER_CALL, BeercoinICO.goalReached()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
etherAmount = address(this).balance

IRs:
TMP_52 = CONVERT this to address
TMP_53(uint256) = SOLIDITY_CALL balance(address)(TMP_52)
etherAmount(uint256) := TMP_53(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(etherAmount)

IRs:
Transfer dest:owner value:etherAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
FundTransfer(owner,etherAmount,false)

IRs:
Emit FundTransfer(owner,etherAmount,False)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, GuardedBeercoinICO.onlyOwner()()""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
goalReached()

IRs:
MODIFIER_CALL, BeercoinICO.goalReached()()""];
5->1;
}
",0,0,1,0,"onlyOwner();etherAmount = address(this).balance;owner.transfer(etherAmount);FundTransfer(owner,etherAmount,false);goalReached()"
./0xf17a9ad24372faaa27f0bb684e13413a3de84c4b_ext.sol,SmokeCoinV_2.withdraw,307,310,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, SmokeCoinV_2.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, SmokeCoinV_2.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x36cce24d6314445c11beb80f99f9f14b5ea9ecc2_ext.sol,LynchpinPrivateICO.closeSale,216,223,"TMP_66(bool) = now > LOCK_PERIOD_START,TMP_67(None) = SOLIDITY_CALL require(bool)(TMP_66),TMP_68 = CONVERT this to address,TMP_69(uint256) = HIGH_LEVEL_CALL, dest:lynT(LynchpinToken), function:balanceOf, arguments:['TMP_68']  ,TMP_70(bool) = HIGH_LEVEL_CALL, dest:lynT(LynchpinToken), function:transfer, arguments:['msg.sender', 'TMP_69']  ,TMP_71 = CONVERT this to address,TMP_72(uint256) = SOLIDITY_CALL balance(address)(TMP_71),Transfer dest:beneficiary value:TMP_72,crowdsaleClosed(bool) := True(bool),Emit LogSaleClosed(),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now > LOCK_PERIOD_START)

IRs:
TMP_66(bool) = now > LOCK_PERIOD_START
TMP_67(None) = SOLIDITY_CALL require(bool)(TMP_66)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
lynT.transfer(msg.sender,lynT.balanceOf(address(this)))

IRs:
TMP_68 = CONVERT this to address
TMP_69(uint256) = HIGH_LEVEL_CALL, dest:lynT(LynchpinToken), function:balanceOf, arguments:['TMP_68']  
TMP_70(bool) = HIGH_LEVEL_CALL, dest:lynT(LynchpinToken), function:transfer, arguments:['msg.sender', 'TMP_69']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
beneficiary.transfer(address(this).balance)

IRs:
TMP_71 = CONVERT this to address
TMP_72(uint256) = SOLIDITY_CALL balance(address)(TMP_71)
Transfer dest:beneficiary value:TMP_72""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
crowdsaleClosed = true

IRs:
crowdsaleClosed(bool) := True(bool)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
LogSaleClosed()

IRs:
Emit LogSaleClosed()""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",0,0,1,0,"onlyOwner();require(bool)(now > LOCK_PERIOD_START);lynT.transfer(msg.sender,lynT.balanceOf(address(this)));beneficiary.transfer(address(this).balance);crowdsaleClosed = true;LogSaleClosed()"
./0xe34cae5cdc42afd4c68727a936908918b5faa675_ext.sol,MiniMeToken.fallback,500,504,"TMP_127(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller),TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127),TMP_129 = CONVERT controller to ITokenController,TMP_131(bool) = HIGH_LEVEL_CALL, dest:TMP_129(ITokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value ,TMP_132(bool) = TMP_131 == True,TMP_133(None) = SOLIDITY_CALL require(bool)(TMP_132)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isContract(controller))

IRs:
TMP_127(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)
TMP_128(None) = SOLIDITY_CALL require(bool)(TMP_127)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(ITokenController(controller).proxyPayment.value(msg.value)(msg.sender) == true)

IRs:
TMP_129 = CONVERT controller to ITokenController
TMP_131(bool) = HIGH_LEVEL_CALL, dest:TMP_129(ITokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value 
TMP_132(bool) = TMP_131 == True
TMP_133(None) = SOLIDITY_CALL require(bool)(TMP_132)""];
}
",0,0,1,0,require(bool)(isContract(controller));require(bool)(ITokenController(controller).proxyPayment.value(msg.value)(msg.sender) == true)
./0x708a64eba17df26cd7085c494b725160ba1a6b7d_ext.sol,ConditionalEscrow.withdraw,842,851,"REF_263(uint256) -> deposits[_payee],payment(uint256) := REF_263(uint256),TMP_402 = CONVERT this to address,TMP_403(uint256) = SOLIDITY_CALL balance(address)(TMP_402),TMP_404(bool) = TMP_403 >= payment,TMP_405(None) = SOLIDITY_CALL assert(bool)(TMP_404),REF_264(uint256) -> deposits[_payee],REF_264(uint256) (->deposits) := 0(uint256),Transfer dest:_payee value:payment,Emit Withdrawn(_payee,payment),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
payment = deposits[_payee]

IRs:
REF_263(uint256) -> deposits[_payee]
payment(uint256) := REF_263(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(address(this).balance >= payment)

IRs:
TMP_402 = CONVERT this to address
TMP_403(uint256) = SOLIDITY_CALL balance(address)(TMP_402)
TMP_404(bool) = TMP_403 >= payment
TMP_405(None) = SOLIDITY_CALL assert(bool)(TMP_404)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
deposits[_payee] = 0

IRs:
REF_264(uint256) -> deposits[_payee]
REF_264(uint256) (->deposits) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
_payee.transfer(payment)

IRs:
Transfer dest:_payee value:payment""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Withdrawn(_payee,payment)

IRs:
Emit Withdrawn(_payee,payment)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",0,0,1,0,"onlyOwner();payment = deposits[_payee];assert(bool)(address(this).balance >= payment);deposits[_payee] = 0;_payee.transfer(payment);Withdrawn(_payee,payment)"
./0x4c7f666ca30fe548fbdc08b0308927327f08336d_ext.sol,RefundVault.close,902,907,"REF_427(RefundVault.State) -> State.Active,TMP_757(bool) = state == REF_427,TMP_758(None) = SOLIDITY_CALL require(bool)(TMP_757),REF_428(RefundVault.State) -> State.Closed,state(RefundVault.State) := REF_428(RefundVault.State),Emit Closed(),REF_430(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:wallet value:REF_430,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_427(RefundVault.State) -> State.Active
TMP_757(bool) = state == REF_427
TMP_758(None) = SOLIDITY_CALL require(bool)(TMP_757)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
state = State.Closed

IRs:
REF_428(RefundVault.State) -> State.Closed
state(RefundVault.State) := REF_428(RefundVault.State)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Closed()

IRs:
Emit Closed()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
wallet.transfer(this.balance)

IRs:
REF_430(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:wallet value:REF_430""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();require(bool)(state == State.Active);state = State.Closed;Closed();wallet.transfer(this.balance)
./0x6b9c8c4e246f43cac225a64aee0c50434e61d7a4_ext.sol,Equio.buy_sale,91,111,"TMP_16(None) = SOLIDITY_CALL require(bool)(bought_tokens),TMP_17(bool) = block.number < earliest_buy_block,TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17),TMP_19(bool) = now < earliest_buy_time,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),TMP_21 = UnaryType.BANG kill_switch ,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),bought_tokens(bool) := True(bool),time_bought(uint256) := now(uint256),REF_8(uint256) = SOLIDITY_CALL balance(address)(this),contract_eth_value(uint256) := REF_8([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188807399A0>]),TMP_24(bool) = LOW_LEVEL_CALL, dest:sale, function:call, arguments:[] value:contract_eth_value ,TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(bought_tokens)

IRs:
TMP_16(None) = SOLIDITY_CALL require(bool)(bought_tokens)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(block.number < earliest_buy_block)

IRs:
TMP_17(bool) = block.number < earliest_buy_block
TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(now < earliest_buy_time)

IRs:
TMP_19(bool) = now < earliest_buy_time
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(! kill_switch)

IRs:
TMP_21 = UnaryType.BANG kill_switch 
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
bought_tokens = true

IRs:
bought_tokens(bool) := True(bool)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
time_bought = now

IRs:
time_bought(uint256) := now(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
contract_eth_value = this.balance

IRs:
REF_8(uint256) = SOLIDITY_CALL balance(address)(this)
contract_eth_value(uint256) := REF_8([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188807399A0>])""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(sale.call.value(contract_eth_value)())

IRs:
TMP_24(bool) = LOW_LEVEL_CALL, dest:sale, function:call, arguments:[] value:contract_eth_value 
TMP_25(None) = SOLIDITY_CALL require(bool)(TMP_24)""];
}
",0,0,1,0,require(bool)(bought_tokens);require(bool)(block.number < earliest_buy_block);require(bool)(now < earliest_buy_time);require(bool)(! kill_switch);bought_tokens = true;time_bought = now;contract_eth_value = this.balance;require(bool)(sale.call.value(contract_eth_value)())
./0xf3cb4203e10f205c6bc91d8b0974eee520af6412_ext.sol,D_Quiz.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x64d581770b541b5609140232fc12f47bbe0fe6bc_ext.sol,MonetoSale.transferEther,329,334,"TMP_131 = CONVERT this to address,TMP_132(uint256) = SOLIDITY_CALL balance(address)(TMP_131),TMP_133(uint256) = TMP_132 - alfatokenFee,TMP_134(bool) = _amount <= TMP_133,TMP_135(None) = SOLIDITY_CALL require(bool)(TMP_134),TMP_136(bool) = now < SALE_START,REF_57(MonetoSale.Stages) -> Stages.Ended,TMP_137(bool) = stage == REF_57,TMP_138(bool) = TMP_136 || TMP_137,TMP_139(None) = SOLIDITY_CALL require(bool)(TMP_138),Transfer dest:_to value:_amount,MODIFIER_CALL, MonetoSale.isOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_amount <= address(this).balance - alfatokenFee)

IRs:
TMP_131 = CONVERT this to address
TMP_132(uint256) = SOLIDITY_CALL balance(address)(TMP_131)
TMP_133(uint256) = TMP_132 - alfatokenFee
TMP_134(bool) = _amount <= TMP_133
TMP_135(None) = SOLIDITY_CALL require(bool)(TMP_134)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(now < SALE_START || stage == Stages.Ended)

IRs:
TMP_136(bool) = now < SALE_START
REF_57(MonetoSale.Stages) -> Stages.Ended
TMP_137(bool) = stage == REF_57
TMP_138(bool) = TMP_136 || TMP_137
TMP_139(None) = SOLIDITY_CALL require(bool)(TMP_138)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_to.transfer(_amount)

IRs:
Transfer dest:_to value:_amount""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
isOwner()

IRs:
MODIFIER_CALL, MonetoSale.isOwner()()""];
4->1;
}
",0,0,1,0,isOwner();require(bool)(_amount <= address(this).balance - alfatokenFee);require(bool)(now < SALE_START || stage == Stages.Ended);_to.transfer(_amount)
./0xd0d6b03cb90ec013c6a00ff60e30c3a350c1df94_ext.sol,NamiMultiSigWallet.executeTransaction,258,273,"TMP_67(bool) = INTERNAL_CALL, NamiMultiSigWallet.isConfirmed(uint256)(transactionId),CONDITION TMP_67,REF_31(NamiMultiSigWallet.Transaction) -> transactions[transactionId],REF_32(bool) -> REF_31.executed,REF_32(bool) (->transactions) := True(bool),REF_33(NamiMultiSigWallet.Transaction) -> transactions[transactionId],REF_34(address) -> REF_33.destination,REF_37(NamiMultiSigWallet.Transaction) -> transactions[transactionId],REF_38(uint256) -> REF_37.value,REF_39(NamiMultiSigWallet.Transaction) -> transactions[transactionId],REF_40(bytes) -> REF_39.data,TMP_69(bool) = LOW_LEVEL_CALL, dest:REF_34, function:call, arguments:['REF_40'] value:REF_38 ,CONDITION TMP_69,Emit Execution(transactionId),Emit ExecutionFailure(transactionId),REF_41(NamiMultiSigWallet.Transaction) -> transactions[transactionId],REF_42(bool) -> REF_41.executed,REF_42(bool) (->transactions) := False(bool),MODIFIER_CALL, NamiMultiSigWallet.notExecuted(uint256)(transactionId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
isConfirmed(transactionId)

IRs:
TMP_67(bool) = INTERNAL_CALL, NamiMultiSigWallet.isConfirmed(uint256)(transactionId)
CONDITION TMP_67""];
1->2[label=""True""];
1->8[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
transactions[transactionId].executed = true

IRs:
REF_31(NamiMultiSigWallet.Transaction) -> transactions[transactionId]
REF_32(bool) -> REF_31.executed
REF_32(bool) (->transactions) := True(bool)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)

IRs:
REF_33(NamiMultiSigWallet.Transaction) -> transactions[transactionId]
REF_34(address) -> REF_33.destination
REF_37(NamiMultiSigWallet.Transaction) -> transactions[transactionId]
REF_38(uint256) -> REF_37.value
REF_39(NamiMultiSigWallet.Transaction) -> transactions[transactionId]
REF_40(bytes) -> REF_39.data
TMP_69(bool) = LOW_LEVEL_CALL, dest:REF_34, function:call, arguments:['REF_40'] value:REF_38 
CONDITION TMP_69""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Execution(transactionId)

IRs:
Emit Execution(transactionId)""];
4->7;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
ExecutionFailure(transactionId)

IRs:
Emit ExecutionFailure(transactionId)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
transactions[transactionId].executed = false

IRs:
REF_41(NamiMultiSigWallet.Transaction) -> transactions[transactionId]
REF_42(bool) -> REF_41.executed
REF_42(bool) (->transactions) := False(bool)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: END_IF 8
""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, NamiMultiSigWallet.notExecuted(uint256)(transactionId)""];
9->1;
}
",0,0,1,0,notExecuted(transactionId);isConfirmed(transactionId);transactions[transactionId].executed = true;;transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data);Execution(transactionId);ExecutionFailure(transactionId);;transactions[transactionId].executed = false
./0x707f0612cbbfa02284e02b0010b4f859bb7308ec_ext.sol,RefundVault.del,1119,1121,"TMP_493(None) = SOLIDITY_CALL selfdestruct(address)(_wallet),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(_wallet)

IRs:
TMP_493(None) = SOLIDITY_CALL selfdestruct(address)(_wallet)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(_wallet)
./0x1d86a854da490ff74dedc7abe281fb468f8c19ee_ext.sol,MultiVesting.flushEth,342,344,"TMP_109 = CONVERT this to address,TMP_110(uint256) = SOLIDITY_CALL balance(address)(TMP_109),Transfer dest:owner value:TMP_110,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_109 = CONVERT this to address
TMP_110(uint256) = SOLIDITY_CALL balance(address)(TMP_109)
Transfer dest:owner value:TMP_110""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();owner.transfer(address(this).balance)
./0x5a779aaeb53d2cba1755442c38dd6721c0cb31d0_ext.sol,RefundVault.close,117,122,"REF_5(RefundVault.State) -> State.Active,TMP_33(bool) = state == REF_5,TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33),REF_6(RefundVault.State) -> State.Closed,state(RefundVault.State) := REF_6(RefundVault.State),Emit Closed(),REF_8(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:wallet value:REF_8,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_5(RefundVault.State) -> State.Active
TMP_33(bool) = state == REF_5
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
state = State.Closed

IRs:
REF_6(RefundVault.State) -> State.Closed
state(RefundVault.State) := REF_6(RefundVault.State)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Closed()

IRs:
Emit Closed()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
wallet.transfer(this.balance)

IRs:
REF_8(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:wallet value:REF_8""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();require(bool)(state == State.Active);state = State.Closed;Closed();wallet.transfer(this.balance)
./0xee7477b1c42d173c0791cecf2592f6a8a4c16b0a_ext.sol,BiddingBase.destroyContract,122,125,"TMP_38(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(msg.sender)

IRs:
TMP_38(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(msg.sender)
./0x46822ac3bc32db7ebd9845da3fe0886f824e9edf_ext.sol,EBSCSale.safeWithdrawal,681,691,"TMP_241 = UnaryType.BANG fundingGoalReached ,CONDITION TMP_241,REF_131(uint256) -> balanceOf[msg.sender],amount(uint256) := REF_131(uint256),REF_132(uint256) -> balanceOf[msg.sender],REF_132(uint256) (->balanceOf) := 0(uint256),TMP_242(bool) = amount > 0,CONDITION TMP_242,Transfer dest:msg.sender value:amount,Emit FundTransfer(msg.sender,amount,False),TMP_245(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['refundAmount', 'amount'] ,refundAmount(uint256) := TMP_245(uint256),MODIFIER_CALL, EBSCSale.afterDeadline()(),MODIFIER_CALL, EBSCSale.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: IF 1

EXPRESSION:
! fundingGoalReached

IRs:
TMP_241 = UnaryType.BANG fundingGoalReached 
CONDITION TMP_241""];
1->2[label=""True""];
1->9[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = balanceOf[msg.sender]

IRs:
REF_131(uint256) -> balanceOf[msg.sender]
amount(uint256) := REF_131(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[msg.sender] = 0

IRs:
REF_132(uint256) -> balanceOf[msg.sender]
REF_132(uint256) (->balanceOf) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
amount > 0

IRs:
TMP_242(bool) = amount > 0
CONDITION TMP_242""];
4->5[label=""True""];
4->8[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
FundTransfer(msg.sender,amount,false)

IRs:
Emit FundTransfer(msg.sender,amount,False)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
refundAmount = refundAmount.add(amount)

IRs:
TMP_245(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['refundAmount', 'amount'] 
refundAmount(uint256) := TMP_245(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
afterDeadline()

IRs:
MODIFIER_CALL, EBSCSale.afterDeadline()()""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, EBSCSale.nonReentrant()()""];
11->1;
}
",0,0,1,0,"afterDeadline();! fundingGoalReached;amount = balanceOf[msg.sender];;balanceOf[msg.sender] = 0;amount > 0;msg.sender.transfer(amount);;FundTransfer(msg.sender,amount,false);refundAmount = refundAmount.add(amount);nonReentrant()"
./0x1fbf025ad94dde79f88732f79966a9a435f2772f_ext.sol,BLITZQUIZ.Play,5,14,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x40ef62929748b3e045fd2036322880ef486e4454_ext.sol,IQ_GAME.Play,5,14,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x70785fec3fad3a3f855d939b74be05fca3ee9d7b_ext.sol,f_game.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 400000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 400000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 400000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 400000000000000000;msg.sender.transfer(this.balance);
./0x03eff7f353aeebea3ac5f23a6e9e844581ff5ef8_ext.sol,PLAY_iQuiz.Stop,28,30,"REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3,MODIFIER_CALL, PLAY_iQuiz.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, PLAY_iQuiz.isAdmin()()""];
2->1;
}
",0,0,1,0,isAdmin();msg.sender.transfer(this.balance)
./0xdf4b22695eeb4a7a1cf9a42162285ce782b8427a_ext.sol,Token.claimTokens,449,459,"TMP_97(bool) = _token == 0,CONDITION TMP_97,REF_59(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:controller value:REF_59,TMP_99 = CONVERT _token to Token,token(Token) := TMP_99(Token),TMP_100(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_100(uint256),TMP_101(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transfer, arguments:['controller', 'balance']  ,Emit ClaimedTokens(_token,controller,balance),MODIFIER_CALL, Controlled.onlyController()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_97(bool) = _token == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_59(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_59""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
token = Token(_token)

IRs:
TMP_99 = CONVERT _token to Token
token(Token) := TMP_99(Token)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_100(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_100(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_101(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transfer, arguments:['controller', 'balance']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()""];
9->1;
}
",0,0,1,0,"onlyController();_token == 0x0;controller.transfer(this.balance);;;token = Token(_token);balance = token.balanceOf(this);token.transfer(controller,balance);ClaimedTokens(_token,controller,balance)"
./0x70fa6e7cf0ecf0e97415f3abbbc8eb67e0c2c588_ext.sol,MyAdvancedToken.getEth,261,263,Transfer dest:owner value:num,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(num)

IRs:
Transfer dest:owner value:num""];
}
",0,0,1,0,owner.transfer(num)
./0x791af5fcb5198c9f469d66b934864dab43d7f044_ext.sol,Verus.withdraw,300,303,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, Verus.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Verus.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0xd16dfe7a7f447b00122a01efd5acb99a7aee7c04_ext.sol,EncryptedToken.getEth,198,200,TMP_90 = SEND dest:owner value:num,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.send(num)

IRs:
TMP_90 = SEND dest:owner value:num""];
}
",0,0,1,0,owner.send(num)
./0x75cb629408d1ea387df0a1f755e0bc371a5fa036_ext.sol,GoodLuckCasino.ownerWithdraw,169,173,"TMP_44 = CONVERT this to address,TMP_45(uint256) = SOLIDITY_CALL balance(address)(TMP_44),TMP_46(bool) = TMP_45 > _val,TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46),Transfer dest:_to value:_val,Emit LOG_OwnerWithdraw(_to,_val),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(address(this).balance > _val)

IRs:
TMP_44 = CONVERT this to address
TMP_45(uint256) = SOLIDITY_CALL balance(address)(TMP_44)
TMP_46(bool) = TMP_45 > _val
TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_to.transfer(_val)

IRs:
Transfer dest:_to value:_val""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
LOG_OwnerWithdraw(_to,_val)

IRs:
Emit LOG_OwnerWithdraw(_to,_val)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->1;
}
",0,0,1,0,"onlyOwner();require(bool)(address(this).balance > _val);_to.transfer(_val);LOG_OwnerWithdraw(_to,_val)"
./0x219e0b7c4868add72a913eef492c228cd1f45cdd_ext.sol,Firextoken.withdraw,300,303,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, Firextoken.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Firextoken.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0xf2f13b50e63454a5ce255f8355285561c13bb3cc_ext.sol,BNCXCrowdsale.fallback,60,84,"TMP_18(bool) = msg.value > 0,TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18),TMP_20(bool) = now > startDate,TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20),TMP_22(bool) = now < endDate,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),TMP_24(uint256) = msg.value / 10000000000,amount(uint256) := TMP_24(uint256),TMP_25(bool) = now > startDate,TMP_26(bool) = now < 1516060800,TMP_27(bool) = TMP_25 && TMP_26,CONDITION TMP_27,TMP_28(uint256) = msg.value * 625,amount(uint256) := TMP_28(uint256),TMP_29(bool) = now > 1516060800,TMP_30(bool) = now < 1518825600,TMP_31(bool) = TMP_29 && TMP_30,CONDITION TMP_31,TMP_32(uint256) = msg.value * 235,amount(uint256) := TMP_32(uint256),TMP_33(bool) = now > 1518825600,TMP_34(bool) = now < endDate,TMP_35(bool) = TMP_33 && TMP_34,CONDITION TMP_35,TMP_36(uint256) = msg.value * 118,amount(uint256) := TMP_36(uint256),HIGH_LEVEL_CALL, dest:tokenReward(Token), function:transfer, arguments:['msg.sender', 'amount']  ,Emit FundTransfer(msg.sender,amount),Transfer dest:owner value:msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value > 0)

IRs:
TMP_18(bool) = msg.value > 0
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(now > startDate)

IRs:
TMP_20(bool) = now > startDate
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(now < endDate)

IRs:
TMP_22(bool) = now < endDate
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
amount = msg.value / 10000000000

IRs:
TMP_24(uint256) = msg.value / 10000000000
amount(uint256) := TMP_24(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
now > startDate && now < 1516060800

IRs:
TMP_25(bool) = now > startDate
TMP_26(bool) = now < 1516060800
TMP_27(bool) = TMP_25 && TMP_26
CONDITION TMP_27""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
amount = msg.value * 625

IRs:
TMP_28(uint256) = msg.value * 625
amount(uint256) := TMP_28(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
now > 1516060800 && now < 1518825600

IRs:
TMP_29(bool) = now > 1516060800
TMP_30(bool) = now < 1518825600
TMP_31(bool) = TMP_29 && TMP_30
CONDITION TMP_31""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
amount = msg.value * 235

IRs:
TMP_32(uint256) = msg.value * 235
amount(uint256) := TMP_32(uint256)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
now > 1518825600 && now < endDate

IRs:
TMP_33(bool) = now > 1518825600
TMP_34(bool) = now < endDate
TMP_35(bool) = TMP_33 && TMP_34
CONDITION TMP_35""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
amount = msg.value * 118

IRs:
TMP_36(uint256) = msg.value * 118
amount(uint256) := TMP_36(uint256)""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
tokenReward.transfer(msg.sender,amount)

IRs:
HIGH_LEVEL_CALL, dest:tokenReward(Token), function:transfer, arguments:['msg.sender', 'amount']  ""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
FundTransfer(msg.sender,amount)

IRs:
Emit FundTransfer(msg.sender,amount)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
owner.transfer(msg.value)

IRs:
Transfer dest:owner value:msg.value""];
}
",0,0,1,0,"require(bool)(msg.value > 0);require(bool)(now > startDate);require(bool)(now < endDate);amount = msg.value / 10000000000;now > startDate && now < 1516060800;amount = msg.value * 625;;now > 1516060800 && now < 1518825600;amount = msg.value * 235;;now > 1518825600 && now < endDate;amount = msg.value * 118;;tokenReward.transfer(msg.sender,amount);FundTransfer(msg.sender,amount);owner.transfer(msg.value)"
./0xe3ac32bbf9e3661c3aff4ee2f80706abaf7c7ea6_ext.sol,Dividend.withdraw,61,73,"REF_18(Dividend.Record) -> records[msg.sender],rec(Dividend.Record) := REF_18(Dividend.Record),REF_19(uint256) -> rec.balance,balance(uint256) := REF_19(uint256),TMP_23(bool) = balance > 0,CONDITION TMP_23,REF_20(uint256) -> rec.balance,REF_20(uint256) (->rec) := 0(uint256),Transfer dest:msg.sender value:balance,Emit Withdrawn(now,msg.sender,balance),TMP_26(uint256) = now - lastInvestmentTime,TMP_27(bool) = TMP_26 > 2419200,CONDITION TMP_27,TMP_28(None) = SOLIDITY_CALL selfdestruct(address)(funder),RETURN balance","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
rec = records[msg.sender]

IRs:
REF_18(Dividend.Record) -> records[msg.sender]
rec(Dividend.Record) := REF_18(Dividend.Record)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
balance = rec.balance

IRs:
REF_19(uint256) -> rec.balance
balance(uint256) := REF_19(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
balance > 0

IRs:
TMP_23(bool) = balance > 0
CONDITION TMP_23""];
3->4[label=""True""];
3->7[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
rec.balance = 0

IRs:
REF_20(uint256) -> rec.balance
REF_20(uint256) (->rec) := 0(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(balance)

IRs:
Transfer dest:msg.sender value:balance""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Withdrawn(now,msg.sender,balance)

IRs:
Emit Withdrawn(now,msg.sender,balance)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
now - lastInvestmentTime > 2419200

IRs:
TMP_26(uint256) = now - lastInvestmentTime
TMP_27(bool) = TMP_26 > 2419200
CONDITION TMP_27""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
selfdestruct(address)(funder)

IRs:
TMP_28(None) = SOLIDITY_CALL selfdestruct(address)(funder)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: RETURN 11

EXPRESSION:
balance

IRs:
RETURN balance""];
}
",0,1,1,0,"rec = records[msg.sender];balance = rec.balance;balance > 0;rec.balance = 0;;msg.sender.transfer(balance);Withdrawn(now,msg.sender,balance);now - lastInvestmentTime > 2419200;selfdestruct(address)(funder);;balance"
./0x184c8624d79f41eff9b3a702737ee86eeef80e67_ext.sol,EthMonsters.withdrawFees,139,144,"TMP_51(bool) = contractFees > 0,TMP_52(None) = SOLIDITY_CALL require(bool)(TMP_51),amount(uint256) := contractFees(uint256),contractFees(uint256) := 0(uint256),Transfer dest:msg.sender value:amount,MODIFIER_CALL, EthMonsters.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(contractFees > 0)

IRs:
TMP_51(bool) = contractFees > 0
TMP_52(None) = SOLIDITY_CALL require(bool)(TMP_51)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = contractFees

IRs:
amount(uint256) := contractFees(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
contractFees = 0

IRs:
contractFees(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, EthMonsters.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();require(bool)(contractFees > 0);amount = contractFees;contractFees = 0;msg.sender.transfer(amount)
./0x05b04cb2c29691d3f9ce74e6aa3c69548da3bee2_ext.sol,EtherStateEquivalentToken.withdrawAmount,103,116,"TMP_32(bool) = amount > 0,TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32),TMP_34(None) = SOLIDITY_CALL require(bool)(softCapReached),REF_11(uint256) -> refBalance[msg.sender],value(uint256) := REF_11(uint256),TMP_35(bool) = value >= amount,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),REF_12(uint256) -> refBalance[msg.sender],TMP_37(uint256) = value - amount,REF_12(uint256) (->refBalance) := TMP_37(uint256),Transfer dest:msg.sender value:amount,Emit OnWithdraw(msg.sender,amount,now)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_32(bool) = amount > 0
TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(softCapReached)

IRs:
TMP_34(None) = SOLIDITY_CALL require(bool)(softCapReached)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
value = refBalance[msg.sender]

IRs:
REF_11(uint256) -> refBalance[msg.sender]
value(uint256) := REF_11(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(value >= amount)

IRs:
TMP_35(bool) = value >= amount
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
refBalance[msg.sender] = value - amount

IRs:
REF_12(uint256) -> refBalance[msg.sender]
TMP_37(uint256) = value - amount
REF_12(uint256) (->refBalance) := TMP_37(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
OnWithdraw(msg.sender,amount,now)

IRs:
Emit OnWithdraw(msg.sender,amount,now)""];
}
",0,0,1,0,"require(bool)(amount > 0);require(bool)(softCapReached);value = refBalance[msg.sender];require(bool)(value >= amount);refBalance[msg.sender] = value - amount;msg.sender.transfer(amount);OnWithdraw(msg.sender,amount,now)"
./0x50ec4b1f8434020e2d896c9cfb8a20d63af6136d_ext.sol,Snip3D.die,307,309,"TMP_132(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(msg.sender)

IRs:
TMP_132(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(msg.sender)
./0xd37a7e9d4681da273e13d652ed9a789274d32bd7_ext.sol,LUPXSale.endLUPXSale,64,68,"TMP_24(uint256) = HIGH_LEVEL_CALL, dest:tokenContract(IERC20Token), function:balanceOf, arguments:['this']  ,TMP_25(bool) = HIGH_LEVEL_CALL, dest:tokenContract(IERC20Token), function:transfer, arguments:['owner', 'TMP_24']  ,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),TMP_27 = CONVERT this to address,TMP_28(uint256) = SOLIDITY_CALL balance(address)(TMP_27),Transfer dest:msg.sender value:TMP_28,Emit endOfSale(now),MODIFIER_CALL, LUPXSale.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(tokenContract.transfer(owner,tokenContract.balanceOf(this)))

IRs:
TMP_24(uint256) = HIGH_LEVEL_CALL, dest:tokenContract(IERC20Token), function:balanceOf, arguments:['this']  
TMP_25(bool) = HIGH_LEVEL_CALL, dest:tokenContract(IERC20Token), function:transfer, arguments:['owner', 'TMP_24']  
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_27 = CONVERT this to address
TMP_28(uint256) = SOLIDITY_CALL balance(address)(TMP_27)
Transfer dest:msg.sender value:TMP_28""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
endOfSale(now)

IRs:
Emit endOfSale(now)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, LUPXSale.onlyOwner()()""];
4->1;
}
",0,0,1,0,"onlyOwner();require(bool)(tokenContract.transfer(owner,tokenContract.balanceOf(this)));msg.sender.transfer(address(this).balance);endOfSale(now)"
./0xd7b45e0cdae4c65ef2c7e19152eeb3074e20f98f_ext.sol,Owned.harvest,41,43,"REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:_owner value:REF_1,MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_owner.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:_owner value:REF_1""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();_owner.transfer(this.balance)
./0x714c1ef3854591d4118bd6887d4740bc4d5f5412_ext.sol,KaasyToken.internalFinishMinting,367,372,"TMP_198(uint256) = now + 3600,tradingDate(uint256) := TMP_198(uint256),isMintingFinished(bool) := True(bool),Emit MintingFinished(now),TMP_200 = CONVERT this to address,TMP_201(uint256) = SOLIDITY_CALL balance(address)(TMP_200),Transfer dest:owner value:TMP_201","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
tradingDate = now + 3600

IRs:
TMP_198(uint256) = now + 3600
tradingDate(uint256) := TMP_198(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isMintingFinished = true

IRs:
isMintingFinished(bool) := True(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
MintingFinished(now)

IRs:
Emit MintingFinished(now)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_200 = CONVERT this to address
TMP_201(uint256) = SOLIDITY_CALL balance(address)(TMP_200)
Transfer dest:owner value:TMP_201""];
}
",0,0,1,0,tradingDate = now + 3600;isMintingFinished = true;MintingFinished(now);owner.transfer(address(this).balance)
./0x33d1a1a2d781d395eace70e69423c594e52f1a8b_ext.sol,MultiOwner.kill,133,138,"REF_31(bool) -> RequireDispose[msg.sender],REF_31(bool) (->RequireDispose) := True(bool),TMP_51(bool) = INTERNAL_CALL, MultiOwner.ConfirmDispose()(),CONDITION TMP_51,TMP_52(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender),MODIFIER_CALL, MultiOwner.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
RequireDispose[msg.sender] = true

IRs:
REF_31(bool) -> RequireDispose[msg.sender]
REF_31(bool) (->RequireDispose) := True(bool)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
ConfirmDispose()

IRs:
TMP_51(bool) = INTERNAL_CALL, MultiOwner.ConfirmDispose()()
CONDITION TMP_51""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
selfdestruct(address)(msg.sender)

IRs:
TMP_52(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender)""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();RequireDispose[msg.sender] = true;ConfirmDispose();selfdestruct(address)(msg.sender);
./0x27369e8f43f44c26853a46da7e6cb52d203b59ce_ext.sol,AgileCycleWithAssistance.failSafe,802,812,"TMP_372(bool) = msg.sender == operator,CONDITION TMP_372,saveMe(bool) := True(bool),TMP_373(bool) = msg.sender == juryOperator,CONDITION TMP_373,TMP_374(bool) = saveMe == True,TMP_375(None) = SOLIDITY_CALL require(bool)(TMP_374),TMP_376 = CONVERT this to address,TMP_377(uint256) = SOLIDITY_CALL balance(address)(TMP_376),TMP_378 = SEND dest:juryOperator value:TMP_377,TMP_379(None) = SOLIDITY_CALL require(bool)(TMP_378),TMP_380(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:balanceOf, arguments:['this']  ,allTheLockedTokens(uint256) := TMP_380(uint256),TMP_381(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transfer, arguments:['juryOperator', 'allTheLockedTokens']  ,TMP_382(None) = SOLIDITY_CALL require(bool)(TMP_381)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == operator

IRs:
TMP_372(bool) = msg.sender == operator
CONDITION TMP_372""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
saveMe = true

IRs:
saveMe(bool) := True(bool)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
msg.sender == juryOperator

IRs:
TMP_373(bool) = msg.sender == juryOperator
CONDITION TMP_373""];
4->5[label=""True""];
4->9[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(saveMe == true)

IRs:
TMP_374(bool) = saveMe == True
TMP_375(None) = SOLIDITY_CALL require(bool)(TMP_374)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(juryOperator.send(address(this).balance))

IRs:
TMP_376 = CONVERT this to address
TMP_377(uint256) = SOLIDITY_CALL balance(address)(TMP_376)
TMP_378 = SEND dest:juryOperator value:TMP_377
TMP_379(None) = SOLIDITY_CALL require(bool)(TMP_378)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
allTheLockedTokens = token.balanceOf(this)

IRs:
TMP_380(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:balanceOf, arguments:['this']  
allTheLockedTokens(uint256) := TMP_380(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(token.transfer(juryOperator,allTheLockedTokens))

IRs:
TMP_381(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transfer, arguments:['juryOperator', 'allTheLockedTokens']  
TMP_382(None) = SOLIDITY_CALL require(bool)(TMP_381)""];
8->9;
9[label=""Node Type: END_IF 9
""];
}
",0,0,1,0,"msg.sender == operator;saveMe = true;;msg.sender == juryOperator;require(bool)(saveMe == true);;require(bool)(juryOperator.send(address(this).balance));allTheLockedTokens = token.balanceOf(this);require(bool)(token.transfer(juryOperator,allTheLockedTokens))"
./0x6d84769b1e287a27f282a938c8110b22714dbf78_ext.sol,ABIO_preICO.safeWithdrawal,200,219,"TMP_119 = UnaryType.BANG fundingGoalReached ,TMP_120(bool) = now >= finalDeadline,TMP_121(bool) = TMP_119 && TMP_120,CONDITION TMP_121,REF_10(uint256) -> ethBalances[msg.sender],amount(uint256) := REF_10(uint256),REF_11(uint256) -> ethBalances[msg.sender],REF_11(uint256) (->ethBalances) := 0(uint256),TMP_122(bool) = amount > 0,CONDITION TMP_122,TMP_123 = SEND dest:msg.sender value:amount,CONDITION TMP_123,Emit FundsWithdrawn(msg.sender,amount),REF_13(uint256) -> ethBalances[msg.sender],REF_13(uint256) (->ethBalances) := amount(uint256),TMP_125(bool) = treasury == msg.sender,TMP_126(bool) = fundingGoalReached && TMP_125,CONDITION TMP_126,TMP_127 = SEND dest:treasury value:weiRaised,CONDITION TMP_127,Emit FundsWithdrawn(treasury,weiRaised),TMP_129 = CONVERT this to address,TMP_130(uint256) = SOLIDITY_CALL balance(address)(TMP_129),TMP_131 = SEND dest:treasury value:TMP_130,CONDITION TMP_131,TMP_132 = CONVERT this to address,TMP_133(uint256) = SOLIDITY_CALL balance(address)(TMP_132),Emit FundsWithdrawn(treasury,TMP_133),MODIFIER_CALL, ABIO_BaseICO.afterDeadline()(),MODIFIER_CALL, Haltable.stopOnPause()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->19;
1[label=""Node Type: IF 1

EXPRESSION:
! fundingGoalReached && now >= finalDeadline

IRs:
TMP_119 = UnaryType.BANG fundingGoalReached 
TMP_120(bool) = now >= finalDeadline
TMP_121(bool) = TMP_119 && TMP_120
CONDITION TMP_121""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = ethBalances[msg.sender]

IRs:
REF_10(uint256) -> ethBalances[msg.sender]
amount(uint256) := REF_10(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ethBalances[msg.sender] = 0

IRs:
REF_11(uint256) -> ethBalances[msg.sender]
REF_11(uint256) (->ethBalances) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
amount > 0

IRs:
TMP_122(bool) = amount > 0
CONDITION TMP_122""];
4->5[label=""True""];
4->9[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
msg.sender.send(amount)

IRs:
TMP_123 = SEND dest:msg.sender value:amount
CONDITION TMP_123""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
FundsWithdrawn(msg.sender,amount)

IRs:
Emit FundsWithdrawn(msg.sender,amount)""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
ethBalances[msg.sender] = amount

IRs:
REF_13(uint256) -> ethBalances[msg.sender]
REF_13(uint256) (->ethBalances) := amount(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->18;
10[label=""Node Type: IF 10

EXPRESSION:
fundingGoalReached && treasury == msg.sender

IRs:
TMP_125(bool) = treasury == msg.sender
TMP_126(bool) = fundingGoalReached && TMP_125
CONDITION TMP_126""];
10->11[label=""True""];
10->17[label=""False""];
11[label=""Node Type: IF 11

EXPRESSION:
treasury.send(weiRaised)

IRs:
TMP_127 = SEND dest:treasury value:weiRaised
CONDITION TMP_127""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
FundsWithdrawn(treasury,weiRaised)

IRs:
Emit FundsWithdrawn(treasury,weiRaised)""];
12->16;
13[label=""Node Type: IF 13

EXPRESSION:
treasury.send(address(this).balance)

IRs:
TMP_129 = CONVERT this to address
TMP_130(uint256) = SOLIDITY_CALL balance(address)(TMP_129)
TMP_131 = SEND dest:treasury value:TMP_130
CONDITION TMP_131""];
13->14[label=""True""];
13->15[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
FundsWithdrawn(treasury,address(this).balance)

IRs:
TMP_132 = CONVERT this to address
TMP_133(uint256) = SOLIDITY_CALL balance(address)(TMP_132)
Emit FundsWithdrawn(treasury,TMP_133)""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
afterDeadline()

IRs:
MODIFIER_CALL, ABIO_BaseICO.afterDeadline()()""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
stopOnPause()

IRs:
MODIFIER_CALL, Haltable.stopOnPause()()""];
20->1;
}
",0,0,1,0,"afterDeadline();! fundingGoalReached && now >= finalDeadline;amount = ethBalances[msg.sender];fundingGoalReached && treasury == msg.sender;ethBalances[msg.sender] = 0;amount > 0;msg.sender.send(amount);;FundsWithdrawn(msg.sender,amount);ethBalances[msg.sender] = amount;;;treasury.send(weiRaised);;FundsWithdrawn(treasury,weiRaised);treasury.send(address(this).balance);;FundsWithdrawn(treasury,address(this).balance);;stopOnPause()"
./0xb39673a1f27ea2da6fd299368fe9fdbae4bc408f_ext.sol,a_game.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 400000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 400000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 400000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 400000000000000000;msg.sender.transfer(this.balance);
./0x78a73b6cbc5d183ce56e786f6e905cadec63547b_ext.sol,FabricTokenFundraiser.finalize,793,816,"TMP_308(bool) = totalSupply >= hardCap,TMP_309(bool) = now >= endDate,TMP_310(bool) = TMP_308 || TMP_309,TMP_311(None) = SOLIDITY_CALL require(bool)(TMP_310),TMP_312 = UnaryType.BANG finalized ,TMP_313(None) = SOLIDITY_CALL require(bool)(TMP_312),REF_150(uint256) = SOLIDITY_CALL balance(address)(this),Emit Finalized(beneficiary,REF_150,totalSupply),REF_152(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:beneficiary value:REF_152,TMP_316(uint256) = HIGH_LEVEL_CALL, dest:fabricTokenSafe(FabricTokenSafe), function:totalTokensLocked, arguments:[]  ,totalTokensLocked(uint256) := TMP_316(uint256),TMP_317 = CONVERT fabricTokenSafe to address,REF_154(uint256) -> balances[TMP_317],TMP_318 = CONVERT fabricTokenSafe to address,REF_155(uint256) -> balances[TMP_318],TMP_319(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['REF_155', 'totalTokensLocked'] ,REF_154(uint256) (->balances) := TMP_319(uint256),TMP_320(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['totalSupply', 'totalTokensLocked'] ,totalSupply(uint256) := TMP_320(uint256),REF_158(uint256) -> balances[owner],REF_159(uint256) -> balances[owner],TMP_321(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['REF_159', 'TOKENS_BOUNTY_PROGRAM'] ,REF_158(uint256) (->balances) := TMP_321(uint256),TMP_322(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['totalSupply', 'TOKENS_BOUNTY_PROGRAM'] ,totalSupply(uint256) := TMP_322(uint256),finalized(bool) := True(bool),INTERNAL_CALL, Freezable.unfreeze()(),MODIFIER_CALL, HasOwner.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((totalSupply >= hardCap) || (now >= endDate))

IRs:
TMP_308(bool) = totalSupply >= hardCap
TMP_309(bool) = now >= endDate
TMP_310(bool) = TMP_308 || TMP_309
TMP_311(None) = SOLIDITY_CALL require(bool)(TMP_310)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! finalized)

IRs:
TMP_312 = UnaryType.BANG finalized 
TMP_313(None) = SOLIDITY_CALL require(bool)(TMP_312)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Finalized(beneficiary,this.balance,totalSupply)

IRs:
REF_150(uint256) = SOLIDITY_CALL balance(address)(this)
Emit Finalized(beneficiary,REF_150,totalSupply)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
beneficiary.transfer(this.balance)

IRs:
REF_152(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:beneficiary value:REF_152""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
totalTokensLocked = fabricTokenSafe.totalTokensLocked()

IRs:
TMP_316(uint256) = HIGH_LEVEL_CALL, dest:fabricTokenSafe(FabricTokenSafe), function:totalTokensLocked, arguments:[]  
totalTokensLocked(uint256) := TMP_316(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balances[address(fabricTokenSafe)] = balances[address(fabricTokenSafe)].plus(totalTokensLocked)

IRs:
TMP_317 = CONVERT fabricTokenSafe to address
REF_154(uint256) -> balances[TMP_317]
TMP_318 = CONVERT fabricTokenSafe to address
REF_155(uint256) -> balances[TMP_318]
TMP_319(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['REF_155', 'totalTokensLocked'] 
REF_154(uint256) (->balances) := TMP_319(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
totalSupply = totalSupply.plus(totalTokensLocked)

IRs:
TMP_320(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['totalSupply', 'totalTokensLocked'] 
totalSupply(uint256) := TMP_320(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[owner] = balances[owner].plus(TOKENS_BOUNTY_PROGRAM)

IRs:
REF_158(uint256) -> balances[owner]
REF_159(uint256) -> balances[owner]
TMP_321(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['REF_159', 'TOKENS_BOUNTY_PROGRAM'] 
REF_158(uint256) (->balances) := TMP_321(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
totalSupply = totalSupply.plus(TOKENS_BOUNTY_PROGRAM)

IRs:
TMP_322(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['totalSupply', 'TOKENS_BOUNTY_PROGRAM'] 
totalSupply(uint256) := TMP_322(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
finalized = true

IRs:
finalized(bool) := True(bool)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
unfreeze()

IRs:
INTERNAL_CALL, Freezable.unfreeze()()""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, HasOwner.onlyOwner()()""];
12->1;
}
",1,0,1,0,"onlyOwner();require(bool)((totalSupply >= hardCap) || (now >= endDate));require(bool)(! finalized);Finalized(beneficiary,this.balance,totalSupply);beneficiary.transfer(this.balance);totalTokensLocked = fabricTokenSafe.totalTokensLocked();balances[address(fabricTokenSafe)] = balances[address(fabricTokenSafe)].plus(totalTokensLocked);totalSupply = totalSupply.plus(totalTokensLocked);balances[owner] = balances[owner].plus(TOKENS_BOUNTY_PROGRAM);totalSupply = totalSupply.plus(TOKENS_BOUNTY_PROGRAM);finalized = true;unfreeze()"
./0x41b8d6336bdab8991ad1c48e3579d0693db17e79_ext.sol,MNY.withdrawDevFees,306,310,"TMP_137(None) = SOLIDITY_CALL require(bool)(_payFees),Transfer dest:_devFeesAddr value:_devFees,_devFees(uint256) := 0(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_payFees)

IRs:
TMP_137(None) = SOLIDITY_CALL require(bool)(_payFees)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_devFeesAddr.transfer(_devFees)

IRs:
Transfer dest:_devFeesAddr value:_devFees""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_devFees = 0

IRs:
_devFees(uint256) := 0(uint256)""];
}
",0,0,1,0,require(bool)(_payFees);_devFeesAddr.transfer(_devFees);_devFees = 0
./0x2066a2e0cd7f19589f582e2fc9af9669cc9e02f1_ext.sol,SetherToken.killContract,58,64,"TMP_6(bool) = msg.sender == owner,TMP_7(bool) = msg.value >= howManyEtherInWeiToKillContract,TMP_8(bool) = TMP_6 || TMP_7,CONDITION TMP_8,TMP_9(None) = SOLIDITY_CALL selfdestruct(address)(owner)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == owner || msg.value >= howManyEtherInWeiToKillContract

IRs:
TMP_6(bool) = msg.sender == owner
TMP_7(bool) = msg.value >= howManyEtherInWeiToKillContract
TMP_8(bool) = TMP_6 || TMP_7
CONDITION TMP_8""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_9(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,0,1,0,msg.sender == owner || msg.value >= howManyEtherInWeiToKillContract;selfdestruct(address)(owner);
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.adminUpdateWallet,2,2,"TMP_68 = CONVERT 0 to address,TMP_69(bool) = _wallet != TMP_68,TMP_70(None) = SOLIDITY_CALL require(bool)(TMP_69),wallet(address) := _wallet(address),Emit eWalletChange(wallet,msg.sender),MODIFIER_CALL, KahnDistributionCentre.onlyAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_68 = CONVERT 0 to address
TMP_69(bool) = _wallet != TMP_68
TMP_70(None) = SOLIDITY_CALL require(bool)(TMP_69)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
eWalletChange(wallet,msg.sender)

IRs:
Emit eWalletChange(wallet,msg.sender)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyAdmin()()""];
4->1;
}
",0,1,1,0,"onlyAdmin();require(bool)(_wallet != address(0));wallet = _wallet;eWalletChange(wallet,msg.sender)"
./0xf2861ad8dd602269c21eddd4d18255903cca47c7_ext.sol,ZethrMultiSigWallet.executeTransaction,379,393,"TMP_78(bool) = INTERNAL_CALL, ZethrMultiSigWallet.isConfirmed(uint256)(transactionId),CONDITION TMP_78,REF_32(ZethrMultiSigWallet.Transaction) -> transactions[transactionId],txToExecute(ZethrMultiSigWallet.Transaction) := REF_32(ZethrMultiSigWallet.Transaction),REF_33(bool) -> txToExecute.executed,REF_33(bool) (->txToExecute) := True(bool),REF_34(address) -> txToExecute.destination,REF_37(uint256) -> txToExecute.value,REF_38(bytes) -> txToExecute.data,TMP_80(bool) = LOW_LEVEL_CALL, dest:REF_34, function:call, arguments:['REF_38'] value:REF_37 ,CONDITION TMP_80,Emit Execution(transactionId),Emit ExecutionFailure(transactionId),REF_39(bool) -> txToExecute.executed,REF_39(bool) (->txToExecute) := False(bool),MODIFIER_CALL, ZethrMultiSigWallet.notExecuted(uint256)(transactionId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: IF 1

EXPRESSION:
isConfirmed(transactionId)

IRs:
TMP_78(bool) = INTERNAL_CALL, ZethrMultiSigWallet.isConfirmed(uint256)(transactionId)
CONDITION TMP_78""];
1->2[label=""True""];
1->9[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
txToExecute = transactions[transactionId]

IRs:
REF_32(ZethrMultiSigWallet.Transaction) -> transactions[transactionId]
txToExecute(ZethrMultiSigWallet.Transaction) := REF_32(ZethrMultiSigWallet.Transaction)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
txToExecute.executed = true

IRs:
REF_33(bool) -> txToExecute.executed
REF_33(bool) (->txToExecute) := True(bool)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
txToExecute.destination.call.value(txToExecute.value)(txToExecute.data)

IRs:
REF_34(address) -> txToExecute.destination
REF_37(uint256) -> txToExecute.value
REF_38(bytes) -> txToExecute.data
TMP_80(bool) = LOW_LEVEL_CALL, dest:REF_34, function:call, arguments:['REF_38'] value:REF_37 
CONDITION TMP_80""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Execution(transactionId)

IRs:
Emit Execution(transactionId)""];
5->8;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
ExecutionFailure(transactionId)

IRs:
Emit ExecutionFailure(transactionId)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
txToExecute.executed = false

IRs:
REF_39(bool) -> txToExecute.executed
REF_39(bool) (->txToExecute) := False(bool)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, ZethrMultiSigWallet.notExecuted(uint256)(transactionId)""];
10->1;
}
",0,0,1,0,notExecuted(transactionId);isConfirmed(transactionId);txToExecute = transactions[transactionId];;txToExecute.executed = true;txToExecute.destination.call.value(txToExecute.value)(txToExecute.data);Execution(transactionId);ExecutionFailure(transactionId);;txToExecute.executed = false
./0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37_ext.sol,WhaleGiveaway1.withdraw,25,31,"TMP_3(bool) = msg.sender == 698670862888103124090043688033161627232733560907,CONDITION TMP_3,Owner(address) := 698670862888103124090043688033161627232733560907(address),TMP_4(bool) = msg.sender == Owner,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_5(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:Owner value:REF_5","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == 0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b

IRs:
TMP_3(bool) = msg.sender == 698670862888103124090043688033161627232733560907
CONDITION TMP_3""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Owner = 0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b

IRs:
Owner(address) := 698670862888103124090043688033161627232733560907(address)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(msg.sender == Owner)

IRs:
TMP_4(bool) = msg.sender == Owner
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Owner.transfer(this.balance)

IRs:
REF_5(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:Owner value:REF_5""];
}
",0,0,1,0,msg.sender == 0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;Owner = 0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;;require(bool)(msg.sender == Owner);Owner.transfer(this.balance)
./0xeef93ec835c7921038d55ee096671a94e961709b_ext.sol,RefundVault.refund,645,651,"REF_257(RefundVault.State) -> State.Refunding,TMP_436(bool) = state == REF_257,TMP_437(None) = SOLIDITY_CALL require(bool)(TMP_436),REF_258(uint256) -> deposited[investor],depositedValue(uint256) := REF_258(uint256),REF_259(uint256) -> deposited[investor],REF_259(uint256) (->deposited) := 0(uint256),Transfer dest:investor value:depositedValue,Emit Refunded(investor,depositedValue)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Refunding)

IRs:
REF_257(RefundVault.State) -> State.Refunding
TMP_436(bool) = state == REF_257
TMP_437(None) = SOLIDITY_CALL require(bool)(TMP_436)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
depositedValue = deposited[investor]

IRs:
REF_258(uint256) -> deposited[investor]
depositedValue(uint256) := REF_258(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
deposited[investor] = 0

IRs:
REF_259(uint256) -> deposited[investor]
REF_259(uint256) (->deposited) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
investor.transfer(depositedValue)

IRs:
Transfer dest:investor value:depositedValue""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Refunded(investor,depositedValue)

IRs:
Emit Refunded(investor,depositedValue)""];
}
",0,0,1,0,"require(bool)(state == State.Refunding);depositedValue = deposited[investor];deposited[investor] = 0;investor.transfer(depositedValue);Refunded(investor,depositedValue)"
./0xf3cb4203e10f205c6bc91d8b0974eee520af6412_ext.sol,D_Quiz.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x345ab5e5f971dbdbc92af2779ce7a8bbf1819e59_ext.sol,TwentyDollars.ownerWithdraw,90,94,"TMP_13(uint256) = INTERNAL_CALL, TwentyDollars.getContractBalance()(),TMP_14(uint256) = TMP_13 - winnerAllocation,Transfer dest:owner value:TMP_14,MODIFIER_CALL, TwentyDollars.onlyOwner()(),MODIFIER_CALL, TwentyDollars.onlyBiddingClosed()(),REF_13(address) -> highestBid.owner,TMP_18 = CONVERT 0 to address,TMP_19(bool) = REF_13 == TMP_18,CONDITION TMP_19,winnerAllocation(uint256) := 0(uint256),winnerAllocation(uint256) := gameValue(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(getContractBalance() - winnerAllocation)

IRs:
TMP_13(uint256) = INTERNAL_CALL, TwentyDollars.getContractBalance()()
TMP_14(uint256) = TMP_13 - winnerAllocation
Transfer dest:owner value:TMP_14""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, TwentyDollars.onlyOwner()()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyBiddingClosed()

IRs:
MODIFIER_CALL, TwentyDollars.onlyBiddingClosed()()""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
(highestBid.owner == address(0))

IRs:
REF_13(address) -> highestBid.owner
TMP_18 = CONVERT 0 to address
TMP_19(bool) = REF_13 == TMP_18
CONDITION TMP_19""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
winnerAllocation = 0

IRs:
winnerAllocation(uint256) := 0(uint256)""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
winnerAllocation = gameValue

IRs:
winnerAllocation(uint256) := gameValue(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->2;
}
",0,0,1,0,onlyOwner();owner.transfer(getContractBalance() - winnerAllocation);onlyBiddingClosed();(highestBid.owner == address(0));winnerAllocation = 0;winnerAllocation = gameValue;
./0x574fb6d9d090042a04d0d12a4e87217f8303a5ca_ext.sol,HelloGoldSale.complete,900,913,"TMP_551(bool) = INTERNAL_CALL, HelloGoldSale.success()(),CONDITION TMP_551,REF_191(uint256) = SOLIDITY_CALL balance(address)(this),val(uint256) := REF_191([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9F900C0D0>]),TMP_552(bool) = val > 0,CONDITION TMP_552,TMP_553 = SEND dest:multiSig value:val,TMP_554 = UnaryType.BANG TMP_553 ,CONDITION TMP_554,TMP_555(None) = SOLIDITY_CALL log0(bytes32)(cannot withdraw),TMP_556(None) = SOLIDITY_CALL log0(bytes32)(funds withdrawn),TMP_557(None) = SOLIDITY_CALL log0(bytes32)(nothing to withdraw),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: IF 1

EXPRESSION:
success()

IRs:
TMP_551(bool) = INTERNAL_CALL, HelloGoldSale.success()()
CONDITION TMP_551""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
val = this.balance

IRs:
REF_191(uint256) = SOLIDITY_CALL balance(address)(this)
val(uint256) := REF_191([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9F900C0D0>])""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
val > 0

IRs:
TMP_552(bool) = val > 0
CONDITION TMP_552""];
3->4[label=""True""];
3->8[label=""False""];
4[label=""Node Type: IF 4

EXPRESSION:
! multiSig.send(val)

IRs:
TMP_553 = SEND dest:multiSig value:val
TMP_554 = UnaryType.BANG TMP_553 
CONDITION TMP_554""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
log0(bytes32)(cannot withdraw)

IRs:
TMP_555(None) = SOLIDITY_CALL log0(bytes32)(cannot withdraw)""];
5->7;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
log0(bytes32)(funds withdrawn)

IRs:
TMP_556(None) = SOLIDITY_CALL log0(bytes32)(funds withdrawn)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->9;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
log0(bytes32)(nothing to withdraw)

IRs:
TMP_557(None) = SOLIDITY_CALL log0(bytes32)(nothing to withdraw)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: END_IF 10
""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
11->1;
}
",0,0,1,0,onlyOwner();success();val = this.balance;;val > 0;! multiSig.send(val);log0(bytes32)(nothing to withdraw);log0(bytes32)(cannot withdraw);log0(bytes32)(funds withdrawn);;
./0x40da24a66f729d0bd0453681c5a6506bdc2a7a6a_ext.sol,CrwdToken.requestPayout,539,544,"Transfer dest:msg.sender value:_amount,MODIFIER_CALL, CrwdToken.onlyWithdraw()(),REF_118(CrwdToken.States) -> States.Operational,MODIFIER_CALL, CrwdToken.requireState(CrwdToken.States)(REF_118)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(_amount)

IRs:
Transfer dest:msg.sender value:_amount""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyWithdraw()

IRs:
MODIFIER_CALL, CrwdToken.onlyWithdraw()()""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
requireState(States.Operational)

IRs:
REF_118(CrwdToken.States) -> States.Operational
MODIFIER_CALL, CrwdToken.requireState(CrwdToken.States)(REF_118)""];
3->1;
}
",0,0,1,0,onlyWithdraw();msg.sender.transfer(_amount);requireState(States.Operational)
./0xe159ab639cd6d5d8c83bcda4bd114480c9ce197b_ext.sol,En_GAME.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 400000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 400000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 400000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 400000000000000000;msg.sender.transfer(this.balance);
./0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06_ext.sol,FlowerCore.withdrawBalance,1462,1464,"TMP_2095 = CONVERT this to address,TMP_2096(uint256) = SOLIDITY_CALL balance(address)(TMP_2095),Transfer dest:owner value:TMP_2096,MODIFIER_CALL, FlowerAdminAccess.onlyAdministrator()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_2095 = CONVERT this to address
TMP_2096(uint256) = SOLIDITY_CALL balance(address)(TMP_2095)
Transfer dest:owner value:TMP_2096""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyAdministrator()

IRs:
MODIFIER_CALL, FlowerAdminAccess.onlyAdministrator()()""];
2->1;
}
",0,0,1,0,onlyAdministrator();owner.transfer(address(this).balance)
./0x8cd06b5c327b0e277a7f6b08b9acea4d8ee36180_ext.sol,JungleScratch.chargeOwe,192,203,"REF_94(JungleScratch.Game) -> TicketPool[secretKey_D_hash],REF_95(bool) -> REF_94.isPay,TMP_165 = UnaryType.BANG REF_95 ,TMP_166(None) = SOLIDITY_CALL require(bool)(TMP_165),REF_96(JungleScratch.Game) -> TicketPool[secretKey_D_hash],REF_97(bool) -> REF_96.isPlay,TMP_167(None) = SOLIDITY_CALL require(bool)(REF_97),REF_98(JungleScratch.Game) -> TicketPool[secretKey_D_hash],REF_99(uint256) -> REF_98.Result,TMP_168(bool) = REF_99 != 0,TMP_169(None) = SOLIDITY_CALL require(bool)(TMP_168),TMP_170 = CONVERT this to address,TMP_171(uint256) = SOLIDITY_CALL balance(address)(TMP_170),REF_100(JungleScratch.Game) -> TicketPool[secretKey_D_hash],REF_101(uint256) -> REF_100.Result,TMP_172(bool) = TMP_171 >= REF_101,CONDITION TMP_172,REF_102(JungleScratch.Game) -> TicketPool[secretKey_D_hash],REF_103(address) -> REF_102.Buyer,REF_105(JungleScratch.Game) -> TicketPool[secretKey_D_hash],REF_106(uint256) -> REF_105.Result,TMP_173 = SEND dest:REF_103 value:REF_106,CONDITION TMP_173,REF_107(JungleScratch.Game) -> TicketPool[secretKey_D_hash],REF_108(bool) -> REF_107.isPay,REF_108(bool) (->TicketPool) := True(bool),REF_109(JungleScratch.Game) -> TicketPool[secretKey_D_hash],REF_110(address) -> REF_109.Buyer,REF_111(JungleScratch.Game) -> TicketPool[secretKey_D_hash],REF_112(uint256) -> REF_111.Result,Emit OwePay(secretKey_D_hash,REF_110,REF_112)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! TicketPool[secretKey_D_hash].isPay)

IRs:
REF_94(JungleScratch.Game) -> TicketPool[secretKey_D_hash]
REF_95(bool) -> REF_94.isPay
TMP_165 = UnaryType.BANG REF_95 
TMP_166(None) = SOLIDITY_CALL require(bool)(TMP_165)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(TicketPool[secretKey_D_hash].isPlay)

IRs:
REF_96(JungleScratch.Game) -> TicketPool[secretKey_D_hash]
REF_97(bool) -> REF_96.isPlay
TMP_167(None) = SOLIDITY_CALL require(bool)(REF_97)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(TicketPool[secretKey_D_hash].Result != 0)

IRs:
REF_98(JungleScratch.Game) -> TicketPool[secretKey_D_hash]
REF_99(uint256) -> REF_98.Result
TMP_168(bool) = REF_99 != 0
TMP_169(None) = SOLIDITY_CALL require(bool)(TMP_168)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
address(this).balance >= TicketPool[secretKey_D_hash].Result

IRs:
TMP_170 = CONVERT this to address
TMP_171(uint256) = SOLIDITY_CALL balance(address)(TMP_170)
REF_100(JungleScratch.Game) -> TicketPool[secretKey_D_hash]
REF_101(uint256) -> REF_100.Result
TMP_172(bool) = TMP_171 >= REF_101
CONDITION TMP_172""];
4->5[label=""True""];
4->9[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
TicketPool[secretKey_D_hash].Buyer.send(TicketPool[secretKey_D_hash].Result)

IRs:
REF_102(JungleScratch.Game) -> TicketPool[secretKey_D_hash]
REF_103(address) -> REF_102.Buyer
REF_105(JungleScratch.Game) -> TicketPool[secretKey_D_hash]
REF_106(uint256) -> REF_105.Result
TMP_173 = SEND dest:REF_103 value:REF_106
CONDITION TMP_173""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
TicketPool[secretKey_D_hash].isPay = true

IRs:
REF_107(JungleScratch.Game) -> TicketPool[secretKey_D_hash]
REF_108(bool) -> REF_107.isPay
REF_108(bool) (->TicketPool) := True(bool)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
OwePay(secretKey_D_hash,TicketPool[secretKey_D_hash].Buyer,TicketPool[secretKey_D_hash].Result)

IRs:
REF_109(JungleScratch.Game) -> TicketPool[secretKey_D_hash]
REF_110(address) -> REF_109.Buyer
REF_111(JungleScratch.Game) -> TicketPool[secretKey_D_hash]
REF_112(uint256) -> REF_111.Result
Emit OwePay(secretKey_D_hash,REF_110,REF_112)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
}
",0,0,1,0,"require(bool)(! TicketPool[secretKey_D_hash].isPay);require(bool)(TicketPool[secretKey_D_hash].isPlay);require(bool)(TicketPool[secretKey_D_hash].Result != 0);address(this).balance >= TicketPool[secretKey_D_hash].Result;TicketPool[secretKey_D_hash].Buyer.send(TicketPool[secretKey_D_hash].Result);;TicketPool[secretKey_D_hash].isPay = true;;OwePay(secretKey_D_hash,TicketPool[secretKey_D_hash].Buyer,TicketPool[secretKey_D_hash].Result)"
./0xf2eefee3c99cdb30c11d57b487a16690e813309b_ext.sol,SlotMachine.killContract,93,95,"TMP_63(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, SlotMachine.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_63(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, SlotMachine.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0x6b1dce414d998a28bd90f201a87f8e1bbf2f0aad_ext.sol,fast_game.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x33b44a1d150f3feaa40503ad20a75634adc39b18_ext.sol,TimeCapsule.kill,36,39,"TMP_11(bool) = INTERNAL_CALL, Ownable.isOwner()(),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),TMP_12(bool) = REF_3 == 0,TMP_13(bool) = TMP_11 && TMP_12,CONDITION TMP_13,TMP_14(None) = SOLIDITY_CALL suicide(address)(msg.sender)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
isOwner() && this.balance == 0

IRs:
TMP_11(bool) = INTERNAL_CALL, Ownable.isOwner()()
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_12(bool) = REF_3 == 0
TMP_13(bool) = TMP_11 && TMP_12
CONDITION TMP_13""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
suicide(address)(msg.sender)

IRs:
TMP_14(None) = SOLIDITY_CALL suicide(address)(msg.sender)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,0,1,0,isOwner() && this.balance == 0;suicide(address)(msg.sender);
./0x9311f7ee5f48a807d598cdd68f43cd4e73ffa747_ext.sol,GTO.buyGifto,130,145,"REF_0(uint256) -> deposit[msg.sender],TMP_1(bool) = REF_0 == 0,CONDITION TMP_1,REF_2 -> LENGTH buyers,TMP_3(uint256) := REF_2(uint256),TMP_4(uint256) = TMP_3 + 1,REF_2(uint256) (->buyers) := TMP_4(uint256),REF_3(address) -> buyers[TMP_3],REF_3(address) (->buyers) := msg.sender(address),REF_4(uint256) -> deposit[msg.sender],REF_4(-> deposit) = REF_4 + msg.value,Transfer dest:owner value:msg.value,MODIFIER_CALL, GTO.onSale()(),MODIFIER_CALL, GTO.validValue()(),MODIFIER_CALL, GTO.validInvestor()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: IF 1

EXPRESSION:
deposit[msg.sender] == 0

IRs:
REF_0(uint256) -> deposit[msg.sender]
TMP_1(bool) = REF_0 == 0
CONDITION TMP_1""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
buyers.push(msg.sender)

IRs:
REF_2 -> LENGTH buyers
TMP_3(uint256) := REF_2(uint256)
TMP_4(uint256) = TMP_3 + 1
REF_2(uint256) (->buyers) := TMP_4(uint256)
REF_3(address) -> buyers[TMP_3]
REF_3(address) (->buyers) := msg.sender(address)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
deposit[msg.sender] += msg.value

IRs:
REF_4(uint256) -> deposit[msg.sender]
REF_4(-> deposit) = REF_4 + msg.value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
owner.transfer(msg.value)

IRs:
Transfer dest:owner value:msg.value""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onSale()

IRs:
MODIFIER_CALL, GTO.onSale()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
validValue()

IRs:
MODIFIER_CALL, GTO.validValue()()""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
validInvestor()

IRs:
MODIFIER_CALL, GTO.validInvestor()()""];
8->1;
}
",0,0,1,0,onSale();deposit[msg.sender] == 0;buyers.push(msg.sender);;deposit[msg.sender] += msg.value;owner.transfer(msg.value);validValue();validInvestor()
./0x6dbb4e882f967432fc0f9200e9ca577c916d8a68_ext.sol,Bussiness.removePrice,109,114,"TMP_32(address) = HIGH_LEVEL_CALL, dest:erc721Address(IERC721), function:ownerOf, arguments:['tokenId']  ,TMP_33(bool) = TMP_32 == msg.sender,TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33),REF_15(Bussiness.Price) -> prices[tokenId],REF_16(uint256) -> REF_15.fee,TMP_35(bool) = REF_16 > 0,CONDITION TMP_35,REF_18(Bussiness.Price) -> prices[tokenId],REF_19(uint256) -> REF_18.fee,Transfer dest:msg.sender value:REF_19,INTERNAL_CALL, Bussiness.resetPrice(uint256)(tokenId),REF_20(Bussiness.Price) -> prices[tokenId],REF_21(uint256) -> REF_20.price,RETURN REF_21","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(erc721Address.ownerOf(tokenId) == msg.sender)

IRs:
TMP_32(address) = HIGH_LEVEL_CALL, dest:erc721Address(IERC721), function:ownerOf, arguments:['tokenId']  
TMP_33(bool) = TMP_32 == msg.sender
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
prices[tokenId].fee > 0

IRs:
REF_15(Bussiness.Price) -> prices[tokenId]
REF_16(uint256) -> REF_15.fee
TMP_35(bool) = REF_16 > 0
CONDITION TMP_35""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(prices[tokenId].fee)

IRs:
REF_18(Bussiness.Price) -> prices[tokenId]
REF_19(uint256) -> REF_18.fee
Transfer dest:msg.sender value:REF_19""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
resetPrice(tokenId)

IRs:
INTERNAL_CALL, Bussiness.resetPrice(uint256)(tokenId)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
prices[tokenId].price

IRs:
REF_20(Bussiness.Price) -> prices[tokenId]
REF_21(uint256) -> REF_20.price
RETURN REF_21""];
}
",1,0,1,0,require(bool)(erc721Address.ownerOf(tokenId) == msg.sender);prices[tokenId].fee > 0;msg.sender.transfer(prices[tokenId].fee);;resetPrice(tokenId);prices[tokenId].price
./0xf099c6ecb16575393b3ba6ac57b4ead943353a52_ext.sol,BuddhaTower.takeDevCut,416,419,"Transfer dest:addr4 value:devCut,devCut(uint256) := 0(uint256),MODIFIER_CALL, BuddhaTower.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
addr4.transfer(devCut)

IRs:
Transfer dest:addr4 value:devCut""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
devCut = 0

IRs:
devCut(uint256) := 0(uint256)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, BuddhaTower.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();addr4.transfer(devCut);devCut = 0
./0x20461ad484795e3db0a18a825b34f55768f77819_ext.sol,FF_Game.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x72636c350431895fc6ee718b92bcc5b4fbd70304_ext.sol,preSale3.finishPreSale3,302,308,"TMP_98(bool) = now > end,REF_88(uint256) = SOLIDITY_CALL balance(address)(this),TMP_99(bool) = REF_88 >= hardcap,TMP_100(bool) = TMP_98 || TMP_99,CONDITION TMP_100,REF_90(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:multisig value:REF_90,preSale3Finished(bool) := True(bool),RETURN True,RETURN False,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: IF 1

EXPRESSION:
now > end || this.balance >= hardcap

IRs:
TMP_98(bool) = now > end
REF_88(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_99(bool) = REF_88 >= hardcap
TMP_100(bool) = TMP_98 || TMP_99
CONDITION TMP_100""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
multisig.transfer(this.balance)

IRs:
REF_90(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:multisig value:REF_90""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
preSale3Finished = true

IRs:
preSale3Finished(bool) := True(bool)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
false

IRs:
RETURN False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
7->1;
}
",0,0,1,0,onlyOwner();now > end || this.balance >= hardcap;multisig.transfer(this.balance);false;preSale3Finished = true;true
./0x00f9f4f3ced5d4f6aedea8a92414206557df7167_ext.sol,SNL.safeWithdrawal,304,309,"TMP_97(bool) = _value == 0,CONDITION TMP_97,TMP_98 = CONVERT this to address,TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98),Transfer dest:owner value:TMP_99,Transfer dest:owner value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_97(bool) = _value == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_98 = CONVERT this to address
TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98)
Transfer dest:owner value:TMP_99""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_value == 0;owner.transfer(address(this).balance);owner.transfer(_value);
./0x1807cf924199c0f8a85b73c15b5c0349aa3844e5_ext.sol,PublickOffering.backETH,113,120,"REF_7(PublickOffering.investorInfo) -> bills[pos],REF_8(bool) -> REF_7.hadback,TMP_22 = UnaryType.BANG REF_8 ,CONDITION TMP_22,TMP_23(bool) = pos < lastAccountNum,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),REF_9(PublickOffering.investorInfo) -> bills[pos],REF_10(address) -> REF_9.investor,REF_12(PublickOffering.investorInfo) -> bills[pos],REF_13(uint256) -> REF_12.amount,Transfer dest:REF_10 value:REF_13,REF_14(PublickOffering.investorInfo) -> bills[pos],REF_15(bool) -> REF_14.hadback,REF_15(bool) (->bills) := True(bool),REF_16(PublickOffering.investorInfo) -> bills[pos],REF_17(address) -> REF_16.investor,REF_18(PublickOffering.investorInfo) -> bills[pos],REF_19(uint256) -> REF_18.amount,Emit Back(REF_17,REF_19,now),MODIFIER_CALL, Authority.onlyBeneficiary()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: IF 1

EXPRESSION:
! bills[pos].hadback

IRs:
REF_7(PublickOffering.investorInfo) -> bills[pos]
REF_8(bool) -> REF_7.hadback
TMP_22 = UnaryType.BANG REF_8 
CONDITION TMP_22""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(pos < lastAccountNum)

IRs:
TMP_23(bool) = pos < lastAccountNum
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
bills[pos].investor.transfer(bills[pos].amount)

IRs:
REF_9(PublickOffering.investorInfo) -> bills[pos]
REF_10(address) -> REF_9.investor
REF_12(PublickOffering.investorInfo) -> bills[pos]
REF_13(uint256) -> REF_12.amount
Transfer dest:REF_10 value:REF_13""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
bills[pos].hadback = true

IRs:
REF_14(PublickOffering.investorInfo) -> bills[pos]
REF_15(bool) -> REF_14.hadback
REF_15(bool) (->bills) := True(bool)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Back(bills[pos].investor,bills[pos].amount,now)

IRs:
REF_16(PublickOffering.investorInfo) -> bills[pos]
REF_17(address) -> REF_16.investor
REF_18(PublickOffering.investorInfo) -> bills[pos]
REF_19(uint256) -> REF_18.amount
Emit Back(REF_17,REF_19,now)""];
5->6;
6[label=""Node Type: END_IF 6
""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyBeneficiary()

IRs:
MODIFIER_CALL, Authority.onlyBeneficiary()()""];
7->1;
}
",0,0,1,0,"onlyBeneficiary();! bills[pos].hadback;require(bool)(pos < lastAccountNum);;bills[pos].investor.transfer(bills[pos].amount);bills[pos].hadback = true;Back(bills[pos].investor,bills[pos].amount,now)"
./0xeba4ce0d799fe901f3af52c0e0f088d026b11c81_ext.sol,CFNDCrowdsale.kill,48,50,"TMP_8(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, CFNDCrowdsale.isCreator()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_8(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isCreator()

IRs:
MODIFIER_CALL, CFNDCrowdsale.isCreator()()""];
2->1;
}
",0,0,1,0,isCreator();selfdestruct(address)(owner)
./0x53f671aef0a803085f6e3a6c215dd88454394f3e_ext.sol,WorldCupWinner.destroy,82,84,"TMP_19(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, WorldCupWinner.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_19(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, WorldCupWinner.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0x6947335452cb7a452fc337c28cb0d597806c7672_ext.sol,SmartWeddingContract.divorce,238,267,"REF_47(bool) -> hasDivorced[msg.sender],TMP_94(bool) = REF_47 == False,TMP_95(None) = SOLIDITY_CALL require(bool,string)(TMP_94,Sender has already approved to divorce!),REF_48(bool) -> hasDivorced[msg.sender],REF_48(bool) (->hasDivorced) := True(bool),Emit DivorceApproved(now,msg.sender),REF_49(bool) -> hasDivorced[husbandAddress],REF_50(bool) -> hasDivorced[wifeAddress],TMP_97(bool) = REF_49 && REF_50,CONDITION TMP_97,divorced(bool) := True(bool),Emit Divorced(now),TMP_99 = CONVERT this to address,TMP_100(uint256) = SOLIDITY_CALL balance(address)(TMP_99),balance(uint256) := TMP_100(uint256),TMP_101(bool) = balance != 0,CONDITION TMP_101,TMP_102(uint256) = balance / 2,balancePerSpouse(uint256) := TMP_102(uint256),Transfer dest:husbandAddress value:balancePerSpouse,Emit FundsSent(now,husbandAddress,balancePerSpouse),Transfer dest:wifeAddress value:balancePerSpouse,Emit FundsSent(now,wifeAddress,balancePerSpouse),MODIFIER_CALL, SmartWeddingContract.onlySpouse()(),MODIFIER_CALL, SmartWeddingContract.isSigned()(),MODIFIER_CALL, SmartWeddingContract.isNotDivorced()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->16;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(hasDivorced[msg.sender] == false,Sender has already approved to divorce!)

IRs:
REF_47(bool) -> hasDivorced[msg.sender]
TMP_94(bool) = REF_47 == False
TMP_95(None) = SOLIDITY_CALL require(bool,string)(TMP_94,Sender has already approved to divorce!)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
hasDivorced[msg.sender] = true

IRs:
REF_48(bool) -> hasDivorced[msg.sender]
REF_48(bool) (->hasDivorced) := True(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
DivorceApproved(now,msg.sender)

IRs:
Emit DivorceApproved(now,msg.sender)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
hasDivorced[husbandAddress] && hasDivorced[wifeAddress]

IRs:
REF_49(bool) -> hasDivorced[husbandAddress]
REF_50(bool) -> hasDivorced[wifeAddress]
TMP_97(bool) = REF_49 && REF_50
CONDITION TMP_97""];
4->5[label=""True""];
4->15[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
divorced = true

IRs:
divorced(bool) := True(bool)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Divorced(now)

IRs:
Emit Divorced(now)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
balance = address(this).balance

IRs:
TMP_99 = CONVERT this to address
TMP_100(uint256) = SOLIDITY_CALL balance(address)(TMP_99)
balance(uint256) := TMP_100(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
balance != 0

IRs:
TMP_101(bool) = balance != 0
CONDITION TMP_101""];
8->9[label=""True""];
8->14[label=""False""];
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
balancePerSpouse = balance / 2

IRs:
TMP_102(uint256) = balance / 2
balancePerSpouse(uint256) := TMP_102(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
husbandAddress.transfer(balancePerSpouse)

IRs:
Transfer dest:husbandAddress value:balancePerSpouse""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
FundsSent(now,husbandAddress,balancePerSpouse)

IRs:
Emit FundsSent(now,husbandAddress,balancePerSpouse)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
wifeAddress.transfer(balancePerSpouse)

IRs:
Transfer dest:wifeAddress value:balancePerSpouse""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
FundsSent(now,wifeAddress,balancePerSpouse)

IRs:
Emit FundsSent(now,wifeAddress,balancePerSpouse)""];
13->14;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: END_IF 15
""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
onlySpouse()

IRs:
MODIFIER_CALL, SmartWeddingContract.onlySpouse()()""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
isSigned()

IRs:
MODIFIER_CALL, SmartWeddingContract.isSigned()()""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
isNotDivorced()

IRs:
MODIFIER_CALL, SmartWeddingContract.isNotDivorced()()""];
18->1;
}
",0,0,1,0,"onlySpouse();require(bool,string)(hasDivorced[msg.sender] == false,Sender has already approved to divorce!);hasDivorced[msg.sender] = true;DivorceApproved(now,msg.sender);hasDivorced[husbandAddress] && hasDivorced[wifeAddress];divorced = true;;Divorced(now);balance = address(this).balance;balance != 0;balancePerSpouse = balance / 2;;husbandAddress.transfer(balancePerSpouse);FundsSent(now,husbandAddress,balancePerSpouse);wifeAddress.transfer(balancePerSpouse);FundsSent(now,wifeAddress,balancePerSpouse);isSigned();isNotDivorced()"
./0x89b5eaec2702ab0ff33ca397b3e66c7d925d5144_ext.sol,Soccer._payout,389,395,"TMP_146 = CONVERT 0 to address,TMP_147(bool) = _to == TMP_146,CONDITION TMP_147,REF_84(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:ceoAddress value:REF_84,REF_86(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:_to value:REF_86","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_to == address(0)

IRs:
TMP_146 = CONVERT 0 to address
TMP_147(bool) = _to == TMP_146
CONDITION TMP_147""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ceoAddress.transfer(this.balance)

IRs:
REF_84(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:ceoAddress value:REF_84""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_to.transfer(this.balance)

IRs:
REF_86(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:_to value:REF_86""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,_to == address(0);ceoAddress.transfer(this.balance);_to.transfer(this.balance);
./0x56a4d4e31c09558f6a1619dfb857a482b3bb2fb6_ext.sol,PlayerBook.registerNameCore,319,346,"REF_54(uint256) -> pIDxName_[_name],TMP_59(bool) = REF_54 != 0,CONDITION TMP_59,REF_55(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_56(bool) -> REF_55[_name],TMP_60(bool) = REF_56 == True,TMP_61(None) = SOLIDITY_CALL require(bool,string)(TMP_60,sorry that names already taken),REF_57(PlayerBook.Player) -> plyr_[_pID],REF_58(bytes32) -> REF_57.name,REF_58(bytes32) (->plyr_) := _name(bytes32),REF_59(uint256) -> pIDxName_[_name],REF_59(uint256) (->pIDxName_) := _pID(uint256),REF_60(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_61(bool) -> REF_60[_name],TMP_62(bool) = REF_61 == False,CONDITION TMP_62,REF_62(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_63(bool) -> REF_62[_name],REF_63(bool) (->plyrNames_) := True(bool),REF_64(PlayerBook.Player) -> plyr_[_pID],REF_65(uint256) -> REF_64.names,TMP_63(uint256) := REF_65(uint256),REF_65(-> plyr_) = REF_65 + 1,REF_66(mapping(uint256 => bytes32)) -> plyrNameList_[_pID],REF_67(PlayerBook.Player) -> plyr_[_pID],REF_68(uint256) -> REF_67.names,REF_69(bytes32) -> REF_66[REF_68],REF_69(bytes32) (->plyrNameList_) := _name(bytes32),TMP_64 = CONVERT this to address,TMP_65(uint256) = SOLIDITY_CALL balance(address)(TMP_64),Transfer dest:admin value:TMP_65,TMP_67(bool) = _all == True,CONDITION TMP_67,i(uint256) := 1(uint256),TMP_68(bool) = i <= gID_,CONDITION TMP_68,REF_71(PlayerBookReceiverInterface) -> games_[i],HIGH_LEVEL_CALL, dest:REF_71(PlayerBookReceiverInterface), function:receivePlayerInfo, arguments:['_pID', '_addr', '_name', '_affID']  ,TMP_70(uint256) := i(uint256),i(uint256) = i + 1,REF_73(PlayerBook.Player) -> plyr_[_affID],REF_74(address) -> REF_73.addr,REF_75(PlayerBook.Player) -> plyr_[_affID],REF_76(bytes32) -> REF_75.name,Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_74,REF_76,msg.value,now)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
pIDxName_[_name] != 0

IRs:
REF_54(uint256) -> pIDxName_[_name]
TMP_59(bool) = REF_54 != 0
CONDITION TMP_59""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(plyrNames_[_pID][_name] == true,sorry that names already taken)

IRs:
REF_55(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_56(bool) -> REF_55[_name]
TMP_60(bool) = REF_56 == True
TMP_61(None) = SOLIDITY_CALL require(bool,string)(TMP_60,sorry that names already taken)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
plyr_[_pID].name = _name

IRs:
REF_57(PlayerBook.Player) -> plyr_[_pID]
REF_58(bytes32) -> REF_57.name
REF_58(bytes32) (->plyr_) := _name(bytes32)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
pIDxName_[_name] = _pID

IRs:
REF_59(uint256) -> pIDxName_[_name]
REF_59(uint256) (->pIDxName_) := _pID(uint256)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
plyrNames_[_pID][_name] == false

IRs:
REF_60(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_61(bool) -> REF_60[_name]
TMP_62(bool) = REF_61 == False
CONDITION TMP_62""];
6->7[label=""True""];
6->10[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
plyrNames_[_pID][_name] = true

IRs:
REF_62(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_63(bool) -> REF_62[_name]
REF_63(bool) (->plyrNames_) := True(bool)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
plyr_[_pID].names ++

IRs:
REF_64(PlayerBook.Player) -> plyr_[_pID]
REF_65(uint256) -> REF_64.names
TMP_63(uint256) := REF_65(uint256)
REF_65(-> plyr_) = REF_65 + 1""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
plyrNameList_[_pID][plyr_[_pID].names] = _name

IRs:
REF_66(mapping(uint256 => bytes32)) -> plyrNameList_[_pID]
REF_67(PlayerBook.Player) -> plyr_[_pID]
REF_68(uint256) -> REF_67.names
REF_69(bytes32) -> REF_66[REF_68]
REF_69(bytes32) (->plyrNameList_) := _name(bytes32)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
admin.transfer(address(this).balance)

IRs:
TMP_64 = CONVERT this to address
TMP_65(uint256) = SOLIDITY_CALL balance(address)(TMP_64)
Transfer dest:admin value:TMP_65""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
_all == true

IRs:
TMP_67(bool) = _all == True
CONDITION TMP_67""];
12->15[label=""True""];
12->19[label=""False""];
13[label=""Node Type: BEGIN_LOOP 13
""];
13->16;
14[label=""Node Type: END_LOOP 14
""];
14->19;
15[label=""Node Type: NEW VARIABLE 15

EXPRESSION:
i = 1

IRs:
i(uint256) := 1(uint256)""];
15->13;
16[label=""Node Type: IF_LOOP 16

EXPRESSION:
i <= gID_

IRs:
TMP_68(bool) = i <= gID_
CONDITION TMP_68""];
16->17[label=""True""];
16->14[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
games_[i].receivePlayerInfo(_pID,_addr,_name,_affID)

IRs:
REF_71(PlayerBookReceiverInterface) -> games_[i]
HIGH_LEVEL_CALL, dest:REF_71(PlayerBookReceiverInterface), function:receivePlayerInfo, arguments:['_pID', '_addr', '_name', '_affID']  ""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
i ++

IRs:
TMP_70(uint256) := i(uint256)
i(uint256) = i + 1""];
18->16;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,msg.value,now)

IRs:
REF_73(PlayerBook.Player) -> plyr_[_affID]
REF_74(address) -> REF_73.addr
REF_75(PlayerBook.Player) -> plyr_[_affID]
REF_76(bytes32) -> REF_75.name
Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_74,REF_76,msg.value,now)""];
}
",0,0,1,0,"pIDxName_[_name] != 0;require(bool,string)(plyrNames_[_pID][_name] == true,sorry that names already taken);;plyr_[_pID].name = _name;pIDxName_[_name] = _pID;plyrNames_[_pID][_name] == false;plyrNames_[_pID][_name] = true;;plyr_[_pID].names ++;plyrNameList_[_pID][plyr_[_pID].names] = _name;admin.transfer(address(this).balance);_all == true;i = 1;;;i <= gID_;;games_[i].receivePlayerInfo(_pID,_addr,_name,_affID);i ++;onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,msg.value,now)"
./0x1b85440d66a5903deabb24807d739019ff1741e6_ext.sol,Subrosa.withDrawAmount,486,490,"TMP_19(uint256) = SOLIDITY_CALL balance(address)(contractAddress),TMP_20(bool) = amount <= TMP_19,TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20),Transfer dest:owner value:amount,Emit WithDraw(owner,amount),MODIFIER_CALL, Subrosa.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(amount <= contractAddress.balance)

IRs:
TMP_19(uint256) = SOLIDITY_CALL balance(address)(contractAddress)
TMP_20(bool) = amount <= TMP_19
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(amount)

IRs:
Transfer dest:owner value:amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
WithDraw(owner,amount)

IRs:
Emit WithDraw(owner,amount)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Subrosa.onlyOwner()()""];
4->1;
}
",0,0,1,0,"onlyOwner();require(bool)(amount <= contractAddress.balance);owner.transfer(amount);WithDraw(owner,amount)"
./0x728781e75735dc0962df3a51d7ef47e798a7107e_ext.sol,WolkExchange.fallback,629,638,"TMP_731(bool) = msg.value > 0,TMP_732(None) = SOLIDITY_CALL require(bool)(TMP_731),TMP_733 = UnaryType.BANG openSaleCompleted ,CONDITION TMP_733,HIGH_LEVEL_CALL, dest:this(address), function:tokenGenerationEvent, arguments:['msg.sender'] value:msg.value ,TMP_736(bool) = block.number >= end_block,CONDITION TMP_736,TMP_738(uint256) = HIGH_LEVEL_CALL, dest:this(address), function:purchaseWolk, arguments:['msg.sender'] value:msg.value ,TMP_739(None) = SOLIDITY_CALL revert()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value > 0)

IRs:
TMP_731(bool) = msg.value > 0
TMP_732(None) = SOLIDITY_CALL require(bool)(TMP_731)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
! openSaleCompleted

IRs:
TMP_733 = UnaryType.BANG openSaleCompleted 
CONDITION TMP_733""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
this.tokenGenerationEvent.value(msg.value)(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:this(address), function:tokenGenerationEvent, arguments:['msg.sender'] value:msg.value ""];
3->8;
4[label=""Node Type: IF 4

EXPRESSION:
block.number >= end_block

IRs:
TMP_736(bool) = block.number >= end_block
CONDITION TMP_736""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
this.purchaseWolk.value(msg.value)(msg.sender)

IRs:
TMP_738(uint256) = HIGH_LEVEL_CALL, dest:this(address), function:purchaseWolk, arguments:['msg.sender'] value:msg.value ""];
5->7;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
revert()()

IRs:
TMP_739(None) = SOLIDITY_CALL revert()()""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: END_IF 8
""];
}
",0,0,1,0,require(bool)(msg.value > 0);! openSaleCompleted;this.tokenGenerationEvent.value(msg.value)(msg.sender);block.number >= end_block;;this.purchaseWolk.value(msg.value)(msg.sender);revert()();
./0x6d54549975e0fef50cd954491a6abee84c6f4e61_ext.sol,QuizTest.Try,5,12,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x7271f8fdd7693dca37b40403080abe89ae740168_ext.sol,Game.fallback,29,58,"TMP_0(bool) = msg.value == 0,REF_0(address) -> last.depositor,TMP_1(bool) = msg.sender == REF_0,TMP_2(bool) = TMP_0 && TMP_1,CONDITION TMP_2,TMP_3(uint256) = SOLIDITY_CALL gasleft()(),TMP_4(bool) = TMP_3 >= 220000,TMP_5(None) = SOLIDITY_CALL require(bool,string)(TMP_4,We require more gas!),REF_1(uint256) -> last.blockNumber,TMP_6(uint256) = REF_1 + 258,TMP_7(bool) = TMP_6 < block.number,TMP_8(None) = SOLIDITY_CALL require(bool,string)(TMP_7,Last depositor should wait 258 blocks (~0.2 hour) to claim reward),TMP_9 = CONVERT this to address,TMP_10(uint256) = SOLIDITY_CALL balance(address)(TMP_9),TMP_11 = CONVERT TMP_10 to uint128,money(uint128) := TMP_11(uint128),REF_2(uint256) -> last.expect,TMP_12(bool) = money >= REF_2,CONDITION TMP_12,REF_3(address) -> last.depositor,REF_5(uint256) -> last.expect,Transfer dest:REF_3 value:REF_5,REF_6(address) -> last.depositor,Transfer dest:REF_6 value:money,last = delete last ,TMP_15(bool) = msg.value > 0,CONDITION TMP_15,TMP_16(uint256) = SOLIDITY_CALL gasleft()(),TMP_17(bool) = TMP_16 >= 220000,TMP_18(None) = SOLIDITY_CALL require(bool,string)(TMP_17,We require more gas!),TMP_19(bool) = msg.value <= MAX_DEPOSIT,TMP_20(bool) = msg.value >= MIN_DEPOSIT,TMP_21(bool) = TMP_19 && TMP_20,TMP_22(None) = SOLIDITY_CALL require(bool,string)(TMP_21,Deposit must be >= 0.01 ETH and <= 1 ETH),TMP_23 = CONVERT msg.value to uint128,TMP_24(uint256) = msg.value * MULTIPLIER,TMP_25(uint256) = TMP_24 / 100,TMP_26 = CONVERT TMP_25 to uint128,TMP_27(Game.Deposit) = new Deposit(msg.sender,TMP_23,TMP_26),REF_9 -> LENGTH queue,TMP_29(uint256) := REF_9(uint256),TMP_30(uint256) = TMP_29 + 1,REF_9(uint256) (->queue) := TMP_30(uint256),REF_10(Game.Deposit) -> queue[TMP_29],REF_10(Game.Deposit) (->queue) := TMP_27(Game.Deposit),REF_11(address) -> last.depositor,REF_11(address) (->last) := msg.sender(address),REF_12(uint256) -> last.expect,TMP_31(uint256) = msg.value * LAST_DEPOSIT_PERCENT,TMP_32(uint256) = TMP_31 / 100,REF_12(-> last) = REF_12 + TMP_32,REF_13(uint256) -> last.blockNumber,REF_13(uint256) (->last) := block.number(uint256),TMP_33(uint256) = msg.value * PROMO_PERCENT,TMP_34(uint256) = TMP_33 / 100,promo(uint256) := TMP_34(uint256),Transfer dest:PROMO value:promo,INTERNAL_CALL, Game.pay()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value == 0 && msg.sender == last.depositor

IRs:
TMP_0(bool) = msg.value == 0
REF_0(address) -> last.depositor
TMP_1(bool) = msg.sender == REF_0
TMP_2(bool) = TMP_0 && TMP_1
CONDITION TMP_2""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(gasleft()() >= 220000,We require more gas!)

IRs:
TMP_3(uint256) = SOLIDITY_CALL gasleft()()
TMP_4(bool) = TMP_3 >= 220000
TMP_5(None) = SOLIDITY_CALL require(bool,string)(TMP_4,We require more gas!)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool,string)(last.blockNumber + 258 < block.number,Last depositor should wait 258 blocks (~0.2 hour) to claim reward)

IRs:
REF_1(uint256) -> last.blockNumber
TMP_6(uint256) = REF_1 + 258
TMP_7(bool) = TMP_6 < block.number
TMP_8(None) = SOLIDITY_CALL require(bool,string)(TMP_7,Last depositor should wait 258 blocks (~0.2 hour) to claim reward)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
money = uint128((address(this).balance))

IRs:
TMP_9 = CONVERT this to address
TMP_10(uint256) = SOLIDITY_CALL balance(address)(TMP_9)
TMP_11 = CONVERT TMP_10 to uint128
money(uint128) := TMP_11(uint128)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
money >= last.expect

IRs:
REF_2(uint256) -> last.expect
TMP_12(bool) = money >= REF_2
CONDITION TMP_12""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
last.depositor.transfer(last.expect)

IRs:
REF_3(address) -> last.depositor
REF_5(uint256) -> last.expect
Transfer dest:REF_3 value:REF_5""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
last.depositor.transfer(money)

IRs:
REF_6(address) -> last.depositor
Transfer dest:REF_6 value:money""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
delete last

IRs:
last = delete last ""];
9->21;
10[label=""Node Type: IF 10

EXPRESSION:
msg.value > 0

IRs:
TMP_15(bool) = msg.value > 0
CONDITION TMP_15""];
10->11[label=""True""];
10->20[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
require(bool,string)(gasleft()() >= 220000,We require more gas!)

IRs:
TMP_16(uint256) = SOLIDITY_CALL gasleft()()
TMP_17(bool) = TMP_16 >= 220000
TMP_18(None) = SOLIDITY_CALL require(bool,string)(TMP_17,We require more gas!)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
require(bool,string)(msg.value <= MAX_DEPOSIT && msg.value >= MIN_DEPOSIT,Deposit must be >= 0.01 ETH and <= 1 ETH)

IRs:
TMP_19(bool) = msg.value <= MAX_DEPOSIT
TMP_20(bool) = msg.value >= MIN_DEPOSIT
TMP_21(bool) = TMP_19 && TMP_20
TMP_22(None) = SOLIDITY_CALL require(bool,string)(TMP_21,Deposit must be >= 0.01 ETH and <= 1 ETH)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
queue.push(Deposit(msg.sender,uint128(msg.value),uint128(msg.value * MULTIPLIER / 100)))

IRs:
TMP_23 = CONVERT msg.value to uint128
TMP_24(uint256) = msg.value * MULTIPLIER
TMP_25(uint256) = TMP_24 / 100
TMP_26 = CONVERT TMP_25 to uint128
TMP_27(Game.Deposit) = new Deposit(msg.sender,TMP_23,TMP_26)
REF_9 -> LENGTH queue
TMP_29(uint256) := REF_9(uint256)
TMP_30(uint256) = TMP_29 + 1
REF_9(uint256) (->queue) := TMP_30(uint256)
REF_10(Game.Deposit) -> queue[TMP_29]
REF_10(Game.Deposit) (->queue) := TMP_27(Game.Deposit)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
last.depositor = msg.sender

IRs:
REF_11(address) -> last.depositor
REF_11(address) (->last) := msg.sender(address)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
last.expect += msg.value * LAST_DEPOSIT_PERCENT / 100

IRs:
REF_12(uint256) -> last.expect
TMP_31(uint256) = msg.value * LAST_DEPOSIT_PERCENT
TMP_32(uint256) = TMP_31 / 100
REF_12(-> last) = REF_12 + TMP_32""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
last.blockNumber = block.number

IRs:
REF_13(uint256) -> last.blockNumber
REF_13(uint256) (->last) := block.number(uint256)""];
16->17;
17[label=""Node Type: NEW VARIABLE 17

EXPRESSION:
promo = msg.value * PROMO_PERCENT / 100

IRs:
TMP_33(uint256) = msg.value * PROMO_PERCENT
TMP_34(uint256) = TMP_33 / 100
promo(uint256) := TMP_34(uint256)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
PROMO.transfer(promo)

IRs:
Transfer dest:PROMO value:promo""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
pay()

IRs:
INTERNAL_CALL, Game.pay()()""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: END_IF 21
""];
}
",0,0,1,0,"msg.value == 0 && msg.sender == last.depositor;require(bool,string)(gasleft()() >= 220000,We require more gas!);msg.value > 0;require(bool,string)(last.blockNumber + 258 < block.number,Last depositor should wait 258 blocks (~0.2 hour) to claim reward);money = uint128((address(this).balance));money >= last.expect;last.depositor.transfer(last.expect);last.depositor.transfer(money);;delete last;;require(bool,string)(gasleft()() >= 220000,We require more gas!);;require(bool,string)(msg.value <= MAX_DEPOSIT && msg.value >= MIN_DEPOSIT,Deposit must be >= 0.01 ETH and <= 1 ETH);queue.push(Deposit(msg.sender,uint128(msg.value),uint128(msg.value * MULTIPLIER / 100)));last.depositor = msg.sender;last.expect += msg.value * LAST_DEPOSIT_PERCENT / 100;last.blockNumber = block.number;promo = msg.value * PROMO_PERCENT / 100;PROMO.transfer(promo);pay()"
./0x2aaefbac989f8951436c36474c304af7bf31bb26_ext.sol,Administration.withdrawBalanceAll,73,75,"TMP_34 = CONVERT this to address,TMP_35(uint256) = SOLIDITY_CALL balance(address)(TMP_34),Transfer dest:CEOAddress value:TMP_35,MODIFIER_CALL, Administration.onlyAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
CEOAddress.transfer(address(this).balance)

IRs:
TMP_34 = CONVERT this to address
TMP_35(uint256) = SOLIDITY_CALL balance(address)(TMP_34)
Transfer dest:CEOAddress value:TMP_35""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Administration.onlyAdmin()()""];
2->1;
}
",0,0,1,0,onlyAdmin();CEOAddress.transfer(address(this).balance)
./0x75cb629408d1ea387df0a1f755e0bc371a5fa036_ext.sol,GoodLuckCasino.userWithdraw,164,167,"Transfer dest:_to value:_amount,Emit LOG_Withdraw(_to,_amount),MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, GoodLuckCasino.onlyIfNotStopped()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_to.transfer(_amount)

IRs:
Transfer dest:_to value:_amount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
LOG_Withdraw(_to,_amount)

IRs:
Emit LOG_Withdraw(_to,_amount)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyIfNotStopped()

IRs:
MODIFIER_CALL, GoodLuckCasino.onlyIfNotStopped()()""];
4->1;
}
",0,0,1,0,"onlyOwner();_to.transfer(_amount);LOG_Withdraw(_to,_amount);onlyIfNotStopped()"
./0xf0cc17aa0ce1c6595e56c9c60b19c1c546ade50d_ext.sol,Vault.withdraw,75,83,"TMP_35(bool) = INTERNAL_CALL, Vault.WithdrawEnabled()(),CONDITION TMP_35,REF_7(uint256) -> Deposits[msg.sender],max(uint256) := REF_7(uint256),TMP_36(bool) = max > 0,TMP_37(bool) = amount <= max,TMP_38(bool) = TMP_36 && TMP_37,CONDITION TMP_38,Transfer dest:to value:amount,Emit Withdrawal(to,amount),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: IF 1

EXPRESSION:
WithdrawEnabled()

IRs:
TMP_35(bool) = INTERNAL_CALL, Vault.WithdrawEnabled()()
CONDITION TMP_35""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
max = Deposits[msg.sender]

IRs:
REF_7(uint256) -> Deposits[msg.sender]
max(uint256) := REF_7(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
max > 0 && amount <= max

IRs:
TMP_36(bool) = max > 0
TMP_37(bool) = amount <= max
TMP_38(bool) = TMP_36 && TMP_37
CONDITION TMP_38""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
to.transfer(amount)

IRs:
Transfer dest:to value:amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Withdrawal(to,amount)

IRs:
Emit Withdrawal(to,amount)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: END_IF 7
""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
8->1;
}
",0,0,1,0,"onlyOwner();WithdrawEnabled();max = Deposits[msg.sender];;max > 0 && amount <= max;to.transfer(amount);;Withdrawal(to,amount)"
./0x8668ef4534ec8716dede42807084a526ff4904e2_ext.sol,BatchTransferContract.drain,83,90,"TMP_31(bool) = msg.sender == owner,TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31),REF_12(uint256) = SOLIDITY_CALL balance(address)(this),TMP_33(uint256) = LIBRARY_CALL, dest:Math, function:Math.min256(uint256,uint256), arguments:['ethAmount', 'REF_12'] ,amount(uint256) := TMP_33(uint256),TMP_34(bool) = amount > 0,CONDITION TMP_34,Transfer dest:owner value:amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_31(bool) = msg.sender == owner
TMP_32(None) = SOLIDITY_CALL require(bool)(TMP_31)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = ethAmount.min256(this.balance)

IRs:
REF_12(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_33(uint256) = LIBRARY_CALL, dest:Math, function:Math.min256(uint256,uint256), arguments:['ethAmount', 'REF_12'] 
amount(uint256) := TMP_33(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
amount > 0

IRs:
TMP_34(bool) = amount > 0
CONDITION TMP_34""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
owner.transfer(amount)

IRs:
Transfer dest:owner value:amount""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,0,1,0,require(bool)(msg.sender == owner);amount = ethAmount.min256(this.balance);amount > 0;owner.transfer(amount);
./0x515c5f699ba46bb43f720914b5615e00aa160871_ext.sol,MultiSigWallet.executeTransaction,222,236,"TMP_48(bool) = INTERNAL_CALL, MultiSigWallet.isConfirmed(uint256)(transactionId),CONDITION TMP_48,REF_31(MultiSigWallet.Transaction) -> transactions[transactionId],tx(MultiSigWallet.Transaction) := REF_31(MultiSigWallet.Transaction),REF_32(bool) -> tx.executed,REF_32(bool) (->tx) := True(bool),REF_33(address) -> tx.destination,REF_36(uint256) -> tx.value,REF_37(bytes) -> tx.data,TMP_50(bool) = LOW_LEVEL_CALL, dest:REF_33, function:call, arguments:['REF_37'] value:REF_36 ,CONDITION TMP_50,Emit Execution(transactionId),Emit ExecutionFailure(transactionId),REF_38(bool) -> tx.executed,REF_38(bool) (->tx) := False(bool),MODIFIER_CALL, MultiSigWallet.notExecuted(uint256)(transactionId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: IF 1

EXPRESSION:
isConfirmed(transactionId)

IRs:
TMP_48(bool) = INTERNAL_CALL, MultiSigWallet.isConfirmed(uint256)(transactionId)
CONDITION TMP_48""];
1->2[label=""True""];
1->9[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
tx = transactions[transactionId]

IRs:
REF_31(MultiSigWallet.Transaction) -> transactions[transactionId]
tx(MultiSigWallet.Transaction) := REF_31(MultiSigWallet.Transaction)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tx.executed = true

IRs:
REF_32(bool) -> tx.executed
REF_32(bool) (->tx) := True(bool)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
tx.destination.call.value(tx.value)(tx.data)

IRs:
REF_33(address) -> tx.destination
REF_36(uint256) -> tx.value
REF_37(bytes) -> tx.data
TMP_50(bool) = LOW_LEVEL_CALL, dest:REF_33, function:call, arguments:['REF_37'] value:REF_36 
CONDITION TMP_50""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Execution(transactionId)

IRs:
Emit Execution(transactionId)""];
5->8;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
ExecutionFailure(transactionId)

IRs:
Emit ExecutionFailure(transactionId)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tx.executed = false

IRs:
REF_38(bool) -> tx.executed
REF_38(bool) (->tx) := False(bool)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, MultiSigWallet.notExecuted(uint256)(transactionId)""];
10->1;
}
",0,0,1,0,notExecuted(transactionId);isConfirmed(transactionId);tx = transactions[transactionId];;tx.executed = true;tx.destination.call.value(tx.value)(tx.data);Execution(transactionId);ExecutionFailure(transactionId);;tx.executed = false
./0x0e915b35cc269b2dfc8bbd8e4a88ed4884a53efc_ext.sol,CrowdSale.safeWithdrawal,139,163,"TMP_20 = UnaryType.BANG fundingGoalReached ,CONDITION TMP_20,REF_2(uint256) -> balanceOf[msg.sender],amount(uint256) := REF_2(uint256),REF_3(uint256) -> balanceOf[msg.sender],REF_3(uint256) (->balanceOf) := 0(uint256),TMP_21(bool) = amount > 0,CONDITION TMP_21,TMP_22 = SEND dest:msg.sender value:amount,CONDITION TMP_22,Emit FundTransfer(msg.sender,amount,False),REF_5(uint256) -> balanceOf[msg.sender],REF_5(uint256) (->balanceOf) := amount(uint256),TMP_24(bool) = beneficiary == msg.sender,TMP_25(bool) = fundingGoalReached && TMP_24,CONDITION TMP_25,TMP_26 = SEND dest:beneficiary value:amountRaised,CONDITION TMP_26,Emit FundTransfer(beneficiary,amountRaised,False),fundingGoalReached(bool) := False(bool),MODIFIER_CALL, CrowdSale.afterDeadline()(),MODIFIER_CALL, CrowdSale.isClosed()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->17;
1[label=""Node Type: IF 1

EXPRESSION:
! fundingGoalReached

IRs:
TMP_20 = UnaryType.BANG fundingGoalReached 
CONDITION TMP_20""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = balanceOf[msg.sender]

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
amount(uint256) := REF_2(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[msg.sender] = 0

IRs:
REF_3(uint256) -> balanceOf[msg.sender]
REF_3(uint256) (->balanceOf) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
amount > 0

IRs:
TMP_21(bool) = amount > 0
CONDITION TMP_21""];
4->5[label=""True""];
4->9[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
msg.sender.send(amount)

IRs:
TMP_22 = SEND dest:msg.sender value:amount
CONDITION TMP_22""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
FundTransfer(msg.sender,amount,false)

IRs:
Emit FundTransfer(msg.sender,amount,False)""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balanceOf[msg.sender] = amount

IRs:
REF_5(uint256) -> balanceOf[msg.sender]
REF_5(uint256) (->balanceOf) := amount(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
fundingGoalReached && beneficiary == msg.sender

IRs:
TMP_24(bool) = beneficiary == msg.sender
TMP_25(bool) = fundingGoalReached && TMP_24
CONDITION TMP_25""];
11->12[label=""True""];
11->16[label=""False""];
12[label=""Node Type: IF 12

EXPRESSION:
beneficiary.send(amountRaised)

IRs:
TMP_26 = SEND dest:beneficiary value:amountRaised
CONDITION TMP_26""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
FundTransfer(beneficiary,amountRaised,false)

IRs:
Emit FundTransfer(beneficiary,amountRaised,False)""];
13->15;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
fundingGoalReached = false

IRs:
fundingGoalReached(bool) := False(bool)""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: END_IF 16
""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
afterDeadline()

IRs:
MODIFIER_CALL, CrowdSale.afterDeadline()()""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
isClosed()

IRs:
MODIFIER_CALL, CrowdSale.isClosed()()""];
18->1;
}
",0,0,1,0,"afterDeadline();! fundingGoalReached;amount = balanceOf[msg.sender];;balanceOf[msg.sender] = 0;amount > 0;msg.sender.send(amount);;FundTransfer(msg.sender,amount,false);balanceOf[msg.sender] = amount;;fundingGoalReached && beneficiary == msg.sender;beneficiary.send(amountRaised);;FundTransfer(beneficiary,amountRaised,false);fundingGoalReached = false;;isClosed()"
./0xbcdc85a62e5f29930a43cc20d15fe96786873084_ext.sol,ENJOY.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x559cc6564ef51bd1ad9fbe752c9455cb6fb7feb1_ext.sol,GuessNumber.kill,52,54,"TMP_7(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, GuessNumber.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_7(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, GuessNumber.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0x0254ffd95dd7c8e27d4c7a32e24464196efcc852_ext.sol,BEATA.safeWithdrawal,304,309,"TMP_97(bool) = _value == 0,CONDITION TMP_97,TMP_98 = CONVERT this to address,TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98),Transfer dest:owner value:TMP_99,Transfer dest:owner value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_97(bool) = _value == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_98 = CONVERT this to address
TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98)
Transfer dest:owner value:TMP_99""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_value == 0;owner.transfer(address(this).balance);owner.transfer(_value);
./0x70bf9df6967dc96156e76cc43b928a7ef02e159a_ext.sol,X_GAME.Play,5,14,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0xd745a7883a6bd19389b6b9dc8580c2ff873f0cd1_ext.sol,Earthpayment.safeWithdrawal,304,309,"TMP_97(bool) = _value == 0,CONDITION TMP_97,TMP_98 = CONVERT this to address,TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98),Transfer dest:owner value:TMP_99,Transfer dest:owner value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_97(bool) = _value == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_98 = CONVERT this to address
TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98)
Transfer dest:owner value:TMP_99""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_value == 0;owner.transfer(address(this).balance);owner.transfer(_value);
./0x71a42fd60323204912468cd32a8283ed5d45a28f_ext.sol,Slugroad.WithdrawBalance,323,332,"INTERNAL_CALL, Slugroad.ClaimDiv()(),REF_56(uint256) -> playerBalance[msg.sender],TMP_80(bool) = REF_56 > 0,TMP_81(None) = SOLIDITY_CALL require(bool,string)(TMP_80,no ether to withdraw),REF_57(uint256) -> playerBalance[msg.sender],_amount(uint256) := REF_57(uint256),REF_58(uint256) -> playerBalance[msg.sender],REF_58(uint256) (->playerBalance) := 0(uint256),Transfer dest:msg.sender value:_amount,Emit WithdrewBalance(msg.sender,_amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ClaimDiv()

IRs:
INTERNAL_CALL, Slugroad.ClaimDiv()()""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(playerBalance[msg.sender] > 0,no ether to withdraw)

IRs:
REF_56(uint256) -> playerBalance[msg.sender]
TMP_80(bool) = REF_56 > 0
TMP_81(None) = SOLIDITY_CALL require(bool,string)(TMP_80,no ether to withdraw)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
_amount = playerBalance[msg.sender]

IRs:
REF_57(uint256) -> playerBalance[msg.sender]
_amount(uint256) := REF_57(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
playerBalance[msg.sender] = 0

IRs:
REF_58(uint256) -> playerBalance[msg.sender]
REF_58(uint256) (->playerBalance) := 0(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(_amount)

IRs:
Transfer dest:msg.sender value:_amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
WithdrewBalance(msg.sender,_amount)

IRs:
Emit WithdrewBalance(msg.sender,_amount)""];
}
",0,0,1,0,"ClaimDiv();require(bool,string)(playerBalance[msg.sender] > 0,no ether to withdraw);_amount = playerBalance[msg.sender];playerBalance[msg.sender] = 0;msg.sender.transfer(_amount);WithdrewBalance(msg.sender,_amount)"
./0xd7afbf5141a7f1d6b0473175f7a6b0a7954ed3d2_ext.sol,CryptoEngineer.upgrade,248,251,"TMP_83(None) = SOLIDITY_CALL selfdestruct(address)(addr),MODIFIER_CALL, CryptoEngineer.isAdministrator()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(addr)

IRs:
TMP_83(None) = SOLIDITY_CALL selfdestruct(address)(addr)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdministrator()

IRs:
MODIFIER_CALL, CryptoEngineer.isAdministrator()()""];
2->1;
}
",0,0,1,0,isAdministrator();selfdestruct(address)(addr)
./0x6543cde961213e82001594bf4c34706579ce34ec_ext.sol,ClinicAllRefundEscrow.beneficiaryWithdrawAll,1138,1142,"TMP_540 = CONVERT this to address,TMP_541(uint256) = SOLIDITY_CALL balance(address)(TMP_540),_value(uint256) := TMP_541(uint256),TMP_542(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['beneficiaryDepositedAmount', '_value'] ,beneficiaryDepositedAmount(uint256) := TMP_542(uint256),Transfer dest:beneficiary value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_value = address(this).balance

IRs:
TMP_540 = CONVERT this to address
TMP_541(uint256) = SOLIDITY_CALL balance(address)(TMP_540)
_value(uint256) := TMP_541(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
beneficiaryDepositedAmount = beneficiaryDepositedAmount.sub(_value)

IRs:
TMP_542(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['beneficiaryDepositedAmount', '_value'] 
beneficiaryDepositedAmount(uint256) := TMP_542(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
beneficiary.transfer(_value)

IRs:
Transfer dest:beneficiary value:_value""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();_value = address(this).balance;beneficiaryDepositedAmount = beneficiaryDepositedAmount.sub(_value);beneficiary.transfer(_value)
./0x1e85407e080a5e6d20a3a95fcdddfc32146fc8e5_ext.sol,MiniMeToken.fallback,612,615,"TMP_129(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller),TMP_130(None) = SOLIDITY_CALL require(bool)(TMP_129),TMP_131 = CONVERT controller to TokenController,TMP_133(bool) = HIGH_LEVEL_CALL, dest:TMP_131(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value ,TMP_134(None) = SOLIDITY_CALL require(bool)(TMP_133)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isContract(controller))

IRs:
TMP_129(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)
TMP_130(None) = SOLIDITY_CALL require(bool)(TMP_129)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))

IRs:
TMP_131 = CONVERT controller to TokenController
TMP_133(bool) = HIGH_LEVEL_CALL, dest:TMP_131(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value 
TMP_134(None) = SOLIDITY_CALL require(bool)(TMP_133)""];
}
",0,0,1,0,require(bool)(isContract(controller));require(bool)(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))
./0x5094f35a78dbe896c4f357bf9165448be40309de_ext.sol,Preallocation.buyTokens,111,117,"REF_5(uint256) = SOLIDITY_CALL balance(address)(this),TMP_30(uint256) = LIBRARY_CALL, dest:Math, function:Math.min256(uint256,uint256), arguments:['REF_5', 'maxBalance'] ,bal(uint256) := TMP_30(uint256),HIGH_LEVEL_CALL, dest:crowdsale(Crowdsale), function:buyTokens, arguments:['investor'] value:bal ,REF_8(Preallocation.States) -> States.Success,state(Preallocation.States) := REF_8(Preallocation.States),Emit InvestmentSucceeded(bal),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
bal = Math.min256(this.balance,maxBalance)

IRs:
REF_5(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_30(uint256) = LIBRARY_CALL, dest:Math, function:Math.min256(uint256,uint256), arguments:['REF_5', 'maxBalance'] 
bal(uint256) := TMP_30(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
crowdsale.buyTokens.value(bal)(investor)

IRs:
HIGH_LEVEL_CALL, dest:crowdsale(Crowdsale), function:buyTokens, arguments:['investor'] value:bal ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
state = States.Success

IRs:
REF_8(Preallocation.States) -> States.Success
state(Preallocation.States) := REF_8(Preallocation.States)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
InvestmentSucceeded(bal)

IRs:
Emit InvestmentSucceeded(bal)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",1,0,1,0,"onlyOwner();bal = Math.min256(this.balance,maxBalance);crowdsale.buyTokens.value(bal)(investor);state = States.Success;InvestmentSucceeded(bal)"
./0x184b8e35fea87e75498705ea96f2326db8ee2470_ext.sol,AirDrop.transferEthToOnwer,94,96,"REF_15(uint256) = SOLIDITY_CALL balance(address)(this),TMP_28 = SEND dest:owner value:REF_15,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(owner.send(this.balance))

IRs:
REF_15(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_28 = SEND dest:owner value:REF_15
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();require(bool)(owner.send(this.balance))
./0x522055cdfabaed68f1fc579f18cd7a8a6e0ab79a_ext.sol,AceDice.kill,1429,1432,"TMP_1415(bool) = lockedInBets == 0,TMP_1416(None) = SOLIDITY_CALL require(bool,string)(TMP_1415,All bets should be processed (settled or refunded) before self-destruct.),TMP_1417(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, AceDice.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(lockedInBets == 0,All bets should be processed (settled or refunded) before self-destruct.)

IRs:
TMP_1415(bool) = lockedInBets == 0
TMP_1416(None) = SOLIDITY_CALL require(bool,string)(TMP_1415,All bets should be processed (settled or refunded) before self-destruct.)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_1417(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, AceDice.onlyOwner()()""];
3->1;
}
",0,0,1,0,"onlyOwner();require(bool,string)(lockedInBets == 0,All bets should be processed (settled or refunded) before self-destruct.);selfdestruct(address)(owner)"
./0xdcb5410ef70f59a5a2839fc6d4d0b2ca981f5e2d_ext.sol,CoinMmc.withDraw,434,442,"TMP_131(bool) = msg.sender == admin_address,TMP_132(bool) = msg.sender == direct_drop_withdraw_address,TMP_133(bool) = TMP_131 || TMP_132,TMP_134(None) = SOLIDITY_CALL require(bool)(TMP_133),TMP_135 = CONVERT this to address,TMP_136(uint256) = SOLIDITY_CALL balance(address)(TMP_135),TMP_137(bool) = TMP_136 > 0,TMP_138(None) = SOLIDITY_CALL require(bool)(TMP_137),TMP_139 = CONVERT this to address,TMP_140(uint256) = SOLIDITY_CALL balance(address)(TMP_139),Transfer dest:direct_drop_withdraw_address value:TMP_140","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == admin_address || msg.sender == direct_drop_withdraw_address)

IRs:
TMP_131(bool) = msg.sender == admin_address
TMP_132(bool) = msg.sender == direct_drop_withdraw_address
TMP_133(bool) = TMP_131 || TMP_132
TMP_134(None) = SOLIDITY_CALL require(bool)(TMP_133)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(address(this).balance > 0)

IRs:
TMP_135 = CONVERT this to address
TMP_136(uint256) = SOLIDITY_CALL balance(address)(TMP_135)
TMP_137(bool) = TMP_136 > 0
TMP_138(None) = SOLIDITY_CALL require(bool)(TMP_137)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
direct_drop_withdraw_address.transfer(address(this).balance)

IRs:
TMP_139 = CONVERT this to address
TMP_140(uint256) = SOLIDITY_CALL balance(address)(TMP_139)
Transfer dest:direct_drop_withdraw_address value:TMP_140""];
}
",0,0,1,0,require(bool)(msg.sender == admin_address || msg.sender == direct_drop_withdraw_address);require(bool)(address(this).balance > 0);direct_drop_withdraw_address.transfer(address(this).balance)
./0x840b875acfd1034723a23cb079184c7b56a89b90_ext.sol,DSG_Dice.sendOwnerDeposit,167,178,"TMP_165(bool) = paused == True,TMP_166(None) = SOLIDITY_CALL require(bool,string)(TMP_165,Game was not stopped),TMP_167(uint256) = INTERNAL_CALL, DSG_Dice.getContractBalance()(),contractBalance(uint256) := TMP_167(uint256),TMP_168(bool) = contractBalance >= ownerDeposit,CONDITION TMP_168,Transfer dest:recipient value:ownerDeposit,Transfer dest:recipient value:contractBalance,jackpotBalance = delete jackpotBalance ,ownerDeposit = delete ownerDeposit ,MODIFIER_CALL, DSG_Dice.onlyOwners()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(paused == true,Game was not stopped)

IRs:
TMP_165(bool) = paused == True
TMP_166(None) = SOLIDITY_CALL require(bool,string)(TMP_165,Game was not stopped)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
contractBalance = getContractBalance()

IRs:
TMP_167(uint256) = INTERNAL_CALL, DSG_Dice.getContractBalance()()
contractBalance(uint256) := TMP_167(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
contractBalance >= ownerDeposit

IRs:
TMP_168(bool) = contractBalance >= ownerDeposit
CONDITION TMP_168""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
recipient.transfer(ownerDeposit)

IRs:
Transfer dest:recipient value:ownerDeposit""];
4->6;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
recipient.transfer(contractBalance)

IRs:
Transfer dest:recipient value:contractBalance""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
delete jackpotBalance

IRs:
jackpotBalance = delete jackpotBalance ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
delete ownerDeposit

IRs:
ownerDeposit = delete ownerDeposit ""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwners()

IRs:
MODIFIER_CALL, DSG_Dice.onlyOwners()()""];
9->1;
}
",0,0,1,0,"onlyOwners();require(bool,string)(paused == true,Game was not stopped);contractBalance = getContractBalance();contractBalance >= ownerDeposit;recipient.transfer(ownerDeposit);recipient.transfer(contractBalance);;delete jackpotBalance;delete ownerDeposit"
./0xdccedb215833b58c8c624abe5b5c715844248816_ext.sol,QuiZ_blIZ.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 400000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 400000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 400000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 400000000000000000;msg.sender.transfer(this.balance);
./0x4c7f666ca30fe548fbdc08b0308927327f08336d_ext.sol,RefundVault.close,902,907,"REF_427(RefundVault.State) -> State.Active,TMP_757(bool) = state == REF_427,TMP_758(None) = SOLIDITY_CALL require(bool)(TMP_757),REF_428(RefundVault.State) -> State.Closed,state(RefundVault.State) := REF_428(RefundVault.State),Emit Closed(),REF_430(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:wallet value:REF_430,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_427(RefundVault.State) -> State.Active
TMP_757(bool) = state == REF_427
TMP_758(None) = SOLIDITY_CALL require(bool)(TMP_757)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
state = State.Closed

IRs:
REF_428(RefundVault.State) -> State.Closed
state(RefundVault.State) := REF_428(RefundVault.State)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Closed()

IRs:
Emit Closed()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
wallet.transfer(this.balance)

IRs:
REF_430(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:wallet value:REF_430""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();require(bool)(state == State.Active);state = State.Closed;Closed();wallet.transfer(this.balance)
./0xa4fd4ba726139d42d7b7cf18a064600cafac4f97_ext.sol,TFTOKEN.safeWithdrawal,304,309,"TMP_97(bool) = _value == 0,CONDITION TMP_97,TMP_98 = CONVERT this to address,TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98),Transfer dest:owner value:TMP_99,Transfer dest:owner value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_97(bool) = _value == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_98 = CONVERT this to address
TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98)
Transfer dest:owner value:TMP_99""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_value == 0;owner.transfer(address(this).balance);owner.transfer(_value);
./0x72ebd62060f78d91dc4bc33e8d88f39307365f87_ext.sol,SEA.destructor,153,157,"TMP_107(bool) = msg.sender == owner,TMP_108(None) = SOLIDITY_CALL require(bool)(TMP_107),TMP_109(None) = SOLIDITY_CALL selfdestruct(address)(owner),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_107(bool) = msg.sender == owner
TMP_108(None) = SOLIDITY_CALL require(bool)(TMP_107)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_109(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
4[label=""Node Type: RETURN 4

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,0,1,0,require(bool)(msg.sender == owner);selfdestruct(address)(owner);true;success
./0x4c0fbe1bb46612915e7967d2c3213cd4d87257ad_ext.sol,ApisCrowdSale.refundByOwner,1025,1044,"REF_190(ApisCrowdSale.Property) -> fundersProperty[_funder],REF_191(uint256) -> REF_190.reservedFunds,TMP_256(bool) = REF_191 > 0,TMP_257(None) = SOLIDITY_CALL require(bool)(TMP_256),REF_192(ApisCrowdSale.Property) -> fundersProperty[_funder],REF_193(uint256) -> REF_192.reservedFunds,amountFunds(uint256) := REF_193(uint256),REF_194(ApisCrowdSale.Property) -> fundersProperty[_funder],REF_195(uint256) -> REF_194.reservedApis,amountApis(uint256) := REF_195(uint256),Transfer dest:_funder value:amountFunds,REF_197(uint256) -> saleStatus.totalReceivedFunds,REF_197(-> saleStatus) = REF_197 - amountFunds,REF_198(uint256) -> saleStatus.totalReservedFunds,REF_198(-> saleStatus) = REF_198 - amountFunds,REF_199(uint256) -> saleStatus.totalSoldApis,REF_199(-> saleStatus) = REF_199 - amountApis,REF_200(uint256) -> saleStatus.totalReservedApis,REF_200(-> saleStatus) = REF_200 - amountApis,REF_201(ApisCrowdSale.Property) -> fundersProperty[_funder],REF_202(uint256) -> REF_201.reservedFunds,REF_202(uint256) (->fundersProperty) := 0(uint256),REF_203(ApisCrowdSale.Property) -> fundersProperty[_funder],REF_204(uint256) -> REF_203.reservedApis,REF_204(uint256) (->fundersProperty) := 0(uint256),Emit Refund(_funder,amountFunds,amountApis),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(fundersProperty[_funder].reservedFunds > 0)

IRs:
REF_190(ApisCrowdSale.Property) -> fundersProperty[_funder]
REF_191(uint256) -> REF_190.reservedFunds
TMP_256(bool) = REF_191 > 0
TMP_257(None) = SOLIDITY_CALL require(bool)(TMP_256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amountFunds = fundersProperty[_funder].reservedFunds

IRs:
REF_192(ApisCrowdSale.Property) -> fundersProperty[_funder]
REF_193(uint256) -> REF_192.reservedFunds
amountFunds(uint256) := REF_193(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
amountApis = fundersProperty[_funder].reservedApis

IRs:
REF_194(ApisCrowdSale.Property) -> fundersProperty[_funder]
REF_195(uint256) -> REF_194.reservedApis
amountApis(uint256) := REF_195(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
_funder.transfer(amountFunds)

IRs:
Transfer dest:_funder value:amountFunds""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
saleStatus.totalReceivedFunds -= amountFunds

IRs:
REF_197(uint256) -> saleStatus.totalReceivedFunds
REF_197(-> saleStatus) = REF_197 - amountFunds""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
saleStatus.totalReservedFunds -= amountFunds

IRs:
REF_198(uint256) -> saleStatus.totalReservedFunds
REF_198(-> saleStatus) = REF_198 - amountFunds""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
saleStatus.totalSoldApis -= amountApis

IRs:
REF_199(uint256) -> saleStatus.totalSoldApis
REF_199(-> saleStatus) = REF_199 - amountApis""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
saleStatus.totalReservedApis -= amountApis

IRs:
REF_200(uint256) -> saleStatus.totalReservedApis
REF_200(-> saleStatus) = REF_200 - amountApis""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
fundersProperty[_funder].reservedFunds = 0

IRs:
REF_201(ApisCrowdSale.Property) -> fundersProperty[_funder]
REF_202(uint256) -> REF_201.reservedFunds
REF_202(uint256) (->fundersProperty) := 0(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
fundersProperty[_funder].reservedApis = 0

IRs:
REF_203(ApisCrowdSale.Property) -> fundersProperty[_funder]
REF_204(uint256) -> REF_203.reservedApis
REF_204(uint256) (->fundersProperty) := 0(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
Refund(_funder,amountFunds,amountApis)

IRs:
Emit Refund(_funder,amountFunds,amountApis)""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
12->1;
}
",0,1,1,0,"onlyOwner();require(bool)(fundersProperty[_funder].reservedFunds > 0);amountFunds = fundersProperty[_funder].reservedFunds;amountApis = fundersProperty[_funder].reservedApis;_funder.transfer(amountFunds);saleStatus.totalReceivedFunds -= amountFunds;saleStatus.totalReservedFunds -= amountFunds;saleStatus.totalSoldApis -= amountApis;saleStatus.totalReservedApis -= amountApis;fundersProperty[_funder].reservedFunds = 0;fundersProperty[_funder].reservedApis = 0;Refund(_funder,amountFunds,amountApis)"
./0x1860b26155ce3319ace6d1a7ad3a363b58bc97c5_ext.sol,MatchBetting.getEther,184,230,"TMP_51(None) = SOLIDITY_CALL require(bool)(matchCompleted),TMP_52(bool) = winIndex == 2,CONDITION TMP_52,REF_48(MatchBetting.Team) -> teams[0],REF_49(mapping(address => uint256)) -> REF_48.bettingContribution,REF_50(uint256) -> REF_49[msg.sender],betOnTeamA(uint256) := REF_50(uint256),REF_51(MatchBetting.Team) -> teams[1],REF_52(mapping(address => uint256)) -> REF_51.bettingContribution,REF_53(uint256) -> REF_52[msg.sender],betOnTeamB(uint256) := REF_53(uint256),REF_54(MatchBetting.Team) -> teams[0],REF_55(mapping(address => uint256)) -> REF_54.bettingContribution,REF_56(uint256) -> REF_55[msg.sender],REF_56(uint256) (->teams) := 0(uint256),REF_57(MatchBetting.Team) -> teams[1],REF_58(mapping(address => uint256)) -> REF_57.bettingContribution,REF_59(uint256) -> REF_58[msg.sender],REF_59(uint256) (->teams) := 0(uint256),TMP_53(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['betOnTeamA', 'betOnTeamB'] ,totalBetContribution(uint256) := TMP_53(uint256),TMP_54(bool) = totalBetContribution != 0,TMP_55(None) = SOLIDITY_CALL require(bool)(TMP_54),Transfer dest:msg.sender value:totalBetContribution,REF_62(MatchBetting.Team) -> teams[winIndex],REF_63(uint256) -> REF_62.totalAmount,TMP_57(bool) = REF_63 == 0,CONDITION TMP_57,REF_64(MatchBetting.Team) -> teams[loosingIndex],REF_65(mapping(address => uint256)) -> REF_64.bettingContribution,REF_66(uint256) -> REF_65[msg.sender],betValue(uint256) := REF_66(uint256),TMP_58(bool) = betValue != 0,TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58),REF_67(MatchBetting.Team) -> teams[loosingIndex],REF_68(mapping(address => uint256)) -> REF_67.bettingContribution,REF_69(uint256) -> REF_68[msg.sender],REF_69(uint256) (->teams) := 0(uint256),Transfer dest:msg.sender value:betValue,REF_71(MatchBetting.Team) -> teams[winIndex],REF_72(mapping(address => uint256)) -> REF_71.bettingContribution,REF_73(uint256) -> REF_72[msg.sender],betValue(uint256) := REF_73(uint256),TMP_61(bool) = betValue != 0,TMP_62(None) = SOLIDITY_CALL require(bool)(TMP_61),REF_74(MatchBetting.Team) -> teams[winIndex],REF_75(mapping(address => uint256)) -> REF_74.bettingContribution,REF_76(uint256) -> REF_75[msg.sender],REF_76(uint256) (->teams) := 0(uint256),REF_77(MatchBetting.Team) -> teams[winIndex],REF_78(uint256) -> REF_77.totalAmount,winTotalAmount(uint256) := REF_78(uint256),REF_79(MatchBetting.Team) -> teams[loosingIndex],REF_80(uint256) -> REF_79.totalAmount,loosingTotalAmount(uint256) := REF_80(uint256),TMP_63(bool) = loosingTotalAmount == 0,CONDITION TMP_63,Transfer dest:msg.sender value:betValue,userTotalShare(uint256) := betValue(uint256),TMP_65(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['betValue', '80'] ,TMP_66(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_65', '100'] ,TMP_67(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_66', 'loosingTotalAmount'] ,TMP_68(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_67', 'winTotalAmount'] ,bettingShare(uint256) := TMP_68(uint256),TMP_69(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['userTotalShare', 'bettingShare'] ,userTotalShare(uint256) := TMP_69(uint256),Transfer dest:msg.sender value:userTotalShare,TMP_71(bool) = winIndex == 0,CONDITION TMP_71,loosingIndex(uint256) := 1(uint256),loosingIndex(uint256) := 0(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(matchCompleted)

IRs:
TMP_51(None) = SOLIDITY_CALL require(bool)(matchCompleted)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
winIndex == 2

IRs:
TMP_52(bool) = winIndex == 2
CONDITION TMP_52""];
2->3[label=""True""];
2->31[label=""False""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
betOnTeamA = teams[0].bettingContribution[msg.sender]

IRs:
REF_48(MatchBetting.Team) -> teams[0]
REF_49(mapping(address => uint256)) -> REF_48.bettingContribution
REF_50(uint256) -> REF_49[msg.sender]
betOnTeamA(uint256) := REF_50(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
betOnTeamB = teams[1].bettingContribution[msg.sender]

IRs:
REF_51(MatchBetting.Team) -> teams[1]
REF_52(mapping(address => uint256)) -> REF_51.bettingContribution
REF_53(uint256) -> REF_52[msg.sender]
betOnTeamB(uint256) := REF_53(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
teams[0].bettingContribution[msg.sender] = 0

IRs:
REF_54(MatchBetting.Team) -> teams[0]
REF_55(mapping(address => uint256)) -> REF_54.bettingContribution
REF_56(uint256) -> REF_55[msg.sender]
REF_56(uint256) (->teams) := 0(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
teams[1].bettingContribution[msg.sender] = 0

IRs:
REF_57(MatchBetting.Team) -> teams[1]
REF_58(mapping(address => uint256)) -> REF_57.bettingContribution
REF_59(uint256) -> REF_58[msg.sender]
REF_59(uint256) (->teams) := 0(uint256)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
totalBetContribution = betOnTeamA.add(betOnTeamB)

IRs:
TMP_53(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['betOnTeamA', 'betOnTeamB'] 
totalBetContribution(uint256) := TMP_53(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(totalBetContribution != 0)

IRs:
TMP_54(bool) = totalBetContribution != 0
TMP_55(None) = SOLIDITY_CALL require(bool)(TMP_54)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
msg.sender.transfer(totalBetContribution)

IRs:
Transfer dest:msg.sender value:totalBetContribution""];
9->30;
11[label=""Node Type: NEW VARIABLE 11
""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
teams[winIndex].totalAmount == 0

IRs:
REF_62(MatchBetting.Team) -> teams[winIndex]
REF_63(uint256) -> REF_62.totalAmount
TMP_57(bool) = REF_63 == 0
CONDITION TMP_57""];
12->13[label=""True""];
12->17[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
betValue = teams[loosingIndex].bettingContribution[msg.sender]

IRs:
REF_64(MatchBetting.Team) -> teams[loosingIndex]
REF_65(mapping(address => uint256)) -> REF_64.bettingContribution
REF_66(uint256) -> REF_65[msg.sender]
betValue(uint256) := REF_66(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
require(bool)(betValue != 0)

IRs:
TMP_58(bool) = betValue != 0
TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
teams[loosingIndex].bettingContribution[msg.sender] = 0

IRs:
REF_67(MatchBetting.Team) -> teams[loosingIndex]
REF_68(mapping(address => uint256)) -> REF_67.bettingContribution
REF_69(uint256) -> REF_68[msg.sender]
REF_69(uint256) (->teams) := 0(uint256)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
msg.sender.transfer(betValue)

IRs:
Transfer dest:msg.sender value:betValue""];
16->29;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
betValue = teams[winIndex].bettingContribution[msg.sender]

IRs:
REF_71(MatchBetting.Team) -> teams[winIndex]
REF_72(mapping(address => uint256)) -> REF_71.bettingContribution
REF_73(uint256) -> REF_72[msg.sender]
betValue(uint256) := REF_73(uint256)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
require(bool)(betValue != 0)

IRs:
TMP_61(bool) = betValue != 0
TMP_62(None) = SOLIDITY_CALL require(bool)(TMP_61)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
teams[winIndex].bettingContribution[msg.sender] = 0

IRs:
REF_74(MatchBetting.Team) -> teams[winIndex]
REF_75(mapping(address => uint256)) -> REF_74.bettingContribution
REF_76(uint256) -> REF_75[msg.sender]
REF_76(uint256) (->teams) := 0(uint256)""];
19->20;
20[label=""Node Type: NEW VARIABLE 20

EXPRESSION:
winTotalAmount = teams[winIndex].totalAmount

IRs:
REF_77(MatchBetting.Team) -> teams[winIndex]
REF_78(uint256) -> REF_77.totalAmount
winTotalAmount(uint256) := REF_78(uint256)""];
20->21;
21[label=""Node Type: NEW VARIABLE 21

EXPRESSION:
loosingTotalAmount = teams[loosingIndex].totalAmount

IRs:
REF_79(MatchBetting.Team) -> teams[loosingIndex]
REF_80(uint256) -> REF_79.totalAmount
loosingTotalAmount(uint256) := REF_80(uint256)""];
21->22;
22[label=""Node Type: IF 22

EXPRESSION:
loosingTotalAmount == 0

IRs:
TMP_63(bool) = loosingTotalAmount == 0
CONDITION TMP_63""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
msg.sender.transfer(betValue)

IRs:
Transfer dest:msg.sender value:betValue""];
23->28;
24[label=""Node Type: NEW VARIABLE 24

EXPRESSION:
userTotalShare = betValue

IRs:
userTotalShare(uint256) := betValue(uint256)""];
24->25;
25[label=""Node Type: NEW VARIABLE 25

EXPRESSION:
bettingShare = betValue.mul(80).div(100).mul(loosingTotalAmount).div(winTotalAmount)

IRs:
TMP_65(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['betValue', '80'] 
TMP_66(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_65', '100'] 
TMP_67(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['TMP_66', 'loosingTotalAmount'] 
TMP_68(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_67', 'winTotalAmount'] 
bettingShare(uint256) := TMP_68(uint256)""];
25->26;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
userTotalShare = userTotalShare.add(bettingShare)

IRs:
TMP_69(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['userTotalShare', 'bettingShare'] 
userTotalShare(uint256) := TMP_69(uint256)""];
26->27;
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
msg.sender.transfer(userTotalShare)

IRs:
Transfer dest:msg.sender value:userTotalShare""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: END_IF 29
""];
29->30;
30[label=""Node Type: END_IF 30
""];
31[label=""Node Type: IF 31

EXPRESSION:
(winIndex == 0)

IRs:
TMP_71(bool) = winIndex == 0
CONDITION TMP_71""];
31->32[label=""True""];
31->33[label=""False""];
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
loosingIndex = 1

IRs:
loosingIndex(uint256) := 1(uint256)""];
32->34;
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
loosingIndex = 0

IRs:
loosingIndex(uint256) := 0(uint256)""];
33->34;
34[label=""Node Type: END_IF 34
""];
34->11;
}
",0,0,1,0,require(bool)(matchCompleted);winIndex == 2;betOnTeamA = teams[0].bettingContribution[msg.sender];(winIndex == 0);betOnTeamB = teams[1].bettingContribution[msg.sender];teams[0].bettingContribution[msg.sender] = 0;teams[1].bettingContribution[msg.sender] = 0;totalBetContribution = betOnTeamA.add(betOnTeamB);require(bool)(totalBetContribution != 0);msg.sender.transfer(totalBetContribution);;;teams[winIndex].totalAmount == 0;betValue = teams[loosingIndex].bettingContribution[msg.sender];betValue = teams[winIndex].bettingContribution[msg.sender];require(bool)(betValue != 0);teams[loosingIndex].bettingContribution[msg.sender] = 0;msg.sender.transfer(betValue);;require(bool)(betValue != 0);teams[winIndex].bettingContribution[msg.sender] = 0;winTotalAmount = teams[winIndex].totalAmount;loosingTotalAmount = teams[loosingIndex].totalAmount;loosingTotalAmount == 0;msg.sender.transfer(betValue);userTotalShare = betValue;;bettingShare = betValue.mul(80).div(100).mul(loosingTotalAmount).div(winTotalAmount);userTotalShare = userTotalShare.add(bettingShare);msg.sender.transfer(userTotalShare);loosingIndex = 1;loosingIndex = 0;
./0x6e5dce687b949b52dad8bb1cc467d0205cb4b6e3_ext.sol,CAC.safeWithdrawal,340,345,"TMP_120(bool) = _value == 0,CONDITION TMP_120,TMP_121 = CONVERT this to address,TMP_122(uint256) = SOLIDITY_CALL balance(address)(TMP_121),Transfer dest:owner value:TMP_122,Transfer dest:owner value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_120(bool) = _value == 0
CONDITION TMP_120""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_121 = CONVERT this to address
TMP_122(uint256) = SOLIDITY_CALL balance(address)(TMP_121)
Transfer dest:owner value:TMP_122""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_value == 0;owner.transfer(address(this).balance);owner.transfer(_value);
./0xf01d0e76efcea913b3203484a0d82b3995202001_ext.sol,GiftCard2017.withdraw,26,28,"Transfer dest:owner value:_amount,MODIFIER_CALL, GiftCard2017.OwnerOnly()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(_amount)

IRs:
Transfer dest:owner value:_amount""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
OwnerOnly()

IRs:
MODIFIER_CALL, GiftCard2017.OwnerOnly()()""];
2->1;
}
",0,0,1,0,OwnerOnly();owner.transfer(_amount)
./0x07c206f253605a9ac4e21a9cf99d7841e8636468_ext.sol,RYCSale.safeWithdrawal,590,600,"TMP_252 = UnaryType.BANG fundingGoalReached ,CONDITION TMP_252,REF_192(uint256) -> balanceOf[msg.sender],amount(uint256) := REF_192(uint256),REF_193(uint256) -> balanceOf[msg.sender],REF_193(uint256) (->balanceOf) := 0(uint256),TMP_253(bool) = amount > 0,CONDITION TMP_253,Transfer dest:msg.sender value:amount,Emit FundTransfer(msg.sender,amount,False),TMP_256(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['refundAmount', 'amount'] ,refundAmount(uint256) := TMP_256(uint256),MODIFIER_CALL, RYCSale.afterDeadline()(),MODIFIER_CALL, RYCSale.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: IF 1

EXPRESSION:
! fundingGoalReached

IRs:
TMP_252 = UnaryType.BANG fundingGoalReached 
CONDITION TMP_252""];
1->2[label=""True""];
1->9[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = balanceOf[msg.sender]

IRs:
REF_192(uint256) -> balanceOf[msg.sender]
amount(uint256) := REF_192(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[msg.sender] = 0

IRs:
REF_193(uint256) -> balanceOf[msg.sender]
REF_193(uint256) (->balanceOf) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
amount > 0

IRs:
TMP_253(bool) = amount > 0
CONDITION TMP_253""];
4->5[label=""True""];
4->8[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
FundTransfer(msg.sender,amount,false)

IRs:
Emit FundTransfer(msg.sender,amount,False)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
refundAmount = refundAmount.add(amount)

IRs:
TMP_256(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['refundAmount', 'amount'] 
refundAmount(uint256) := TMP_256(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
afterDeadline()

IRs:
MODIFIER_CALL, RYCSale.afterDeadline()()""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, RYCSale.nonReentrant()()""];
11->1;
}
",0,0,1,0,"afterDeadline();! fundingGoalReached;amount = balanceOf[msg.sender];;balanceOf[msg.sender] = 0;amount > 0;msg.sender.transfer(amount);;FundTransfer(msg.sender,amount,false);refundAmount = refundAmount.add(amount);nonReentrant()"
./0xee53ca3ae3d296c0f2a128138d12a0a3a60fa1f5_ext.sol,ZethrShell.WithdrawToBankroll,159,163,"REF_15(address) -> UsedBankrollAddresses[0],TMP_27 = CONVERT REF_15 to address,TMP_28 = CONVERT this to address,TMP_29(uint256) = SOLIDITY_CALL balance(address)(TMP_28),Transfer dest:TMP_27 value:TMP_29","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
address(UsedBankrollAddresses[0]).transfer(address(this).balance)

IRs:
REF_15(address) -> UsedBankrollAddresses[0]
TMP_27 = CONVERT REF_15 to address
TMP_28 = CONVERT this to address
TMP_29(uint256) = SOLIDITY_CALL balance(address)(TMP_28)
Transfer dest:TMP_27 value:TMP_29""];
}
",0,0,1,0,address(UsedBankrollAddresses[0]).transfer(address(this).balance)
./0xf165c0df0b759e93e6166aecb667c7ec2a300525_ext.sol,TokenICOGAT.withdrawEtherHomeLocal,171,175,"CONDITION purchasingAllowed,TMP_97(None) = SOLIDITY_CALL revert()(),TMP_98(bool) = msg.sender != owner,CONDITION TMP_98,TMP_99(None) = SOLIDITY_CALL revert()(),REF_45(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:_ethHome value:REF_45","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
purchasingAllowed

IRs:
CONDITION purchasingAllowed""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_97(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
msg.sender != owner

IRs:
TMP_98(bool) = msg.sender != owner
CONDITION TMP_98""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
revert()()

IRs:
TMP_99(None) = SOLIDITY_CALL revert()()""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
_ethHome.transfer(this.balance)

IRs:
REF_45(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:_ethHome value:REF_45""];
}
",0,0,1,0,purchasingAllowed;revert()();;msg.sender != owner;revert()();;_ethHome.transfer(this.balance)
./0x264979ffd35d608e69b69681f4bbcba9877e6c4a_ext.sol,qz_game.StopGame,29,31,"TMP_9(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender),MODIFIER_CALL, qz_game.onlyQuestionSender()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(msg.sender)

IRs:
TMP_9(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyQuestionSender()

IRs:
MODIFIER_CALL, qz_game.onlyQuestionSender()()""];
2->1;
}
",0,0,1,0,onlyQuestionSender();selfdestruct(address)(msg.sender)
./0xeee95f7af91b4611c0a707a0012e3ba06f7ca8d9_ext.sol,quiz_game.StopGame,33,36,"TMP_10(bool) = msg.sender == questionSender,TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_10(bool) = msg.sender == questionSender
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0xf0344800bd3ffa687e4d780357961b28995a5f46_ext.sol,QUIZ_GAME.StopGame,34,40,"TMP_9(bool) = msg.sender == questionSender,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_9(bool) = msg.sender == questionSender
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0x447b4ccab1b370afbe5ae2e68c0b700be913a585_ext.sol,AgileCycle.failSafe,794,804,"TMP_368(bool) = msg.sender == operator,CONDITION TMP_368,saveMe(bool) := True(bool),TMP_369(bool) = msg.sender == juryOperator,CONDITION TMP_369,TMP_370(bool) = saveMe == True,TMP_371(None) = SOLIDITY_CALL require(bool)(TMP_370),TMP_372 = CONVERT this to address,TMP_373(uint256) = SOLIDITY_CALL balance(address)(TMP_372),TMP_374 = SEND dest:juryOperator value:TMP_373,TMP_375(None) = SOLIDITY_CALL require(bool)(TMP_374),TMP_376(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:balanceOf, arguments:['this']  ,allTheLockedTokens(uint256) := TMP_376(uint256),TMP_377(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transfer, arguments:['juryOperator', 'allTheLockedTokens']  ,TMP_378(None) = SOLIDITY_CALL require(bool)(TMP_377)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == operator

IRs:
TMP_368(bool) = msg.sender == operator
CONDITION TMP_368""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
saveMe = true

IRs:
saveMe(bool) := True(bool)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
msg.sender == juryOperator

IRs:
TMP_369(bool) = msg.sender == juryOperator
CONDITION TMP_369""];
4->5[label=""True""];
4->9[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(saveMe == true)

IRs:
TMP_370(bool) = saveMe == True
TMP_371(None) = SOLIDITY_CALL require(bool)(TMP_370)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(juryOperator.send(address(this).balance))

IRs:
TMP_372 = CONVERT this to address
TMP_373(uint256) = SOLIDITY_CALL balance(address)(TMP_372)
TMP_374 = SEND dest:juryOperator value:TMP_373
TMP_375(None) = SOLIDITY_CALL require(bool)(TMP_374)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
allTheLockedTokens = token.balanceOf(this)

IRs:
TMP_376(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:balanceOf, arguments:['this']  
allTheLockedTokens(uint256) := TMP_376(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(token.transfer(juryOperator,allTheLockedTokens))

IRs:
TMP_377(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transfer, arguments:['juryOperator', 'allTheLockedTokens']  
TMP_378(None) = SOLIDITY_CALL require(bool)(TMP_377)""];
8->9;
9[label=""Node Type: END_IF 9
""];
}
",0,0,1,0,"msg.sender == operator;saveMe = true;;msg.sender == juryOperator;require(bool)(saveMe == true);;require(bool)(juryOperator.send(address(this).balance));allTheLockedTokens = token.balanceOf(this);require(bool)(token.transfer(juryOperator,allTheLockedTokens))"
./0xd2df59cfcd5086264532936afde48a5312ce96bb_ext.sol,Auction.weiToOwner,208,214,"TMP_55(bool) = block.timestamp > _end,TMP_56(None) = SOLIDITY_CALL require(bool,string)(TMP_55,Auction not ended),TMP_57 = CONVERT this to address,TMP_58(uint256) = SOLIDITY_CALL balance(address)(TMP_57),Transfer dest:_address value:TMP_58,RETURN True,MODIFIER_CALL, Ownable.contract_onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(block.timestamp > _end,Auction not ended)

IRs:
TMP_55(bool) = block.timestamp > _end
TMP_56(None) = SOLIDITY_CALL require(bool,string)(TMP_55,Auction not ended)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_address.transfer(address(this).balance)

IRs:
TMP_57 = CONVERT this to address
TMP_58(uint256) = SOLIDITY_CALL balance(address)(TMP_57)
Transfer dest:_address value:TMP_58""];
2->3;
3[label=""Node Type: RETURN 3

EXPRESSION:
true

IRs:
RETURN True""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
contract_onlyOwner()

IRs:
MODIFIER_CALL, Ownable.contract_onlyOwner()()""];
4->1;
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,0,1,0,"contract_onlyOwner();require(bool,string)(block.timestamp > _end,Auction not ended);_address.transfer(address(this).balance);true;success"
./0x3a37dcda0503f92626c082540dfbc9d95104ab96_ext.sol,EthernautsLogic.withdrawBalances,1009,1011,"REF_99(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:_to value:REF_99,MODIFIER_CALL, EthernautsAccessControl.onlyCLevel()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_to.transfer(this.balance)

IRs:
REF_99(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:_to value:REF_99""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyCLevel()

IRs:
MODIFIER_CALL, EthernautsAccessControl.onlyCLevel()()""];
2->1;
}
",0,0,1,0,onlyCLevel();_to.transfer(this.balance)
./0x00676065a7854163c6a4d5f474496514d03e31c4_ext.sol,CrystalDeposit.upgrade,143,146,"TMP_15(None) = SOLIDITY_CALL selfdestruct(address)(addr),MODIFIER_CALL, CrystalDeposit.isAdministrator()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(addr)

IRs:
TMP_15(None) = SOLIDITY_CALL selfdestruct(address)(addr)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdministrator()

IRs:
MODIFIER_CALL, CrystalDeposit.isAdministrator()()""];
2->1;
}
",0,0,1,0,isAdministrator();selfdestruct(address)(addr)
./0xeebf279ee18d7d7fc11cb945975db1a38eb94058_ext.sol,MMOToken.withdraw,155,159,"myAddress(address) := this(address),TMP_48(uint256) = SOLIDITY_CALL balance(address)(myAddress),etherBalance(uint256) := TMP_48(uint256),Transfer dest:owner value:etherBalance,MODIFIER_CALL, MMOToken.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
myAddress = this

IRs:
myAddress(address) := this(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
etherBalance = myAddress.balance

IRs:
TMP_48(uint256) = SOLIDITY_CALL balance(address)(myAddress)
etherBalance(uint256) := TMP_48(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(etherBalance)

IRs:
Transfer dest:owner value:etherBalance""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MMOToken.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();myAddress = this;etherBalance = myAddress.balance;owner.transfer(etherBalance)
./0x219014ef0fdf1b9b0d4e9e453e021573b7082bed_ext.sol,ItemToken.withdrawAmount,122,124,"Transfer dest:owner value:_amount,MODIFIER_CALL, ItemToken.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(_amount)

IRs:
Transfer dest:owner value:_amount""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ItemToken.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();owner.transfer(_amount)
./0xf099c6ecb16575393b3ba6ac57b4ead943353a52_ext.sol,BuddhaTower.takeDevCut,416,419,"Transfer dest:addr4 value:devCut,devCut(uint256) := 0(uint256),MODIFIER_CALL, BuddhaTower.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
addr4.transfer(devCut)

IRs:
Transfer dest:addr4 value:devCut""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
devCut = 0

IRs:
devCut(uint256) := 0(uint256)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, BuddhaTower.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();addr4.transfer(devCut);devCut = 0
./0x288d045357ac63438278af0b5b84d677713e7c30_ext.sol,MerchantWallet.doWithdrawal,693,696,"TMP_234(bool) = beneficiary != 0,TMP_235(None) = SOLIDITY_CALL require(bool)(TMP_234),Transfer dest:beneficiary value:amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != 0x0)

IRs:
TMP_234(bool) = beneficiary != 0
TMP_235(None) = SOLIDITY_CALL require(bool)(TMP_234)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
beneficiary.transfer(amount)

IRs:
Transfer dest:beneficiary value:amount""];
}
",0,0,1,0,require(bool)(beneficiary != 0x0);beneficiary.transfer(amount)
./0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44_ext.sol,SanityPools.buyTokens,76,89,"REF_6(SanityPools.Pool) -> pools[_index],pool(SanityPools.Pool) := REF_6(SanityPools.Pool),REF_7(uint256) -> pool.pool_eth_value,REF_8(uint256) -> pool.min_amount,TMP_14(bool) = REF_7 >= REF_8,TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14),REF_9(uint256) -> pool.pool_eth_value,REF_10(uint256) -> pool.max_amount,TMP_16(bool) = REF_9 <= REF_10,REF_11(uint256) -> pool.max_amount,TMP_17(bool) = REF_11 == 0,TMP_18(bool) = TMP_16 || TMP_17,TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18),REF_12(bool) -> pool.bought_tokens,TMP_20 = UnaryType.BANG REF_12 ,TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20),REF_13(address) -> pool.sale,TMP_22(bool) = REF_13 != 0,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),REF_14(uint256) -> pool.buy_block,REF_14(uint256) (->pool) := block.number(uint256),REF_15(bool) -> pool.bought_tokens,REF_15(bool) (->pool) := True(bool),REF_16(address) -> pool.sale,REF_18(uint256) -> pool.pool_eth_value,Transfer dest:REF_16 value:REF_18,MODIFIER_CALL, Controller.onlyOwner()(),MODIFIER_CALL, SanityPools.validIndex(uint256)(_index)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
pool = pools[_index]

IRs:
REF_6(SanityPools.Pool) -> pools[_index]
pool(SanityPools.Pool) := REF_6(SanityPools.Pool)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(pool.pool_eth_value >= pool.min_amount)

IRs:
REF_7(uint256) -> pool.pool_eth_value
REF_8(uint256) -> pool.min_amount
TMP_14(bool) = REF_7 >= REF_8
TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(pool.pool_eth_value <= pool.max_amount || pool.max_amount == 0)

IRs:
REF_9(uint256) -> pool.pool_eth_value
REF_10(uint256) -> pool.max_amount
TMP_16(bool) = REF_9 <= REF_10
REF_11(uint256) -> pool.max_amount
TMP_17(bool) = REF_11 == 0
TMP_18(bool) = TMP_16 || TMP_17
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(! pool.bought_tokens)

IRs:
REF_12(bool) -> pool.bought_tokens
TMP_20 = UnaryType.BANG REF_12 
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(pool.sale != 0x0)

IRs:
REF_13(address) -> pool.sale
TMP_22(bool) = REF_13 != 0
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
pool.buy_block = block.number

IRs:
REF_14(uint256) -> pool.buy_block
REF_14(uint256) (->pool) := block.number(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
pool.bought_tokens = true

IRs:
REF_15(bool) -> pool.bought_tokens
REF_15(bool) (->pool) := True(bool)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
pool.sale.transfer(pool.pool_eth_value)

IRs:
REF_16(address) -> pool.sale
REF_18(uint256) -> pool.pool_eth_value
Transfer dest:REF_16 value:REF_18""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Controller.onlyOwner()()""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
validIndex(_index)

IRs:
MODIFIER_CALL, SanityPools.validIndex(uint256)(_index)""];
10->1;
}
",0,0,1,0,onlyOwner();pool = pools[_index];require(bool)(pool.pool_eth_value >= pool.min_amount);require(bool)(pool.pool_eth_value <= pool.max_amount || pool.max_amount == 0);require(bool)(! pool.bought_tokens);require(bool)(pool.sale != 0x0);pool.buy_block = block.number;pool.bought_tokens = true;pool.sale.transfer(pool.pool_eth_value);validIndex(_index)
./0x32fcdefa047d8edeea0c21a50179b18181074c60_ext.sol,CryptoSanguoToken.withdrawAmount,124,126,"Transfer dest:owner value:_amount,MODIFIER_CALL, CryptoSanguoToken.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(_amount)

IRs:
Transfer dest:owner value:_amount""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, CryptoSanguoToken.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();owner.transfer(_amount)
./0x8cd06b5c327b0e277a7f6b08b9acea4d8ee36180_ext.sol,JungleScratch.withdraw,171,173,"Transfer dest:msg.sender value:withdrawEther_,MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(withdrawEther_)

IRs:
Transfer dest:msg.sender value:withdrawEther_""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();msg.sender.transfer(withdrawEther_)
./0x86c6a7ee4ec24d25456580d81f7e8f486186ec91_ext.sol,Coin.refund,55,60,"REF_0(uint256) -> balances[_client],REF_0(-> balances) = REF_0 - _tokens,TMP_1 = CONVERT this to address,REF_1(uint256) -> balances[TMP_1],REF_1(-> balances) = REF_1 + _tokens,Transfer dest:_client value:_amount,Emit Refund(_client,_amount,_tokens),MODIFIER_CALL, Coin.workingFlag()(),MODIFIER_CALL, Coin.ownerAndCoin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
balances[_client] -= _tokens

IRs:
REF_0(uint256) -> balances[_client]
REF_0(-> balances) = REF_0 - _tokens""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[address(this)] += _tokens

IRs:
TMP_1 = CONVERT this to address
REF_1(uint256) -> balances[TMP_1]
REF_1(-> balances) = REF_1 + _tokens""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_client.transfer(_amount)

IRs:
Transfer dest:_client value:_amount""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Refund(_client,_amount,_tokens)

IRs:
Emit Refund(_client,_amount,_tokens)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
workingFlag()

IRs:
MODIFIER_CALL, Coin.workingFlag()()""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
ownerAndCoin()

IRs:
MODIFIER_CALL, Coin.ownerAndCoin()()""];
6->1;
}
",0,1,1,0,"workingFlag();balances[_client] -= _tokens;balances[address(this)] += _tokens;_client.transfer(_amount);Refund(_client,_amount,_tokens);ownerAndCoin()"
./0x92949bd74c4d21852a3d9f7dfb841fad2833302b_ext.sol,basisneuro.fallback,197,203,"REF_7(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:owner value:REF_7,Emit Message(Thanks for your donation.)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(this.balance)

IRs:
REF_7(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:owner value:REF_7""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Message(Thanks for your donation.)

IRs:
Emit Message(Thanks for your donation.)""];
}
",0,0,1,0,owner.transfer(this.balance);Message(Thanks for your donation.)
./0x36fc9fff1bf5b08ed2c472d6370dc62fa3016ffa_ext.sol,quizgame.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 400000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 400000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 400000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 400000000000000000;msg.sender.transfer(this.balance);
./0x70052a651eec65f98925e845820a0aa5749b033d_ext.sol,ATxAssetProxy.fallback,298,300,"TMP_49(ATxAssetInterface) = INTERNAL_CALL, ATxAssetProxy._getAsset()(),HIGH_LEVEL_CALL, dest:TMP_49(ATxAssetInterface), function:__process, arguments:['msg.data', 'msg.sender'] value:msg.value ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_getAsset().__process.value(msg.value)(msg.data,msg.sender)

IRs:
TMP_49(ATxAssetInterface) = INTERNAL_CALL, ATxAssetProxy._getAsset()()
HIGH_LEVEL_CALL, dest:TMP_49(ATxAssetInterface), function:__process, arguments:['msg.data', 'msg.sender'] value:msg.value ""];
}
",0,0,1,0,"_getAsset().__process.value(msg.value)(msg.data,msg.sender)"
./0xef02c45c5913629dd12e7a9446455049775eec32_ext.sol,RuletkaIo._payout,198,205,"TMP_74 = CONVERT 0 to address,TMP_75(bool) = _to == TMP_74,CONDITION TMP_75,TMP_76 = CONVERT this to address,TMP_77(uint256) = SOLIDITY_CALL balance(address)(TMP_76),TMP_78(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_77', '2'] ,Transfer dest:CTO value:TMP_78,TMP_80 = CONVERT this to address,TMP_81(uint256) = SOLIDITY_CALL balance(address)(TMP_80),Transfer dest:CEO value:TMP_81,TMP_83 = CONVERT this to address,TMP_84(uint256) = SOLIDITY_CALL balance(address)(TMP_83),Transfer dest:_to value:TMP_84","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_to == address(0)

IRs:
TMP_74 = CONVERT 0 to address
TMP_75(bool) = _to == TMP_74
CONDITION TMP_75""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
CTO.transfer(SafeMath.div(address(this).balance,2))

IRs:
TMP_76 = CONVERT this to address
TMP_77(uint256) = SOLIDITY_CALL balance(address)(TMP_76)
TMP_78(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_77', '2'] 
Transfer dest:CTO value:TMP_78""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
CEO.transfer(address(this).balance)

IRs:
TMP_80 = CONVERT this to address
TMP_81(uint256) = SOLIDITY_CALL balance(address)(TMP_80)
Transfer dest:CEO value:TMP_81""];
3->5;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
_to.transfer(address(this).balance)

IRs:
TMP_83 = CONVERT this to address
TMP_84(uint256) = SOLIDITY_CALL balance(address)(TMP_83)
Transfer dest:_to value:TMP_84""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,0,1,0,"_to == address(0);CTO.transfer(SafeMath.div(address(this).balance,2));_to.transfer(address(this).balance);CEO.transfer(address(this).balance);"
./0xa5dc0165b798779ac80acc84c4da4ee77b79843f_ext.sol,EosPizzaSliceDonationraiser.finalize,811,835,"TMP_278(bool) = totalSupply >= hardCap,TMP_279(bool) = now >= endDate,TMP_280(bool) = TMP_278 || TMP_279,TMP_281(None) = SOLIDITY_CALL require(bool)(TMP_280),TMP_282 = UnaryType.BANG finalized ,TMP_283(None) = SOLIDITY_CALL require(bool)(TMP_282),contractAddress(address) := this(address),TMP_284(uint256) = SOLIDITY_CALL balance(address)(contractAddress),Emit Finalized(beneficiary,TMP_284,totalSupply),TMP_286(uint256) = SOLIDITY_CALL balance(address)(contractAddress),Transfer dest:beneficiary value:TMP_286,TMP_288(uint256) = HIGH_LEVEL_CALL, dest:eosPizzaSliceSafe(EosPizzaSliceSafe), function:totalTokensLocked, arguments:[]  ,totalTokensLocked(uint256) := TMP_288(uint256),TMP_289 = CONVERT eosPizzaSliceSafe to address,REF_145(uint256) -> balances[TMP_289],TMP_290 = CONVERT eosPizzaSliceSafe to address,REF_146(uint256) -> balances[TMP_290],TMP_291(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['REF_146', 'totalTokensLocked'] ,REF_145(uint256) (->balances) := TMP_291(uint256),TMP_292(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['totalSupply', 'totalTokensLocked'] ,totalSupply(uint256) := TMP_292(uint256),REF_149(uint256) -> balances[owner],REF_150(uint256) -> balances[owner],TMP_293(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['REF_150', 'TOKENS_BOUNTY_PROGRAM'] ,REF_149(uint256) (->balances) := TMP_293(uint256),TMP_294(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['totalSupply', 'TOKENS_BOUNTY_PROGRAM'] ,totalSupply(uint256) := TMP_294(uint256),finalized(bool) := True(bool),INTERNAL_CALL, Freezable.unfreeze()(),MODIFIER_CALL, HasOwner.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->13;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((totalSupply >= hardCap) || (now >= endDate))

IRs:
TMP_278(bool) = totalSupply >= hardCap
TMP_279(bool) = now >= endDate
TMP_280(bool) = TMP_278 || TMP_279
TMP_281(None) = SOLIDITY_CALL require(bool)(TMP_280)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! finalized)

IRs:
TMP_282 = UnaryType.BANG finalized 
TMP_283(None) = SOLIDITY_CALL require(bool)(TMP_282)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
contractAddress = this

IRs:
contractAddress(address) := this(address)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Finalized(beneficiary,contractAddress.balance,totalSupply)

IRs:
TMP_284(uint256) = SOLIDITY_CALL balance(address)(contractAddress)
Emit Finalized(beneficiary,TMP_284,totalSupply)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
beneficiary.transfer(contractAddress.balance)

IRs:
TMP_286(uint256) = SOLIDITY_CALL balance(address)(contractAddress)
Transfer dest:beneficiary value:TMP_286""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
totalTokensLocked = eosPizzaSliceSafe.totalTokensLocked()

IRs:
TMP_288(uint256) = HIGH_LEVEL_CALL, dest:eosPizzaSliceSafe(EosPizzaSliceSafe), function:totalTokensLocked, arguments:[]  
totalTokensLocked(uint256) := TMP_288(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balances[address(eosPizzaSliceSafe)] = balances[address(eosPizzaSliceSafe)].plus(totalTokensLocked)

IRs:
TMP_289 = CONVERT eosPizzaSliceSafe to address
REF_145(uint256) -> balances[TMP_289]
TMP_290 = CONVERT eosPizzaSliceSafe to address
REF_146(uint256) -> balances[TMP_290]
TMP_291(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['REF_146', 'totalTokensLocked'] 
REF_145(uint256) (->balances) := TMP_291(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
totalSupply = totalSupply.plus(totalTokensLocked)

IRs:
TMP_292(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['totalSupply', 'totalTokensLocked'] 
totalSupply(uint256) := TMP_292(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
balances[owner] = balances[owner].plus(TOKENS_BOUNTY_PROGRAM)

IRs:
REF_149(uint256) -> balances[owner]
REF_150(uint256) -> balances[owner]
TMP_293(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['REF_150', 'TOKENS_BOUNTY_PROGRAM'] 
REF_149(uint256) (->balances) := TMP_293(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
totalSupply = totalSupply.plus(TOKENS_BOUNTY_PROGRAM)

IRs:
TMP_294(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.plus(uint256,uint256), arguments:['totalSupply', 'TOKENS_BOUNTY_PROGRAM'] 
totalSupply(uint256) := TMP_294(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
finalized = true

IRs:
finalized(bool) := True(bool)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
unfreeze()

IRs:
INTERNAL_CALL, Freezable.unfreeze()()""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, HasOwner.onlyOwner()()""];
13->1;
}
",1,0,1,0,"onlyOwner();require(bool)((totalSupply >= hardCap) || (now >= endDate));require(bool)(! finalized);contractAddress = this;Finalized(beneficiary,contractAddress.balance,totalSupply);beneficiary.transfer(contractAddress.balance);totalTokensLocked = eosPizzaSliceSafe.totalTokensLocked();balances[address(eosPizzaSliceSafe)] = balances[address(eosPizzaSliceSafe)].plus(totalTokensLocked);totalSupply = totalSupply.plus(totalTokensLocked);balances[owner] = balances[owner].plus(TOKENS_BOUNTY_PROGRAM);totalSupply = totalSupply.plus(TOKENS_BOUNTY_PROGRAM);finalized = true;unfreeze()"
./0xc55e5e72911fab07ef912c58e6dc168d73348820_ext.sol,EtherCup.withdrawAll,189,191,"TMP_56 = CONVERT this to address,TMP_57(uint256) = SOLIDITY_CALL balance(address)(TMP_56),Transfer dest:ceoAddress value:TMP_57,MODIFIER_CALL, EtherCup.onlyCEO()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ceoAddress.transfer(address(this).balance)

IRs:
TMP_56 = CONVERT this to address
TMP_57(uint256) = SOLIDITY_CALL balance(address)(TMP_56)
Transfer dest:ceoAddress value:TMP_57""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyCEO()

IRs:
MODIFIER_CALL, EtherCup.onlyCEO()()""];
2->1;
}
",0,0,1,0,onlyCEO();ceoAddress.transfer(address(this).balance)
./0x58a2263f77e1b23a74a3d99b9d01506da308800b_ext.sol,NetworkTokenPayment.withdrawAll,317,321,"myAddress(address) := this(address),TMP_138(uint256) = SOLIDITY_CALL balance(address)(myAddress),etherBalance(uint256) := TMP_138(uint256),Transfer dest:owner value:etherBalance,MODIFIER_CALL, NetworkTokenPayment.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
myAddress = this

IRs:
myAddress(address) := this(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
etherBalance = myAddress.balance

IRs:
TMP_138(uint256) = SOLIDITY_CALL balance(address)(myAddress)
etherBalance(uint256) := TMP_138(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(etherBalance)

IRs:
Transfer dest:owner value:etherBalance""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, NetworkTokenPayment.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();myAddress = this;etherBalance = myAddress.balance;owner.transfer(etherBalance)
./0x183891e9cfaee0c9e2dbcdfefe1505626c696951_ext.sol,Withdrawal.withdrawAll,443,448,"TMP_87 = CONVERT this to address,TMP_88(uint256) = SOLIDITY_CALL balance(address)(TMP_87),weiAmount(uint256) := TMP_88(uint256),Transfer dest:withdrawWallet value:weiAmount,Emit WithdrawLog(weiAmount),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
weiAmount = address(this).balance

IRs:
TMP_87 = CONVERT this to address
TMP_88(uint256) = SOLIDITY_CALL balance(address)(TMP_87)
weiAmount(uint256) := TMP_88(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
withdrawWallet.transfer(weiAmount)

IRs:
Transfer dest:withdrawWallet value:weiAmount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
WithdrawLog(weiAmount)

IRs:
Emit WithdrawLog(weiAmount)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();weiAmount = address(this).balance;withdrawWallet.transfer(weiAmount);WithdrawLog(weiAmount)
./0xedde8f9b753ae899794f09756e11999cf54c82c5_ext.sol,EncryptedToken.fallback,156,160,"TMP_85 = SEND dest:owner value:msg.value,TMP_86(uint256) = msg.value * buyPrice,amount(uint256) := TMP_86(uint256),INTERNAL_CALL, EncryptedToken._transfer(address,address,uint256)(owner,msg.sender,amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.send(msg.value)

IRs:
TMP_85 = SEND dest:owner value:msg.value""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = msg.value * buyPrice

IRs:
TMP_86(uint256) = msg.value * buyPrice
amount(uint256) := TMP_86(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_transfer(owner,msg.sender,amount)

IRs:
INTERNAL_CALL, EncryptedToken._transfer(address,address,uint256)(owner,msg.sender,amount)""];
}
",0,0,1,0,"owner.send(msg.value);amount = msg.value * buyPrice;_transfer(owner,msg.sender,amount)"
./0x1b5c8afd9739c3d2af5a4859dec0482a6df7667d_ext.sol,HomesCoin.collect,174,178,"TMP_82(bool) = msg.sender == owner,TMP_83(None) = SOLIDITY_CALL require(bool)(TMP_82),TMP_84 = CONVERT this to address,TMP_85(uint256) = SOLIDITY_CALL balance(address)(TMP_84),TMP_86(uint256) = amount + 1000000000000000000,TMP_87(bool) = TMP_85 >= TMP_86,TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87),Transfer dest:msg.sender value:amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_82(bool) = msg.sender == owner
TMP_83(None) = SOLIDITY_CALL require(bool)(TMP_82)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(address(this).balance >= amount + 1000000000000000000)

IRs:
TMP_84 = CONVERT this to address
TMP_85(uint256) = SOLIDITY_CALL balance(address)(TMP_84)
TMP_86(uint256) = amount + 1000000000000000000
TMP_87(bool) = TMP_85 >= TMP_86
TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
}
",0,0,1,0,require(bool)(msg.sender == owner);require(bool)(address(this).balance >= amount + 1000000000000000000);msg.sender.transfer(amount)
./0x74028170d74751878228cda221fd0ac42a830921_ext.sol,EncryptedToken.selfdestructs,162,164,"TMP_88(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_88(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0x184c8624d79f41eff9b3a702737ee86eeef80e67_ext.sol,EthMonsters.withdraw,146,151,"REF_68(uint256) -> userBalance[msg.sender],TMP_55(bool) = REF_68 > 0,TMP_56(None) = SOLIDITY_CALL require(bool)(TMP_55),REF_69(uint256) -> userBalance[msg.sender],amount(uint256) := REF_69(uint256),REF_70(uint256) -> userBalance[msg.sender],REF_70(uint256) (->userBalance) := 0(uint256),Transfer dest:msg.sender value:amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(userBalance[msg.sender] > 0)

IRs:
REF_68(uint256) -> userBalance[msg.sender]
TMP_55(bool) = REF_68 > 0
TMP_56(None) = SOLIDITY_CALL require(bool)(TMP_55)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = userBalance[msg.sender]

IRs:
REF_69(uint256) -> userBalance[msg.sender]
amount(uint256) := REF_69(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
userBalance[msg.sender] = 0

IRs:
REF_70(uint256) -> userBalance[msg.sender]
REF_70(uint256) (->userBalance) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
}
",0,0,1,0,require(bool)(userBalance[msg.sender] > 0);amount = userBalance[msg.sender];userBalance[msg.sender] = 0;msg.sender.transfer(amount)
./0x1f58af89d12d4a60647f99a9fc71dd0367b56df4_ext.sol,BurnupGameFinance._sendFunds,836,845,"TMP_493 = SEND dest:beneficiary value:amount,TMP_494 = UnaryType.BANG TMP_493 ,CONDITION TMP_494,INTERNAL_CALL, PullPayment.asyncSend(address,uint256)(beneficiary,amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
! beneficiary.send(amount)

IRs:
TMP_493 = SEND dest:beneficiary value:amount
TMP_494 = UnaryType.BANG TMP_493 
CONDITION TMP_494""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
asyncSend(beneficiary,amount)

IRs:
INTERNAL_CALL, PullPayment.asyncSend(address,uint256)(beneficiary,amount)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,0,1,0,"! beneficiary.send(amount);asyncSend(beneficiary,amount);"
./0xd0d932c9f78583d297e487a7965223d0fe1008c8_ext.sol,CSC.withdraw,71,74,"TMP_19(bool) = msg.sender == owner,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),TMP_21 = CONVERT this to address,TMP_22(uint256) = SOLIDITY_CALL balance(address)(TMP_21),Transfer dest:msg.sender value:TMP_22","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_19(bool) = msg.sender == owner
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_21 = CONVERT this to address
TMP_22(uint256) = SOLIDITY_CALL balance(address)(TMP_21)
Transfer dest:msg.sender value:TMP_22""];
}
",0,0,1,0,require(bool)(msg.sender == owner);msg.sender.transfer(address(this).balance)
./0x4176f0f2b7c95486a5ae06e3d1b29201a42e7630_ext.sol,Bounty0xEscrow.distributeTokenToAddress,266,279,"TMP_76 = CONVERT 0 to address,TMP_77(bool) = _hunter != TMP_76,TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77),REF_22(mapping(address => uint256)) -> tokens[_token],REF_23(uint256) -> REF_22[_host],TMP_79(bool) = REF_23 >= _amount,TMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79),REF_24(mapping(address => uint256)) -> tokens[_token],REF_25(uint256) -> REF_24[_host],REF_27(mapping(address => uint256)) -> tokens[_token],REF_28(uint256) -> REF_27[_host],TMP_81(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_amount'] ,REF_25(uint256) (->tokens) := TMP_81(uint256),TMP_82 = CONVERT 0 to address,TMP_83(bool) = _token == TMP_82,CONDITION TMP_83,TMP_84 = SEND dest:_hunter value:_amount,TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84),TMP_86 = CONVERT _token to ERC20,TMP_87(bool) = HIGH_LEVEL_CALL, dest:TMP_86(ERC20), function:transfer, arguments:['_hunter', '_amount']  ,TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87),Emit Distribution(_token,_host,_hunter,_amount),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_hunter != address(0))

IRs:
TMP_76 = CONVERT 0 to address
TMP_77(bool) = _hunter != TMP_76
TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(tokens[_token][_host] >= _amount)

IRs:
REF_22(mapping(address => uint256)) -> tokens[_token]
REF_23(uint256) -> REF_22[_host]
TMP_79(bool) = REF_23 >= _amount
TMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tokens[_token][_host] = SafeMath.sub(tokens[_token][_host],_amount)

IRs:
REF_24(mapping(address => uint256)) -> tokens[_token]
REF_25(uint256) -> REF_24[_host]
REF_27(mapping(address => uint256)) -> tokens[_token]
REF_28(uint256) -> REF_27[_host]
TMP_81(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_amount'] 
REF_25(uint256) (->tokens) := TMP_81(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
_token == address(0)

IRs:
TMP_82 = CONVERT 0 to address
TMP_83(bool) = _token == TMP_82
CONDITION TMP_83""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(_hunter.send(_amount))

IRs:
TMP_84 = SEND dest:_hunter value:_amount
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)""];
5->7;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(ERC20(_token).transfer(_hunter,_amount))

IRs:
TMP_86 = CONVERT _token to ERC20
TMP_87(bool) = HIGH_LEVEL_CALL, dest:TMP_86(ERC20), function:transfer, arguments:['_hunter', '_amount']  
TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Distribution(_token,_host,_hunter,_amount)

IRs:
Emit Distribution(_token,_host,_hunter,_amount)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
9->1;
}
",1,0,1,0,"onlyOwner();require(bool)(_hunter != address(0));require(bool)(tokens[_token][_host] >= _amount);tokens[_token][_host] = SafeMath.sub(tokens[_token][_host],_amount);_token == address(0);require(bool)(_hunter.send(_amount));require(bool)(ERC20(_token).transfer(_hunter,_amount));;Distribution(_token,_host,_hunter,_amount)"
./0x50a667b73223bc612bcc43200120b5c46ee6b4e9_ext.sol,RC.refundEther,345,349,"REF_66(uint256) -> etherUser[to],Transfer dest:to value:REF_66,REF_67(uint256) -> etherUser[to],REF_67(uint256) (->etherUser) := 0(uint256),REF_68(uint256) -> pendingTokenUser[to],REF_68(uint256) (->pendingTokenUser) := 0(uint256),MODIFIER_CALL, RC.onlyTokenSaleOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
to.transfer(etherUser[to])

IRs:
REF_66(uint256) -> etherUser[to]
Transfer dest:to value:REF_66""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
etherUser[to] = 0

IRs:
REF_67(uint256) -> etherUser[to]
REF_67(uint256) (->etherUser) := 0(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
pendingTokenUser[to] = 0

IRs:
REF_68(uint256) -> pendingTokenUser[to]
REF_68(uint256) (->pendingTokenUser) := 0(uint256)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyTokenSaleOwner()

IRs:
MODIFIER_CALL, RC.onlyTokenSaleOwner()()""];
4->1;
}
",0,0,1,0,onlyTokenSaleOwner();to.transfer(etherUser[to]);etherUser[to] = 0;pendingTokenUser[to] = 0
./0xaa3fbfaf03cd50e6a44d27d10eb14333d1c02e52_ext.sol,ETH_GAME.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0xf122d58b7a4083f103b7336ab05b78d7c6a02a37_ext.sol,PresalePool.withdraw,172,183,"REF_10(PresalePool.Contributor) -> contributorMap[msg.sender],c(PresalePool.Contributor) := REF_10(PresalePool.Contributor),REF_11(uint256) -> c.balance,TMP_49(bool) = REF_11 > 0,TMP_50(None) = SOLIDITY_CALL require(bool)(TMP_49),TMP_51(bool) = contractStage < 3,CONDITION TMP_51,REF_12(uint256) -> c.balance,amountToTransfer(uint256) := REF_12(uint256),REF_13(uint256) -> c.balance,REF_13(uint256) (->c) := 0(uint256),Transfer dest:msg.sender value:amountToTransfer,Emit ContributorBalanceChanged(msg.sender,0),INTERNAL_CALL, PresalePool._withdraw(address,address)(msg.sender,tokenAddr)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
c = contributorMap[msg.sender]

IRs:
REF_10(PresalePool.Contributor) -> contributorMap[msg.sender]
c(PresalePool.Contributor) := REF_10(PresalePool.Contributor)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(c.balance > 0)

IRs:
REF_11(uint256) -> c.balance
TMP_49(bool) = REF_11 > 0
TMP_50(None) = SOLIDITY_CALL require(bool)(TMP_49)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
contractStage < 3

IRs:
TMP_51(bool) = contractStage < 3
CONDITION TMP_51""];
3->4[label=""True""];
3->8[label=""False""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
amountToTransfer = c.balance

IRs:
REF_12(uint256) -> c.balance
amountToTransfer(uint256) := REF_12(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
c.balance = 0

IRs:
REF_13(uint256) -> c.balance
REF_13(uint256) (->c) := 0(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
msg.sender.transfer(amountToTransfer)

IRs:
Transfer dest:msg.sender value:amountToTransfer""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
ContributorBalanceChanged(msg.sender,0)

IRs:
Emit ContributorBalanceChanged(msg.sender,0)""];
7->9;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
_withdraw(msg.sender,tokenAddr)

IRs:
INTERNAL_CALL, PresalePool._withdraw(address,address)(msg.sender,tokenAddr)""];
8->9;
9[label=""Node Type: END_IF 9
""];
}
",0,0,1,0,"c = contributorMap[msg.sender];require(bool)(c.balance > 0);contractStage < 3;amountToTransfer = c.balance;_withdraw(msg.sender,tokenAddr);c.balance = 0;msg.sender.transfer(amountToTransfer);ContributorBalanceChanged(msg.sender,0);"
./0xeef93ec835c7921038d55ee096671a94e961709b_ext.sol,RefundVault.close,632,637,"REF_251(RefundVault.State) -> State.Active,TMP_427(bool) = state == REF_251,TMP_428(None) = SOLIDITY_CALL require(bool)(TMP_427),REF_252(RefundVault.State) -> State.Closed,state(RefundVault.State) := REF_252(RefundVault.State),Emit Closed(),REF_254(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:wallet value:REF_254,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_251(RefundVault.State) -> State.Active
TMP_427(bool) = state == REF_251
TMP_428(None) = SOLIDITY_CALL require(bool)(TMP_427)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
state = State.Closed

IRs:
REF_252(RefundVault.State) -> State.Closed
state(RefundVault.State) := REF_252(RefundVault.State)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Closed()

IRs:
Emit Closed()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
wallet.transfer(this.balance)

IRs:
REF_254(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:wallet value:REF_254""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();require(bool)(state == State.Active);state = State.Closed;Closed();wallet.transfer(this.balance)
./0xd1ceeeef70c61da45800bd81be3352160ad72f2a_ext.sol,Dice2Win.kill,112,115,"TMP_5(bool) = lockedInBets == 0,TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5),TMP_7(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Dice2Win.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(lockedInBets == 0)

IRs:
TMP_5(bool) = lockedInBets == 0
TMP_6(None) = SOLIDITY_CALL require(bool)(TMP_5)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_7(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Dice2Win.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();require(bool)(lockedInBets == 0);selfdestruct(address)(owner)
./0x1eb0d4794d4067ed004c9d55ff6eb50620b27c58_ext.sol,ProspectorsCrowdsale.refund,280,289,"TMP_194(bool) = total_raised >= goal,TMP_195(bool) = closed == False,TMP_196(bool) = TMP_194 || TMP_195,CONDITION TMP_196,TMP_197(None) = SOLIDITY_CALL revert()(),REF_5(uint256) -> funded[msg.sender],amount(uint256) := REF_5(uint256),TMP_198(bool) = amount > 0,CONDITION TMP_198,REF_6(uint256) -> funded[msg.sender],REF_6(uint256) (->funded) := 0(uint256),Transfer dest:msg.sender value:amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
total_raised >= goal || closed == false

IRs:
TMP_194(bool) = total_raised >= goal
TMP_195(bool) = closed == False
TMP_196(bool) = TMP_194 || TMP_195
CONDITION TMP_196""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_197(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
amount = funded[msg.sender]

IRs:
REF_5(uint256) -> funded[msg.sender]
amount(uint256) := REF_5(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
amount > 0

IRs:
TMP_198(bool) = amount > 0
CONDITION TMP_198""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
funded[msg.sender] = 0

IRs:
REF_6(uint256) -> funded[msg.sender]
REF_6(uint256) (->funded) := 0(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
7->8;
8[label=""Node Type: END_IF 8
""];
}
",0,0,1,0,total_raised >= goal || closed == false;revert()();;amount = funded[msg.sender];amount > 0;funded[msg.sender] = 0;;msg.sender.transfer(amount)
./0x4b368266adb3e159affe3f6fe85b8e0f789323c2_ext.sol,TTS.getEth,94,102,"TMP_21(bool) = _price > 0,CONDITION TMP_21,TMP_22 = CONVERT this to address,TMP_23(uint256) = SOLIDITY_CALL balance(address)(TMP_22),TMP_24(bool) = TMP_23 >= _price,CONDITION TMP_24,Transfer dest:owner value:_price,TMP_26 = CONVERT this to address,TMP_27(uint256) = SOLIDITY_CALL balance(address)(TMP_26),Transfer dest:owner value:TMP_27,MODIFIER_CALL, TTS.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: IF 1

EXPRESSION:
_price > 0

IRs:
TMP_21(bool) = _price > 0
CONDITION TMP_21""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
address(this).balance >= _price

IRs:
TMP_22 = CONVERT this to address
TMP_23(uint256) = SOLIDITY_CALL balance(address)(TMP_22)
TMP_24(bool) = TMP_23 >= _price
CONDITION TMP_24""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_price)

IRs:
Transfer dest:owner value:_price""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->6;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_26 = CONVERT this to address
TMP_27(uint256) = SOLIDITY_CALL balance(address)(TMP_26)
Transfer dest:owner value:TMP_27""];
5->6;
6[label=""Node Type: END_IF 6
""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, TTS.onlyOwner()()""];
7->1;
}
",0,0,1,0,onlyOwner();_price > 0;address(this).balance >= _price;owner.transfer(address(this).balance);owner.transfer(_price);;
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.removeStaffWhitelist,2,2,"REF_26 -> LENGTH _userlist,TMP_57(bool) = REF_26 > 0,TMP_58(None) = SOLIDITY_CALL require(bool)(TMP_57),i(uint256) := 0(uint256),REF_27 -> LENGTH _userlist,TMP_59(bool) = i < REF_27,CONDITION TMP_59,REF_28(address) -> _userlist[i],baddr(address) := REF_28(address),TMP_60 = CONVERT 0 to address,TMP_61(bool) = baddr != TMP_60,CONDITION TMP_61,REF_29(bool) -> staffs[baddr],CONDITION REF_29,REF_30(bool) -> staffs[baddr],REF_30(bool) (->staffs) := False(bool),TMP_62(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, KahnDistributionCentre.onlyAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->13;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_userlist.length > 0)

IRs:
REF_26 -> LENGTH _userlist
TMP_57(bool) = REF_26 > 0
TMP_58(None) = SOLIDITY_CALL require(bool)(TMP_57)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < _userlist.length

IRs:
REF_27 -> LENGTH _userlist
TMP_59(bool) = i < REF_27
CONDITION TMP_59""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
baddr = _userlist[i]

IRs:
REF_28(address) -> _userlist[i]
baddr(address) := REF_28(address)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
baddr != address(0)

IRs:
TMP_60 = CONVERT 0 to address
TMP_61(bool) = baddr != TMP_60
CONDITION TMP_61""];
7->8[label=""True""];
7->11[label=""False""];
8[label=""Node Type: IF 8

EXPRESSION:
staffs[baddr]

IRs:
REF_29(bool) -> staffs[baddr]
CONDITION REF_29""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
staffs[baddr] = false

IRs:
REF_30(bool) -> staffs[baddr]
REF_30(bool) (->staffs) := False(bool)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_62(uint256) := i(uint256)
i(uint256) = i + 1""];
12->5;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyAdmin()()""];
13->1;
}
",0,1,1,0,onlyAdmin();require(bool)(_userlist.length > 0);i = 0;;i < _userlist.length;;baddr = _userlist[i];baddr != address(0);staffs[baddr];;staffs[baddr] = false;;i ++
./0xee1f0f9731ee93736e219598e6aa441ad36ffc61_ext.sol,ENIGMA.Try,5,12,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 3000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 3000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 3000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 3000000000000000000;msg.sender.transfer(this.balance);
./0xaab606817809841e8b1168be8779eeaf6744ef64_ext.sol,DividendToken.requestUnclaimed,641,648,"TMP_240(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['dividendEndTime', 'claimTimeout'] ,TMP_241(bool) = block.timestamp >= TMP_240,TMP_242(None) = SOLIDITY_CALL require(bool)(TMP_241),TMP_243 = CONVERT this to address,TMP_244(uint256) = SOLIDITY_CALL balance(address)(TMP_243),Transfer dest:msg.sender value:TMP_244,TMP_246 = CONVERT this to address,TMP_247(uint256) = SOLIDITY_CALL balance(address)(TMP_246),Emit Reclaimed(TMP_247,dividendEndTime,block.timestamp),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(block.timestamp >= dividendEndTime.sub(claimTimeout))

IRs:
TMP_240(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['dividendEndTime', 'claimTimeout'] 
TMP_241(bool) = block.timestamp >= TMP_240
TMP_242(None) = SOLIDITY_CALL require(bool)(TMP_241)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_243 = CONVERT this to address
TMP_244(uint256) = SOLIDITY_CALL balance(address)(TMP_243)
Transfer dest:msg.sender value:TMP_244""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Reclaimed(address(this).balance,dividendEndTime,block.timestamp)

IRs:
TMP_246 = CONVERT this to address
TMP_247(uint256) = SOLIDITY_CALL balance(address)(TMP_246)
Emit Reclaimed(TMP_247,dividendEndTime,block.timestamp)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->1;
}
",0,0,1,0,"onlyOwner();require(bool)(block.timestamp >= dividendEndTime.sub(claimTimeout));msg.sender.transfer(address(this).balance);Reclaimed(address(this).balance,dividendEndTime,block.timestamp)"
./0x70d28b8d6c19f3074a3edf3033f0defa7a4ce4df_ext.sol,AceDice.kill,201,204,"TMP_35(bool) = lockedInBets == 0,TMP_36(None) = SOLIDITY_CALL require(bool,string)(TMP_35,All bets should be processed (settled or refunded) before self-destruct.),TMP_37(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, AceDice.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(lockedInBets == 0,All bets should be processed (settled or refunded) before self-destruct.)

IRs:
TMP_35(bool) = lockedInBets == 0
TMP_36(None) = SOLIDITY_CALL require(bool,string)(TMP_35,All bets should be processed (settled or refunded) before self-destruct.)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_37(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, AceDice.onlyOwner()()""];
3->1;
}
",0,0,1,0,"onlyOwner();require(bool,string)(lockedInBets == 0,All bets should be processed (settled or refunded) before self-destruct.);selfdestruct(address)(owner)"
./0x553e3e5ba03e862c93c7834b80ca800018ba4736_ext.sol,SamsungCryptoPayments.getTokens,182,242,"tokens(uint256) := 0(uint256),bonus(uint256) := 0(uint256),countbonus(uint256) := 0(uint256),TMP_45(uint256) = 1000000000000000000 / 10,bonusCond1(uint256) := TMP_45(uint256),bonusCond2(uint256) := 1000000000000000000(uint256),bonusCond3(uint256) := 5000000000000000000(uint256),TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_47(uint256) = TMP_46 / 1000000000000000000,tokens(uint256) := TMP_47(uint256),investor(address) := msg.sender(address),TMP_48(bool) = msg.value >= requestMinimum,TMP_49(bool) = now < deadline,TMP_50(bool) = TMP_48 && TMP_49,TMP_51(bool) = now < round1,TMP_52(bool) = TMP_50 && TMP_51,TMP_53(bool) = now < round2,TMP_54(bool) = TMP_52 && TMP_53,CONDITION TMP_54,TMP_55(bool) = msg.value >= bonusCond1,TMP_56(bool) = msg.value < bonusCond2,TMP_57(bool) = TMP_55 && TMP_56,CONDITION TMP_57,TMP_58(uint256) = tokens * 1,TMP_59(uint256) = TMP_58 / 100,countbonus(uint256) := TMP_59(uint256),TMP_60(bool) = msg.value >= bonusCond2,TMP_61(bool) = msg.value < bonusCond3,TMP_62(bool) = TMP_60 && TMP_61,CONDITION TMP_62,TMP_63(uint256) = tokens * 2,TMP_64(uint256) = TMP_63 / 100,countbonus(uint256) := TMP_64(uint256),TMP_65(bool) = msg.value >= bonusCond3,CONDITION TMP_65,TMP_66(uint256) = tokens * 3,TMP_67(uint256) = TMP_66 / 100,countbonus(uint256) := TMP_67(uint256),TMP_68(bool) = msg.value >= requestMinimum,TMP_69(bool) = now < deadline,TMP_70(bool) = TMP_68 && TMP_69,TMP_71(bool) = now > round1,TMP_72(bool) = TMP_70 && TMP_71,TMP_73(bool) = now < round2,TMP_74(bool) = TMP_72 && TMP_73,CONDITION TMP_74,TMP_75(bool) = msg.value >= bonusCond2,TMP_76(bool) = msg.value < bonusCond3,TMP_77(bool) = TMP_75 && TMP_76,CONDITION TMP_77,TMP_78(uint256) = tokens * 2,TMP_79(uint256) = TMP_78 / 100,countbonus(uint256) := TMP_79(uint256),TMP_80(bool) = msg.value >= bonusCond3,CONDITION TMP_80,TMP_81(uint256) = tokens * 3,TMP_82(uint256) = TMP_81 / 100,countbonus(uint256) := TMP_82(uint256),countbonus(uint256) := 0(uint256),TMP_83(uint256) = tokens + countbonus,bonus(uint256) := TMP_83(uint256),TMP_84(bool) = tokens == 0,CONDITION TMP_84,valdrop(uint256) := 10(uint256),REF_12(bool) -> Claimed[investor],TMP_85(bool) = REF_12 == False,TMP_86(bool) = progress0drop <= target0drop,TMP_87(bool) = TMP_85 && TMP_86,CONDITION TMP_87,TMP_88(bool) = INTERNAL_CALL, SamsungCryptoPayments.distr(address,uint256)(investor,valdrop),REF_13(bool) -> Claimed[investor],REF_13(bool) (->Claimed) := True(bool),TMP_89(uint256) := progress0drop(uint256),progress0drop(uint256) = progress0drop + 1,TMP_90(bool) = msg.value >= requestMinimum,TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),TMP_92(bool) = tokens > 0,TMP_93(bool) = msg.value >= requestMinimum,TMP_94(bool) = TMP_92 && TMP_93,CONDITION TMP_94,TMP_95(bool) = now >= deadline,TMP_96(bool) = now >= round1,TMP_97(bool) = TMP_95 && TMP_96,TMP_98(bool) = now < round2,TMP_99(bool) = TMP_97 && TMP_98,CONDITION TMP_99,TMP_100(bool) = INTERNAL_CALL, SamsungCryptoPayments.distr(address,uint256)(investor,tokens),TMP_101(bool) = msg.value >= bonusCond1,CONDITION TMP_101,TMP_102(bool) = INTERNAL_CALL, SamsungCryptoPayments.distr(address,uint256)(investor,bonus),TMP_103(bool) = INTERNAL_CALL, SamsungCryptoPayments.distr(address,uint256)(investor,tokens),TMP_104(bool) = msg.value >= requestMinimum,TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104),TMP_106(bool) = totalDistributed >= totalSupply,CONDITION TMP_106,distributionFinished(bool) := True(bool),Transfer dest:multisig value:msg.value,MODIFIER_CALL, SamsungCryptoPayments.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->53;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bonusCond1 = 1000000000000000000 / 10

IRs:
TMP_45(uint256) = 1000000000000000000 / 10
bonusCond1(uint256) := TMP_45(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bonusCond2 = 1000000000000000000

IRs:
bonusCond2(uint256) := 1000000000000000000(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
bonusCond3 = 5000000000000000000

IRs:
bonusCond3(uint256) := 5000000000000000000(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_47(uint256) = TMP_46 / 1000000000000000000
tokens(uint256) := TMP_47(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now < round1 && now < round2

IRs:
TMP_48(bool) = msg.value >= requestMinimum
TMP_49(bool) = now < deadline
TMP_50(bool) = TMP_48 && TMP_49
TMP_51(bool) = now < round1
TMP_52(bool) = TMP_50 && TMP_51
TMP_53(bool) = now < round2
TMP_54(bool) = TMP_52 && TMP_53
CONDITION TMP_54""];
9->10[label=""True""];
9->19[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
msg.value >= bonusCond1 && msg.value < bonusCond2

IRs:
TMP_55(bool) = msg.value >= bonusCond1
TMP_56(bool) = msg.value < bonusCond2
TMP_57(bool) = TMP_55 && TMP_56
CONDITION TMP_57""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
countbonus = tokens * 1 / 100

IRs:
TMP_58(uint256) = tokens * 1
TMP_59(uint256) = TMP_58 / 100
countbonus(uint256) := TMP_59(uint256)""];
11->18;
12[label=""Node Type: IF 12

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_60(bool) = msg.value >= bonusCond2
TMP_61(bool) = msg.value < bonusCond3
TMP_62(bool) = TMP_60 && TMP_61
CONDITION TMP_62""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
countbonus = tokens * 2 / 100

IRs:
TMP_63(uint256) = tokens * 2
TMP_64(uint256) = TMP_63 / 100
countbonus(uint256) := TMP_64(uint256)""];
13->17;
14[label=""Node Type: IF 14

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_65(bool) = msg.value >= bonusCond3
CONDITION TMP_65""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
countbonus = tokens * 3 / 100

IRs:
TMP_66(uint256) = tokens * 3
TMP_67(uint256) = TMP_66 / 100
countbonus(uint256) := TMP_67(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->28;
19[label=""Node Type: IF 19

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now > round1 && now < round2

IRs:
TMP_68(bool) = msg.value >= requestMinimum
TMP_69(bool) = now < deadline
TMP_70(bool) = TMP_68 && TMP_69
TMP_71(bool) = now > round1
TMP_72(bool) = TMP_70 && TMP_71
TMP_73(bool) = now < round2
TMP_74(bool) = TMP_72 && TMP_73
CONDITION TMP_74""];
19->20[label=""True""];
19->26[label=""False""];
20[label=""Node Type: IF 20

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_75(bool) = msg.value >= bonusCond2
TMP_76(bool) = msg.value < bonusCond3
TMP_77(bool) = TMP_75 && TMP_76
CONDITION TMP_77""];
20->21[label=""True""];
20->22[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
countbonus = tokens * 2 / 100

IRs:
TMP_78(uint256) = tokens * 2
TMP_79(uint256) = TMP_78 / 100
countbonus(uint256) := TMP_79(uint256)""];
21->25;
22[label=""Node Type: IF 22

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_80(bool) = msg.value >= bonusCond3
CONDITION TMP_80""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
countbonus = tokens * 3 / 100

IRs:
TMP_81(uint256) = tokens * 3
TMP_82(uint256) = TMP_81 / 100
countbonus(uint256) := TMP_82(uint256)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->27;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
bonus = tokens + countbonus

IRs:
TMP_83(uint256) = tokens + countbonus
bonus(uint256) := TMP_83(uint256)""];
29->30;
30[label=""Node Type: IF 30

EXPRESSION:
tokens == 0

IRs:
TMP_84(bool) = tokens == 0
CONDITION TMP_84""];
30->31[label=""True""];
30->38[label=""False""];
31[label=""Node Type: NEW VARIABLE 31

EXPRESSION:
valdrop = 1e1

IRs:
valdrop(uint256) := 10(uint256)""];
31->32;
32[label=""Node Type: IF 32

EXPRESSION:
Claimed[investor] == false && progress0drop <= target0drop

IRs:
REF_12(bool) -> Claimed[investor]
TMP_85(bool) = REF_12 == False
TMP_86(bool) = progress0drop <= target0drop
TMP_87(bool) = TMP_85 && TMP_86
CONDITION TMP_87""];
32->33[label=""True""];
32->36[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
distr(investor,valdrop)

IRs:
TMP_88(bool) = INTERNAL_CALL, SamsungCryptoPayments.distr(address,uint256)(investor,valdrop)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
Claimed[investor] = true

IRs:
REF_13(bool) -> Claimed[investor]
REF_13(bool) (->Claimed) := True(bool)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
progress0drop ++

IRs:
TMP_89(uint256) := progress0drop(uint256)
progress0drop(uint256) = progress0drop + 1""];
35->37;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_90(bool) = msg.value >= requestMinimum
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
36->37;
37[label=""Node Type: END_IF 37
""];
37->48;
38[label=""Node Type: IF 38

EXPRESSION:
tokens > 0 && msg.value >= requestMinimum

IRs:
TMP_92(bool) = tokens > 0
TMP_93(bool) = msg.value >= requestMinimum
TMP_94(bool) = TMP_92 && TMP_93
CONDITION TMP_94""];
38->39[label=""True""];
38->46[label=""False""];
39[label=""Node Type: IF 39

EXPRESSION:
now >= deadline && now >= round1 && now < round2

IRs:
TMP_95(bool) = now >= deadline
TMP_96(bool) = now >= round1
TMP_97(bool) = TMP_95 && TMP_96
TMP_98(bool) = now < round2
TMP_99(bool) = TMP_97 && TMP_98
CONDITION TMP_99""];
39->40[label=""True""];
39->41[label=""False""];
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_100(bool) = INTERNAL_CALL, SamsungCryptoPayments.distr(address,uint256)(investor,tokens)""];
40->45;
41[label=""Node Type: IF 41

EXPRESSION:
msg.value >= bonusCond1

IRs:
TMP_101(bool) = msg.value >= bonusCond1
CONDITION TMP_101""];
41->42[label=""True""];
41->43[label=""False""];
42[label=""Node Type: EXPRESSION 42

EXPRESSION:
distr(investor,bonus)

IRs:
TMP_102(bool) = INTERNAL_CALL, SamsungCryptoPayments.distr(address,uint256)(investor,bonus)""];
42->44;
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_103(bool) = INTERNAL_CALL, SamsungCryptoPayments.distr(address,uint256)(investor,tokens)""];
43->44;
44[label=""Node Type: END_IF 44
""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->47;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_104(bool) = msg.value >= requestMinimum
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: IF 49

EXPRESSION:
totalDistributed >= totalSupply

IRs:
TMP_106(bool) = totalDistributed >= totalSupply
CONDITION TMP_106""];
49->50[label=""True""];
49->51[label=""False""];
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
multisig.transfer(msg.value)

IRs:
Transfer dest:multisig value:msg.value""];
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, SamsungCryptoPayments.canDistr()()""];
53->1;
}
",0,0,1,0,"canDistr();tokens = 0;bonus = 0;countbonus = 0;bonusCond1 = 1000000000000000000 / 10;bonusCond2 = 1000000000000000000;bonusCond3 = 5000000000000000000;tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;investor = msg.sender;msg.value >= requestMinimum && now < deadline && now < round1 && now < round2;msg.value >= bonusCond1 && msg.value < bonusCond2;msg.value >= requestMinimum && now < deadline && now > round1 && now < round2;countbonus = tokens * 1 / 100;msg.value >= bonusCond2 && msg.value < bonusCond3;;countbonus = tokens * 2 / 100;msg.value >= bonusCond3;;countbonus = tokens * 3 / 100;;;msg.value >= bonusCond2 && msg.value < bonusCond3;countbonus = 0;countbonus = tokens * 2 / 100;msg.value >= bonusCond3;;countbonus = tokens * 3 / 100;;;bonus = tokens + countbonus;tokens == 0;valdrop = 1e1;tokens > 0 && msg.value >= requestMinimum;Claimed[investor] == false && progress0drop <= target0drop;distr(investor,valdrop);require(bool)(msg.value >= requestMinimum);Claimed[investor] = true;progress0drop ++;;;now >= deadline && now >= round1 && now < round2;require(bool)(msg.value >= requestMinimum);distr(investor,tokens);msg.value >= bonusCond1;;distr(investor,bonus);distr(investor,tokens);;;totalDistributed >= totalSupply;distributionFinished = true;;multisig.transfer(msg.value)"
./0xd7faef6fd3d3e22037619a756221e38f7f2c9c62_ext.sol,Blogger.requestRefund,56,69,"REF_5(bool) -> didGive[msg.sender],TMP_8(None) = SOLIDITY_CALL require(bool)(REF_5),REF_6(Blogger.Donate) -> donationRecords[msg.sender],record(Blogger.Donate) := REF_6(Blogger.Donate),REF_7(address) -> record.funder,TMP_9(bool) = REF_7 == msg.sender,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_8(address) -> record.funder,REF_10(uint256) -> record.value,Transfer dest:REF_8 value:REF_10,REF_11(bool) -> didGive[msg.sender],REF_11(bool) (->didGive) := False(bool),TMP_12(Blogger.Donate) = new Donate(0,0),clearRecords(Blogger.Donate) := TMP_12(Blogger.Donate),REF_12(Blogger.Donate) -> donationRecords[msg.sender],REF_12(Blogger.Donate) (->donationRecords) := clearRecords(Blogger.Donate)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(didGive[msg.sender])

IRs:
REF_5(bool) -> didGive[msg.sender]
TMP_8(None) = SOLIDITY_CALL require(bool)(REF_5)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
record = donationRecords[msg.sender]

IRs:
REF_6(Blogger.Donate) -> donationRecords[msg.sender]
record(Blogger.Donate) := REF_6(Blogger.Donate)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(record.funder == msg.sender)

IRs:
REF_7(address) -> record.funder
TMP_9(bool) = REF_7 == msg.sender
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
record.funder.transfer(record.value)

IRs:
REF_8(address) -> record.funder
REF_10(uint256) -> record.value
Transfer dest:REF_8 value:REF_10""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
didGive[msg.sender] = false

IRs:
REF_11(bool) -> didGive[msg.sender]
REF_11(bool) (->didGive) := False(bool)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
clearRecords = Donate({funder:0,value:0})

IRs:
TMP_12(Blogger.Donate) = new Donate(0,0)
clearRecords(Blogger.Donate) := TMP_12(Blogger.Donate)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
donationRecords[msg.sender] = clearRecords

IRs:
REF_12(Blogger.Donate) -> donationRecords[msg.sender]
REF_12(Blogger.Donate) (->donationRecords) := clearRecords(Blogger.Donate)""];
}
",0,0,1,0,"require(bool)(didGive[msg.sender]);record = donationRecords[msg.sender];require(bool)(record.funder == msg.sender);record.funder.transfer(record.value);didGive[msg.sender] = false;clearRecords = Donate({funder:0,value:0});donationRecords[msg.sender] = clearRecords"
./0xbf008cb93c2b19c3ae0db4149bcfa465b2ea0888_ext.sol,GameTable.kill,76,80,"TMP_12(bool) = owner == msg.sender,CONDITION TMP_12,TMP_13(None) = SOLIDITY_CALL selfdestruct(address)(owner)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
owner == msg.sender

IRs:
TMP_12(bool) = owner == msg.sender
CONDITION TMP_12""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_13(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,0,1,0,owner == msg.sender;selfdestruct(address)(owner);
./0x383ece94bfdbdefe651aa2cba51e7fca2773b788_ext.sol,PreSale.forwardFunds,541,543,Transfer dest:wallet value:_value,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
wallet.transfer(_value)

IRs:
Transfer dest:wallet value:_value""];
}
",0,0,1,0,wallet.transfer(_value)
./0xedbc41b7d0330860be1dd8d682b2e868ae6da6e4_ext.sol,TokenERC20.selfdestructs,209,211,"TMP_93(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_93(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0x4c4757b23526ba13876f8ef3efe973618266e3e8_ext.sol,UZMINI_KO.StopGame,34,40,"TMP_9(bool) = msg.sender == questionSender,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_9(bool) = msg.sender == questionSender
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0xd3efa0d59dccd79a8f2011f5adf527e78f1f68b4_ext.sol,EncryptedToken.fallback,156,160,"TMP_85 = SEND dest:owner value:msg.value,TMP_86(uint256) = msg.value * buyPrice,amount(uint256) := TMP_86(uint256),INTERNAL_CALL, EncryptedToken._transfer(address,address,uint256)(owner,msg.sender,amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.send(msg.value)

IRs:
TMP_85 = SEND dest:owner value:msg.value""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = msg.value * buyPrice

IRs:
TMP_86(uint256) = msg.value * buyPrice
amount(uint256) := TMP_86(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_transfer(owner,msg.sender,amount)

IRs:
INTERNAL_CALL, EncryptedToken._transfer(address,address,uint256)(owner,msg.sender,amount)""];
}
",0,0,1,0,"owner.send(msg.value);amount = msg.value * buyPrice;_transfer(owner,msg.sender,amount)"
./0xf3391a78b4d53b2a600ad9e663ae00f6d5bb41a4_ext.sol,MillenniumNetwork.withdraw,294,297,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, MillenniumNetwork.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MillenniumNetwork.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0xee68907c93b57d57a1c4d60940ff1b310e18e467_ext.sol,ICOBuyer.withdrawEther,129,133,"REF_0(uint256) = SOLIDITY_CALL balance(address)(this),TMP_20(bool) = REF_0 != 0,TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20),REF_2(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:owner value:REF_2,REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Emit EtherWithdrawn(REF_3),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(this.balance != 0)

IRs:
REF_0(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_20(bool) = REF_0 != 0
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(this.balance)

IRs:
REF_2(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:owner value:REF_2""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
EtherWithdrawn(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Emit EtherWithdrawn(REF_3)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();require(bool)(this.balance != 0);owner.transfer(this.balance);EtherWithdrawn(this.balance)
./0x44cf74e16bd4dfcf38cec1236f5cb7e92a4f9edf_ext.sol,BC_GAME.Stop,28,30,"REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3,MODIFIER_CALL, BC_GAME.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, BC_GAME.isAdmin()()""];
2->1;
}
",0,0,1,0,isAdmin();msg.sender.transfer(this.balance)
./0x6de3cc59152e19f108378984f45e20a34c9f6338_ext.sol,EtherSpin.ownerTransferEther,1188,1190,"TMP_1470 = SEND dest:addy value:value,TMP_1471 = UnaryType.BANG TMP_1470 ,CONDITION TMP_1471,MODIFIER_CALL, EtherSpin.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: IF 1

EXPRESSION:
! addy.send(value)

IRs:
TMP_1470 = SEND dest:addy value:value
TMP_1471 = UnaryType.BANG TMP_1470 
CONDITION TMP_1471""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, EtherSpin.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();! addy.send(value);;
./0xedebe7749b91a475918750842256f23fbe8e3029_ext.sol,PlayerBook.registerNameCore,311,337,"REF_53(uint256) -> pIDxName_[_name],TMP_49(bool) = REF_53 != 0,CONDITION TMP_49,REF_54(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_55(bool) -> REF_54[_name],TMP_50(bool) = REF_55 == True,TMP_51(None) = SOLIDITY_CALL require(bool)(TMP_50),REF_56(PlayerBook.Player) -> plyr_[_pID],REF_57(bytes32) -> REF_56.name,REF_57(bytes32) (->plyr_) := _name(bytes32),REF_58(uint256) -> pIDxName_[_name],REF_58(uint256) (->pIDxName_) := _pID(uint256),REF_59(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_60(bool) -> REF_59[_name],TMP_52(bool) = REF_60 == False,CONDITION TMP_52,REF_61(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_62(bool) -> REF_61[_name],REF_62(bool) (->plyrNames_) := True(bool),REF_63(PlayerBook.Player) -> plyr_[_pID],REF_64(uint256) -> REF_63.names,TMP_53(uint256) := REF_64(uint256),REF_64(-> plyr_) = REF_64 + 1,REF_65(mapping(uint256 => bytes32)) -> plyrNameList_[_pID],REF_66(PlayerBook.Player) -> plyr_[_pID],REF_67(uint256) -> REF_66.names,REF_68(bytes32) -> REF_65[REF_67],REF_68(bytes32) (->plyrNameList_) := _name(bytes32),TMP_54 = CONVERT this to address,TMP_55(uint256) = SOLIDITY_CALL balance(address)(TMP_54),Transfer dest:admin value:TMP_55,TMP_57(bool) = _all == True,CONDITION TMP_57,i(uint256) := 1(uint256),TMP_58(bool) = i <= gID_,CONDITION TMP_58,REF_70(PlayerBookReceiverInterface) -> games_[i],HIGH_LEVEL_CALL, dest:REF_70(PlayerBookReceiverInterface), function:receivePlayerInfo, arguments:['_pID', '_addr', '_name', '_affID']  ,TMP_60(uint256) := i(uint256),i(uint256) = i + 1,REF_72(PlayerBook.Player) -> plyr_[_affID],REF_73(address) -> REF_72.addr,REF_74(PlayerBook.Player) -> plyr_[_affID],REF_75(bytes32) -> REF_74.name,Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_73,REF_75,msg.value,now)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
pIDxName_[_name] != 0

IRs:
REF_53(uint256) -> pIDxName_[_name]
TMP_49(bool) = REF_53 != 0
CONDITION TMP_49""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(plyrNames_[_pID][_name] == true)

IRs:
REF_54(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_55(bool) -> REF_54[_name]
TMP_50(bool) = REF_55 == True
TMP_51(None) = SOLIDITY_CALL require(bool)(TMP_50)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
plyr_[_pID].name = _name

IRs:
REF_56(PlayerBook.Player) -> plyr_[_pID]
REF_57(bytes32) -> REF_56.name
REF_57(bytes32) (->plyr_) := _name(bytes32)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
pIDxName_[_name] = _pID

IRs:
REF_58(uint256) -> pIDxName_[_name]
REF_58(uint256) (->pIDxName_) := _pID(uint256)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
plyrNames_[_pID][_name] == false

IRs:
REF_59(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_60(bool) -> REF_59[_name]
TMP_52(bool) = REF_60 == False
CONDITION TMP_52""];
6->7[label=""True""];
6->10[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
plyrNames_[_pID][_name] = true

IRs:
REF_61(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_62(bool) -> REF_61[_name]
REF_62(bool) (->plyrNames_) := True(bool)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
plyr_[_pID].names ++

IRs:
REF_63(PlayerBook.Player) -> plyr_[_pID]
REF_64(uint256) -> REF_63.names
TMP_53(uint256) := REF_64(uint256)
REF_64(-> plyr_) = REF_64 + 1""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
plyrNameList_[_pID][plyr_[_pID].names] = _name

IRs:
REF_65(mapping(uint256 => bytes32)) -> plyrNameList_[_pID]
REF_66(PlayerBook.Player) -> plyr_[_pID]
REF_67(uint256) -> REF_66.names
REF_68(bytes32) -> REF_65[REF_67]
REF_68(bytes32) (->plyrNameList_) := _name(bytes32)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
admin.transfer(address(this).balance)

IRs:
TMP_54 = CONVERT this to address
TMP_55(uint256) = SOLIDITY_CALL balance(address)(TMP_54)
Transfer dest:admin value:TMP_55""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
_all == true

IRs:
TMP_57(bool) = _all == True
CONDITION TMP_57""];
12->15[label=""True""];
12->19[label=""False""];
13[label=""Node Type: BEGIN_LOOP 13
""];
13->16;
14[label=""Node Type: END_LOOP 14
""];
14->19;
15[label=""Node Type: NEW VARIABLE 15

EXPRESSION:
i = 1

IRs:
i(uint256) := 1(uint256)""];
15->13;
16[label=""Node Type: IF_LOOP 16

EXPRESSION:
i <= gID_

IRs:
TMP_58(bool) = i <= gID_
CONDITION TMP_58""];
16->17[label=""True""];
16->14[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
games_[i].receivePlayerInfo(_pID,_addr,_name,_affID)

IRs:
REF_70(PlayerBookReceiverInterface) -> games_[i]
HIGH_LEVEL_CALL, dest:REF_70(PlayerBookReceiverInterface), function:receivePlayerInfo, arguments:['_pID', '_addr', '_name', '_affID']  ""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
i ++

IRs:
TMP_60(uint256) := i(uint256)
i(uint256) = i + 1""];
18->16;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,msg.value,now)

IRs:
REF_72(PlayerBook.Player) -> plyr_[_affID]
REF_73(address) -> REF_72.addr
REF_74(PlayerBook.Player) -> plyr_[_affID]
REF_75(bytes32) -> REF_74.name
Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_73,REF_75,msg.value,now)""];
}
",0,0,1,0,"pIDxName_[_name] != 0;require(bool)(plyrNames_[_pID][_name] == true);;plyr_[_pID].name = _name;pIDxName_[_name] = _pID;plyrNames_[_pID][_name] == false;plyrNames_[_pID][_name] = true;;plyr_[_pID].names ++;plyrNameList_[_pID][plyr_[_pID].names] = _name;admin.transfer(address(this).balance);_all == true;i = 1;;;i <= gID_;;games_[i].receivePlayerInfo(_pID,_addr,_name,_affID);i ++;onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,msg.value,now)"
./0x0180ec945191fda23c52b1d05eec64a2e3f68781_ext.sol,BnsPresale.sendRefund,132,142,"REF_8(uint256) -> balances[msg.sender],REF_9(uint256) = SOLIDITY_CALL balance(address)(this),TMP_20([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188BA734310>]) = REF_9 - msg.value,TMP_21(uint256) = INTERNAL_CALL, BnsPresale.min(uint256,uint256)(REF_8,TMP_20),amount_to_refund(uint256) := TMP_21(uint256),REF_10(uint256) -> balances[msg.sender],REF_10(-> balances) = REF_10 - amount_to_refund,total_refunded(uint256) = total_refunded + amount_to_refund,TMP_22(uint256) = amount_to_refund + msg.value,Transfer dest:msg.sender value:TMP_22,MODIFIER_CALL, BnsPresale.tokenHoldersOnly()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
amount_to_refund = min(balances[msg.sender],this.balance - msg.value)

IRs:
REF_8(uint256) -> balances[msg.sender]
REF_9(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_20([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188BA734310>]) = REF_9 - msg.value
TMP_21(uint256) = INTERNAL_CALL, BnsPresale.min(uint256,uint256)(REF_8,TMP_20)
amount_to_refund(uint256) := TMP_21(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] -= amount_to_refund

IRs:
REF_10(uint256) -> balances[msg.sender]
REF_10(-> balances) = REF_10 - amount_to_refund""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
total_refunded += amount_to_refund

IRs:
total_refunded(uint256) = total_refunded + amount_to_refund""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(amount_to_refund + msg.value)

IRs:
TMP_22(uint256) = amount_to_refund + msg.value
Transfer dest:msg.sender value:TMP_22""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
tokenHoldersOnly()

IRs:
MODIFIER_CALL, BnsPresale.tokenHoldersOnly()()""];
5->1;
}
",0,1,1,0,"tokenHoldersOnly();amount_to_refund = min(balances[msg.sender],this.balance - msg.value);balances[msg.sender] -= amount_to_refund;total_refunded += amount_to_refund;msg.sender.transfer(amount_to_refund + msg.value)"
./0x3395465cb04b8ebd2ae2647cf37bcb2384d71d49_ext.sol,Base._userRefund,122,141,"TMP_18(bool) = _to != 0,TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18),INTERNAL_CALL, Base.lock()(),REF_0(uint256) -> userEtherOf[msg.sender],amount(uint256) := REF_0(uint256),TMP_21(bool) = amount > 0,CONDITION TMP_21,REF_1(uint256) -> userEtherOf[msg.sender],REF_1(uint256) (->userEtherOf) := 0(uint256),Transfer dest:_to value:amount,_result(bool) := True(bool),_result(bool) := False(bool),INTERNAL_CALL, Base.unLock()(),RETURN _result","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_18(bool) = _to != 0
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
lock()

IRs:
INTERNAL_CALL, Base.lock()()""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
amount = userEtherOf[msg.sender]

IRs:
REF_0(uint256) -> userEtherOf[msg.sender]
amount(uint256) := REF_0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
amount > 0

IRs:
TMP_21(bool) = amount > 0
CONDITION TMP_21""];
4->5[label=""True""];
4->8[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
userEtherOf[msg.sender] = 0

IRs:
REF_1(uint256) -> userEtherOf[msg.sender]
REF_1(uint256) (->userEtherOf) := 0(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
_to.transfer(amount)

IRs:
Transfer dest:_to value:amount""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
_result = true

IRs:
_result(bool) := True(bool)""];
7->9;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
_result = false

IRs:
_result(bool) := False(bool)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
unLock()

IRs:
INTERNAL_CALL, Base.unLock()()""];
10->11;
11[label=""Node Type: RETURN 11

EXPRESSION:
_result

IRs:
RETURN _result""];
}
",0,0,1,0,require(bool)(_to != 0x0);lock();amount = userEtherOf[msg.sender];amount > 0;userEtherOf[msg.sender] = 0;_result = false;_to.transfer(amount);_result = true;;unLock();_result
./0x5085c5356129ee11bffb523e3166d7153ac13c75_ext.sol,Casino.withdraw,348,352,"TMP_149 = CONVERT this to address,TMP_150(uint256) = SOLIDITY_CALL balance(address)(TMP_149),TMP_151(uint256) = TMP_150 - bankFund,TMP_152(bool) = _amount <= TMP_151,TMP_153(None) = SOLIDITY_CALL require(bool,string)(TMP_152,cannot withdraw amount greater than (balance - bankFund)),Transfer dest:owner value:_amount,Emit LogDealerWithdraw(owner,_amount),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(_amount <= address(this).balance - bankFund,cannot withdraw amount greater than (balance - bankFund))

IRs:
TMP_149 = CONVERT this to address
TMP_150(uint256) = SOLIDITY_CALL balance(address)(TMP_149)
TMP_151(uint256) = TMP_150 - bankFund
TMP_152(bool) = _amount <= TMP_151
TMP_153(None) = SOLIDITY_CALL require(bool,string)(TMP_152,cannot withdraw amount greater than (balance - bankFund))""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(_amount)

IRs:
Transfer dest:owner value:_amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
LogDealerWithdraw(owner,_amount)

IRs:
Emit LogDealerWithdraw(owner,_amount)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->1;
}
",0,0,1,0,"onlyOwner();require(bool,string)(_amount <= address(this).balance - bankFund,cannot withdraw amount greater than (balance - bankFund));owner.transfer(_amount);LogDealerWithdraw(owner,_amount)"
./0x84cd9cf60bcb44f7bab8b75e6f03614c2c3b22b7_ext.sol,ESmart.withdrawPrize,195,206,"TMP_59(int256) = INTERNAL_CALL, ESmart.getCurrentStageByTime()(),TMP_60(bool) = TMP_59 >= 5,TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60),REF_21(uint256) -> maxDepositInfo.count,TMP_62(bool) = REF_21 > 0,TMP_63(None) = SOLIDITY_CALL require(bool,string)(TMP_62,The max depositor is not confirmed yet),TMP_64 = CONVERT this to address,TMP_65(uint256) = SOLIDITY_CALL balance(address)(TMP_64),balance(uint256) := TMP_65(uint256),TMP_66(bool) = jackpotAmount > balance,CONDITION TMP_66,jackpotAmount(uint256) := balance(uint256),REF_22(address) -> maxDepositInfo.depositor,TMP_67 = SEND dest:REF_22 value:jackpotAmount,TMP_68(None) = SOLIDITY_CALL selfdestruct(address)(TECH)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(getCurrentStageByTime() >= 5)

IRs:
TMP_59(int256) = INTERNAL_CALL, ESmart.getCurrentStageByTime()()
TMP_60(bool) = TMP_59 >= 5
TMP_61(None) = SOLIDITY_CALL require(bool)(TMP_60)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(maxDepositInfo.count > 0,The max depositor is not confirmed yet)

IRs:
REF_21(uint256) -> maxDepositInfo.count
TMP_62(bool) = REF_21 > 0
TMP_63(None) = SOLIDITY_CALL require(bool,string)(TMP_62,The max depositor is not confirmed yet)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
balance = address(this).balance

IRs:
TMP_64 = CONVERT this to address
TMP_65(uint256) = SOLIDITY_CALL balance(address)(TMP_64)
balance(uint256) := TMP_65(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
jackpotAmount > balance

IRs:
TMP_66(bool) = jackpotAmount > balance
CONDITION TMP_66""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
jackpotAmount = balance

IRs:
jackpotAmount(uint256) := balance(uint256)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
maxDepositInfo.depositor.send(jackpotAmount)

IRs:
REF_22(address) -> maxDepositInfo.depositor
TMP_67 = SEND dest:REF_22 value:jackpotAmount""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
selfdestruct(address)(TECH)

IRs:
TMP_68(None) = SOLIDITY_CALL selfdestruct(address)(TECH)""];
}
",0,0,1,0,"require(bool)(getCurrentStageByTime() >= 5);require(bool,string)(maxDepositInfo.count > 0,The max depositor is not confirmed yet);balance = address(this).balance;jackpotAmount > balance;jackpotAmount = balance;;maxDepositInfo.depositor.send(jackpotAmount);selfdestruct(address)(TECH)"
./0x86e4dc25259ee2191cd8ae40e1865b9f0319646c_ext.sol,CryptoRomeControl.withdrawBalance,810,812,"TMP_266 = CONVERT this to address,TMP_267(uint256) = SOLIDITY_CALL balance(address)(TMP_266),Transfer dest:ownerWallet value:TMP_267,MODIFIER_CALL, CryptoRomeControl.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
ownerWallet.transfer(address(this).balance)

IRs:
TMP_266 = CONVERT this to address
TMP_267(uint256) = SOLIDITY_CALL balance(address)(TMP_266)
Transfer dest:ownerWallet value:TMP_267""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, CryptoRomeControl.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();ownerWallet.transfer(address(this).balance)
./0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0_ext.sol,Play0x_LottoBall.withdrawAllFunds,344,351,"TMP_63 = CONVERT this to address,TMP_64(uint256) = SOLIDITY_CALL balance(address)(TMP_63),TMP_65 = SEND dest:beneficiary value:TMP_64,CONDITION TMP_65,lockedInBets(uint256) := 0(uint256),TMP_66 = CONVERT this to address,TMP_67(uint256) = SOLIDITY_CALL balance(address)(TMP_66),Emit Payment(beneficiary,TMP_67),TMP_69 = CONVERT this to address,TMP_70(uint256) = SOLIDITY_CALL balance(address)(TMP_69),Emit FailedPayment(beneficiary,TMP_70),MODIFIER_CALL, Play0x_LottoBall.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: IF 1

EXPRESSION:
beneficiary.send(address(this).balance)

IRs:
TMP_63 = CONVERT this to address
TMP_64(uint256) = SOLIDITY_CALL balance(address)(TMP_63)
TMP_65 = SEND dest:beneficiary value:TMP_64
CONDITION TMP_65""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
lockedInBets = 0

IRs:
lockedInBets(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Payment(beneficiary,address(this).balance)

IRs:
TMP_66 = CONVERT this to address
TMP_67(uint256) = SOLIDITY_CALL balance(address)(TMP_66)
Emit Payment(beneficiary,TMP_67)""];
3->5;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
FailedPayment(beneficiary,address(this).balance)

IRs:
TMP_69 = CONVERT this to address
TMP_70(uint256) = SOLIDITY_CALL balance(address)(TMP_69)
Emit FailedPayment(beneficiary,TMP_70)""];
4->5;
5[label=""Node Type: END_IF 5
""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Play0x_LottoBall.onlyOwner()()""];
6->1;
}
",0,0,1,0,"onlyOwner();beneficiary.send(address(this).balance);lockedInBets = 0;FailedPayment(beneficiary,address(this).balance);Payment(beneficiary,address(this).balance);"
./0x5bf5436b367de54860d1b0be31203349a4d5caa7_ext.sol,CryptoCarAuction.getasall,253,257,"myAddress(address) := this(address),TMP_85(uint256) = SOLIDITY_CALL balance(address)(myAddress),etherBalance(uint256) := TMP_85(uint256),Transfer dest:owner value:etherBalance,MODIFIER_CALL, CryptoCarAuction.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
myAddress = this

IRs:
myAddress(address) := this(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
etherBalance = myAddress.balance

IRs:
TMP_85(uint256) = SOLIDITY_CALL balance(address)(myAddress)
etherBalance(uint256) := TMP_85(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(etherBalance)

IRs:
Transfer dest:owner value:etherBalance""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, CryptoCarAuction.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();myAddress = this;etherBalance = myAddress.balance;owner.transfer(etherBalance)
./0x0dcfdb9f5496ed7f62dd0ac019c7daf184a66aef_ext.sol,LVRCrowdsale.kill,57,60,"TMP_14(bool) = msg.sender == creator,TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14),TMP_16(None) = SOLIDITY_CALL selfdestruct(address)(owner)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == creator)

IRs:
TMP_14(bool) = msg.sender == creator
TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_16(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
}
",0,0,1,0,require(bool)(msg.sender == creator);selfdestruct(address)(owner)
./0x7012ef33dcc79a7341ba05cf2c5699eaaa5e0d7d_ext.sol,Transaction.sendAmount,236,243,"TMP_90(bool) = seller != 0,TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),TMP_92(bool) = msg.sender != seller,TMP_93(None) = SOLIDITY_CALL require(bool)(TMP_92),Transfer dest:seller value:msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(seller != 0x0)

IRs:
TMP_90(bool) = seller != 0
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender != seller)

IRs:
TMP_92(bool) = msg.sender != seller
TMP_93(None) = SOLIDITY_CALL require(bool)(TMP_92)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
seller.transfer(msg.value)

IRs:
Transfer dest:seller value:msg.value""];
}
",0,0,1,0,require(bool)(seller != 0x0);require(bool)(msg.sender != seller);seller.transfer(msg.value)
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.getBountyAddress,2,2,"RETURN bountyaddress,MODIFIER_CALL, KahnDistributionCentre.onlyStaffs()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: RETURN 1

EXPRESSION:
bountyaddress

IRs:
RETURN bountyaddress""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyStaffs()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyStaffs()()""];
2->1;
}
",0,1,1,0,onlyStaffs();bountyaddress
./0x53fedbfc3f34bcda66f7dbbff52c907e7707bbff_ext.sol,BeezGold.getTokens,179,239,"tokens(uint256) := 0(uint256),bonus(uint256) := 0(uint256),countbonus(uint256) := 0(uint256),TMP_45(uint256) = 1000000000000000000 / 10,bonusCond1(uint256) := TMP_45(uint256),TMP_46(uint256) = 5000000000000000000 / 10,bonusCond2(uint256) := TMP_46(uint256),bonusCond3(uint256) := 1000000000000000000(uint256),TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_48(uint256) = TMP_47 / 1000000000000000000,tokens(uint256) := TMP_48(uint256),investor(address) := msg.sender(address),TMP_49(bool) = msg.value >= requestMinimum,TMP_50(bool) = now < deadline,TMP_51(bool) = TMP_49 && TMP_50,TMP_52(bool) = now < round1,TMP_53(bool) = TMP_51 && TMP_52,TMP_54(bool) = now < round2,TMP_55(bool) = TMP_53 && TMP_54,CONDITION TMP_55,TMP_56(bool) = msg.value >= bonusCond1,TMP_57(bool) = msg.value < bonusCond2,TMP_58(bool) = TMP_56 && TMP_57,CONDITION TMP_58,TMP_59(uint256) = tokens * 5,TMP_60(uint256) = TMP_59 / 100,countbonus(uint256) := TMP_60(uint256),TMP_61(bool) = msg.value >= bonusCond2,TMP_62(bool) = msg.value < bonusCond3,TMP_63(bool) = TMP_61 && TMP_62,CONDITION TMP_63,TMP_64(uint256) = tokens * 10,TMP_65(uint256) = TMP_64 / 100,countbonus(uint256) := TMP_65(uint256),TMP_66(bool) = msg.value >= bonusCond3,CONDITION TMP_66,TMP_67(uint256) = tokens * 20,TMP_68(uint256) = TMP_67 / 100,countbonus(uint256) := TMP_68(uint256),TMP_69(bool) = msg.value >= requestMinimum,TMP_70(bool) = now < deadline,TMP_71(bool) = TMP_69 && TMP_70,TMP_72(bool) = now > round1,TMP_73(bool) = TMP_71 && TMP_72,TMP_74(bool) = now < round2,TMP_75(bool) = TMP_73 && TMP_74,CONDITION TMP_75,TMP_76(bool) = msg.value >= bonusCond2,TMP_77(bool) = msg.value < bonusCond3,TMP_78(bool) = TMP_76 && TMP_77,CONDITION TMP_78,TMP_79(uint256) = tokens * 2,TMP_80(uint256) = TMP_79 / 100,countbonus(uint256) := TMP_80(uint256),TMP_81(bool) = msg.value >= bonusCond3,CONDITION TMP_81,TMP_82(uint256) = tokens * 3,TMP_83(uint256) = TMP_82 / 100,countbonus(uint256) := TMP_83(uint256),countbonus(uint256) := 0(uint256),TMP_84(uint256) = tokens + countbonus,bonus(uint256) := TMP_84(uint256),TMP_85(bool) = tokens == 0,CONDITION TMP_85,valdrop(uint256) := 0(uint256),REF_12(bool) -> Claimed[investor],TMP_86(bool) = REF_12 == False,TMP_87(bool) = progress0drop <= target0drop,TMP_88(bool) = TMP_86 && TMP_87,CONDITION TMP_88,TMP_89(bool) = INTERNAL_CALL, BeezGold.distr(address,uint256)(investor,valdrop),REF_13(bool) -> Claimed[investor],REF_13(bool) (->Claimed) := True(bool),TMP_90(uint256) := progress0drop(uint256),progress0drop(uint256) = progress0drop + 1,TMP_91(bool) = msg.value >= requestMinimum,TMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91),TMP_93(bool) = tokens > 0,TMP_94(bool) = msg.value >= requestMinimum,TMP_95(bool) = TMP_93 && TMP_94,CONDITION TMP_95,TMP_96(bool) = now >= deadline,TMP_97(bool) = now >= round1,TMP_98(bool) = TMP_96 && TMP_97,TMP_99(bool) = now < round2,TMP_100(bool) = TMP_98 && TMP_99,CONDITION TMP_100,TMP_101(bool) = INTERNAL_CALL, BeezGold.distr(address,uint256)(investor,tokens),TMP_102(bool) = msg.value >= bonusCond1,CONDITION TMP_102,TMP_103(bool) = INTERNAL_CALL, BeezGold.distr(address,uint256)(investor,bonus),TMP_104(bool) = INTERNAL_CALL, BeezGold.distr(address,uint256)(investor,tokens),TMP_105(bool) = msg.value >= requestMinimum,TMP_106(None) = SOLIDITY_CALL require(bool)(TMP_105),TMP_107(bool) = totalDistributed >= totalSupply,CONDITION TMP_107,distributionFinished(bool) := True(bool),Transfer dest:multisig value:msg.value,MODIFIER_CALL, BeezGold.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->53;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bonusCond1 = 1000000000000000000 / 10

IRs:
TMP_45(uint256) = 1000000000000000000 / 10
bonusCond1(uint256) := TMP_45(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bonusCond2 = 5000000000000000000 / 10

IRs:
TMP_46(uint256) = 5000000000000000000 / 10
bonusCond2(uint256) := TMP_46(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
bonusCond3 = 1000000000000000000

IRs:
bonusCond3(uint256) := 1000000000000000000(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_48(uint256) = TMP_47 / 1000000000000000000
tokens(uint256) := TMP_48(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now < round1 && now < round2

IRs:
TMP_49(bool) = msg.value >= requestMinimum
TMP_50(bool) = now < deadline
TMP_51(bool) = TMP_49 && TMP_50
TMP_52(bool) = now < round1
TMP_53(bool) = TMP_51 && TMP_52
TMP_54(bool) = now < round2
TMP_55(bool) = TMP_53 && TMP_54
CONDITION TMP_55""];
9->10[label=""True""];
9->19[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
msg.value >= bonusCond1 && msg.value < bonusCond2

IRs:
TMP_56(bool) = msg.value >= bonusCond1
TMP_57(bool) = msg.value < bonusCond2
TMP_58(bool) = TMP_56 && TMP_57
CONDITION TMP_58""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
countbonus = tokens * 5 / 100

IRs:
TMP_59(uint256) = tokens * 5
TMP_60(uint256) = TMP_59 / 100
countbonus(uint256) := TMP_60(uint256)""];
11->18;
12[label=""Node Type: IF 12

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_61(bool) = msg.value >= bonusCond2
TMP_62(bool) = msg.value < bonusCond3
TMP_63(bool) = TMP_61 && TMP_62
CONDITION TMP_63""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
countbonus = tokens * 10 / 100

IRs:
TMP_64(uint256) = tokens * 10
TMP_65(uint256) = TMP_64 / 100
countbonus(uint256) := TMP_65(uint256)""];
13->17;
14[label=""Node Type: IF 14

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_66(bool) = msg.value >= bonusCond3
CONDITION TMP_66""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
countbonus = tokens * 20 / 100

IRs:
TMP_67(uint256) = tokens * 20
TMP_68(uint256) = TMP_67 / 100
countbonus(uint256) := TMP_68(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->28;
19[label=""Node Type: IF 19

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now > round1 && now < round2

IRs:
TMP_69(bool) = msg.value >= requestMinimum
TMP_70(bool) = now < deadline
TMP_71(bool) = TMP_69 && TMP_70
TMP_72(bool) = now > round1
TMP_73(bool) = TMP_71 && TMP_72
TMP_74(bool) = now < round2
TMP_75(bool) = TMP_73 && TMP_74
CONDITION TMP_75""];
19->20[label=""True""];
19->26[label=""False""];
20[label=""Node Type: IF 20

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_76(bool) = msg.value >= bonusCond2
TMP_77(bool) = msg.value < bonusCond3
TMP_78(bool) = TMP_76 && TMP_77
CONDITION TMP_78""];
20->21[label=""True""];
20->22[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
countbonus = tokens * 2 / 100

IRs:
TMP_79(uint256) = tokens * 2
TMP_80(uint256) = TMP_79 / 100
countbonus(uint256) := TMP_80(uint256)""];
21->25;
22[label=""Node Type: IF 22

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_81(bool) = msg.value >= bonusCond3
CONDITION TMP_81""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
countbonus = tokens * 3 / 100

IRs:
TMP_82(uint256) = tokens * 3
TMP_83(uint256) = TMP_82 / 100
countbonus(uint256) := TMP_83(uint256)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->27;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
bonus = tokens + countbonus

IRs:
TMP_84(uint256) = tokens + countbonus
bonus(uint256) := TMP_84(uint256)""];
29->30;
30[label=""Node Type: IF 30

EXPRESSION:
tokens == 0

IRs:
TMP_85(bool) = tokens == 0
CONDITION TMP_85""];
30->31[label=""True""];
30->38[label=""False""];
31[label=""Node Type: NEW VARIABLE 31

EXPRESSION:
valdrop = 0e8

IRs:
valdrop(uint256) := 0(uint256)""];
31->32;
32[label=""Node Type: IF 32

EXPRESSION:
Claimed[investor] == false && progress0drop <= target0drop

IRs:
REF_12(bool) -> Claimed[investor]
TMP_86(bool) = REF_12 == False
TMP_87(bool) = progress0drop <= target0drop
TMP_88(bool) = TMP_86 && TMP_87
CONDITION TMP_88""];
32->33[label=""True""];
32->36[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
distr(investor,valdrop)

IRs:
TMP_89(bool) = INTERNAL_CALL, BeezGold.distr(address,uint256)(investor,valdrop)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
Claimed[investor] = true

IRs:
REF_13(bool) -> Claimed[investor]
REF_13(bool) (->Claimed) := True(bool)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
progress0drop ++

IRs:
TMP_90(uint256) := progress0drop(uint256)
progress0drop(uint256) = progress0drop + 1""];
35->37;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_91(bool) = msg.value >= requestMinimum
TMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91)""];
36->37;
37[label=""Node Type: END_IF 37
""];
37->48;
38[label=""Node Type: IF 38

EXPRESSION:
tokens > 0 && msg.value >= requestMinimum

IRs:
TMP_93(bool) = tokens > 0
TMP_94(bool) = msg.value >= requestMinimum
TMP_95(bool) = TMP_93 && TMP_94
CONDITION TMP_95""];
38->39[label=""True""];
38->46[label=""False""];
39[label=""Node Type: IF 39

EXPRESSION:
now >= deadline && now >= round1 && now < round2

IRs:
TMP_96(bool) = now >= deadline
TMP_97(bool) = now >= round1
TMP_98(bool) = TMP_96 && TMP_97
TMP_99(bool) = now < round2
TMP_100(bool) = TMP_98 && TMP_99
CONDITION TMP_100""];
39->40[label=""True""];
39->41[label=""False""];
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_101(bool) = INTERNAL_CALL, BeezGold.distr(address,uint256)(investor,tokens)""];
40->45;
41[label=""Node Type: IF 41

EXPRESSION:
msg.value >= bonusCond1

IRs:
TMP_102(bool) = msg.value >= bonusCond1
CONDITION TMP_102""];
41->42[label=""True""];
41->43[label=""False""];
42[label=""Node Type: EXPRESSION 42

EXPRESSION:
distr(investor,bonus)

IRs:
TMP_103(bool) = INTERNAL_CALL, BeezGold.distr(address,uint256)(investor,bonus)""];
42->44;
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_104(bool) = INTERNAL_CALL, BeezGold.distr(address,uint256)(investor,tokens)""];
43->44;
44[label=""Node Type: END_IF 44
""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->47;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_105(bool) = msg.value >= requestMinimum
TMP_106(None) = SOLIDITY_CALL require(bool)(TMP_105)""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: IF 49

EXPRESSION:
totalDistributed >= totalSupply

IRs:
TMP_107(bool) = totalDistributed >= totalSupply
CONDITION TMP_107""];
49->50[label=""True""];
49->51[label=""False""];
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
multisig.transfer(msg.value)

IRs:
Transfer dest:multisig value:msg.value""];
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, BeezGold.canDistr()()""];
53->1;
}
",0,0,1,0,"canDistr();tokens = 0;bonus = 0;countbonus = 0;bonusCond1 = 1000000000000000000 / 10;bonusCond2 = 5000000000000000000 / 10;bonusCond3 = 1000000000000000000;tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;investor = msg.sender;msg.value >= requestMinimum && now < deadline && now < round1 && now < round2;msg.value >= bonusCond1 && msg.value < bonusCond2;msg.value >= requestMinimum && now < deadline && now > round1 && now < round2;countbonus = tokens * 5 / 100;msg.value >= bonusCond2 && msg.value < bonusCond3;;countbonus = tokens * 10 / 100;msg.value >= bonusCond3;;countbonus = tokens * 20 / 100;;;msg.value >= bonusCond2 && msg.value < bonusCond3;countbonus = 0;countbonus = tokens * 2 / 100;msg.value >= bonusCond3;;countbonus = tokens * 3 / 100;;;bonus = tokens + countbonus;tokens == 0;valdrop = 0e8;tokens > 0 && msg.value >= requestMinimum;Claimed[investor] == false && progress0drop <= target0drop;distr(investor,valdrop);require(bool)(msg.value >= requestMinimum);Claimed[investor] = true;progress0drop ++;;;now >= deadline && now >= round1 && now < round2;require(bool)(msg.value >= requestMinimum);distr(investor,tokens);msg.value >= bonusCond1;;distr(investor,bonus);distr(investor,tokens);;;totalDistributed >= totalSupply;distributionFinished = true;;multisig.transfer(msg.value)"
./0xa3ea961ea44bafa061fe7b2ece819d2a8ceb69b2_ext.sol,TydoPreIco.refund,158,171,"TMP_62(bool) = state == 2,TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62),REF_14(uint256) -> balances[msg.sender],tokenAmount(uint256) := REF_14(uint256),TMP_64(bool) = tokenAmount > 0,TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64),REF_15(uint256) -> ethBalances[msg.sender],weiAmount(uint256) := REF_15(uint256),Transfer dest:msg.sender value:weiAmount,REF_18(uint256) -> balances[msg.sender],TMP_67(bool) = HIGH_LEVEL_CALL, dest:token(AbstractERC20), function:transfer, arguments:['owner', 'REF_18']  ,REF_19(uint256) -> ethBalances[msg.sender],REF_19(uint256) (->ethBalances) := 0(uint256),REF_20(uint256) -> balances[msg.sender],REF_20(uint256) (->balances) := 0(uint256),TMP_68(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['ethCollected', 'weiAmount'] ,ethCollected(uint256) := TMP_68(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == 2)

IRs:
TMP_62(bool) = state == 2
TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
tokenAmount = balances[msg.sender]

IRs:
REF_14(uint256) -> balances[msg.sender]
tokenAmount(uint256) := REF_14(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(tokenAmount > 0)

IRs:
TMP_64(bool) = tokenAmount > 0
TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
weiAmount = ethBalances[msg.sender]

IRs:
REF_15(uint256) -> ethBalances[msg.sender]
weiAmount(uint256) := REF_15(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(weiAmount)

IRs:
Transfer dest:msg.sender value:weiAmount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
token.transfer(owner,balances[msg.sender])

IRs:
REF_18(uint256) -> balances[msg.sender]
TMP_67(bool) = HIGH_LEVEL_CALL, dest:token(AbstractERC20), function:transfer, arguments:['owner', 'REF_18']  ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
ethBalances[msg.sender] = 0

IRs:
REF_19(uint256) -> ethBalances[msg.sender]
REF_19(uint256) (->ethBalances) := 0(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[msg.sender] = 0

IRs:
REF_20(uint256) -> balances[msg.sender]
REF_20(uint256) (->balances) := 0(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
ethCollected = ethCollected.sub(weiAmount)

IRs:
TMP_68(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['ethCollected', 'weiAmount'] 
ethCollected(uint256) := TMP_68(uint256)""];
}
",0,0,1,0,"require(bool)(state == 2);tokenAmount = balances[msg.sender];require(bool)(tokenAmount > 0);weiAmount = ethBalances[msg.sender];msg.sender.transfer(weiAmount);token.transfer(owner,balances[msg.sender]);ethBalances[msg.sender] = 0;balances[msg.sender] = 0;ethCollected = ethCollected.sub(weiAmount)"
./0x0d11511ab22ec6e7a87f439a663862f1ec6d4a4b_ext.sol,SMCT.safeWithdrawal,304,309,"TMP_97(bool) = _value == 0,CONDITION TMP_97,TMP_98 = CONVERT this to address,TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98),Transfer dest:owner value:TMP_99,Transfer dest:owner value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_97(bool) = _value == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_98 = CONVERT this to address
TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98)
Transfer dest:owner value:TMP_99""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_value == 0;owner.transfer(address(this).balance);owner.transfer(_value);
./0x0091e27b9ef50427ad431be70dc441f9f6639d78_ext.sol,COE.withdrawDevFees,304,308,"TMP_136(None) = SOLIDITY_CALL require(bool)(_payFees),Transfer dest:_devFeesAddr value:_devFees,_devFees(uint256) := 0(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_payFees)

IRs:
TMP_136(None) = SOLIDITY_CALL require(bool)(_payFees)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_devFeesAddr.transfer(_devFees)

IRs:
Transfer dest:_devFeesAddr value:_devFees""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_devFees = 0

IRs:
_devFees(uint256) := 0(uint256)""];
}
",0,0,1,0,require(bool)(_payFees);_devFeesAddr.transfer(_devFees);_devFees = 0
./0x0dc11b7ed751594906bce3a7091952b30528ee7e_ext.sol,DickMeasurementContest.withdraw,26,31,"TMP_1(uint256) = lastBlock + 259200,TMP_2(bool) = now > TMP_1,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),REF_2(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_2,MODIFIER_CALL, DickMeasurementContest.onlyowner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now > lastBlock + 259200)

IRs:
TMP_1(uint256) = lastBlock + 259200
TMP_2(bool) = now > TMP_1
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_2(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_2""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyowner()

IRs:
MODIFIER_CALL, DickMeasurementContest.onlyowner()()""];
3->1;
}
",0,0,1,0,onlyowner();require(bool)(now > lastBlock + 259200);msg.sender.transfer(this.balance)
./0x5c529eda84ef12dba15aa1a12fefafeb8dee4ea7_ext.sol,GarudaCoin.withdraw,295,298,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, GarudaCoin.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, GarudaCoin.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x36cce24d6314445c11beb80f99f9f14b5ea9ecc2_ext.sol,LynchpinPrivateICO.closeSale,216,223,"TMP_66(bool) = now > LOCK_PERIOD_START,TMP_67(None) = SOLIDITY_CALL require(bool)(TMP_66),TMP_68 = CONVERT this to address,TMP_69(uint256) = HIGH_LEVEL_CALL, dest:lynT(LynchpinToken), function:balanceOf, arguments:['TMP_68']  ,TMP_70(bool) = HIGH_LEVEL_CALL, dest:lynT(LynchpinToken), function:transfer, arguments:['msg.sender', 'TMP_69']  ,TMP_71 = CONVERT this to address,TMP_72(uint256) = SOLIDITY_CALL balance(address)(TMP_71),Transfer dest:beneficiary value:TMP_72,crowdsaleClosed(bool) := True(bool),Emit LogSaleClosed(),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now > LOCK_PERIOD_START)

IRs:
TMP_66(bool) = now > LOCK_PERIOD_START
TMP_67(None) = SOLIDITY_CALL require(bool)(TMP_66)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
lynT.transfer(msg.sender,lynT.balanceOf(address(this)))

IRs:
TMP_68 = CONVERT this to address
TMP_69(uint256) = HIGH_LEVEL_CALL, dest:lynT(LynchpinToken), function:balanceOf, arguments:['TMP_68']  
TMP_70(bool) = HIGH_LEVEL_CALL, dest:lynT(LynchpinToken), function:transfer, arguments:['msg.sender', 'TMP_69']  ""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
beneficiary.transfer(address(this).balance)

IRs:
TMP_71 = CONVERT this to address
TMP_72(uint256) = SOLIDITY_CALL balance(address)(TMP_71)
Transfer dest:beneficiary value:TMP_72""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
crowdsaleClosed = true

IRs:
crowdsaleClosed(bool) := True(bool)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
LogSaleClosed()

IRs:
Emit LogSaleClosed()""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",0,0,1,0,"onlyOwner();require(bool)(now > LOCK_PERIOD_START);lynT.transfer(msg.sender,lynT.balanceOf(address(this)));beneficiary.transfer(address(this).balance);crowdsaleClosed = true;LogSaleClosed()"
./0x7241496a3fad5b8fd93b647399f57d7c835d2385_ext.sol,TFTOKEN.safeWithdrawal,304,309,"TMP_97(bool) = _value == 0,CONDITION TMP_97,TMP_98 = CONVERT this to address,TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98),Transfer dest:owner value:TMP_99,Transfer dest:owner value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_97(bool) = _value == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_98 = CONVERT this to address
TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98)
Transfer dest:owner value:TMP_99""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_value == 0;owner.transfer(address(this).balance);owner.transfer(_value);
./0x39f89421c5bf8bb0d855c0216b00b45e3733b515_ext.sol,DINOSale.safeWithdrawal,705,715,"TMP_297 = UnaryType.BANG fundingGoalReached ,CONDITION TMP_297,REF_145(uint256) -> balanceOf[msg.sender],amount(uint256) := REF_145(uint256),REF_146(uint256) -> balanceOf[msg.sender],REF_146(uint256) (->balanceOf) := 0(uint256),TMP_298(bool) = amount > 0,CONDITION TMP_298,Transfer dest:msg.sender value:amount,Emit FundTransfer(msg.sender,amount,False),TMP_301(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['refundAmount', 'amount'] ,refundAmount(uint256) := TMP_301(uint256),MODIFIER_CALL, BaseDINOSale.afterDeadline()(),MODIFIER_CALL, BaseDINOSale.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: IF 1

EXPRESSION:
! fundingGoalReached

IRs:
TMP_297 = UnaryType.BANG fundingGoalReached 
CONDITION TMP_297""];
1->2[label=""True""];
1->9[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = balanceOf[msg.sender]

IRs:
REF_145(uint256) -> balanceOf[msg.sender]
amount(uint256) := REF_145(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[msg.sender] = 0

IRs:
REF_146(uint256) -> balanceOf[msg.sender]
REF_146(uint256) (->balanceOf) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
amount > 0

IRs:
TMP_298(bool) = amount > 0
CONDITION TMP_298""];
4->5[label=""True""];
4->8[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
FundTransfer(msg.sender,amount,false)

IRs:
Emit FundTransfer(msg.sender,amount,False)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
refundAmount = refundAmount.add(amount)

IRs:
TMP_301(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['refundAmount', 'amount'] 
refundAmount(uint256) := TMP_301(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
afterDeadline()

IRs:
MODIFIER_CALL, BaseDINOSale.afterDeadline()()""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, BaseDINOSale.nonReentrant()()""];
11->1;
}
",0,0,1,0,"afterDeadline();! fundingGoalReached;amount = balanceOf[msg.sender];;balanceOf[msg.sender] = 0;amount > 0;msg.sender.transfer(amount);;FundTransfer(msg.sender,amount,false);refundAmount = refundAmount.add(amount);nonReentrant()"
./0xece7814a9691a94e7f3d9354155e21cfb291e13b_ext.sol,AlmightyKeyChain.safeWithdrawal,304,309,"TMP_97(bool) = _value == 0,CONDITION TMP_97,TMP_98 = CONVERT this to address,TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98),Transfer dest:owner value:TMP_99,Transfer dest:owner value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_97(bool) = _value == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_98 = CONVERT this to address
TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98)
Transfer dest:owner value:TMP_99""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_value == 0;owner.transfer(address(this).balance);owner.transfer(_value);
./0xf2b89f45cc4ebbf11a36bdb4a4b24eada8dd30a7_ext.sol,AirDrop.transferEthToOnwer,79,81,"REF_10(uint256) = SOLIDITY_CALL balance(address)(this),TMP_22 = SEND dest:owner value:REF_10,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(owner.send(this.balance))

IRs:
REF_10(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_22 = SEND dest:owner value:REF_10
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();require(bool)(owner.send(this.balance))
./0xd37a7e9d4681da273e13d652ed9a789274d32bd7_ext.sol,LUPXSale.withdrawETH,60,62,"TMP_20 = CONVERT this to address,TMP_21(uint256) = SOLIDITY_CALL balance(address)(TMP_20),Transfer dest:msg.sender value:TMP_21,MODIFIER_CALL, LUPXSale.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_20 = CONVERT this to address
TMP_21(uint256) = SOLIDITY_CALL balance(address)(TMP_20)
Transfer dest:msg.sender value:TMP_21""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, LUPXSale.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();msg.sender.transfer(address(this).balance)
./0xdf4b22695eeb4a7a1cf9a42162285ce782b8427a_ext.sol,Token.fallback,396,401,"TMP_81(bool) = INTERNAL_CALL, Token.isContract(address)(controller),TMP_82(None) = SOLIDITY_CALL require(bool)(TMP_81),TMP_83 = CONVERT controller to TokenController,TMP_85(bool) = HIGH_LEVEL_CALL, dest:TMP_83(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value ,proxyPayment(bool) := TMP_85(bool),TMP_86(None) = SOLIDITY_CALL require(bool)(proxyPayment)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isContract(controller))

IRs:
TMP_81(bool) = INTERNAL_CALL, Token.isContract(address)(controller)
TMP_82(None) = SOLIDITY_CALL require(bool)(TMP_81)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
proxyPayment = TokenController(controller).proxyPayment.value(msg.value)(msg.sender)

IRs:
TMP_83 = CONVERT controller to TokenController
TMP_85(bool) = HIGH_LEVEL_CALL, dest:TMP_83(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value 
proxyPayment(bool) := TMP_85(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(proxyPayment)

IRs:
TMP_86(None) = SOLIDITY_CALL require(bool)(proxyPayment)""];
}
",0,0,1,0,require(bool)(isContract(controller));proxyPayment = TokenController(controller).proxyPayment.value(msg.value)(msg.sender);require(bool)(proxyPayment)
./0x91f2203f273677e68d47786b62efbd9497594698_ext.sol,Simpl_Quiz.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 400000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 400000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 400000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 400000000000000000;msg.sender.transfer(this.balance);
./0x4145492ad5039b802bd7e58098c8d71706a2cd14_ext.sol,RefundVault.close,193,198,"REF_6(RefundVault.State) -> State.Active,TMP_46(bool) = state == REF_6,TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46),REF_7(RefundVault.State) -> State.Closed,state(RefundVault.State) := REF_7(RefundVault.State),Emit Closed(),REF_9(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:wallet value:REF_9,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_6(RefundVault.State) -> State.Active
TMP_46(bool) = state == REF_6
TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
state = State.Closed

IRs:
REF_7(RefundVault.State) -> State.Closed
state(RefundVault.State) := REF_7(RefundVault.State)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Closed()

IRs:
Emit Closed()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
wallet.transfer(this.balance)

IRs:
REF_9(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:wallet value:REF_9""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();require(bool)(state == State.Active);state = State.Closed;Closed();wallet.transfer(this.balance)
./0x2f5c8d7259b48078c0b6c0a7cf6269e3817680e5_ext.sol,Refund.fallback,75,89,"TMP_33(bool) = msg.sender == tx.origin,TMP_34(None) = SOLIDITY_CALL require(bool,string)(TMP_33,msg.sender == tx.orgin),TMP_35(uint256) = HIGH_LEVEL_CALL, dest:xcc(tokenInterface), function:balanceOf, arguments:['msg.sender']  ,xcc_amount(uint256) := TMP_35(uint256),TMP_36(bool) = xcc_amount > 0,TMP_37(None) = SOLIDITY_CALL require(bool,string)(TMP_36,xcc_amount > 0),REF_1(uint256) -> refunds[msg.sender],money(uint256) := REF_1(uint256),TMP_38(bool) = money > 0,TMP_39(None) = SOLIDITY_CALL require(bool,string)(TMP_38,money > 0),REF_2(uint256) -> refunds[msg.sender],REF_2(uint256) (->refunds) := 0(uint256),TMP_40(bool) = HIGH_LEVEL_CALL, dest:xcc(tokenInterface), function:originBurn, arguments:['xcc_amount']  ,Transfer dest:msg.sender value:money","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(msg.sender == tx.origin,msg.sender == tx.orgin)

IRs:
TMP_33(bool) = msg.sender == tx.origin
TMP_34(None) = SOLIDITY_CALL require(bool,string)(TMP_33,msg.sender == tx.orgin)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
xcc_amount = xcc.balanceOf(msg.sender)

IRs:
TMP_35(uint256) = HIGH_LEVEL_CALL, dest:xcc(tokenInterface), function:balanceOf, arguments:['msg.sender']  
xcc_amount(uint256) := TMP_35(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool,string)(xcc_amount > 0,xcc_amount > 0)

IRs:
TMP_36(bool) = xcc_amount > 0
TMP_37(None) = SOLIDITY_CALL require(bool,string)(TMP_36,xcc_amount > 0)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
money = refunds[msg.sender]

IRs:
REF_1(uint256) -> refunds[msg.sender]
money(uint256) := REF_1(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool,string)(money > 0,money > 0)

IRs:
TMP_38(bool) = money > 0
TMP_39(None) = SOLIDITY_CALL require(bool,string)(TMP_38,money > 0)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
refunds[msg.sender] = 0

IRs:
REF_2(uint256) -> refunds[msg.sender]
REF_2(uint256) (->refunds) := 0(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
xcc.originBurn(xcc_amount)

IRs:
TMP_40(bool) = HIGH_LEVEL_CALL, dest:xcc(tokenInterface), function:originBurn, arguments:['xcc_amount']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
msg.sender.transfer(money)

IRs:
Transfer dest:msg.sender value:money""];
}
",0,0,1,0,"require(bool,string)(msg.sender == tx.origin,msg.sender == tx.orgin);xcc_amount = xcc.balanceOf(msg.sender);require(bool,string)(xcc_amount > 0,xcc_amount > 0);money = refunds[msg.sender];require(bool,string)(money > 0,money > 0);refunds[msg.sender] = 0;xcc.originBurn(xcc_amount);msg.sender.transfer(money)"
./0x0033fb5561719b8b697b604466d6d39308c58191_ext.sol,EncryptedToken.selfdestructs,223,225,TMP_87(None) = SOLIDITY_CALL selfdestruct(address)(owner),"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_87(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
}
",0,0,1,0,selfdestruct(address)(owner)
./0xdc99adde3a358e5ff62fff3f26b2296f8cca2306_ext.sol,TokenFactoryCN.safeWithdrawal,304,309,"TMP_97(bool) = _value == 0,CONDITION TMP_97,TMP_98 = CONVERT this to address,TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98),Transfer dest:owner value:TMP_99,Transfer dest:owner value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_97(bool) = _value == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_98 = CONVERT this to address
TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98)
Transfer dest:owner value:TMP_99""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_value == 0;owner.transfer(address(this).balance);owner.transfer(_value);
./0x36995d4e1ab6ee76aa55f16736fc85ec6e7b6c1d_ext.sol,HardcodedCrowdsale.withdrawFunds,266,271,"TMP_130(bool) = Softcap <= ICOcollected,TMP_131(None) = SOLIDITY_CALL require(bool)(TMP_130),TMP_132(uint256) = ICOcollected - TakedFunds,Transfer dest:owner value:TMP_132,TakedFunds(uint256) := ICOcollected(uint256),RETURN True,MODIFIER_CALL, HardcodedCrowdsale.onlyOwner()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(Softcap <= ICOcollected)

IRs:
TMP_130(bool) = Softcap <= ICOcollected
TMP_131(None) = SOLIDITY_CALL require(bool)(TMP_130)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(ICOcollected - TakedFunds)

IRs:
TMP_132(uint256) = ICOcollected - TakedFunds
Transfer dest:owner value:TMP_132""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
TakedFunds = ICOcollected

IRs:
TakedFunds(uint256) := ICOcollected(uint256)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, HardcodedCrowdsale.onlyOwner()()""];
5->1;
6[label=""Node Type: RETURN 6

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,0,1,0,onlyOwner();require(bool)(Softcap <= ICOcollected);owner.transfer(ICOcollected - TakedFunds);TakedFunds = ICOcollected;true;success
./0xd54920cedf704b87342fa26d5773efabf9037a77_ext.sol,CryptoStars.withdrawPartial,376,384,"TMP_112(bool) = msg.sender != owner,CONDITION TMP_112,REF_146(uint256) -> pendingWithdrawals[msg.sender],TMP_113(bool) = withdrawAmount > REF_146,CONDITION TMP_113,REF_147(uint256) -> pendingWithdrawals[msg.sender],REF_147(-> pendingWithdrawals) = REF_147 - withdrawAmount,TMP_114 = SEND dest:msg.sender value:withdrawAmount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender != owner

IRs:
TMP_112(bool) = msg.sender != owner
CONDITION TMP_112""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
withdrawAmount > pendingWithdrawals[msg.sender]

IRs:
REF_146(uint256) -> pendingWithdrawals[msg.sender]
TMP_113(bool) = withdrawAmount > REF_146
CONDITION TMP_113""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: THROW 5
""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
pendingWithdrawals[msg.sender] -= withdrawAmount

IRs:
REF_147(uint256) -> pendingWithdrawals[msg.sender]
REF_147(-> pendingWithdrawals) = REF_147 - withdrawAmount""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
msg.sender.send(withdrawAmount)

IRs:
TMP_114 = SEND dest:msg.sender value:withdrawAmount""];
}
",0,0,1,0,msg.sender != owner;;;withdrawAmount > pendingWithdrawals[msg.sender];;;pendingWithdrawals[msg.sender] -= withdrawAmount;msg.sender.send(withdrawAmount)
./0x1ed81e904acfa95ca1ffe224ee7aa89f2bf5ef9c_ext.sol,En_GAME.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x1f0d1de1558582ad6f13763f477119a1455502af_ext.sol,Exchange.sendTokensTo,494,502,"TMP_199(bool) = tkn == etherAddress,CONDITION TMP_199,Transfer dest:destination value:amount,TMP_201 = CONVERT tkn to ERC20,TMP_202(bool) = HIGH_LEVEL_CALL, dest:TMP_201(ERC20), function:transfer, arguments:['destination', 'amount']  ,TMP_203(None) = SOLIDITY_CALL require(bool)(TMP_202),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
tkn == etherAddress

IRs:
TMP_199(bool) = tkn == etherAddress
CONDITION TMP_199""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
destination.transfer(amount)

IRs:
Transfer dest:destination value:amount""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(ERC20(tkn).transfer(destination,amount))

IRs:
TMP_201 = CONVERT tkn to ERC20
TMP_202(bool) = HIGH_LEVEL_CALL, dest:TMP_201(ERC20), function:transfer, arguments:['destination', 'amount']  
TMP_203(None) = SOLIDITY_CALL require(bool)(TMP_202)""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,0,1,0,"tkn == etherAddress;destination.transfer(amount);require(bool)(ERC20(tkn).transfer(destination,amount));;true"
./0x945f171de4ea81a213dcc7a1e8c4f6feb3b4b806_ext.sol,ECP_Token.withdraw_all,117,128,"TMP_19(bool) = msg.sender == owner,TMP_20(bool) = msg.sender == bkaddress,TMP_21(bool) = TMP_19 || TMP_20,CONDITION TMP_21,REF_7(uint256) = SOLIDITY_CALL balance(address)(this),TMP_22([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B6426F40>]) = REF_7 - 10000000000000000,amountWith(uint256) := TMP_22([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B6426F40>]),Transfer dest:benAddress value:amountWith,TMP_24(None) = SOLIDITY_CALL revert()(),MODIFIER_CALL, ECP_Token.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: IF 1

EXPRESSION:
(msg.sender == owner) || (msg.sender == bkaddress)

IRs:
TMP_19(bool) = msg.sender == owner
TMP_20(bool) = msg.sender == bkaddress
TMP_21(bool) = TMP_19 || TMP_20
CONDITION TMP_21""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amountWith = this.balance - 10000000000000000

IRs:
REF_7(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_22([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B6426F40>]) = REF_7 - 10000000000000000
amountWith(uint256) := TMP_22([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B6426F40>])""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
benAddress.transfer(amountWith)

IRs:
Transfer dest:benAddress value:amountWith""];
3->5;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
revert()()

IRs:
TMP_24(None) = SOLIDITY_CALL revert()()""];
4->5;
5[label=""Node Type: END_IF 5
""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ECP_Token.onlyOwner()()""];
6->1;
}
",0,0,1,0,onlyOwner();(msg.sender == owner) || (msg.sender == bkaddress);amountWith = this.balance - 10000000000000000;revert()();benAddress.transfer(amountWith);
./0xead7adf1bf0df9f03b15429d82ea1f70ebd619f1_ext.sol,Crowdsale.withdrawFunds,132,151,"TMP_39 = UnaryType.BANG preICOWithdrawn ,TMP_40(bool) = TMP_39 && preICOClosed,TMP_41 = UnaryType.BANG ICOWithdrawn ,TMP_42(bool) = TMP_41 && ICOClosed,TMP_43(bool) = TMP_40 || TMP_42,TMP_44(None) = SOLIDITY_CALL require(bool)(TMP_43),TMP_45 = UnaryType.BANG preICOWithdrawn ,TMP_46(bool) = TMP_45 && preICOClosed,CONDITION TMP_46,TMP_47 = SEND dest:beneficiary value:preICORaised,CONDITION TMP_47,preICOWithdrawn(bool) := True(bool),Emit FundTransfer(beneficiary,preICORaised,False),TMP_49 = UnaryType.BANG ICOWithdrawn ,TMP_50(bool) = TMP_49 && ICOClosed,CONDITION TMP_50,TMP_51 = SEND dest:beneficiary value:ICORaised,CONDITION TMP_51,ICOWithdrawn(bool) := True(bool),Emit FundTransfer(beneficiary,ICORaised,False),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((! preICOWithdrawn && preICOClosed) || (! ICOWithdrawn && ICOClosed))

IRs:
TMP_39 = UnaryType.BANG preICOWithdrawn 
TMP_40(bool) = TMP_39 && preICOClosed
TMP_41 = UnaryType.BANG ICOWithdrawn 
TMP_42(bool) = TMP_41 && ICOClosed
TMP_43(bool) = TMP_40 || TMP_42
TMP_44(None) = SOLIDITY_CALL require(bool)(TMP_43)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
! preICOWithdrawn && preICOClosed

IRs:
TMP_45 = UnaryType.BANG preICOWithdrawn 
TMP_46(bool) = TMP_45 && preICOClosed
CONDITION TMP_46""];
2->3[label=""True""];
2->7[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
beneficiary.send(preICORaised)

IRs:
TMP_47 = SEND dest:beneficiary value:preICORaised
CONDITION TMP_47""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
preICOWithdrawn = true

IRs:
preICOWithdrawn(bool) := True(bool)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
FundTransfer(beneficiary,preICORaised,false)

IRs:
Emit FundTransfer(beneficiary,preICORaised,False)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
! ICOWithdrawn && ICOClosed

IRs:
TMP_49 = UnaryType.BANG ICOWithdrawn 
TMP_50(bool) = TMP_49 && ICOClosed
CONDITION TMP_50""];
8->9[label=""True""];
8->13[label=""False""];
9[label=""Node Type: IF 9

EXPRESSION:
beneficiary.send(ICORaised)

IRs:
TMP_51 = SEND dest:beneficiary value:ICORaised
CONDITION TMP_51""];
9->10[label=""True""];
9->12[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
ICOWithdrawn = true

IRs:
ICOWithdrawn(bool) := True(bool)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
FundTransfer(beneficiary,ICORaised,false)

IRs:
Emit FundTransfer(beneficiary,ICORaised,False)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: END_IF 13
""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
14->1;
}
",0,0,1,0,"onlyOwner();require(bool)((! preICOWithdrawn && preICOClosed) || (! ICOWithdrawn && ICOClosed));! preICOWithdrawn && preICOClosed;beneficiary.send(preICORaised);;preICOWithdrawn = true;;FundTransfer(beneficiary,preICORaised,false);! ICOWithdrawn && ICOClosed;beneficiary.send(ICORaised);;ICOWithdrawn = true;;FundTransfer(beneficiary,ICORaised,false)"
./0x3686986e559f257cfaccb44f17af5b245e45814f_ext.sol,ZEROtoken.fallback,53,61,"TMP_35 = UnaryType.BANG purchasingAllowed ,CONDITION TMP_35,TMP_36(bool) = msg.value > 0,CONDITION TMP_36,Transfer dest:owner value:msg.value,TMP_38(bool) = msg.value == 0,CONDITION TMP_38,Transfer dest:owner value:msg.value,totalContribution(uint256) = totalContribution + msg.value,TMP_40(uint256) = msg.value * 10000,tokensIssued(uint256) := TMP_40(uint256),TMP_41(bool) = msg.value >= 10000000000000000,CONDITION TMP_41,tokensIssued(uint256) = tokensIssued + totalContribution,totalSupply(uint256) = totalSupply + tokensIssued,REF_27(uint256) -> balances[msg.sender],REF_27(-> balances) = REF_27 + tokensIssued,TMP_42 = CONVERT this to address,Emit Transfer(TMP_42,msg.sender,tokensIssued)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
! purchasingAllowed

IRs:
TMP_35 = UnaryType.BANG purchasingAllowed 
CONDITION TMP_35""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
msg.value > 0

IRs:
TMP_36(bool) = msg.value > 0
CONDITION TMP_36""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(msg.value)

IRs:
Transfer dest:owner value:msg.value""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: RETURN 5
""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
msg.value == 0

IRs:
TMP_38(bool) = msg.value == 0
CONDITION TMP_38""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: RETURN 8
""];
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
owner.transfer(msg.value)

IRs:
Transfer dest:owner value:msg.value""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
totalContribution += msg.value

IRs:
totalContribution(uint256) = totalContribution + msg.value""];
11->12;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
tokensIssued = (msg.value * 10000)

IRs:
TMP_40(uint256) = msg.value * 10000
tokensIssued(uint256) := TMP_40(uint256)""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
msg.value >= 10000000000000000

IRs:
TMP_41(bool) = msg.value >= 10000000000000000
CONDITION TMP_41""];
13->14[label=""True""];
13->15[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
tokensIssued += totalContribution

IRs:
tokensIssued(uint256) = tokensIssued + totalContribution""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
totalSupply += tokensIssued

IRs:
totalSupply(uint256) = totalSupply + tokensIssued""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
balances[msg.sender] += tokensIssued

IRs:
REF_27(uint256) -> balances[msg.sender]
REF_27(-> balances) = REF_27 + tokensIssued""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
Transfer(address(this),msg.sender,tokensIssued)

IRs:
TMP_42 = CONVERT this to address
Emit Transfer(TMP_42,msg.sender,tokensIssued)""];
}
",0,1,1,0,"! purchasingAllowed;msg.value > 0;;owner.transfer(msg.value);;;msg.value == 0;;;owner.transfer(msg.value);totalContribution += msg.value;tokensIssued = (msg.value * 10000);msg.value >= 10000000000000000;tokensIssued += totalContribution;;totalSupply += tokensIssued;balances[msg.sender] += tokensIssued;Transfer(address(this),msg.sender,tokensIssued)"
./0x4d81198dc71ffd13917da27d1a3f8599ac690535_ext.sol,DSG_Dice.sendOwnerDeposit,165,176,"TMP_158(bool) = paused == True,TMP_159(None) = SOLIDITY_CALL require(bool,string)(TMP_158,Game was not stopped),TMP_160(uint256) = INTERNAL_CALL, DSG_Dice.getContractBalance()(),contractBalance(uint256) := TMP_160(uint256),TMP_161(bool) = contractBalance >= ownerDeposit,CONDITION TMP_161,Transfer dest:recipient value:ownerDeposit,Transfer dest:recipient value:contractBalance,jackpotBalance = delete jackpotBalance ,ownerDeposit = delete ownerDeposit ,MODIFIER_CALL, DSG_Dice.onlyOwners()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(paused == true,Game was not stopped)

IRs:
TMP_158(bool) = paused == True
TMP_159(None) = SOLIDITY_CALL require(bool,string)(TMP_158,Game was not stopped)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
contractBalance = getContractBalance()

IRs:
TMP_160(uint256) = INTERNAL_CALL, DSG_Dice.getContractBalance()()
contractBalance(uint256) := TMP_160(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
contractBalance >= ownerDeposit

IRs:
TMP_161(bool) = contractBalance >= ownerDeposit
CONDITION TMP_161""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
recipient.transfer(ownerDeposit)

IRs:
Transfer dest:recipient value:ownerDeposit""];
4->6;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
recipient.transfer(contractBalance)

IRs:
Transfer dest:recipient value:contractBalance""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
delete jackpotBalance

IRs:
jackpotBalance = delete jackpotBalance ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
delete ownerDeposit

IRs:
ownerDeposit = delete ownerDeposit ""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwners()

IRs:
MODIFIER_CALL, DSG_Dice.onlyOwners()()""];
9->1;
}
",0,0,1,0,"onlyOwners();require(bool,string)(paused == true,Game was not stopped);contractBalance = getContractBalance();contractBalance >= ownerDeposit;recipient.transfer(ownerDeposit);recipient.transfer(contractBalance);;delete jackpotBalance;delete ownerDeposit"
./0xec987914ade432ce9806f418787a4ed0b0e77000_ext.sol,LuckyDice.playerWithdrawPendingTransactions,358,373,"REF_81(uint256) -> playerPendingWithdrawals[msg.sender],withdrawAmount(uint256) := REF_81(uint256),REF_82(uint256) -> playerPendingWithdrawals[msg.sender],REF_82(uint256) (->playerPendingWithdrawals) := 0(uint256),TMP_89(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:withdrawAmount ,CONDITION TMP_89,RETURN True,REF_85(uint256) -> playerPendingWithdrawals[msg.sender],REF_85(uint256) (->playerPendingWithdrawals) := withdrawAmount(uint256),RETURN False,MODIFIER_CALL, LuckyDice.payoutsAreActive()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
withdrawAmount = playerPendingWithdrawals[msg.sender]

IRs:
REF_81(uint256) -> playerPendingWithdrawals[msg.sender]
withdrawAmount(uint256) := REF_81(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
playerPendingWithdrawals[msg.sender] = 0

IRs:
REF_82(uint256) -> playerPendingWithdrawals[msg.sender]
REF_82(uint256) (->playerPendingWithdrawals) := 0(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
msg.sender.call.value(withdrawAmount)()

IRs:
TMP_89(bool) = LOW_LEVEL_CALL, dest:msg.sender, function:call, arguments:[] value:withdrawAmount 
CONDITION TMP_89""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
playerPendingWithdrawals[msg.sender] = withdrawAmount

IRs:
REF_85(uint256) -> playerPendingWithdrawals[msg.sender]
REF_85(uint256) (->playerPendingWithdrawals) := withdrawAmount(uint256)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
false

IRs:
RETURN False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
payoutsAreActive()

IRs:
MODIFIER_CALL, LuckyDice.payoutsAreActive()()""];
8->1;
}
",0,0,1,0,payoutsAreActive();withdrawAmount = playerPendingWithdrawals[msg.sender];playerPendingWithdrawals[msg.sender] = 0;msg.sender.call.value(withdrawAmount)();true;playerPendingWithdrawals[msg.sender] = withdrawAmount;false
./0x4b5da69c6289bd71d643710d0a63bd4867808451_ext.sol,CoolPandaToken.transferEth,235,237,"TMP_75 = CONVERT this to address,TMP_76(uint256) = SOLIDITY_CALL balance(address)(TMP_75),Transfer dest:fundWallet value:TMP_76,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
fundWallet.transfer(address(this).balance)

IRs:
TMP_75 = CONVERT this to address
TMP_76(uint256) = SOLIDITY_CALL balance(address)(TMP_75)
Transfer dest:fundWallet value:TMP_76""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();fundWallet.transfer(address(this).balance)
./0xeece3bfd3c83715f1f801dfa6b735ac9093c5bc3_ext.sol,SecuritySale.withdraw,231,233,"TMP_73 = CONVERT this to address,TMP_74(uint256) = SOLIDITY_CALL balance(address)(TMP_73),Transfer dest:msg.sender value:TMP_74,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_73 = CONVERT this to address
TMP_74(uint256) = SOLIDITY_CALL balance(address)(TMP_73)
Transfer dest:msg.sender value:TMP_74""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();msg.sender.transfer(address(this).balance)
./0xf331f7887d31714dce936d9a9846e6afbe82e0a0_ext.sol,Ico.fallback,476,600,"REF_94(Ico.State) -> State.Failed,TMP_102(bool) = state == REF_94,CONDITION TMP_102,REF_95(uint256) -> invested[msg.sender],REF_96(uint256) -> investedOnPreIco[msg.sender],TMP_103(uint256) = REF_95 + REF_96,amount(uint256) := TMP_103(uint256),REF_97(uint256) -> invested[msg.sender],REF_97(uint256) (->invested) := 0(uint256),REF_98(uint256) -> investedOnPreIco[msg.sender],REF_98(uint256) (->investedOnPreIco) := 0(uint256),Emit Refund(msg.sender,amount),TMP_105(uint256) = amount + msg.value,Transfer dest:msg.sender value:TMP_105,REF_100(Ico.State) -> State.Expired,TMP_107(bool) = state == REF_100,CONDITION TMP_107,REF_101(uint256) -> invested[msg.sender],amount(uint256) := REF_101(uint256),REF_102(uint256) -> invested[msg.sender],REF_102(uint256) (->invested) := 0(uint256),Emit Refund(msg.sender,amount),TMP_109(uint256) = amount + msg.value,Transfer dest:msg.sender value:TMP_109,REF_104(Ico.State) -> State.Runned,TMP_111(bool) = state == REF_104,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113(bool) = now >= endIcoDate,CONDITION TMP_113,TMP_114 = CONVERT token to Agricoin,TMP_115(uint256) = HIGH_LEVEL_CALL, dest:TMP_114(Agricoin), function:totalSupply, arguments:[]  ,TMP_116 = CONVERT token to Agricoin,TMP_117(uint256) = HIGH_LEVEL_CALL, dest:TMP_116(Agricoin), function:totalSupplyOnIco, arguments:[]  ,TMP_118(uint256) = TMP_115 + TMP_117,TMP_119(bool) = TMP_118 >= softCap,CONDITION TMP_119,REF_107(Ico.State) -> State.Finished,state(Ico.State) := REF_107(Ico.State),TMP_120 = CONVERT token to Agricoin,TMP_121(uint256) = HIGH_LEVEL_CALL, dest:TMP_120(Agricoin), function:decimals, arguments:[]  ,decimals(uint256) := TMP_121(uint256),TMP_122 = CONVERT token to Agricoin,TMP_123(uint256) = HIGH_LEVEL_CALL, dest:TMP_122(Agricoin), function:totalSupply, arguments:[]  ,TMP_124 = CONVERT token to Agricoin,TMP_125(uint256) = HIGH_LEVEL_CALL, dest:TMP_124(Agricoin), function:totalSupplyOnIco, arguments:[]  ,TMP_126(uint256) = TMP_123 + TMP_125,supply(uint256) := TMP_126(uint256),TMP_127(uint256) = 1500000 * decimals,TMP_128(bool) = supply >= TMP_127,CONDITION TMP_128,TMP_129 = CONVERT token to Agricoin,TMP_130(uint256) = 300000 * decimals,TMP_131(bool) = HIGH_LEVEL_CALL, dest:TMP_129(Agricoin), function:mint, arguments:['bounty', 'TMP_130', 'True']  ,TMP_132(uint256) = 1150000 * decimals,TMP_133(bool) = supply >= TMP_132,CONDITION TMP_133,TMP_134 = CONVERT token to Agricoin,TMP_135(uint256) = 200000 * decimals,TMP_136(bool) = HIGH_LEVEL_CALL, dest:TMP_134(Agricoin), function:mint, arguments:['bounty', 'TMP_135', 'True']  ,TMP_137(uint256) = 800000 * decimals,TMP_138(bool) = supply >= TMP_137,CONDITION TMP_138,TMP_139 = CONVERT token to Agricoin,TMP_140(uint256) = 100000 * decimals,TMP_141(bool) = HIGH_LEVEL_CALL, dest:TMP_139(Agricoin), function:mint, arguments:['bounty', 'TMP_140', 'True']  ,TMP_142 = CONVERT token to Agricoin,TMP_143(bool) = HIGH_LEVEL_CALL, dest:TMP_142(Agricoin), function:activate, arguments:['True']  ,Emit End(True),Transfer dest:msg.sender value:msg.value,REF_116(Ico.State) -> State.Expired,state(Ico.State) := REF_116(Ico.State),TMP_146 = CONVERT token to Agricoin,TMP_147(bool) = HIGH_LEVEL_CALL, dest:TMP_146(Agricoin), function:activate, arguments:['False']  ,Transfer dest:msg.sender value:msg.value,Emit End(False),TMP_150(bool) = INTERNAL_CALL, Ico.isRunningPreIco(uint256)(now),CONDITION TMP_150,TMP_151(uint256) = investedSumOnPreIco / preIcoPrice,TMP_152(bool) = TMP_151 < preIcoTarget,TMP_153(None) = SOLIDITY_CALL require(bool)(TMP_152),TMP_154(uint256) = investedSumOnPreIco + msg.value,TMP_155(uint256) = TMP_154 / preIcoPrice,TMP_156(bool) = TMP_155 >= preIcoTarget,CONDITION TMP_156,TMP_157(uint256) = preIcoTarget * preIcoPrice,TMP_158(uint256) = TMP_157 - investedSumOnPreIco,value(uint256) := TMP_158(uint256),TMP_159(bool) = value != 0,TMP_160(None) = SOLIDITY_CALL require(bool)(TMP_159),TMP_161(uint256) = preIcoTarget * preIcoPrice,investedSumOnPreIco(uint256) := TMP_161(uint256),REF_119(uint256) -> investedOnPreIco[msg.sender],REF_119(-> investedOnPreIco) = REF_119 + value,Emit Invested(msg.sender,value),TMP_163 = CONVERT token to Agricoin,TMP_164(uint256) = value / preIcoPrice,TMP_165(bool) = HIGH_LEVEL_CALL, dest:TMP_163(Agricoin), function:mint, arguments:['msg.sender', 'TMP_164', 'False']  ,TMP_166(uint256) = msg.value - value,Transfer dest:msg.sender value:TMP_166,TMP_168(uint256) = msg.value % preIcoPrice,rest(uint256) := TMP_168(uint256),TMP_169(uint256) = msg.value - rest,TMP_170(bool) = TMP_169 >= preIcoPrice,TMP_171(None) = SOLIDITY_CALL require(bool)(TMP_170),TMP_172(uint256) = msg.value - rest,investedSumOnPreIco(uint256) = investedSumOnPreIco + TMP_172,REF_122(uint256) -> investedOnPreIco[msg.sender],TMP_173(uint256) = msg.value - rest,REF_122(-> investedOnPreIco) = REF_122 + TMP_173,TMP_174(uint256) = msg.value - rest,Emit Invested(msg.sender,TMP_174),TMP_176 = CONVERT token to Agricoin,TMP_177(uint256) = msg.value / preIcoPrice,TMP_178(bool) = HIGH_LEVEL_CALL, dest:TMP_176(Agricoin), function:mint, arguments:['msg.sender', 'TMP_177', 'False']  ,Transfer dest:msg.sender value:rest,TMP_180(bool) = INTERNAL_CALL, Ico.isRunningIco(uint256)(now),CONDITION TMP_180,TMP_181(uint256) = investedSumOnIco / icoPrice,TMP_182(bool) = TMP_181 < icoTarget,TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182),TMP_184(uint256) = investedSumOnIco + msg.value,TMP_185(uint256) = TMP_184 / icoPrice,TMP_186(bool) = TMP_185 >= icoTarget,CONDITION TMP_186,TMP_187(uint256) = icoTarget * icoPrice,TMP_188(uint256) = TMP_187 - investedSumOnIco,value(uint256) := TMP_188(uint256),TMP_189(bool) = value != 0,TMP_190(None) = SOLIDITY_CALL require(bool)(TMP_189),TMP_191(uint256) = icoTarget * icoPrice,investedSumOnIco(uint256) := TMP_191(uint256),REF_125(uint256) -> invested[msg.sender],REF_125(-> invested) = REF_125 + value,Emit Invested(msg.sender,value),TMP_193 = CONVERT token to Agricoin,TMP_194(uint256) = value / icoPrice,TMP_195(bool) = HIGH_LEVEL_CALL, dest:TMP_193(Agricoin), function:mint, arguments:['msg.sender', 'TMP_194', 'True']  ,TMP_196(uint256) = msg.value - value,Transfer dest:msg.sender value:TMP_196,TMP_198(uint256) = msg.value % icoPrice,rest(uint256) := TMP_198(uint256),TMP_199(uint256) = msg.value - rest,TMP_200(bool) = TMP_199 >= icoPrice,TMP_201(None) = SOLIDITY_CALL require(bool)(TMP_200),TMP_202(uint256) = msg.value - rest,investedSumOnIco(uint256) = investedSumOnIco + TMP_202,REF_128(uint256) -> invested[msg.sender],TMP_203(uint256) = msg.value - rest,REF_128(-> invested) = REF_128 + TMP_203,TMP_204(uint256) = msg.value - rest,Emit Invested(msg.sender,TMP_204),TMP_206 = CONVERT token to Agricoin,TMP_207(uint256) = msg.value / icoPrice,TMP_208(bool) = HIGH_LEVEL_CALL, dest:TMP_206(Agricoin), function:mint, arguments:['msg.sender', 'TMP_207', 'True']  ,Transfer dest:msg.sender value:rest,TMP_210(None) = SOLIDITY_CALL revert()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: NEW VARIABLE 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
state == State.Failed

IRs:
REF_94(Ico.State) -> State.Failed
TMP_102(bool) = state == REF_94
CONDITION TMP_102""];
4->5[label=""True""];
4->11[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
amount = invested[msg.sender] + investedOnPreIco[msg.sender]

IRs:
REF_95(uint256) -> invested[msg.sender]
REF_96(uint256) -> investedOnPreIco[msg.sender]
TMP_103(uint256) = REF_95 + REF_96
amount(uint256) := TMP_103(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
invested[msg.sender] = 0

IRs:
REF_97(uint256) -> invested[msg.sender]
REF_97(uint256) (->invested) := 0(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
investedOnPreIco[msg.sender] = 0

IRs:
REF_98(uint256) -> investedOnPreIco[msg.sender]
REF_98(uint256) (->investedOnPreIco) := 0(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Refund(msg.sender,amount)

IRs:
Emit Refund(msg.sender,amount)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
msg.sender.transfer(amount + msg.value)

IRs:
TMP_105(uint256) = amount + msg.value
Transfer dest:msg.sender value:TMP_105""];
9->10;
10[label=""Node Type: RETURN 10
""];
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
state == State.Expired

IRs:
REF_100(Ico.State) -> State.Expired
TMP_107(bool) = state == REF_100
CONDITION TMP_107""];
12->13[label=""True""];
12->18[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
amount = invested[msg.sender]

IRs:
REF_101(uint256) -> invested[msg.sender]
amount(uint256) := REF_101(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
invested[msg.sender] = 0

IRs:
REF_102(uint256) -> invested[msg.sender]
REF_102(uint256) (->invested) := 0(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
Refund(msg.sender,amount)

IRs:
Emit Refund(msg.sender,amount)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
msg.sender.transfer(amount + msg.value)

IRs:
TMP_109(uint256) = amount + msg.value
Transfer dest:msg.sender value:TMP_109""];
16->17;
17[label=""Node Type: RETURN 17
""];
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
require(bool)(state == State.Runned)

IRs:
REF_104(Ico.State) -> State.Runned
TMP_111(bool) = state == REF_104
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
19->20;
20[label=""Node Type: IF 20

EXPRESSION:
now >= endIcoDate

IRs:
TMP_113(bool) = now >= endIcoDate
CONDITION TMP_113""];
20->21[label=""True""];
20->44[label=""False""];
21[label=""Node Type: IF 21

EXPRESSION:
Agricoin(token).totalSupply() + Agricoin(token).totalSupplyOnIco() >= softCap

IRs:
TMP_114 = CONVERT token to Agricoin
TMP_115(uint256) = HIGH_LEVEL_CALL, dest:TMP_114(Agricoin), function:totalSupply, arguments:[]  
TMP_116 = CONVERT token to Agricoin
TMP_117(uint256) = HIGH_LEVEL_CALL, dest:TMP_116(Agricoin), function:totalSupplyOnIco, arguments:[]  
TMP_118(uint256) = TMP_115 + TMP_117
TMP_119(bool) = TMP_118 >= softCap
CONDITION TMP_119""];
21->22[label=""True""];
21->38[label=""False""];
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
state = State.Finished

IRs:
REF_107(Ico.State) -> State.Finished
state(Ico.State) := REF_107(Ico.State)""];
22->23;
23[label=""Node Type: NEW VARIABLE 23

EXPRESSION:
decimals = Agricoin(token).decimals()

IRs:
TMP_120 = CONVERT token to Agricoin
TMP_121(uint256) = HIGH_LEVEL_CALL, dest:TMP_120(Agricoin), function:decimals, arguments:[]  
decimals(uint256) := TMP_121(uint256)""];
23->24;
24[label=""Node Type: NEW VARIABLE 24

EXPRESSION:
supply = Agricoin(token).totalSupply() + Agricoin(token).totalSupplyOnIco()

IRs:
TMP_122 = CONVERT token to Agricoin
TMP_123(uint256) = HIGH_LEVEL_CALL, dest:TMP_122(Agricoin), function:totalSupply, arguments:[]  
TMP_124 = CONVERT token to Agricoin
TMP_125(uint256) = HIGH_LEVEL_CALL, dest:TMP_124(Agricoin), function:totalSupplyOnIco, arguments:[]  
TMP_126(uint256) = TMP_123 + TMP_125
supply(uint256) := TMP_126(uint256)""];
24->25;
25[label=""Node Type: IF 25

EXPRESSION:
supply >= 1500000 * decimals

IRs:
TMP_127(uint256) = 1500000 * decimals
TMP_128(bool) = supply >= TMP_127
CONDITION TMP_128""];
25->26[label=""True""];
25->27[label=""False""];
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
Agricoin(token).mint(bounty,300000 * decimals,true)

IRs:
TMP_129 = CONVERT token to Agricoin
TMP_130(uint256) = 300000 * decimals
TMP_131(bool) = HIGH_LEVEL_CALL, dest:TMP_129(Agricoin), function:mint, arguments:['bounty', 'TMP_130', 'True']  ""];
26->33;
27[label=""Node Type: IF 27

EXPRESSION:
supply >= 1150000 * decimals

IRs:
TMP_132(uint256) = 1150000 * decimals
TMP_133(bool) = supply >= TMP_132
CONDITION TMP_133""];
27->28[label=""True""];
27->29[label=""False""];
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
Agricoin(token).mint(bounty,200000 * decimals,true)

IRs:
TMP_134 = CONVERT token to Agricoin
TMP_135(uint256) = 200000 * decimals
TMP_136(bool) = HIGH_LEVEL_CALL, dest:TMP_134(Agricoin), function:mint, arguments:['bounty', 'TMP_135', 'True']  ""];
28->32;
29[label=""Node Type: IF 29

EXPRESSION:
supply >= 800000 * decimals

IRs:
TMP_137(uint256) = 800000 * decimals
TMP_138(bool) = supply >= TMP_137
CONDITION TMP_138""];
29->30[label=""True""];
29->31[label=""False""];
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
Agricoin(token).mint(bounty,100000 * decimals,true)

IRs:
TMP_139 = CONVERT token to Agricoin
TMP_140(uint256) = 100000 * decimals
TMP_141(bool) = HIGH_LEVEL_CALL, dest:TMP_139(Agricoin), function:mint, arguments:['bounty', 'TMP_140', 'True']  ""];
30->31;
31[label=""Node Type: END_IF 31
""];
31->32;
32[label=""Node Type: END_IF 32
""];
32->33;
33[label=""Node Type: END_IF 33
""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
Agricoin(token).activate(true)

IRs:
TMP_142 = CONVERT token to Agricoin
TMP_143(bool) = HIGH_LEVEL_CALL, dest:TMP_142(Agricoin), function:activate, arguments:['True']  ""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
End(true)

IRs:
Emit End(True)""];
35->36;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
msg.sender.transfer(msg.value)

IRs:
Transfer dest:msg.sender value:msg.value""];
36->37;
37[label=""Node Type: RETURN 37
""];
38[label=""Node Type: EXPRESSION 38

EXPRESSION:
state = State.Expired

IRs:
REF_116(Ico.State) -> State.Expired
state(Ico.State) := REF_116(Ico.State)""];
38->39;
39[label=""Node Type: EXPRESSION 39

EXPRESSION:
Agricoin(token).activate(false)

IRs:
TMP_146 = CONVERT token to Agricoin
TMP_147(bool) = HIGH_LEVEL_CALL, dest:TMP_146(Agricoin), function:activate, arguments:['False']  ""];
39->40;
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
msg.sender.transfer(msg.value)

IRs:
Transfer dest:msg.sender value:msg.value""];
40->41;
41[label=""Node Type: EXPRESSION 41

EXPRESSION:
End(false)

IRs:
Emit End(False)""];
41->42;
42[label=""Node Type: RETURN 42
""];
44[label=""Node Type: IF 44

EXPRESSION:
isRunningPreIco(now)

IRs:
TMP_150(bool) = INTERNAL_CALL, Ico.isRunningPreIco(uint256)(now)
CONDITION TMP_150""];
44->45[label=""True""];
44->64[label=""False""];
45[label=""Node Type: EXPRESSION 45

EXPRESSION:
require(bool)(investedSumOnPreIco / preIcoPrice < preIcoTarget)

IRs:
TMP_151(uint256) = investedSumOnPreIco / preIcoPrice
TMP_152(bool) = TMP_151 < preIcoTarget
TMP_153(None) = SOLIDITY_CALL require(bool)(TMP_152)""];
45->46;
46[label=""Node Type: IF 46

EXPRESSION:
(investedSumOnPreIco + msg.value) / preIcoPrice >= preIcoTarget

IRs:
TMP_154(uint256) = investedSumOnPreIco + msg.value
TMP_155(uint256) = TMP_154 / preIcoPrice
TMP_156(bool) = TMP_155 >= preIcoTarget
CONDITION TMP_156""];
46->47[label=""True""];
46->55[label=""False""];
47[label=""Node Type: EXPRESSION 47

EXPRESSION:
value = preIcoTarget * preIcoPrice - investedSumOnPreIco

IRs:
TMP_157(uint256) = preIcoTarget * preIcoPrice
TMP_158(uint256) = TMP_157 - investedSumOnPreIco
value(uint256) := TMP_158(uint256)""];
47->48;
48[label=""Node Type: EXPRESSION 48

EXPRESSION:
require(bool)(value != 0)

IRs:
TMP_159(bool) = value != 0
TMP_160(None) = SOLIDITY_CALL require(bool)(TMP_159)""];
48->49;
49[label=""Node Type: EXPRESSION 49

EXPRESSION:
investedSumOnPreIco = preIcoTarget * preIcoPrice

IRs:
TMP_161(uint256) = preIcoTarget * preIcoPrice
investedSumOnPreIco(uint256) := TMP_161(uint256)""];
49->50;
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
investedOnPreIco[msg.sender] += value

IRs:
REF_119(uint256) -> investedOnPreIco[msg.sender]
REF_119(-> investedOnPreIco) = REF_119 + value""];
50->51;
51[label=""Node Type: EXPRESSION 51

EXPRESSION:
Invested(msg.sender,value)

IRs:
Emit Invested(msg.sender,value)""];
51->52;
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
Agricoin(token).mint(msg.sender,value / preIcoPrice,false)

IRs:
TMP_163 = CONVERT token to Agricoin
TMP_164(uint256) = value / preIcoPrice
TMP_165(bool) = HIGH_LEVEL_CALL, dest:TMP_163(Agricoin), function:mint, arguments:['msg.sender', 'TMP_164', 'False']  ""];
52->53;
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
msg.sender.transfer(msg.value - value)

IRs:
TMP_166(uint256) = msg.value - value
Transfer dest:msg.sender value:TMP_166""];
53->54;
54[label=""Node Type: RETURN 54
""];
55[label=""Node Type: EXPRESSION 55

EXPRESSION:
rest = msg.value % preIcoPrice

IRs:
TMP_168(uint256) = msg.value % preIcoPrice
rest(uint256) := TMP_168(uint256)""];
55->56;
56[label=""Node Type: EXPRESSION 56

EXPRESSION:
require(bool)(msg.value - rest >= preIcoPrice)

IRs:
TMP_169(uint256) = msg.value - rest
TMP_170(bool) = TMP_169 >= preIcoPrice
TMP_171(None) = SOLIDITY_CALL require(bool)(TMP_170)""];
56->57;
57[label=""Node Type: EXPRESSION 57

EXPRESSION:
investedSumOnPreIco += msg.value - rest

IRs:
TMP_172(uint256) = msg.value - rest
investedSumOnPreIco(uint256) = investedSumOnPreIco + TMP_172""];
57->58;
58[label=""Node Type: EXPRESSION 58

EXPRESSION:
investedOnPreIco[msg.sender] += msg.value - rest

IRs:
REF_122(uint256) -> investedOnPreIco[msg.sender]
TMP_173(uint256) = msg.value - rest
REF_122(-> investedOnPreIco) = REF_122 + TMP_173""];
58->59;
59[label=""Node Type: EXPRESSION 59

EXPRESSION:
Invested(msg.sender,msg.value - rest)

IRs:
TMP_174(uint256) = msg.value - rest
Emit Invested(msg.sender,TMP_174)""];
59->60;
60[label=""Node Type: EXPRESSION 60

EXPRESSION:
Agricoin(token).mint(msg.sender,msg.value / preIcoPrice,false)

IRs:
TMP_176 = CONVERT token to Agricoin
TMP_177(uint256) = msg.value / preIcoPrice
TMP_178(bool) = HIGH_LEVEL_CALL, dest:TMP_176(Agricoin), function:mint, arguments:['msg.sender', 'TMP_177', 'False']  ""];
60->61;
61[label=""Node Type: EXPRESSION 61

EXPRESSION:
msg.sender.transfer(rest)

IRs:
Transfer dest:msg.sender value:rest""];
61->62;
62[label=""Node Type: RETURN 62
""];
64[label=""Node Type: IF 64

EXPRESSION:
isRunningIco(now)

IRs:
TMP_180(bool) = INTERNAL_CALL, Ico.isRunningIco(uint256)(now)
CONDITION TMP_180""];
64->65[label=""True""];
64->84[label=""False""];
65[label=""Node Type: EXPRESSION 65

EXPRESSION:
require(bool)(investedSumOnIco / icoPrice < icoTarget)

IRs:
TMP_181(uint256) = investedSumOnIco / icoPrice
TMP_182(bool) = TMP_181 < icoTarget
TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182)""];
65->66;
66[label=""Node Type: IF 66

EXPRESSION:
(investedSumOnIco + msg.value) / icoPrice >= icoTarget

IRs:
TMP_184(uint256) = investedSumOnIco + msg.value
TMP_185(uint256) = TMP_184 / icoPrice
TMP_186(bool) = TMP_185 >= icoTarget
CONDITION TMP_186""];
66->67[label=""True""];
66->75[label=""False""];
67[label=""Node Type: EXPRESSION 67

EXPRESSION:
value = icoTarget * icoPrice - investedSumOnIco

IRs:
TMP_187(uint256) = icoTarget * icoPrice
TMP_188(uint256) = TMP_187 - investedSumOnIco
value(uint256) := TMP_188(uint256)""];
67->68;
68[label=""Node Type: EXPRESSION 68

EXPRESSION:
require(bool)(value != 0)

IRs:
TMP_189(bool) = value != 0
TMP_190(None) = SOLIDITY_CALL require(bool)(TMP_189)""];
68->69;
69[label=""Node Type: EXPRESSION 69

EXPRESSION:
investedSumOnIco = icoTarget * icoPrice

IRs:
TMP_191(uint256) = icoTarget * icoPrice
investedSumOnIco(uint256) := TMP_191(uint256)""];
69->70;
70[label=""Node Type: EXPRESSION 70

EXPRESSION:
invested[msg.sender] += value

IRs:
REF_125(uint256) -> invested[msg.sender]
REF_125(-> invested) = REF_125 + value""];
70->71;
71[label=""Node Type: EXPRESSION 71

EXPRESSION:
Invested(msg.sender,value)

IRs:
Emit Invested(msg.sender,value)""];
71->72;
72[label=""Node Type: EXPRESSION 72

EXPRESSION:
Agricoin(token).mint(msg.sender,value / icoPrice,true)

IRs:
TMP_193 = CONVERT token to Agricoin
TMP_194(uint256) = value / icoPrice
TMP_195(bool) = HIGH_LEVEL_CALL, dest:TMP_193(Agricoin), function:mint, arguments:['msg.sender', 'TMP_194', 'True']  ""];
72->73;
73[label=""Node Type: EXPRESSION 73

EXPRESSION:
msg.sender.transfer(msg.value - value)

IRs:
TMP_196(uint256) = msg.value - value
Transfer dest:msg.sender value:TMP_196""];
73->74;
74[label=""Node Type: RETURN 74
""];
75[label=""Node Type: EXPRESSION 75

EXPRESSION:
rest = msg.value % icoPrice

IRs:
TMP_198(uint256) = msg.value % icoPrice
rest(uint256) := TMP_198(uint256)""];
75->76;
76[label=""Node Type: EXPRESSION 76

EXPRESSION:
require(bool)(msg.value - rest >= icoPrice)

IRs:
TMP_199(uint256) = msg.value - rest
TMP_200(bool) = TMP_199 >= icoPrice
TMP_201(None) = SOLIDITY_CALL require(bool)(TMP_200)""];
76->77;
77[label=""Node Type: EXPRESSION 77

EXPRESSION:
investedSumOnIco += msg.value - rest

IRs:
TMP_202(uint256) = msg.value - rest
investedSumOnIco(uint256) = investedSumOnIco + TMP_202""];
77->78;
78[label=""Node Type: EXPRESSION 78

EXPRESSION:
invested[msg.sender] += msg.value - rest

IRs:
REF_128(uint256) -> invested[msg.sender]
TMP_203(uint256) = msg.value - rest
REF_128(-> invested) = REF_128 + TMP_203""];
78->79;
79[label=""Node Type: EXPRESSION 79

EXPRESSION:
Invested(msg.sender,msg.value - rest)

IRs:
TMP_204(uint256) = msg.value - rest
Emit Invested(msg.sender,TMP_204)""];
79->80;
80[label=""Node Type: EXPRESSION 80

EXPRESSION:
Agricoin(token).mint(msg.sender,msg.value / icoPrice,true)

IRs:
TMP_206 = CONVERT token to Agricoin
TMP_207(uint256) = msg.value / icoPrice
TMP_208(bool) = HIGH_LEVEL_CALL, dest:TMP_206(Agricoin), function:mint, arguments:['msg.sender', 'TMP_207', 'True']  ""];
80->81;
81[label=""Node Type: EXPRESSION 81

EXPRESSION:
msg.sender.transfer(rest)

IRs:
Transfer dest:msg.sender value:rest""];
81->82;
82[label=""Node Type: RETURN 82
""];
84[label=""Node Type: EXPRESSION 84

EXPRESSION:
revert()()

IRs:
TMP_210(None) = SOLIDITY_CALL revert()()""];
84->85;
85[label=""Node Type: END_IF 85
""];
85->86;
86[label=""Node Type: END_IF 86
""];
86->87;
87[label=""Node Type: END_IF 87
""];
}
",0,0,1,0,";;;state == State.Failed;amount = invested[msg.sender] + investedOnPreIco[msg.sender];;invested[msg.sender] = 0;investedOnPreIco[msg.sender] = 0;Refund(msg.sender,amount);msg.sender.transfer(amount + msg.value);;state == State.Expired;amount = invested[msg.sender];;invested[msg.sender] = 0;Refund(msg.sender,amount);msg.sender.transfer(amount + msg.value);;require(bool)(state == State.Runned);now >= endIcoDate;Agricoin(token).totalSupply() + Agricoin(token).totalSupplyOnIco() >= softCap;isRunningPreIco(now);state = State.Finished;state = State.Expired;decimals = Agricoin(token).decimals();supply = Agricoin(token).totalSupply() + Agricoin(token).totalSupplyOnIco();supply >= 1500000 * decimals;Agricoin(token).mint(bounty,300000 * decimals,true);supply >= 1150000 * decimals;;Agricoin(token).mint(bounty,200000 * decimals,true);supply >= 800000 * decimals;;Agricoin(token).mint(bounty,100000 * decimals,true);;Agricoin(token).activate(true);End(true);msg.sender.transfer(msg.value);;Agricoin(token).activate(false);msg.sender.transfer(msg.value);End(false);;require(bool)(investedSumOnPreIco / preIcoPrice < preIcoTarget);isRunningIco(now);(investedSumOnPreIco + msg.value) / preIcoPrice >= preIcoTarget;value = preIcoTarget * preIcoPrice - investedSumOnPreIco;rest = msg.value % preIcoPrice;require(bool)(value != 0);investedSumOnPreIco = preIcoTarget * preIcoPrice;investedOnPreIco[msg.sender] += value;Invested(msg.sender,value);Agricoin(token).mint(msg.sender,value / preIcoPrice,false);msg.sender.transfer(msg.value - value);;require(bool)(msg.value - rest >= preIcoPrice);investedSumOnPreIco += msg.value - rest;investedOnPreIco[msg.sender] += msg.value - rest;Invested(msg.sender,msg.value - rest);Agricoin(token).mint(msg.sender,msg.value / preIcoPrice,false);msg.sender.transfer(rest);;require(bool)(investedSumOnIco / icoPrice < icoTarget);revert()();(investedSumOnIco + msg.value) / icoPrice >= icoTarget;value = icoTarget * icoPrice - investedSumOnIco;rest = msg.value % icoPrice;require(bool)(value != 0);investedSumOnIco = icoTarget * icoPrice;invested[msg.sender] += value;Invested(msg.sender,value);Agricoin(token).mint(msg.sender,value / icoPrice,true);msg.sender.transfer(msg.value - value);;require(bool)(msg.value - rest >= icoPrice);investedSumOnIco += msg.value - rest;invested[msg.sender] += msg.value - rest;Invested(msg.sender,msg.value - rest);Agricoin(token).mint(msg.sender,msg.value / icoPrice,true);msg.sender.transfer(rest);;;;"
./0x6f59c5e4a98bbeca595cd8f44d4ae6c1f055edbc_ext.sol,PiperToken.fallback,114,120,"TMP_39(bool) = block.timestamp > endICO,CONDITION TMP_39,TMP_40(None) = SOLIDITY_CALL revert(string)(ICO OVER),REF_9(uint256) -> balances[msg.sender],REF_10(uint256) -> balances[msg.sender],TMP_41(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(msg.value,exchange),TMP_42(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_10,TMP_41),REF_9(uint256) (->balances) := TMP_42(uint256),TMP_43(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(msg.value,exchange),TMP_44(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(totalSupply,TMP_43),totalSupply(uint256) := TMP_44(uint256),TMP_45 = CONVERT this to address,TMP_46(uint256) = SOLIDITY_CALL balance(address)(TMP_45),Transfer dest:admin value:TMP_46","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
block.timestamp > endICO

IRs:
TMP_39(bool) = block.timestamp > endICO
CONDITION TMP_39""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert(string)(ICO OVER)

IRs:
TMP_40(None) = SOLIDITY_CALL revert(string)(ICO OVER)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[msg.sender] = safeAdd(balances[msg.sender],safeMul(msg.value,exchange))

IRs:
REF_9(uint256) -> balances[msg.sender]
REF_10(uint256) -> balances[msg.sender]
TMP_41(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(msg.value,exchange)
TMP_42(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(REF_10,TMP_41)
REF_9(uint256) (->balances) := TMP_42(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalSupply = safeAdd(totalSupply,safeMul(msg.value,exchange))

IRs:
TMP_43(uint256) = INTERNAL_CALL, SafeMath.safeMul(uint256,uint256)(msg.value,exchange)
TMP_44(uint256) = INTERNAL_CALL, SafeMath.safeAdd(uint256,uint256)(totalSupply,TMP_43)
totalSupply(uint256) := TMP_44(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
admin.transfer(address(this).balance)

IRs:
TMP_45 = CONVERT this to address
TMP_46(uint256) = SOLIDITY_CALL balance(address)(TMP_45)
Transfer dest:admin value:TMP_46""];
}
",0,0,1,0,"block.timestamp > endICO;revert(string)(ICO OVER);;balances[msg.sender] = safeAdd(balances[msg.sender],safeMul(msg.value,exchange));totalSupply = safeAdd(totalSupply,safeMul(msg.value,exchange));admin.transfer(address(this).balance)"
./0x6543cde961213e82001594bf4c34706579ce34ec_ext.sol,ClinicAllRefundEscrow.withdraw,1015,1036,"TMP_428(bool) = INTERNAL_CALL, RefundEscrow.withdrawalAllowed(address)(_payee),TMP_429(None) = SOLIDITY_CALL require(bool)(TMP_428),INTERNAL_CALL, Escrow.withdraw(address)(_payee)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(withdrawalAllowed(_payee))

IRs:
TMP_428(bool) = INTERNAL_CALL, RefundEscrow.withdrawalAllowed(address)(_payee)
TMP_429(None) = SOLIDITY_CALL require(bool)(TMP_428)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
super.withdraw(_payee)

IRs:
INTERNAL_CALL, Escrow.withdraw(address)(_payee)""];
}
",0,0,1,0,require(bool)(withdrawalAllowed(_payee));super.withdraw(_payee)
./0x1807cf924199c0f8a85b73c15b5c0349aa3844e5_ext.sol,PublickOffering.backETH,113,120,"REF_7(PublickOffering.investorInfo) -> bills[pos],REF_8(bool) -> REF_7.hadback,TMP_22 = UnaryType.BANG REF_8 ,CONDITION TMP_22,TMP_23(bool) = pos < lastAccountNum,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),REF_9(PublickOffering.investorInfo) -> bills[pos],REF_10(address) -> REF_9.investor,REF_12(PublickOffering.investorInfo) -> bills[pos],REF_13(uint256) -> REF_12.amount,Transfer dest:REF_10 value:REF_13,REF_14(PublickOffering.investorInfo) -> bills[pos],REF_15(bool) -> REF_14.hadback,REF_15(bool) (->bills) := True(bool),REF_16(PublickOffering.investorInfo) -> bills[pos],REF_17(address) -> REF_16.investor,REF_18(PublickOffering.investorInfo) -> bills[pos],REF_19(uint256) -> REF_18.amount,Emit Back(REF_17,REF_19,now),MODIFIER_CALL, Authority.onlyBeneficiary()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: IF 1

EXPRESSION:
! bills[pos].hadback

IRs:
REF_7(PublickOffering.investorInfo) -> bills[pos]
REF_8(bool) -> REF_7.hadback
TMP_22 = UnaryType.BANG REF_8 
CONDITION TMP_22""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(pos < lastAccountNum)

IRs:
TMP_23(bool) = pos < lastAccountNum
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
bills[pos].investor.transfer(bills[pos].amount)

IRs:
REF_9(PublickOffering.investorInfo) -> bills[pos]
REF_10(address) -> REF_9.investor
REF_12(PublickOffering.investorInfo) -> bills[pos]
REF_13(uint256) -> REF_12.amount
Transfer dest:REF_10 value:REF_13""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
bills[pos].hadback = true

IRs:
REF_14(PublickOffering.investorInfo) -> bills[pos]
REF_15(bool) -> REF_14.hadback
REF_15(bool) (->bills) := True(bool)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Back(bills[pos].investor,bills[pos].amount,now)

IRs:
REF_16(PublickOffering.investorInfo) -> bills[pos]
REF_17(address) -> REF_16.investor
REF_18(PublickOffering.investorInfo) -> bills[pos]
REF_19(uint256) -> REF_18.amount
Emit Back(REF_17,REF_19,now)""];
5->6;
6[label=""Node Type: END_IF 6
""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyBeneficiary()

IRs:
MODIFIER_CALL, Authority.onlyBeneficiary()()""];
7->1;
}
",0,0,1,0,"onlyBeneficiary();! bills[pos].hadback;require(bool)(pos < lastAccountNum);;bills[pos].investor.transfer(bills[pos].amount);bills[pos].hadback = true;Back(bills[pos].investor,bills[pos].amount,now)"
./0x375fe03d186747e455e4ebbc235e9df083c7fe92_ext.sol,QUEST_X.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x00f90986cdd79744409f8a3c7747064afa4473b5_ext.sol,SmartBillions.pay,365,380,"REF_103(uint256) = SOLIDITY_CALL balance(address)(this),TMP_170([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B8EB7D30>]) = REF_103 / 2,maxpay(uint256) := TMP_170([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B8EB7D30>]),TMP_171(bool) = maxpay >= _amount,CONDITION TMP_171,Transfer dest:msg.sender value:_amount,TMP_173(bool) = _amount > 1000000000000000,CONDITION TMP_173,INTERNAL_CALL, SmartBillions.houseKeeping()(),TMP_175(uint256) = _amount - maxpay,keepbalance(uint256) := TMP_175(uint256),walletBalance(uint256) = walletBalance + keepbalance,REF_105(SmartBillions.Wallet) -> wallets[msg.sender],REF_106(uint208) -> REF_105.balance,TMP_176 = CONVERT keepbalance to uint208,REF_106(-> wallets) = REF_106 + TMP_176,REF_107(SmartBillions.Wallet) -> wallets[msg.sender],REF_108(uint32) -> REF_107.nextWithdrawBlock,TMP_177(uint256) = 4 * 60,TMP_178(uint256) = TMP_177 * 24,TMP_179(uint256) = TMP_178 * 30,TMP_180(uint256) = block.number + TMP_179,TMP_181 = CONVERT TMP_180 to uint32,REF_108(uint32) (->wallets) := TMP_181(uint32),Transfer dest:msg.sender value:maxpay","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
maxpay = this.balance / 2

IRs:
REF_103(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_170([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B8EB7D30>]) = REF_103 / 2
maxpay(uint256) := TMP_170([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B8EB7D30>])""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
maxpay >= _amount

IRs:
TMP_171(bool) = maxpay >= _amount
CONDITION TMP_171""];
2->3[label=""True""];
2->7[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(_amount)

IRs:
Transfer dest:msg.sender value:_amount""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
_amount > 1000000000000000

IRs:
TMP_173(bool) = _amount > 1000000000000000
CONDITION TMP_173""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
houseKeeping()

IRs:
INTERNAL_CALL, SmartBillions.houseKeeping()()""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->12;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
keepbalance = _amount - maxpay

IRs:
TMP_175(uint256) = _amount - maxpay
keepbalance(uint256) := TMP_175(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
walletBalance += keepbalance

IRs:
walletBalance(uint256) = walletBalance + keepbalance""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
wallets[msg.sender].balance += uint208(keepbalance)

IRs:
REF_105(SmartBillions.Wallet) -> wallets[msg.sender]
REF_106(uint208) -> REF_105.balance
TMP_176 = CONVERT keepbalance to uint208
REF_106(-> wallets) = REF_106 + TMP_176""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30)

IRs:
REF_107(SmartBillions.Wallet) -> wallets[msg.sender]
REF_108(uint32) -> REF_107.nextWithdrawBlock
TMP_177(uint256) = 4 * 60
TMP_178(uint256) = TMP_177 * 24
TMP_179(uint256) = TMP_178 * 30
TMP_180(uint256) = block.number + TMP_179
TMP_181 = CONVERT TMP_180 to uint32
REF_108(uint32) (->wallets) := TMP_181(uint32)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
msg.sender.transfer(maxpay)

IRs:
Transfer dest:msg.sender value:maxpay""];
11->12;
12[label=""Node Type: END_IF 12
""];
}
",0,0,1,0,maxpay = this.balance / 2;maxpay >= _amount;msg.sender.transfer(_amount);keepbalance = _amount - maxpay;_amount > 1000000000000000;houseKeeping();;;walletBalance += keepbalance;wallets[msg.sender].balance += uint208(keepbalance);wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30);msg.sender.transfer(maxpay)
./0x3a966ffa8451cbf3769b7d1f94d5b47da254edb0_ext.sol,Play0x_LottoBall.sendFundsToManager,856,862,"TMP_457 = SEND dest:manager value:amount,CONDITION TMP_457,Emit ToManagerPayment(manager,amount),Emit ToManagerFailedPayment(manager,amount),MODIFIER_CALL, Play0x_LottoBall.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
manager.send(amount)

IRs:
TMP_457 = SEND dest:manager value:amount
CONDITION TMP_457""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ToManagerPayment(manager,amount)

IRs:
Emit ToManagerPayment(manager,amount)""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ToManagerFailedPayment(manager,amount)

IRs:
Emit ToManagerFailedPayment(manager,amount)""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Play0x_LottoBall.onlyOwner()()""];
5->1;
}
",0,0,1,0,"onlyOwner();manager.send(amount);ToManagerPayment(manager,amount);ToManagerFailedPayment(manager,amount);"
./0x548d32216d01617452892ea360bfce9ce8dc9729_ext.sol,ChemistryCore.withdrawAll,560,562,"REF_164(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:owner value:REF_164,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(this.balance)

IRs:
REF_164(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:owner value:REF_164""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();owner.transfer(this.balance)
./0xedde8f9b753ae899794f09756e11999cf54c82c5_ext.sol,EncryptedToken.fallback,156,160,"TMP_85 = SEND dest:owner value:msg.value,TMP_86(uint256) = msg.value * buyPrice,amount(uint256) := TMP_86(uint256),INTERNAL_CALL, EncryptedToken._transfer(address,address,uint256)(owner,msg.sender,amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.send(msg.value)

IRs:
TMP_85 = SEND dest:owner value:msg.value""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = msg.value * buyPrice

IRs:
TMP_86(uint256) = msg.value * buyPrice
amount(uint256) := TMP_86(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_transfer(owner,msg.sender,amount)

IRs:
INTERNAL_CALL, EncryptedToken._transfer(address,address,uint256)(owner,msg.sender,amount)""];
}
",0,0,1,0,"owner.send(msg.value);amount = msg.value * buyPrice;_transfer(owner,msg.sender,amount)"
./0xa44fb3aa5c8465512b806145a8f9b60e74f3f851_ext.sol,PITSTOP.withdrawAll,288,292,"myAddress(address) := this(address),TMP_138(uint256) = SOLIDITY_CALL balance(address)(myAddress),etherBalance(uint256) := TMP_138(uint256),Transfer dest:owner value:etherBalance,MODIFIER_CALL, PITSTOP.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
myAddress = this

IRs:
myAddress(address) := this(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
etherBalance = myAddress.balance

IRs:
TMP_138(uint256) = SOLIDITY_CALL balance(address)(myAddress)
etherBalance(uint256) := TMP_138(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(etherBalance)

IRs:
Transfer dest:owner value:etherBalance""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, PITSTOP.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();myAddress = this;etherBalance = myAddress.balance;owner.transfer(etherBalance)
./0x361f5a02be315ed1241d8c2997d1fc35aaa27596_ext.sol,DinarETHCrypto.fallback,114,118,"REF_1(uint256) = SOLIDITY_CALL balance(address)(this),TMP_13(bool) = REF_1 > 1000000000000000000,CONDITION TMP_13,REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:owner value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
this.balance > 1000000000000000000

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_13(bool) = REF_1 > 1000000000000000000
CONDITION TMP_13""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:owner value:REF_3""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,0,1,0,this.balance > 1000000000000000000;owner.transfer(this.balance);
./0x70bf9df6967dc96156e76cc43b928a7ef02e159a_ext.sol,X_GAME.Play,5,14,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0xeca7f8aa63d1d28fafda5fdf021388b5d7166dee_ext.sol,TryToPlay.Try,5,12,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x29c690419841e126b74981e4709e43916ac80f64_ext.sol,QQ_game.Stop,28,30,"REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3,MODIFIER_CALL, QQ_game.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, QQ_game.isAdmin()()""];
2->1;
}
",0,0,1,0,isAdmin();msg.sender.transfer(this.balance)
./0x4cf6e4b46d58d17bc51c6752381ae7d4149b04eb_ext.sol,OXO.getEth,119,127,"TMP_27(bool) = _price > 0,CONDITION TMP_27,TMP_28 = CONVERT this to address,TMP_29(uint256) = SOLIDITY_CALL balance(address)(TMP_28),TMP_30(bool) = TMP_29 >= _price,CONDITION TMP_30,Transfer dest:owner value:_price,TMP_32 = CONVERT this to address,TMP_33(uint256) = SOLIDITY_CALL balance(address)(TMP_32),Transfer dest:owner value:TMP_33,MODIFIER_CALL, OXO.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: IF 1

EXPRESSION:
_price > 0

IRs:
TMP_27(bool) = _price > 0
CONDITION TMP_27""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
address(this).balance >= _price

IRs:
TMP_28 = CONVERT this to address
TMP_29(uint256) = SOLIDITY_CALL balance(address)(TMP_28)
TMP_30(bool) = TMP_29 >= _price
CONDITION TMP_30""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_price)

IRs:
Transfer dest:owner value:_price""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->6;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_32 = CONVERT this to address
TMP_33(uint256) = SOLIDITY_CALL balance(address)(TMP_32)
Transfer dest:owner value:TMP_33""];
5->6;
6[label=""Node Type: END_IF 6
""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, OXO.onlyOwner()()""];
7->1;
}
",0,0,1,0,onlyOwner();_price > 0;address(this).balance >= _price;owner.transfer(address(this).balance);owner.transfer(_price);;
./0x479cbe1f6a7fa4d7e304ae983803c46e85ced870_ext.sol,Slaughter3D.withdraw,268,280,"INTERNAL_CALL, Slaughter3D.tryFinalizeStage()(),REF_46(uint256) -> playerVault[msg.sender],amount(uint256) := REF_46(uint256),REF_47(uint256) -> playerVault[msg.sender],REF_47(uint256) (->playerVault) := 0(uint256),Emit EarningsWithdrawn(msg.sender,amount),Transfer dest:msg.sender value:amount,MODIFIER_CALL, Slaughter3D.hasEarnings()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
tryFinalizeStage()

IRs:
INTERNAL_CALL, Slaughter3D.tryFinalizeStage()()""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = playerVault[msg.sender]

IRs:
REF_46(uint256) -> playerVault[msg.sender]
amount(uint256) := REF_46(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
playerVault[msg.sender] = 0

IRs:
REF_47(uint256) -> playerVault[msg.sender]
REF_47(uint256) (->playerVault) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
EarningsWithdrawn(msg.sender,amount)

IRs:
Emit EarningsWithdrawn(msg.sender,amount)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
hasEarnings()

IRs:
MODIFIER_CALL, Slaughter3D.hasEarnings()()""];
6->1;
}
",0,0,1,0,"hasEarnings();tryFinalizeStage();amount = playerVault[msg.sender];playerVault[msg.sender] = 0;EarningsWithdrawn(msg.sender,amount);msg.sender.transfer(amount)"
./0x5576250692275701efde5eeb51596e2d9460790b_ext.sol,UserDataManager.registerNameCore,244,260,"REF_46(uint256) -> pIDxName_[_name],TMP_49(bool) = REF_46 != 0,CONDITION TMP_49,REF_47(uint256) -> pIDxName_[_name],TMP_50(bool) = REF_47 == _pID,TMP_51(None) = SOLIDITY_CALL require(bool,string)(TMP_50,sorry that names already taken),REF_48(UserDataManager.Player) -> plyr_[_pID],REF_49(bytes32) -> REF_48.name,REF_49(bytes32) (->plyr_) := _name(bytes32),REF_50(uint256) -> pIDxName_[_name],REF_50(uint256) (->pIDxName_) := _pID(uint256),TMP_52 = CONVERT this to address,TMP_53(uint256) = SOLIDITY_CALL balance(address)(TMP_52),Transfer dest:admin value:TMP_53,TMP_55(bool) = _all == True,CONDITION TMP_55,i(uint256) := 1(uint256),TMP_56(bool) = i <= gID_,CONDITION TMP_56,REF_52(UserDataManagerReceiverInterface) -> games_[i],HIGH_LEVEL_CALL, dest:REF_52(UserDataManagerReceiverInterface), function:receivePlayerInfo, arguments:['_pID', '_addr', '_name', '_affID']  ,TMP_58(uint256) := i(uint256),i(uint256) = i + 1,REF_54(UserDataManager.Player) -> plyr_[_affID],REF_55(address) -> REF_54.addr,REF_56(UserDataManager.Player) -> plyr_[_affID],REF_57(bytes32) -> REF_56.name,Emit onNewPlayer(_pID,_addr,_name,_isNewPlayer,_affID,REF_55,REF_57,msg.value,now)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
pIDxName_[_name] != 0

IRs:
REF_46(uint256) -> pIDxName_[_name]
TMP_49(bool) = REF_46 != 0
CONDITION TMP_49""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(pIDxName_[_name] == _pID,sorry that names already taken)

IRs:
REF_47(uint256) -> pIDxName_[_name]
TMP_50(bool) = REF_47 == _pID
TMP_51(None) = SOLIDITY_CALL require(bool,string)(TMP_50,sorry that names already taken)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
plyr_[_pID].name = _name

IRs:
REF_48(UserDataManager.Player) -> plyr_[_pID]
REF_49(bytes32) -> REF_48.name
REF_49(bytes32) (->plyr_) := _name(bytes32)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
pIDxName_[_name] = _pID

IRs:
REF_50(uint256) -> pIDxName_[_name]
REF_50(uint256) (->pIDxName_) := _pID(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
admin.transfer(address(this).balance)

IRs:
TMP_52 = CONVERT this to address
TMP_53(uint256) = SOLIDITY_CALL balance(address)(TMP_52)
Transfer dest:admin value:TMP_53""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
_all == true

IRs:
TMP_55(bool) = _all == True
CONDITION TMP_55""];
7->10[label=""True""];
7->14[label=""False""];
8[label=""Node Type: BEGIN_LOOP 8
""];
8->11;
9[label=""Node Type: END_LOOP 9
""];
9->14;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
i = 1

IRs:
i(uint256) := 1(uint256)""];
10->8;
11[label=""Node Type: IF_LOOP 11

EXPRESSION:
i <= gID_

IRs:
TMP_56(bool) = i <= gID_
CONDITION TMP_56""];
11->12[label=""True""];
11->9[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
games_[i].receivePlayerInfo(_pID,_addr,_name,_affID)

IRs:
REF_52(UserDataManagerReceiverInterface) -> games_[i]
HIGH_LEVEL_CALL, dest:REF_52(UserDataManagerReceiverInterface), function:receivePlayerInfo, arguments:['_pID', '_addr', '_name', '_affID']  ""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
i ++

IRs:
TMP_58(uint256) := i(uint256)
i(uint256) = i + 1""];
13->11;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
onNewPlayer(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,msg.value,now)

IRs:
REF_54(UserDataManager.Player) -> plyr_[_affID]
REF_55(address) -> REF_54.addr
REF_56(UserDataManager.Player) -> plyr_[_affID]
REF_57(bytes32) -> REF_56.name
Emit onNewPlayer(_pID,_addr,_name,_isNewPlayer,_affID,REF_55,REF_57,msg.value,now)""];
}
",0,0,1,0,"pIDxName_[_name] != 0;require(bool,string)(pIDxName_[_name] == _pID,sorry that names already taken);;plyr_[_pID].name = _name;pIDxName_[_name] = _pID;admin.transfer(address(this).balance);_all == true;i = 1;;;i <= gID_;;games_[i].receivePlayerInfo(_pID,_addr,_name,_affID);i ++;onNewPlayer(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,msg.value,now)"
./0x56e0dc284a913f7c1198c83f7c69bfec36d31eed_ext.sol,NKYS.withdraw,281,284,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, NKYS.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, NKYS.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.adminRetrieveContractConfig2,2,2,"RETURN mineth,minsignupeth,wallet,startTimes,endTimes,userSignupCount,MODIFIER_CALL, KahnDistributionCentre.onlyStaffs()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: RETURN 1

EXPRESSION:
(mineth,minsignupeth,wallet,startTimes,endTimes,userSignupCount)

IRs:
RETURN mineth,minsignupeth,wallet,startTimes,endTimes,userSignupCount""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyStaffs()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyStaffs()()""];
2->1;
}
",0,1,1,0,"onlyStaffs();(mineth,minsignupeth,wallet,startTimes,endTimes,userSignupCount)"
./0x0114289efe38186b732d12c07a1ce4341e266513_ext.sol,PreICO.forwardFunds,436,438,Transfer dest:wallet value:value,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
wallet.transfer(value)

IRs:
Transfer dest:wallet value:value""];
}
",0,0,1,0,wallet.transfer(value)
./0xb42359b3aee091fd4a2fb798bf6a8839c7902ed3_ext.sol,ButterCoin.getTokens,187,246,"tokens(uint256) := 0(uint256),bonus(uint256) := 0(uint256),countbonus(uint256) := 0(uint256),TMP_45(uint256) = 10000000000000000000 / 10,bonusCond1(uint256) := TMP_45(uint256),bonusCond2(uint256) := 10000000000000000000(uint256),bonusCond3(uint256) := 50000000000000000000(uint256),TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_47(uint256) = TMP_46 / 1000000000000000000,tokens(uint256) := TMP_47(uint256),investor(address) := msg.sender(address),TMP_48(bool) = msg.value >= requestMinimum,TMP_49(bool) = now < deadline,TMP_50(bool) = TMP_48 && TMP_49,TMP_51(bool) = now < round1,TMP_52(bool) = TMP_50 && TMP_51,TMP_53(bool) = now < round2,TMP_54(bool) = TMP_52 && TMP_53,CONDITION TMP_54,TMP_55(bool) = msg.value >= bonusCond1,TMP_56(bool) = msg.value < bonusCond2,TMP_57(bool) = TMP_55 && TMP_56,CONDITION TMP_57,TMP_58(uint256) = tokens * 0,TMP_59(uint256) = TMP_58 / 100,countbonus(uint256) := TMP_59(uint256),TMP_60(bool) = msg.value >= bonusCond2,TMP_61(bool) = msg.value < bonusCond3,TMP_62(bool) = TMP_60 && TMP_61,CONDITION TMP_62,TMP_63(uint256) = tokens * 20,TMP_64(uint256) = TMP_63 / 100,countbonus(uint256) := TMP_64(uint256),TMP_65(bool) = msg.value >= bonusCond3,CONDITION TMP_65,TMP_66(uint256) = tokens * 35,TMP_67(uint256) = TMP_66 / 100,countbonus(uint256) := TMP_67(uint256),TMP_68(bool) = msg.value >= requestMinimum,TMP_69(bool) = now < deadline,TMP_70(bool) = TMP_68 && TMP_69,TMP_71(bool) = now > round1,TMP_72(bool) = TMP_70 && TMP_71,TMP_73(bool) = now < round2,TMP_74(bool) = TMP_72 && TMP_73,CONDITION TMP_74,TMP_75(bool) = msg.value >= bonusCond2,TMP_76(bool) = msg.value < bonusCond3,TMP_77(bool) = TMP_75 && TMP_76,CONDITION TMP_77,TMP_78(uint256) = tokens * 20,TMP_79(uint256) = TMP_78 / 100,countbonus(uint256) := TMP_79(uint256),TMP_80(bool) = msg.value >= bonusCond3,CONDITION TMP_80,TMP_81(uint256) = tokens * 35,TMP_82(uint256) = TMP_81 / 100,countbonus(uint256) := TMP_82(uint256),countbonus(uint256) := 0(uint256),TMP_83(uint256) = tokens + countbonus,bonus(uint256) := TMP_83(uint256),TMP_84(bool) = tokens == 0,CONDITION TMP_84,valdrop(uint256) := 3000000000(uint256),REF_12(bool) -> Claimed[investor],TMP_85(bool) = REF_12 == False,TMP_86(bool) = progress0drop <= target0drop,TMP_87(bool) = TMP_85 && TMP_86,CONDITION TMP_87,TMP_88(bool) = INTERNAL_CALL, ButterCoin.distr(address,uint256)(investor,valdrop),REF_13(bool) -> Claimed[investor],REF_13(bool) (->Claimed) := True(bool),TMP_89(uint256) := progress0drop(uint256),progress0drop(uint256) = progress0drop + 1,TMP_90(bool) = msg.value >= requestMinimum,TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),TMP_92(bool) = tokens > 0,TMP_93(bool) = msg.value >= requestMinimum,TMP_94(bool) = TMP_92 && TMP_93,CONDITION TMP_94,TMP_95(bool) = now >= deadline,TMP_96(bool) = now >= round1,TMP_97(bool) = TMP_95 && TMP_96,TMP_98(bool) = now < round2,TMP_99(bool) = TMP_97 && TMP_98,CONDITION TMP_99,TMP_100(bool) = INTERNAL_CALL, ButterCoin.distr(address,uint256)(investor,tokens),TMP_101(bool) = msg.value >= bonusCond1,CONDITION TMP_101,TMP_102(bool) = INTERNAL_CALL, ButterCoin.distr(address,uint256)(investor,bonus),TMP_103(bool) = INTERNAL_CALL, ButterCoin.distr(address,uint256)(investor,tokens),TMP_104(bool) = msg.value >= requestMinimum,TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104),TMP_106(bool) = totalDistributed >= totalSupply,CONDITION TMP_106,distributionFinished(bool) := True(bool),Transfer dest:multisig value:msg.value,MODIFIER_CALL, ButterCoin.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->53;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bonusCond1 = 10000000000000000000 / 10

IRs:
TMP_45(uint256) = 10000000000000000000 / 10
bonusCond1(uint256) := TMP_45(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bonusCond2 = 10000000000000000000

IRs:
bonusCond2(uint256) := 10000000000000000000(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
bonusCond3 = 50000000000000000000

IRs:
bonusCond3(uint256) := 50000000000000000000(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_47(uint256) = TMP_46 / 1000000000000000000
tokens(uint256) := TMP_47(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now < round1 && now < round2

IRs:
TMP_48(bool) = msg.value >= requestMinimum
TMP_49(bool) = now < deadline
TMP_50(bool) = TMP_48 && TMP_49
TMP_51(bool) = now < round1
TMP_52(bool) = TMP_50 && TMP_51
TMP_53(bool) = now < round2
TMP_54(bool) = TMP_52 && TMP_53
CONDITION TMP_54""];
9->10[label=""True""];
9->19[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
msg.value >= bonusCond1 && msg.value < bonusCond2

IRs:
TMP_55(bool) = msg.value >= bonusCond1
TMP_56(bool) = msg.value < bonusCond2
TMP_57(bool) = TMP_55 && TMP_56
CONDITION TMP_57""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
countbonus = tokens * 0 / 100

IRs:
TMP_58(uint256) = tokens * 0
TMP_59(uint256) = TMP_58 / 100
countbonus(uint256) := TMP_59(uint256)""];
11->18;
12[label=""Node Type: IF 12

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_60(bool) = msg.value >= bonusCond2
TMP_61(bool) = msg.value < bonusCond3
TMP_62(bool) = TMP_60 && TMP_61
CONDITION TMP_62""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
countbonus = tokens * 20 / 100

IRs:
TMP_63(uint256) = tokens * 20
TMP_64(uint256) = TMP_63 / 100
countbonus(uint256) := TMP_64(uint256)""];
13->17;
14[label=""Node Type: IF 14

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_65(bool) = msg.value >= bonusCond3
CONDITION TMP_65""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
countbonus = tokens * 35 / 100

IRs:
TMP_66(uint256) = tokens * 35
TMP_67(uint256) = TMP_66 / 100
countbonus(uint256) := TMP_67(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->28;
19[label=""Node Type: IF 19

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now > round1 && now < round2

IRs:
TMP_68(bool) = msg.value >= requestMinimum
TMP_69(bool) = now < deadline
TMP_70(bool) = TMP_68 && TMP_69
TMP_71(bool) = now > round1
TMP_72(bool) = TMP_70 && TMP_71
TMP_73(bool) = now < round2
TMP_74(bool) = TMP_72 && TMP_73
CONDITION TMP_74""];
19->20[label=""True""];
19->26[label=""False""];
20[label=""Node Type: IF 20

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_75(bool) = msg.value >= bonusCond2
TMP_76(bool) = msg.value < bonusCond3
TMP_77(bool) = TMP_75 && TMP_76
CONDITION TMP_77""];
20->21[label=""True""];
20->22[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
countbonus = tokens * 20 / 100

IRs:
TMP_78(uint256) = tokens * 20
TMP_79(uint256) = TMP_78 / 100
countbonus(uint256) := TMP_79(uint256)""];
21->25;
22[label=""Node Type: IF 22

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_80(bool) = msg.value >= bonusCond3
CONDITION TMP_80""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
countbonus = tokens * 35 / 100

IRs:
TMP_81(uint256) = tokens * 35
TMP_82(uint256) = TMP_81 / 100
countbonus(uint256) := TMP_82(uint256)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->27;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
bonus = tokens + countbonus

IRs:
TMP_83(uint256) = tokens + countbonus
bonus(uint256) := TMP_83(uint256)""];
29->30;
30[label=""Node Type: IF 30

EXPRESSION:
tokens == 0

IRs:
TMP_84(bool) = tokens == 0
CONDITION TMP_84""];
30->31[label=""True""];
30->38[label=""False""];
31[label=""Node Type: NEW VARIABLE 31

EXPRESSION:
valdrop = 30e8

IRs:
valdrop(uint256) := 3000000000(uint256)""];
31->32;
32[label=""Node Type: IF 32

EXPRESSION:
Claimed[investor] == false && progress0drop <= target0drop

IRs:
REF_12(bool) -> Claimed[investor]
TMP_85(bool) = REF_12 == False
TMP_86(bool) = progress0drop <= target0drop
TMP_87(bool) = TMP_85 && TMP_86
CONDITION TMP_87""];
32->33[label=""True""];
32->36[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
distr(investor,valdrop)

IRs:
TMP_88(bool) = INTERNAL_CALL, ButterCoin.distr(address,uint256)(investor,valdrop)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
Claimed[investor] = true

IRs:
REF_13(bool) -> Claimed[investor]
REF_13(bool) (->Claimed) := True(bool)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
progress0drop ++

IRs:
TMP_89(uint256) := progress0drop(uint256)
progress0drop(uint256) = progress0drop + 1""];
35->37;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_90(bool) = msg.value >= requestMinimum
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
36->37;
37[label=""Node Type: END_IF 37
""];
37->48;
38[label=""Node Type: IF 38

EXPRESSION:
tokens > 0 && msg.value >= requestMinimum

IRs:
TMP_92(bool) = tokens > 0
TMP_93(bool) = msg.value >= requestMinimum
TMP_94(bool) = TMP_92 && TMP_93
CONDITION TMP_94""];
38->39[label=""True""];
38->46[label=""False""];
39[label=""Node Type: IF 39

EXPRESSION:
now >= deadline && now >= round1 && now < round2

IRs:
TMP_95(bool) = now >= deadline
TMP_96(bool) = now >= round1
TMP_97(bool) = TMP_95 && TMP_96
TMP_98(bool) = now < round2
TMP_99(bool) = TMP_97 && TMP_98
CONDITION TMP_99""];
39->40[label=""True""];
39->41[label=""False""];
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_100(bool) = INTERNAL_CALL, ButterCoin.distr(address,uint256)(investor,tokens)""];
40->45;
41[label=""Node Type: IF 41

EXPRESSION:
msg.value >= bonusCond1

IRs:
TMP_101(bool) = msg.value >= bonusCond1
CONDITION TMP_101""];
41->42[label=""True""];
41->43[label=""False""];
42[label=""Node Type: EXPRESSION 42

EXPRESSION:
distr(investor,bonus)

IRs:
TMP_102(bool) = INTERNAL_CALL, ButterCoin.distr(address,uint256)(investor,bonus)""];
42->44;
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_103(bool) = INTERNAL_CALL, ButterCoin.distr(address,uint256)(investor,tokens)""];
43->44;
44[label=""Node Type: END_IF 44
""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->47;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_104(bool) = msg.value >= requestMinimum
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: IF 49

EXPRESSION:
totalDistributed >= totalSupply

IRs:
TMP_106(bool) = totalDistributed >= totalSupply
CONDITION TMP_106""];
49->50[label=""True""];
49->51[label=""False""];
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
multisig.transfer(msg.value)

IRs:
Transfer dest:multisig value:msg.value""];
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, ButterCoin.canDistr()()""];
53->1;
}
",0,0,1,0,"canDistr();tokens = 0;bonus = 0;countbonus = 0;bonusCond1 = 10000000000000000000 / 10;bonusCond2 = 10000000000000000000;bonusCond3 = 50000000000000000000;tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;investor = msg.sender;msg.value >= requestMinimum && now < deadline && now < round1 && now < round2;msg.value >= bonusCond1 && msg.value < bonusCond2;msg.value >= requestMinimum && now < deadline && now > round1 && now < round2;countbonus = tokens * 0 / 100;msg.value >= bonusCond2 && msg.value < bonusCond3;;countbonus = tokens * 20 / 100;msg.value >= bonusCond3;;countbonus = tokens * 35 / 100;;;msg.value >= bonusCond2 && msg.value < bonusCond3;countbonus = 0;countbonus = tokens * 20 / 100;msg.value >= bonusCond3;;countbonus = tokens * 35 / 100;;;bonus = tokens + countbonus;tokens == 0;valdrop = 30e8;tokens > 0 && msg.value >= requestMinimum;Claimed[investor] == false && progress0drop <= target0drop;distr(investor,valdrop);require(bool)(msg.value >= requestMinimum);Claimed[investor] = true;progress0drop ++;;;now >= deadline && now >= round1 && now < round2;require(bool)(msg.value >= requestMinimum);distr(investor,tokens);msg.value >= bonusCond1;;distr(investor,bonus);distr(investor,tokens);;;totalDistributed >= totalSupply;distributionFinished = true;;multisig.transfer(msg.value)"
./0xaa8722fb1c9eec9b6c32a90dbe9aa4c9eff19f55_ext.sol,OrganicumOrders.takeInvest,159,170,"TMP_83(uint256) = endDate + durationVoting,TMP_84(bool) = now >= TMP_83,TMP_85(None) = SOLIDITY_CALL assert(bool)(TMP_84),REF_44(uint256) = SOLIDITY_CALL balance(address)(this),TMP_86(bool) = REF_44 > 0,TMP_87(None) = SOLIDITY_CALL assert(bool)(TMP_86),TMP_88(uint256) = supplyTokensSaved / 2,TMP_89(bool) = sumVote > TMP_88,CONDITION TMP_89,TMP_90(bool) = supplyTokens == 0,TMP_91(None) = SOLIDITY_CALL assert(bool)(TMP_90),REF_46(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:owner value:REF_46,MODIFIER_CALL, OrganicumOrders.isOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(now >= endDate + durationVoting)

IRs:
TMP_83(uint256) = endDate + durationVoting
TMP_84(bool) = now >= TMP_83
TMP_85(None) = SOLIDITY_CALL assert(bool)(TMP_84)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(this.balance > 0)

IRs:
REF_44(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_86(bool) = REF_44 > 0
TMP_87(None) = SOLIDITY_CALL assert(bool)(TMP_86)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
sumVote > supplyTokensSaved / 2

IRs:
TMP_88(uint256) = supplyTokensSaved / 2
TMP_89(bool) = sumVote > TMP_88
CONDITION TMP_89""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
assert(bool)(supplyTokens == 0)

IRs:
TMP_90(bool) = supplyTokens == 0
TMP_91(None) = SOLIDITY_CALL assert(bool)(TMP_90)""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
owner.transfer(this.balance)

IRs:
REF_46(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:owner value:REF_46""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
isOwner()

IRs:
MODIFIER_CALL, OrganicumOrders.isOwner()()""];
7->1;
}
",0,0,1,0,isOwner();assert(bool)(now >= endDate + durationVoting);assert(bool)(this.balance > 0);sumVote > supplyTokensSaved / 2;assert(bool)(supplyTokens == 0);;owner.transfer(this.balance)
./0x6fff3806bbac52a20e0d79bc538d527f6a22c96b_ext.sol,Token.payout,464,467,"TMP_196 = CONVERT 0 to address,TMP_197(bool) = dst != TMP_196,TMP_198(None) = SOLIDITY_CALL require(bool)(TMP_197),REF_18(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:dst value:REF_18,MODIFIER_CALL, Auth.auth()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(dst != address(0))

IRs:
TMP_196 = CONVERT 0 to address
TMP_197(bool) = dst != TMP_196
TMP_198(None) = SOLIDITY_CALL require(bool)(TMP_197)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
dst.transfer(this.balance)

IRs:
REF_18(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:dst value:REF_18""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, Auth.auth()()""];
3->1;
}
",0,0,1,0,auth();require(bool)(dst != address(0));dst.transfer(this.balance)
./0x379f2596d4c4a417ef1023b81c8b9ff5419b13d4_ext.sol,EncryptedToken.selfdestructs,162,164,"TMP_88(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_88(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0x5b39afa22a9debd9247bf84b68a79b8736c2ba4e_ext.sol,Quiz.StopGame,37,44,"TMP_9(bool) = msg.sender == questionSender,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_9(bool) = msg.sender == questionSender
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0xefcc5dcaba4a93046b5f5c24c1281c685154214c_ext.sol,CrypteloPreSale.withdrawAllEther,166,170,"REF_34(bool) -> owners[msg.sender],CONDITION REF_34,REF_36(uint256) = SOLIDITY_CALL balance(address)(this),TMP_42 = SEND dest:msg.sender value:REF_36","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
owners[msg.sender]

IRs:
REF_34(bool) -> owners[msg.sender]
CONDITION REF_34""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.send(this.balance)

IRs:
REF_36(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_42 = SEND dest:msg.sender value:REF_36""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,0,1,0,owners[msg.sender];msg.sender.send(this.balance);
./0x56b7f2a2d6f70d88b991e6c7b8005e0a13a9b379_ext.sol,CryptoCurrencyExchange.safeWithdrawal,304,309,"TMP_97(bool) = _value == 0,CONDITION TMP_97,TMP_98 = CONVERT this to address,TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98),Transfer dest:owner value:TMP_99,Transfer dest:owner value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_97(bool) = _value == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_98 = CONVERT this to address
TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98)
Transfer dest:owner value:TMP_99""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_value == 0;owner.transfer(address(this).balance);owner.transfer(_value);
./0x03a897c8d7d21688ae0a49ea087836b2667c2cc8_ext.sol,RefundVault.refund,628,634,"REF_142(RefundVault.State) -> State.Refunding,TMP_210(bool) = state == REF_142,TMP_211(None) = SOLIDITY_CALL require(bool)(TMP_210),REF_143(uint256) -> deposited[investor],depositedValue(uint256) := REF_143(uint256),REF_144(uint256) -> deposited[investor],REF_144(uint256) (->deposited) := 0(uint256),Transfer dest:investor value:depositedValue,Emit Refunded(investor,depositedValue)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Refunding)

IRs:
REF_142(RefundVault.State) -> State.Refunding
TMP_210(bool) = state == REF_142
TMP_211(None) = SOLIDITY_CALL require(bool)(TMP_210)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
depositedValue = deposited[investor]

IRs:
REF_143(uint256) -> deposited[investor]
depositedValue(uint256) := REF_143(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
deposited[investor] = 0

IRs:
REF_144(uint256) -> deposited[investor]
REF_144(uint256) (->deposited) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
investor.transfer(depositedValue)

IRs:
Transfer dest:investor value:depositedValue""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Refunded(investor,depositedValue)

IRs:
Emit Refunded(investor,depositedValue)""];
}
",0,0,1,0,"require(bool)(state == State.Refunding);depositedValue = deposited[investor];deposited[investor] = 0;investor.transfer(depositedValue);Refunded(investor,depositedValue)"
./0xa2038ce672658f492fcd9e4fdaa1a3c530011a8a_ext.sol,RefundVault.refund,252,258,"REF_41(RefundVault.State) -> State.Refunding,TMP_94(bool) = state == REF_41,TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94),REF_42(uint256) -> deposited[investor],depositedValue(uint256) := REF_42(uint256),REF_43(uint256) -> deposited[investor],REF_43(uint256) (->deposited) := 0(uint256),Transfer dest:investor value:depositedValue,Emit Refunded(investor,depositedValue)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Refunding)

IRs:
REF_41(RefundVault.State) -> State.Refunding
TMP_94(bool) = state == REF_41
TMP_95(None) = SOLIDITY_CALL require(bool)(TMP_94)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
depositedValue = deposited[investor]

IRs:
REF_42(uint256) -> deposited[investor]
depositedValue(uint256) := REF_42(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
deposited[investor] = 0

IRs:
REF_43(uint256) -> deposited[investor]
REF_43(uint256) (->deposited) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
investor.transfer(depositedValue)

IRs:
Transfer dest:investor value:depositedValue""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Refunded(investor,depositedValue)

IRs:
Emit Refunded(investor,depositedValue)""];
}
",0,0,1,0,"require(bool)(state == State.Refunding);depositedValue = deposited[investor];deposited[investor] = 0;investor.transfer(depositedValue);Refunded(investor,depositedValue)"
./0x6f3d1879cd84fa1a7eec7fe936af6a84b67f4567_ext.sol,ERC721dAppCaps.kill,864,866,"TMP_243(bool) = msg.sender == owner,CONDITION TMP_243,TMP_244(None) = SOLIDITY_CALL selfdestruct(address)(owner)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_243(bool) = msg.sender == owner
CONDITION TMP_243""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_244(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,0,1,0,msg.sender == owner;selfdestruct(address)(owner);
./0xd7faef6fd3d3e22037619a756221e38f7f2c9c62_ext.sol,Blogger.withdraw,71,77,"TMP_13(bool) = withdrawalDate < now,TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13),TMP_15 = CONVERT this to address,TMP_16(uint256) = SOLIDITY_CALL balance(address)(TMP_15),Transfer dest:author value:TMP_16,TMP_18(uint256) = now + 2592000,withdrawalDate(uint256) := TMP_18(uint256),MODIFIER_CALL, Blogger.restricted()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(withdrawalDate < now)

IRs:
TMP_13(bool) = withdrawalDate < now
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
author.transfer(address(this).balance)

IRs:
TMP_15 = CONVERT this to address
TMP_16(uint256) = SOLIDITY_CALL balance(address)(TMP_15)
Transfer dest:author value:TMP_16""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
withdrawalDate = now + 2592000

IRs:
TMP_18(uint256) = now + 2592000
withdrawalDate(uint256) := TMP_18(uint256)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
restricted()

IRs:
MODIFIER_CALL, Blogger.restricted()()""];
4->1;
}
",0,0,1,0,restricted();require(bool)(withdrawalDate < now);author.transfer(address(this).balance);withdrawalDate = now + 2592000
./0x50ec4b1f8434020e2d896c9cfb8a20d63af6136d_ext.sol,Snip3D.die,307,309,"TMP_132(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(msg.sender)

IRs:
TMP_132(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(msg.sender)
./0x46d1ebf7bb93044e078e0496e4661ec772607d9d_ext.sol,TTCSale.safeWithdrawal,684,694,"TMP_243 = UnaryType.BANG fundingGoalReached ,CONDITION TMP_243,REF_133(uint256) -> balanceOf[msg.sender],amount(uint256) := REF_133(uint256),REF_134(uint256) -> balanceOf[msg.sender],REF_134(uint256) (->balanceOf) := 0(uint256),TMP_244(bool) = amount > 0,CONDITION TMP_244,Transfer dest:msg.sender value:amount,Emit FundTransfer(msg.sender,amount,False),TMP_247(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['refundAmount', 'amount'] ,refundAmount(uint256) := TMP_247(uint256),MODIFIER_CALL, TTCSale.afterDeadline()(),MODIFIER_CALL, TTCSale.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: IF 1

EXPRESSION:
! fundingGoalReached

IRs:
TMP_243 = UnaryType.BANG fundingGoalReached 
CONDITION TMP_243""];
1->2[label=""True""];
1->9[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = balanceOf[msg.sender]

IRs:
REF_133(uint256) -> balanceOf[msg.sender]
amount(uint256) := REF_133(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[msg.sender] = 0

IRs:
REF_134(uint256) -> balanceOf[msg.sender]
REF_134(uint256) (->balanceOf) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
amount > 0

IRs:
TMP_244(bool) = amount > 0
CONDITION TMP_244""];
4->5[label=""True""];
4->8[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
FundTransfer(msg.sender,amount,false)

IRs:
Emit FundTransfer(msg.sender,amount,False)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
refundAmount = refundAmount.add(amount)

IRs:
TMP_247(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['refundAmount', 'amount'] 
refundAmount(uint256) := TMP_247(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
afterDeadline()

IRs:
MODIFIER_CALL, TTCSale.afterDeadline()()""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, TTCSale.nonReentrant()()""];
11->1;
}
",0,0,1,0,"afterDeadline();! fundingGoalReached;amount = balanceOf[msg.sender];;balanceOf[msg.sender] = 0;amount > 0;msg.sender.transfer(amount);;FundTransfer(msg.sender,amount,false);refundAmount = refundAmount.add(amount);nonReentrant()"
./0xec6ce30daf8195a65c83a29025bd334bc9481ca0_ext.sol,ZeroFeeXchange.Implt,301,304,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, ZeroFeeXchange.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ZeroFeeXchange.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0xe1dbbce4570b815b6ce3434bb3097dc9f453c565_ext.sol,MobiusRED.withdrawDevShare,415,419,"value(uint256) := devBalance(uint256),devBalance(uint256) := 0(uint256),Transfer dest:msg.sender value:value,MODIFIER_CALL, DSAuth.auth()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
value = devBalance

IRs:
value(uint256) := devBalance(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
devBalance = 0

IRs:
devBalance(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(value)

IRs:
Transfer dest:msg.sender value:value""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
4->1;
}
",0,0,1,0,auth();value = devBalance;devBalance = 0;msg.sender.transfer(value)
./0xee58ee0b1519bb47801812a3a9c83ab600c63d81_ext.sol,Destructible.destroyAndSend,110,112,"TMP_26(None) = SOLIDITY_CALL selfdestruct(address)(_recipient),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(_recipient)

IRs:
TMP_26(None) = SOLIDITY_CALL selfdestruct(address)(_recipient)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(_recipient)
./0xeb62b8c5c4f0f5d59a7f060554c13e8f38f4de9f_ext.sol,HODL.get,11,14,"TMP_2 = CONVERT this to address,TMP_3(uint256) = SOLIDITY_CALL balance(address)(TMP_2),TMP_4(bool) = msg.value >= TMP_3,CONDITION TMP_4,TMP_5 = CONVERT this to address,TMP_6(uint256) = SOLIDITY_CALL balance(address)(TMP_5),Transfer dest:msg.sender value:TMP_6","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value >= address(this).balance

IRs:
TMP_2 = CONVERT this to address
TMP_3(uint256) = SOLIDITY_CALL balance(address)(TMP_2)
TMP_4(bool) = msg.value >= TMP_3
CONDITION TMP_4""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_5 = CONVERT this to address
TMP_6(uint256) = SOLIDITY_CALL balance(address)(TMP_5)
Transfer dest:msg.sender value:TMP_6""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,0,1,0,msg.value >= address(this).balance;msg.sender.transfer(address(this).balance);
./0x6de3cc59152e19f108378984f45e20a34c9f6338_ext.sol,EtherSpin.ownerKillContract,1192,1194,"TMP_1473(None) = SOLIDITY_CALL suicide(address)(owner),MODIFIER_CALL, EtherSpin.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
suicide(address)(owner)

IRs:
TMP_1473(None) = SOLIDITY_CALL suicide(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, EtherSpin.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();suicide(address)(owner)
./0x6c602f1798a453f90f249e208e2b64c7c09226f7_ext.sol,Mentoring._flushBalance,318,324,"TMP_91 = CONVERT this to address,TMP_92(uint256) = SOLIDITY_CALL balance(address)(TMP_91),balance(uint256) := TMP_92(uint256),TMP_93(bool) = balance > 0,CONDITION TMP_93,TMP_94 = CONVERT heroes to address,Transfer dest:TMP_94 value:balance,TMP_96 = CONVERT this to address,Emit Income(TMP_96,balance)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
balance = address(this).balance

IRs:
TMP_91 = CONVERT this to address
TMP_92(uint256) = SOLIDITY_CALL balance(address)(TMP_91)
balance(uint256) := TMP_92(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
balance > 0

IRs:
TMP_93(bool) = balance > 0
CONDITION TMP_93""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
address(heroes).transfer(balance)

IRs:
TMP_94 = CONVERT heroes to address
Transfer dest:TMP_94 value:balance""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Income(address(this),balance)

IRs:
TMP_96 = CONVERT this to address
Emit Income(TMP_96,balance)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,0,1,0,"balance = address(this).balance;balance > 0;address(heroes).transfer(balance);;Income(address(this),balance)"
./0x0595d187cac88f04466371eff3a6b6d1b12fb013_ext.sol,GIFT_1_ETH.GetGift,5,13,"TMP_0(bytes32) = SOLIDITY_CALL keccak256()(pass),TMP_1(bool) = hashPass == TMP_0,TMP_2(bool) = now > giftTime,TMP_3(bool) = TMP_1 && TMP_2,CONDITION TMP_3,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
hashPass == keccak256()(pass) && now > giftTime

IRs:
TMP_0(bytes32) = SOLIDITY_CALL keccak256()(pass)
TMP_1(bool) = hashPass == TMP_0
TMP_2(bool) = now > giftTime
TMP_3(bool) = TMP_1 && TMP_2
CONDITION TMP_3""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,1,1,0,hashPass == keccak256()(pass) && now > giftTime;msg.sender.transfer(this.balance);
./0xcdcbb474268703da1b6744c540500e8a2a39e8dc_ext.sol,knf.cleanup,249,249,"TMP_66(None) = SOLIDITY_CALL selfdestruct(address)(control),MODIFIER_CALL, knf.onlyControl()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(control)

IRs:
TMP_66(None) = SOLIDITY_CALL selfdestruct(address)(control)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyControl()

IRs:
MODIFIER_CALL, knf.onlyControl()()""];
2->1;
}
",0,0,1,0,onlyControl();selfdestruct(address)(control)
./0x55654a38372617aedd583009f76e28700e48fdad_ext.sol,CarnieGamesBlackBox.OpenBox,14,25,"TMP_0(bool) = msg.value >= 100000000000000000,CONDITION TMP_0,TMP_1(bytes32) = SOLIDITY_CALL keccak256()(guess),TMP_2(bool) = TMP_1 == key,CONDITION TMP_2,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:Owner value:REF_1,REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value >= 100000000000000000

IRs:
TMP_0(bool) = msg.value >= 100000000000000000
CONDITION TMP_0""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
keccak256()(guess) == key

IRs:
TMP_1(bytes32) = SOLIDITY_CALL keccak256()(guess)
TMP_2(bool) = TMP_1 == key
CONDITION TMP_2""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Owner.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:Owner value:REF_1""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,0,1,0,msg.value >= 100000000000000000;keccak256()(guess) == key;;Owner.transfer(this.balance);;msg.sender.transfer(this.balance)
./0xa23a42b2bb161b0ab7bbcbd72bea54952e5299fc_ext.sol,zeepay.getTokens,181,241,"tokens(uint256) := 0(uint256),bonus(uint256) := 0(uint256),countbonus(uint256) := 0(uint256),TMP_45(uint256) = 1000000000000000000 / 10,bonusCond1(uint256) := TMP_45(uint256),bonusCond2(uint256) := 1000000000000000000(uint256),bonusCond3(uint256) := 5000000000000000000(uint256),TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_47(uint256) = TMP_46 / 1000000000000000000,tokens(uint256) := TMP_47(uint256),investor(address) := msg.sender(address),TMP_48(bool) = msg.value >= requestMinimum,TMP_49(bool) = now < deadline,TMP_50(bool) = TMP_48 && TMP_49,TMP_51(bool) = now < round1,TMP_52(bool) = TMP_50 && TMP_51,TMP_53(bool) = now < round2,TMP_54(bool) = TMP_52 && TMP_53,CONDITION TMP_54,TMP_55(bool) = msg.value >= bonusCond1,TMP_56(bool) = msg.value < bonusCond2,TMP_57(bool) = TMP_55 && TMP_56,CONDITION TMP_57,TMP_58(uint256) = tokens * 5,TMP_59(uint256) = TMP_58 / 100,countbonus(uint256) := TMP_59(uint256),TMP_60(bool) = msg.value >= bonusCond2,TMP_61(bool) = msg.value < bonusCond3,TMP_62(bool) = TMP_60 && TMP_61,CONDITION TMP_62,TMP_63(uint256) = tokens * 10,TMP_64(uint256) = TMP_63 / 100,countbonus(uint256) := TMP_64(uint256),TMP_65(bool) = msg.value >= bonusCond3,CONDITION TMP_65,TMP_66(uint256) = tokens * 15,TMP_67(uint256) = TMP_66 / 100,countbonus(uint256) := TMP_67(uint256),TMP_68(bool) = msg.value >= requestMinimum,TMP_69(bool) = now < deadline,TMP_70(bool) = TMP_68 && TMP_69,TMP_71(bool) = now > round1,TMP_72(bool) = TMP_70 && TMP_71,TMP_73(bool) = now < round2,TMP_74(bool) = TMP_72 && TMP_73,CONDITION TMP_74,TMP_75(bool) = msg.value >= bonusCond2,TMP_76(bool) = msg.value < bonusCond3,TMP_77(bool) = TMP_75 && TMP_76,CONDITION TMP_77,TMP_78(uint256) = tokens * 5,TMP_79(uint256) = TMP_78 / 100,countbonus(uint256) := TMP_79(uint256),TMP_80(bool) = msg.value >= bonusCond3,CONDITION TMP_80,TMP_81(uint256) = tokens * 10,TMP_82(uint256) = TMP_81 / 100,countbonus(uint256) := TMP_82(uint256),countbonus(uint256) := 0(uint256),TMP_83(uint256) = tokens + countbonus,bonus(uint256) := TMP_83(uint256),TMP_84(bool) = tokens == 0,CONDITION TMP_84,valdrop(uint256) := 100000000000(uint256),REF_12(bool) -> Claimed[investor],TMP_85(bool) = REF_12 == False,TMP_86(bool) = progress0drop <= target0drop,TMP_87(bool) = TMP_85 && TMP_86,CONDITION TMP_87,TMP_88(bool) = INTERNAL_CALL, zeepay.distr(address,uint256)(investor,valdrop),REF_13(bool) -> Claimed[investor],REF_13(bool) (->Claimed) := True(bool),TMP_89(uint256) := progress0drop(uint256),progress0drop(uint256) = progress0drop + 1,TMP_90(bool) = msg.value >= requestMinimum,TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),TMP_92(bool) = tokens > 0,TMP_93(bool) = msg.value >= requestMinimum,TMP_94(bool) = TMP_92 && TMP_93,CONDITION TMP_94,TMP_95(bool) = now >= deadline,TMP_96(bool) = now >= round1,TMP_97(bool) = TMP_95 && TMP_96,TMP_98(bool) = now < round2,TMP_99(bool) = TMP_97 && TMP_98,CONDITION TMP_99,TMP_100(bool) = INTERNAL_CALL, zeepay.distr(address,uint256)(investor,tokens),TMP_101(bool) = msg.value >= bonusCond1,CONDITION TMP_101,TMP_102(bool) = INTERNAL_CALL, zeepay.distr(address,uint256)(investor,bonus),TMP_103(bool) = INTERNAL_CALL, zeepay.distr(address,uint256)(investor,tokens),TMP_104(bool) = msg.value >= requestMinimum,TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104),TMP_106(bool) = totalDistributed >= totalSupply,CONDITION TMP_106,distributionFinished(bool) := True(bool),Transfer dest:multisig value:msg.value,MODIFIER_CALL, zeepay.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->53;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bonusCond1 = 1000000000000000000 / 10

IRs:
TMP_45(uint256) = 1000000000000000000 / 10
bonusCond1(uint256) := TMP_45(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bonusCond2 = 1000000000000000000

IRs:
bonusCond2(uint256) := 1000000000000000000(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
bonusCond3 = 5000000000000000000

IRs:
bonusCond3(uint256) := 5000000000000000000(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_47(uint256) = TMP_46 / 1000000000000000000
tokens(uint256) := TMP_47(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now < round1 && now < round2

IRs:
TMP_48(bool) = msg.value >= requestMinimum
TMP_49(bool) = now < deadline
TMP_50(bool) = TMP_48 && TMP_49
TMP_51(bool) = now < round1
TMP_52(bool) = TMP_50 && TMP_51
TMP_53(bool) = now < round2
TMP_54(bool) = TMP_52 && TMP_53
CONDITION TMP_54""];
9->10[label=""True""];
9->19[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
msg.value >= bonusCond1 && msg.value < bonusCond2

IRs:
TMP_55(bool) = msg.value >= bonusCond1
TMP_56(bool) = msg.value < bonusCond2
TMP_57(bool) = TMP_55 && TMP_56
CONDITION TMP_57""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
countbonus = tokens * 5 / 100

IRs:
TMP_58(uint256) = tokens * 5
TMP_59(uint256) = TMP_58 / 100
countbonus(uint256) := TMP_59(uint256)""];
11->18;
12[label=""Node Type: IF 12

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_60(bool) = msg.value >= bonusCond2
TMP_61(bool) = msg.value < bonusCond3
TMP_62(bool) = TMP_60 && TMP_61
CONDITION TMP_62""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
countbonus = tokens * 10 / 100

IRs:
TMP_63(uint256) = tokens * 10
TMP_64(uint256) = TMP_63 / 100
countbonus(uint256) := TMP_64(uint256)""];
13->17;
14[label=""Node Type: IF 14

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_65(bool) = msg.value >= bonusCond3
CONDITION TMP_65""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
countbonus = tokens * 15 / 100

IRs:
TMP_66(uint256) = tokens * 15
TMP_67(uint256) = TMP_66 / 100
countbonus(uint256) := TMP_67(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->28;
19[label=""Node Type: IF 19

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now > round1 && now < round2

IRs:
TMP_68(bool) = msg.value >= requestMinimum
TMP_69(bool) = now < deadline
TMP_70(bool) = TMP_68 && TMP_69
TMP_71(bool) = now > round1
TMP_72(bool) = TMP_70 && TMP_71
TMP_73(bool) = now < round2
TMP_74(bool) = TMP_72 && TMP_73
CONDITION TMP_74""];
19->20[label=""True""];
19->26[label=""False""];
20[label=""Node Type: IF 20

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_75(bool) = msg.value >= bonusCond2
TMP_76(bool) = msg.value < bonusCond3
TMP_77(bool) = TMP_75 && TMP_76
CONDITION TMP_77""];
20->21[label=""True""];
20->22[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
countbonus = tokens * 5 / 100

IRs:
TMP_78(uint256) = tokens * 5
TMP_79(uint256) = TMP_78 / 100
countbonus(uint256) := TMP_79(uint256)""];
21->25;
22[label=""Node Type: IF 22

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_80(bool) = msg.value >= bonusCond3
CONDITION TMP_80""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
countbonus = tokens * 10 / 100

IRs:
TMP_81(uint256) = tokens * 10
TMP_82(uint256) = TMP_81 / 100
countbonus(uint256) := TMP_82(uint256)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->27;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
bonus = tokens + countbonus

IRs:
TMP_83(uint256) = tokens + countbonus
bonus(uint256) := TMP_83(uint256)""];
29->30;
30[label=""Node Type: IF 30

EXPRESSION:
tokens == 0

IRs:
TMP_84(bool) = tokens == 0
CONDITION TMP_84""];
30->31[label=""True""];
30->38[label=""False""];
31[label=""Node Type: NEW VARIABLE 31

EXPRESSION:
valdrop = 1000e8

IRs:
valdrop(uint256) := 100000000000(uint256)""];
31->32;
32[label=""Node Type: IF 32

EXPRESSION:
Claimed[investor] == false && progress0drop <= target0drop

IRs:
REF_12(bool) -> Claimed[investor]
TMP_85(bool) = REF_12 == False
TMP_86(bool) = progress0drop <= target0drop
TMP_87(bool) = TMP_85 && TMP_86
CONDITION TMP_87""];
32->33[label=""True""];
32->36[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
distr(investor,valdrop)

IRs:
TMP_88(bool) = INTERNAL_CALL, zeepay.distr(address,uint256)(investor,valdrop)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
Claimed[investor] = true

IRs:
REF_13(bool) -> Claimed[investor]
REF_13(bool) (->Claimed) := True(bool)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
progress0drop ++

IRs:
TMP_89(uint256) := progress0drop(uint256)
progress0drop(uint256) = progress0drop + 1""];
35->37;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_90(bool) = msg.value >= requestMinimum
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
36->37;
37[label=""Node Type: END_IF 37
""];
37->48;
38[label=""Node Type: IF 38

EXPRESSION:
tokens > 0 && msg.value >= requestMinimum

IRs:
TMP_92(bool) = tokens > 0
TMP_93(bool) = msg.value >= requestMinimum
TMP_94(bool) = TMP_92 && TMP_93
CONDITION TMP_94""];
38->39[label=""True""];
38->46[label=""False""];
39[label=""Node Type: IF 39

EXPRESSION:
now >= deadline && now >= round1 && now < round2

IRs:
TMP_95(bool) = now >= deadline
TMP_96(bool) = now >= round1
TMP_97(bool) = TMP_95 && TMP_96
TMP_98(bool) = now < round2
TMP_99(bool) = TMP_97 && TMP_98
CONDITION TMP_99""];
39->40[label=""True""];
39->41[label=""False""];
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_100(bool) = INTERNAL_CALL, zeepay.distr(address,uint256)(investor,tokens)""];
40->45;
41[label=""Node Type: IF 41

EXPRESSION:
msg.value >= bonusCond1

IRs:
TMP_101(bool) = msg.value >= bonusCond1
CONDITION TMP_101""];
41->42[label=""True""];
41->43[label=""False""];
42[label=""Node Type: EXPRESSION 42

EXPRESSION:
distr(investor,bonus)

IRs:
TMP_102(bool) = INTERNAL_CALL, zeepay.distr(address,uint256)(investor,bonus)""];
42->44;
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_103(bool) = INTERNAL_CALL, zeepay.distr(address,uint256)(investor,tokens)""];
43->44;
44[label=""Node Type: END_IF 44
""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->47;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_104(bool) = msg.value >= requestMinimum
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: IF 49

EXPRESSION:
totalDistributed >= totalSupply

IRs:
TMP_106(bool) = totalDistributed >= totalSupply
CONDITION TMP_106""];
49->50[label=""True""];
49->51[label=""False""];
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
multisig.transfer(msg.value)

IRs:
Transfer dest:multisig value:msg.value""];
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, zeepay.canDistr()()""];
53->1;
}
",0,0,1,0,"canDistr();tokens = 0;bonus = 0;countbonus = 0;bonusCond1 = 1000000000000000000 / 10;bonusCond2 = 1000000000000000000;bonusCond3 = 5000000000000000000;tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;investor = msg.sender;msg.value >= requestMinimum && now < deadline && now < round1 && now < round2;msg.value >= bonusCond1 && msg.value < bonusCond2;msg.value >= requestMinimum && now < deadline && now > round1 && now < round2;countbonus = tokens * 5 / 100;msg.value >= bonusCond2 && msg.value < bonusCond3;;countbonus = tokens * 10 / 100;msg.value >= bonusCond3;;countbonus = tokens * 15 / 100;;;msg.value >= bonusCond2 && msg.value < bonusCond3;countbonus = 0;countbonus = tokens * 5 / 100;msg.value >= bonusCond3;;countbonus = tokens * 10 / 100;;;bonus = tokens + countbonus;tokens == 0;valdrop = 1000e8;tokens > 0 && msg.value >= requestMinimum;Claimed[investor] == false && progress0drop <= target0drop;distr(investor,valdrop);require(bool)(msg.value >= requestMinimum);Claimed[investor] = true;progress0drop ++;;;now >= deadline && now >= round1 && now < round2;require(bool)(msg.value >= requestMinimum);distr(investor,tokens);msg.value >= bonusCond1;;distr(investor,bonus);distr(investor,tokens);;;totalDistributed >= totalSupply;distributionFinished = true;;multisig.transfer(msg.value)"
./0x8d46facfb889740a345755e624942257dc87b5ac_ext.sol,UpgradeableToken.fallback,276,281,"TMP_254(bool) = migrationAgent != 0,TMP_255(None) = SOLIDITY_CALL require(bool)(TMP_254),REF_113(uint256) -> balances[msg.sender],TMP_256(bool) = REF_113 > 0,TMP_257(None) = SOLIDITY_CALL require(bool)(TMP_256),INTERNAL_CALL, UpgradeableToken.migrate()(),Transfer dest:msg.sender value:msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(migrationAgent != 0)

IRs:
TMP_254(bool) = migrationAgent != 0
TMP_255(None) = SOLIDITY_CALL require(bool)(TMP_254)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[msg.sender] > 0)

IRs:
REF_113(uint256) -> balances[msg.sender]
TMP_256(bool) = REF_113 > 0
TMP_257(None) = SOLIDITY_CALL require(bool)(TMP_256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
migrate()

IRs:
INTERNAL_CALL, UpgradeableToken.migrate()()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(msg.value)

IRs:
Transfer dest:msg.sender value:msg.value""];
}
",0,0,1,0,require(bool)(migrationAgent != 0);require(bool)(balances[msg.sender] > 0);migrate();msg.sender.transfer(msg.value)
./0x5ab883cfde389e09c623c049939d7553f312ac43_ext.sol,Core.withdrawCommissionBalanceWEI,104,109,"Transfer dest:_to value:commissionBalanceWEI,Emit WithdrawWEI(msg.sender,_to,commissionBalanceWEI,3),commissionBalanceWEI(uint256) := 0(uint256),MODIFIER_CALL, Control.onlyADM()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_to.transfer(commissionBalanceWEI)

IRs:
Transfer dest:_to value:commissionBalanceWEI""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
WithdrawWEI(msg.sender,_to,commissionBalanceWEI,3)

IRs:
Emit WithdrawWEI(msg.sender,_to,commissionBalanceWEI,3)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
commissionBalanceWEI = 0

IRs:
commissionBalanceWEI(uint256) := 0(uint256)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyADM()

IRs:
MODIFIER_CALL, Control.onlyADM()()""];
4->1;
}
",0,0,1,0,"onlyADM();_to.transfer(commissionBalanceWEI);WithdrawWEI(msg.sender,_to,commissionBalanceWEI,3);commissionBalanceWEI = 0"
./0xd0306dd978c2deced267a29b25290f353149450a_ext.sol,Slaughter3D.offerAsSacrificeFromVaultForce,310,345,"value(uint256) := msg.value(uint256),TMP_68(bool) = value >= 5000000000000000,TMP_69(None) = SOLIDITY_CALL require(bool)(TMP_68),REF_51(uint256) -> playerVault[forcedToFight],TMP_70(bool) = REF_51 >= OFFER_SIZE,TMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70),TMP_72(uint256) = numberOfStages - 1,REF_52(Slaughter3D.Stage) -> stages[TMP_72],REF_53(mapping(address => bool)) -> REF_52.players,REF_54(bool) -> REF_53[forcedToFight],TMP_73(bool) = REF_54 == False,TMP_74(None) = SOLIDITY_CALL require(bool)(TMP_73),REF_55(uint256) -> playerVault[forcedToFight],REF_55(-> playerVault) = REF_55 - OFFER_SIZE,REF_56(uint256) -> playerVault[forcedToFight],REF_56(-> playerVault) = REF_56 + 3000000000000000,HIGH_LEVEL_CALL, dest:SPASM_(SPASMInterface), function:disburse, arguments:[] value:2000000000000000 ,TMP_77(uint256) = numberOfStages - 1,REF_59(Slaughter3D.Stage) -> stages[TMP_77],currentStage(Slaughter3D.Stage) := REF_59(Slaughter3D.Stage),REF_60(uint8) -> currentStage.numberOfPlayers,TMP_78(bool) = REF_60 < MAX_PLAYERS_PER_STAGE,TMP_79(None) = SOLIDITY_CALL assert(bool)(TMP_78),player(address) := forcedToFight(address),REF_61(mapping(uint8 => address)) -> currentStage.slotXplayer,REF_62(uint8) -> currentStage.numberOfPlayers,REF_63(address) -> REF_61[REF_62],REF_63(address) (->currentStage) := player(address),REF_64(uint8) -> currentStage.numberOfPlayers,TMP_80(uint8) := REF_64(uint8),REF_64(-> currentStage) = REF_64 + 1,REF_65(mapping(address => bool)) -> currentStage.players,REF_66(bool) -> REF_65[player],REF_66(bool) (->currentStage) := True(bool),REF_67(mapping(uint8 => address)) -> currentStage.setMN,REF_68(uint8) -> currentStage.numberOfPlayers,REF_69(address) -> REF_67[REF_68],REF_69(address) (->currentStage) := MN(address),Emit SacrificeOffered(player),REF_70(uint8) -> currentStage.numberOfPlayers,TMP_82(bool) = REF_70 == MAX_PLAYERS_PER_STAGE,CONDITION TMP_82,REF_71(uint256) -> currentStage.blocknumber,REF_71(uint256) (->currentStage) := block.number(uint256),INTERNAL_CALL, Slaughter3D.tryFinalizeStage()(),MODIFIER_CALL, Slaughter3D.prepareStage()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->20;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
value = msg.value

IRs:
value(uint256) := msg.value(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(value >= 5000000000000000)

IRs:
TMP_68(bool) = value >= 5000000000000000
TMP_69(None) = SOLIDITY_CALL require(bool)(TMP_68)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(playerVault[forcedToFight] >= OFFER_SIZE)

IRs:
REF_51(uint256) -> playerVault[forcedToFight]
TMP_70(bool) = REF_51 >= OFFER_SIZE
TMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(stages[numberOfStages - 1].players[forcedToFight] == false)

IRs:
TMP_72(uint256) = numberOfStages - 1
REF_52(Slaughter3D.Stage) -> stages[TMP_72]
REF_53(mapping(address => bool)) -> REF_52.players
REF_54(bool) -> REF_53[forcedToFight]
TMP_73(bool) = REF_54 == False
TMP_74(None) = SOLIDITY_CALL require(bool)(TMP_73)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
playerVault[forcedToFight] -= OFFER_SIZE

IRs:
REF_55(uint256) -> playerVault[forcedToFight]
REF_55(-> playerVault) = REF_55 - OFFER_SIZE""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
playerVault[forcedToFight] += 3000000000000000

IRs:
REF_56(uint256) -> playerVault[forcedToFight]
REF_56(-> playerVault) = REF_56 + 3000000000000000""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
SPASM_.disburse.value(2000000000000000)()

IRs:
HIGH_LEVEL_CALL, dest:SPASM_(SPASMInterface), function:disburse, arguments:[] value:2000000000000000 ""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
currentStage = stages[numberOfStages - 1]

IRs:
TMP_77(uint256) = numberOfStages - 1
REF_59(Slaughter3D.Stage) -> stages[TMP_77]
currentStage(Slaughter3D.Stage) := REF_59(Slaughter3D.Stage)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
assert(bool)(currentStage.numberOfPlayers < MAX_PLAYERS_PER_STAGE)

IRs:
REF_60(uint8) -> currentStage.numberOfPlayers
TMP_78(bool) = REF_60 < MAX_PLAYERS_PER_STAGE
TMP_79(None) = SOLIDITY_CALL assert(bool)(TMP_78)""];
9->10;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
player = forcedToFight

IRs:
player(address) := forcedToFight(address)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
currentStage.slotXplayer[currentStage.numberOfPlayers] = player

IRs:
REF_61(mapping(uint8 => address)) -> currentStage.slotXplayer
REF_62(uint8) -> currentStage.numberOfPlayers
REF_63(address) -> REF_61[REF_62]
REF_63(address) (->currentStage) := player(address)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
currentStage.numberOfPlayers ++

IRs:
REF_64(uint8) -> currentStage.numberOfPlayers
TMP_80(uint8) := REF_64(uint8)
REF_64(-> currentStage) = REF_64 + 1""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
currentStage.players[player] = true

IRs:
REF_65(mapping(address => bool)) -> currentStage.players
REF_66(bool) -> REF_65[player]
REF_66(bool) (->currentStage) := True(bool)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
currentStage.setMN[currentStage.numberOfPlayers] = MN

IRs:
REF_67(mapping(uint8 => address)) -> currentStage.setMN
REF_68(uint8) -> currentStage.numberOfPlayers
REF_69(address) -> REF_67[REF_68]
REF_69(address) (->currentStage) := MN(address)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
SacrificeOffered(player)

IRs:
Emit SacrificeOffered(player)""];
15->16;
16[label=""Node Type: IF 16

EXPRESSION:
currentStage.numberOfPlayers == MAX_PLAYERS_PER_STAGE

IRs:
REF_70(uint8) -> currentStage.numberOfPlayers
TMP_82(bool) = REF_70 == MAX_PLAYERS_PER_STAGE
CONDITION TMP_82""];
16->17[label=""True""];
16->18[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
currentStage.blocknumber = block.number

IRs:
REF_71(uint256) -> currentStage.blocknumber
REF_71(uint256) (->currentStage) := block.number(uint256)""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
tryFinalizeStage()

IRs:
INTERNAL_CALL, Slaughter3D.tryFinalizeStage()()""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
prepareStage()

IRs:
MODIFIER_CALL, Slaughter3D.prepareStage()()""];
20->1;
}
",0,0,1,0,prepareStage();value = msg.value;require(bool)(value >= 5000000000000000);require(bool)(playerVault[forcedToFight] >= OFFER_SIZE);require(bool)(stages[numberOfStages - 1].players[forcedToFight] == false);playerVault[forcedToFight] -= OFFER_SIZE;playerVault[forcedToFight] += 3000000000000000;SPASM_.disburse.value(2000000000000000)();currentStage = stages[numberOfStages - 1];assert(bool)(currentStage.numberOfPlayers < MAX_PLAYERS_PER_STAGE);player = forcedToFight;currentStage.slotXplayer[currentStage.numberOfPlayers] = player;currentStage.numberOfPlayers ++;currentStage.players[player] = true;currentStage.setMN[currentStage.numberOfPlayers] = MN;SacrificeOffered(player);currentStage.numberOfPlayers == MAX_PLAYERS_PER_STAGE;currentStage.blocknumber = block.number;;tryFinalizeStage()
./0x55654a38372617aedd583009f76e28700e48fdad_ext.sol,CarnieGamesBlackBox.OpenBox,14,25,"TMP_0(bool) = msg.value >= 100000000000000000,CONDITION TMP_0,TMP_1(bytes32) = SOLIDITY_CALL keccak256()(guess),TMP_2(bool) = TMP_1 == key,CONDITION TMP_2,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:Owner value:REF_1,REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value >= 100000000000000000

IRs:
TMP_0(bool) = msg.value >= 100000000000000000
CONDITION TMP_0""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
keccak256()(guess) == key

IRs:
TMP_1(bytes32) = SOLIDITY_CALL keccak256()(guess)
TMP_2(bool) = TMP_1 == key
CONDITION TMP_2""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Owner.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:Owner value:REF_1""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,0,1,0,msg.value >= 100000000000000000;keccak256()(guess) == key;;Owner.transfer(this.balance);;msg.sender.transfer(this.balance)
./0x333b20d643b58263e1558de655fda9cf7d07c401_ext.sol,RefundVault.refund,400,406,"REF_157(RefundVault.State) -> State.Refunding,TMP_182(bool) = state == REF_157,TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182),REF_158(uint256) -> deposited[investor],depositedValue(uint256) := REF_158(uint256),REF_159(uint256) -> deposited[investor],REF_159(uint256) (->deposited) := 0(uint256),Transfer dest:investor value:depositedValue,Emit Refunded(investor,depositedValue)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Refunding)

IRs:
REF_157(RefundVault.State) -> State.Refunding
TMP_182(bool) = state == REF_157
TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
depositedValue = deposited[investor]

IRs:
REF_158(uint256) -> deposited[investor]
depositedValue(uint256) := REF_158(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
deposited[investor] = 0

IRs:
REF_159(uint256) -> deposited[investor]
REF_159(uint256) (->deposited) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
investor.transfer(depositedValue)

IRs:
Transfer dest:investor value:depositedValue""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Refunded(investor,depositedValue)

IRs:
Emit Refunded(investor,depositedValue)""];
}
",0,0,1,0,"require(bool)(state == State.Refunding);depositedValue = deposited[investor];deposited[investor] = 0;investor.transfer(depositedValue);Refunded(investor,depositedValue)"
./0x50f37df80a4e804a03275b21f83ebf5d5a668d39_ext.sol,AuctionPotato.withdraw,266,271,"TMP_80(bool) = now > endTime,TMP_81(None) = SOLIDITY_CALL require(bool)(TMP_80),TMP_82 = CONVERT this to address,TMP_83(uint256) = SOLIDITY_CALL balance(address)(TMP_82),Emit Withdraw(msg.sender,TMP_83),TMP_85 = CONVERT this to address,TMP_86(uint256) = SOLIDITY_CALL balance(address)(TMP_85),Transfer dest:msg.sender value:TMP_86,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now > endTime)

IRs:
TMP_80(bool) = now > endTime
TMP_81(None) = SOLIDITY_CALL require(bool)(TMP_80)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Withdraw(msg.sender,address(this).balance)

IRs:
TMP_82 = CONVERT this to address
TMP_83(uint256) = SOLIDITY_CALL balance(address)(TMP_82)
Emit Withdraw(msg.sender,TMP_83)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_85 = CONVERT this to address
TMP_86(uint256) = SOLIDITY_CALL balance(address)(TMP_85)
Transfer dest:msg.sender value:TMP_86""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->1;
}
",0,0,1,0,"onlyOwner();require(bool)(now > endTime);Withdraw(msg.sender,address(this).balance);msg.sender.transfer(address(this).balance)"
./0x7012ef33dcc79a7341ba05cf2c5699eaaa5e0d7d_ext.sol,Transaction.sendAmount,236,243,"TMP_90(bool) = seller != 0,TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),TMP_92(bool) = msg.sender != seller,TMP_93(None) = SOLIDITY_CALL require(bool)(TMP_92),Transfer dest:seller value:msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(seller != 0x0)

IRs:
TMP_90(bool) = seller != 0
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender != seller)

IRs:
TMP_92(bool) = msg.sender != seller
TMP_93(None) = SOLIDITY_CALL require(bool)(TMP_92)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
seller.transfer(msg.value)

IRs:
Transfer dest:seller value:msg.value""];
}
",0,0,1,0,require(bool)(seller != 0x0);require(bool)(msg.sender != seller);seller.transfer(msg.value)
./0x0e6f6ed4581d25944d8c6a595b9f50e11431b754_ext.sol,PaymentHolder.migrate,474,484,"TMP_171 = CONVERT newHolder to PaymentHolder,TMP_172 = CONVERT this to address,TMP_173(uint256) = SOLIDITY_CALL balance(address)(TMP_172),TMP_175(bool) = HIGH_LEVEL_CALL, dest:TMP_171(PaymentHolder), function:update, arguments:['_allowed'] value:TMP_173 ,TMP_176(None) = SOLIDITY_CALL require(bool)(TMP_175),i(uint256) := 0(uint256),REF_80 -> LENGTH tokens,TMP_177(bool) = i < REF_80,CONDITION TMP_177,REF_81(address) -> tokens[i],token(address) := REF_81(address),TMP_178 = CONVERT token to Token,TMP_179(uint256) = HIGH_LEVEL_CALL, dest:TMP_178(Token), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_179(uint256),TMP_180(bool) = balance > 0,CONDITION TMP_180,TMP_181 = CONVERT token to Token,TMP_182(bool) = HIGH_LEVEL_CALL, dest:TMP_181(Token), function:transfer, arguments:['newHolder', 'balance']  ,TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182),TMP_184(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(PaymentHolder(newHolder).update.value(address(this).balance)(_allowed))

IRs:
TMP_171 = CONVERT newHolder to PaymentHolder
TMP_172 = CONVERT this to address
TMP_173(uint256) = SOLIDITY_CALL balance(address)(TMP_172)
TMP_175(bool) = HIGH_LEVEL_CALL, dest:TMP_171(PaymentHolder), function:update, arguments:['_allowed'] value:TMP_173 
TMP_176(None) = SOLIDITY_CALL require(bool)(TMP_175)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < tokens.length

IRs:
REF_80 -> LENGTH tokens
TMP_177(bool) = i < REF_80
CONDITION TMP_177""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
token = tokens[i]

IRs:
REF_81(address) -> tokens[i]
token(address) := REF_81(address)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
balance = Token(token).balanceOf(this)

IRs:
TMP_178 = CONVERT token to Token
TMP_179(uint256) = HIGH_LEVEL_CALL, dest:TMP_178(Token), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_179(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
balance > 0

IRs:
TMP_180(bool) = balance > 0
CONDITION TMP_180""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(Token(token).transfer(newHolder,balance))

IRs:
TMP_181 = CONVERT token to Token
TMP_182(bool) = HIGH_LEVEL_CALL, dest:TMP_181(Token), function:transfer, arguments:['newHolder', 'balance']  
TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_184(uint256) := i(uint256)
i(uint256) = i + 1""];
11->5;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
12->1;
}
",1,0,1,0,"onlyOwner();require(bool)(PaymentHolder(newHolder).update.value(address(this).balance)(_allowed));i = 0;;i < tokens.length;;token = tokens[i];balance = Token(token).balanceOf(this);balance > 0;require(bool)(Token(token).transfer(newHolder,balance));;i ++"
./0xefe17f088be79ba802b60ea84ebafb255ea18aa4_ext.sol,AccessService.withdraw,79,91,"TMP_37(bool) = msg.sender == addrFinance,TMP_38(bool) = msg.sender == addrAdmin,TMP_39(bool) = TMP_37 || TMP_38,TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39),TMP_41(bool) = _amount > 0,TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41),REF_0(uint256) = SOLIDITY_CALL balance(address)(this),balance(uint256) := REF_0([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E30C3AC0>]),TMP_43(bool) = _amount < balance,CONDITION TMP_43,Transfer dest:receiver value:_amount,REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:receiver value:REF_3,TMP_46 = CONVERT 0 to address,TMP_47(bool) = _target == TMP_46,CONDITION TMP_47,receiver(address) := addrFinance(address),receiver(address) := _target(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == addrFinance || msg.sender == addrAdmin)

IRs:
TMP_37(bool) = msg.sender == addrFinance
TMP_38(bool) = msg.sender == addrAdmin
TMP_39(bool) = TMP_37 || TMP_38
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amount > 0)

IRs:
TMP_41(bool) = _amount > 0
TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)""];
2->9;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
balance = this.balance

IRs:
REF_0(uint256) = SOLIDITY_CALL balance(address)(this)
balance(uint256) := REF_0([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E30C3AC0>])""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
_amount < balance

IRs:
TMP_43(bool) = _amount < balance
CONDITION TMP_43""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
receiver.transfer(_amount)

IRs:
Transfer dest:receiver value:_amount""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
receiver.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:receiver value:REF_3""];
7->8;
8[label=""Node Type: END_IF 8
""];
9[label=""Node Type: IF 9

EXPRESSION:
_target == address(0)

IRs:
TMP_46 = CONVERT 0 to address
TMP_47(bool) = _target == TMP_46
CONDITION TMP_47""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
receiver = addrFinance

IRs:
receiver(address) := addrFinance(address)""];
10->12;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
receiver = _target

IRs:
receiver(address) := _target(address)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->4;
}
",0,0,1,0,require(bool)(msg.sender == addrFinance || msg.sender == addrAdmin);require(bool)(_amount > 0);_target == address(0);balance = this.balance;_amount < balance;receiver.transfer(_amount);receiver.transfer(this.balance);;receiver = addrFinance;receiver = _target;
./0xeb156f1722c1357518fe2599bd8362fb19a56757_ext.sol,Lucky_2020.getTokens,182,245,"tokens(uint256) := 0(uint256),bonus(uint256) := 0(uint256),countbonus(uint256) := 0(uint256),TMP_45(uint256) = 5000000000000000000 / 100,bonusCond1(uint256) := TMP_45(uint256),TMP_46(uint256) = 1000000000000000000 / 10,bonusCond2(uint256) := TMP_46(uint256),TMP_47(uint256) = 5000000000000000000 / 10,bonusCond3(uint256) := TMP_47(uint256),bonusCond4(uint256) := 1000000000000000000(uint256),TMP_48(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_49(uint256) = TMP_48 / 1000000000000000000,tokens(uint256) := TMP_49(uint256),investor(address) := msg.sender(address),TMP_50(bool) = msg.value >= requestMinimum,TMP_51(bool) = now < deadline,TMP_52(bool) = TMP_50 && TMP_51,TMP_53(bool) = now < round1,TMP_54(bool) = TMP_52 && TMP_53,TMP_55(bool) = now < round2,TMP_56(bool) = TMP_54 && TMP_55,CONDITION TMP_56,TMP_57(bool) = msg.value >= bonusCond1,TMP_58(bool) = msg.value < bonusCond2,TMP_59(bool) = TMP_57 && TMP_58,CONDITION TMP_59,TMP_60(uint256) = tokens * 10,TMP_61(uint256) = TMP_60 / 100,countbonus(uint256) := TMP_61(uint256),TMP_62(bool) = msg.value >= bonusCond2,TMP_63(bool) = msg.value < bonusCond3,TMP_64(bool) = TMP_62 && TMP_63,CONDITION TMP_64,TMP_65(uint256) = tokens * 20,TMP_66(uint256) = TMP_65 / 100,countbonus(uint256) := TMP_66(uint256),TMP_67(bool) = msg.value >= bonusCond3,TMP_68(bool) = msg.value < bonusCond4,TMP_69(bool) = TMP_67 && TMP_68,CONDITION TMP_69,TMP_70(uint256) = tokens * 35,TMP_71(uint256) = TMP_70 / 100,countbonus(uint256) := TMP_71(uint256),TMP_72(bool) = msg.value >= bonusCond4,CONDITION TMP_72,TMP_73(uint256) = tokens * 50,TMP_74(uint256) = TMP_73 / 100,countbonus(uint256) := TMP_74(uint256),TMP_75(bool) = msg.value >= requestMinimum,TMP_76(bool) = now < deadline,TMP_77(bool) = TMP_75 && TMP_76,TMP_78(bool) = now > round1,TMP_79(bool) = TMP_77 && TMP_78,TMP_80(bool) = now < round2,TMP_81(bool) = TMP_79 && TMP_80,CONDITION TMP_81,TMP_82(bool) = msg.value >= bonusCond2,TMP_83(bool) = msg.value < bonusCond3,TMP_84(bool) = TMP_82 && TMP_83,CONDITION TMP_84,TMP_85(uint256) = tokens * 2,TMP_86(uint256) = TMP_85 / 100,countbonus(uint256) := TMP_86(uint256),TMP_87(bool) = msg.value >= bonusCond3,CONDITION TMP_87,TMP_88(uint256) = tokens * 3,TMP_89(uint256) = TMP_88 / 100,countbonus(uint256) := TMP_89(uint256),countbonus(uint256) := 0(uint256),TMP_90(uint256) = tokens + countbonus,bonus(uint256) := TMP_90(uint256),TMP_91(bool) = tokens == 0,CONDITION TMP_91,valdrop(uint256) := 0(uint256),REF_12(bool) -> Claimed[investor],TMP_92(bool) = REF_12 == False,TMP_93(bool) = progress0drop <= target0drop,TMP_94(bool) = TMP_92 && TMP_93,CONDITION TMP_94,TMP_95(bool) = INTERNAL_CALL, Lucky_2020.distr(address,uint256)(investor,valdrop),REF_13(bool) -> Claimed[investor],REF_13(bool) (->Claimed) := True(bool),TMP_96(uint256) := progress0drop(uint256),progress0drop(uint256) = progress0drop + 1,TMP_97(bool) = msg.value >= requestMinimum,TMP_98(None) = SOLIDITY_CALL require(bool)(TMP_97),TMP_99(bool) = tokens > 0,TMP_100(bool) = msg.value >= requestMinimum,TMP_101(bool) = TMP_99 && TMP_100,CONDITION TMP_101,TMP_102(bool) = now >= deadline,TMP_103(bool) = now >= round1,TMP_104(bool) = TMP_102 && TMP_103,TMP_105(bool) = now < round2,TMP_106(bool) = TMP_104 && TMP_105,CONDITION TMP_106,TMP_107(bool) = INTERNAL_CALL, Lucky_2020.distr(address,uint256)(investor,tokens),TMP_108(bool) = msg.value >= bonusCond1,CONDITION TMP_108,TMP_109(bool) = INTERNAL_CALL, Lucky_2020.distr(address,uint256)(investor,bonus),TMP_110(bool) = INTERNAL_CALL, Lucky_2020.distr(address,uint256)(investor,tokens),TMP_111(bool) = msg.value >= requestMinimum,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113(bool) = totalDistributed >= totalSupply,CONDITION TMP_113,distributionFinished(bool) := True(bool),Transfer dest:multisig value:msg.value,MODIFIER_CALL, Lucky_2020.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->57;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bonusCond1 = 5000000000000000000 / 100

IRs:
TMP_45(uint256) = 5000000000000000000 / 100
bonusCond1(uint256) := TMP_45(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bonusCond2 = 1000000000000000000 / 10

IRs:
TMP_46(uint256) = 1000000000000000000 / 10
bonusCond2(uint256) := TMP_46(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
bonusCond3 = 5000000000000000000 / 10

IRs:
TMP_47(uint256) = 5000000000000000000 / 10
bonusCond3(uint256) := TMP_47(uint256)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
bonusCond4 = 1000000000000000000

IRs:
bonusCond4(uint256) := 1000000000000000000(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_48(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_49(uint256) = TMP_48 / 1000000000000000000
tokens(uint256) := TMP_49(uint256)""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now < round1 && now < round2

IRs:
TMP_50(bool) = msg.value >= requestMinimum
TMP_51(bool) = now < deadline
TMP_52(bool) = TMP_50 && TMP_51
TMP_53(bool) = now < round1
TMP_54(bool) = TMP_52 && TMP_53
TMP_55(bool) = now < round2
TMP_56(bool) = TMP_54 && TMP_55
CONDITION TMP_56""];
10->11[label=""True""];
10->23[label=""False""];
11[label=""Node Type: IF 11

EXPRESSION:
msg.value >= bonusCond1 && msg.value < bonusCond2

IRs:
TMP_57(bool) = msg.value >= bonusCond1
TMP_58(bool) = msg.value < bonusCond2
TMP_59(bool) = TMP_57 && TMP_58
CONDITION TMP_59""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
countbonus = tokens * 10 / 100

IRs:
TMP_60(uint256) = tokens * 10
TMP_61(uint256) = TMP_60 / 100
countbonus(uint256) := TMP_61(uint256)""];
12->22;
13[label=""Node Type: IF 13

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_62(bool) = msg.value >= bonusCond2
TMP_63(bool) = msg.value < bonusCond3
TMP_64(bool) = TMP_62 && TMP_63
CONDITION TMP_64""];
13->14[label=""True""];
13->15[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
countbonus = tokens * 20 / 100

IRs:
TMP_65(uint256) = tokens * 20
TMP_66(uint256) = TMP_65 / 100
countbonus(uint256) := TMP_66(uint256)""];
14->21;
15[label=""Node Type: IF 15

EXPRESSION:
msg.value >= bonusCond3 && msg.value < bonusCond4

IRs:
TMP_67(bool) = msg.value >= bonusCond3
TMP_68(bool) = msg.value < bonusCond4
TMP_69(bool) = TMP_67 && TMP_68
CONDITION TMP_69""];
15->16[label=""True""];
15->17[label=""False""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
countbonus = tokens * 35 / 100

IRs:
TMP_70(uint256) = tokens * 35
TMP_71(uint256) = TMP_70 / 100
countbonus(uint256) := TMP_71(uint256)""];
16->20;
17[label=""Node Type: IF 17

EXPRESSION:
msg.value >= bonusCond4

IRs:
TMP_72(bool) = msg.value >= bonusCond4
CONDITION TMP_72""];
17->18[label=""True""];
17->19[label=""False""];
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
countbonus = tokens * 50 / 100

IRs:
TMP_73(uint256) = tokens * 50
TMP_74(uint256) = TMP_73 / 100
countbonus(uint256) := TMP_74(uint256)""];
18->19;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: END_IF 21
""];
21->22;
22[label=""Node Type: END_IF 22
""];
22->32;
23[label=""Node Type: IF 23

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now > round1 && now < round2

IRs:
TMP_75(bool) = msg.value >= requestMinimum
TMP_76(bool) = now < deadline
TMP_77(bool) = TMP_75 && TMP_76
TMP_78(bool) = now > round1
TMP_79(bool) = TMP_77 && TMP_78
TMP_80(bool) = now < round2
TMP_81(bool) = TMP_79 && TMP_80
CONDITION TMP_81""];
23->24[label=""True""];
23->30[label=""False""];
24[label=""Node Type: IF 24

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_82(bool) = msg.value >= bonusCond2
TMP_83(bool) = msg.value < bonusCond3
TMP_84(bool) = TMP_82 && TMP_83
CONDITION TMP_84""];
24->25[label=""True""];
24->26[label=""False""];
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
countbonus = tokens * 2 / 100

IRs:
TMP_85(uint256) = tokens * 2
TMP_86(uint256) = TMP_85 / 100
countbonus(uint256) := TMP_86(uint256)""];
25->29;
26[label=""Node Type: IF 26

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_87(bool) = msg.value >= bonusCond3
CONDITION TMP_87""];
26->27[label=""True""];
26->28[label=""False""];
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
countbonus = tokens * 3 / 100

IRs:
TMP_88(uint256) = tokens * 3
TMP_89(uint256) = TMP_88 / 100
countbonus(uint256) := TMP_89(uint256)""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: END_IF 29
""];
29->31;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
30->31;
31[label=""Node Type: END_IF 31
""];
31->32;
32[label=""Node Type: END_IF 32
""];
32->33;
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
bonus = tokens + countbonus

IRs:
TMP_90(uint256) = tokens + countbonus
bonus(uint256) := TMP_90(uint256)""];
33->34;
34[label=""Node Type: IF 34

EXPRESSION:
tokens == 0

IRs:
TMP_91(bool) = tokens == 0
CONDITION TMP_91""];
34->35[label=""True""];
34->42[label=""False""];
35[label=""Node Type: NEW VARIABLE 35

EXPRESSION:
valdrop = 0e0

IRs:
valdrop(uint256) := 0(uint256)""];
35->36;
36[label=""Node Type: IF 36

EXPRESSION:
Claimed[investor] == false && progress0drop <= target0drop

IRs:
REF_12(bool) -> Claimed[investor]
TMP_92(bool) = REF_12 == False
TMP_93(bool) = progress0drop <= target0drop
TMP_94(bool) = TMP_92 && TMP_93
CONDITION TMP_94""];
36->37[label=""True""];
36->40[label=""False""];
37[label=""Node Type: EXPRESSION 37

EXPRESSION:
distr(investor,valdrop)

IRs:
TMP_95(bool) = INTERNAL_CALL, Lucky_2020.distr(address,uint256)(investor,valdrop)""];
37->38;
38[label=""Node Type: EXPRESSION 38

EXPRESSION:
Claimed[investor] = true

IRs:
REF_13(bool) -> Claimed[investor]
REF_13(bool) (->Claimed) := True(bool)""];
38->39;
39[label=""Node Type: EXPRESSION 39

EXPRESSION:
progress0drop ++

IRs:
TMP_96(uint256) := progress0drop(uint256)
progress0drop(uint256) = progress0drop + 1""];
39->41;
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_97(bool) = msg.value >= requestMinimum
TMP_98(None) = SOLIDITY_CALL require(bool)(TMP_97)""];
40->41;
41[label=""Node Type: END_IF 41
""];
41->52;
42[label=""Node Type: IF 42

EXPRESSION:
tokens > 0 && msg.value >= requestMinimum

IRs:
TMP_99(bool) = tokens > 0
TMP_100(bool) = msg.value >= requestMinimum
TMP_101(bool) = TMP_99 && TMP_100
CONDITION TMP_101""];
42->43[label=""True""];
42->50[label=""False""];
43[label=""Node Type: IF 43

EXPRESSION:
now >= deadline && now >= round1 && now < round2

IRs:
TMP_102(bool) = now >= deadline
TMP_103(bool) = now >= round1
TMP_104(bool) = TMP_102 && TMP_103
TMP_105(bool) = now < round2
TMP_106(bool) = TMP_104 && TMP_105
CONDITION TMP_106""];
43->44[label=""True""];
43->45[label=""False""];
44[label=""Node Type: EXPRESSION 44

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_107(bool) = INTERNAL_CALL, Lucky_2020.distr(address,uint256)(investor,tokens)""];
44->49;
45[label=""Node Type: IF 45

EXPRESSION:
msg.value >= bonusCond1

IRs:
TMP_108(bool) = msg.value >= bonusCond1
CONDITION TMP_108""];
45->46[label=""True""];
45->47[label=""False""];
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
distr(investor,bonus)

IRs:
TMP_109(bool) = INTERNAL_CALL, Lucky_2020.distr(address,uint256)(investor,bonus)""];
46->48;
47[label=""Node Type: EXPRESSION 47

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_110(bool) = INTERNAL_CALL, Lucky_2020.distr(address,uint256)(investor,tokens)""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: END_IF 49
""];
49->51;
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_111(bool) = msg.value >= requestMinimum
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: END_IF 52
""];
52->53;
53[label=""Node Type: IF 53

EXPRESSION:
totalDistributed >= totalSupply

IRs:
TMP_113(bool) = totalDistributed >= totalSupply
CONDITION TMP_113""];
53->54[label=""True""];
53->55[label=""False""];
54[label=""Node Type: EXPRESSION 54

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)""];
54->55;
55[label=""Node Type: END_IF 55
""];
55->56;
56[label=""Node Type: EXPRESSION 56

EXPRESSION:
multisig.transfer(msg.value)

IRs:
Transfer dest:multisig value:msg.value""];
57[label=""Node Type: EXPRESSION 57

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, Lucky_2020.canDistr()()""];
57->1;
}
",0,0,1,0,"canDistr();tokens = 0;bonus = 0;countbonus = 0;bonusCond1 = 5000000000000000000 / 100;bonusCond2 = 1000000000000000000 / 10;bonusCond3 = 5000000000000000000 / 10;bonusCond4 = 1000000000000000000;tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;investor = msg.sender;msg.value >= requestMinimum && now < deadline && now < round1 && now < round2;msg.value >= bonusCond1 && msg.value < bonusCond2;msg.value >= requestMinimum && now < deadline && now > round1 && now < round2;countbonus = tokens * 10 / 100;msg.value >= bonusCond2 && msg.value < bonusCond3;;countbonus = tokens * 20 / 100;msg.value >= bonusCond3 && msg.value < bonusCond4;;countbonus = tokens * 35 / 100;msg.value >= bonusCond4;;countbonus = tokens * 50 / 100;;;msg.value >= bonusCond2 && msg.value < bonusCond3;countbonus = 0;countbonus = tokens * 2 / 100;msg.value >= bonusCond3;;countbonus = tokens * 3 / 100;;;bonus = tokens + countbonus;tokens == 0;valdrop = 0e0;tokens > 0 && msg.value >= requestMinimum;Claimed[investor] == false && progress0drop <= target0drop;distr(investor,valdrop);require(bool)(msg.value >= requestMinimum);Claimed[investor] = true;progress0drop ++;;;now >= deadline && now >= round1 && now < round2;require(bool)(msg.value >= requestMinimum);distr(investor,tokens);msg.value >= bonusCond1;;distr(investor,bonus);distr(investor,tokens);;;totalDistributed >= totalSupply;distributionFinished = true;;multisig.transfer(msg.value)"
./0x6c4fe5b5b3f8a60fd5d036940afef65c73e4d2ae_ext.sol,MCFitCrowdsale.close,450,461,"REF_164(MCFitCrowdsale.State) -> State.Active,TMP_268(bool) = state == REF_164,TMP_269(None) = SOLIDITY_CALL require(bool)(TMP_268),CONDITION checkDate,TMP_270(bool) = INTERNAL_CALL, Crowdsale.hasEnded()(),TMP_271(None) = SOLIDITY_CALL require(bool)(TMP_270),REF_165(MCFitCrowdsale.State) -> State.Closed,state(MCFitCrowdsale.State) := REF_165(MCFitCrowdsale.State),transfersEnabled(bool) := False(bool),TMP_272(bool) = INTERNAL_CALL, MintableToken.finishMinting()(),Emit Closed(),INTERNAL_CALL, Crowdsale.finalize()(),REF_167(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:wallet value:REF_167,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_164(MCFitCrowdsale.State) -> State.Active
TMP_268(bool) = state == REF_164
TMP_269(None) = SOLIDITY_CALL require(bool)(TMP_268)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
checkDate

IRs:
CONDITION checkDate""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(hasEnded())

IRs:
TMP_270(bool) = INTERNAL_CALL, Crowdsale.hasEnded()()
TMP_271(None) = SOLIDITY_CALL require(bool)(TMP_270)""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
state = State.Closed

IRs:
REF_165(MCFitCrowdsale.State) -> State.Closed
state(MCFitCrowdsale.State) := REF_165(MCFitCrowdsale.State)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
transfersEnabled = false

IRs:
transfersEnabled(bool) := False(bool)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
finishMinting()

IRs:
TMP_272(bool) = INTERNAL_CALL, MintableToken.finishMinting()()""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Closed()

IRs:
Emit Closed()""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
finalize()

IRs:
INTERNAL_CALL, Crowdsale.finalize()()""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
wallet.transfer(this.balance)

IRs:
REF_167(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:wallet value:REF_167""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
11->1;
}
",0,0,1,0,onlyOwner();require(bool)(state == State.Active);checkDate;require(bool)(hasEnded());;state = State.Closed;transfersEnabled = false;finishMinting();Closed();finalize();wallet.transfer(this.balance)
./0x000000002bb43c83ece652d161ad0fa862129a2c_ext.sol,AccountRegistry.deregister,333,344,"REF_100(AccountRegistry.Account) -> accounts[msg.sender],account(AccountRegistry.Account) := REF_100(AccountRegistry.Account),REF_101(uint8) -> account.membership,TMP_94(uint8) = REF_101 & VOTER,TMP_95(bool) = TMP_94 != 0,TMP_96(None) = SOLIDITY_CALL require(bool)(TMP_95),REF_102(uint256) -> account.lastAccess,TMP_97(uint256) = REF_102 + 604800,TMP_98(bool) = TMP_97 <= now,TMP_99(None) = SOLIDITY_CALL require(bool)(TMP_98),REF_103(uint8) -> account.membership,REF_103(-> account) = REF_103 ^ VOTER,REF_104(uint256) -> account.lastAccess,REF_104(uint256) (->account) := 0(uint256),Transfer dest:msg.sender value:registrationDeposit,Emit Deregistered(msg.sender)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
account = accounts[msg.sender]

IRs:
REF_100(AccountRegistry.Account) -> accounts[msg.sender]
account(AccountRegistry.Account) := REF_100(AccountRegistry.Account)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(account.membership & VOTER != 0)

IRs:
REF_101(uint8) -> account.membership
TMP_94(uint8) = REF_101 & VOTER
TMP_95(bool) = TMP_94 != 0
TMP_96(None) = SOLIDITY_CALL require(bool)(TMP_95)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(account.lastAccess + 604800 <= now)

IRs:
REF_102(uint256) -> account.lastAccess
TMP_97(uint256) = REF_102 + 604800
TMP_98(bool) = TMP_97 <= now
TMP_99(None) = SOLIDITY_CALL require(bool)(TMP_98)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
account.membership ^= VOTER

IRs:
REF_103(uint8) -> account.membership
REF_103(-> account) = REF_103 ^ VOTER""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
account.lastAccess = 0

IRs:
REF_104(uint256) -> account.lastAccess
REF_104(uint256) (->account) := 0(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
msg.sender.transfer(registrationDeposit)

IRs:
Transfer dest:msg.sender value:registrationDeposit""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Deregistered(msg.sender)

IRs:
Emit Deregistered(msg.sender)""];
}
",0,0,1,0,account = accounts[msg.sender];require(bool)(account.membership & VOTER != 0);require(bool)(account.lastAccess + 604800 <= now);account.membership ^= VOTER;account.lastAccess = 0;msg.sender.transfer(registrationDeposit);Deregistered(msg.sender)
./0x549b38e8e5fb1ba4acd4187d8b7c8a04deb53206_ext.sol,LotteryAdmin.destruct,98,100,"TMP_26(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, LotteryAdmin.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_26(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, LotteryAdmin.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0x5838f878000fe44b6f6c677bbf839e12f097c147_ext.sol,Q_GAME.StopGame,29,32,"TMP_9(bool) = msg.sender == questionSender,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_9(bool) = msg.sender == questionSender
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0x46822ac3bc32db7ebd9845da3fe0886f824e9edf_ext.sol,EBSCSale.ownerSafeWithdrawal,658,663,"TMP_234(None) = SOLIDITY_CALL require(bool)(fundingGoalReached),REF_129(uint256) = SOLIDITY_CALL balance(address)(this),balanceToSend(uint256) := REF_129([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B6A437C0>]),Transfer dest:beneficiary value:balanceToSend,Emit FundTransfer(beneficiary,balanceToSend,False),MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, EBSCSale.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(fundingGoalReached)

IRs:
TMP_234(None) = SOLIDITY_CALL require(bool)(fundingGoalReached)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
balanceToSend = this.balance

IRs:
REF_129(uint256) = SOLIDITY_CALL balance(address)(this)
balanceToSend(uint256) := REF_129([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B6A437C0>])""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
beneficiary.transfer(balanceToSend)

IRs:
Transfer dest:beneficiary value:balanceToSend""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
FundTransfer(beneficiary,balanceToSend,false)

IRs:
Emit FundTransfer(beneficiary,balanceToSend,False)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, EBSCSale.nonReentrant()()""];
6->1;
}
",0,0,1,0,"onlyOwner();require(bool)(fundingGoalReached);balanceToSend = this.balance;beneficiary.transfer(balanceToSend);FundTransfer(beneficiary,balanceToSend,false);nonReentrant()"
./0xd7f4aea7c2b8d633d88c449eab91d7d5ef89427e_ext.sol,EDAX.withdraw,295,298,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, EDAX.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, EDAX.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x6bd26bb09c992e09d2156b48f723e56e52eead9c_ext.sol,MiniMeToken.claimTokens,559,569,"TMP_136(bool) = _token == 0,CONDITION TMP_136,REF_58(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:controller value:REF_58,TMP_138 = CONVERT _token to MiniMeToken,token(MiniMeToken) := TMP_138(MiniMeToken),TMP_139(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_139(uint256),TMP_140(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  ,Emit ClaimedTokens(_token,controller,balance),MODIFIER_CALL, Controlled.onlyController()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_136(bool) = _token == 0
CONDITION TMP_136""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_58(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_58""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
token = MiniMeToken(_token)

IRs:
TMP_138 = CONVERT _token to MiniMeToken
token(MiniMeToken) := TMP_138(MiniMeToken)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_139(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_139(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_140(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()""];
9->1;
}
",0,0,1,0,"onlyController();_token == 0x0;controller.transfer(this.balance);;;token = MiniMeToken(_token);balance = token.balanceOf(this);token.transfer(controller,balance);ClaimedTokens(_token,controller,balance)"
./0xe3dd9bb9022c805660a2cd5914f89e92014229c1_ext.sol,go_to_play.StopGame,33,36,"TMP_10(bool) = msg.sender == questionSender,TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_10(bool) = msg.sender == questionSender
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0xcdf35c3fe4ccfacb3b1bbedfe71ca3a5ff6f2db1_ext.sol,GenericCrowdsale.withdrawFunding,666,669,"REF_128(GenericCrowdsale.State) -> State.PreIco,TMP_336(bool) = state == REF_128,TMP_337(bool) = INTERNAL_CALL, GenericCrowdsale.successed()(),TMP_338(bool) = TMP_336 || TMP_337,TMP_339(None) = SOLIDITY_CALL require(bool)(TMP_338),REF_130(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:beneficiary value:REF_130,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((state == State.PreIco || successed()))

IRs:
REF_128(GenericCrowdsale.State) -> State.PreIco
TMP_336(bool) = state == REF_128
TMP_337(bool) = INTERNAL_CALL, GenericCrowdsale.successed()()
TMP_338(bool) = TMP_336 || TMP_337
TMP_339(None) = SOLIDITY_CALL require(bool)(TMP_338)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
beneficiary.transfer(this.balance)

IRs:
REF_130(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:beneficiary value:REF_130""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();require(bool)((state == State.PreIco || successed()));beneficiary.transfer(this.balance)
./0xf1171e1e8df34ab97832342c7cbf04d9121a1ac3_ext.sol,CSportsContest.transferApprovedFunds,382,400,"REF_7(uint128) -> authorizedUserPayment[msg.sender],amount(uint128) := REF_7(uint128),TMP_118(bool) = amount > 0,CONDITION TMP_118,TMP_119(bool) = totalAuthorizedForPayment >= amount,CONDITION TMP_119,REF_8(uint128) -> authorizedUserPayment[msg.sender],authorizedUserPayment = delete REF_8 ,totalAuthorizedForPayment(uint128) = totalAuthorizedForPayment - amount,Transfer dest:msg.sender value:amount,Emit ContestApprovedFundsDelivered(msg.sender,amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
amount = authorizedUserPayment[msg.sender]

IRs:
REF_7(uint128) -> authorizedUserPayment[msg.sender]
amount(uint128) := REF_7(uint128)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
amount > 0

IRs:
TMP_118(bool) = amount > 0
CONDITION TMP_118""];
2->3[label=""True""];
2->9[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
totalAuthorizedForPayment >= amount

IRs:
TMP_119(bool) = totalAuthorizedForPayment >= amount
CONDITION TMP_119""];
3->4[label=""True""];
3->8[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
delete authorizedUserPayment[msg.sender]

IRs:
REF_8(uint128) -> authorizedUserPayment[msg.sender]
authorizedUserPayment = delete REF_8 ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalAuthorizedForPayment -= amount

IRs:
totalAuthorizedForPayment(uint128) = totalAuthorizedForPayment - amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
ContestApprovedFundsDelivered(msg.sender,amount)

IRs:
Emit ContestApprovedFundsDelivered(msg.sender,amount)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
}
",0,0,1,0,"amount = authorizedUserPayment[msg.sender];amount > 0;totalAuthorizedForPayment >= amount;;delete authorizedUserPayment[msg.sender];;totalAuthorizedForPayment -= amount;msg.sender.transfer(amount);ContestApprovedFundsDelivered(msg.sender,amount)"
./0x6f91e584f4c150951386b133e21aa769c8b7d060_ext.sol,BigbomTokenSale.sendETHToMultiSig,679,681,Transfer dest:bigbomMultiSigWallet value:value,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
bigbomMultiSigWallet.transfer(value)

IRs:
Transfer dest:bigbomMultiSigWallet value:value""];
}
",0,0,1,0,bigbomMultiSigWallet.transfer(value)
./0xbf2000b42c1ba2eb9e5163a0b7e2fe987ed124b4_ext.sol,SeedCrowdsaleContract.refundTransaction,177,183,"CONDITION _stateChanged,Transfer dest:msg.sender value:msg.value,TMP_51(None) = SOLIDITY_CALL revert()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_stateChanged

IRs:
CONDITION _stateChanged""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(msg.value)

IRs:
Transfer dest:msg.sender value:msg.value""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
revert()()

IRs:
TMP_51(None) = SOLIDITY_CALL revert()()""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,_stateChanged;msg.sender.transfer(msg.value);revert()();
./0xc80205befdb86a1891019969001e90b064d5735a_ext.sol,MILO.getTokens,174,233,"tokens(uint256) := 0(uint256),bonus(uint256) := 0(uint256),countbonus(uint256) := 0(uint256),TMP_45(uint256) = 1000000000000000000 / 2,bonusCond1(uint256) := TMP_45(uint256),bonusCond2(uint256) := 1000000000000000000(uint256),bonusCond3(uint256) := 3000000000000000000(uint256),TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_47(uint256) = TMP_46 / 1000000000000000000,tokens(uint256) := TMP_47(uint256),investor(address) := msg.sender(address),TMP_48(bool) = msg.value >= requestMinimum,TMP_49(bool) = now < deadline,TMP_50(bool) = TMP_48 && TMP_49,TMP_51(bool) = now < round1,TMP_52(bool) = TMP_50 && TMP_51,TMP_53(bool) = now < round2,TMP_54(bool) = TMP_52 && TMP_53,CONDITION TMP_54,TMP_55(bool) = msg.value >= bonusCond1,TMP_56(bool) = msg.value < bonusCond2,TMP_57(bool) = TMP_55 && TMP_56,CONDITION TMP_57,TMP_58(uint256) = tokens * 10,TMP_59(uint256) = TMP_58 / 100,countbonus(uint256) := TMP_59(uint256),TMP_60(bool) = msg.value >= bonusCond2,TMP_61(bool) = msg.value < bonusCond3,TMP_62(bool) = TMP_60 && TMP_61,CONDITION TMP_62,TMP_63(uint256) = tokens * 50,TMP_64(uint256) = TMP_63 / 100,countbonus(uint256) := TMP_64(uint256),TMP_65(bool) = msg.value >= bonusCond3,CONDITION TMP_65,TMP_66(uint256) = tokens * 75,TMP_67(uint256) = TMP_66 / 100,countbonus(uint256) := TMP_67(uint256),TMP_68(bool) = msg.value >= requestMinimum,TMP_69(bool) = now < deadline,TMP_70(bool) = TMP_68 && TMP_69,TMP_71(bool) = now > round1,TMP_72(bool) = TMP_70 && TMP_71,TMP_73(bool) = now < round2,TMP_74(bool) = TMP_72 && TMP_73,CONDITION TMP_74,TMP_75(bool) = msg.value >= bonusCond2,TMP_76(bool) = msg.value < bonusCond3,TMP_77(bool) = TMP_75 && TMP_76,CONDITION TMP_77,TMP_78(uint256) = tokens * 25,TMP_79(uint256) = TMP_78 / 100,countbonus(uint256) := TMP_79(uint256),TMP_80(bool) = msg.value >= bonusCond3,CONDITION TMP_80,TMP_81(uint256) = tokens * 50,TMP_82(uint256) = TMP_81 / 100,countbonus(uint256) := TMP_82(uint256),countbonus(uint256) := 0(uint256),TMP_83(uint256) = tokens + countbonus,bonus(uint256) := TMP_83(uint256),TMP_84(bool) = tokens == 0,CONDITION TMP_84,valdrop(uint256) := 51100000000000(uint256),REF_12(bool) -> Claimed[investor],TMP_85(bool) = REF_12 == False,TMP_86(bool) = progress0drop <= target0drop,TMP_87(bool) = TMP_85 && TMP_86,CONDITION TMP_87,TMP_88(bool) = INTERNAL_CALL, MILO.distr(address,uint256)(investor,valdrop),REF_13(bool) -> Claimed[investor],REF_13(bool) (->Claimed) := True(bool),TMP_89(uint256) := progress0drop(uint256),progress0drop(uint256) = progress0drop + 1,TMP_90(bool) = msg.value >= requestMinimum,TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),TMP_92(bool) = tokens > 0,TMP_93(bool) = msg.value >= requestMinimum,TMP_94(bool) = TMP_92 && TMP_93,CONDITION TMP_94,TMP_95(bool) = now >= deadline,TMP_96(bool) = now >= round1,TMP_97(bool) = TMP_95 && TMP_96,TMP_98(bool) = now < round2,TMP_99(bool) = TMP_97 && TMP_98,CONDITION TMP_99,TMP_100(bool) = INTERNAL_CALL, MILO.distr(address,uint256)(investor,tokens),TMP_101(bool) = msg.value >= bonusCond1,CONDITION TMP_101,TMP_102(bool) = INTERNAL_CALL, MILO.distr(address,uint256)(investor,bonus),TMP_103(bool) = INTERNAL_CALL, MILO.distr(address,uint256)(investor,tokens),TMP_104(bool) = msg.value >= requestMinimum,TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104),TMP_106(bool) = totalDistributed >= totalSupply,CONDITION TMP_106,distributionFinished(bool) := True(bool),Transfer dest:multisig value:msg.value,MODIFIER_CALL, MILO.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->53;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bonusCond1 = 1000000000000000000 / 2

IRs:
TMP_45(uint256) = 1000000000000000000 / 2
bonusCond1(uint256) := TMP_45(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bonusCond2 = 1000000000000000000

IRs:
bonusCond2(uint256) := 1000000000000000000(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
bonusCond3 = 3000000000000000000

IRs:
bonusCond3(uint256) := 3000000000000000000(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_47(uint256) = TMP_46 / 1000000000000000000
tokens(uint256) := TMP_47(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now < round1 && now < round2

IRs:
TMP_48(bool) = msg.value >= requestMinimum
TMP_49(bool) = now < deadline
TMP_50(bool) = TMP_48 && TMP_49
TMP_51(bool) = now < round1
TMP_52(bool) = TMP_50 && TMP_51
TMP_53(bool) = now < round2
TMP_54(bool) = TMP_52 && TMP_53
CONDITION TMP_54""];
9->10[label=""True""];
9->19[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
msg.value >= bonusCond1 && msg.value < bonusCond2

IRs:
TMP_55(bool) = msg.value >= bonusCond1
TMP_56(bool) = msg.value < bonusCond2
TMP_57(bool) = TMP_55 && TMP_56
CONDITION TMP_57""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
countbonus = tokens * 10 / 100

IRs:
TMP_58(uint256) = tokens * 10
TMP_59(uint256) = TMP_58 / 100
countbonus(uint256) := TMP_59(uint256)""];
11->18;
12[label=""Node Type: IF 12

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_60(bool) = msg.value >= bonusCond2
TMP_61(bool) = msg.value < bonusCond3
TMP_62(bool) = TMP_60 && TMP_61
CONDITION TMP_62""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
countbonus = tokens * 50 / 100

IRs:
TMP_63(uint256) = tokens * 50
TMP_64(uint256) = TMP_63 / 100
countbonus(uint256) := TMP_64(uint256)""];
13->17;
14[label=""Node Type: IF 14

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_65(bool) = msg.value >= bonusCond3
CONDITION TMP_65""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
countbonus = tokens * 75 / 100

IRs:
TMP_66(uint256) = tokens * 75
TMP_67(uint256) = TMP_66 / 100
countbonus(uint256) := TMP_67(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->28;
19[label=""Node Type: IF 19

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now > round1 && now < round2

IRs:
TMP_68(bool) = msg.value >= requestMinimum
TMP_69(bool) = now < deadline
TMP_70(bool) = TMP_68 && TMP_69
TMP_71(bool) = now > round1
TMP_72(bool) = TMP_70 && TMP_71
TMP_73(bool) = now < round2
TMP_74(bool) = TMP_72 && TMP_73
CONDITION TMP_74""];
19->20[label=""True""];
19->26[label=""False""];
20[label=""Node Type: IF 20

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_75(bool) = msg.value >= bonusCond2
TMP_76(bool) = msg.value < bonusCond3
TMP_77(bool) = TMP_75 && TMP_76
CONDITION TMP_77""];
20->21[label=""True""];
20->22[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
countbonus = tokens * 25 / 100

IRs:
TMP_78(uint256) = tokens * 25
TMP_79(uint256) = TMP_78 / 100
countbonus(uint256) := TMP_79(uint256)""];
21->25;
22[label=""Node Type: IF 22

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_80(bool) = msg.value >= bonusCond3
CONDITION TMP_80""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
countbonus = tokens * 50 / 100

IRs:
TMP_81(uint256) = tokens * 50
TMP_82(uint256) = TMP_81 / 100
countbonus(uint256) := TMP_82(uint256)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->27;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
bonus = tokens + countbonus

IRs:
TMP_83(uint256) = tokens + countbonus
bonus(uint256) := TMP_83(uint256)""];
29->30;
30[label=""Node Type: IF 30

EXPRESSION:
tokens == 0

IRs:
TMP_84(bool) = tokens == 0
CONDITION TMP_84""];
30->31[label=""True""];
30->38[label=""False""];
31[label=""Node Type: NEW VARIABLE 31

EXPRESSION:
valdrop = 511000e8

IRs:
valdrop(uint256) := 51100000000000(uint256)""];
31->32;
32[label=""Node Type: IF 32

EXPRESSION:
Claimed[investor] == false && progress0drop <= target0drop

IRs:
REF_12(bool) -> Claimed[investor]
TMP_85(bool) = REF_12 == False
TMP_86(bool) = progress0drop <= target0drop
TMP_87(bool) = TMP_85 && TMP_86
CONDITION TMP_87""];
32->33[label=""True""];
32->36[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
distr(investor,valdrop)

IRs:
TMP_88(bool) = INTERNAL_CALL, MILO.distr(address,uint256)(investor,valdrop)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
Claimed[investor] = true

IRs:
REF_13(bool) -> Claimed[investor]
REF_13(bool) (->Claimed) := True(bool)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
progress0drop ++

IRs:
TMP_89(uint256) := progress0drop(uint256)
progress0drop(uint256) = progress0drop + 1""];
35->37;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_90(bool) = msg.value >= requestMinimum
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
36->37;
37[label=""Node Type: END_IF 37
""];
37->48;
38[label=""Node Type: IF 38

EXPRESSION:
tokens > 0 && msg.value >= requestMinimum

IRs:
TMP_92(bool) = tokens > 0
TMP_93(bool) = msg.value >= requestMinimum
TMP_94(bool) = TMP_92 && TMP_93
CONDITION TMP_94""];
38->39[label=""True""];
38->46[label=""False""];
39[label=""Node Type: IF 39

EXPRESSION:
now >= deadline && now >= round1 && now < round2

IRs:
TMP_95(bool) = now >= deadline
TMP_96(bool) = now >= round1
TMP_97(bool) = TMP_95 && TMP_96
TMP_98(bool) = now < round2
TMP_99(bool) = TMP_97 && TMP_98
CONDITION TMP_99""];
39->40[label=""True""];
39->41[label=""False""];
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_100(bool) = INTERNAL_CALL, MILO.distr(address,uint256)(investor,tokens)""];
40->45;
41[label=""Node Type: IF 41

EXPRESSION:
msg.value >= bonusCond1

IRs:
TMP_101(bool) = msg.value >= bonusCond1
CONDITION TMP_101""];
41->42[label=""True""];
41->43[label=""False""];
42[label=""Node Type: EXPRESSION 42

EXPRESSION:
distr(investor,bonus)

IRs:
TMP_102(bool) = INTERNAL_CALL, MILO.distr(address,uint256)(investor,bonus)""];
42->44;
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_103(bool) = INTERNAL_CALL, MILO.distr(address,uint256)(investor,tokens)""];
43->44;
44[label=""Node Type: END_IF 44
""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->47;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_104(bool) = msg.value >= requestMinimum
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: IF 49

EXPRESSION:
totalDistributed >= totalSupply

IRs:
TMP_106(bool) = totalDistributed >= totalSupply
CONDITION TMP_106""];
49->50[label=""True""];
49->51[label=""False""];
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
multisig.transfer(msg.value)

IRs:
Transfer dest:multisig value:msg.value""];
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, MILO.canDistr()()""];
53->1;
}
",0,0,1,0,"canDistr();tokens = 0;bonus = 0;countbonus = 0;bonusCond1 = 1000000000000000000 / 2;bonusCond2 = 1000000000000000000;bonusCond3 = 3000000000000000000;tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;investor = msg.sender;msg.value >= requestMinimum && now < deadline && now < round1 && now < round2;msg.value >= bonusCond1 && msg.value < bonusCond2;msg.value >= requestMinimum && now < deadline && now > round1 && now < round2;countbonus = tokens * 10 / 100;msg.value >= bonusCond2 && msg.value < bonusCond3;;countbonus = tokens * 50 / 100;msg.value >= bonusCond3;;countbonus = tokens * 75 / 100;;;msg.value >= bonusCond2 && msg.value < bonusCond3;countbonus = 0;countbonus = tokens * 25 / 100;msg.value >= bonusCond3;;countbonus = tokens * 50 / 100;;;bonus = tokens + countbonus;tokens == 0;valdrop = 511000e8;tokens > 0 && msg.value >= requestMinimum;Claimed[investor] == false && progress0drop <= target0drop;distr(investor,valdrop);require(bool)(msg.value >= requestMinimum);Claimed[investor] = true;progress0drop ++;;;now >= deadline && now >= round1 && now < round2;require(bool)(msg.value >= requestMinimum);distr(investor,tokens);msg.value >= bonusCond1;;distr(investor,bonus);distr(investor,tokens);;;totalDistributed >= totalSupply;distributionFinished = true;;multisig.transfer(msg.value)"
./0x217aff4ee5bc1dfcabd8d5c3a36e0b430b02ab9d_ext.sol,ETher_game.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x8d46facfb889740a345755e624942257dc87b5ac_ext.sol,Mortal.close,44,46,"TMP_22(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Owner.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_22(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owner.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0x025dce2d39a46296766db7cac8c322e8f59cd5d9_ext.sol,EthToSmthSwaps.withdraw,130,144,"REF_23(mapping(address => EthToSmthSwaps.Swap)) -> swaps[_ownerAddress],REF_24(EthToSmthSwaps.Swap) -> REF_23[msg.sender],swap(EthToSmthSwaps.Swap) := REF_24(EthToSmthSwaps.Swap),REF_25(bytes20) -> swap.secretHash,TMP_32(bytes32) = SOLIDITY_CALL ripemd160()(_secret),TMP_33(bool) = REF_25 == TMP_32,TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33),REF_26(uint256) -> swap.balance,TMP_35 = CONVERT 0 to uint256,TMP_36(bool) = REF_26 > TMP_35,TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36),REF_27(uint256) -> swap.createdAt,TMP_38(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_27', 'SafeTime'] ,TMP_39(bool) = TMP_38 > now,TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39),TMP_41 = CONVERT ratingContractAddress to Reputation,HIGH_LEVEL_CALL, dest:TMP_41(Reputation), function:change, arguments:['msg.sender', '1']  ,REF_31(uint256) -> swap.balance,Transfer dest:msg.sender value:REF_31,REF_32(mapping(address => EthToSmthSwaps.Swap)) -> swaps[_ownerAddress],REF_33(EthToSmthSwaps.Swap) -> REF_32[msg.sender],REF_34(uint256) -> REF_33.balance,REF_34(uint256) (->swaps) := 0(uint256),REF_35(mapping(address => EthToSmthSwaps.Swap)) -> swaps[_ownerAddress],REF_36(EthToSmthSwaps.Swap) -> REF_35[msg.sender],REF_37(bytes32) -> REF_36.secret,REF_37(bytes32) (->swaps) := _secret(bytes32),Emit Withdraw()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
swap = swaps[_ownerAddress][msg.sender]

IRs:
REF_23(mapping(address => EthToSmthSwaps.Swap)) -> swaps[_ownerAddress]
REF_24(EthToSmthSwaps.Swap) -> REF_23[msg.sender]
swap(EthToSmthSwaps.Swap) := REF_24(EthToSmthSwaps.Swap)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(swap.secretHash == ripemd160()(_secret))

IRs:
REF_25(bytes20) -> swap.secretHash
TMP_32(bytes32) = SOLIDITY_CALL ripemd160()(_secret)
TMP_33(bool) = REF_25 == TMP_32
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(swap.balance > uint256(0))

IRs:
REF_26(uint256) -> swap.balance
TMP_35 = CONVERT 0 to uint256
TMP_36(bool) = REF_26 > TMP_35
TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(swap.createdAt.add(SafeTime) > now)

IRs:
REF_27(uint256) -> swap.createdAt
TMP_38(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_27', 'SafeTime'] 
TMP_39(bool) = TMP_38 > now
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Reputation(ratingContractAddress).change(msg.sender,1)

IRs:
TMP_41 = CONVERT ratingContractAddress to Reputation
HIGH_LEVEL_CALL, dest:TMP_41(Reputation), function:change, arguments:['msg.sender', '1']  ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
msg.sender.transfer(swap.balance)

IRs:
REF_31(uint256) -> swap.balance
Transfer dest:msg.sender value:REF_31""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
swaps[_ownerAddress][msg.sender].balance = 0

IRs:
REF_32(mapping(address => EthToSmthSwaps.Swap)) -> swaps[_ownerAddress]
REF_33(EthToSmthSwaps.Swap) -> REF_32[msg.sender]
REF_34(uint256) -> REF_33.balance
REF_34(uint256) (->swaps) := 0(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
swaps[_ownerAddress][msg.sender].secret = _secret

IRs:
REF_35(mapping(address => EthToSmthSwaps.Swap)) -> swaps[_ownerAddress]
REF_36(EthToSmthSwaps.Swap) -> REF_35[msg.sender]
REF_37(bytes32) -> REF_36.secret
REF_37(bytes32) (->swaps) := _secret(bytes32)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
Withdraw()

IRs:
Emit Withdraw()""];
}
",0,0,1,0,"swap = swaps[_ownerAddress][msg.sender];require(bool)(swap.secretHash == ripemd160()(_secret));require(bool)(swap.balance > uint256(0));require(bool)(swap.createdAt.add(SafeTime) > now);Reputation(ratingContractAddress).change(msg.sender,1);msg.sender.transfer(swap.balance);swaps[_ownerAddress][msg.sender].balance = 0;swaps[_ownerAddress][msg.sender].secret = _secret;Withdraw()"
./0x6d074dfa6111404ee8be2c9f024e32c9fffda1b7_ext.sol,CrowdsaleToken.endIco,306,313,"REF_115(CrowdsaleToken.Stages) -> Stages.icoEnd,currentStage(CrowdsaleToken.Stages) := REF_115(CrowdsaleToken.Stages),TMP_120(bool) = remainingTokens > 0,CONDITION TMP_120,REF_116(uint256) -> balances[owner],REF_117(uint256) -> balances[owner],TMP_121(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_117', 'remainingTokens'] ,REF_116(uint256) (->balances) := TMP_121(uint256),TMP_122 = CONVERT this to address,TMP_123(uint256) = SOLIDITY_CALL balance(address)(TMP_122),Transfer dest:owner value:TMP_123","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
currentStage = Stages.icoEnd

IRs:
REF_115(CrowdsaleToken.Stages) -> Stages.icoEnd
currentStage(CrowdsaleToken.Stages) := REF_115(CrowdsaleToken.Stages)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
remainingTokens > 0

IRs:
TMP_120(bool) = remainingTokens > 0
CONDITION TMP_120""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[owner] = balances[owner].add(remainingTokens)

IRs:
REF_116(uint256) -> balances[owner]
REF_117(uint256) -> balances[owner]
TMP_121(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_117', 'remainingTokens'] 
REF_116(uint256) (->balances) := TMP_121(uint256)""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_122 = CONVERT this to address
TMP_123(uint256) = SOLIDITY_CALL balance(address)(TMP_122)
Transfer dest:owner value:TMP_123""];
}
",0,0,1,0,currentStage = Stages.icoEnd;remainingTokens > 0;balances[owner] = balances[owner].add(remainingTokens);;owner.transfer(address(this).balance)
./0x32e78bdc108565c3f3811a8dc00da797b6c96dfe_ext.sol,AddressWarsBeta.withdrawAmount,711,723,"TMP_134(bool) = amount > 0,TMP_135(None) = SOLIDITY_CALL require(bool)(TMP_134),sender(address) := msg.sender(address),REF_96(uint256) -> _balanceOf[sender],balance(uint256) := REF_96(uint256),TMP_136(bool) = amount <= balance,TMP_137(None) = SOLIDITY_CALL require(bool)(TMP_136),REF_97(uint256) -> _balanceOf[sender],REF_99(uint256) -> _balanceOf[sender],TMP_138(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_99', 'amount'] ,REF_97(uint256) (->_balanceOf) := TMP_138(uint256),Transfer dest:sender value:amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_134(bool) = amount > 0
TMP_135(None) = SOLIDITY_CALL require(bool)(TMP_134)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
sender = msg.sender

IRs:
sender(address) := msg.sender(address)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
balance = _balanceOf[sender]

IRs:
REF_96(uint256) -> _balanceOf[sender]
balance(uint256) := REF_96(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(amount <= balance)

IRs:
TMP_136(bool) = amount <= balance
TMP_137(None) = SOLIDITY_CALL require(bool)(TMP_136)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_balanceOf[sender] = SafeMath.sub(_balanceOf[sender],amount)

IRs:
REF_97(uint256) -> _balanceOf[sender]
REF_99(uint256) -> _balanceOf[sender]
TMP_138(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_99', 'amount'] 
REF_97(uint256) (->_balanceOf) := TMP_138(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
sender.transfer(amount)

IRs:
Transfer dest:sender value:amount""];
}
",0,0,1,0,"require(bool)(amount > 0);sender = msg.sender;balance = _balanceOf[sender];require(bool)(amount <= balance);_balanceOf[sender] = SafeMath.sub(_balanceOf[sender],amount);sender.transfer(amount)"
./0x1cf6949f4b661018b3195f3ff98effe12f587263_ext.sol,AtlantToken.changeOwner,47,55,"TMP_3(bool) = msg.value >= howManyEtherInWeiToBecomeOwner,CONDITION TMP_3,Transfer dest:owner value:msg.value,REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:owner value:REF_3,owner(address) := _newowner(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value >= howManyEtherInWeiToBecomeOwner

IRs:
TMP_3(bool) = msg.value >= howManyEtherInWeiToBecomeOwner
CONDITION TMP_3""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(msg.value)

IRs:
Transfer dest:owner value:msg.value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:owner value:REF_3""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
owner = _newowner

IRs:
owner(address) := _newowner(address)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,0,1,0,msg.value >= howManyEtherInWeiToBecomeOwner;owner.transfer(msg.value);;owner.transfer(this.balance);owner = _newowner
./0x44f12955189e3f01be5daf1dd9002ee4d774f42b_ext.sol,AfterSchoolCrowdsaleToken.batchReturnEthIfFailed,433,451,"REF_107(AfterSchoolCrowdsaleToken.state) -> state.crowdsaleEnded,TMP_203(bool) = crowdsaleState != REF_107,TMP_204(None) = SOLIDITY_CALL require(bool)(TMP_203),TMP_205(bool) = ethRaised < minCap,TMP_206(None) = SOLIDITY_CALL require(bool)(TMP_205),cnt(uint256) := 0(uint256),TMP_207(bool) = cnt < _numberOfReturns,CONDITION TMP_207,REF_108(address) -> contributorIndexes[nextContributorToClaim],currentParticipantAddress(address) := REF_108(address),TMP_208(bool) = currentParticipantAddress == 0,CONDITION TMP_208,REF_109(bool) -> hasClaimedEthWhenFail[currentParticipantAddress],TMP_209 = UnaryType.BANG REF_109 ,CONDITION TMP_209,REF_110(AfterSchoolCrowdsaleToken.ContributorData) -> contributorList[currentParticipantAddress],REF_111(uint256) -> REF_110.contributionAmount,contribution(uint256) := REF_111(uint256),REF_112(bool) -> hasClaimedEthWhenFail[currentParticipantAddress],REF_112(bool) (->hasClaimedEthWhenFail) := True(bool),REF_113(uint256) -> balances[currentParticipantAddress],REF_113(uint256) (->balances) := 0(uint256),TMP_210 = SEND dest:currentParticipantAddress value:contribution,TMP_211 = UnaryType.BANG TMP_210 ,CONDITION TMP_211,Emit ErrorSendingETH(currentParticipantAddress,contribution),nextContributorToClaim(uint256) = nextContributorToClaim + 1,TMP_213(uint256) := cnt(uint256),cnt(uint256) = cnt + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->23;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(crowdsaleState != state.crowdsaleEnded)

IRs:
REF_107(AfterSchoolCrowdsaleToken.state) -> state.crowdsaleEnded
TMP_203(bool) = crowdsaleState != REF_107
TMP_204(None) = SOLIDITY_CALL require(bool)(TMP_203)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(ethRaised < minCap)

IRs:
TMP_205(bool) = ethRaised < minCap
TMP_206(None) = SOLIDITY_CALL require(bool)(TMP_205)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4
""];
4->7;
5[label=""Node Type: BEGIN_LOOP 5
""];
5->8;
6[label=""Node Type: END_LOOP 6
""];
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
cnt = 0

IRs:
cnt(uint256) := 0(uint256)""];
7->5;
8[label=""Node Type: IF_LOOP 8

EXPRESSION:
cnt < _numberOfReturns

IRs:
TMP_207(bool) = cnt < _numberOfReturns
CONDITION TMP_207""];
8->9[label=""True""];
8->6[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
currentParticipantAddress = contributorIndexes[nextContributorToClaim]

IRs:
REF_108(address) -> contributorIndexes[nextContributorToClaim]
currentParticipantAddress(address) := REF_108(address)""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
currentParticipantAddress == 0x0

IRs:
TMP_208(bool) = currentParticipantAddress == 0
CONDITION TMP_208""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: RETURN 11
""];
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
! hasClaimedEthWhenFail[currentParticipantAddress]

IRs:
REF_109(bool) -> hasClaimedEthWhenFail[currentParticipantAddress]
TMP_209 = UnaryType.BANG REF_109 
CONDITION TMP_209""];
13->14[label=""True""];
13->20[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
contribution = contributorList[currentParticipantAddress].contributionAmount

IRs:
REF_110(AfterSchoolCrowdsaleToken.ContributorData) -> contributorList[currentParticipantAddress]
REF_111(uint256) -> REF_110.contributionAmount
contribution(uint256) := REF_111(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
hasClaimedEthWhenFail[currentParticipantAddress] = true

IRs:
REF_112(bool) -> hasClaimedEthWhenFail[currentParticipantAddress]
REF_112(bool) (->hasClaimedEthWhenFail) := True(bool)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
balances[currentParticipantAddress] = 0

IRs:
REF_113(uint256) -> balances[currentParticipantAddress]
REF_113(uint256) (->balances) := 0(uint256)""];
16->17;
17[label=""Node Type: IF 17

EXPRESSION:
! currentParticipantAddress.send(contribution)

IRs:
TMP_210 = SEND dest:currentParticipantAddress value:contribution
TMP_211 = UnaryType.BANG TMP_210 
CONDITION TMP_211""];
17->18[label=""True""];
17->19[label=""False""];
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
ErrorSendingETH(currentParticipantAddress,contribution)

IRs:
Emit ErrorSendingETH(currentParticipantAddress,contribution)""];
18->19;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
nextContributorToClaim += 1

IRs:
nextContributorToClaim(uint256) = nextContributorToClaim + 1""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
cnt ++

IRs:
TMP_213(uint256) := cnt(uint256)
cnt(uint256) = cnt + 1""];
22->8;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
23->1;
}
",0,0,1,0,"onlyOwner();require(bool)(crowdsaleState != state.crowdsaleEnded);require(bool)(ethRaised < minCap);;;cnt = 0;;cnt < _numberOfReturns;;currentParticipantAddress = contributorIndexes[nextContributorToClaim];currentParticipantAddress == 0x0;;;! hasClaimedEthWhenFail[currentParticipantAddress];contribution = contributorList[currentParticipantAddress].contributionAmount;;hasClaimedEthWhenFail[currentParticipantAddress] = true;balances[currentParticipantAddress] = 0;! currentParticipantAddress.send(contribution);ErrorSendingETH(currentParticipantAddress,contribution);;nextContributorToClaim += 1;cnt ++"
./0xd88577ed936819807612c0d4a17ade05adcdf1d3_ext.sol,ZTRTokenSale.withdraw,125,140,"TMP_45(bool) = amountRaised < fundingGoal,CONDITION TMP_45,REF_17(uint256) -> ethBalance[msg.sender],ethVal(uint256) := REF_17(uint256),REF_18(uint256) -> ethBalance[msg.sender],REF_18(uint256) (->ethBalance) := 0(uint256),Transfer dest:msg.sender value:ethVal,REF_20(uint256) -> balanceOf[msg.sender],tokenVal(uint256) := REF_20(uint256),REF_21(uint256) -> balanceOf[msg.sender],REF_21(uint256) (->balanceOf) := 0(uint256),TMP_47 = CONVERT ZTRTokenContract to ZTRToken,t(ZTRToken) := TMP_47(ZTRToken),HIGH_LEVEL_CALL, dest:t(ZTRToken), function:transfer, arguments:['msg.sender', 'tokenVal']  ,MODIFIER_CALL, ZTRTokenSale.afterDeadline()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: IF 1

EXPRESSION:
amountRaised < fundingGoal

IRs:
TMP_45(bool) = amountRaised < fundingGoal
CONDITION TMP_45""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
ethVal = ethBalance[msg.sender]

IRs:
REF_17(uint256) -> ethBalance[msg.sender]
ethVal(uint256) := REF_17(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ethBalance[msg.sender] = 0

IRs:
REF_18(uint256) -> ethBalance[msg.sender]
REF_18(uint256) (->ethBalance) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(ethVal)

IRs:
Transfer dest:msg.sender value:ethVal""];
4->9;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
tokenVal = balanceOf[msg.sender]

IRs:
REF_20(uint256) -> balanceOf[msg.sender]
tokenVal(uint256) := REF_20(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
balanceOf[msg.sender] = 0

IRs:
REF_21(uint256) -> balanceOf[msg.sender]
REF_21(uint256) (->balanceOf) := 0(uint256)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
t = ZTRToken(ZTRTokenContract)

IRs:
TMP_47 = CONVERT ZTRTokenContract to ZTRToken
t(ZTRToken) := TMP_47(ZTRToken)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
t.transfer(msg.sender,tokenVal)

IRs:
HIGH_LEVEL_CALL, dest:t(ZTRToken), function:transfer, arguments:['msg.sender', 'tokenVal']  ""];
8->9;
9[label=""Node Type: END_IF 9
""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
afterDeadline()

IRs:
MODIFIER_CALL, ZTRTokenSale.afterDeadline()()""];
10->1;
}
",0,0,1,0,"afterDeadline();amountRaised < fundingGoal;ethVal = ethBalance[msg.sender];tokenVal = balanceOf[msg.sender];ethBalance[msg.sender] = 0;msg.sender.transfer(ethVal);;balanceOf[msg.sender] = 0;t = ZTRToken(ZTRTokenContract);t.transfer(msg.sender,tokenVal)"
./0x0002325fcaaac6ebf1254a626589147bde1a2394_ext.sol,HorseyPilot.withdrawCeo,1160,1177,"TMP_365(bool) = toBeDistributed > 0,CONDITION TMP_365,INTERNAL_CALL, HorseyPilot._updateDistribution()(),REF_126(uint256) -> _cBalance[msg.sender],balance(uint256) := REF_126(uint256),TMP_367(bool) = balance > 0,TMP_368 = CONVERT this to address,TMP_369(uint256) = SOLIDITY_CALL balance(address)(TMP_368),TMP_370(bool) = TMP_369 >= balance,TMP_371(bool) = TMP_367 && TMP_370,CONDITION TMP_371,Transfer dest:destination value:balance,REF_128(uint256) -> _cBalance[msg.sender],REF_128(uint256) (->_cBalance) := 0(uint256),MODIFIER_CALL, HorseyPilot.onlyCLevelAccess()(),MODIFIER_CALL, HorseyPilot.validAddress(address)(destination)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
toBeDistributed > 0

IRs:
TMP_365(bool) = toBeDistributed > 0
CONDITION TMP_365""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_updateDistribution()

IRs:
INTERNAL_CALL, HorseyPilot._updateDistribution()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
balance = _cBalance[msg.sender]

IRs:
REF_126(uint256) -> _cBalance[msg.sender]
balance(uint256) := REF_126(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
balance > 0 && (address(this).balance >= balance)

IRs:
TMP_367(bool) = balance > 0
TMP_368 = CONVERT this to address
TMP_369(uint256) = SOLIDITY_CALL balance(address)(TMP_368)
TMP_370(bool) = TMP_369 >= balance
TMP_371(bool) = TMP_367 && TMP_370
CONDITION TMP_371""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
destination.transfer(balance)

IRs:
Transfer dest:destination value:balance""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
_cBalance[msg.sender] = 0

IRs:
REF_128(uint256) -> _cBalance[msg.sender]
REF_128(uint256) (->_cBalance) := 0(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyCLevelAccess()

IRs:
MODIFIER_CALL, HorseyPilot.onlyCLevelAccess()()""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
validAddress(destination)

IRs:
MODIFIER_CALL, HorseyPilot.validAddress(address)(destination)""];
10->1;
}
",0,0,1,0,onlyCLevelAccess();toBeDistributed > 0;_updateDistribution();;balance = _cBalance[msg.sender];balance > 0 && (address(this).balance >= balance);destination.transfer(balance);;_cBalance[msg.sender] = 0;validAddress(destination)
./0x009ef15c147ff4c0eb373e1abd2f4d184e5cb916_ext.sol,CampaignContract.killContract,252,254,"TMP_97(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender),MODIFIER_CALL, CampaignContract.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(msg.sender)

IRs:
TMP_97(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, CampaignContract.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(msg.sender)
./0x0dcb6d4a156206da89177aa53c891e5a87d9da45_ext.sol,ALFA_Quiz.Stop,28,30,"REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3,MODIFIER_CALL, ALFA_Quiz.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, ALFA_Quiz.isAdmin()()""];
2->1;
}
",0,0,1,0,isAdmin();msg.sender.transfer(this.balance)
./0x35b5abaedeed12c63e04029120fa6bb084342b4d_ext.sol,BLITZ_GAME.Try,5,12,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 3000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 3000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 3000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 3000000000000000000;msg.sender.transfer(this.balance);
./0x70bf9df6967dc96156e76cc43b928a7ef02e159a_ext.sol,X_GAME.StopGame,34,40,"TMP_9(bool) = msg.sender == questionSender,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_9(bool) = msg.sender == questionSender
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0x0838524d3ba16e7f9433ab7f914847f1d38b53e8_ext.sol,RTDAirDrop.airDrop,51,54,"Transfer dest:_user value:_value,Emit AirDropCoin(_user,_value),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_user.transfer(_value)

IRs:
Transfer dest:_user value:_value""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
AirDropCoin(_user,_value)

IRs:
Emit AirDropCoin(_user,_value)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
3->1;
}
",0,0,1,0,"onlyOwner();_user.transfer(_value);AirDropCoin(_user,_value)"
./0x72f1295238a6a0d95631ad9f81b829c486861057_ext.sol,Simpl_quiz.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x9adc8a707ee86497461472c4055e039d99e70d6d_ext.sol,Iou_Token.withdraw,156,162,"REF_1(uint256) = SOLIDITY_CALL balance(address)(this),balance(uint256) := REF_1([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B886DC10>]),TMP_16(bool) = _amount > 0,CONDITION TMP_16,balance(uint256) := _amount(uint256),TMP_17 = SEND dest:owner value:balance,RETURN True,MODIFIER_CALL, Iou_Token.onlyOwner()(),RETURN result","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balance = this.balance

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
balance(uint256) := REF_1([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B886DC10>])""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_amount > 0

IRs:
TMP_16(bool) = _amount > 0
CONDITION TMP_16""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balance = _amount

IRs:
balance(uint256) := _amount(uint256)""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
owner.send(balance)

IRs:
TMP_17 = SEND dest:owner value:balance""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Iou_Token.onlyOwner()()""];
8->1;
9[label=""Node Type: RETURN 9

EXPRESSION:
result

IRs:
RETURN result""];
}
",0,0,1,0,onlyOwner();;balance = this.balance;_amount > 0;balance = _amount;;owner.send(balance);true;result
./0x01d28329619796bae733e849696f80a764422700_ext.sol,Token.fallback,379,384,"TMP_71(bool) = INTERNAL_CALL, Token.isContract(address)(controller),TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71),TMP_73 = CONVERT controller to TokenController,TMP_75(bool) = HIGH_LEVEL_CALL, dest:TMP_73(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value ,proxyPayment(bool) := TMP_75(bool),TMP_76(None) = SOLIDITY_CALL require(bool)(proxyPayment)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isContract(controller))

IRs:
TMP_71(bool) = INTERNAL_CALL, Token.isContract(address)(controller)
TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
proxyPayment = TokenController(controller).proxyPayment.value(msg.value)(msg.sender)

IRs:
TMP_73 = CONVERT controller to TokenController
TMP_75(bool) = HIGH_LEVEL_CALL, dest:TMP_73(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value 
proxyPayment(bool) := TMP_75(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(proxyPayment)

IRs:
TMP_76(None) = SOLIDITY_CALL require(bool)(proxyPayment)""];
}
",0,0,1,0,require(bool)(isContract(controller));proxyPayment = TokenController(controller).proxyPayment.value(msg.value)(msg.sender);require(bool)(proxyPayment)
./0xd871a7ce9bcf9cfbefbca3ede0ce53ba1787dfc9_ext.sol,try_to_play.Try,4,11,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 2000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 2000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 2000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 2000000000000000000;msg.sender.transfer(this.balance);
./0x6a3cfb5aeefb9138a28b28f3852a8fee81216df3_ext.sol,RxEALSaleContract.forwardFunds,448,460,"TMP_122(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['weiAmount', '4'] ,value(uint256) := TMP_122(uint256),TMP_123(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['value', '4'] ,TMP_124(bool) = TMP_123 != weiAmount,CONDITION TMP_124,Transfer dest:wallet1 value:weiAmount,Transfer dest:wallet1 value:value,Transfer dest:wallet2 value:value,Transfer dest:wallet3 value:value,Transfer dest:wallet4 value:value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
value = weiAmount.div(4)

IRs:
TMP_122(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['weiAmount', '4'] 
value(uint256) := TMP_122(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
value.mul(4) != weiAmount

IRs:
TMP_123(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['value', '4'] 
TMP_124(bool) = TMP_123 != weiAmount
CONDITION TMP_124""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
wallet1.transfer(weiAmount)

IRs:
Transfer dest:wallet1 value:weiAmount""];
3->8;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
wallet1.transfer(value)

IRs:
Transfer dest:wallet1 value:value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
wallet2.transfer(value)

IRs:
Transfer dest:wallet2 value:value""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
wallet3.transfer(value)

IRs:
Transfer dest:wallet3 value:value""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
wallet4.transfer(value)

IRs:
Transfer dest:wallet4 value:value""];
7->8;
8[label=""Node Type: END_IF 8
""];
}
",0,0,1,0,value = weiAmount.div(4);value.mul(4) != weiAmount;wallet1.transfer(weiAmount);wallet1.transfer(value);;wallet2.transfer(value);wallet3.transfer(value);wallet4.transfer(value)
./0x65171746deb1d6eee256455f77c350eceda34ae2_ext.sol,AgroNest.getTokens,182,242,"tokens(uint256) := 0(uint256),bonus(uint256) := 0(uint256),countbonus(uint256) := 0(uint256),TMP_45(uint256) = 1000000000000000000 / 10,bonusCond1(uint256) := TMP_45(uint256),bonusCond2(uint256) := 1000000000000000000(uint256),bonusCond3(uint256) := 5000000000000000000(uint256),TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_47(uint256) = TMP_46 / 1000000000000000000,tokens(uint256) := TMP_47(uint256),investor(address) := msg.sender(address),TMP_48(bool) = msg.value >= requestMinimum,TMP_49(bool) = now < deadline,TMP_50(bool) = TMP_48 && TMP_49,TMP_51(bool) = now < round1,TMP_52(bool) = TMP_50 && TMP_51,TMP_53(bool) = now < round2,TMP_54(bool) = TMP_52 && TMP_53,CONDITION TMP_54,TMP_55(bool) = msg.value >= bonusCond1,TMP_56(bool) = msg.value < bonusCond2,TMP_57(bool) = TMP_55 && TMP_56,CONDITION TMP_57,TMP_58(uint256) = tokens * 20,TMP_59(uint256) = TMP_58 / 100,countbonus(uint256) := TMP_59(uint256),TMP_60(bool) = msg.value >= bonusCond2,TMP_61(bool) = msg.value < bonusCond3,TMP_62(bool) = TMP_60 && TMP_61,CONDITION TMP_62,TMP_63(uint256) = tokens * 20,TMP_64(uint256) = TMP_63 / 100,countbonus(uint256) := TMP_64(uint256),TMP_65(bool) = msg.value >= bonusCond3,CONDITION TMP_65,TMP_66(uint256) = tokens * 20,TMP_67(uint256) = TMP_66 / 100,countbonus(uint256) := TMP_67(uint256),TMP_68(bool) = msg.value >= requestMinimum,TMP_69(bool) = now < deadline,TMP_70(bool) = TMP_68 && TMP_69,TMP_71(bool) = now > round1,TMP_72(bool) = TMP_70 && TMP_71,TMP_73(bool) = now < round2,TMP_74(bool) = TMP_72 && TMP_73,CONDITION TMP_74,TMP_75(bool) = msg.value >= bonusCond2,TMP_76(bool) = msg.value < bonusCond3,TMP_77(bool) = TMP_75 && TMP_76,CONDITION TMP_77,TMP_78(uint256) = tokens * 20,TMP_79(uint256) = TMP_78 / 100,countbonus(uint256) := TMP_79(uint256),TMP_80(bool) = msg.value >= bonusCond3,CONDITION TMP_80,TMP_81(uint256) = tokens * 20,TMP_82(uint256) = TMP_81 / 100,countbonus(uint256) := TMP_82(uint256),countbonus(uint256) := 0(uint256),TMP_83(uint256) = tokens + countbonus,bonus(uint256) := TMP_83(uint256),TMP_84(bool) = tokens == 0,CONDITION TMP_84,valdrop(uint256) := 1000000000000000000000(uint256),REF_12(bool) -> Claimed[investor],TMP_85(bool) = REF_12 == False,TMP_86(bool) = progress0drop <= target0drop,TMP_87(bool) = TMP_85 && TMP_86,CONDITION TMP_87,TMP_88(bool) = INTERNAL_CALL, AgroNest.distr(address,uint256)(investor,valdrop),REF_13(bool) -> Claimed[investor],REF_13(bool) (->Claimed) := True(bool),TMP_89(uint256) := progress0drop(uint256),progress0drop(uint256) = progress0drop + 1,TMP_90(bool) = msg.value >= requestMinimum,TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),TMP_92(bool) = tokens > 0,TMP_93(bool) = msg.value >= requestMinimum,TMP_94(bool) = TMP_92 && TMP_93,CONDITION TMP_94,TMP_95(bool) = now >= deadline,TMP_96(bool) = now >= round1,TMP_97(bool) = TMP_95 && TMP_96,TMP_98(bool) = now < round2,TMP_99(bool) = TMP_97 && TMP_98,CONDITION TMP_99,TMP_100(bool) = INTERNAL_CALL, AgroNest.distr(address,uint256)(investor,tokens),TMP_101(bool) = msg.value >= bonusCond1,CONDITION TMP_101,TMP_102(bool) = INTERNAL_CALL, AgroNest.distr(address,uint256)(investor,bonus),TMP_103(bool) = INTERNAL_CALL, AgroNest.distr(address,uint256)(investor,tokens),TMP_104(bool) = msg.value >= requestMinimum,TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104),TMP_106(bool) = totalDistributed >= totalSupply,CONDITION TMP_106,distributionFinished(bool) := True(bool),Transfer dest:multisig value:msg.value,MODIFIER_CALL, AgroNest.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->53;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bonusCond1 = 1000000000000000000 / 10

IRs:
TMP_45(uint256) = 1000000000000000000 / 10
bonusCond1(uint256) := TMP_45(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bonusCond2 = 1000000000000000000

IRs:
bonusCond2(uint256) := 1000000000000000000(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
bonusCond3 = 5000000000000000000

IRs:
bonusCond3(uint256) := 5000000000000000000(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_47(uint256) = TMP_46 / 1000000000000000000
tokens(uint256) := TMP_47(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now < round1 && now < round2

IRs:
TMP_48(bool) = msg.value >= requestMinimum
TMP_49(bool) = now < deadline
TMP_50(bool) = TMP_48 && TMP_49
TMP_51(bool) = now < round1
TMP_52(bool) = TMP_50 && TMP_51
TMP_53(bool) = now < round2
TMP_54(bool) = TMP_52 && TMP_53
CONDITION TMP_54""];
9->10[label=""True""];
9->19[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
msg.value >= bonusCond1 && msg.value < bonusCond2

IRs:
TMP_55(bool) = msg.value >= bonusCond1
TMP_56(bool) = msg.value < bonusCond2
TMP_57(bool) = TMP_55 && TMP_56
CONDITION TMP_57""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
countbonus = tokens * 20 / 100

IRs:
TMP_58(uint256) = tokens * 20
TMP_59(uint256) = TMP_58 / 100
countbonus(uint256) := TMP_59(uint256)""];
11->18;
12[label=""Node Type: IF 12

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_60(bool) = msg.value >= bonusCond2
TMP_61(bool) = msg.value < bonusCond3
TMP_62(bool) = TMP_60 && TMP_61
CONDITION TMP_62""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
countbonus = tokens * 20 / 100

IRs:
TMP_63(uint256) = tokens * 20
TMP_64(uint256) = TMP_63 / 100
countbonus(uint256) := TMP_64(uint256)""];
13->17;
14[label=""Node Type: IF 14

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_65(bool) = msg.value >= bonusCond3
CONDITION TMP_65""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
countbonus = tokens * 20 / 100

IRs:
TMP_66(uint256) = tokens * 20
TMP_67(uint256) = TMP_66 / 100
countbonus(uint256) := TMP_67(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->28;
19[label=""Node Type: IF 19

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now > round1 && now < round2

IRs:
TMP_68(bool) = msg.value >= requestMinimum
TMP_69(bool) = now < deadline
TMP_70(bool) = TMP_68 && TMP_69
TMP_71(bool) = now > round1
TMP_72(bool) = TMP_70 && TMP_71
TMP_73(bool) = now < round2
TMP_74(bool) = TMP_72 && TMP_73
CONDITION TMP_74""];
19->20[label=""True""];
19->26[label=""False""];
20[label=""Node Type: IF 20

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_75(bool) = msg.value >= bonusCond2
TMP_76(bool) = msg.value < bonusCond3
TMP_77(bool) = TMP_75 && TMP_76
CONDITION TMP_77""];
20->21[label=""True""];
20->22[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
countbonus = tokens * 20 / 100

IRs:
TMP_78(uint256) = tokens * 20
TMP_79(uint256) = TMP_78 / 100
countbonus(uint256) := TMP_79(uint256)""];
21->25;
22[label=""Node Type: IF 22

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_80(bool) = msg.value >= bonusCond3
CONDITION TMP_80""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
countbonus = tokens * 20 / 100

IRs:
TMP_81(uint256) = tokens * 20
TMP_82(uint256) = TMP_81 / 100
countbonus(uint256) := TMP_82(uint256)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->27;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
bonus = tokens + countbonus

IRs:
TMP_83(uint256) = tokens + countbonus
bonus(uint256) := TMP_83(uint256)""];
29->30;
30[label=""Node Type: IF 30

EXPRESSION:
tokens == 0

IRs:
TMP_84(bool) = tokens == 0
CONDITION TMP_84""];
30->31[label=""True""];
30->38[label=""False""];
31[label=""Node Type: NEW VARIABLE 31

EXPRESSION:
valdrop = 1000e18

IRs:
valdrop(uint256) := 1000000000000000000000(uint256)""];
31->32;
32[label=""Node Type: IF 32

EXPRESSION:
Claimed[investor] == false && progress0drop <= target0drop

IRs:
REF_12(bool) -> Claimed[investor]
TMP_85(bool) = REF_12 == False
TMP_86(bool) = progress0drop <= target0drop
TMP_87(bool) = TMP_85 && TMP_86
CONDITION TMP_87""];
32->33[label=""True""];
32->36[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
distr(investor,valdrop)

IRs:
TMP_88(bool) = INTERNAL_CALL, AgroNest.distr(address,uint256)(investor,valdrop)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
Claimed[investor] = true

IRs:
REF_13(bool) -> Claimed[investor]
REF_13(bool) (->Claimed) := True(bool)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
progress0drop ++

IRs:
TMP_89(uint256) := progress0drop(uint256)
progress0drop(uint256) = progress0drop + 1""];
35->37;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_90(bool) = msg.value >= requestMinimum
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
36->37;
37[label=""Node Type: END_IF 37
""];
37->48;
38[label=""Node Type: IF 38

EXPRESSION:
tokens > 0 && msg.value >= requestMinimum

IRs:
TMP_92(bool) = tokens > 0
TMP_93(bool) = msg.value >= requestMinimum
TMP_94(bool) = TMP_92 && TMP_93
CONDITION TMP_94""];
38->39[label=""True""];
38->46[label=""False""];
39[label=""Node Type: IF 39

EXPRESSION:
now >= deadline && now >= round1 && now < round2

IRs:
TMP_95(bool) = now >= deadline
TMP_96(bool) = now >= round1
TMP_97(bool) = TMP_95 && TMP_96
TMP_98(bool) = now < round2
TMP_99(bool) = TMP_97 && TMP_98
CONDITION TMP_99""];
39->40[label=""True""];
39->41[label=""False""];
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_100(bool) = INTERNAL_CALL, AgroNest.distr(address,uint256)(investor,tokens)""];
40->45;
41[label=""Node Type: IF 41

EXPRESSION:
msg.value >= bonusCond1

IRs:
TMP_101(bool) = msg.value >= bonusCond1
CONDITION TMP_101""];
41->42[label=""True""];
41->43[label=""False""];
42[label=""Node Type: EXPRESSION 42

EXPRESSION:
distr(investor,bonus)

IRs:
TMP_102(bool) = INTERNAL_CALL, AgroNest.distr(address,uint256)(investor,bonus)""];
42->44;
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_103(bool) = INTERNAL_CALL, AgroNest.distr(address,uint256)(investor,tokens)""];
43->44;
44[label=""Node Type: END_IF 44
""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->47;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_104(bool) = msg.value >= requestMinimum
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: IF 49

EXPRESSION:
totalDistributed >= totalSupply

IRs:
TMP_106(bool) = totalDistributed >= totalSupply
CONDITION TMP_106""];
49->50[label=""True""];
49->51[label=""False""];
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
multisig.transfer(msg.value)

IRs:
Transfer dest:multisig value:msg.value""];
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, AgroNest.canDistr()()""];
53->1;
}
",0,0,1,0,"canDistr();tokens = 0;bonus = 0;countbonus = 0;bonusCond1 = 1000000000000000000 / 10;bonusCond2 = 1000000000000000000;bonusCond3 = 5000000000000000000;tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;investor = msg.sender;msg.value >= requestMinimum && now < deadline && now < round1 && now < round2;msg.value >= bonusCond1 && msg.value < bonusCond2;msg.value >= requestMinimum && now < deadline && now > round1 && now < round2;countbonus = tokens * 20 / 100;msg.value >= bonusCond2 && msg.value < bonusCond3;;countbonus = tokens * 20 / 100;msg.value >= bonusCond3;;countbonus = tokens * 20 / 100;;;msg.value >= bonusCond2 && msg.value < bonusCond3;countbonus = 0;countbonus = tokens * 20 / 100;msg.value >= bonusCond3;;countbonus = tokens * 20 / 100;;;bonus = tokens + countbonus;tokens == 0;valdrop = 1000e18;tokens > 0 && msg.value >= requestMinimum;Claimed[investor] == false && progress0drop <= target0drop;distr(investor,valdrop);require(bool)(msg.value >= requestMinimum);Claimed[investor] = true;progress0drop ++;;;now >= deadline && now >= round1 && now < round2;require(bool)(msg.value >= requestMinimum);distr(investor,tokens);msg.value >= bonusCond1;;distr(investor,bonus);distr(investor,tokens);;;totalDistributed >= totalSupply;distributionFinished = true;;multisig.transfer(msg.value)"
./0x87cdabc87128476d84462eb9c5a67a7acfa7889e_ext.sol,RefundEscrow.beneficiaryWithdraw,280,283,"REF_27(RefundEscrow.State) -> State.Closed,TMP_104(bool) = state == REF_27,TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104),TMP_106 = CONVERT this to address,TMP_107(uint256) = SOLIDITY_CALL balance(address)(TMP_106),Transfer dest:beneficiary value:TMP_107","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Closed)

IRs:
REF_27(RefundEscrow.State) -> State.Closed
TMP_104(bool) = state == REF_27
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
beneficiary.transfer(address(this).balance)

IRs:
TMP_106 = CONVERT this to address
TMP_107(uint256) = SOLIDITY_CALL balance(address)(TMP_106)
Transfer dest:beneficiary value:TMP_107""];
}
",0,0,1,0,require(bool)(state == State.Closed);beneficiary.transfer(address(this).balance)
./0x35d76c3db8e826907d2a977500b54b3914ecc020_ext.sol,RefundVault.close,212,217,"REF_22(RefundVault.State) -> State.Active,TMP_178(bool) = state == REF_22,TMP_179(None) = SOLIDITY_CALL require(bool)(TMP_178),REF_23(RefundVault.State) -> State.Closed,state(RefundVault.State) := REF_23(RefundVault.State),Emit Closed(),REF_25(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:wallet value:REF_25,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_22(RefundVault.State) -> State.Active
TMP_178(bool) = state == REF_22
TMP_179(None) = SOLIDITY_CALL require(bool)(TMP_178)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
state = State.Closed

IRs:
REF_23(RefundVault.State) -> State.Closed
state(RefundVault.State) := REF_23(RefundVault.State)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Closed()

IRs:
Emit Closed()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
wallet.transfer(this.balance)

IRs:
REF_25(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:wallet value:REF_25""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();require(bool)(state == State.Active);state = State.Closed;Closed();wallet.transfer(this.balance)
./0x7275f61c3abfba3596ae71f7128bdc3b0fc01fa9_ext.sol,Ownable.kill,39,42,"REF_0(uint256) = SOLIDITY_CALL balance(address)(this),TMP_2(bool) = REF_0 == 0,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),TMP_4(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(this.balance == 0)

IRs:
REF_0(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_2(bool) = REF_0 == 0
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_4(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();require(bool)(this.balance == 0);selfdestruct(address)(owner)
./0xece0429a5130ebe0616363939067eefca4fbaceb_ext.sol,MiniMeToken.fallback,529,532,"TMP_126(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller),TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126),TMP_128 = CONVERT controller to TokenController,TMP_130(bool) = HIGH_LEVEL_CALL, dest:TMP_128(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value ,TMP_131(None) = SOLIDITY_CALL require(bool)(TMP_130)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isContract(controller))

IRs:
TMP_126(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)
TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))

IRs:
TMP_128 = CONVERT controller to TokenController
TMP_130(bool) = HIGH_LEVEL_CALL, dest:TMP_128(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value 
TMP_131(None) = SOLIDITY_CALL require(bool)(TMP_130)""];
}
",0,0,1,0,require(bool)(isContract(controller));require(bool)(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))
./0x347925b22d0217a4797f470faa2afebbdb150b7a_ext.sol,Nanotechnology.withdraw,300,303,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, Nanotechnology.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Nanotechnology.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0xf0a0116885943f5466cb50ed8cf50b15b3d45801_ext.sol,EthercraftFarm.reap,242,257,"TMP_109 = CONVERT 0 to address,TMP_110(bool) = _object != TMP_109,TMP_111(None) = SOLIDITY_CALL require(bool)(TMP_110),REF_27(mapping(address => uint256)) -> balanceOfToken[msg.sender],REF_28(uint256) -> REF_27[_object],TMP_112(bool) = REF_28 > 0,TMP_113(None) = SOLIDITY_CALL require(bool)(TMP_112),TMP_114(bool) = msg.sender == owner,CONDITION TMP_114,REF_30(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:owner value:REF_30,REF_31(mapping(address => uint256)) -> balanceOfToken[msg.sender],REF_32(uint256) -> REF_31[_object],balance(uint256) := REF_32(uint256),TMP_116(uint256) = balance % 1000000000000000000,TMP_117(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['balance', 'TMP_116'] ,balance(uint256) := TMP_117(uint256),TMP_118 = CONVERT _object to ERC20Basic,TMP_119(bool) = HIGH_LEVEL_CALL, dest:TMP_118(ERC20Basic), function:transfer, arguments:['msg.sender', 'balance']  ,REF_35(mapping(address => uint256)) -> balanceOfToken[msg.sender],REF_36(uint256) -> REF_35[_object],REF_36(uint256) (->balanceOfToken) := 0(uint256),REF_37(uint256) -> totalOfToken[_object],REF_38(uint256) -> totalOfToken[_object],TMP_120(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_38', 'balance'] ,REF_37(uint256) (->totalOfToken) := TMP_120(uint256),Emit Reapped(_object,balance),MODIFIER_CALL, ReentrancyGuard.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_object != address(0))

IRs:
TMP_109 = CONVERT 0 to address
TMP_110(bool) = _object != TMP_109
TMP_111(None) = SOLIDITY_CALL require(bool)(TMP_110)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balanceOfToken[msg.sender][_object] > 0)

IRs:
REF_27(mapping(address => uint256)) -> balanceOfToken[msg.sender]
REF_28(uint256) -> REF_27[_object]
TMP_112(bool) = REF_28 > 0
TMP_113(None) = SOLIDITY_CALL require(bool)(TMP_112)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
msg.sender == owner

IRs:
TMP_114(bool) = msg.sender == owner
CONDITION TMP_114""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
owner.transfer(this.balance)

IRs:
REF_30(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:owner value:REF_30""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = balanceOfToken[msg.sender][_object]

IRs:
REF_31(mapping(address => uint256)) -> balanceOfToken[msg.sender]
REF_32(uint256) -> REF_31[_object]
balance(uint256) := REF_32(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balance = balance.sub(balance % (1000000000000000000))

IRs:
TMP_116(uint256) = balance % 1000000000000000000
TMP_117(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['balance', 'TMP_116'] 
balance(uint256) := TMP_117(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ERC20Basic(_object).transfer(msg.sender,balance)

IRs:
TMP_118 = CONVERT _object to ERC20Basic
TMP_119(bool) = HIGH_LEVEL_CALL, dest:TMP_118(ERC20Basic), function:transfer, arguments:['msg.sender', 'balance']  ""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
balanceOfToken[msg.sender][_object] = 0

IRs:
REF_35(mapping(address => uint256)) -> balanceOfToken[msg.sender]
REF_36(uint256) -> REF_35[_object]
REF_36(uint256) (->balanceOfToken) := 0(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
totalOfToken[_object] = totalOfToken[_object].sub(balance)

IRs:
REF_37(uint256) -> totalOfToken[_object]
REF_38(uint256) -> totalOfToken[_object]
TMP_120(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_38', 'balance'] 
REF_37(uint256) (->totalOfToken) := TMP_120(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
Reapped(_object,balance)

IRs:
Emit Reapped(_object,balance)""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, ReentrancyGuard.nonReentrant()()""];
12->1;
}
",0,0,1,0,"nonReentrant();require(bool)(_object != address(0));require(bool)(balanceOfToken[msg.sender][_object] > 0);msg.sender == owner;owner.transfer(this.balance);;balance = balanceOfToken[msg.sender][_object];balance = balance.sub(balance % (1000000000000000000));ERC20Basic(_object).transfer(msg.sender,balance);balanceOfToken[msg.sender][_object] = 0;totalOfToken[_object] = totalOfToken[_object].sub(balance);Reapped(_object,balance)"
./0xf17a9ad24372faaa27f0bb684e13413a3de84c4b_ext.sol,SmokeCoinV_2.withdraw,307,310,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, SmokeCoinV_2.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, SmokeCoinV_2.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x1c3bed5bd4b0e6a8389efd0d2876f948a907ab5b_ext.sol,MiniMeToken.claimTokens,505,515,"TMP_130(bool) = _token == 0,CONDITION TMP_130,REF_58(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:controller value:REF_58,TMP_132 = CONVERT _token to MiniMeToken,token(MiniMeToken) := TMP_132(MiniMeToken),TMP_133(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_133(uint256),TMP_134(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  ,Emit ClaimedTokens(_token,controller,balance),MODIFIER_CALL, Controlled.onlyController()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_130(bool) = _token == 0
CONDITION TMP_130""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_58(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_58""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
token = MiniMeToken(_token)

IRs:
TMP_132 = CONVERT _token to MiniMeToken
token(MiniMeToken) := TMP_132(MiniMeToken)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_133(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_133(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_134(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()""];
9->1;
}
",0,0,1,0,"onlyController();_token == 0x0;controller.transfer(this.balance);;;token = MiniMeToken(_token);balance = token.balanceOf(this);token.transfer(controller,balance);ClaimedTokens(_token,controller,balance)"
./0x01d28329619796bae733e849696f80a764422700_ext.sol,Token.fallback,379,384,"TMP_71(bool) = INTERNAL_CALL, Token.isContract(address)(controller),TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71),TMP_73 = CONVERT controller to TokenController,TMP_75(bool) = HIGH_LEVEL_CALL, dest:TMP_73(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value ,proxyPayment(bool) := TMP_75(bool),TMP_76(None) = SOLIDITY_CALL require(bool)(proxyPayment)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isContract(controller))

IRs:
TMP_71(bool) = INTERNAL_CALL, Token.isContract(address)(controller)
TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
proxyPayment = TokenController(controller).proxyPayment.value(msg.value)(msg.sender)

IRs:
TMP_73 = CONVERT controller to TokenController
TMP_75(bool) = HIGH_LEVEL_CALL, dest:TMP_73(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value 
proxyPayment(bool) := TMP_75(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(proxyPayment)

IRs:
TMP_76(None) = SOLIDITY_CALL require(bool)(proxyPayment)""];
}
",0,0,1,0,require(bool)(isContract(controller));proxyPayment = TokenController(controller).proxyPayment.value(msg.value)(msg.sender);require(bool)(proxyPayment)
./0x0dd88f1d1cbc9bcdda5ddd9e9fc86e8183f8f3b9_ext.sol,XenoxCoin.withdrawAll,296,300,"myAddress(address) := this(address),TMP_141(uint256) = SOLIDITY_CALL balance(address)(myAddress),etherBalance(uint256) := TMP_141(uint256),Transfer dest:owner value:etherBalance,MODIFIER_CALL, XenoxCoin.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
myAddress = this

IRs:
myAddress(address) := this(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
etherBalance = myAddress.balance

IRs:
TMP_141(uint256) = SOLIDITY_CALL balance(address)(myAddress)
etherBalance(uint256) := TMP_141(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(etherBalance)

IRs:
Transfer dest:owner value:etherBalance""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, XenoxCoin.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();myAddress = this;etherBalance = myAddress.balance;owner.transfer(etherBalance)
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.addAdminWhitelist,2,2,"REF_5 -> LENGTH _userlist,TMP_25(bool) = REF_5 > 0,TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25),i(uint256) := 0(uint256),REF_6 -> LENGTH _userlist,TMP_27(bool) = i < REF_6,CONDITION TMP_27,REF_7(address) -> _userlist[i],baddr(address) := REF_7(address),TMP_28 = CONVERT 0 to address,TMP_29(bool) = baddr != TMP_28,CONDITION TMP_29,REF_8(bool) -> admins[baddr],TMP_30 = UnaryType.BANG REF_8 ,CONDITION TMP_30,REF_9(bool) -> admins[baddr],REF_9(bool) (->admins) := True(bool),REF_11 -> LENGTH adminaddress,TMP_33(uint256) := REF_11(uint256),TMP_34(uint256) = TMP_33 + 1,REF_11(uint256) (->adminaddress) := TMP_34(uint256),REF_12(address) -> adminaddress[TMP_33],REF_12(address) (->adminaddress) := baddr(address),TMP_32(None) = TMP_31 - 1,TMP_35(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, KahnDistributionCentre.onlyOwner()(),MODIFIER_CALL, KahnDistributionCentre.onlyAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_userlist.length > 0)

IRs:
REF_5 -> LENGTH _userlist
TMP_25(bool) = REF_5 > 0
TMP_26(None) = SOLIDITY_CALL require(bool)(TMP_25)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < _userlist.length

IRs:
REF_6 -> LENGTH _userlist
TMP_27(bool) = i < REF_6
CONDITION TMP_27""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
baddr = _userlist[i]

IRs:
REF_7(address) -> _userlist[i]
baddr(address) := REF_7(address)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
baddr != address(0)

IRs:
TMP_28 = CONVERT 0 to address
TMP_29(bool) = baddr != TMP_28
CONDITION TMP_29""];
7->8[label=""True""];
7->12[label=""False""];
8[label=""Node Type: IF 8

EXPRESSION:
! admins[baddr]

IRs:
REF_8(bool) -> admins[baddr]
TMP_30 = UnaryType.BANG REF_8 
CONDITION TMP_30""];
8->9[label=""True""];
8->11[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
admins[baddr] = true

IRs:
REF_9(bool) -> admins[baddr]
REF_9(bool) (->admins) := True(bool)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
adminaddress.push(baddr) - 1

IRs:
REF_11 -> LENGTH adminaddress
TMP_33(uint256) := REF_11(uint256)
TMP_34(uint256) = TMP_33 + 1
REF_11(uint256) (->adminaddress) := TMP_34(uint256)
REF_12(address) -> adminaddress[TMP_33]
REF_12(address) (->adminaddress) := baddr(address)
TMP_32(None) = TMP_31 - 1""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
i ++

IRs:
TMP_35(uint256) := i(uint256)
i(uint256) = i + 1""];
13->5;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyOwner()()""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyAdmin()()""];
15->1;
}
",0,1,1,0,onlyOwner();require(bool)(_userlist.length > 0);i = 0;;i < _userlist.length;;baddr = _userlist[i];baddr != address(0);! admins[baddr];;admins[baddr] = true;;adminaddress.push(baddr) - 1;i ++;onlyAdmin()
./0xd3a97d46fd0c28a5a035a4e0813afe7c2c1376bd_ext.sol,InterCrypto.kill,169,171,"TMP_140(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_140(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0xee58ee0b1519bb47801812a3a9c83ab600c63d81_ext.sol,MerchantWallet.doWithdrawal,506,509,"TMP_172(bool) = beneficiary != 0,TMP_173(None) = SOLIDITY_CALL require(bool)(TMP_172),Transfer dest:beneficiary value:amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(beneficiary != 0x0)

IRs:
TMP_172(bool) = beneficiary != 0
TMP_173(None) = SOLIDITY_CALL require(bool)(TMP_172)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
beneficiary.transfer(amount)

IRs:
Transfer dest:beneficiary value:amount""];
}
",0,0,1,0,require(bool)(beneficiary != 0x0);beneficiary.transfer(amount)
./0x0232ba609782cea145ec3663f52cf7aeb4ac773c_ext.sol,Withdrawable.withdrawEther,252,255,"Transfer dest:sendTo value:amount,Emit EtherWithdraw(amount,sendTo),MODIFIER_CALL, PermissionGroups.onlyAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
sendTo.transfer(amount)

IRs:
Transfer dest:sendTo value:amount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
EtherWithdraw(amount,sendTo)

IRs:
Emit EtherWithdraw(amount,sendTo)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, PermissionGroups.onlyAdmin()()""];
3->1;
}
",0,0,1,0,"onlyAdmin();sendTo.transfer(amount);EtherWithdraw(amount,sendTo)"
./0x5085c5356129ee11bffb523e3166d7153ac13c75_ext.sol,Casino.refundBet,320,336,"REF_29(Casino.Bet) -> bets[_commit],bet(Casino.Bet) := REF_29(Casino.Bet),REF_30(uint256) -> bet.amount,amount(uint256) := REF_30(uint256),REF_31(uint256) -> bet.placeBlockNumber,placeBlockNumber(uint256) := REF_31(uint256),REF_32(address) -> bet.player,player(address) := REF_32(address),REF_33(bool) -> bet.isActive,TMP_140(None) = SOLIDITY_CALL require(bool,string)(REF_33,this bet is not active),TMP_141(uint256) = placeBlockNumber + BET_EXPIRATION_BLOCKS,TMP_142(bool) = block.number > TMP_141,TMP_143(None) = SOLIDITY_CALL require(bool,string)(TMP_142,this bet has not expired),Transfer dest:player value:amount,REF_36(uint256) -> bet.winAmount,TMP_145(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['bankFund', 'REF_36'] ,bankFund(uint256) := TMP_145(uint256),REF_37(bool) -> bet.isActive,REF_37(bool) (->bet) := False(bool),Emit LogRefund(player,amount),MODIFIER_CALL, HouseAdmin.onlyCroupier()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
bet = bets[_commit]

IRs:
REF_29(Casino.Bet) -> bets[_commit]
bet(Casino.Bet) := REF_29(Casino.Bet)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = bet.amount

IRs:
REF_30(uint256) -> bet.amount
amount(uint256) := REF_30(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
placeBlockNumber = bet.placeBlockNumber

IRs:
REF_31(uint256) -> bet.placeBlockNumber
placeBlockNumber(uint256) := REF_31(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
player = bet.player

IRs:
REF_32(address) -> bet.player
player(address) := REF_32(address)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool,string)(bet.isActive,this bet is not active)

IRs:
REF_33(bool) -> bet.isActive
TMP_140(None) = SOLIDITY_CALL require(bool,string)(REF_33,this bet is not active)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool,string)(block.number > placeBlockNumber + BET_EXPIRATION_BLOCKS,this bet has not expired)

IRs:
TMP_141(uint256) = placeBlockNumber + BET_EXPIRATION_BLOCKS
TMP_142(bool) = block.number > TMP_141
TMP_143(None) = SOLIDITY_CALL require(bool,string)(TMP_142,this bet has not expired)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
player.transfer(amount)

IRs:
Transfer dest:player value:amount""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
bankFund = bankFund.sub(bet.winAmount)

IRs:
REF_36(uint256) -> bet.winAmount
TMP_145(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['bankFund', 'REF_36'] 
bankFund(uint256) := TMP_145(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
bet.isActive = false

IRs:
REF_37(bool) -> bet.isActive
REF_37(bool) (->bet) := False(bool)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
LogRefund(player,amount)

IRs:
Emit LogRefund(player,amount)""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
onlyCroupier()

IRs:
MODIFIER_CALL, HouseAdmin.onlyCroupier()()""];
11->1;
}
",0,0,1,0,"onlyCroupier();bet = bets[_commit];amount = bet.amount;placeBlockNumber = bet.placeBlockNumber;player = bet.player;require(bool,string)(bet.isActive,this bet is not active);require(bool,string)(block.number > placeBlockNumber + BET_EXPIRATION_BLOCKS,this bet has not expired);player.transfer(amount);bankFund = bankFund.sub(bet.winAmount);bet.isActive = false;LogRefund(player,amount)"
./0x70d0907b064ab5c86849d391124f62ce9bcbf597_ext.sol,Fastbitcoin.getTokens,181,241,"tokens(uint256) := 0(uint256),bonus(uint256) := 0(uint256),countbonus(uint256) := 0(uint256),TMP_45(uint256) = 1000000000000000000 / 10,bonusCond1(uint256) := TMP_45(uint256),bonusCond2(uint256) := 1000000000000000000(uint256),bonusCond3(uint256) := 5000000000000000000(uint256),TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_47(uint256) = TMP_46 / 1000000000000000000,tokens(uint256) := TMP_47(uint256),investor(address) := msg.sender(address),TMP_48(bool) = msg.value >= requestMinimum,TMP_49(bool) = now < deadline,TMP_50(bool) = TMP_48 && TMP_49,TMP_51(bool) = now < round1,TMP_52(bool) = TMP_50 && TMP_51,TMP_53(bool) = now < round2,TMP_54(bool) = TMP_52 && TMP_53,CONDITION TMP_54,TMP_55(bool) = msg.value >= bonusCond1,TMP_56(bool) = msg.value < bonusCond2,TMP_57(bool) = TMP_55 && TMP_56,CONDITION TMP_57,TMP_58(uint256) = tokens * 5,TMP_59(uint256) = TMP_58 / 100,countbonus(uint256) := TMP_59(uint256),TMP_60(bool) = msg.value >= bonusCond2,TMP_61(bool) = msg.value < bonusCond3,TMP_62(bool) = TMP_60 && TMP_61,CONDITION TMP_62,TMP_63(uint256) = tokens * 10,TMP_64(uint256) = TMP_63 / 100,countbonus(uint256) := TMP_64(uint256),TMP_65(bool) = msg.value >= bonusCond3,CONDITION TMP_65,TMP_66(uint256) = tokens * 15,TMP_67(uint256) = TMP_66 / 100,countbonus(uint256) := TMP_67(uint256),TMP_68(bool) = msg.value >= requestMinimum,TMP_69(bool) = now < deadline,TMP_70(bool) = TMP_68 && TMP_69,TMP_71(bool) = now > round1,TMP_72(bool) = TMP_70 && TMP_71,TMP_73(bool) = now < round2,TMP_74(bool) = TMP_72 && TMP_73,CONDITION TMP_74,TMP_75(bool) = msg.value >= bonusCond2,TMP_76(bool) = msg.value < bonusCond3,TMP_77(bool) = TMP_75 && TMP_76,CONDITION TMP_77,TMP_78(uint256) = tokens * 5,TMP_79(uint256) = TMP_78 / 100,countbonus(uint256) := TMP_79(uint256),TMP_80(bool) = msg.value >= bonusCond3,CONDITION TMP_80,TMP_81(uint256) = tokens * 10,TMP_82(uint256) = TMP_81 / 100,countbonus(uint256) := TMP_82(uint256),countbonus(uint256) := 0(uint256),TMP_83(uint256) = tokens + countbonus,bonus(uint256) := TMP_83(uint256),TMP_84(bool) = tokens == 0,CONDITION TMP_84,valdrop(uint256) := 500000000000(uint256),REF_12(bool) -> Claimed[investor],TMP_85(bool) = REF_12 == False,TMP_86(bool) = progress0drop <= target0drop,TMP_87(bool) = TMP_85 && TMP_86,CONDITION TMP_87,TMP_88(bool) = INTERNAL_CALL, Fastbitcoin.distr(address,uint256)(investor,valdrop),REF_13(bool) -> Claimed[investor],REF_13(bool) (->Claimed) := True(bool),TMP_89(uint256) := progress0drop(uint256),progress0drop(uint256) = progress0drop + 1,TMP_90(bool) = msg.value >= requestMinimum,TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),TMP_92(bool) = tokens > 0,TMP_93(bool) = msg.value >= requestMinimum,TMP_94(bool) = TMP_92 && TMP_93,CONDITION TMP_94,TMP_95(bool) = now >= deadline,TMP_96(bool) = now >= round1,TMP_97(bool) = TMP_95 && TMP_96,TMP_98(bool) = now < round2,TMP_99(bool) = TMP_97 && TMP_98,CONDITION TMP_99,TMP_100(bool) = INTERNAL_CALL, Fastbitcoin.distr(address,uint256)(investor,tokens),TMP_101(bool) = msg.value >= bonusCond1,CONDITION TMP_101,TMP_102(bool) = INTERNAL_CALL, Fastbitcoin.distr(address,uint256)(investor,bonus),TMP_103(bool) = INTERNAL_CALL, Fastbitcoin.distr(address,uint256)(investor,tokens),TMP_104(bool) = msg.value >= requestMinimum,TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104),TMP_106(bool) = totalDistributed >= totalSupply,CONDITION TMP_106,distributionFinished(bool) := True(bool),Transfer dest:multisig value:msg.value,MODIFIER_CALL, Fastbitcoin.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->53;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bonusCond1 = 1000000000000000000 / 10

IRs:
TMP_45(uint256) = 1000000000000000000 / 10
bonusCond1(uint256) := TMP_45(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bonusCond2 = 1000000000000000000

IRs:
bonusCond2(uint256) := 1000000000000000000(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
bonusCond3 = 5000000000000000000

IRs:
bonusCond3(uint256) := 5000000000000000000(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_47(uint256) = TMP_46 / 1000000000000000000
tokens(uint256) := TMP_47(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now < round1 && now < round2

IRs:
TMP_48(bool) = msg.value >= requestMinimum
TMP_49(bool) = now < deadline
TMP_50(bool) = TMP_48 && TMP_49
TMP_51(bool) = now < round1
TMP_52(bool) = TMP_50 && TMP_51
TMP_53(bool) = now < round2
TMP_54(bool) = TMP_52 && TMP_53
CONDITION TMP_54""];
9->10[label=""True""];
9->19[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
msg.value >= bonusCond1 && msg.value < bonusCond2

IRs:
TMP_55(bool) = msg.value >= bonusCond1
TMP_56(bool) = msg.value < bonusCond2
TMP_57(bool) = TMP_55 && TMP_56
CONDITION TMP_57""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
countbonus = tokens * 5 / 100

IRs:
TMP_58(uint256) = tokens * 5
TMP_59(uint256) = TMP_58 / 100
countbonus(uint256) := TMP_59(uint256)""];
11->18;
12[label=""Node Type: IF 12

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_60(bool) = msg.value >= bonusCond2
TMP_61(bool) = msg.value < bonusCond3
TMP_62(bool) = TMP_60 && TMP_61
CONDITION TMP_62""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
countbonus = tokens * 10 / 100

IRs:
TMP_63(uint256) = tokens * 10
TMP_64(uint256) = TMP_63 / 100
countbonus(uint256) := TMP_64(uint256)""];
13->17;
14[label=""Node Type: IF 14

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_65(bool) = msg.value >= bonusCond3
CONDITION TMP_65""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
countbonus = tokens * 15 / 100

IRs:
TMP_66(uint256) = tokens * 15
TMP_67(uint256) = TMP_66 / 100
countbonus(uint256) := TMP_67(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->28;
19[label=""Node Type: IF 19

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now > round1 && now < round2

IRs:
TMP_68(bool) = msg.value >= requestMinimum
TMP_69(bool) = now < deadline
TMP_70(bool) = TMP_68 && TMP_69
TMP_71(bool) = now > round1
TMP_72(bool) = TMP_70 && TMP_71
TMP_73(bool) = now < round2
TMP_74(bool) = TMP_72 && TMP_73
CONDITION TMP_74""];
19->20[label=""True""];
19->26[label=""False""];
20[label=""Node Type: IF 20

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_75(bool) = msg.value >= bonusCond2
TMP_76(bool) = msg.value < bonusCond3
TMP_77(bool) = TMP_75 && TMP_76
CONDITION TMP_77""];
20->21[label=""True""];
20->22[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
countbonus = tokens * 5 / 100

IRs:
TMP_78(uint256) = tokens * 5
TMP_79(uint256) = TMP_78 / 100
countbonus(uint256) := TMP_79(uint256)""];
21->25;
22[label=""Node Type: IF 22

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_80(bool) = msg.value >= bonusCond3
CONDITION TMP_80""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
countbonus = tokens * 10 / 100

IRs:
TMP_81(uint256) = tokens * 10
TMP_82(uint256) = TMP_81 / 100
countbonus(uint256) := TMP_82(uint256)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->27;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
bonus = tokens + countbonus

IRs:
TMP_83(uint256) = tokens + countbonus
bonus(uint256) := TMP_83(uint256)""];
29->30;
30[label=""Node Type: IF 30

EXPRESSION:
tokens == 0

IRs:
TMP_84(bool) = tokens == 0
CONDITION TMP_84""];
30->31[label=""True""];
30->38[label=""False""];
31[label=""Node Type: NEW VARIABLE 31

EXPRESSION:
valdrop = 5000e8

IRs:
valdrop(uint256) := 500000000000(uint256)""];
31->32;
32[label=""Node Type: IF 32

EXPRESSION:
Claimed[investor] == false && progress0drop <= target0drop

IRs:
REF_12(bool) -> Claimed[investor]
TMP_85(bool) = REF_12 == False
TMP_86(bool) = progress0drop <= target0drop
TMP_87(bool) = TMP_85 && TMP_86
CONDITION TMP_87""];
32->33[label=""True""];
32->36[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
distr(investor,valdrop)

IRs:
TMP_88(bool) = INTERNAL_CALL, Fastbitcoin.distr(address,uint256)(investor,valdrop)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
Claimed[investor] = true

IRs:
REF_13(bool) -> Claimed[investor]
REF_13(bool) (->Claimed) := True(bool)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
progress0drop ++

IRs:
TMP_89(uint256) := progress0drop(uint256)
progress0drop(uint256) = progress0drop + 1""];
35->37;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_90(bool) = msg.value >= requestMinimum
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
36->37;
37[label=""Node Type: END_IF 37
""];
37->48;
38[label=""Node Type: IF 38

EXPRESSION:
tokens > 0 && msg.value >= requestMinimum

IRs:
TMP_92(bool) = tokens > 0
TMP_93(bool) = msg.value >= requestMinimum
TMP_94(bool) = TMP_92 && TMP_93
CONDITION TMP_94""];
38->39[label=""True""];
38->46[label=""False""];
39[label=""Node Type: IF 39

EXPRESSION:
now >= deadline && now >= round1 && now < round2

IRs:
TMP_95(bool) = now >= deadline
TMP_96(bool) = now >= round1
TMP_97(bool) = TMP_95 && TMP_96
TMP_98(bool) = now < round2
TMP_99(bool) = TMP_97 && TMP_98
CONDITION TMP_99""];
39->40[label=""True""];
39->41[label=""False""];
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_100(bool) = INTERNAL_CALL, Fastbitcoin.distr(address,uint256)(investor,tokens)""];
40->45;
41[label=""Node Type: IF 41

EXPRESSION:
msg.value >= bonusCond1

IRs:
TMP_101(bool) = msg.value >= bonusCond1
CONDITION TMP_101""];
41->42[label=""True""];
41->43[label=""False""];
42[label=""Node Type: EXPRESSION 42

EXPRESSION:
distr(investor,bonus)

IRs:
TMP_102(bool) = INTERNAL_CALL, Fastbitcoin.distr(address,uint256)(investor,bonus)""];
42->44;
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_103(bool) = INTERNAL_CALL, Fastbitcoin.distr(address,uint256)(investor,tokens)""];
43->44;
44[label=""Node Type: END_IF 44
""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->47;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_104(bool) = msg.value >= requestMinimum
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: IF 49

EXPRESSION:
totalDistributed >= totalSupply

IRs:
TMP_106(bool) = totalDistributed >= totalSupply
CONDITION TMP_106""];
49->50[label=""True""];
49->51[label=""False""];
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
multisig.transfer(msg.value)

IRs:
Transfer dest:multisig value:msg.value""];
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, Fastbitcoin.canDistr()()""];
53->1;
}
",0,0,1,0,"canDistr();tokens = 0;bonus = 0;countbonus = 0;bonusCond1 = 1000000000000000000 / 10;bonusCond2 = 1000000000000000000;bonusCond3 = 5000000000000000000;tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;investor = msg.sender;msg.value >= requestMinimum && now < deadline && now < round1 && now < round2;msg.value >= bonusCond1 && msg.value < bonusCond2;msg.value >= requestMinimum && now < deadline && now > round1 && now < round2;countbonus = tokens * 5 / 100;msg.value >= bonusCond2 && msg.value < bonusCond3;;countbonus = tokens * 10 / 100;msg.value >= bonusCond3;;countbonus = tokens * 15 / 100;;;msg.value >= bonusCond2 && msg.value < bonusCond3;countbonus = 0;countbonus = tokens * 5 / 100;msg.value >= bonusCond3;;countbonus = tokens * 10 / 100;;;bonus = tokens + countbonus;tokens == 0;valdrop = 5000e8;tokens > 0 && msg.value >= requestMinimum;Claimed[investor] == false && progress0drop <= target0drop;distr(investor,valdrop);require(bool)(msg.value >= requestMinimum);Claimed[investor] = true;progress0drop ++;;;now >= deadline && now >= round1 && now < round2;require(bool)(msg.value >= requestMinimum);distr(investor,tokens);msg.value >= bonusCond1;;distr(investor,bonus);distr(investor,tokens);;;totalDistributed >= totalSupply;distributionFinished = true;;multisig.transfer(msg.value)"
./0x496676b297799eeb9446b9d808c6051d33c6cb58_ext.sol,the_game.StopGame,33,36,"TMP_10(bool) = msg.sender == questionSender,TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_10(bool) = msg.sender == questionSender
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0x549b38e8e5fb1ba4acd4187d8b7c8a04deb53206_ext.sol,LotteryAdmin.withdraw,72,74,"Transfer dest:owner value:_value,MODIFIER_CALL, LotteryAdmin.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, LotteryAdmin.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();owner.transfer(_value)
./0x35bab7165a301e99c75c3e59b48817856b4d5e5c_ext.sol,Bet.withdraw,498,503,"TMP_158(None) = SOLIDITY_CALL require(bool)(isBetClosed),TMP_159 = CONVERT this to address,TMP_160(uint256) = SOLIDITY_CALL balance(address)(TMP_159),_balance(uint256) := TMP_160(uint256),REF_89(address) -> betInfo.dealer,Transfer dest:REF_89 value:_balance,REF_91(address) -> betInfo.dealer,Emit LogDealerWithdraw(REF_91,_balance)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isBetClosed)

IRs:
TMP_158(None) = SOLIDITY_CALL require(bool)(isBetClosed)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
_balance = address(this).balance

IRs:
TMP_159 = CONVERT this to address
TMP_160(uint256) = SOLIDITY_CALL balance(address)(TMP_159)
_balance(uint256) := TMP_160(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
betInfo.dealer.transfer(_balance)

IRs:
REF_89(address) -> betInfo.dealer
Transfer dest:REF_89 value:_balance""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
LogDealerWithdraw(betInfo.dealer,_balance)

IRs:
REF_91(address) -> betInfo.dealer
Emit LogDealerWithdraw(REF_91,_balance)""];
}
",0,0,1,0,"require(bool)(isBetClosed);_balance = address(this).balance;betInfo.dealer.transfer(_balance);LogDealerWithdraw(betInfo.dealer,_balance)"
./0xe3ec74dbce6ee1d8680e38714b67ab5535c95bdb_ext.sol,try_it.StopGame,33,36,"TMP_10(bool) = msg.sender == questionSender,TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_10(bool) = msg.sender == questionSender
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0x56cd53067e5acd557dbbfb4c66580dfb9722962a_ext.sol,CryptoMoviesToken._payout,370,376,"TMP_95 = CONVERT 0 to address,TMP_96(bool) = _to == TMP_95,CONDITION TMP_96,REF_38(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:ceoAddress value:REF_38,REF_40(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:_to value:REF_40","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_to == address(0)

IRs:
TMP_95 = CONVERT 0 to address
TMP_96(bool) = _to == TMP_95
CONDITION TMP_96""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ceoAddress.transfer(this.balance)

IRs:
REF_38(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:ceoAddress value:REF_38""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_to.transfer(this.balance)

IRs:
REF_40(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:_to value:REF_40""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,_to == address(0);ceoAddress.transfer(this.balance);_to.transfer(this.balance);
./0x2920e0b7d86ab76aa09bcddffedef081faaf6e2c_ext.sol,BloomToken.changeOwner,47,55,"TMP_3(bool) = msg.value >= howManyEtherInWeiToBecomeOwner,CONDITION TMP_3,Transfer dest:owner value:msg.value,REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:owner value:REF_3,owner(address) := _newowner(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value >= howManyEtherInWeiToBecomeOwner

IRs:
TMP_3(bool) = msg.value >= howManyEtherInWeiToBecomeOwner
CONDITION TMP_3""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(msg.value)

IRs:
Transfer dest:owner value:msg.value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:owner value:REF_3""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
owner = _newowner

IRs:
owner(address) := _newowner(address)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,0,1,0,msg.value >= howManyEtherInWeiToBecomeOwner;owner.transfer(msg.value);;owner.transfer(this.balance);owner = _newowner
./0x9c4d051974cdf3deb4d504ec24eac42b5e4e8847_ext.sol,omexchange.withdraw,299,302,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, omexchange.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, omexchange.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x0e2354b2ea4a6312009b228d5171bf6a02c51150_ext.sol,THE_GAME.Try,5,12,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 3000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 3000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 3000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 3000000000000000000;msg.sender.transfer(this.balance);
./0x3a858b6aa825c23621e339677a5016cfc4ff8b12_ext.sol,Enigma_X.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 400000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 400000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 400000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 400000000000000000;msg.sender.transfer(this.balance);
./0x00416b9d728069edb0ceb04bc2b203fa7336d1f1_ext.sol,SeedCrowdsaleContract.refundTransaction,177,183,"CONDITION _stateChanged,Transfer dest:msg.sender value:msg.value,TMP_51(None) = SOLIDITY_CALL revert()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_stateChanged

IRs:
CONDITION _stateChanged""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(msg.value)

IRs:
Transfer dest:msg.sender value:msg.value""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
revert()()

IRs:
TMP_51(None) = SOLIDITY_CALL revert()()""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,_stateChanged;msg.sender.transfer(msg.value);revert()();
./0x3639d5dc956e35540fbd1de691870fb1318d6783_ext.sol,SNTGiveaway.manualSend,192,202,"REF_21(bool) -> sentToAddress[_dest],TMP_35 = UnaryType.BANG REF_21 ,REF_22(bool) -> codeUsed[_code],TMP_36 = UnaryType.BANG REF_22 ,TMP_37(bool) = TMP_35 && TMP_36,TMP_38(None) = SOLIDITY_CALL require(bool,string)(TMP_37,Funds already sent / Code already used),REF_23(bool) -> sentToAddress[_dest],REF_23(bool) (->sentToAddress) := True(bool),REF_24(bool) -> codeUsed[_code],REF_24(bool) (->codeUsed) := True(bool),TMP_39(bool) = HIGH_LEVEL_CALL, dest:SNT(ERC20Token), function:transfer, arguments:['_dest', 'sntAmount']  ,TMP_40(None) = SOLIDITY_CALL require(bool,string)(TMP_39,Transfer did not work),Transfer dest:_dest value:ethAmount,Emit AddressFunded(_dest,_code,ethAmount,sntAmount),MODIFIER_CALL, Controlled.onlyController()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(! sentToAddress[_dest] && ! codeUsed[_code],Funds already sent / Code already used)

IRs:
REF_21(bool) -> sentToAddress[_dest]
TMP_35 = UnaryType.BANG REF_21 
REF_22(bool) -> codeUsed[_code]
TMP_36 = UnaryType.BANG REF_22 
TMP_37(bool) = TMP_35 && TMP_36
TMP_38(None) = SOLIDITY_CALL require(bool,string)(TMP_37,Funds already sent / Code already used)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
sentToAddress[_dest] = true

IRs:
REF_23(bool) -> sentToAddress[_dest]
REF_23(bool) (->sentToAddress) := True(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
codeUsed[_code] = true

IRs:
REF_24(bool) -> codeUsed[_code]
REF_24(bool) (->codeUsed) := True(bool)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool,string)(SNT.transfer(_dest,sntAmount),Transfer did not work)

IRs:
TMP_39(bool) = HIGH_LEVEL_CALL, dest:SNT(ERC20Token), function:transfer, arguments:['_dest', 'sntAmount']  
TMP_40(None) = SOLIDITY_CALL require(bool,string)(TMP_39,Transfer did not work)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_dest.transfer(ethAmount)

IRs:
Transfer dest:_dest value:ethAmount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
AddressFunded(_dest,_code,ethAmount,sntAmount)

IRs:
Emit AddressFunded(_dest,_code,ethAmount,sntAmount)""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()""];
7->1;
}
",1,0,1,0,"onlyController();require(bool,string)(! sentToAddress[_dest] && ! codeUsed[_code],Funds already sent / Code already used);sentToAddress[_dest] = true;codeUsed[_code] = true;require(bool,string)(SNT.transfer(_dest,sntAmount),Transfer did not work);_dest.transfer(ethAmount);AddressFunded(_dest,_code,ethAmount,sntAmount)"
./0xedebe7749b91a475918750842256f23fbe8e3029_ext.sol,PlayerBook.registerNameCore,311,337,"REF_53(uint256) -> pIDxName_[_name],TMP_49(bool) = REF_53 != 0,CONDITION TMP_49,REF_54(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_55(bool) -> REF_54[_name],TMP_50(bool) = REF_55 == True,TMP_51(None) = SOLIDITY_CALL require(bool)(TMP_50),REF_56(PlayerBook.Player) -> plyr_[_pID],REF_57(bytes32) -> REF_56.name,REF_57(bytes32) (->plyr_) := _name(bytes32),REF_58(uint256) -> pIDxName_[_name],REF_58(uint256) (->pIDxName_) := _pID(uint256),REF_59(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_60(bool) -> REF_59[_name],TMP_52(bool) = REF_60 == False,CONDITION TMP_52,REF_61(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_62(bool) -> REF_61[_name],REF_62(bool) (->plyrNames_) := True(bool),REF_63(PlayerBook.Player) -> plyr_[_pID],REF_64(uint256) -> REF_63.names,TMP_53(uint256) := REF_64(uint256),REF_64(-> plyr_) = REF_64 + 1,REF_65(mapping(uint256 => bytes32)) -> plyrNameList_[_pID],REF_66(PlayerBook.Player) -> plyr_[_pID],REF_67(uint256) -> REF_66.names,REF_68(bytes32) -> REF_65[REF_67],REF_68(bytes32) (->plyrNameList_) := _name(bytes32),TMP_54 = CONVERT this to address,TMP_55(uint256) = SOLIDITY_CALL balance(address)(TMP_54),Transfer dest:admin value:TMP_55,TMP_57(bool) = _all == True,CONDITION TMP_57,i(uint256) := 1(uint256),TMP_58(bool) = i <= gID_,CONDITION TMP_58,REF_70(PlayerBookReceiverInterface) -> games_[i],HIGH_LEVEL_CALL, dest:REF_70(PlayerBookReceiverInterface), function:receivePlayerInfo, arguments:['_pID', '_addr', '_name', '_affID']  ,TMP_60(uint256) := i(uint256),i(uint256) = i + 1,REF_72(PlayerBook.Player) -> plyr_[_affID],REF_73(address) -> REF_72.addr,REF_74(PlayerBook.Player) -> plyr_[_affID],REF_75(bytes32) -> REF_74.name,Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_73,REF_75,msg.value,now)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
pIDxName_[_name] != 0

IRs:
REF_53(uint256) -> pIDxName_[_name]
TMP_49(bool) = REF_53 != 0
CONDITION TMP_49""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(plyrNames_[_pID][_name] == true)

IRs:
REF_54(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_55(bool) -> REF_54[_name]
TMP_50(bool) = REF_55 == True
TMP_51(None) = SOLIDITY_CALL require(bool)(TMP_50)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
plyr_[_pID].name = _name

IRs:
REF_56(PlayerBook.Player) -> plyr_[_pID]
REF_57(bytes32) -> REF_56.name
REF_57(bytes32) (->plyr_) := _name(bytes32)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
pIDxName_[_name] = _pID

IRs:
REF_58(uint256) -> pIDxName_[_name]
REF_58(uint256) (->pIDxName_) := _pID(uint256)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
plyrNames_[_pID][_name] == false

IRs:
REF_59(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_60(bool) -> REF_59[_name]
TMP_52(bool) = REF_60 == False
CONDITION TMP_52""];
6->7[label=""True""];
6->10[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
plyrNames_[_pID][_name] = true

IRs:
REF_61(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_62(bool) -> REF_61[_name]
REF_62(bool) (->plyrNames_) := True(bool)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
plyr_[_pID].names ++

IRs:
REF_63(PlayerBook.Player) -> plyr_[_pID]
REF_64(uint256) -> REF_63.names
TMP_53(uint256) := REF_64(uint256)
REF_64(-> plyr_) = REF_64 + 1""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
plyrNameList_[_pID][plyr_[_pID].names] = _name

IRs:
REF_65(mapping(uint256 => bytes32)) -> plyrNameList_[_pID]
REF_66(PlayerBook.Player) -> plyr_[_pID]
REF_67(uint256) -> REF_66.names
REF_68(bytes32) -> REF_65[REF_67]
REF_68(bytes32) (->plyrNameList_) := _name(bytes32)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
admin.transfer(address(this).balance)

IRs:
TMP_54 = CONVERT this to address
TMP_55(uint256) = SOLIDITY_CALL balance(address)(TMP_54)
Transfer dest:admin value:TMP_55""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
_all == true

IRs:
TMP_57(bool) = _all == True
CONDITION TMP_57""];
12->15[label=""True""];
12->19[label=""False""];
13[label=""Node Type: BEGIN_LOOP 13
""];
13->16;
14[label=""Node Type: END_LOOP 14
""];
14->19;
15[label=""Node Type: NEW VARIABLE 15

EXPRESSION:
i = 1

IRs:
i(uint256) := 1(uint256)""];
15->13;
16[label=""Node Type: IF_LOOP 16

EXPRESSION:
i <= gID_

IRs:
TMP_58(bool) = i <= gID_
CONDITION TMP_58""];
16->17[label=""True""];
16->14[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
games_[i].receivePlayerInfo(_pID,_addr,_name,_affID)

IRs:
REF_70(PlayerBookReceiverInterface) -> games_[i]
HIGH_LEVEL_CALL, dest:REF_70(PlayerBookReceiverInterface), function:receivePlayerInfo, arguments:['_pID', '_addr', '_name', '_affID']  ""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
i ++

IRs:
TMP_60(uint256) := i(uint256)
i(uint256) = i + 1""];
18->16;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,msg.value,now)

IRs:
REF_72(PlayerBook.Player) -> plyr_[_affID]
REF_73(address) -> REF_72.addr
REF_74(PlayerBook.Player) -> plyr_[_affID]
REF_75(bytes32) -> REF_74.name
Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_73,REF_75,msg.value,now)""];
}
",0,0,1,0,"pIDxName_[_name] != 0;require(bool)(plyrNames_[_pID][_name] == true);;plyr_[_pID].name = _name;pIDxName_[_name] = _pID;plyrNames_[_pID][_name] == false;plyrNames_[_pID][_name] = true;;plyr_[_pID].names ++;plyrNameList_[_pID][plyr_[_pID].names] = _name;admin.transfer(address(this).balance);_all == true;i = 1;;;i <= gID_;;games_[i].receivePlayerInfo(_pID,_addr,_name,_affID);i ++;onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,msg.value,now)"
./0x93143d3e34a50aebab466368c3455fd858f77ad3_ext.sol,FourOutOfFive.withdrawOwnerMaxPossibleSafe,152,155,"Transfer dest:owner value:maxPossibleWithdraw,maxPossibleWithdraw(uint256) := 0(uint256),MODIFIER_CALL, FourOutOfFive.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(maxPossibleWithdraw)

IRs:
Transfer dest:owner value:maxPossibleWithdraw""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
maxPossibleWithdraw = 0

IRs:
maxPossibleWithdraw(uint256) := 0(uint256)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, FourOutOfFive.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();owner.transfer(maxPossibleWithdraw);maxPossibleWithdraw = 0
./0xf1a3dc9de80f17a22b43acecaae62f5480063111_ext.sol,RefundVault.close,445,450,"REF_109(RefundVault.State) -> State.Active,TMP_182(bool) = state == REF_109,TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182),REF_110(RefundVault.State) -> State.Closed,state(RefundVault.State) := REF_110(RefundVault.State),Emit Closed(),REF_112(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:wallet value:REF_112,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_109(RefundVault.State) -> State.Active
TMP_182(bool) = state == REF_109
TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
state = State.Closed

IRs:
REF_110(RefundVault.State) -> State.Closed
state(RefundVault.State) := REF_110(RefundVault.State)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Closed()

IRs:
Emit Closed()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
wallet.transfer(this.balance)

IRs:
REF_112(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:wallet value:REF_112""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();require(bool)(state == State.Active);state = State.Closed;Closed();wallet.transfer(this.balance)
./0x279f9f9b73bfdbe14e4912a6d5f7442ecdf97b37_ext.sol,Destructible.destroy,123,125,"TMP_43(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_43(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0xd587cb111d3e506ffafdf4b1c5d19008086c4e5a_ext.sol,IartistChain.selfdestructs,153,155,"TMP_82(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_82(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0xc780b0272bbe7caedb6b47157d88ce51b324da58_ext.sol,CashFlow.fallback,31,35,"TMP_0 = CONVERT this to address,TMP_1(uint256) = SOLIDITY_CALL balance(address)(TMP_0),TMP_2(bool) = TMP_1 > 10000000000000000000,CONDITION TMP_2,Transfer dest:depositAddress value:10000000000000000000","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
address(this).balance > 10000000000000000000

IRs:
TMP_0 = CONVERT this to address
TMP_1(uint256) = SOLIDITY_CALL balance(address)(TMP_0)
TMP_2(bool) = TMP_1 > 10000000000000000000
CONDITION TMP_2""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
depositAddress.transfer(10000000000000000000)

IRs:
Transfer dest:depositAddress value:10000000000000000000""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,0,1,0,address(this).balance > 10000000000000000000;depositAddress.transfer(10000000000000000000);
./0x7275f61c3abfba3596ae71f7128bdc3b0fc01fa9_ext.sol,Ownable.kill,39,42,"REF_0(uint256) = SOLIDITY_CALL balance(address)(this),TMP_2(bool) = REF_0 == 0,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),TMP_4(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(this.balance == 0)

IRs:
REF_0(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_2(bool) = REF_0 == 0
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_4(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();require(bool)(this.balance == 0);selfdestruct(address)(owner)
./0x50f37df80a4e804a03275b21f83ebf5d5a668d39_ext.sol,AuctionPotato.withdraw,266,271,"TMP_80(bool) = now > endTime,TMP_81(None) = SOLIDITY_CALL require(bool)(TMP_80),TMP_82 = CONVERT this to address,TMP_83(uint256) = SOLIDITY_CALL balance(address)(TMP_82),Emit Withdraw(msg.sender,TMP_83),TMP_85 = CONVERT this to address,TMP_86(uint256) = SOLIDITY_CALL balance(address)(TMP_85),Transfer dest:msg.sender value:TMP_86,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now > endTime)

IRs:
TMP_80(bool) = now > endTime
TMP_81(None) = SOLIDITY_CALL require(bool)(TMP_80)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Withdraw(msg.sender,address(this).balance)

IRs:
TMP_82 = CONVERT this to address
TMP_83(uint256) = SOLIDITY_CALL balance(address)(TMP_82)
Emit Withdraw(msg.sender,TMP_83)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_85 = CONVERT this to address
TMP_86(uint256) = SOLIDITY_CALL balance(address)(TMP_85)
Transfer dest:msg.sender value:TMP_86""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->1;
}
",0,0,1,0,"onlyOwner();require(bool)(now > endTime);Withdraw(msg.sender,address(this).balance);msg.sender.transfer(address(this).balance)"
./0xf3f3dd2b5d9f3de1b1ceb6ad84683bf31adf29d1_ext.sol,SAFE_GIFT.GetGift,5,13,"TMP_0(bytes32) = SOLIDITY_CALL keccak256()(pass),TMP_1(bool) = hashPass == TMP_0,TMP_2(bool) = now > giftTime,TMP_3(bool) = TMP_1 && TMP_2,CONDITION TMP_3,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
hashPass == keccak256()(pass) && now > giftTime

IRs:
TMP_0(bytes32) = SOLIDITY_CALL keccak256()(pass)
TMP_1(bool) = hashPass == TMP_0
TMP_2(bool) = now > giftTime
TMP_3(bool) = TMP_1 && TMP_2
CONDITION TMP_3""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,1,1,0,hashPass == keccak256()(pass) && now > giftTime;msg.sender.transfer(this.balance);
./0x2066a2e0cd7f19589f582e2fc9af9669cc9e02f1_ext.sol,SetherToken.killContract,58,64,"TMP_6(bool) = msg.sender == owner,TMP_7(bool) = msg.value >= howManyEtherInWeiToKillContract,TMP_8(bool) = TMP_6 || TMP_7,CONDITION TMP_8,TMP_9(None) = SOLIDITY_CALL selfdestruct(address)(owner)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == owner || msg.value >= howManyEtherInWeiToKillContract

IRs:
TMP_6(bool) = msg.sender == owner
TMP_7(bool) = msg.value >= howManyEtherInWeiToKillContract
TMP_8(bool) = TMP_6 || TMP_7
CONDITION TMP_8""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_9(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,0,1,0,msg.sender == owner || msg.value >= howManyEtherInWeiToKillContract;selfdestruct(address)(owner);
./0xc80205befdb86a1891019969001e90b064d5735a_ext.sol,MILO.withdraw,291,294,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, MILO.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MILO.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06_ext.sol,FlowerCore.withdrawBalance,1462,1464,"TMP_2095 = CONVERT this to address,TMP_2096(uint256) = SOLIDITY_CALL balance(address)(TMP_2095),Transfer dest:owner value:TMP_2096,MODIFIER_CALL, FlowerAdminAccess.onlyAdministrator()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_2095 = CONVERT this to address
TMP_2096(uint256) = SOLIDITY_CALL balance(address)(TMP_2095)
Transfer dest:owner value:TMP_2096""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyAdministrator()

IRs:
MODIFIER_CALL, FlowerAdminAccess.onlyAdministrator()()""];
2->1;
}
",0,0,1,0,onlyAdministrator();owner.transfer(address(this).balance)
./0xde745420248e0dde0cf774b5db8d59c96982b3a2_ext.sol,Payout.extractFund,81,88,"TMP_30(bool) = _amount == 0,CONDITION TMP_30,TMP_31 = CONVERT this to address,TMP_32(uint256) = SOLIDITY_CALL balance(address)(TMP_31),Transfer dest:owner value:TMP_32,TMP_34 = CONVERT this to address,TMP_35(uint256) = SOLIDITY_CALL balance(address)(TMP_34),TMP_36(bool) = _amount <= TMP_35,TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36),Transfer dest:owner value:_amount,MODIFIER_CALL, Payout.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: IF 1

EXPRESSION:
_amount == 0

IRs:
TMP_30(bool) = _amount == 0
CONDITION TMP_30""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_31 = CONVERT this to address
TMP_32(uint256) = SOLIDITY_CALL balance(address)(TMP_31)
Transfer dest:owner value:TMP_32""];
2->5;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_amount <= address(this).balance)

IRs:
TMP_34 = CONVERT this to address
TMP_35(uint256) = SOLIDITY_CALL balance(address)(TMP_34)
TMP_36(bool) = _amount <= TMP_35
TMP_37(None) = SOLIDITY_CALL require(bool)(TMP_36)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
owner.transfer(_amount)

IRs:
Transfer dest:owner value:_amount""];
4->5;
5[label=""Node Type: END_IF 5
""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Payout.onlyOwner()()""];
6->1;
}
",0,0,1,0,onlyOwner();_amount == 0;owner.transfer(address(this).balance);require(bool)(_amount <= address(this).balance);;owner.transfer(_amount)
./0xd029de67c3f46d046c635f60efeb41d5b92a74ae_ext.sol,Owned.destroy,38,40,"TMP_0(None) = SOLIDITY_CALL suicide(address)(msg.sender),MODIFIER_CALL, Owned.onlyContractOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
suicide(address)(msg.sender)

IRs:
TMP_0(None) = SOLIDITY_CALL suicide(address)(msg.sender)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyContractOwner()

IRs:
MODIFIER_CALL, Owned.onlyContractOwner()()""];
2->1;
}
",0,0,1,0,onlyContractOwner();suicide(address)(msg.sender)
./0x479cbe1f6a7fa4d7e304ae983803c46e85ced870_ext.sol,Slaughter3D.Expand,149,156,"REF_22(uint256) -> ETHtoP3Dbymasternode[masternode],amt(uint256) := REF_22(uint256),REF_23(uint256) -> ETHtoP3Dbymasternode[masternode],REF_23(uint256) (->ETHtoP3Dbymasternode) := 0(uint256),TMP_8(bool) = masternode == 0,CONDITION TMP_8,masternode(address) := 871306264221423929613616941033271715489402817017(address),TMP_10(uint256) = HIGH_LEVEL_CALL, dest:p3dContract(HourglassInterface), function:buy, arguments:['masternode'] value:amt ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
amt = ETHtoP3Dbymasternode[masternode]

IRs:
REF_22(uint256) -> ETHtoP3Dbymasternode[masternode]
amt(uint256) := REF_22(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ETHtoP3Dbymasternode[masternode] = 0

IRs:
REF_23(uint256) -> ETHtoP3Dbymasternode[masternode]
REF_23(uint256) (->ETHtoP3Dbymasternode) := 0(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
masternode == 0x0

IRs:
TMP_8(bool) = masternode == 0
CONDITION TMP_8""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
masternode = 0x989eB9629225B8C06997eF0577CC08535fD789F9

IRs:
masternode(address) := 871306264221423929613616941033271715489402817017(address)""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
p3dContract.buy.value(amt)(masternode)

IRs:
TMP_10(uint256) = HIGH_LEVEL_CALL, dest:p3dContract(HourglassInterface), function:buy, arguments:['masternode'] value:amt ""];
}
",0,0,1,0,amt = ETHtoP3Dbymasternode[masternode];ETHtoP3Dbymasternode[masternode] = 0;masternode == 0x0;masternode = 0x989eB9629225B8C06997eF0577CC08535fD789F9;;p3dContract.buy.value(amt)(masternode)
./0x5b39afa22a9debd9247bf84b68a79b8736c2ba4e_ext.sol,Quiz.Try,5,15,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x3f96c0e80b82458c1a96a3b7d7d2297f55df4965_ext.sol,Treethereum.fallback,24,50,"timeout(uint256) := 1520665289(uint256),recaddress(address) := msg.sender(address),TMP_13(address) = INTERNAL_CALL, Treethereum.bytesToAddr(bytes)(msg.data),invaddress(address) := TMP_13(address),TMP_14(bool) = invaddress == 0,TMP_15(bool) = invaddress == recaddress,TMP_16(bool) = TMP_14 || TMP_15,CONDITION TMP_16,invaddress(address) := 843954883858546009863249338577906010284353392187(address),INTERNAL_CALL, Treethereum.addrecruit(address,address)(recaddress,invaddress),i(uint256) := 0(uint256),amount(uint256) := msg.value(uint256),TMP_18(bool) = amount < 200000000000000000,TMP_19(bool) = now > timeout,TMP_20(bool) = TMP_18 && TMP_19,CONDITION TMP_20,Transfer dest:msg.sender value:msg.value,TMP_22(None) = SOLIDITY_CALL revert()(),TMP_23(bool) = i < 7,CONDITION TMP_23,TMP_24(uint256) = amount / 2,share(uint256) := TMP_24(uint256),TMP_25(bool) = recaddress == 0,CONDITION TMP_25,REF_6(address) -> inviter[recaddress],Transfer dest:REF_6 value:share,recaddress(address) := 843954883858546009863249338577906010284353392187(address),REF_8(address) -> inviter[recaddress],Transfer dest:REF_8 value:share,REF_10(address) -> inviter[recaddress],recaddress(address) := REF_10(address),amount(uint256) = amount - share,TMP_28(uint256) := i(uint256),i(uint256) = i + 1,REF_11(address) -> inviter[recaddress],Transfer dest:REF_11 value:share","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
timeout = 1520665289

IRs:
timeout(uint256) := 1520665289(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
recaddress = msg.sender

IRs:
recaddress(address) := msg.sender(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
invaddress = bytesToAddr(msg.data)

IRs:
TMP_13(address) = INTERNAL_CALL, Treethereum.bytesToAddr(bytes)(msg.data)
invaddress(address) := TMP_13(address)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
invaddress == 0x0 || invaddress == recaddress

IRs:
TMP_14(bool) = invaddress == 0
TMP_15(bool) = invaddress == recaddress
TMP_16(bool) = TMP_14 || TMP_15
CONDITION TMP_16""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
invaddress = 0x93D43eeFcFbE8F9e479E172ee5d92DdDd2600E3b

IRs:
invaddress(address) := 843954883858546009863249338577906010284353392187(address)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
addrecruit(recaddress,invaddress)

IRs:
INTERNAL_CALL, Treethereum.addrecruit(address,address)(recaddress,invaddress)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
amount = msg.value

IRs:
amount(uint256) := msg.value(uint256)""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
amount < 200000000000000000 && now > timeout

IRs:
TMP_18(bool) = amount < 200000000000000000
TMP_19(bool) = now > timeout
TMP_20(bool) = TMP_18 && TMP_19
CONDITION TMP_20""];
10->11[label=""True""];
10->13[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
msg.sender.transfer(msg.value)

IRs:
Transfer dest:msg.sender value:msg.value""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
revert()()

IRs:
TMP_22(None) = SOLIDITY_CALL revert()()""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: BEGIN_LOOP 14
""];
14->15;
15[label=""Node Type: IF_LOOP 15

EXPRESSION:
i < 7

IRs:
TMP_23(bool) = i < 7
CONDITION TMP_23""];
15->16[label=""True""];
15->25[label=""False""];
16[label=""Node Type: NEW VARIABLE 16

EXPRESSION:
share = amount / 2

IRs:
TMP_24(uint256) = amount / 2
share(uint256) := TMP_24(uint256)""];
16->17;
17[label=""Node Type: IF 17

EXPRESSION:
recaddress == 0x0

IRs:
TMP_25(bool) = recaddress == 0
CONDITION TMP_25""];
17->18[label=""True""];
17->20[label=""False""];
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
inviter[recaddress].transfer(share)

IRs:
REF_6(address) -> inviter[recaddress]
Transfer dest:REF_6 value:share""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
recaddress = 0x93D43eeFcFbE8F9e479E172ee5d92DdDd2600E3b

IRs:
recaddress(address) := 843954883858546009863249338577906010284353392187(address)""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
inviter[recaddress].transfer(share)

IRs:
REF_8(address) -> inviter[recaddress]
Transfer dest:REF_8 value:share""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
recaddress = inviter[recaddress]

IRs:
REF_10(address) -> inviter[recaddress]
recaddress(address) := REF_10(address)""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
amount -= share

IRs:
amount(uint256) = amount - share""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
i ++

IRs:
TMP_28(uint256) := i(uint256)
i(uint256) = i + 1""];
24->15;
25[label=""Node Type: END_LOOP 25
""];
25->26;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
inviter[recaddress].transfer(share)

IRs:
REF_11(address) -> inviter[recaddress]
Transfer dest:REF_11 value:share""];
}
",0,0,1,0,"timeout = 1520665289;recaddress = msg.sender;invaddress = bytesToAddr(msg.data);invaddress == 0x0 || invaddress == recaddress;invaddress = 0x93D43eeFcFbE8F9e479E172ee5d92DdDd2600E3b;;addrecruit(recaddress,invaddress);i = 0;amount = msg.value;amount < 200000000000000000 && now > timeout;msg.sender.transfer(msg.value);;revert()();;i < 7;share = amount / 2;;recaddress == 0x0;inviter[recaddress].transfer(share);;recaddress = 0x93D43eeFcFbE8F9e479E172ee5d92DdDd2600E3b;inviter[recaddress].transfer(share);recaddress = inviter[recaddress];amount -= share;i ++;inviter[recaddress].transfer(share)"
./0xcf377dfd654676940e2b5a87cf2673def25aeaed_ext.sol,GreenEthereusPromo.massSending,73,87,"TMP_2(bool) = index != 1000000,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),i(uint256) := index(uint256),REF_0 -> LENGTH _addresses,TMP_4(bool) = i < REF_0,CONDITION TMP_4,REF_1(address) -> _addresses[i],TMP_5 = SEND dest:REF_1 value:777,REF_3(address) -> _addresses[i],Emit Transfer(0,REF_3,777),REF_4 -> LENGTH _addresses,TMP_7(uint256) = REF_4 - 1,TMP_8(bool) = i == TMP_7,CONDITION TMP_8,index(uint256) := 1000000(uint256),TMP_9(uint256) = SOLIDITY_CALL gasleft()(),TMP_10(bool) = TMP_9 <= 50000,CONDITION TMP_10,index(uint256) := i(uint256),TMP_11(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, GreenEthereusPromo.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->17;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(index != 1000000)

IRs:
TMP_2(bool) = index != 1000000
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = index

IRs:
i(uint256) := index(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < _addresses.length

IRs:
REF_0 -> LENGTH _addresses
TMP_4(bool) = i < REF_0
CONDITION TMP_4""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
_addresses[i].send(777)

IRs:
REF_1(address) -> _addresses[i]
TMP_5 = SEND dest:REF_1 value:777""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Transfer(0x0,_addresses[i],777)

IRs:
REF_3(address) -> _addresses[i]
Emit Transfer(0,REF_3,777)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
i == _addresses.length - 1

IRs:
REF_4 -> LENGTH _addresses
TMP_7(uint256) = REF_4 - 1
TMP_8(bool) = i == TMP_7
CONDITION TMP_8""];
8->9[label=""True""];
8->11[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
index = 1000000

IRs:
index(uint256) := 1000000(uint256)""];
9->10;
10[label=""Node Type: BREAK 10
""];
10->3;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
gasleft()() <= 50000

IRs:
TMP_9(uint256) = SOLIDITY_CALL gasleft()()
TMP_10(bool) = TMP_9 <= 50000
CONDITION TMP_10""];
12->13[label=""True""];
12->15[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
index = i

IRs:
index(uint256) := i(uint256)""];
13->14;
14[label=""Node Type: BREAK 14
""];
14->3;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
i ++

IRs:
TMP_11(uint256) := i(uint256)
i(uint256) = i + 1""];
16->5;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, GreenEthereusPromo.onlyOwner()()""];
17->1;
}
",0,0,1,0,"onlyOwner();require(bool)(index != 1000000);i = index;;i < _addresses.length;;_addresses[i].send(777);Transfer(0x0,_addresses[i],777);i == _addresses.length - 1;index = 1000000;;;gasleft()() <= 50000;index = i;;;i ++"
./0xd16dfe7a7f447b00122a01efd5acb99a7aee7c04_ext.sol,EncryptedToken.selfdestructs,193,195,"TMP_88(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_88(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0xa2201234a4652a704f5539058ccb9ab6ebcd486b_ext.sol,MultiSigWallet.executeTransaction,229,243,"TMP_68(bool) = INTERNAL_CALL, MultiSigWallet.isConfirmed(uint256)(transactionId),CONDITION TMP_68,REF_44(MultiSigWallet.Transaction) -> transactions[transactionId],tx(MultiSigWallet.Transaction) := REF_44(MultiSigWallet.Transaction),REF_45(bool) -> tx.executed,REF_45(bool) (->tx) := True(bool),REF_46(address) -> tx.destination,REF_49(uint256) -> tx.value,REF_50(bytes) -> tx.data,TMP_70(bool) = LOW_LEVEL_CALL, dest:REF_46, function:call, arguments:['REF_50'] value:REF_49 ,CONDITION TMP_70,Emit Execution(transactionId),Emit ExecutionFailure(transactionId),REF_51(bool) -> tx.executed,REF_51(bool) (->tx) := False(bool),MODIFIER_CALL, MultiSigWallet.notExecuted(uint256)(transactionId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: IF 1

EXPRESSION:
isConfirmed(transactionId)

IRs:
TMP_68(bool) = INTERNAL_CALL, MultiSigWallet.isConfirmed(uint256)(transactionId)
CONDITION TMP_68""];
1->2[label=""True""];
1->9[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
tx = transactions[transactionId]

IRs:
REF_44(MultiSigWallet.Transaction) -> transactions[transactionId]
tx(MultiSigWallet.Transaction) := REF_44(MultiSigWallet.Transaction)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tx.executed = true

IRs:
REF_45(bool) -> tx.executed
REF_45(bool) (->tx) := True(bool)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
tx.destination.call.value(tx.value)(tx.data)

IRs:
REF_46(address) -> tx.destination
REF_49(uint256) -> tx.value
REF_50(bytes) -> tx.data
TMP_70(bool) = LOW_LEVEL_CALL, dest:REF_46, function:call, arguments:['REF_50'] value:REF_49 
CONDITION TMP_70""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Execution(transactionId)

IRs:
Emit Execution(transactionId)""];
5->8;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
ExecutionFailure(transactionId)

IRs:
Emit ExecutionFailure(transactionId)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tx.executed = false

IRs:
REF_51(bool) -> tx.executed
REF_51(bool) (->tx) := False(bool)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, MultiSigWallet.notExecuted(uint256)(transactionId)""];
10->1;
}
",0,0,1,0,notExecuted(transactionId);isConfirmed(transactionId);tx = transactions[transactionId];;tx.executed = true;tx.destination.call.value(tx.value)(tx.data);Execution(transactionId);ExecutionFailure(transactionId);;tx.executed = false
./0x8d40e75ed0bcc4ca13aa4113738898f9779858be_ext.sol,STEShop.withdrawToFounders,144,154,"REF_8 -> LENGTH foundersAddresses,TMP_41(uint256) = _amount / REF_8,amount_to_withdraw(uint256) := TMP_41(uint256),i(uint8) := 0(uint256),errors(uint8) := 0(uint256),i(uint8) := 0(uint256),REF_9 -> LENGTH foundersAddresses,TMP_42(bool) = i < REF_9,CONDITION TMP_42,REF_10(address) -> foundersAddresses[i],TMP_43 = SEND dest:REF_10 value:amount_to_withdraw,TMP_44 = UnaryType.BANG TMP_43 ,CONDITION TMP_44,TMP_45(uint8) := errors(uint8),errors(uint8) = errors + 1,TMP_46(uint8) := i(uint8),i(uint8) = i + 1,RETURN errors,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->13;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
amount_to_withdraw = _amount / foundersAddresses.length

IRs:
REF_8 -> LENGTH foundersAddresses
TMP_41(uint256) = _amount / REF_8
amount_to_withdraw(uint256) := TMP_41(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
errors = 0

IRs:
errors(uint8) := 0(uint256)""];
3->6;
4[label=""Node Type: BEGIN_LOOP 4
""];
4->7;
5[label=""Node Type: END_LOOP 5
""];
5->12;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)""];
6->4;
7[label=""Node Type: IF_LOOP 7

EXPRESSION:
i < foundersAddresses.length

IRs:
REF_9 -> LENGTH foundersAddresses
TMP_42(bool) = i < REF_9
CONDITION TMP_42""];
7->8[label=""True""];
7->5[label=""False""];
8[label=""Node Type: IF 8

EXPRESSION:
! foundersAddresses[i].send(amount_to_withdraw)

IRs:
REF_10(address) -> foundersAddresses[i]
TMP_43 = SEND dest:REF_10 value:amount_to_withdraw
TMP_44 = UnaryType.BANG TMP_43 
CONDITION TMP_44""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
errors ++

IRs:
TMP_45(uint8) := errors(uint8)
errors(uint8) = errors + 1""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_46(uint8) := i(uint8)
i(uint8) = i + 1""];
11->7;
12[label=""Node Type: RETURN 12

EXPRESSION:
errors

IRs:
RETURN errors""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
13->1;
}
",0,0,1,0,onlyOwner();amount_to_withdraw = _amount / foundersAddresses.length;i = 0;errors = 0;i = 0;;i < foundersAddresses.length;;errors;! foundersAddresses[i].send(amount_to_withdraw);errors ++;;i ++
./0xa3ea961ea44bafa061fe7b2ece819d2a8ceb69b2_ext.sol,TydoPreIco.withdraw,173,179,"TMP_69(bool) = state == 3,TMP_70(None) = SOLIDITY_CALL require(bool)(TMP_69),Transfer dest:owner value:ethCollected,ethCollected(uint256) := 0(uint256),state(uint8) := 4(uint256),MODIFIER_CALL, Owned.ownerOnly()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == 3)

IRs:
TMP_69(bool) = state == 3
TMP_70(None) = SOLIDITY_CALL require(bool)(TMP_69)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(ethCollected)

IRs:
Transfer dest:owner value:ethCollected""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ethCollected = 0

IRs:
ethCollected(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
state = 4

IRs:
state(uint8) := 4(uint256)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
ownerOnly()

IRs:
MODIFIER_CALL, Owned.ownerOnly()()""];
5->1;
}
",0,0,1,0,ownerOnly();require(bool)(state == 3);owner.transfer(ethCollected);ethCollected = 0;state = 4
./0xed29ff5874fa64dcf47ed7dacb770857a5d164fb_ext.sol,Vault.withdraw,70,78,"TMP_34(bool) = INTERNAL_CALL, Vault.WithdrawEnabled()(),CONDITION TMP_34,REF_7(uint256) -> Deposits[msg.sender],max(uint256) := REF_7(uint256),TMP_35(bool) = max > 0,TMP_36(bool) = amount <= max,TMP_37(bool) = TMP_35 && TMP_36,CONDITION TMP_37,Transfer dest:to value:amount,Emit Withdrawal(to,amount),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: IF 1

EXPRESSION:
WithdrawEnabled()

IRs:
TMP_34(bool) = INTERNAL_CALL, Vault.WithdrawEnabled()()
CONDITION TMP_34""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
max = Deposits[msg.sender]

IRs:
REF_7(uint256) -> Deposits[msg.sender]
max(uint256) := REF_7(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
max > 0 && amount <= max

IRs:
TMP_35(bool) = max > 0
TMP_36(bool) = amount <= max
TMP_37(bool) = TMP_35 && TMP_36
CONDITION TMP_37""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
to.transfer(amount)

IRs:
Transfer dest:to value:amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Withdrawal(to,amount)

IRs:
Emit Withdrawal(to,amount)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: END_IF 7
""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
8->1;
}
",0,0,1,0,"onlyOwner();WithdrawEnabled();max = Deposits[msg.sender];;max > 0 && amount <= max;to.transfer(amount);;Withdrawal(to,amount)"
./0x36fc9fff1bf5b08ed2c472d6370dc62fa3016ffa_ext.sol,quizgame.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 400000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 400000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 400000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 400000000000000000;msg.sender.transfer(this.balance);
./0xed29ff5874fa64dcf47ed7dacb770857a5d164fb_ext.sol,Vault.kill,88,88,"REF_9(uint256) = SOLIDITY_CALL balance(address)(this),TMP_42(bool) = REF_9 == 0,TMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42),TMP_44(None) = SOLIDITY_CALL selfdestruct(address)(Owner)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(this.balance == 0)

IRs:
REF_9(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_42(bool) = REF_9 == 0
TMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(Owner)

IRs:
TMP_44(None) = SOLIDITY_CALL selfdestruct(address)(Owner)""];
}
",0,0,1,0,require(bool)(this.balance == 0);selfdestruct(address)(Owner)
./0x553e3e5ba03e862c93c7834b80ca800018ba4736_ext.sol,SamsungCryptoPayments.withdraw,300,303,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, SamsungCryptoPayments.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, SamsungCryptoPayments.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x0dcfdb9f5496ed7f62dd0ac019c7daf184a66aef_ext.sol,LVRCrowdsale.fallback,62,87,"TMP_17(bool) = msg.value > 0,TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17),TMP_19(bool) = now > startDate,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),TMP_21(bool) = now < endDate,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),TMP_23(uint256) = msg.value * price,amount(uint256) := TMP_23(uint256),TMP_24(uint256) = amount / 20,_amount(uint256) := TMP_24(uint256),TMP_25(bool) = now > 1522839600,TMP_26(bool) = now < 1523098800,TMP_27(bool) = TMP_25 && TMP_26,CONDITION TMP_27,TMP_28(uint256) = _amount * 6,amount(uint256) = amount + TMP_28,TMP_29(bool) = now > 1523098800,TMP_30(bool) = now < 1523703600,TMP_31(bool) = TMP_29 && TMP_30,CONDITION TMP_31,TMP_32(uint256) = _amount * 4,amount(uint256) = amount + TMP_32,TMP_33(bool) = now > 1523703600,TMP_34(bool) = now < 1524913200,TMP_35(bool) = TMP_33 && TMP_34,CONDITION TMP_35,TMP_36(uint256) = _amount * 2,amount(uint256) = amount + TMP_36,TMP_37(bool) = HIGH_LEVEL_CALL, dest:tokenReward(Token), function:transferFrom, arguments:['owner', 'msg.sender', 'amount']  ,Emit FundTransfer(msg.sender,amount,True),Transfer dest:owner value:msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value > 0)

IRs:
TMP_17(bool) = msg.value > 0
TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(now > startDate)

IRs:
TMP_19(bool) = now > startDate
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(now < endDate)

IRs:
TMP_21(bool) = now < endDate
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
amount = msg.value * price

IRs:
TMP_23(uint256) = msg.value * price
amount(uint256) := TMP_23(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
_amount = amount / 20

IRs:
TMP_24(uint256) = amount / 20
_amount(uint256) := TMP_24(uint256)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
now > 1522839600 && now < 1523098800

IRs:
TMP_25(bool) = now > 1522839600
TMP_26(bool) = now < 1523098800
TMP_27(bool) = TMP_25 && TMP_26
CONDITION TMP_27""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
amount += _amount * 6

IRs:
TMP_28(uint256) = _amount * 6
amount(uint256) = amount + TMP_28""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
now > 1523098800 && now < 1523703600

IRs:
TMP_29(bool) = now > 1523098800
TMP_30(bool) = now < 1523703600
TMP_31(bool) = TMP_29 && TMP_30
CONDITION TMP_31""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
amount += _amount * 4

IRs:
TMP_32(uint256) = _amount * 4
amount(uint256) = amount + TMP_32""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
now > 1523703600 && now < 1524913200

IRs:
TMP_33(bool) = now > 1523703600
TMP_34(bool) = now < 1524913200
TMP_35(bool) = TMP_33 && TMP_34
CONDITION TMP_35""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
amount += _amount * 2

IRs:
TMP_36(uint256) = _amount * 2
amount(uint256) = amount + TMP_36""];
13->14;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
tokenReward.transferFrom(owner,msg.sender,amount)

IRs:
TMP_37(bool) = HIGH_LEVEL_CALL, dest:tokenReward(Token), function:transferFrom, arguments:['owner', 'msg.sender', 'amount']  ""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
FundTransfer(msg.sender,amount,true)

IRs:
Emit FundTransfer(msg.sender,amount,True)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
owner.transfer(msg.value)

IRs:
Transfer dest:owner value:msg.value""];
}
",0,0,1,0,"require(bool)(msg.value > 0);require(bool)(now > startDate);require(bool)(now < endDate);amount = msg.value * price;_amount = amount / 20;now > 1522839600 && now < 1523098800;amount += _amount * 6;;now > 1523098800 && now < 1523703600;amount += _amount * 4;;now > 1523703600 && now < 1524913200;amount += _amount * 2;;tokenReward.transferFrom(owner,msg.sender,amount);FundTransfer(msg.sender,amount,true);owner.transfer(msg.value)"
./0x0d9a437282ba395664ed7d26df2377659a7e16af_ext.sol,SaleTracker.purchase,163,197,"TMP_49(bool) = msg.value != 0,TMP_50(None) = SOLIDITY_CALL require(bool)(TMP_49),TMP_51(bool) = paymentCode != 0,TMP_52(None) = SOLIDITY_CALL require(bool)(TMP_51),CONDITION enforceAddressMatch,TMP_53(bytes32) = SOLIDITY_CALL sha3()(msg.sender),TMP_54 = CONVERT TMP_53 to bytes8,calculatedPaymentCode(bytes8) := TMP_54(bytes8),TMP_55(bool) = calculatedPaymentCode == paymentCode,TMP_56(None) = SOLIDITY_CALL require(bool)(TMP_55),REF_0(uint256) -> purchases[msg.sender],existingPurchaseAmount(uint256) := REF_0(uint256),TMP_57(bool) = existingPurchaseAmount == 0,CONDITION TMP_57,REF_2 -> LENGTH purchaserAddresses,TMP_59(uint256) := REF_2(uint256),TMP_60(uint256) = TMP_59 + 1,REF_2(uint256) (->purchaserAddresses) := TMP_60(uint256),REF_3(address) -> purchaserAddresses[TMP_59],REF_3(address) (->purchaserAddresses) := msg.sender(address),REF_4(uint256) -> purchases[msg.sender],TMP_61(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['existingPurchaseAmount', 'msg.value'] ,REF_4(uint256) (->purchases) := TMP_61(uint256),Transfer dest:owner value:msg.value,Emit PurchaseMade(msg.sender,paymentCode,msg.value),MODIFIER_CALL, Pausable.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value != 0)

IRs:
TMP_49(bool) = msg.value != 0
TMP_50(None) = SOLIDITY_CALL require(bool)(TMP_49)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(paymentCode != 0)

IRs:
TMP_51(bool) = paymentCode != 0
TMP_52(None) = SOLIDITY_CALL require(bool)(TMP_51)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
enforceAddressMatch

IRs:
CONDITION enforceAddressMatch""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
calculatedPaymentCode = bytes8(sha3()(msg.sender))

IRs:
TMP_53(bytes32) = SOLIDITY_CALL sha3()(msg.sender)
TMP_54 = CONVERT TMP_53 to bytes8
calculatedPaymentCode(bytes8) := TMP_54(bytes8)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(calculatedPaymentCode == paymentCode)

IRs:
TMP_55(bool) = calculatedPaymentCode == paymentCode
TMP_56(None) = SOLIDITY_CALL require(bool)(TMP_55)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
existingPurchaseAmount = purchases[msg.sender]

IRs:
REF_0(uint256) -> purchases[msg.sender]
existingPurchaseAmount(uint256) := REF_0(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
existingPurchaseAmount == 0

IRs:
TMP_57(bool) = existingPurchaseAmount == 0
CONDITION TMP_57""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
purchaserAddresses.push(msg.sender)

IRs:
REF_2 -> LENGTH purchaserAddresses
TMP_59(uint256) := REF_2(uint256)
TMP_60(uint256) = TMP_59 + 1
REF_2(uint256) (->purchaserAddresses) := TMP_60(uint256)
REF_3(address) -> purchaserAddresses[TMP_59]
REF_3(address) (->purchaserAddresses) := msg.sender(address)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
purchases[msg.sender] = existingPurchaseAmount.add(msg.value)

IRs:
REF_4(uint256) -> purchases[msg.sender]
TMP_61(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['existingPurchaseAmount', 'msg.value'] 
REF_4(uint256) (->purchases) := TMP_61(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
owner.transfer(msg.value)

IRs:
Transfer dest:owner value:msg.value""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
PurchaseMade(msg.sender,paymentCode,msg.value)

IRs:
Emit PurchaseMade(msg.sender,paymentCode,msg.value)""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
14->1;
}
",0,0,1,0,"whenNotPaused();require(bool)(msg.value != 0);require(bool)(paymentCode != 0);enforceAddressMatch;calculatedPaymentCode = bytes8(sha3()(msg.sender));;require(bool)(calculatedPaymentCode == paymentCode);existingPurchaseAmount = purchases[msg.sender];existingPurchaseAmount == 0;purchaserAddresses.push(msg.sender);;purchases[msg.sender] = existingPurchaseAmount.add(msg.value);owner.transfer(msg.value);PurchaseMade(msg.sender,paymentCode,msg.value)"
./0xf17a9ad24372faaa27f0bb684e13413a3de84c4b_ext.sol,SmokeCoinV_2.getTokens,189,249,"tokens(uint256) := 0(uint256),bonus(uint256) := 0(uint256),countbonus(uint256) := 0(uint256),TMP_45(uint256) = 1000000000000000000 / 10,bonusCond1(uint256) := TMP_45(uint256),TMP_46(uint256) = 5000000000000000000 / 10,bonusCond2(uint256) := TMP_46(uint256),bonusCond3(uint256) := 1000000000000000000(uint256),TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_48(uint256) = TMP_47 / 1000000000000000000,tokens(uint256) := TMP_48(uint256),investor(address) := msg.sender(address),TMP_49(bool) = msg.value >= requestMinimum,TMP_50(bool) = now < deadline,TMP_51(bool) = TMP_49 && TMP_50,TMP_52(bool) = now < round1,TMP_53(bool) = TMP_51 && TMP_52,TMP_54(bool) = now < round2,TMP_55(bool) = TMP_53 && TMP_54,CONDITION TMP_55,TMP_56(bool) = msg.value >= bonusCond1,TMP_57(bool) = msg.value < bonusCond2,TMP_58(bool) = TMP_56 && TMP_57,CONDITION TMP_58,TMP_59(uint256) = tokens * 10,TMP_60(uint256) = TMP_59 / 100,countbonus(uint256) := TMP_60(uint256),TMP_61(bool) = msg.value >= bonusCond2,TMP_62(bool) = msg.value < bonusCond3,TMP_63(bool) = TMP_61 && TMP_62,CONDITION TMP_63,TMP_64(uint256) = tokens * 20,TMP_65(uint256) = TMP_64 / 100,countbonus(uint256) := TMP_65(uint256),TMP_66(bool) = msg.value >= bonusCond3,CONDITION TMP_66,TMP_67(uint256) = tokens * 35,TMP_68(uint256) = TMP_67 / 100,countbonus(uint256) := TMP_68(uint256),TMP_69(bool) = msg.value >= requestMinimum,TMP_70(bool) = now < deadline,TMP_71(bool) = TMP_69 && TMP_70,TMP_72(bool) = now > round1,TMP_73(bool) = TMP_71 && TMP_72,TMP_74(bool) = now < round2,TMP_75(bool) = TMP_73 && TMP_74,CONDITION TMP_75,TMP_76(bool) = msg.value >= bonusCond2,TMP_77(bool) = msg.value < bonusCond3,TMP_78(bool) = TMP_76 && TMP_77,CONDITION TMP_78,TMP_79(uint256) = tokens * 2,TMP_80(uint256) = TMP_79 / 100,countbonus(uint256) := TMP_80(uint256),TMP_81(bool) = msg.value >= bonusCond3,CONDITION TMP_81,TMP_82(uint256) = tokens * 3,TMP_83(uint256) = TMP_82 / 100,countbonus(uint256) := TMP_83(uint256),countbonus(uint256) := 0(uint256),TMP_84(uint256) = tokens + countbonus,bonus(uint256) := TMP_84(uint256),TMP_85(bool) = tokens == 0,CONDITION TMP_85,valdrop(uint256) := 20000000(uint256),REF_12(bool) -> Claimed[investor],TMP_86(bool) = REF_12 == False,TMP_87(bool) = progress0drop <= target0drop,TMP_88(bool) = TMP_86 && TMP_87,CONDITION TMP_88,TMP_89(bool) = INTERNAL_CALL, SmokeCoinV_2.distr(address,uint256)(investor,valdrop),REF_13(bool) -> Claimed[investor],REF_13(bool) (->Claimed) := True(bool),TMP_90(uint256) := progress0drop(uint256),progress0drop(uint256) = progress0drop + 1,TMP_91(bool) = msg.value >= requestMinimum,TMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91),TMP_93(bool) = tokens > 0,TMP_94(bool) = msg.value >= requestMinimum,TMP_95(bool) = TMP_93 && TMP_94,CONDITION TMP_95,TMP_96(bool) = now >= deadline,TMP_97(bool) = now >= round1,TMP_98(bool) = TMP_96 && TMP_97,TMP_99(bool) = now < round2,TMP_100(bool) = TMP_98 && TMP_99,CONDITION TMP_100,TMP_101(bool) = INTERNAL_CALL, SmokeCoinV_2.distr(address,uint256)(investor,tokens),TMP_102(bool) = msg.value >= bonusCond1,CONDITION TMP_102,TMP_103(bool) = INTERNAL_CALL, SmokeCoinV_2.distr(address,uint256)(investor,bonus),TMP_104(bool) = INTERNAL_CALL, SmokeCoinV_2.distr(address,uint256)(investor,tokens),TMP_105(bool) = msg.value >= requestMinimum,TMP_106(None) = SOLIDITY_CALL require(bool)(TMP_105),TMP_107(bool) = totalDistributed >= totalSupply,CONDITION TMP_107,distributionFinished(bool) := True(bool),Transfer dest:multisig value:msg.value,MODIFIER_CALL, SmokeCoinV_2.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->53;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bonusCond1 = 1000000000000000000 / 10

IRs:
TMP_45(uint256) = 1000000000000000000 / 10
bonusCond1(uint256) := TMP_45(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bonusCond2 = 5000000000000000000 / 10

IRs:
TMP_46(uint256) = 5000000000000000000 / 10
bonusCond2(uint256) := TMP_46(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
bonusCond3 = 1000000000000000000

IRs:
bonusCond3(uint256) := 1000000000000000000(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_48(uint256) = TMP_47 / 1000000000000000000
tokens(uint256) := TMP_48(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now < round1 && now < round2

IRs:
TMP_49(bool) = msg.value >= requestMinimum
TMP_50(bool) = now < deadline
TMP_51(bool) = TMP_49 && TMP_50
TMP_52(bool) = now < round1
TMP_53(bool) = TMP_51 && TMP_52
TMP_54(bool) = now < round2
TMP_55(bool) = TMP_53 && TMP_54
CONDITION TMP_55""];
9->10[label=""True""];
9->19[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
msg.value >= bonusCond1 && msg.value < bonusCond2

IRs:
TMP_56(bool) = msg.value >= bonusCond1
TMP_57(bool) = msg.value < bonusCond2
TMP_58(bool) = TMP_56 && TMP_57
CONDITION TMP_58""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
countbonus = tokens * 10 / 100

IRs:
TMP_59(uint256) = tokens * 10
TMP_60(uint256) = TMP_59 / 100
countbonus(uint256) := TMP_60(uint256)""];
11->18;
12[label=""Node Type: IF 12

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_61(bool) = msg.value >= bonusCond2
TMP_62(bool) = msg.value < bonusCond3
TMP_63(bool) = TMP_61 && TMP_62
CONDITION TMP_63""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
countbonus = tokens * 20 / 100

IRs:
TMP_64(uint256) = tokens * 20
TMP_65(uint256) = TMP_64 / 100
countbonus(uint256) := TMP_65(uint256)""];
13->17;
14[label=""Node Type: IF 14

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_66(bool) = msg.value >= bonusCond3
CONDITION TMP_66""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
countbonus = tokens * 35 / 100

IRs:
TMP_67(uint256) = tokens * 35
TMP_68(uint256) = TMP_67 / 100
countbonus(uint256) := TMP_68(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->28;
19[label=""Node Type: IF 19

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now > round1 && now < round2

IRs:
TMP_69(bool) = msg.value >= requestMinimum
TMP_70(bool) = now < deadline
TMP_71(bool) = TMP_69 && TMP_70
TMP_72(bool) = now > round1
TMP_73(bool) = TMP_71 && TMP_72
TMP_74(bool) = now < round2
TMP_75(bool) = TMP_73 && TMP_74
CONDITION TMP_75""];
19->20[label=""True""];
19->26[label=""False""];
20[label=""Node Type: IF 20

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_76(bool) = msg.value >= bonusCond2
TMP_77(bool) = msg.value < bonusCond3
TMP_78(bool) = TMP_76 && TMP_77
CONDITION TMP_78""];
20->21[label=""True""];
20->22[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
countbonus = tokens * 2 / 100

IRs:
TMP_79(uint256) = tokens * 2
TMP_80(uint256) = TMP_79 / 100
countbonus(uint256) := TMP_80(uint256)""];
21->25;
22[label=""Node Type: IF 22

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_81(bool) = msg.value >= bonusCond3
CONDITION TMP_81""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
countbonus = tokens * 3 / 100

IRs:
TMP_82(uint256) = tokens * 3
TMP_83(uint256) = TMP_82 / 100
countbonus(uint256) := TMP_83(uint256)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->27;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
bonus = tokens + countbonus

IRs:
TMP_84(uint256) = tokens + countbonus
bonus(uint256) := TMP_84(uint256)""];
29->30;
30[label=""Node Type: IF 30

EXPRESSION:
tokens == 0

IRs:
TMP_85(bool) = tokens == 0
CONDITION TMP_85""];
30->31[label=""True""];
30->38[label=""False""];
31[label=""Node Type: NEW VARIABLE 31

EXPRESSION:
valdrop = 20000000

IRs:
valdrop(uint256) := 20000000(uint256)""];
31->32;
32[label=""Node Type: IF 32

EXPRESSION:
Claimed[investor] == false && progress0drop <= target0drop

IRs:
REF_12(bool) -> Claimed[investor]
TMP_86(bool) = REF_12 == False
TMP_87(bool) = progress0drop <= target0drop
TMP_88(bool) = TMP_86 && TMP_87
CONDITION TMP_88""];
32->33[label=""True""];
32->36[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
distr(investor,valdrop)

IRs:
TMP_89(bool) = INTERNAL_CALL, SmokeCoinV_2.distr(address,uint256)(investor,valdrop)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
Claimed[investor] = true

IRs:
REF_13(bool) -> Claimed[investor]
REF_13(bool) (->Claimed) := True(bool)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
progress0drop ++

IRs:
TMP_90(uint256) := progress0drop(uint256)
progress0drop(uint256) = progress0drop + 1""];
35->37;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_91(bool) = msg.value >= requestMinimum
TMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91)""];
36->37;
37[label=""Node Type: END_IF 37
""];
37->48;
38[label=""Node Type: IF 38

EXPRESSION:
tokens > 0 && msg.value >= requestMinimum

IRs:
TMP_93(bool) = tokens > 0
TMP_94(bool) = msg.value >= requestMinimum
TMP_95(bool) = TMP_93 && TMP_94
CONDITION TMP_95""];
38->39[label=""True""];
38->46[label=""False""];
39[label=""Node Type: IF 39

EXPRESSION:
now >= deadline && now >= round1 && now < round2

IRs:
TMP_96(bool) = now >= deadline
TMP_97(bool) = now >= round1
TMP_98(bool) = TMP_96 && TMP_97
TMP_99(bool) = now < round2
TMP_100(bool) = TMP_98 && TMP_99
CONDITION TMP_100""];
39->40[label=""True""];
39->41[label=""False""];
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_101(bool) = INTERNAL_CALL, SmokeCoinV_2.distr(address,uint256)(investor,tokens)""];
40->45;
41[label=""Node Type: IF 41

EXPRESSION:
msg.value >= bonusCond1

IRs:
TMP_102(bool) = msg.value >= bonusCond1
CONDITION TMP_102""];
41->42[label=""True""];
41->43[label=""False""];
42[label=""Node Type: EXPRESSION 42

EXPRESSION:
distr(investor,bonus)

IRs:
TMP_103(bool) = INTERNAL_CALL, SmokeCoinV_2.distr(address,uint256)(investor,bonus)""];
42->44;
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_104(bool) = INTERNAL_CALL, SmokeCoinV_2.distr(address,uint256)(investor,tokens)""];
43->44;
44[label=""Node Type: END_IF 44
""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->47;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_105(bool) = msg.value >= requestMinimum
TMP_106(None) = SOLIDITY_CALL require(bool)(TMP_105)""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: IF 49

EXPRESSION:
totalDistributed >= totalSupply

IRs:
TMP_107(bool) = totalDistributed >= totalSupply
CONDITION TMP_107""];
49->50[label=""True""];
49->51[label=""False""];
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
multisig.transfer(msg.value)

IRs:
Transfer dest:multisig value:msg.value""];
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, SmokeCoinV_2.canDistr()()""];
53->1;
}
",0,0,1,0,"canDistr();tokens = 0;bonus = 0;countbonus = 0;bonusCond1 = 1000000000000000000 / 10;bonusCond2 = 5000000000000000000 / 10;bonusCond3 = 1000000000000000000;tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;investor = msg.sender;msg.value >= requestMinimum && now < deadline && now < round1 && now < round2;msg.value >= bonusCond1 && msg.value < bonusCond2;msg.value >= requestMinimum && now < deadline && now > round1 && now < round2;countbonus = tokens * 10 / 100;msg.value >= bonusCond2 && msg.value < bonusCond3;;countbonus = tokens * 20 / 100;msg.value >= bonusCond3;;countbonus = tokens * 35 / 100;;;msg.value >= bonusCond2 && msg.value < bonusCond3;countbonus = 0;countbonus = tokens * 2 / 100;msg.value >= bonusCond3;;countbonus = tokens * 3 / 100;;;bonus = tokens + countbonus;tokens == 0;valdrop = 20000000;tokens > 0 && msg.value >= requestMinimum;Claimed[investor] == false && progress0drop <= target0drop;distr(investor,valdrop);require(bool)(msg.value >= requestMinimum);Claimed[investor] = true;progress0drop ++;;;now >= deadline && now >= round1 && now < round2;require(bool)(msg.value >= requestMinimum);distr(investor,tokens);msg.value >= bonusCond1;;distr(investor,bonus);distr(investor,tokens);;;totalDistributed >= totalSupply;distributionFinished = true;;multisig.transfer(msg.value)"
./0x403860568bcd726ec403f8a1ca67f374e842f16c_ext.sol,CrowdCoinICO.refund,516,525,"TMP_675(bool) = total_raised >= goal,TMP_676(uint256) = INTERNAL_CALL, CrowdCoinICO.time()(),TMP_677(bool) = TMP_676 < end_time,TMP_678(bool) = TMP_675 || TMP_677,CONDITION TMP_678,TMP_679(None) = SOLIDITY_CALL revert()(),REF_93(uint256) -> funded[msg.sender],amount(uint256) := REF_93(uint256),TMP_680(bool) = amount > 0,CONDITION TMP_680,REF_94(uint256) -> funded[msg.sender],REF_94(uint256) (->funded) := 0(uint256),Transfer dest:msg.sender value:amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
total_raised >= goal || time() < end_time

IRs:
TMP_675(bool) = total_raised >= goal
TMP_676(uint256) = INTERNAL_CALL, CrowdCoinICO.time()()
TMP_677(bool) = TMP_676 < end_time
TMP_678(bool) = TMP_675 || TMP_677
CONDITION TMP_678""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_679(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
amount = funded[msg.sender]

IRs:
REF_93(uint256) -> funded[msg.sender]
amount(uint256) := REF_93(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
amount > 0

IRs:
TMP_680(bool) = amount > 0
CONDITION TMP_680""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
funded[msg.sender] = 0

IRs:
REF_94(uint256) -> funded[msg.sender]
REF_94(uint256) (->funded) := 0(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
7->8;
8[label=""Node Type: END_IF 8
""];
}
",0,0,1,0,total_raised >= goal || time() < end_time;revert()();;amount = funded[msg.sender];amount > 0;funded[msg.sender] = 0;;msg.sender.transfer(amount)
./0x889a32263d237872b4f7985ead9c29ebfe8b464d_ext.sol,CaviarToken.changeOwner,49,57,"TMP_3(bool) = msg.value >= howManyEtherInWeiToBecomeOwner,CONDITION TMP_3,Transfer dest:owner value:msg.value,REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:owner value:REF_3,owner(address) := _newowner(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value >= howManyEtherInWeiToBecomeOwner

IRs:
TMP_3(bool) = msg.value >= howManyEtherInWeiToBecomeOwner
CONDITION TMP_3""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(msg.value)

IRs:
Transfer dest:owner value:msg.value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:owner value:REF_3""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
owner = _newowner

IRs:
owner(address) := _newowner(address)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,0,1,0,msg.value >= howManyEtherInWeiToBecomeOwner;owner.transfer(msg.value);;owner.transfer(this.balance);owner = _newowner
./0x887e1988f7d697df22aea1207a5e1831ad3065ef_ext.sol,Manageable.payout,108,114,"TMP_31 = CONVERT 0 to address,TMP_32(bool) = _to == TMP_31,CONDITION TMP_32,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:owner value:REF_1,REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:_to value:REF_3,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_to == address(0)

IRs:
TMP_31 = CONVERT 0 to address
TMP_32(bool) = _to == TMP_31
CONDITION TMP_32""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:owner value:REF_1""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_to.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:_to value:REF_3""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_to == address(0);owner.transfer(this.balance);_to.transfer(this.balance);
./0xa1d38ef843553322a338cdd7d6134565ffba97ab_ext.sol,LEVT.withdraw,269,272,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, LEVT.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, LEVT.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x1fdedef5c2da1ed9db44d80003a9592dfa18163c_ext.sol,Syndicate.claimPlayerWinnings,127,134,"REF_21(Syndicate.somePlayer) -> allPlayers[msg.sender],REF_22(uint256) -> REF_21.winnings,TMP_23(bool) = REF_22 == 0,CONDITION TMP_23,TMP_24(None) = SOLIDITY_CALL revert()(),REF_23(Syndicate.somePlayer) -> allPlayers[msg.sender],REF_24(uint256) -> REF_23.winnings,winnings(uint256) := REF_24(uint256),TMP_25(bool) = winnings > 0,CONDITION TMP_25,REF_25(Syndicate.somePlayer) -> allPlayers[msg.sender],REF_26(uint256) -> REF_25.winnings,REF_26(uint256) (->allPlayers) := 0(uint256),Transfer dest:msg.sender value:winnings","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
allPlayers[msg.sender].winnings == 0

IRs:
REF_21(Syndicate.somePlayer) -> allPlayers[msg.sender]
REF_22(uint256) -> REF_21.winnings
TMP_23(bool) = REF_22 == 0
CONDITION TMP_23""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_24(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
winnings = allPlayers[msg.sender].winnings

IRs:
REF_23(Syndicate.somePlayer) -> allPlayers[msg.sender]
REF_24(uint256) -> REF_23.winnings
winnings(uint256) := REF_24(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
winnings > 0

IRs:
TMP_25(bool) = winnings > 0
CONDITION TMP_25""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allPlayers[msg.sender].winnings = 0

IRs:
REF_25(Syndicate.somePlayer) -> allPlayers[msg.sender]
REF_26(uint256) -> REF_25.winnings
REF_26(uint256) (->allPlayers) := 0(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
msg.sender.transfer(winnings)

IRs:
Transfer dest:msg.sender value:winnings""];
7->8;
8[label=""Node Type: END_IF 8
""];
}
",0,0,1,0,allPlayers[msg.sender].winnings == 0;revert()();;winnings = allPlayers[msg.sender].winnings;winnings > 0;allPlayers[msg.sender].winnings = 0;;msg.sender.transfer(winnings)
./0xa2e59b1c5e64130d06f08a99cd5eda8af9c68b8a_ext.sol,Broker.claimBrokerFee,235,241,"REF_28(uint256) -> BrokerIncoming[msg.sender],fee(uint256) := REF_28(uint256),TMP_203(bool) = fee > 0,TMP_204(None) = SOLIDITY_CALL require(bool)(TMP_203),Transfer dest:msg.sender value:fee,REF_30(uint256) -> BrokerIncoming[msg.sender],REF_30(uint256) (->BrokerIncoming) := 0(uint256),Emit BrokerFeeClaim(msg.sender,fee),MODIFIER_CALL, Administration.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
fee = BrokerIncoming[msg.sender]

IRs:
REF_28(uint256) -> BrokerIncoming[msg.sender]
fee(uint256) := REF_28(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(fee > 0)

IRs:
TMP_203(bool) = fee > 0
TMP_204(None) = SOLIDITY_CALL require(bool)(TMP_203)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(fee)

IRs:
Transfer dest:msg.sender value:fee""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
BrokerIncoming[msg.sender] = 0

IRs:
REF_30(uint256) -> BrokerIncoming[msg.sender]
REF_30(uint256) (->BrokerIncoming) := 0(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
BrokerFeeClaim(msg.sender,fee)

IRs:
Emit BrokerFeeClaim(msg.sender,fee)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Administration.whenNotPaused()()""];
6->1;
}
",0,0,1,0,"whenNotPaused();fee = BrokerIncoming[msg.sender];require(bool)(fee > 0);msg.sender.transfer(fee);BrokerIncoming[msg.sender] = 0;BrokerFeeClaim(msg.sender,fee)"
./0x4cdee773fd90f91e98b7d33db5c12376deee3b08_ext.sol,NEBC.safeWithdrawal,304,309,"TMP_97(bool) = _value == 0,CONDITION TMP_97,TMP_98 = CONVERT this to address,TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98),Transfer dest:owner value:TMP_99,Transfer dest:owner value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_97(bool) = _value == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_98 = CONVERT this to address
TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98)
Transfer dest:owner value:TMP_99""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_value == 0;owner.transfer(address(this).balance);owner.transfer(_value);
./0x1a7208627ffe43a69f13f3c393a41712fa4a7831_ext.sol,AccessService.withdraw,107,119,"TMP_37(bool) = msg.sender == addrFinance,TMP_38(bool) = msg.sender == addrAdmin,TMP_39(bool) = TMP_37 || TMP_38,TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39),TMP_41(bool) = _amount > 0,TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41),REF_0(uint256) = SOLIDITY_CALL balance(address)(this),balance(uint256) := REF_0([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B6E65490>]),TMP_43(bool) = _amount < balance,CONDITION TMP_43,Transfer dest:receiver value:_amount,REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:receiver value:REF_3,TMP_46 = CONVERT 0 to address,TMP_47(bool) = _target == TMP_46,CONDITION TMP_47,receiver(address) := addrFinance(address),receiver(address) := _target(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == addrFinance || msg.sender == addrAdmin)

IRs:
TMP_37(bool) = msg.sender == addrFinance
TMP_38(bool) = msg.sender == addrAdmin
TMP_39(bool) = TMP_37 || TMP_38
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amount > 0)

IRs:
TMP_41(bool) = _amount > 0
TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)""];
2->9;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
balance = this.balance

IRs:
REF_0(uint256) = SOLIDITY_CALL balance(address)(this)
balance(uint256) := REF_0([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B6E65490>])""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
_amount < balance

IRs:
TMP_43(bool) = _amount < balance
CONDITION TMP_43""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
receiver.transfer(_amount)

IRs:
Transfer dest:receiver value:_amount""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
receiver.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:receiver value:REF_3""];
7->8;
8[label=""Node Type: END_IF 8
""];
9[label=""Node Type: IF 9

EXPRESSION:
_target == address(0)

IRs:
TMP_46 = CONVERT 0 to address
TMP_47(bool) = _target == TMP_46
CONDITION TMP_47""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
receiver = addrFinance

IRs:
receiver(address) := addrFinance(address)""];
10->12;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
receiver = _target

IRs:
receiver(address) := _target(address)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->4;
}
",0,0,1,0,require(bool)(msg.sender == addrFinance || msg.sender == addrAdmin);require(bool)(_amount > 0);_target == address(0);balance = this.balance;_amount < balance;receiver.transfer(_amount);receiver.transfer(this.balance);;receiver = addrFinance;receiver = _target;
./0xd6aca5b766853f7879d153fdb7567be356dd46ec_ext.sol,ExeniumToken.withdrawAmount,685,701,"wallet(address) := owner(address),CONDITION acceptAdminWithdraw,wallet(address) := msg.sender(address),TMP_657 = CONVERT this to address,TMP_658(uint256) = SOLIDITY_CALL balance(address)(TMP_657),Emit Withdraw(msg.sender,wallet,TMP_658),TMP_660 = CONVERT this to address,TMP_661(uint256) = SOLIDITY_CALL balance(address)(TMP_660),Transfer dest:wallet value:TMP_661,RETURN True,REF_318(Authorizable.Level) -> Level.ADMIN,MODIFIER_CALL, Authorizable.authLevel(Authorizable.Level)(REF_318),TMP_664 = CONVERT this to address,TMP_665(uint256) = SOLIDITY_CALL balance(address)(TMP_664),MODIFIER_CALL, Utils.greaterThanZero(uint256)(TMP_665),MODIFIER_CALL, Utils.greaterThanZero(uint256)(_amount),MODIFIER_CALL, Utils.validBalanceThis(uint256)(_amount),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wallet = owner

IRs:
wallet(address) := owner(address)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
acceptAdminWithdraw

IRs:
CONDITION acceptAdminWithdraw""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
wallet = msg.sender

IRs:
wallet(address) := msg.sender(address)""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Withdraw(msg.sender,wallet,address(this).balance)

IRs:
TMP_657 = CONVERT this to address
TMP_658(uint256) = SOLIDITY_CALL balance(address)(TMP_657)
Emit Withdraw(msg.sender,wallet,TMP_658)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
wallet.transfer(address(this).balance)

IRs:
TMP_660 = CONVERT this to address
TMP_661(uint256) = SOLIDITY_CALL balance(address)(TMP_660)
Transfer dest:wallet value:TMP_661""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
authLevel(Level.ADMIN)

IRs:
REF_318(Authorizable.Level) -> Level.ADMIN
MODIFIER_CALL, Authorizable.authLevel(Authorizable.Level)(REF_318)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
greaterThanZero(address(this).balance)

IRs:
TMP_664 = CONVERT this to address
TMP_665(uint256) = SOLIDITY_CALL balance(address)(TMP_664)
MODIFIER_CALL, Utils.greaterThanZero(uint256)(TMP_665)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
greaterThanZero(_amount)

IRs:
MODIFIER_CALL, Utils.greaterThanZero(uint256)(_amount)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
validBalanceThis(_amount)

IRs:
MODIFIER_CALL, Utils.validBalanceThis(uint256)(_amount)""];
11->1;
12[label=""Node Type: RETURN 12

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,0,1,0,"authLevel(Level.ADMIN);wallet = owner;acceptAdminWithdraw;wallet = msg.sender;;Withdraw(msg.sender,wallet,address(this).balance);wallet.transfer(address(this).balance);true;greaterThanZero(address(this).balance);greaterThanZero(_amount);validBalanceThis(_amount);success"
./0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06_ext.sol,ClockAuction.withdrawBalance,999,1003,"TMP_771 = CONVERT nonFungibleContract to address,nftAddress(address) := TMP_771(address),TMP_772(bool) = msg.sender == owner,TMP_773(bool) = msg.sender == nftAddress,TMP_774(bool) = TMP_772 || TMP_773,TMP_775(None) = SOLIDITY_CALL require(bool)(TMP_774),TMP_776 = CONVERT this to address,TMP_777(uint256) = SOLIDITY_CALL balance(address)(TMP_776),Transfer dest:owner value:TMP_777","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
nftAddress = address(nonFungibleContract)

IRs:
TMP_771 = CONVERT nonFungibleContract to address
nftAddress(address) := TMP_771(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == owner || msg.sender == nftAddress)

IRs:
TMP_772(bool) = msg.sender == owner
TMP_773(bool) = msg.sender == nftAddress
TMP_774(bool) = TMP_772 || TMP_773
TMP_775(None) = SOLIDITY_CALL require(bool)(TMP_774)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_776 = CONVERT this to address
TMP_777(uint256) = SOLIDITY_CALL balance(address)(TMP_776)
Transfer dest:owner value:TMP_777""];
}
",0,0,1,0,nftAddress = address(nonFungibleContract);require(bool)(msg.sender == owner || msg.sender == nftAddress);owner.transfer(address(this).balance)
./0x6c940a8d477922f1cffe012449321098e06db3f7_ext.sol,CryptoGain.withdraw,147,152,"REF_31(uint256) -> balances[msg.sender],TMP_52(bool) = REF_31 > 0,TMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52),REF_32(uint256) -> balances[msg.sender],amount(uint256) := REF_32(uint256),REF_33(uint256) -> balances[msg.sender],REF_33(uint256) (->balances) := 0(uint256),Transfer dest:msg.sender value:amount,MODIFIER_CALL, CryptoGain.onlyAlive()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(balances[msg.sender] > 0)

IRs:
REF_31(uint256) -> balances[msg.sender]
TMP_52(bool) = REF_31 > 0
TMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = balances[msg.sender]

IRs:
REF_32(uint256) -> balances[msg.sender]
amount(uint256) := REF_32(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = 0

IRs:
REF_33(uint256) -> balances[msg.sender]
REF_33(uint256) (->balances) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyAlive()

IRs:
MODIFIER_CALL, CryptoGain.onlyAlive()()""];
5->1;
}
",0,0,1,0,onlyAlive();require(bool)(balances[msg.sender] > 0);amount = balances[msg.sender];balances[msg.sender] = 0;msg.sender.transfer(amount)
./0x1fe3825a3012e581843a483df1452fc2fa4f0bad_ext.sol,JcashRegistrar.transferEth,964,988,"TMP_379 = CONVERT 0 to bytes32,TMP_380(bool) = _txHash != TMP_379,TMP_381(None) = SOLIDITY_CALL require(bool)(TMP_380),REF_56(bool) -> processedTxs[_txHash],TMP_382(bool) = REF_56 == False,TMP_383(None) = SOLIDITY_CALL require(bool)(TMP_382),TMP_384 = CONVERT 0 to address,TMP_385(bool) = _to != TMP_384,TMP_386(None) = SOLIDITY_CALL require(bool)(TMP_385),TMP_387 = CONVERT this to address,TMP_388(bool) = _to != TMP_387,TMP_389(None) = SOLIDITY_CALL require(bool)(TMP_388),TMP_390(bool) = _weivalue > 0,TMP_391(None) = SOLIDITY_CALL require(bool)(TMP_390),REF_57(bool) -> processedTxs[_txHash],REF_57(bool) (->processedTxs) := True(bool),Transfer dest:_to value:_weivalue,TMP_393(uint256) = INTERNAL_CALL, JNTPayableService.getActionPrice(string)(transfer_eth),TMP_394(bool) = TMP_393 > 0,CONDITION TMP_394,INTERNAL_CALL, JNTPayableService.initChargeJNT(address,string)(_to,transfer_eth),Emit TransferEthEvent(_txHash,_to,_weivalue),MODIFIER_CALL, ManageableInterface.onlyAllowedManager(string)(transfer_eth),MODIFIER_CALL, PausableInterface.whenContractNotPaused()(),TMP_399(uint256) = 3 * 32,MODIFIER_CALL, JcashRegistrar.onlyPayloadSize(uint256)(TMP_399)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_txHash != bytes32(0))

IRs:
TMP_379 = CONVERT 0 to bytes32
TMP_380(bool) = _txHash != TMP_379
TMP_381(None) = SOLIDITY_CALL require(bool)(TMP_380)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(processedTxs[_txHash] == false)

IRs:
REF_56(bool) -> processedTxs[_txHash]
TMP_382(bool) = REF_56 == False
TMP_383(None) = SOLIDITY_CALL require(bool)(TMP_382)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_to != address(0x0))

IRs:
TMP_384 = CONVERT 0 to address
TMP_385(bool) = _to != TMP_384
TMP_386(None) = SOLIDITY_CALL require(bool)(TMP_385)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_to != address(this))

IRs:
TMP_387 = CONVERT this to address
TMP_388(bool) = _to != TMP_387
TMP_389(None) = SOLIDITY_CALL require(bool)(TMP_388)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(_weivalue > 0)

IRs:
TMP_390(bool) = _weivalue > 0
TMP_391(None) = SOLIDITY_CALL require(bool)(TMP_390)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
processedTxs[_txHash] = true

IRs:
REF_57(bool) -> processedTxs[_txHash]
REF_57(bool) (->processedTxs) := True(bool)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
_to.transfer(_weivalue)

IRs:
Transfer dest:_to value:_weivalue""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
getActionPrice(transfer_eth) > 0

IRs:
TMP_393(uint256) = INTERNAL_CALL, JNTPayableService.getActionPrice(string)(transfer_eth)
TMP_394(bool) = TMP_393 > 0
CONDITION TMP_394""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
initChargeJNT(_to,transfer_eth)

IRs:
INTERNAL_CALL, JNTPayableService.initChargeJNT(address,string)(_to,transfer_eth)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
TransferEthEvent(_txHash,_to,_weivalue)

IRs:
Emit TransferEthEvent(_txHash,_to,_weivalue)""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyAllowedManager(transfer_eth)

IRs:
MODIFIER_CALL, ManageableInterface.onlyAllowedManager(string)(transfer_eth)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
whenContractNotPaused()

IRs:
MODIFIER_CALL, PausableInterface.whenContractNotPaused()()""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
onlyPayloadSize(3 * 32)

IRs:
TMP_399(uint256) = 3 * 32
MODIFIER_CALL, JcashRegistrar.onlyPayloadSize(uint256)(TMP_399)""];
14->1;
}
",0,0,1,0,"onlyAllowedManager(transfer_eth);require(bool)(_txHash != bytes32(0));require(bool)(processedTxs[_txHash] == false);require(bool)(_to != address(0x0));require(bool)(_to != address(this));require(bool)(_weivalue > 0);processedTxs[_txHash] = true;_to.transfer(_weivalue);getActionPrice(transfer_eth) > 0;initChargeJNT(_to,transfer_eth);;TransferEthEvent(_txHash,_to,_weivalue);whenContractNotPaused();onlyPayloadSize(3 * 32)"
./0x2d92102bf50c111d59b93f7a10bafd13e770ed61_ext.sol,Ownable.kill,62,64,"TMP_9(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_9(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0x93143d3e34a50aebab466368c3455fd858f77ad3_ext.sol,FourOutOfFive.withdrawOwnerMaxPossibleSafe,152,155,"Transfer dest:owner value:maxPossibleWithdraw,maxPossibleWithdraw(uint256) := 0(uint256),MODIFIER_CALL, FourOutOfFive.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(maxPossibleWithdraw)

IRs:
Transfer dest:owner value:maxPossibleWithdraw""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
maxPossibleWithdraw = 0

IRs:
maxPossibleWithdraw(uint256) := 0(uint256)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, FourOutOfFive.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();owner.transfer(maxPossibleWithdraw);maxPossibleWithdraw = 0
./0x035611f47a13f3603109152952f0034c674959ba_ext.sol,ReservationFund.refundPayment,224,235,"TMP_68(None) = SOLIDITY_CALL require(bool)(crowdsaleFinished),REF_19(uint256) -> contributions[contributor],TMP_69(bool) = REF_19 > 0,REF_20(uint256) -> tokensToIssue[contributor],TMP_70(bool) = REF_20 > 0,TMP_71(bool) = TMP_69 || TMP_70,TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71),REF_21(uint256) -> contributions[contributor],amountToRefund(uint256) := REF_21(uint256),REF_22(uint256) -> contributions[contributor],REF_22(uint256) (->contributions) := 0(uint256),REF_23(uint256) -> tokensToIssue[contributor],REF_23(uint256) (->tokensToIssue) := 0(uint256),REF_24(uint256) -> bonusTokensToIssue[contributor],REF_24(uint256) (->bonusTokensToIssue) := 0(uint256),Transfer dest:contributor value:amountToRefund,Emit RefundPayment(contributor,amountToRefund)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(crowdsaleFinished)

IRs:
TMP_68(None) = SOLIDITY_CALL require(bool)(crowdsaleFinished)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(contributions[contributor] > 0 || tokensToIssue[contributor] > 0)

IRs:
REF_19(uint256) -> contributions[contributor]
TMP_69(bool) = REF_19 > 0
REF_20(uint256) -> tokensToIssue[contributor]
TMP_70(bool) = REF_20 > 0
TMP_71(bool) = TMP_69 || TMP_70
TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
amountToRefund = contributions[contributor]

IRs:
REF_21(uint256) -> contributions[contributor]
amountToRefund(uint256) := REF_21(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
contributions[contributor] = 0

IRs:
REF_22(uint256) -> contributions[contributor]
REF_22(uint256) (->contributions) := 0(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
tokensToIssue[contributor] = 0

IRs:
REF_23(uint256) -> tokensToIssue[contributor]
REF_23(uint256) (->tokensToIssue) := 0(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
bonusTokensToIssue[contributor] = 0

IRs:
REF_24(uint256) -> bonusTokensToIssue[contributor]
REF_24(uint256) (->bonusTokensToIssue) := 0(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
contributor.transfer(amountToRefund)

IRs:
Transfer dest:contributor value:amountToRefund""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
RefundPayment(contributor,amountToRefund)

IRs:
Emit RefundPayment(contributor,amountToRefund)""];
}
",0,0,1,0,"require(bool)(crowdsaleFinished);require(bool)(contributions[contributor] > 0 || tokensToIssue[contributor] > 0);amountToRefund = contributions[contributor];contributions[contributor] = 0;tokensToIssue[contributor] = 0;bonusTokensToIssue[contributor] = 0;contributor.transfer(amountToRefund);RefundPayment(contributor,amountToRefund)"
./0x33dcb440beb0c640fa75ac297bc2e048e6853844_ext.sol,Bonds.withdraw,269,280,"_customerAddress(address) := msg.sender(address),REF_106(uint256) -> ownerAccounts[_customerAddress],TMP_58(bool) = REF_106 > 0,TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58),REF_107(uint256) -> ownerAccounts[_customerAddress],_dividends(uint256) := REF_107(uint256),REF_108(uint256) -> ownerAccounts[_customerAddress],REF_108(uint256) (->ownerAccounts) := 0(uint256),Transfer dest:_customerAddress value:_dividends,Emit onWithdraw(_customerAddress,_dividends)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(ownerAccounts[_customerAddress] > 0)

IRs:
REF_106(uint256) -> ownerAccounts[_customerAddress]
TMP_58(bool) = REF_106 > 0
TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
_dividends = ownerAccounts[_customerAddress]

IRs:
REF_107(uint256) -> ownerAccounts[_customerAddress]
_dividends(uint256) := REF_107(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownerAccounts[_customerAddress] = 0

IRs:
REF_108(uint256) -> ownerAccounts[_customerAddress]
REF_108(uint256) (->ownerAccounts) := 0(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_customerAddress.transfer(_dividends)

IRs:
Transfer dest:_customerAddress value:_dividends""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onWithdraw(_customerAddress,_dividends)

IRs:
Emit onWithdraw(_customerAddress,_dividends)""];
}
",0,0,1,0,"_customerAddress = msg.sender;require(bool)(ownerAccounts[_customerAddress] > 0);_dividends = ownerAccounts[_customerAddress];ownerAccounts[_customerAddress] = 0;_customerAddress.transfer(_dividends);onWithdraw(_customerAddress,_dividends)"
./0x410526cd583af0be0530166d53efcd7da969f7b7_ext.sol,PlayerBook.registerNameCore,439,463,"REF_48(uint256) -> pIDxName_[_name],TMP_116(bool) = REF_48 != 0,CONDITION TMP_116,REF_49(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_50(bool) -> REF_49[_name],TMP_117(bool) = REF_50 == True,TMP_118(None) = SOLIDITY_CALL require(bool,string)(TMP_117,That names already taken),REF_51(PlayerBook.Player) -> plyr_[_pID],REF_52(bytes32) -> REF_51.name,REF_52(bytes32) (->plyr_) := _name(bytes32),REF_53(uint256) -> pIDxName_[_name],REF_53(uint256) (->pIDxName_) := _pID(uint256),REF_54(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_55(bool) -> REF_54[_name],TMP_119(bool) = REF_55 == False,CONDITION TMP_119,REF_56(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_57(bool) -> REF_56[_name],REF_57(bool) (->plyrNames_) := True(bool),REF_58(PlayerBook.Player) -> plyr_[_pID],REF_59(uint256) -> REF_58.names,TMP_120(uint256) := REF_59(uint256),REF_59(-> plyr_) = REF_59 + 1,REF_60(mapping(uint256 => bytes32)) -> plyrNameList_[_pID],REF_61(PlayerBook.Player) -> plyr_[_pID],REF_62(uint256) -> REF_61.names,REF_63(bytes32) -> REF_60[REF_62],REF_63(bytes32) (->plyrNameList_) := _name(bytes32),TMP_121 = CONVERT this to address,TMP_122(uint256) = SOLIDITY_CALL balance(address)(TMP_121),TMP_123(bool) = TMP_122 > 0,CONDITION TMP_123,TMP_124 = CONVERT communityAddr to address,TMP_125 = CONVERT 0 to address,TMP_126(bool) = TMP_124 != TMP_125,CONDITION TMP_126,TMP_127 = CONVERT this to address,TMP_128(uint256) = SOLIDITY_CALL balance(address)(TMP_127),Transfer dest:communityAddr value:TMP_128,TMP_130(bool) = _all == True,CONDITION TMP_130,i(uint256) := 1(uint256),TMP_131(bool) = i <= gID_,CONDITION TMP_131,REF_65(PlayerBookReceiverInterface) -> games_[i],HIGH_LEVEL_CALL, dest:REF_65(PlayerBookReceiverInterface), function:receivePlayerInfo, arguments:['_pID', '_addr', '_name', '_affID']  ,TMP_133(uint256) := i(uint256),i(uint256) = i + 1,REF_67(PlayerBook.Player) -> plyr_[_affID],REF_68(address) -> REF_67.addr,REF_69(PlayerBook.Player) -> plyr_[_affID],REF_70(bytes32) -> REF_69.name,Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_68,REF_70,msg.value,now)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
pIDxName_[_name] != 0

IRs:
REF_48(uint256) -> pIDxName_[_name]
TMP_116(bool) = REF_48 != 0
CONDITION TMP_116""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(plyrNames_[_pID][_name] == true,That names already taken)

IRs:
REF_49(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_50(bool) -> REF_49[_name]
TMP_117(bool) = REF_50 == True
TMP_118(None) = SOLIDITY_CALL require(bool,string)(TMP_117,That names already taken)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
plyr_[_pID].name = _name

IRs:
REF_51(PlayerBook.Player) -> plyr_[_pID]
REF_52(bytes32) -> REF_51.name
REF_52(bytes32) (->plyr_) := _name(bytes32)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
pIDxName_[_name] = _pID

IRs:
REF_53(uint256) -> pIDxName_[_name]
REF_53(uint256) (->pIDxName_) := _pID(uint256)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
plyrNames_[_pID][_name] == false

IRs:
REF_54(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_55(bool) -> REF_54[_name]
TMP_119(bool) = REF_55 == False
CONDITION TMP_119""];
6->7[label=""True""];
6->10[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
plyrNames_[_pID][_name] = true

IRs:
REF_56(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_57(bool) -> REF_56[_name]
REF_57(bool) (->plyrNames_) := True(bool)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
plyr_[_pID].names ++

IRs:
REF_58(PlayerBook.Player) -> plyr_[_pID]
REF_59(uint256) -> REF_58.names
TMP_120(uint256) := REF_59(uint256)
REF_59(-> plyr_) = REF_59 + 1""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
plyrNameList_[_pID][plyr_[_pID].names] = _name

IRs:
REF_60(mapping(uint256 => bytes32)) -> plyrNameList_[_pID]
REF_61(PlayerBook.Player) -> plyr_[_pID]
REF_62(uint256) -> REF_61.names
REF_63(bytes32) -> REF_60[REF_62]
REF_63(bytes32) (->plyrNameList_) := _name(bytes32)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
address(this).balance > 0

IRs:
TMP_121 = CONVERT this to address
TMP_122(uint256) = SOLIDITY_CALL balance(address)(TMP_121)
TMP_123(bool) = TMP_122 > 0
CONDITION TMP_123""];
11->12[label=""True""];
11->15[label=""False""];
12[label=""Node Type: IF 12

EXPRESSION:
address(communityAddr) != address(0x0)

IRs:
TMP_124 = CONVERT communityAddr to address
TMP_125 = CONVERT 0 to address
TMP_126(bool) = TMP_124 != TMP_125
CONDITION TMP_126""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
communityAddr.transfer(address(this).balance)

IRs:
TMP_127 = CONVERT this to address
TMP_128(uint256) = SOLIDITY_CALL balance(address)(TMP_127)
Transfer dest:communityAddr value:TMP_128""];
13->14;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: IF 16

EXPRESSION:
_all == true

IRs:
TMP_130(bool) = _all == True
CONDITION TMP_130""];
16->19[label=""True""];
16->23[label=""False""];
17[label=""Node Type: BEGIN_LOOP 17
""];
17->20;
18[label=""Node Type: END_LOOP 18
""];
18->23;
19[label=""Node Type: NEW VARIABLE 19

EXPRESSION:
i = 1

IRs:
i(uint256) := 1(uint256)""];
19->17;
20[label=""Node Type: IF_LOOP 20

EXPRESSION:
i <= gID_

IRs:
TMP_131(bool) = i <= gID_
CONDITION TMP_131""];
20->21[label=""True""];
20->18[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
games_[i].receivePlayerInfo(_pID,_addr,_name,_affID)

IRs:
REF_65(PlayerBookReceiverInterface) -> games_[i]
HIGH_LEVEL_CALL, dest:REF_65(PlayerBookReceiverInterface), function:receivePlayerInfo, arguments:['_pID', '_addr', '_name', '_affID']  ""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
i ++

IRs:
TMP_133(uint256) := i(uint256)
i(uint256) = i + 1""];
22->20;
23[label=""Node Type: END_IF 23
""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,msg.value,now)

IRs:
REF_67(PlayerBook.Player) -> plyr_[_affID]
REF_68(address) -> REF_67.addr
REF_69(PlayerBook.Player) -> plyr_[_affID]
REF_70(bytes32) -> REF_69.name
Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_68,REF_70,msg.value,now)""];
}
",0,0,1,0,"pIDxName_[_name] != 0;require(bool,string)(plyrNames_[_pID][_name] == true,That names already taken);;plyr_[_pID].name = _name;pIDxName_[_name] = _pID;plyrNames_[_pID][_name] == false;plyrNames_[_pID][_name] = true;;plyr_[_pID].names ++;plyrNameList_[_pID][plyr_[_pID].names] = _name;address(this).balance > 0;address(communityAddr) != address(0x0);;communityAddr.transfer(address(this).balance);;_all == true;i = 1;;;i <= gID_;;games_[i].receivePlayerInfo(_pID,_addr,_name,_affID);i ++;onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,msg.value,now)"
./0x52b5a68d069a6c9b2f36f279e9d936557fe8d29c_ext.sol,BridgeX_Network.withdrawAll,288,292,"myAddress(address) := this(address),TMP_138(uint256) = SOLIDITY_CALL balance(address)(myAddress),etherBalance(uint256) := TMP_138(uint256),Transfer dest:owner value:etherBalance,MODIFIER_CALL, BridgeX_Network.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
myAddress = this

IRs:
myAddress(address) := this(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
etherBalance = myAddress.balance

IRs:
TMP_138(uint256) = SOLIDITY_CALL balance(address)(myAddress)
etherBalance(uint256) := TMP_138(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(etherBalance)

IRs:
Transfer dest:owner value:etherBalance""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, BridgeX_Network.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();myAddress = this;etherBalance = myAddress.balance;owner.transfer(etherBalance)
./0xd359e3f53b5d4e11b8b11dc0772448f380accf3c_ext.sol,Manageable.payout,108,114,"TMP_31 = CONVERT 0 to address,TMP_32(bool) = _to == TMP_31,CONDITION TMP_32,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:owner value:REF_1,REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:_to value:REF_3,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_to == address(0)

IRs:
TMP_31 = CONVERT 0 to address
TMP_32(bool) = _to == TMP_31
CONDITION TMP_32""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:owner value:REF_1""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_to.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:_to value:REF_3""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_to == address(0);owner.transfer(this.balance);_to.transfer(this.balance);
./0xd74186459dd2e4aaff9330129ba68331761f38ae_ext.sol,alfa_QUIZ.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x000621424c60951cb69e9d75d64b79813846d498_ext.sol,HasNoEther.reclaimEther,101,103,"REF_1(uint256) = SOLIDITY_CALL balance(address)(this),TMP_32 = SEND dest:owner value:REF_1,TMP_33(None) = SOLIDITY_CALL assert(bool)(TMP_32),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(owner.send(this.balance))

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_32 = SEND dest:owner value:REF_1
TMP_33(None) = SOLIDITY_CALL assert(bool)(TMP_32)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();assert(bool)(owner.send(this.balance))
./0x46cefba4dd7512b2449e1ac4b730bfb7f77d1407_ext.sol,DecentralizedExchangeHotPotato.withdrawAll,50,52,"TMP_3 = CONVERT this to address,TMP_4(uint256) = SOLIDITY_CALL balance(address)(TMP_3),Transfer dest:msg.sender value:TMP_4,MODIFIER_CALL, DecentralizedExchangeHotPotato.onlyAdmins()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_3 = CONVERT this to address
TMP_4(uint256) = SOLIDITY_CALL balance(address)(TMP_3)
Transfer dest:msg.sender value:TMP_4""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyAdmins()

IRs:
MODIFIER_CALL, DecentralizedExchangeHotPotato.onlyAdmins()()""];
2->1;
}
",0,0,1,0,onlyAdmins();msg.sender.transfer(address(this).balance)
./0x6bd33d49d48f76abcd96652e5347e398aa3fda96_ext.sol,BancorBuyer.withdraw,42,49,"REF_0(uint256) -> balances[msg.sender],amount(uint256) := REF_0(uint256),REF_1(uint256) -> balances[msg.sender],REF_1(uint256) (->balances) := 0(uint256),Transfer dest:msg.sender value:amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
amount = balances[msg.sender]

IRs:
REF_0(uint256) -> balances[msg.sender]
amount(uint256) := REF_0(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balances[msg.sender] = 0

IRs:
REF_1(uint256) -> balances[msg.sender]
REF_1(uint256) (->balances) := 0(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
}
",0,0,1,0,amount = balances[msg.sender];balances[msg.sender] = 0;msg.sender.transfer(amount)
./0xd2df59cfcd5086264532936afde48a5312ce96bb_ext.sol,Auction.placeBid,184,202,"TMP_42(bool) = block.timestamp > _start,TMP_43(None) = SOLIDITY_CALL require(bool,string)(TMP_42,Auction not started),TMP_44(bool) = block.timestamp < _end,TMP_45(None) = SOLIDITY_CALL require(bool,string)(TMP_44,Auction ended),TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_highestBid', '_minStep'] ,TMP_47(bool) = msg.value >= TMP_46,TMP_48(None) = SOLIDITY_CALL require(bool,string)(TMP_47,Amount too low),_payout(uint256) := _highestBid(uint256),_highestBid(uint256) := msg.value(uint256),_oldHighestBidder(address) := _highestBidder(address),_highestBidder(address) := msg.sender(address),TMP_49 = SEND dest:_oldHighestBidder value:_payout,TMP_50(bool) = TMP_49 == True,CONDITION TMP_50,Emit etherTransfered(_payout,_oldHighestBidder),Emit bidPlaced(_highestBid,_highestBidder),RETURN True","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(block.timestamp > _start,Auction not started)

IRs:
TMP_42(bool) = block.timestamp > _start
TMP_43(None) = SOLIDITY_CALL require(bool,string)(TMP_42,Auction not started)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(block.timestamp < _end,Auction ended)

IRs:
TMP_44(bool) = block.timestamp < _end
TMP_45(None) = SOLIDITY_CALL require(bool,string)(TMP_44,Auction ended)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool,string)(msg.value >= _highestBid.add(_minStep),Amount too low)

IRs:
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_highestBid', '_minStep'] 
TMP_47(bool) = msg.value >= TMP_46
TMP_48(None) = SOLIDITY_CALL require(bool,string)(TMP_47,Amount too low)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
_payout = _highestBid

IRs:
_payout(uint256) := _highestBid(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_highestBid = msg.value

IRs:
_highestBid(uint256) := msg.value(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
_oldHighestBidder = _highestBidder

IRs:
_oldHighestBidder(address) := _highestBidder(address)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
_highestBidder = msg.sender

IRs:
_highestBidder(address) := msg.sender(address)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
_oldHighestBidder.send(_payout) == true

IRs:
TMP_49 = SEND dest:_oldHighestBidder value:_payout
TMP_50(bool) = TMP_49 == True
CONDITION TMP_50""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
etherTransfered(_payout,_oldHighestBidder)

IRs:
Emit etherTransfered(_payout,_oldHighestBidder)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
bidPlaced(_highestBid,_highestBidder)

IRs:
Emit bidPlaced(_highestBid,_highestBidder)""];
11->12;
12[label=""Node Type: RETURN 12

EXPRESSION:
true

IRs:
RETURN True""];
}
",0,0,1,0,"require(bool,string)(block.timestamp > _start,Auction not started);require(bool,string)(block.timestamp < _end,Auction ended);require(bool,string)(msg.value >= _highestBid.add(_minStep),Amount too low);_payout = _highestBid;_highestBid = msg.value;_oldHighestBidder = _highestBidder;_highestBidder = msg.sender;_oldHighestBidder.send(_payout) == true;etherTransfered(_payout,_oldHighestBidder);;bidPlaced(_highestBid,_highestBidder);true"
./0x000621424c60951cb69e9d75d64b79813846d498_ext.sol,Destructible.destroy,70,72,"TMP_21(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_21(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0xf2b89f45cc4ebbf11a36bdb4a4b24eada8dd30a7_ext.sol,AirDrop.kill,94,96,"TMP_25(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_25(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0x5ae96153d99dfdd7a6b471451afe0f564e10b934_ext.sol,CommonSale.finishMinting,497,521,"TMP_301(bool) = invested < softcap,TMP_302(bool) = isSoftcapOn && TMP_301,CONDITION TMP_302,refundOn(bool) := True(bool),TMP_303(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:finishMinting, arguments:[]  ,CONDITION isSoftcapOn,Transfer dest:multisigWallet value:invested,TMP_305(uint256) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:totalSupply, arguments:[]  ,issuedTokenSupply(uint256) := TMP_305(uint256),TMP_306(uint256) = bountyTokensPercent + foundersTokensPercent,summaryTokensPercent(uint256) := TMP_306(uint256),TMP_307(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['issuedTokenSupply', 'summaryTokensPercent'] ,TMP_308(uint256) = percentRate - summaryTokensPercent,TMP_309(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_307', 'TMP_308'] ,summaryFoundersTokens(uint256) := TMP_309(uint256),TMP_310(uint256) = summaryFoundersTokens + issuedTokenSupply,totalSupply(uint256) := TMP_310(uint256),TMP_311(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['totalSupply', 'foundersTokensPercent'] ,TMP_312(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_311', 'percentRate'] ,foundersTokens(uint256) := TMP_312(uint256),TMP_313(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['totalSupply', 'bountyTokensPercent'] ,TMP_314(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_313', 'percentRate'] ,bountyTokens(uint256) := TMP_314(uint256),TMP_315(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['this', 'foundersTokens']  ,TMP_316(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:transfer, arguments:['foundersTokensWallet', 'foundersTokens']  ,TMP_317(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['this', 'bountyTokens']  ,TMP_318(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:transfer, arguments:['bountyTokensWallet', 'bountyTokens']  ,TMP_319 = CONVERT 0 to address,TMP_320(bool) = nextSale == TMP_319,CONDITION TMP_320,TMP_321(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:finishMinting, arguments:[]  ,HIGH_LEVEL_CALL, dest:token(MintableToken), function:setSaleAgent, arguments:['nextSale']  ,MODIFIER_CALL, Pausable.whenNotPaused()(),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->22;
1[label=""Node Type: IF 1

EXPRESSION:
isSoftcapOn && invested < softcap

IRs:
TMP_301(bool) = invested < softcap
TMP_302(bool) = isSoftcapOn && TMP_301
CONDITION TMP_302""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
refundOn = true

IRs:
refundOn(bool) := True(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
token.finishMinting()

IRs:
TMP_303(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:finishMinting, arguments:[]  ""];
3->21;
4[label=""Node Type: IF 4

EXPRESSION:
isSoftcapOn

IRs:
CONDITION isSoftcapOn""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
multisigWallet.transfer(invested)

IRs:
Transfer dest:multisigWallet value:invested""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
issuedTokenSupply = token.totalSupply()

IRs:
TMP_305(uint256) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:totalSupply, arguments:[]  
issuedTokenSupply(uint256) := TMP_305(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
summaryTokensPercent = bountyTokensPercent + foundersTokensPercent

IRs:
TMP_306(uint256) = bountyTokensPercent + foundersTokensPercent
summaryTokensPercent(uint256) := TMP_306(uint256)""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
summaryFoundersTokens = issuedTokenSupply.mul(summaryTokensPercent).div(percentRate - summaryTokensPercent)

IRs:
TMP_307(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['issuedTokenSupply', 'summaryTokensPercent'] 
TMP_308(uint256) = percentRate - summaryTokensPercent
TMP_309(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_307', 'TMP_308'] 
summaryFoundersTokens(uint256) := TMP_309(uint256)""];
9->10;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
totalSupply = summaryFoundersTokens + issuedTokenSupply

IRs:
TMP_310(uint256) = summaryFoundersTokens + issuedTokenSupply
totalSupply(uint256) := TMP_310(uint256)""];
10->11;
11[label=""Node Type: NEW VARIABLE 11

EXPRESSION:
foundersTokens = totalSupply.mul(foundersTokensPercent).div(percentRate)

IRs:
TMP_311(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['totalSupply', 'foundersTokensPercent'] 
TMP_312(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_311', 'percentRate'] 
foundersTokens(uint256) := TMP_312(uint256)""];
11->12;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
bountyTokens = totalSupply.mul(bountyTokensPercent).div(percentRate)

IRs:
TMP_313(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['totalSupply', 'bountyTokensPercent'] 
TMP_314(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_313', 'percentRate'] 
bountyTokens(uint256) := TMP_314(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
token.mint(this,foundersTokens)

IRs:
TMP_315(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['this', 'foundersTokens']  ""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
token.transfer(foundersTokensWallet,foundersTokens)

IRs:
TMP_316(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:transfer, arguments:['foundersTokensWallet', 'foundersTokens']  ""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
token.mint(this,bountyTokens)

IRs:
TMP_317(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:mint, arguments:['this', 'bountyTokens']  ""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
token.transfer(bountyTokensWallet,bountyTokens)

IRs:
TMP_318(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:transfer, arguments:['bountyTokensWallet', 'bountyTokens']  ""];
16->17;
17[label=""Node Type: IF 17

EXPRESSION:
nextSale == address(0)

IRs:
TMP_319 = CONVERT 0 to address
TMP_320(bool) = nextSale == TMP_319
CONDITION TMP_320""];
17->18[label=""True""];
17->19[label=""False""];
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
token.finishMinting()

IRs:
TMP_321(bool) = HIGH_LEVEL_CALL, dest:token(MintableToken), function:finishMinting, arguments:[]  ""];
18->20;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
token.setSaleAgent(nextSale)

IRs:
HIGH_LEVEL_CALL, dest:token(MintableToken), function:setSaleAgent, arguments:['nextSale']  ""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: END_IF 21
""];
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
23->1;
}
",0,0,1,0,"whenNotPaused();isSoftcapOn && invested < softcap;refundOn = true;isSoftcapOn;token.finishMinting();;multisigWallet.transfer(invested);;issuedTokenSupply = token.totalSupply();summaryTokensPercent = bountyTokensPercent + foundersTokensPercent;summaryFoundersTokens = issuedTokenSupply.mul(summaryTokensPercent).div(percentRate - summaryTokensPercent);totalSupply = summaryFoundersTokens + issuedTokenSupply;foundersTokens = totalSupply.mul(foundersTokensPercent).div(percentRate);bountyTokens = totalSupply.mul(bountyTokensPercent).div(percentRate);token.mint(this,foundersTokens);token.transfer(foundersTokensWallet,foundersTokens);token.mint(this,bountyTokens);token.transfer(bountyTokensWallet,bountyTokens);nextSale == address(0);token.finishMinting();token.setSaleAgent(nextSale);;onlyOwner()"
./0x1ff54baa4cfca0826e125e6e1e312a53748c2637_ext.sol,LimeEyes.withdrawAll,182,184,"REF_21(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:toAddress value:REF_21,MODIFIER_CALL, LimeEyes.onlyDev()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
toAddress.transfer(this.balance)

IRs:
REF_21(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:toAddress value:REF_21""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyDev()

IRs:
MODIFIER_CALL, LimeEyes.onlyDev()()""];
2->1;
}
",0,0,1,0,onlyDev();toAddress.transfer(this.balance)
./0x41a322b28d0ff354040e2cbc676f0320d8c8850d_ext.sol,SupeRare.cancelBid,474,481,"REF_69(address) -> tokenBidder[_tokenId],bidder(address) := REF_69(address),TMP_176(bool) = msg.sender == bidder,TMP_177(None) = SOLIDITY_CALL require(bool)(TMP_176),REF_70(uint256) -> tokenCurrentBid[_tokenId],bidAmount(uint256) := REF_70(uint256),Transfer dest:msg.sender value:bidAmount,INTERNAL_CALL, SupeRare.clearBid(uint256)(_tokenId),Emit CancelBid(bidder,bidAmount,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
bidder = tokenBidder[_tokenId]

IRs:
REF_69(address) -> tokenBidder[_tokenId]
bidder(address) := REF_69(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == bidder)

IRs:
TMP_176(bool) = msg.sender == bidder
TMP_177(None) = SOLIDITY_CALL require(bool)(TMP_176)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
bidAmount = tokenCurrentBid[_tokenId]

IRs:
REF_70(uint256) -> tokenCurrentBid[_tokenId]
bidAmount(uint256) := REF_70(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(bidAmount)

IRs:
Transfer dest:msg.sender value:bidAmount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
clearBid(_tokenId)

IRs:
INTERNAL_CALL, SupeRare.clearBid(uint256)(_tokenId)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
CancelBid(bidder,bidAmount,_tokenId)

IRs:
Emit CancelBid(bidder,bidAmount,_tokenId)""];
}
",0,0,1,0,"bidder = tokenBidder[_tokenId];require(bool)(msg.sender == bidder);bidAmount = tokenCurrentBid[_tokenId];msg.sender.transfer(bidAmount);clearBid(_tokenId);CancelBid(bidder,bidAmount,_tokenId)"
./0x3a858b6aa825c23621e339677a5016cfc4ff8b12_ext.sol,Enigma_X.Stop,28,30,"REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3,MODIFIER_CALL, Enigma_X.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, Enigma_X.isAdmin()()""];
2->1;
}
",0,0,1,0,isAdmin();msg.sender.transfer(this.balance)
./0x18b67380942d56c09001a3764ce1aa9e64644433_ext.sol,TokenERC20.selfdestructs,209,211,"TMP_93(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_93(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0xeece3bfd3c83715f1f801dfa6b735ac9093c5bc3_ext.sol,SecuritySale.withdrawSome,236,239,"TMP_77 = CONVERT this to address,TMP_78(uint256) = SOLIDITY_CALL balance(address)(TMP_77),TMP_79(bool) = value <= TMP_78,TMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79),Transfer dest:msg.sender value:value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(value <= address(this).balance)

IRs:
TMP_77 = CONVERT this to address
TMP_78(uint256) = SOLIDITY_CALL balance(address)(TMP_77)
TMP_79(bool) = value <= TMP_78
TMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(value)

IRs:
Transfer dest:msg.sender value:value""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();require(bool)(value <= address(this).balance);msg.sender.transfer(value)
./0x5576250692275701efde5eeb51596e2d9460790b_ext.sol,UserDataManager.registerNameCore,244,260,"REF_46(uint256) -> pIDxName_[_name],TMP_49(bool) = REF_46 != 0,CONDITION TMP_49,REF_47(uint256) -> pIDxName_[_name],TMP_50(bool) = REF_47 == _pID,TMP_51(None) = SOLIDITY_CALL require(bool,string)(TMP_50,sorry that names already taken),REF_48(UserDataManager.Player) -> plyr_[_pID],REF_49(bytes32) -> REF_48.name,REF_49(bytes32) (->plyr_) := _name(bytes32),REF_50(uint256) -> pIDxName_[_name],REF_50(uint256) (->pIDxName_) := _pID(uint256),TMP_52 = CONVERT this to address,TMP_53(uint256) = SOLIDITY_CALL balance(address)(TMP_52),Transfer dest:admin value:TMP_53,TMP_55(bool) = _all == True,CONDITION TMP_55,i(uint256) := 1(uint256),TMP_56(bool) = i <= gID_,CONDITION TMP_56,REF_52(UserDataManagerReceiverInterface) -> games_[i],HIGH_LEVEL_CALL, dest:REF_52(UserDataManagerReceiverInterface), function:receivePlayerInfo, arguments:['_pID', '_addr', '_name', '_affID']  ,TMP_58(uint256) := i(uint256),i(uint256) = i + 1,REF_54(UserDataManager.Player) -> plyr_[_affID],REF_55(address) -> REF_54.addr,REF_56(UserDataManager.Player) -> plyr_[_affID],REF_57(bytes32) -> REF_56.name,Emit onNewPlayer(_pID,_addr,_name,_isNewPlayer,_affID,REF_55,REF_57,msg.value,now)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
pIDxName_[_name] != 0

IRs:
REF_46(uint256) -> pIDxName_[_name]
TMP_49(bool) = REF_46 != 0
CONDITION TMP_49""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(pIDxName_[_name] == _pID,sorry that names already taken)

IRs:
REF_47(uint256) -> pIDxName_[_name]
TMP_50(bool) = REF_47 == _pID
TMP_51(None) = SOLIDITY_CALL require(bool,string)(TMP_50,sorry that names already taken)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
plyr_[_pID].name = _name

IRs:
REF_48(UserDataManager.Player) -> plyr_[_pID]
REF_49(bytes32) -> REF_48.name
REF_49(bytes32) (->plyr_) := _name(bytes32)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
pIDxName_[_name] = _pID

IRs:
REF_50(uint256) -> pIDxName_[_name]
REF_50(uint256) (->pIDxName_) := _pID(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
admin.transfer(address(this).balance)

IRs:
TMP_52 = CONVERT this to address
TMP_53(uint256) = SOLIDITY_CALL balance(address)(TMP_52)
Transfer dest:admin value:TMP_53""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
_all == true

IRs:
TMP_55(bool) = _all == True
CONDITION TMP_55""];
7->10[label=""True""];
7->14[label=""False""];
8[label=""Node Type: BEGIN_LOOP 8
""];
8->11;
9[label=""Node Type: END_LOOP 9
""];
9->14;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
i = 1

IRs:
i(uint256) := 1(uint256)""];
10->8;
11[label=""Node Type: IF_LOOP 11

EXPRESSION:
i <= gID_

IRs:
TMP_56(bool) = i <= gID_
CONDITION TMP_56""];
11->12[label=""True""];
11->9[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
games_[i].receivePlayerInfo(_pID,_addr,_name,_affID)

IRs:
REF_52(UserDataManagerReceiverInterface) -> games_[i]
HIGH_LEVEL_CALL, dest:REF_52(UserDataManagerReceiverInterface), function:receivePlayerInfo, arguments:['_pID', '_addr', '_name', '_affID']  ""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
i ++

IRs:
TMP_58(uint256) := i(uint256)
i(uint256) = i + 1""];
13->11;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
onNewPlayer(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,msg.value,now)

IRs:
REF_54(UserDataManager.Player) -> plyr_[_affID]
REF_55(address) -> REF_54.addr
REF_56(UserDataManager.Player) -> plyr_[_affID]
REF_57(bytes32) -> REF_56.name
Emit onNewPlayer(_pID,_addr,_name,_isNewPlayer,_affID,REF_55,REF_57,msg.value,now)""];
}
",0,0,1,0,"pIDxName_[_name] != 0;require(bool,string)(pIDxName_[_name] == _pID,sorry that names already taken);;plyr_[_pID].name = _name;pIDxName_[_name] = _pID;admin.transfer(address(this).balance);_all == true;i = 1;;;i <= gID_;;games_[i].receivePlayerInfo(_pID,_addr,_name,_affID);i ++;onNewPlayer(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,msg.value,now)"
./0x32fcdefa047d8edeea0c21a50179b18181074c60_ext.sol,CryptoSanguoToken.withdrawAmount,124,126,"Transfer dest:owner value:_amount,MODIFIER_CALL, CryptoSanguoToken.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(_amount)

IRs:
Transfer dest:owner value:_amount""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, CryptoSanguoToken.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();owner.transfer(_amount)
./0x6fdfce60998725f4cfb4cc57505a3abdbb6d0646_ext.sol,SelfKeyToken.killContract,57,63,"TMP_6(bool) = msg.sender == owner,TMP_7(bool) = msg.value >= howManyEtherInWeiToKillContract,TMP_8(bool) = TMP_6 || TMP_7,CONDITION TMP_8,TMP_9(None) = SOLIDITY_CALL selfdestruct(address)(owner)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == owner || msg.value >= howManyEtherInWeiToKillContract

IRs:
TMP_6(bool) = msg.sender == owner
TMP_7(bool) = msg.value >= howManyEtherInWeiToKillContract
TMP_8(bool) = TMP_6 || TMP_7
CONDITION TMP_8""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_9(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,0,1,0,msg.sender == owner || msg.value >= howManyEtherInWeiToKillContract;selfdestruct(address)(owner);
./0x00416b9d728069edb0ceb04bc2b203fa7336d1f1_ext.sol,SeedCrowdsaleContract.refundTransaction,177,183,"CONDITION _stateChanged,Transfer dest:msg.sender value:msg.value,TMP_51(None) = SOLIDITY_CALL revert()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_stateChanged

IRs:
CONDITION _stateChanged""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(msg.value)

IRs:
Transfer dest:msg.sender value:msg.value""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
revert()()

IRs:
TMP_51(None) = SOLIDITY_CALL revert()()""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,_stateChanged;msg.sender.transfer(msg.value);revert()();
./0x1ac68e35dbd49a7250fa1b1ceb9dbd3110edaf50_ext.sol,VikkyToken.reclaimFund,410,437,"TMP_174(uint256) = INTERNAL_CALL, VikkyToken.atNow()(),TMP_175(bool) = TMP_174 > DATE_ICO_END,TMP_176(bool) = INTERNAL_CALL, VikkyToken.icoThresholdReached()(),TMP_177 = UnaryType.BANG TMP_176 ,TMP_178(bool) = TMP_175 && TMP_177,TMP_179(None) = SOLIDITY_CALL require(bool)(TMP_178),REF_85(bool) -> refundClaimed[_participant],TMP_180 = UnaryType.BANG REF_85 ,TMP_181(None) = SOLIDITY_CALL require(bool)(TMP_180),REF_86(uint256) -> icoEtherContributed[_participant],TMP_182(bool) = REF_86 > 0,TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182),REF_87(uint256) -> icoTokensReceived[_participant],tokens(uint256) := REF_87(uint256),REF_88(uint256) -> icoEtherContributed[_participant],amount(uint256) := REF_88(uint256),REF_89(uint256) -> balances[_participant],REF_90(uint256) -> balances[_participant],TMP_184(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_90', 'tokens'] ,REF_89(uint256) (->balances) := TMP_184(uint256),TMP_185(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalDistributed', 'tokens'] ,totalDistributed(uint256) := TMP_185(uint256),REF_93(bool) -> refundClaimed[_participant],REF_93(bool) (->refundClaimed) := True(bool),Transfer dest:_participant value:amount,Emit Transfer(_participant,0,tokens),Emit Refund(_participant,amount,tokens)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(atNow() > DATE_ICO_END && ! icoThresholdReached())

IRs:
TMP_174(uint256) = INTERNAL_CALL, VikkyToken.atNow()()
TMP_175(bool) = TMP_174 > DATE_ICO_END
TMP_176(bool) = INTERNAL_CALL, VikkyToken.icoThresholdReached()()
TMP_177 = UnaryType.BANG TMP_176 
TMP_178(bool) = TMP_175 && TMP_177
TMP_179(None) = SOLIDITY_CALL require(bool)(TMP_178)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(! refundClaimed[_participant])

IRs:
REF_85(bool) -> refundClaimed[_participant]
TMP_180 = UnaryType.BANG REF_85 
TMP_181(None) = SOLIDITY_CALL require(bool)(TMP_180)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(icoEtherContributed[_participant] > 0)

IRs:
REF_86(uint256) -> icoEtherContributed[_participant]
TMP_182(bool) = REF_86 > 0
TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tokens = icoTokensReceived[_participant]

IRs:
REF_87(uint256) -> icoTokensReceived[_participant]
tokens(uint256) := REF_87(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
amount = icoEtherContributed[_participant]

IRs:
REF_88(uint256) -> icoEtherContributed[_participant]
amount(uint256) := REF_88(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[_participant] = balances[_participant].sub(tokens)

IRs:
REF_89(uint256) -> balances[_participant]
REF_90(uint256) -> balances[_participant]
TMP_184(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_90', 'tokens'] 
REF_89(uint256) (->balances) := TMP_184(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
totalDistributed = totalDistributed.sub(tokens)

IRs:
TMP_185(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalDistributed', 'tokens'] 
totalDistributed(uint256) := TMP_185(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
refundClaimed[_participant] = true

IRs:
REF_93(bool) -> refundClaimed[_participant]
REF_93(bool) (->refundClaimed) := True(bool)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
_participant.transfer(amount)

IRs:
Transfer dest:_participant value:amount""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
Transfer(_participant,0x0,tokens)

IRs:
Emit Transfer(_participant,0,tokens)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
Refund(_participant,amount,tokens)

IRs:
Emit Refund(_participant,amount,tokens)""];
}
",0,0,1,0,";;require(bool)(atNow() > DATE_ICO_END && ! icoThresholdReached());require(bool)(! refundClaimed[_participant]);require(bool)(icoEtherContributed[_participant] > 0);tokens = icoTokensReceived[_participant];amount = icoEtherContributed[_participant];balances[_participant] = balances[_participant].sub(tokens);totalDistributed = totalDistributed.sub(tokens);refundClaimed[_participant] = true;_participant.transfer(amount);Transfer(_participant,0x0,tokens);Refund(_participant,amount,tokens)"
./0xee68907c93b57d57a1c4d60940ff1b310e18e467_ext.sol,ICOBuyer.buyICO,148,158,"TMP_34(uint256) = INTERNAL_CALL, ICOBuyer.getBlockNumber()(),TMP_35(bool) = TMP_34 < icoStartBlock,CONDITION TMP_35,REF_6(uint256) = SOLIDITY_CALL balance(address)(this),TMP_36(bool) = REF_6 == 0,CONDITION TMP_36,REF_8(uint256) = SOLIDITY_CALL balance(address)(this),TMP_37(uint256) = LIBRARY_CALL, dest:Math, function:Math.min256(uint256,uint256), arguments:['REF_8', 'purchaseCap'] ,purchaseAmount(uint256) := TMP_37(uint256),TMP_39(bool) = LOW_LEVEL_CALL, dest:crowdSale, function:call, arguments:[] value:purchaseAmount ,TMP_40(None) = SOLIDITY_CALL assert(bool)(TMP_39),Emit ICOPurchased(purchaseAmount),MODIFIER_CALL, ICOBuyer.onlyExecutorOrOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: IF 1

EXPRESSION:
getBlockNumber() < icoStartBlock

IRs:
TMP_34(uint256) = INTERNAL_CALL, ICOBuyer.getBlockNumber()()
TMP_35(bool) = TMP_34 < icoStartBlock
CONDITION TMP_35""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
this.balance == 0

IRs:
REF_6(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_36(bool) = REF_6 == 0
CONDITION TMP_36""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: RETURN 5
""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
purchaseAmount = Math.min256(this.balance,purchaseCap)

IRs:
REF_8(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_37(uint256) = LIBRARY_CALL, dest:Math, function:Math.min256(uint256,uint256), arguments:['REF_8', 'purchaseCap'] 
purchaseAmount(uint256) := TMP_37(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(crowdSale.call.value(purchaseAmount)())

IRs:
TMP_39(bool) = LOW_LEVEL_CALL, dest:crowdSale, function:call, arguments:[] value:purchaseAmount 
TMP_40(None) = SOLIDITY_CALL assert(bool)(TMP_39)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
ICOPurchased(purchaseAmount)

IRs:
Emit ICOPurchased(purchaseAmount)""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyExecutorOrOwner()

IRs:
MODIFIER_CALL, ICOBuyer.onlyExecutorOrOwner()()""];
10->1;
}
",1,0,1,0,"onlyExecutorOrOwner();getBlockNumber() < icoStartBlock;;;this.balance == 0;;;purchaseAmount = Math.min256(this.balance,purchaseCap);assert(bool)(crowdSale.call.value(purchaseAmount)());ICOPurchased(purchaseAmount)"
./0x722baa20d3b42fc1ec0b63fb84ba3fda47da4a26_ext.sol,Presale.withdraw,559,562,"TMP_297(bool) = msg.sender == addrFinance,TMP_298(bool) = msg.sender == addrAdmin,TMP_299(bool) = TMP_297 || TMP_298,TMP_300(None) = SOLIDITY_CALL require(bool)(TMP_299),TMP_301 = CONVERT this to address,TMP_302(uint256) = SOLIDITY_CALL balance(address)(TMP_301),Transfer dest:addrFinance value:TMP_302","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == addrFinance || msg.sender == addrAdmin)

IRs:
TMP_297(bool) = msg.sender == addrFinance
TMP_298(bool) = msg.sender == addrAdmin
TMP_299(bool) = TMP_297 || TMP_298
TMP_300(None) = SOLIDITY_CALL require(bool)(TMP_299)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
addrFinance.transfer(address(this).balance)

IRs:
TMP_301 = CONVERT this to address
TMP_302(uint256) = SOLIDITY_CALL balance(address)(TMP_301)
Transfer dest:addrFinance value:TMP_302""];
}
",0,0,1,0,require(bool)(msg.sender == addrFinance || msg.sender == addrAdmin);addrFinance.transfer(address(this).balance)
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.singleUserSignUp,2,2,"TMP_173(bool) = userSignupCount <= maxSignup,CONDITION TMP_173,REF_104(bool) -> signups[_address],TMP_174 = UnaryType.BANG REF_104 ,REF_105(KahnDistributionCentre.User) -> bounties[_address],REF_106(address) -> REF_105.user_address,TMP_175(bool) = REF_106 != _address,TMP_176(bool) = TMP_174 && TMP_175,TMP_177(bool) = msg.value >= minsignupeth,TMP_178(bool) = TMP_176 && TMP_177,CONDITION TMP_178,TMP_179(bool) = payoutNow != 1,TMP_180(bool) = payoutNow != 2,TMP_181(bool) = TMP_179 || TMP_180,CONDITION TMP_181,REF_107(bool) -> signups[_address],REF_107(bool) (->signups) := True(bool),temrew(uint256) := 0(uint256),TMP_182(bool) = payStyle == 1,CONDITION TMP_182,temrew(uint256) := fixPayAmt(uint256),REF_108(KahnDistributionCentre.User) -> bounties[_address],TMP_183(KahnDistributionCentre.User) = new User(_address,now,temrew,False,0,0,True),REF_108(KahnDistributionCentre.User) (->bounties) := TMP_183(KahnDistributionCentre.User),REF_109(bool) -> signups[_address],REF_109(bool) (->signups) := True(bool),REF_111 -> LENGTH bountyaddress,TMP_186(uint256) := REF_111(uint256),TMP_187(uint256) = TMP_186 + 1,REF_111(uint256) (->bountyaddress) := TMP_187(uint256),REF_112(address) -> bountyaddress[TMP_186],REF_112(address) (->bountyaddress) := _address(address),TMP_185(None) = TMP_184 - 1,TMP_188(uint256) := userSignupCount(uint256),userSignupCount(uint256) = userSignupCount + 1,INTERNAL_CALL, KahnDistributionCentre.forwardWei()(),MODIFIER_CALL, KahnDistributionCentre.ifNotStartExp()(),MODIFIER_CALL, KahnDistributionCentre.ifNotPaused()(),MODIFIER_CALL, KahnDistributionCentre.ifNotBlacklisted()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->17;
1[label=""Node Type: IF 1

EXPRESSION:
userSignupCount <= maxSignup

IRs:
TMP_173(bool) = userSignupCount <= maxSignup
CONDITION TMP_173""];
1->2[label=""True""];
1->15[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
! signups[_address] && bounties[_address].user_address != _address && msg.value >= minsignupeth

IRs:
REF_104(bool) -> signups[_address]
TMP_174 = UnaryType.BANG REF_104 
REF_105(KahnDistributionCentre.User) -> bounties[_address]
REF_106(address) -> REF_105.user_address
TMP_175(bool) = REF_106 != _address
TMP_176(bool) = TMP_174 && TMP_175
TMP_177(bool) = msg.value >= minsignupeth
TMP_178(bool) = TMP_176 && TMP_177
CONDITION TMP_178""];
2->3[label=""True""];
2->14[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
payoutNow != 1 || payoutNow != 2

IRs:
TMP_179(bool) = payoutNow != 1
TMP_180(bool) = payoutNow != 2
TMP_181(bool) = TMP_179 || TMP_180
CONDITION TMP_181""];
3->4[label=""True""];
3->13[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
signups[_address] = true

IRs:
REF_107(bool) -> signups[_address]
REF_107(bool) (->signups) := True(bool)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
temrew = 0

IRs:
temrew(uint256) := 0(uint256)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
payStyle == 1

IRs:
TMP_182(bool) = payStyle == 1
CONDITION TMP_182""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
temrew = fixPayAmt

IRs:
temrew(uint256) := fixPayAmt(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
bounties[_address] = User(_address,now,temrew,false,0,0,true)

IRs:
REF_108(KahnDistributionCentre.User) -> bounties[_address]
TMP_183(KahnDistributionCentre.User) = new User(_address,now,temrew,False,0,0,True)
REF_108(KahnDistributionCentre.User) (->bounties) := TMP_183(KahnDistributionCentre.User)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
signups[_address] = true

IRs:
REF_109(bool) -> signups[_address]
REF_109(bool) (->signups) := True(bool)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
bountyaddress.push(_address) - 1

IRs:
REF_111 -> LENGTH bountyaddress
TMP_186(uint256) := REF_111(uint256)
TMP_187(uint256) = TMP_186 + 1
REF_111(uint256) (->bountyaddress) := TMP_187(uint256)
REF_112(address) -> bountyaddress[TMP_186]
REF_112(address) (->bountyaddress) := _address(address)
TMP_185(None) = TMP_184 - 1""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
userSignupCount ++

IRs:
TMP_188(uint256) := userSignupCount(uint256)
userSignupCount(uint256) = userSignupCount + 1""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
forwardWei()

IRs:
INTERNAL_CALL, KahnDistributionCentre.forwardWei()()""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
ifNotStartExp()

IRs:
MODIFIER_CALL, KahnDistributionCentre.ifNotStartExp()()""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
ifNotPaused()

IRs:
MODIFIER_CALL, KahnDistributionCentre.ifNotPaused()()""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
ifNotBlacklisted()

IRs:
MODIFIER_CALL, KahnDistributionCentre.ifNotBlacklisted()()""];
19->1;
}
",0,1,1,0,"ifNotStartExp();userSignupCount <= maxSignup;! signups[_address] && bounties[_address].user_address != _address && msg.value >= minsignupeth;;payoutNow != 1 || payoutNow != 2;;signups[_address] = true;;temrew = 0;payStyle == 1;temrew = fixPayAmt;;bounties[_address] = User(_address,now,temrew,false,0,0,true);signups[_address] = true;bountyaddress.push(_address) - 1;userSignupCount ++;forwardWei();ifNotPaused();ifNotBlacklisted()"
./0x7638a5f444eab0281ca1abff2c8029cbb806a566_ext.sol,XOXOCoin.withdraw,259,263,"REF_92(uint256) = SOLIDITY_CALL balance(address)(this),etherBalance(uint256) := REF_92([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E495B6D0>]),owner(address) := msg.sender(address),Transfer dest:owner value:etherBalance,MODIFIER_CALL, XOXOCoin.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
etherBalance = this.balance

IRs:
REF_92(uint256) = SOLIDITY_CALL balance(address)(this)
etherBalance(uint256) := REF_92([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E495B6D0>])""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(etherBalance)

IRs:
Transfer dest:owner value:etherBalance""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, XOXOCoin.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();etherBalance = this.balance;owner = msg.sender;owner.transfer(etherBalance)
./0x33ac37240f71629294de98e0b51f904fda17a366_ext.sol,enigma.StopGame,33,36,"TMP_10(bool) = msg.sender == questionSender,TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_10(bool) = msg.sender == questionSender
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0x39e568276531f17da3c76d54400cfd8300201652_ext.sol,CSC.withdrawTo,90,93,"TMP_30(bool) = msg.sender == owner,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),TMP_32 = CONVERT _to to address,TMP_33 = CONVERT this to address,TMP_34(uint256) = SOLIDITY_CALL balance(address)(TMP_33),Transfer dest:TMP_32 value:TMP_34","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_30(bool) = msg.sender == owner
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
address(_to).transfer(address(this).balance)

IRs:
TMP_32 = CONVERT _to to address
TMP_33 = CONVERT this to address
TMP_34(uint256) = SOLIDITY_CALL balance(address)(TMP_33)
Transfer dest:TMP_32 value:TMP_34""];
}
",0,0,1,0,require(bool)(msg.sender == owner);address(_to).transfer(address(this).balance)
./0x70052a651eec65f98925e845820a0aa5749b033d_ext.sol,ATxBuyback.withdrawAllEth,669,678,"TMP_122 = CONVERT this to address,TMP_123(uint256) = SOLIDITY_CALL balance(address)(TMP_122),_balance(uint256) := TMP_123(uint256),TMP_124(bool) = _balance == 0,CONDITION TMP_124,RETURN 0,Transfer dest:_to value:_balance,RETURN OK,MODIFIER_CALL, Owned.onlyContractOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_balance = address(this).balance

IRs:
TMP_122 = CONVERT this to address
TMP_123(uint256) = SOLIDITY_CALL balance(address)(TMP_122)
_balance(uint256) := TMP_123(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
_balance == 0

IRs:
TMP_124(bool) = _balance == 0
CONDITION TMP_124""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3

EXPRESSION:
0

IRs:
RETURN 0""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_to.transfer(_balance)

IRs:
Transfer dest:_to value:_balance""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
OK

IRs:
RETURN OK""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyContractOwner()

IRs:
MODIFIER_CALL, Owned.onlyContractOwner()()""];
7->1;
}
",0,0,1,0,onlyContractOwner();_balance = address(this).balance;_balance == 0;0;;_to.transfer(_balance);OK
./0xf051a2f404435d3413337aae24171342fddc8571_ext.sol,FoxicoPool.refundFunds,179,191,"TMP_54 = CONVERT 0 to address,TMP_55(bool) = _wallet != TMP_54,TMP_56(None) = SOLIDITY_CALL require(bool)(TMP_55),REF_13(uint256) -> deposited[_wallet],TMP_57(bool) = REF_13 > 0,TMP_58(None) = SOLIDITY_CALL require(bool)(TMP_57),TMP_59(bool) = now < endTime,TMP_60(None) = SOLIDITY_CALL require(bool)(TMP_59),REF_14(uint256) -> deposited[_wallet],depositedValue(uint256) := REF_14(uint256),REF_15(uint256) -> deposited[_wallet],REF_15(uint256) (->deposited) := 0(uint256),Transfer dest:_wallet value:depositedValue,Emit Refunded(_wallet,depositedValue)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_54 = CONVERT 0 to address
TMP_55(bool) = _wallet != TMP_54
TMP_56(None) = SOLIDITY_CALL require(bool)(TMP_55)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(deposited[_wallet] > 0)

IRs:
REF_13(uint256) -> deposited[_wallet]
TMP_57(bool) = REF_13 > 0
TMP_58(None) = SOLIDITY_CALL require(bool)(TMP_57)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(now < endTime)

IRs:
TMP_59(bool) = now < endTime
TMP_60(None) = SOLIDITY_CALL require(bool)(TMP_59)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
depositedValue = deposited[_wallet]

IRs:
REF_14(uint256) -> deposited[_wallet]
depositedValue(uint256) := REF_14(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
deposited[_wallet] = 0

IRs:
REF_15(uint256) -> deposited[_wallet]
REF_15(uint256) (->deposited) := 0(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
_wallet.transfer(depositedValue)

IRs:
Transfer dest:_wallet value:depositedValue""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Refunded(_wallet,depositedValue)

IRs:
Emit Refunded(_wallet,depositedValue)""];
}
",0,0,1,0,"require(bool)(_wallet != address(0));require(bool)(deposited[_wallet] > 0);require(bool)(now < endTime);depositedValue = deposited[_wallet];deposited[_wallet] = 0;_wallet.transfer(depositedValue);Refunded(_wallet,depositedValue)"
./0xeed618c15d12c635c3c319aee7bded2e2879aea0_ext.sol,PlayerBook.registerNameCore,291,319,"REF_54(uint256) -> pIDxName_[_name],TMP_59(bool) = REF_54 != 0,CONDITION TMP_59,REF_55(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_56(bool) -> REF_55[_name],TMP_60(bool) = REF_56 == True,TMP_61(None) = SOLIDITY_CALL require(bool,string)(TMP_60,sorry that names already taken),REF_57(PlayerBook.Player) -> plyr_[_pID],REF_58(bytes32) -> REF_57.name,REF_58(bytes32) (->plyr_) := _name(bytes32),REF_59(uint256) -> pIDxName_[_name],REF_59(uint256) (->pIDxName_) := _pID(uint256),REF_60(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_61(bool) -> REF_60[_name],TMP_62(bool) = REF_61 == False,CONDITION TMP_62,REF_62(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_63(bool) -> REF_62[_name],REF_63(bool) (->plyrNames_) := True(bool),REF_64(PlayerBook.Player) -> plyr_[_pID],REF_65(uint256) -> REF_64.names,TMP_63(uint256) := REF_65(uint256),REF_65(-> plyr_) = REF_65 + 1,REF_66(mapping(uint256 => bytes32)) -> plyrNameList_[_pID],REF_67(PlayerBook.Player) -> plyr_[_pID],REF_68(uint256) -> REF_67.names,REF_69(bytes32) -> REF_66[REF_68],REF_69(bytes32) (->plyrNameList_) := _name(bytes32),TMP_64 = CONVERT this to address,TMP_65(uint256) = SOLIDITY_CALL balance(address)(TMP_64),Transfer dest:_owner value:TMP_65,TMP_67(bool) = _all == True,CONDITION TMP_67,i(uint256) := 1(uint256),TMP_68(bool) = i <= gID_,CONDITION TMP_68,REF_71(PlayerBookReceiverInterface) -> games_[i],HIGH_LEVEL_CALL, dest:REF_71(PlayerBookReceiverInterface), function:receivePlayerInfo, arguments:['_pID', '_addr', '_name', '_affID']  ,TMP_70(uint256) := i(uint256),i(uint256) = i + 1,REF_73(PlayerBook.Player) -> plyr_[_affID],REF_74(address) -> REF_73.addr,REF_75(PlayerBook.Player) -> plyr_[_affID],REF_76(bytes32) -> REF_75.name,Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_74,REF_76,msg.value,now)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
pIDxName_[_name] != 0

IRs:
REF_54(uint256) -> pIDxName_[_name]
TMP_59(bool) = REF_54 != 0
CONDITION TMP_59""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(plyrNames_[_pID][_name] == true,sorry that names already taken)

IRs:
REF_55(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_56(bool) -> REF_55[_name]
TMP_60(bool) = REF_56 == True
TMP_61(None) = SOLIDITY_CALL require(bool,string)(TMP_60,sorry that names already taken)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
plyr_[_pID].name = _name

IRs:
REF_57(PlayerBook.Player) -> plyr_[_pID]
REF_58(bytes32) -> REF_57.name
REF_58(bytes32) (->plyr_) := _name(bytes32)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
pIDxName_[_name] = _pID

IRs:
REF_59(uint256) -> pIDxName_[_name]
REF_59(uint256) (->pIDxName_) := _pID(uint256)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
plyrNames_[_pID][_name] == false

IRs:
REF_60(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_61(bool) -> REF_60[_name]
TMP_62(bool) = REF_61 == False
CONDITION TMP_62""];
6->7[label=""True""];
6->10[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
plyrNames_[_pID][_name] = true

IRs:
REF_62(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_63(bool) -> REF_62[_name]
REF_63(bool) (->plyrNames_) := True(bool)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
plyr_[_pID].names ++

IRs:
REF_64(PlayerBook.Player) -> plyr_[_pID]
REF_65(uint256) -> REF_64.names
TMP_63(uint256) := REF_65(uint256)
REF_65(-> plyr_) = REF_65 + 1""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
plyrNameList_[_pID][plyr_[_pID].names] = _name

IRs:
REF_66(mapping(uint256 => bytes32)) -> plyrNameList_[_pID]
REF_67(PlayerBook.Player) -> plyr_[_pID]
REF_68(uint256) -> REF_67.names
REF_69(bytes32) -> REF_66[REF_68]
REF_69(bytes32) (->plyrNameList_) := _name(bytes32)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
_owner.transfer(address(this).balance)

IRs:
TMP_64 = CONVERT this to address
TMP_65(uint256) = SOLIDITY_CALL balance(address)(TMP_64)
Transfer dest:_owner value:TMP_65""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
_all == true

IRs:
TMP_67(bool) = _all == True
CONDITION TMP_67""];
12->15[label=""True""];
12->19[label=""False""];
13[label=""Node Type: BEGIN_LOOP 13
""];
13->16;
14[label=""Node Type: END_LOOP 14
""];
14->19;
15[label=""Node Type: NEW VARIABLE 15

EXPRESSION:
i = 1

IRs:
i(uint256) := 1(uint256)""];
15->13;
16[label=""Node Type: IF_LOOP 16

EXPRESSION:
i <= gID_

IRs:
TMP_68(bool) = i <= gID_
CONDITION TMP_68""];
16->17[label=""True""];
16->14[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
games_[i].receivePlayerInfo(_pID,_addr,_name,_affID)

IRs:
REF_71(PlayerBookReceiverInterface) -> games_[i]
HIGH_LEVEL_CALL, dest:REF_71(PlayerBookReceiverInterface), function:receivePlayerInfo, arguments:['_pID', '_addr', '_name', '_affID']  ""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
i ++

IRs:
TMP_70(uint256) := i(uint256)
i(uint256) = i + 1""];
18->16;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,msg.value,now)

IRs:
REF_73(PlayerBook.Player) -> plyr_[_affID]
REF_74(address) -> REF_73.addr
REF_75(PlayerBook.Player) -> plyr_[_affID]
REF_76(bytes32) -> REF_75.name
Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_74,REF_76,msg.value,now)""];
}
",0,0,1,0,"pIDxName_[_name] != 0;require(bool,string)(plyrNames_[_pID][_name] == true,sorry that names already taken);;plyr_[_pID].name = _name;pIDxName_[_name] = _pID;plyrNames_[_pID][_name] == false;plyrNames_[_pID][_name] = true;;plyr_[_pID].names ++;plyrNameList_[_pID][plyr_[_pID].names] = _name;_owner.transfer(address(this).balance);_all == true;i = 1;;;i <= gID_;;games_[i].receivePlayerInfo(_pID,_addr,_name,_affID);i ++;onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,msg.value,now)"
./0x86e4dc25259ee2191cd8ae40e1865b9f0319646c_ext.sol,CryptoRomeLandDistribution.purchaseFromVillageInventory,1139,1156,"TMP_725(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['villageInventoryPrice', '_num'] ,price(uint256) := TMP_725(uint256),TMP_726(bool) = msg.value >= price,TMP_727(None) = SOLIDITY_CALL require(bool)(TMP_726),TMP_728(bool) = _num > 0,TMP_729(bool) = _num <= 50,TMP_730(bool) = TMP_728 && TMP_729,TMP_731(None) = SOLIDITY_CALL require(bool)(TMP_730),TMP_732(uint256) = INTERNAL_CALL, CryptoRomeLandDistribution.computeFee(uint256)(price),marketFee(uint256) := TMP_732(uint256),Transfer dest:cryptoRomeWallet value:marketFee,TMP_734(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.value', 'price'] ,excessPayment(uint256) := TMP_734(uint256),Transfer dest:msg.sender value:excessPayment,i(uint256) := 0(uint256),TMP_736(bool) = i < _num,CONDITION TMP_736,TMP_737(uint256) = INTERNAL_CALL, CryptoRomeLandDistribution._createVillageWithImprovementsFromInv(address)(msg.sender),TMP_738(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, CryptoRomeControl.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
price = villageInventoryPrice.mul(_num)

IRs:
TMP_725(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['villageInventoryPrice', '_num'] 
price(uint256) := TMP_725(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.value >= price)

IRs:
TMP_726(bool) = msg.value >= price
TMP_727(None) = SOLIDITY_CALL require(bool)(TMP_726)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_num > 0 && _num <= 50)

IRs:
TMP_728(bool) = _num > 0
TMP_729(bool) = _num <= 50
TMP_730(bool) = TMP_728 && TMP_729
TMP_731(None) = SOLIDITY_CALL require(bool)(TMP_730)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
marketFee = computeFee(price)

IRs:
TMP_732(uint256) = INTERNAL_CALL, CryptoRomeLandDistribution.computeFee(uint256)(price)
marketFee(uint256) := TMP_732(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
cryptoRomeWallet.transfer(marketFee)

IRs:
Transfer dest:cryptoRomeWallet value:marketFee""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
excessPayment = msg.value.sub(price)

IRs:
TMP_734(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.value', 'price'] 
excessPayment(uint256) := TMP_734(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
msg.sender.transfer(excessPayment)

IRs:
Transfer dest:msg.sender value:excessPayment""];
7->10;
8[label=""Node Type: BEGIN_LOOP 8
""];
8->11;
9[label=""Node Type: END_LOOP 9
""];
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
10->8;
11[label=""Node Type: IF_LOOP 11

EXPRESSION:
i < _num

IRs:
TMP_736(bool) = i < _num
CONDITION TMP_736""];
11->12[label=""True""];
11->9[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
_createVillageWithImprovementsFromInv(msg.sender)

IRs:
TMP_737(uint256) = INTERNAL_CALL, CryptoRomeLandDistribution._createVillageWithImprovementsFromInv(address)(msg.sender)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
i ++

IRs:
TMP_738(uint256) := i(uint256)
i(uint256) = i + 1""];
13->11;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, CryptoRomeControl.whenNotPaused()()""];
14->1;
}
",0,0,1,0,whenNotPaused();price = villageInventoryPrice.mul(_num);require(bool)(msg.value >= price);require(bool)(_num > 0 && _num <= 50);marketFee = computeFee(price);cryptoRomeWallet.transfer(marketFee);excessPayment = msg.value.sub(price);msg.sender.transfer(excessPayment);i = 0;;i < _num;;_createVillageWithImprovementsFromInv(msg.sender);i ++
./0x261ace754fba8af93e1fecdff13640540402940f_ext.sol,Phila_Token.claimTokens,207,218,"TMP_46 = CONVERT this to address,TMP_47(bool) = _token != TMP_46,TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47),TMP_49(bool) = _token == 0,CONDITION TMP_49,TMP_50 = CONVERT this to address,TMP_51(uint256) = SOLIDITY_CALL balance(address)(TMP_50),Transfer dest:owner value:TMP_51,TMP_53 = CONVERT _token to ERC20Interface,token(ERC20Interface) := TMP_53(ERC20Interface),TMP_54(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Interface), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_54(uint256),TMP_55(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Interface), function:transfer, arguments:['owner', 'balance']  ,Emit ClaimedTokens(_token,owner,balance),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_token != address(this))

IRs:
TMP_46 = CONVERT this to address
TMP_47(bool) = _token != TMP_46
TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
_token == 0x0

IRs:
TMP_49(bool) = _token == 0
CONDITION TMP_49""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_50 = CONVERT this to address
TMP_51(uint256) = SOLIDITY_CALL balance(address)(TMP_50)
Transfer dest:owner value:TMP_51""];
3->4;
4[label=""Node Type: RETURN 4
""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
token = ERC20Interface(_token)

IRs:
TMP_53 = CONVERT _token to ERC20Interface
token(ERC20Interface) := TMP_53(ERC20Interface)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_54(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Interface), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_54(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
token.transfer(owner,balance)

IRs:
TMP_55(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Interface), function:transfer, arguments:['owner', 'balance']  ""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
ClaimedTokens(_token,owner,balance)

IRs:
Emit ClaimedTokens(_token,owner,balance)""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
10->1;
}
",1,0,1,0,"onlyOwner();require(bool)(_token != address(this));_token == 0x0;owner.transfer(address(this).balance);;;token = ERC20Interface(_token);balance = token.balanceOf(this);token.transfer(owner,balance);ClaimedTokens(_token,owner,balance)"
./0xf030b8fbe57c4498298449fc78a0f7054a5ef76d_ext.sol,ArkToken.withdraw,347,353,"TMP_112(bool) = _amount == 0,CONDITION TMP_112,_amount(uint256) := developerCut(uint256),TMP_113(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['developerCut', '_amount'] ,developerCut(uint256) := TMP_113(uint256),Transfer dest:owner value:_amount,MODIFIER_CALL, Ownable.onlyAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: IF 1

EXPRESSION:
_amount == 0

IRs:
TMP_112(bool) = _amount == 0
CONDITION TMP_112""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_amount = developerCut

IRs:
_amount(uint256) := developerCut(uint256)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
developerCut = developerCut.sub(_amount)

IRs:
TMP_113(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['developerCut', '_amount'] 
developerCut(uint256) := TMP_113(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
owner.transfer(_amount)

IRs:
Transfer dest:owner value:_amount""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Ownable.onlyAdmin()()""];
6->1;
}
",0,0,1,0,onlyAdmin();_amount == 0;_amount = developerCut;;developerCut = developerCut.sub(_amount);owner.transfer(_amount)
./0xe01ba6c593003b0edcd43b7839a7c36b00a44dfc_ext.sol,SBITokenCrowdsale.kill,449,463,"TMP_154(bool) = INTERNAL_CALL, SBITokenCrowdsale.isICOActive()(),TMP_155 = UnaryType.BANG TMP_154 ,TMP_156(None) = SOLIDITY_CALL require(bool)(TMP_155),TMP_157(uint256) = SOLIDITY_CALL balance(address)(crowdsaleAddress),TMP_158(bool) = TMP_157 > 0,CONDITION TMP_158,TMP_159(None) = SOLIDITY_CALL revert()(),TMP_160(bool) = now < preSaleStartDate,CONDITION TMP_160,TMP_161(None) = SOLIDITY_CALL selfdestruct(address)(owner),TMP_162(uint256) = HIGH_LEVEL_CALL, dest:token(SBIToken), function:balanceOf, arguments:['saleWalletAddress']  ,featureDevelopmentAmount(uint256) := TMP_162(uint256),REF_50(address) -> featureDevelopment.addr,TMP_163(bool) = HIGH_LEVEL_CALL, dest:token(SBIToken), function:transferFrom, arguments:['saleWalletAddress', 'REF_50', 'featureDevelopmentAmount']  ,TMP_164(uint256) = SOLIDITY_CALL balance(address)(crowdsaleAddress),Emit FundTransfer(crowdsaleAddress,msg.sender,TMP_164),TMP_166(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isICOActive())

IRs:
TMP_154(bool) = INTERNAL_CALL, SBITokenCrowdsale.isICOActive()()
TMP_155 = UnaryType.BANG TMP_154 
TMP_156(None) = SOLIDITY_CALL require(bool)(TMP_155)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
crowdsaleAddress.balance > 0

IRs:
TMP_157(uint256) = SOLIDITY_CALL balance(address)(crowdsaleAddress)
TMP_158(bool) = TMP_157 > 0
CONDITION TMP_158""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
revert()()

IRs:
TMP_159(None) = SOLIDITY_CALL revert()()""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
now < preSaleStartDate

IRs:
TMP_160(bool) = now < preSaleStartDate
CONDITION TMP_160""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_161(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
featureDevelopmentAmount = token.balanceOf(saleWalletAddress)

IRs:
TMP_162(uint256) = HIGH_LEVEL_CALL, dest:token(SBIToken), function:balanceOf, arguments:['saleWalletAddress']  
featureDevelopmentAmount(uint256) := TMP_162(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
token.transferFrom(saleWalletAddress,featureDevelopment.addr,featureDevelopmentAmount)

IRs:
REF_50(address) -> featureDevelopment.addr
TMP_163(bool) = HIGH_LEVEL_CALL, dest:token(SBIToken), function:transferFrom, arguments:['saleWalletAddress', 'REF_50', 'featureDevelopmentAmount']  ""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
FundTransfer(crowdsaleAddress,msg.sender,crowdsaleAddress.balance)

IRs:
TMP_164(uint256) = SOLIDITY_CALL balance(address)(crowdsaleAddress)
Emit FundTransfer(crowdsaleAddress,msg.sender,TMP_164)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_166(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
12->1;
}
",0,0,1,0,"onlyOwner();require(bool)(! isICOActive());crowdsaleAddress.balance > 0;revert()();;now < preSaleStartDate;selfdestruct(address)(owner);;featureDevelopmentAmount = token.balanceOf(saleWalletAddress);token.transferFrom(saleWalletAddress,featureDevelopment.addr,featureDevelopmentAmount);FundTransfer(crowdsaleAddress,msg.sender,crowdsaleAddress.balance);selfdestruct(address)(owner)"
./0xed616b87b2b441e4a36d23f27a660ea0f0faccbd_ext.sol,Destructible.destroyAndSend,142,144,"TMP_43(None) = SOLIDITY_CALL selfdestruct(address)(_recipient),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(_recipient)

IRs:
TMP_43(None) = SOLIDITY_CALL selfdestruct(address)(_recipient)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(_recipient)
./0x4145492ad5039b802bd7e58098c8d71706a2cd14_ext.sol,RefundVault.refund,206,212,"REF_12(RefundVault.State) -> State.Refunding,TMP_55(bool) = state == REF_12,TMP_56(None) = SOLIDITY_CALL require(bool)(TMP_55),REF_13(uint256) -> deposited[investor],depositedValue(uint256) := REF_13(uint256),REF_14(uint256) -> deposited[investor],REF_14(uint256) (->deposited) := 0(uint256),Transfer dest:investor value:depositedValue,Emit Refunded(investor,depositedValue)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Refunding)

IRs:
REF_12(RefundVault.State) -> State.Refunding
TMP_55(bool) = state == REF_12
TMP_56(None) = SOLIDITY_CALL require(bool)(TMP_55)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
depositedValue = deposited[investor]

IRs:
REF_13(uint256) -> deposited[investor]
depositedValue(uint256) := REF_13(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
deposited[investor] = 0

IRs:
REF_14(uint256) -> deposited[investor]
REF_14(uint256) (->deposited) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
investor.transfer(depositedValue)

IRs:
Transfer dest:investor value:depositedValue""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Refunded(investor,depositedValue)

IRs:
Emit Refunded(investor,depositedValue)""];
}
",0,0,1,0,"require(bool)(state == State.Refunding);depositedValue = deposited[investor];deposited[investor] = 0;investor.transfer(depositedValue);Refunded(investor,depositedValue)"
./0x4c1ef44b89fdadaea76a6a8004a1b7a5b6a7f603_ext.sol,Destructible.destroy,75,77,"TMP_27(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_27(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0x929e488770ae5218cf4bb5387a390bd36b2135dd_ext.sol,QUIZ_QUIZ.Stop,28,30,"REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3,MODIFIER_CALL, QUIZ_QUIZ.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, QUIZ_QUIZ.isAdmin()()""];
2->1;
}
",0,0,1,0,isAdmin();msg.sender.transfer(this.balance)
./0x36ed5fbd27abf98f7081f1692ce48abab37db172_ext.sol,Quiz_BliZ.Stop,28,30,"REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3,MODIFIER_CALL, Quiz_BliZ.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, Quiz_BliZ.isAdmin()()""];
2->1;
}
",0,0,1,0,isAdmin();msg.sender.transfer(this.balance)
./0xf099c6ecb16575393b3ba6ac57b4ead943353a52_ext.sol,BuddhaTower.takeDevCut,416,419,"Transfer dest:addr4 value:devCut,devCut(uint256) := 0(uint256),MODIFIER_CALL, BuddhaTower.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
addr4.transfer(devCut)

IRs:
Transfer dest:addr4 value:devCut""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
devCut = 0

IRs:
devCut(uint256) := 0(uint256)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, BuddhaTower.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();addr4.transfer(devCut);devCut = 0
./0x7562eacac20093065c37ec6111baae15f152958c_ext.sol,AICrypto.safeWithdrawal,304,309,"TMP_97(bool) = _value == 0,CONDITION TMP_97,TMP_98 = CONVERT this to address,TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98),Transfer dest:owner value:TMP_99,Transfer dest:owner value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_97(bool) = _value == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_98 = CONVERT this to address
TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98)
Transfer dest:owner value:TMP_99""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_value == 0;owner.transfer(address(this).balance);owner.transfer(_value);
./0xd871a7ce9bcf9cfbefbca3ede0ce53ba1787dfc9_ext.sol,try_to_play.Try,4,11,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 2000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 2000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 2000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 2000000000000000000;msg.sender.transfer(this.balance);
./0x708a64eba17df26cd7085c494b725160ba1a6b7d_ext.sol,RefundEscrow.beneficiaryWithdraw,918,921,"REF_279(RefundEscrow.State) -> State.Closed,TMP_459(bool) = state == REF_279,TMP_460(None) = SOLIDITY_CALL require(bool)(TMP_459),TMP_461 = CONVERT this to address,TMP_462(uint256) = SOLIDITY_CALL balance(address)(TMP_461),Transfer dest:beneficiary value:TMP_462","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Closed)

IRs:
REF_279(RefundEscrow.State) -> State.Closed
TMP_459(bool) = state == REF_279
TMP_460(None) = SOLIDITY_CALL require(bool)(TMP_459)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
beneficiary.transfer(address(this).balance)

IRs:
TMP_461 = CONVERT this to address
TMP_462(uint256) = SOLIDITY_CALL balance(address)(TMP_461)
Transfer dest:beneficiary value:TMP_462""];
}
",0,0,1,0,require(bool)(state == State.Closed);beneficiary.transfer(address(this).balance)
./0x6f5c1ed62a4fa41cfc332d81fafd3cd38aacbd85_ext.sol,Vault.kill,88,88,"REF_9(uint256) = SOLIDITY_CALL balance(address)(this),TMP_42(bool) = REF_9 == 0,TMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42),TMP_44(None) = SOLIDITY_CALL selfdestruct(address)(Owner)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(this.balance == 0)

IRs:
REF_9(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_42(bool) = REF_9 == 0
TMP_43(None) = SOLIDITY_CALL require(bool)(TMP_42)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(Owner)

IRs:
TMP_44(None) = SOLIDITY_CALL selfdestruct(address)(Owner)""];
}
",0,0,1,0,require(bool)(this.balance == 0);selfdestruct(address)(Owner)
./0x7229bb50da9c01b28b9f1aace7711605d88afbd3_ext.sol,OysterPrePearl.withdrawFunds,77,81,"REF_1(uint256) = SOLIDITY_CALL balance(address)(this),TMP_14([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E422B520>]) = REF_1 / 2,TMP_15([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E422B520>]) = TMP_14 - 2,payout(uint256) := TMP_15([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E422B520>]),Transfer dest:owner value:payout,Transfer dest:partner value:payout,MODIFIER_CALL, OysterPrePearl.onlyAuth()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
payout = (this.balance / 2) - 2

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_14([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E422B520>]) = REF_1 / 2
TMP_15([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E422B520>]) = TMP_14 - 2
payout(uint256) := TMP_15([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E422B520>])""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(payout)

IRs:
Transfer dest:owner value:payout""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
partner.transfer(payout)

IRs:
Transfer dest:partner value:payout""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyAuth()

IRs:
MODIFIER_CALL, OysterPrePearl.onlyAuth()()""];
4->1;
}
",0,0,1,0,onlyAuth();payout = (this.balance / 2) - 2;owner.transfer(payout);partner.transfer(payout)
./0xeb71e963645f1e76f233f70e1b0815e8f089bbc8_ext.sol,SimplePHXExchange.cancelEthOffer,102,106,"REF_38(uint256) -> ethAddrNdx[msg.sender],TMP_35(bool) = REF_38 == 0,CONDITION TMP_35,REF_40(uint256) -> ethEtherOffered[msg.sender],Transfer dest:msg.sender value:REF_40,INTERNAL_CALL, SimplePHXExchange._cancelEthOffer(address)(msg.sender)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
ethAddrNdx[msg.sender] == 0

IRs:
REF_38(uint256) -> ethAddrNdx[msg.sender]
TMP_35(bool) = REF_38 == 0
CONDITION TMP_35""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: RETURN 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(ethEtherOffered[msg.sender])

IRs:
REF_40(uint256) -> ethEtherOffered[msg.sender]
Transfer dest:msg.sender value:REF_40""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_cancelEthOffer(msg.sender)

IRs:
INTERNAL_CALL, SimplePHXExchange._cancelEthOffer(address)(msg.sender)""];
}
",0,0,1,0,ethAddrNdx[msg.sender] == 0;;;msg.sender.transfer(ethEtherOffered[msg.sender]);_cancelEthOffer(msg.sender)
./0x50a667b73223bc612bcc43200120b5c46ee6b4e9_ext.sol,RC.refundEther,345,349,"REF_66(uint256) -> etherUser[to],Transfer dest:to value:REF_66,REF_67(uint256) -> etherUser[to],REF_67(uint256) (->etherUser) := 0(uint256),REF_68(uint256) -> pendingTokenUser[to],REF_68(uint256) (->pendingTokenUser) := 0(uint256),MODIFIER_CALL, RC.onlyTokenSaleOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
to.transfer(etherUser[to])

IRs:
REF_66(uint256) -> etherUser[to]
Transfer dest:to value:REF_66""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
etherUser[to] = 0

IRs:
REF_67(uint256) -> etherUser[to]
REF_67(uint256) (->etherUser) := 0(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
pendingTokenUser[to] = 0

IRs:
REF_68(uint256) -> pendingTokenUser[to]
REF_68(uint256) (->pendingTokenUser) := 0(uint256)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyTokenSaleOwner()

IRs:
MODIFIER_CALL, RC.onlyTokenSaleOwner()()""];
4->1;
}
",0,0,1,0,onlyTokenSaleOwner();to.transfer(etherUser[to]);etherUser[to] = 0;pendingTokenUser[to] = 0
./0x887834d3b8d450b6bab109c252df3da286d73ce4_ext.sol,MiniMeToken.claimTokens,596,606,"TMP_131(bool) = _token == 0,CONDITION TMP_131,REF_58(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:controller value:REF_58,TMP_133 = CONVERT _token to ERC20Token,token(ERC20Token) := TMP_133(ERC20Token),TMP_134(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_134(uint256),TMP_135(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:transfer, arguments:['controller', 'balance']  ,Emit ClaimedTokens(_token,controller,balance),MODIFIER_CALL, Controlled.onlyController()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_131(bool) = _token == 0
CONDITION TMP_131""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_58(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_58""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
token = ERC20Token(_token)

IRs:
TMP_133 = CONVERT _token to ERC20Token
token(ERC20Token) := TMP_133(ERC20Token)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_134(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_134(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_135(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:transfer, arguments:['controller', 'balance']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()""];
9->1;
}
",0,0,1,0,"onlyController();_token == 0x0;controller.transfer(this.balance);;;token = ERC20Token(_token);balance = token.balanceOf(this);token.transfer(controller,balance);ClaimedTokens(_token,controller,balance)"
./0xa2388330bcb4b3d5f6395a3f5999fecb73960af3_ext.sol,BTRCTOKEN.kill,85,88,"TMP_6(bool) = workingState == False,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),TMP_8(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, BTRCTOKEN.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(workingState == false)

IRs:
TMP_6(bool) = workingState == False
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_8(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, BTRCTOKEN.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();require(bool)(workingState == false);selfdestruct(address)(owner)
./0x37e3efe76ee6cec50559bc07565eaf36ddc05467_ext.sol,ControlledToken.claimTokens,220,230,"TMP_54(bool) = _token == 0,CONDITION TMP_54,REF_24(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:controller value:REF_24,TMP_56 = CONVERT _token to ControlledToken,token(ControlledToken) := TMP_56(ControlledToken),TMP_57(uint256) = HIGH_LEVEL_CALL, dest:token(ControlledToken), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_57(uint256),TMP_58(bool) = HIGH_LEVEL_CALL, dest:token(ControlledToken), function:transfer, arguments:['controller', 'balance']  ,Emit ClaimedTokens(_token,controller,balance),MODIFIER_CALL, Controlled.onlyController()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_54(bool) = _token == 0
CONDITION TMP_54""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_24(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_24""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
token = ControlledToken(_token)

IRs:
TMP_56 = CONVERT _token to ControlledToken
token(ControlledToken) := TMP_56(ControlledToken)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_57(uint256) = HIGH_LEVEL_CALL, dest:token(ControlledToken), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_57(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_58(bool) = HIGH_LEVEL_CALL, dest:token(ControlledToken), function:transfer, arguments:['controller', 'balance']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()""];
9->1;
}
",0,0,1,0,"onlyController();_token == 0x0;controller.transfer(this.balance);;;token = ControlledToken(_token);balance = token.balanceOf(this);token.transfer(controller,balance);ClaimedTokens(_token,controller,balance)"
./0x67d9be79f2f13b7d3c9684d3782bc646f5ba6d63_ext.sol,MilinfinityToken.withdraw,300,303,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, MilinfinityToken.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MilinfinityToken.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0xd0792ac0de7ef31197c5f452b21a34389ecc725f_ext.sol,CryptoWaterMargin.withdrawAll,132,134,"REF_4(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_4,MODIFIER_CALL, CryptoWaterMargin.onlyAdmins()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_4(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_4""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyAdmins()

IRs:
MODIFIER_CALL, CryptoWaterMargin.onlyAdmins()()""];
2->1;
}
",0,0,1,0,onlyAdmins();msg.sender.transfer(this.balance)
./0xc7db6a0e78efb4d64bb06359faf83420f04cfb52_ext.sol,play_IQUIZ.Stop,35,37,"REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3,MODIFIER_CALL, play_IQUIZ.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, play_IQUIZ.isAdmin()()""];
2->1;
}
",0,0,1,0,isAdmin();msg.sender.transfer(this.balance)
./0xa21c9a3ae47103b1fd1dfa04766c4d00c19e1ff6_ext.sol,CryptoOscarsToken._payout,359,365,"TMP_89 = CONVERT 0 to address,TMP_90(bool) = _to == TMP_89,CONDITION TMP_90,REF_32(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:ceoAddress value:REF_32,REF_34(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:_to value:REF_34","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_to == address(0)

IRs:
TMP_89 = CONVERT 0 to address
TMP_90(bool) = _to == TMP_89
CONDITION TMP_90""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ceoAddress.transfer(this.balance)

IRs:
REF_32(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:ceoAddress value:REF_32""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_to.transfer(this.balance)

IRs:
REF_34(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:_to value:REF_34""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,_to == address(0);ceoAddress.transfer(this.balance);_to.transfer(this.balance);
./0x42fbfb1d1994a99de3bc52c2172d8370cd3d6671_ext.sol,Destructible.destroy,259,261,"TMP_57(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_57(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0x1fbf025ad94dde79f88732f79966a9a435f2772f_ext.sol,BLITZQUIZ.StopGame,34,40,"TMP_9(bool) = msg.sender == questionSender,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_9(bool) = msg.sender == questionSender
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0xef86db910c71ffa3c80233bc9108dc51ad1e008a_ext.sol,CommonWallet.sendEtherTo,67,72,"REF_20(uint256) -> etherBalance[msg.sender],TMP_18(bool) = REF_20 >= amount,TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18),TMP_20(bool) = to_ != msg.sender,TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20),Transfer dest:to_ value:amount,REF_22(uint256) -> etherBalance[msg.sender],REF_23(uint256) -> etherBalance[msg.sender],TMP_23(uint256) = INTERNAL_CALL, CommonWallet.safeSub(uint256,uint256)(REF_23,amount),REF_22(uint256) (->etherBalance) := TMP_23(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(etherBalance[msg.sender] >= amount)

IRs:
REF_20(uint256) -> etherBalance[msg.sender]
TMP_18(bool) = REF_20 >= amount
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(to_ != msg.sender)

IRs:
TMP_20(bool) = to_ != msg.sender
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
to_.transfer(amount)

IRs:
Transfer dest:to_ value:amount""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
etherBalance[msg.sender] = safeSub(etherBalance[msg.sender],amount)

IRs:
REF_22(uint256) -> etherBalance[msg.sender]
REF_23(uint256) -> etherBalance[msg.sender]
TMP_23(uint256) = INTERNAL_CALL, CommonWallet.safeSub(uint256,uint256)(REF_23,amount)
REF_22(uint256) (->etherBalance) := TMP_23(uint256)""];
}
",0,0,1,0,"require(bool)(etherBalance[msg.sender] >= amount);require(bool)(to_ != msg.sender);to_.transfer(amount);etherBalance[msg.sender] = safeSub(etherBalance[msg.sender],amount)"
./0xaa3fbfaf03cd50e6a44d27d10eb14333d1c02e52_ext.sol,ETH_GAME.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x6543cde961213e82001594bf4c34706579ce34ec_ext.sol,RefundEscrow.beneficiaryWithdraw,911,914,"REF_190(RefundEscrow.State) -> State.Closed,TMP_400(bool) = state == REF_190,TMP_401(None) = SOLIDITY_CALL require(bool)(TMP_400),TMP_402 = CONVERT this to address,TMP_403(uint256) = SOLIDITY_CALL balance(address)(TMP_402),Transfer dest:beneficiary value:TMP_403","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Closed)

IRs:
REF_190(RefundEscrow.State) -> State.Closed
TMP_400(bool) = state == REF_190
TMP_401(None) = SOLIDITY_CALL require(bool)(TMP_400)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
beneficiary.transfer(address(this).balance)

IRs:
TMP_402 = CONVERT this to address
TMP_403(uint256) = SOLIDITY_CALL balance(address)(TMP_402)
Transfer dest:beneficiary value:TMP_403""];
}
",0,0,1,0,require(bool)(state == State.Closed);beneficiary.transfer(address(this).balance)
./0x5b8aeecf9958a76054dae8bdc98b44ff9007d4ef_ext.sol,SRNMagicBox.withDrawBalance,1733,1740,"TMP_966 = CONVERT this to address,TMP_967(uint256) = SOLIDITY_CALL balance(address)(TMP_966),TMP_968(bool) = TMP_967 >= amount,TMP_969(None) = SOLIDITY_CALL require(bool)(TMP_968),TMP_970(bool) = amount == 0,CONDITION TMP_970,TMP_971 = CONVERT this to address,TMP_972(uint256) = SOLIDITY_CALL balance(address)(TMP_971),Transfer dest:CFO value:TMP_972,Transfer dest:CFO value:amount,MODIFIER_CALL, AccessControl.onlyCFO()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(address(this).balance >= amount)

IRs:
TMP_966 = CONVERT this to address
TMP_967(uint256) = SOLIDITY_CALL balance(address)(TMP_966)
TMP_968(bool) = TMP_967 >= amount
TMP_969(None) = SOLIDITY_CALL require(bool)(TMP_968)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
amount == 0

IRs:
TMP_970(bool) = amount == 0
CONDITION TMP_970""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
CFO.transfer(address(this).balance)

IRs:
TMP_971 = CONVERT this to address
TMP_972(uint256) = SOLIDITY_CALL balance(address)(TMP_971)
Transfer dest:CFO value:TMP_972""];
3->5;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
CFO.transfer(amount)

IRs:
Transfer dest:CFO value:amount""];
4->5;
5[label=""Node Type: END_IF 5
""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyCFO()

IRs:
MODIFIER_CALL, AccessControl.onlyCFO()()""];
6->1;
}
",0,0,1,0,onlyCFO();require(bool)(address(this).balance >= amount);amount == 0;CFO.transfer(address(this).balance);CFO.transfer(amount);
./0x01bbef7b099128a2675d619567ab449ec9a04fe1_ext.sol,ether_game.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0xc801e2ca666fdfcb43cf29b972d7f3731436e4a1_ext.sol,MyAdvancedToken.getEth,254,256,Transfer dest:owner value:num,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(num)

IRs:
Transfer dest:owner value:num""];
}
",0,0,1,0,owner.transfer(num)
./0x723aaf922709819c25344b81901dd8a9c84c0b89_ext.sol,RefundVault.close,142,147,"REF_7(RefundVault.State) -> State.Active,TMP_48(bool) = state == REF_7,TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48),REF_8(RefundVault.State) -> State.Closed,state(RefundVault.State) := REF_8(RefundVault.State),Emit Closed(),REF_10(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:wallet value:REF_10,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_7(RefundVault.State) -> State.Active
TMP_48(bool) = state == REF_7
TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
state = State.Closed

IRs:
REF_8(RefundVault.State) -> State.Closed
state(RefundVault.State) := REF_8(RefundVault.State)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Closed()

IRs:
Emit Closed()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
wallet.transfer(this.balance)

IRs:
REF_10(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:wallet value:REF_10""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();require(bool)(state == State.Active);state = State.Closed;Closed();wallet.transfer(this.balance)
./0xe34cae5cdc42afd4c68727a936908918b5faa675_ext.sol,MiniMeToken.claimTokens,514,524,"TMP_134(bool) = _token == 0,CONDITION TMP_134,REF_58(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:controller value:REF_58,TMP_136 = CONVERT _token to MiniMeToken,token(MiniMeToken) := TMP_136(MiniMeToken),TMP_137(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_137(uint256),TMP_138(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  ,Emit ClaimedTokens(_token,controller,balance),MODIFIER_CALL, Controlled.onlyController()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_134(bool) = _token == 0
CONDITION TMP_134""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_58(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_58""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
token = MiniMeToken(_token)

IRs:
TMP_136 = CONVERT _token to MiniMeToken
token(MiniMeToken) := TMP_136(MiniMeToken)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_137(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_137(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_138(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()""];
9->1;
}
",0,0,1,0,"onlyController();_token == 0x0;controller.transfer(this.balance);;;token = MiniMeToken(_token);balance = token.balanceOf(this);token.transfer(controller,balance);ClaimedTokens(_token,controller,balance)"
./0x6bd26bb09c992e09d2156b48f723e56e52eead9c_ext.sol,MiniMeToken.fallback,546,549,"TMP_130(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller),TMP_131(None) = SOLIDITY_CALL require(bool)(TMP_130),TMP_132 = CONVERT controller to TokenController,TMP_134(bool) = HIGH_LEVEL_CALL, dest:TMP_132(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value ,TMP_135(None) = SOLIDITY_CALL require(bool)(TMP_134)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isContract(controller))

IRs:
TMP_130(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)
TMP_131(None) = SOLIDITY_CALL require(bool)(TMP_130)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))

IRs:
TMP_132 = CONVERT controller to TokenController
TMP_134(bool) = HIGH_LEVEL_CALL, dest:TMP_132(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value 
TMP_135(None) = SOLIDITY_CALL require(bool)(TMP_134)""];
}
",0,0,1,0,require(bool)(isContract(controller));require(bool)(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))
./0xee53ca3ae3d296c0f2a128138d12a0a3a60fa1f5_ext.sol,ZethrShell.WithdrawToBankroll,159,163,"REF_15(address) -> UsedBankrollAddresses[0],TMP_27 = CONVERT REF_15 to address,TMP_28 = CONVERT this to address,TMP_29(uint256) = SOLIDITY_CALL balance(address)(TMP_28),Transfer dest:TMP_27 value:TMP_29","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
address(UsedBankrollAddresses[0]).transfer(address(this).balance)

IRs:
REF_15(address) -> UsedBankrollAddresses[0]
TMP_27 = CONVERT REF_15 to address
TMP_28 = CONVERT this to address
TMP_29(uint256) = SOLIDITY_CALL balance(address)(TMP_28)
Transfer dest:TMP_27 value:TMP_29""];
}
",0,0,1,0,address(UsedBankrollAddresses[0]).transfer(address(this).balance)
./0x483a816f1672e276416d7e18e905226f15c7e698_ext.sol,eth_GAME.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x28e0d54349c00607505aadc713147140fb60ea12_ext.sol,TheQuizGame.Try,5,12,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x0174312e4aef436606ffdeb4d05d22fb68f36ba0_ext.sol,LatiumSeller.withdrawEther,106,114,"TMP_35(bool) = _amount == 0,CONDITION TMP_35,_amount(uint256) := _etherAmount(uint256),TMP_36(bool) = _amount > 0,TMP_37(bool) = _etherAmount >= _amount,TMP_38(bool) = TMP_36 && TMP_37,TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38),_etherAmount(uint256) = _etherAmount - _amount,Transfer dest:msg.sender value:_amount,MODIFIER_CALL, LatiumSeller.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: IF 1

EXPRESSION:
_amount == 0

IRs:
TMP_35(bool) = _amount == 0
CONDITION TMP_35""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_amount = _etherAmount

IRs:
_amount(uint256) := _etherAmount(uint256)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_amount > 0 && _etherAmount >= _amount)

IRs:
TMP_36(bool) = _amount > 0
TMP_37(bool) = _etherAmount >= _amount
TMP_38(bool) = TMP_36 && TMP_37
TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_etherAmount -= _amount

IRs:
_etherAmount(uint256) = _etherAmount - _amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
msg.sender.transfer(_amount)

IRs:
Transfer dest:msg.sender value:_amount""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, LatiumSeller.onlyOwner()()""];
7->1;
}
",0,0,1,0,onlyOwner();_amount == 0;_amount = _etherAmount;;require(bool)(_amount > 0 && _etherAmount >= _amount);_etherAmount -= _amount;msg.sender.transfer(_amount)
./0x64d581770b541b5609140232fc12f47bbe0fe6bc_ext.sol,MonetoSale.proxyTakeEtherBack,364,377,"TMP_162(bool) = receiverAddress != 0,TMP_163(None) = SOLIDITY_CALL require(bool)(TMP_162),REF_66(uint256) -> icoBuyers[receiverAddress],TMP_164(bool) = REF_66 == 0,CONDITION TMP_164,RETURN False,REF_67(uint256) -> icoBuyers[receiverAddress],amount(uint256) := REF_67(uint256),REF_68(uint256) -> icoBuyers[receiverAddress],REF_68(uint256) (->icoBuyers) := 0(uint256),Transfer dest:receiverAddress value:amount,REF_70(uint256) -> icoBuyers[receiverAddress],TMP_166(bool) = REF_70 == 0,TMP_167(None) = SOLIDITY_CALL assert(bool)(TMP_166),RETURN True,REF_71(MonetoSale.Stages) -> Stages.Canceled,MODIFIER_CALL, MonetoSale.atStage(MonetoSale.Stages)(REF_71)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(receiverAddress != 0x0)

IRs:
TMP_162(bool) = receiverAddress != 0
TMP_163(None) = SOLIDITY_CALL require(bool)(TMP_162)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
icoBuyers[receiverAddress] == 0

IRs:
REF_66(uint256) -> icoBuyers[receiverAddress]
TMP_164(bool) = REF_66 == 0
CONDITION TMP_164""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3

EXPRESSION:
false

IRs:
RETURN False""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
amount = icoBuyers[receiverAddress]

IRs:
REF_67(uint256) -> icoBuyers[receiverAddress]
amount(uint256) := REF_67(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
icoBuyers[receiverAddress] = 0

IRs:
REF_68(uint256) -> icoBuyers[receiverAddress]
REF_68(uint256) (->icoBuyers) := 0(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
receiverAddress.transfer(amount)

IRs:
Transfer dest:receiverAddress value:amount""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
assert(bool)(icoBuyers[receiverAddress] == 0)

IRs:
REF_70(uint256) -> icoBuyers[receiverAddress]
TMP_166(bool) = REF_70 == 0
TMP_167(None) = SOLIDITY_CALL assert(bool)(TMP_166)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
atStage(Stages.Canceled)

IRs:
REF_71(MonetoSale.Stages) -> Stages.Canceled
MODIFIER_CALL, MonetoSale.atStage(MonetoSale.Stages)(REF_71)""];
10->1;
}
",0,0,1,0,atStage(Stages.Canceled);require(bool)(receiverAddress != 0x0);icoBuyers[receiverAddress] == 0;false;;amount = icoBuyers[receiverAddress];icoBuyers[receiverAddress] = 0;receiverAddress.transfer(amount);assert(bool)(icoBuyers[receiverAddress] == 0);true
./0x6f4e647f553397dc999382ad3a9c5336c5de27aa_ext.sol,YouCollectBase._payout,196,202,"TMP_81 = CONVERT 0 to address,TMP_82(bool) = _to == TMP_81,CONDITION TMP_82,Transfer dest:ceoAddress value:amount,Transfer dest:_to value:amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_to == address(0)

IRs:
TMP_81 = CONVERT 0 to address
TMP_82(bool) = _to == TMP_81
CONDITION TMP_82""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ceoAddress.transfer(amount)

IRs:
Transfer dest:ceoAddress value:amount""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_to.transfer(amount)

IRs:
Transfer dest:_to value:amount""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,_to == address(0);ceoAddress.transfer(amount);_to.transfer(amount);
./0x6bd26bb09c992e09d2156b48f723e56e52eead9c_ext.sol,MiniMeToken.claimTokens,559,569,"TMP_136(bool) = _token == 0,CONDITION TMP_136,REF_58(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:controller value:REF_58,TMP_138 = CONVERT _token to MiniMeToken,token(MiniMeToken) := TMP_138(MiniMeToken),TMP_139(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_139(uint256),TMP_140(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  ,Emit ClaimedTokens(_token,controller,balance),MODIFIER_CALL, Controlled.onlyController()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_136(bool) = _token == 0
CONDITION TMP_136""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_58(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_58""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
token = MiniMeToken(_token)

IRs:
TMP_138 = CONVERT _token to MiniMeToken
token(MiniMeToken) := TMP_138(MiniMeToken)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_139(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_139(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_140(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()""];
9->1;
}
",0,0,1,0,"onlyController();_token == 0x0;controller.transfer(this.balance);;;token = MiniMeToken(_token);balance = token.balanceOf(this);token.transfer(controller,balance);ClaimedTokens(_token,controller,balance)"
./0xa23a42b2bb161b0ab7bbcbd72bea54952e5299fc_ext.sol,zeepay.withdraw,299,302,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, zeepay.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, zeepay.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x33dcb440beb0c640fa75ac297bc2e048e6853844_ext.sol,Bonds.withdrawPart,282,294,"_customerAddress(address) := msg.sender(address),REF_110(uint256) -> ownerAccounts[_customerAddress],TMP_62(bool) = REF_110 > 0,TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62),REF_111(uint256) -> ownerAccounts[_customerAddress],TMP_64(bool) = _amount <= REF_111,TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64),REF_112(uint256) -> ownerAccounts[_customerAddress],REF_114(uint256) -> ownerAccounts[_customerAddress],TMP_66(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_114', '_amount'] ,REF_112(uint256) (->ownerAccounts) := TMP_66(uint256),Transfer dest:_customerAddress value:_amount,Emit onWithdraw(_customerAddress,_amount),MODIFIER_CALL, Bonds.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(ownerAccounts[_customerAddress] > 0)

IRs:
REF_110(uint256) -> ownerAccounts[_customerAddress]
TMP_62(bool) = REF_110 > 0
TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_amount <= ownerAccounts[_customerAddress])

IRs:
REF_111(uint256) -> ownerAccounts[_customerAddress]
TMP_64(bool) = _amount <= REF_111
TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownerAccounts[_customerAddress] = SafeMath.sub(ownerAccounts[_customerAddress],_amount)

IRs:
REF_112(uint256) -> ownerAccounts[_customerAddress]
REF_114(uint256) -> ownerAccounts[_customerAddress]
TMP_66(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_114', '_amount'] 
REF_112(uint256) (->ownerAccounts) := TMP_66(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_customerAddress.transfer(_amount)

IRs:
Transfer dest:_customerAddress value:_amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onWithdraw(_customerAddress,_amount)

IRs:
Emit onWithdraw(_customerAddress,_amount)""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Bonds.onlyOwner()()""];
7->1;
}
",0,0,1,0,"onlyOwner();_customerAddress = msg.sender;require(bool)(ownerAccounts[_customerAddress] > 0);require(bool)(_amount <= ownerAccounts[_customerAddress]);ownerAccounts[_customerAddress] = SafeMath.sub(ownerAccounts[_customerAddress],_amount);_customerAddress.transfer(_amount);onWithdraw(_customerAddress,_amount)"
./0x549b38e8e5fb1ba4acd4187d8b7c8a04deb53206_ext.sol,LotteryAdmin.withdraw,72,74,"Transfer dest:owner value:_value,MODIFIER_CALL, LotteryAdmin.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, LotteryAdmin.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();owner.transfer(_value)
./0xeafd8b734e32aec64c4b445e9da401427ef63a3a_ext.sol,PullPayment.withdrawPayments,57,68,"payee(address) := msg.sender(address),REF_0(uint256) -> payments[payee],payment(uint256) := REF_0(uint256),TMP_13(bool) = payment != 0,TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13),TMP_15 = CONVERT this to address,TMP_16(uint256) = SOLIDITY_CALL balance(address)(TMP_15),TMP_17(bool) = TMP_16 >= payment,TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17),TMP_19(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalPayments', 'payment'] ,totalPayments(uint256) := TMP_19(uint256),REF_2(uint256) -> payments[payee],REF_2(uint256) (->payments) := 0(uint256),Transfer dest:payee value:payment","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
payee = msg.sender

IRs:
payee(address) := msg.sender(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
payment = payments[payee]

IRs:
REF_0(uint256) -> payments[payee]
payment(uint256) := REF_0(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(payment != 0)

IRs:
TMP_13(bool) = payment != 0
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(address(this).balance >= payment)

IRs:
TMP_15 = CONVERT this to address
TMP_16(uint256) = SOLIDITY_CALL balance(address)(TMP_15)
TMP_17(bool) = TMP_16 >= payment
TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalPayments = totalPayments.sub(payment)

IRs:
TMP_19(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalPayments', 'payment'] 
totalPayments(uint256) := TMP_19(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
payments[payee] = 0

IRs:
REF_2(uint256) -> payments[payee]
REF_2(uint256) (->payments) := 0(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
payee.transfer(payment)

IRs:
Transfer dest:payee value:payment""];
}
",0,0,1,0,payee = msg.sender;payment = payments[payee];require(bool)(payment != 0);require(bool)(address(this).balance >= payment);totalPayments = totalPayments.sub(payment);payments[payee] = 0;payee.transfer(payment)
./0x013620bf5142f9d8487e92c1d514c38e1b086613_ext.sol,Etherumble.destroykill,118,120,"TMP_25(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Etherumble.isOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_25(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isOwner()

IRs:
MODIFIER_CALL, Etherumble.isOwner()()""];
2->1;
}
",0,0,1,0,isOwner();selfdestruct(address)(owner)
./0x53f671aef0a803085f6e3a6c215dd88454394f3e_ext.sol,WorldCupWinner.shareAmount,86,90,"TMP_21 = CONVERT this to address,TMP_22(uint256) = SOLIDITY_CALL balance(address)(TMP_21),TMP_23(bool) = TMP_22 >= amount,TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23),Transfer dest:winner value:amount,TMP_26 = CONVERT now to uint256,Emit ShareBonus(winner,TMP_26,_buyerType,_gameID,amount),MODIFIER_CALL, WorldCupWinner.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(address(this).balance >= amount)

IRs:
TMP_21 = CONVERT this to address
TMP_22(uint256) = SOLIDITY_CALL balance(address)(TMP_21)
TMP_23(bool) = TMP_22 >= amount
TMP_24(None) = SOLIDITY_CALL require(bool)(TMP_23)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
winner.transfer(amount)

IRs:
Transfer dest:winner value:amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ShareBonus(winner,uint256(now),_buyerType,_gameID,amount)

IRs:
TMP_26 = CONVERT now to uint256
Emit ShareBonus(winner,TMP_26,_buyerType,_gameID,amount)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, WorldCupWinner.onlyOwner()()""];
4->1;
}
",0,0,1,0,"onlyOwner();require(bool)(address(this).balance >= amount);winner.transfer(amount);ShareBonus(winner,uint256(now),_buyerType,_gameID,amount)"
./0x28a9824cc26361fe97417a60d5bd1225853db46d_ext.sol,TTS.getEth,119,127,"TMP_27(bool) = _price > 0,CONDITION TMP_27,TMP_28 = CONVERT this to address,TMP_29(uint256) = SOLIDITY_CALL balance(address)(TMP_28),TMP_30(bool) = TMP_29 >= _price,CONDITION TMP_30,Transfer dest:owner value:_price,TMP_32 = CONVERT this to address,TMP_33(uint256) = SOLIDITY_CALL balance(address)(TMP_32),Transfer dest:owner value:TMP_33,MODIFIER_CALL, TTS.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: IF 1

EXPRESSION:
_price > 0

IRs:
TMP_27(bool) = _price > 0
CONDITION TMP_27""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
address(this).balance >= _price

IRs:
TMP_28 = CONVERT this to address
TMP_29(uint256) = SOLIDITY_CALL balance(address)(TMP_28)
TMP_30(bool) = TMP_29 >= _price
CONDITION TMP_30""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_price)

IRs:
Transfer dest:owner value:_price""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->6;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_32 = CONVERT this to address
TMP_33(uint256) = SOLIDITY_CALL balance(address)(TMP_32)
Transfer dest:owner value:TMP_33""];
5->6;
6[label=""Node Type: END_IF 6
""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, TTS.onlyOwner()()""];
7->1;
}
",0,0,1,0,onlyOwner();_price > 0;address(this).balance >= _price;owner.transfer(address(this).balance);owner.transfer(_price);;
./0x26bf81f017a7149576dc5d82323172fcae9fd469_ext.sol,PhxGo.registerVIP,169,174,"TMP_59(bool) = msg.value >= VIPFee,TMP_60(None) = SOLIDITY_CALL require(bool)(TMP_59),TMP_61(address) = INTERNAL_CALL, PhxGo.getReceiverAddress()(),_receiverAddress(address) := TMP_61(address),TMP_62 = SEND dest:_receiverAddress value:msg.value,TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62),REF_35(bool) -> vipList[msg.sender],REF_35(bool) (->vipList) := True(bool)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= VIPFee)

IRs:
TMP_59(bool) = msg.value >= VIPFee
TMP_60(None) = SOLIDITY_CALL require(bool)(TMP_59)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
_receiverAddress = getReceiverAddress()

IRs:
TMP_61(address) = INTERNAL_CALL, PhxGo.getReceiverAddress()()
_receiverAddress(address) := TMP_61(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_receiverAddress.send(msg.value))

IRs:
TMP_62 = SEND dest:_receiverAddress value:msg.value
TMP_63(None) = SOLIDITY_CALL require(bool)(TMP_62)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
vipList[msg.sender] = true

IRs:
REF_35(bool) -> vipList[msg.sender]
REF_35(bool) (->vipList) := True(bool)""];
}
",0,0,1,0,require(bool)(msg.value >= VIPFee);_receiverAddress = getReceiverAddress();require(bool)(_receiverAddress.send(msg.value));vipList[msg.sender] = true
./0xf1171e1e8df34ab97832342c7cbf04d9121a1ac3_ext.sol,CSportsAuth.withdrawBalance,167,169,"TMP_31 = CONVERT this to address,TMP_32(uint256) = SOLIDITY_CALL balance(address)(TMP_31),Transfer dest:cfoAddress value:TMP_32,MODIFIER_CALL, CSportsAuth.onlyCFO()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
cfoAddress.transfer(address(this).balance)

IRs:
TMP_31 = CONVERT this to address
TMP_32(uint256) = SOLIDITY_CALL balance(address)(TMP_31)
Transfer dest:cfoAddress value:TMP_32""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyCFO()

IRs:
MODIFIER_CALL, CSportsAuth.onlyCFO()()""];
2->1;
}
",0,0,1,0,onlyCFO();cfoAddress.transfer(address(this).balance)
./0x38c83b225eb17d44f33f8bb3bdc23d86733838db_ext.sol,try_to_play.Try,5,12,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0xed710216da4b1416a78768790ca9aa3633ca110f_ext.sol,PLAY_AND_GAIN.Play,23,32,"TMP_2(bool) = msg.sender == tx.origin,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),TMP_4(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_5(bool) = responseHash == TMP_4,TMP_6(bool) = msg.value > 1000000000000000000,TMP_7(bool) = TMP_5 && TMP_6,CONDITION TMP_7,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_2(bool) = msg.sender == tx.origin
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_4(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_5(bool) = responseHash == TMP_4
TMP_6(bool) = msg.value > 1000000000000000000
TMP_7(bool) = TMP_5 && TMP_6
CONDITION TMP_7""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0xf070aaa3149c73626d543e02d4c8826c1762ea71_ext.sol,LUX.withdraw,303,306,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, LUX.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, LUX.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x264979ffd35d608e69b69681f4bbcba9877e6c4a_ext.sol,qz_game.StopGame,29,31,"TMP_9(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender),MODIFIER_CALL, qz_game.onlyQuestionSender()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(msg.sender)

IRs:
TMP_9(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyQuestionSender()

IRs:
MODIFIER_CALL, qz_game.onlyQuestionSender()()""];
2->1;
}
",0,0,1,0,onlyQuestionSender();selfdestruct(address)(msg.sender)
./0xbf008cb93c2b19c3ae0db4149bcfa465b2ea0888_ext.sol,GameTable.safeWithdrawal,173,209,"TMP_86(bool) = gameid < 0,TMP_87(bool) = gameid > 999999999999999999999999999999999999,TMP_88(bool) = TMP_86 || TMP_87,CONDITION TMP_88,TMP_89(None) = SOLIDITY_CALL revert()(),REF_142(GameTable.Game) -> games[gameid],REF_143(uint256) -> REF_142.openTime,TMP_90(bool) = now <= REF_143,CONDITION TMP_90,TMP_91(None) = SOLIDITY_CALL revert()(),REF_144(GameTable.Game) -> games[gameid],REF_145(uint256) -> REF_144.runingStatus,TMP_92(bool) = REF_145 != 2,CONDITION TMP_92,TMP_93(None) = SOLIDITY_CALL revert()(),REF_146(GameTable.Game) -> games[gameid],REF_147(uint256) -> REF_146.winner,winnerID(uint256) := REF_147(uint256),TMP_94(bool) = winnerID > 0,TMP_95(bool) = winnerID < 9999,TMP_96(bool) = TMP_94 && TMP_95,CONDITION TMP_96,REF_148(GameTable.Game) -> games[gameid],REF_149(uint256) -> REF_148.runingStatus,REF_149(uint256) (->games) := 3(uint256),REF_150(GameTable.Game) -> games[gameid],REF_151(mapping(uint256 => GameTable.Option)) -> REF_150.options,REF_152(GameTable.Option) -> REF_151[winnerID],REF_153(uint256) -> REF_152.amount,totalWinpool(uint256) := REF_153(uint256),REF_154(GameTable.Game) -> games[gameid],REF_155(uint256) -> REF_154.amount,TMP_97(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_155', 'totalWinpool'] ,totalWinpool(uint256) := TMP_97(uint256),TMP_98(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['totalWinpool', '15'] ,fee(uint256) := TMP_98(uint256),TMP_99(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['fee', '1000'] ,fee(uint256) := TMP_99(uint256),TMP_100(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalWinpool', 'fee'] ,reward(uint256) := TMP_100(uint256),REF_160(GameTable.Game) -> games[gameid],REF_161(mapping(uint256 => GameTable.Option)) -> REF_160.options,REF_162(GameTable.Option) -> REF_161[winnerID],REF_163(uint256) -> REF_162.amount,TMP_101(bool) = REF_163 < 100000000000,CONDITION TMP_101,Transfer dest:gameDeveloper value:reward,TMP_103(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['reward', '100'] ,ratio(uint256) := TMP_103(uint256),REF_167(GameTable.Game) -> games[gameid],REF_168(mapping(uint256 => GameTable.Option)) -> REF_167.options,REF_169(GameTable.Option) -> REF_168[winnerID],REF_170(uint256) -> REF_169.amount,TMP_104(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['ratio', 'REF_170'] ,ratio(uint256) := TMP_104(uint256),totalReturn(uint256) := 0(uint256),i(uint256) := 0(uint256),REF_171(GameTable.Game) -> games[gameid],REF_172(mapping(uint256 => GameTable.Option)) -> REF_171.options,REF_173(GameTable.Option) -> REF_172[winnerID],REF_174(uint256) -> REF_173.numPlayers,TMP_105(bool) = i < REF_174,CONDITION TMP_105,REF_175(GameTable.Game) -> games[gameid],REF_176(mapping(uint256 => GameTable.Option)) -> REF_175.options,REF_177(GameTable.Option) -> REF_176[winnerID],REF_178(mapping(uint256 => GameTable.Player)) -> REF_177.players,REF_179(GameTable.Player) -> REF_178[i],REF_180(uint256) -> REF_179.amount,TMP_106(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_180', 'ratio'] ,returnWinAmount(uint256) := TMP_106(uint256),TMP_107(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['returnWinAmount', '100'] ,returnWinAmount(uint256) := TMP_107(uint256),REF_183(GameTable.Game) -> games[gameid],REF_184(mapping(uint256 => GameTable.Option)) -> REF_183.options,REF_185(GameTable.Option) -> REF_184[winnerID],REF_186(mapping(uint256 => GameTable.Player)) -> REF_185.players,REF_187(GameTable.Player) -> REF_186[i],REF_188(uint256) -> REF_187.amount,TMP_108(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_188', 'returnWinAmount'] ,returnWinAmount(uint256) := TMP_108(uint256),REF_190(GameTable.Game) -> games[gameid],REF_191(mapping(uint256 => GameTable.Option)) -> REF_190.options,REF_192(GameTable.Option) -> REF_191[winnerID],REF_193(mapping(uint256 => GameTable.Player)) -> REF_192.players,REF_194(GameTable.Player) -> REF_193[i],REF_195(address) -> REF_194.addr,Transfer dest:REF_195 value:returnWinAmount,REF_197(GameTable.Game) -> games[gameid],REF_198(mapping(uint256 => GameTable.Option)) -> REF_197.options,REF_199(GameTable.Option) -> REF_198[winnerID],REF_200(mapping(uint256 => GameTable.Player)) -> REF_199.players,REF_201(GameTable.Player) -> REF_200[i],REF_202(uint256) -> REF_201.profit,REF_202(uint256) (->games) := returnWinAmount(uint256),TMP_110(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalReturn', 'returnWinAmount'] ,totalReturn(uint256) := TMP_110(uint256),TMP_111(uint256) := i(uint256),i(uint256) = i + 1,REF_204(GameTable.Game) -> games[gameid],REF_205(uint256) -> REF_204.amount,TMP_112(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_205', 'totalReturn'] ,totalFee(uint256) := TMP_112(uint256),Transfer dest:gameDeveloper value:totalFee","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
(gameid < 0) || (gameid > 999999999999999999999999999999999999)

IRs:
TMP_86(bool) = gameid < 0
TMP_87(bool) = gameid > 999999999999999999999999999999999999
TMP_88(bool) = TMP_86 || TMP_87
CONDITION TMP_88""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_89(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
now <= games[gameid].openTime

IRs:
REF_142(GameTable.Game) -> games[gameid]
REF_143(uint256) -> REF_142.openTime
TMP_90(bool) = now <= REF_143
CONDITION TMP_90""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
revert()()

IRs:
TMP_91(None) = SOLIDITY_CALL revert()()""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
games[gameid].runingStatus != 2

IRs:
REF_144(GameTable.Game) -> games[gameid]
REF_145(uint256) -> REF_144.runingStatus
TMP_92(bool) = REF_145 != 2
CONDITION TMP_92""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
revert()()

IRs:
TMP_93(None) = SOLIDITY_CALL revert()()""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
winnerID = games[gameid].winner

IRs:
REF_146(GameTable.Game) -> games[gameid]
REF_147(uint256) -> REF_146.winner
winnerID(uint256) := REF_147(uint256)""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
winnerID > 0 && winnerID < 9999

IRs:
TMP_94(bool) = winnerID > 0
TMP_95(bool) = winnerID < 9999
TMP_96(bool) = TMP_94 && TMP_95
CONDITION TMP_96""];
11->12[label=""True""];
11->37[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
games[gameid].runingStatus = 3

IRs:
REF_148(GameTable.Game) -> games[gameid]
REF_149(uint256) -> REF_148.runingStatus
REF_149(uint256) (->games) := 3(uint256)""];
12->13;
13[label=""Node Type: NEW VARIABLE 13

EXPRESSION:
totalWinpool = games[gameid].options[winnerID].amount

IRs:
REF_150(GameTable.Game) -> games[gameid]
REF_151(mapping(uint256 => GameTable.Option)) -> REF_150.options
REF_152(GameTable.Option) -> REF_151[winnerID]
REF_153(uint256) -> REF_152.amount
totalWinpool(uint256) := REF_153(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
totalWinpool = games[gameid].amount.sub(totalWinpool)

IRs:
REF_154(GameTable.Game) -> games[gameid]
REF_155(uint256) -> REF_154.amount
TMP_97(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_155', 'totalWinpool'] 
totalWinpool(uint256) := TMP_97(uint256)""];
14->15;
15[label=""Node Type: NEW VARIABLE 15

EXPRESSION:
fee = totalWinpool.mul(15)

IRs:
TMP_98(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['totalWinpool', '15'] 
fee(uint256) := TMP_98(uint256)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
fee = fee.div(1000)

IRs:
TMP_99(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['fee', '1000'] 
fee(uint256) := TMP_99(uint256)""];
16->17;
17[label=""Node Type: NEW VARIABLE 17

EXPRESSION:
reward = totalWinpool.sub(fee)

IRs:
TMP_100(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalWinpool', 'fee'] 
reward(uint256) := TMP_100(uint256)""];
17->18;
18[label=""Node Type: IF 18

EXPRESSION:
games[gameid].options[winnerID].amount < 100000000000

IRs:
REF_160(GameTable.Game) -> games[gameid]
REF_161(mapping(uint256 => GameTable.Option)) -> REF_160.options
REF_162(GameTable.Option) -> REF_161[winnerID]
REF_163(uint256) -> REF_162.amount
TMP_101(bool) = REF_163 < 100000000000
CONDITION TMP_101""];
18->19[label=""True""];
18->20[label=""False""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
gameDeveloper.transfer(reward)

IRs:
Transfer dest:gameDeveloper value:reward""];
19->36;
20[label=""Node Type: NEW VARIABLE 20

EXPRESSION:
ratio = reward.mul(100)

IRs:
TMP_103(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['reward', '100'] 
ratio(uint256) := TMP_103(uint256)""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
ratio = ratio.div(games[gameid].options[winnerID].amount)

IRs:
REF_167(GameTable.Game) -> games[gameid]
REF_168(mapping(uint256 => GameTable.Option)) -> REF_167.options
REF_169(GameTable.Option) -> REF_168[winnerID]
REF_170(uint256) -> REF_169.amount
TMP_104(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['ratio', 'REF_170'] 
ratio(uint256) := TMP_104(uint256)""];
21->22;
22[label=""Node Type: NEW VARIABLE 22

EXPRESSION:
totalReturn = 0

IRs:
totalReturn(uint256) := 0(uint256)""];
22->25;
23[label=""Node Type: BEGIN_LOOP 23
""];
23->26;
24[label=""Node Type: END_LOOP 24
""];
24->34;
25[label=""Node Type: NEW VARIABLE 25

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
25->23;
26[label=""Node Type: IF_LOOP 26

EXPRESSION:
i < games[gameid].options[winnerID].numPlayers

IRs:
REF_171(GameTable.Game) -> games[gameid]
REF_172(mapping(uint256 => GameTable.Option)) -> REF_171.options
REF_173(GameTable.Option) -> REF_172[winnerID]
REF_174(uint256) -> REF_173.numPlayers
TMP_105(bool) = i < REF_174
CONDITION TMP_105""];
26->27[label=""True""];
26->24[label=""False""];
27[label=""Node Type: NEW VARIABLE 27

EXPRESSION:
returnWinAmount = games[gameid].options[winnerID].players[i].amount.mul(ratio)

IRs:
REF_175(GameTable.Game) -> games[gameid]
REF_176(mapping(uint256 => GameTable.Option)) -> REF_175.options
REF_177(GameTable.Option) -> REF_176[winnerID]
REF_178(mapping(uint256 => GameTable.Player)) -> REF_177.players
REF_179(GameTable.Player) -> REF_178[i]
REF_180(uint256) -> REF_179.amount
TMP_106(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_180', 'ratio'] 
returnWinAmount(uint256) := TMP_106(uint256)""];
27->28;
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
returnWinAmount = returnWinAmount.div(100)

IRs:
TMP_107(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['returnWinAmount', '100'] 
returnWinAmount(uint256) := TMP_107(uint256)""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
returnWinAmount = games[gameid].options[winnerID].players[i].amount.add(returnWinAmount)

IRs:
REF_183(GameTable.Game) -> games[gameid]
REF_184(mapping(uint256 => GameTable.Option)) -> REF_183.options
REF_185(GameTable.Option) -> REF_184[winnerID]
REF_186(mapping(uint256 => GameTable.Player)) -> REF_185.players
REF_187(GameTable.Player) -> REF_186[i]
REF_188(uint256) -> REF_187.amount
TMP_108(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_188', 'returnWinAmount'] 
returnWinAmount(uint256) := TMP_108(uint256)""];
29->30;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
games[gameid].options[winnerID].players[i].addr.transfer(returnWinAmount)

IRs:
REF_190(GameTable.Game) -> games[gameid]
REF_191(mapping(uint256 => GameTable.Option)) -> REF_190.options
REF_192(GameTable.Option) -> REF_191[winnerID]
REF_193(mapping(uint256 => GameTable.Player)) -> REF_192.players
REF_194(GameTable.Player) -> REF_193[i]
REF_195(address) -> REF_194.addr
Transfer dest:REF_195 value:returnWinAmount""];
30->31;
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
games[gameid].options[winnerID].players[i].profit = returnWinAmount

IRs:
REF_197(GameTable.Game) -> games[gameid]
REF_198(mapping(uint256 => GameTable.Option)) -> REF_197.options
REF_199(GameTable.Option) -> REF_198[winnerID]
REF_200(mapping(uint256 => GameTable.Player)) -> REF_199.players
REF_201(GameTable.Player) -> REF_200[i]
REF_202(uint256) -> REF_201.profit
REF_202(uint256) (->games) := returnWinAmount(uint256)""];
31->32;
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
totalReturn = totalReturn.add(returnWinAmount)

IRs:
TMP_110(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalReturn', 'returnWinAmount'] 
totalReturn(uint256) := TMP_110(uint256)""];
32->33;
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
i ++

IRs:
TMP_111(uint256) := i(uint256)
i(uint256) = i + 1""];
33->26;
34[label=""Node Type: NEW VARIABLE 34

EXPRESSION:
totalFee = games[gameid].amount.sub(totalReturn)

IRs:
REF_204(GameTable.Game) -> games[gameid]
REF_205(uint256) -> REF_204.amount
TMP_112(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_205', 'totalReturn'] 
totalFee(uint256) := TMP_112(uint256)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
gameDeveloper.transfer(totalFee)

IRs:
Transfer dest:gameDeveloper value:totalFee""];
35->36;
36[label=""Node Type: END_IF 36
""];
36->37;
37[label=""Node Type: END_IF 37
""];
}
",0,0,1,0,(gameid < 0) || (gameid > 999999999999999999999999999999999999);revert()();;now <= games[gameid].openTime;revert()();;games[gameid].runingStatus != 2;revert()();;winnerID = games[gameid].winner;winnerID > 0 && winnerID < 9999;games[gameid].runingStatus = 3;;totalWinpool = games[gameid].options[winnerID].amount;totalWinpool = games[gameid].amount.sub(totalWinpool);fee = totalWinpool.mul(15);fee = fee.div(1000);reward = totalWinpool.sub(fee);games[gameid].options[winnerID].amount < 100000000000;gameDeveloper.transfer(reward);ratio = reward.mul(100);;ratio = ratio.div(games[gameid].options[winnerID].amount);totalReturn = 0;i = 0;;i < games[gameid].options[winnerID].numPlayers;;totalFee = games[gameid].amount.sub(totalReturn);returnWinAmount = games[gameid].options[winnerID].players[i].amount.mul(ratio);returnWinAmount = returnWinAmount.div(100);returnWinAmount = games[gameid].options[winnerID].players[i].amount.add(returnWinAmount);games[gameid].options[winnerID].players[i].addr.transfer(returnWinAmount);games[gameid].options[winnerID].players[i].profit = returnWinAmount;totalReturn = totalReturn.add(returnWinAmount);i ++;gameDeveloper.transfer(totalFee)
./0xdc8a6ef9a8a4114773e806dc24bb8e7b6f3d92eb_ext.sol,PullPayment.withdrawPayments,63,74,"payee(address) := msg.sender(address),REF_0(uint256) -> payments[payee],payment(uint256) := REF_0(uint256),TMP_13(bool) = payment != 0,TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13),TMP_15 = CONVERT this to address,TMP_16(uint256) = SOLIDITY_CALL balance(address)(TMP_15),TMP_17(bool) = TMP_16 >= payment,TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17),TMP_19(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalPayments', 'payment'] ,totalPayments(uint256) := TMP_19(uint256),REF_2(uint256) -> payments[payee],REF_2(uint256) (->payments) := 0(uint256),Transfer dest:payee value:payment","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
payee = msg.sender

IRs:
payee(address) := msg.sender(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
payment = payments[payee]

IRs:
REF_0(uint256) -> payments[payee]
payment(uint256) := REF_0(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(payment != 0)

IRs:
TMP_13(bool) = payment != 0
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(address(this).balance >= payment)

IRs:
TMP_15 = CONVERT this to address
TMP_16(uint256) = SOLIDITY_CALL balance(address)(TMP_15)
TMP_17(bool) = TMP_16 >= payment
TMP_18(None) = SOLIDITY_CALL require(bool)(TMP_17)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
totalPayments = totalPayments.sub(payment)

IRs:
TMP_19(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalPayments', 'payment'] 
totalPayments(uint256) := TMP_19(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
payments[payee] = 0

IRs:
REF_2(uint256) -> payments[payee]
REF_2(uint256) (->payments) := 0(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
payee.transfer(payment)

IRs:
Transfer dest:payee value:payment""];
}
",0,0,1,0,payee = msg.sender;payment = payments[payee];require(bool)(payment != 0);require(bool)(address(this).balance >= payment);totalPayments = totalPayments.sub(payment);payments[payee] = 0;payee.transfer(payment)
./0x0e2354b2ea4a6312009b228d5171bf6a02c51150_ext.sol,THE_GAME.StopGame,32,35,"TMP_10(bool) = msg.sender == questionSender,TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_10(bool) = msg.sender == questionSender
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.KahnDistributionCentre,2,2,"TMP_12 = CONVERT 0 to address,TMP_13(bool) = _token != TMP_12,TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13),token(ERC20) := _token(ERC20),REF_0(bool) -> admins[msg.sender],REF_0(bool) (->admins) := True(bool),REF_2 -> LENGTH adminaddress,TMP_17(uint256) := REF_2(uint256),TMP_18(uint256) = TMP_17 + 1,REF_2(uint256) (->adminaddress) := TMP_18(uint256),REF_3(address) -> adminaddress[TMP_17],REF_3(address) (->adminaddress) := msg.sender(address),TMP_16(None) = TMP_15 - 1,owner(address) := msg.sender(address),mineth(uint256) := _min_eth(uint256),minsignupeth(uint256) := _minsignupeth(uint256),wallet(address) := _wallet(address),payStyle(uint256) := _paystyle(uint256),startTimes(uint256) := _starttimes(uint256),endTimes(uint256) := _endtimes(uint256),payoutNow(uint256) := _payoutnow(uint256),fixPayAmt(uint256) := _fixpayamt(uint256),maxSignup(uint256) := _maxsignup(uint256),allowsSignup(bool) := _allowssignup(bool),paidversion(bool) := _paidversion(bool)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_token != address(0))

IRs:
TMP_12 = CONVERT 0 to address
TMP_13(bool) = _token != TMP_12
TMP_14(None) = SOLIDITY_CALL require(bool)(TMP_13)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
token = _token

IRs:
token(ERC20) := _token(ERC20)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
admins[msg.sender] = true

IRs:
REF_0(bool) -> admins[msg.sender]
REF_0(bool) (->admins) := True(bool)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
adminaddress.push(msg.sender) - 1

IRs:
REF_2 -> LENGTH adminaddress
TMP_17(uint256) := REF_2(uint256)
TMP_18(uint256) = TMP_17 + 1
REF_2(uint256) (->adminaddress) := TMP_18(uint256)
REF_3(address) -> adminaddress[TMP_17]
REF_3(address) (->adminaddress) := msg.sender(address)
TMP_16(None) = TMP_15 - 1""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
mineth = _min_eth

IRs:
mineth(uint256) := _min_eth(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
minsignupeth = _minsignupeth

IRs:
minsignupeth(uint256) := _minsignupeth(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
payStyle = _paystyle

IRs:
payStyle(uint256) := _paystyle(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
startTimes = _starttimes

IRs:
startTimes(uint256) := _starttimes(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
endTimes = _endtimes

IRs:
endTimes(uint256) := _endtimes(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
payoutNow = _payoutnow

IRs:
payoutNow(uint256) := _payoutnow(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
fixPayAmt = _fixpayamt

IRs:
fixPayAmt(uint256) := _fixpayamt(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
maxSignup = _maxsignup

IRs:
maxSignup(uint256) := _maxsignup(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
allowsSignup = _allowssignup

IRs:
allowsSignup(bool) := _allowssignup(bool)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
paidversion = _paidversion

IRs:
paidversion(bool) := _paidversion(bool)""];
}
",0,1,1,0,require(bool)(_token != address(0));token = _token;admins[msg.sender] = true;adminaddress.push(msg.sender) - 1;owner = msg.sender;mineth = _min_eth;minsignupeth = _minsignupeth;wallet = _wallet;payStyle = _paystyle;startTimes = _starttimes;endTimes = _endtimes;payoutNow = _payoutnow;fixPayAmt = _fixpayamt;maxSignup = _maxsignup;allowsSignup = _allowssignup;paidversion = _paidversion
./0xdb209c97e0de799bbf14e3377307780ddc26be4e_ext.sol,DarkPay.getTokens,180,240,"tokens(uint256) := 0(uint256),bonus(uint256) := 0(uint256),countbonus(uint256) := 0(uint256),TMP_45(uint256) = 1000000000000000000 / 10,bonusCond1(uint256) := TMP_45(uint256),bonusCond2(uint256) := 1000000000000000000(uint256),bonusCond3(uint256) := 5000000000000000000(uint256),TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_47(uint256) = TMP_46 / 1000000000000000000,tokens(uint256) := TMP_47(uint256),investor(address) := msg.sender(address),TMP_48(bool) = msg.value >= requestMinimum,TMP_49(bool) = now < deadline,TMP_50(bool) = TMP_48 && TMP_49,TMP_51(bool) = now < round1,TMP_52(bool) = TMP_50 && TMP_51,TMP_53(bool) = now < round2,TMP_54(bool) = TMP_52 && TMP_53,CONDITION TMP_54,TMP_55(bool) = msg.value >= bonusCond1,TMP_56(bool) = msg.value < bonusCond2,TMP_57(bool) = TMP_55 && TMP_56,CONDITION TMP_57,TMP_58(uint256) = tokens * 5,TMP_59(uint256) = TMP_58 / 100,countbonus(uint256) := TMP_59(uint256),TMP_60(bool) = msg.value >= bonusCond2,TMP_61(bool) = msg.value < bonusCond3,TMP_62(bool) = TMP_60 && TMP_61,CONDITION TMP_62,TMP_63(uint256) = tokens * 10,TMP_64(uint256) = TMP_63 / 100,countbonus(uint256) := TMP_64(uint256),TMP_65(bool) = msg.value >= bonusCond3,CONDITION TMP_65,TMP_66(uint256) = tokens * 15,TMP_67(uint256) = TMP_66 / 100,countbonus(uint256) := TMP_67(uint256),TMP_68(bool) = msg.value >= requestMinimum,TMP_69(bool) = now < deadline,TMP_70(bool) = TMP_68 && TMP_69,TMP_71(bool) = now > round1,TMP_72(bool) = TMP_70 && TMP_71,TMP_73(bool) = now < round2,TMP_74(bool) = TMP_72 && TMP_73,CONDITION TMP_74,TMP_75(bool) = msg.value >= bonusCond2,TMP_76(bool) = msg.value < bonusCond3,TMP_77(bool) = TMP_75 && TMP_76,CONDITION TMP_77,TMP_78(uint256) = tokens * 5,TMP_79(uint256) = TMP_78 / 100,countbonus(uint256) := TMP_79(uint256),TMP_80(bool) = msg.value >= bonusCond3,CONDITION TMP_80,TMP_81(uint256) = tokens * 10,TMP_82(uint256) = TMP_81 / 100,countbonus(uint256) := TMP_82(uint256),countbonus(uint256) := 0(uint256),TMP_83(uint256) = tokens + countbonus,bonus(uint256) := TMP_83(uint256),TMP_84(bool) = tokens == 0,CONDITION TMP_84,valdrop(uint256) := 5000000000(uint256),REF_12(bool) -> Claimed[investor],TMP_85(bool) = REF_12 == False,TMP_86(bool) = progress0drop <= target0drop,TMP_87(bool) = TMP_85 && TMP_86,CONDITION TMP_87,TMP_88(bool) = INTERNAL_CALL, DarkPay.distr(address,uint256)(investor,valdrop),REF_13(bool) -> Claimed[investor],REF_13(bool) (->Claimed) := True(bool),TMP_89(uint256) := progress0drop(uint256),progress0drop(uint256) = progress0drop + 1,TMP_90(bool) = msg.value >= requestMinimum,TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),TMP_92(bool) = tokens > 0,TMP_93(bool) = msg.value >= requestMinimum,TMP_94(bool) = TMP_92 && TMP_93,CONDITION TMP_94,TMP_95(bool) = now >= deadline,TMP_96(bool) = now >= round1,TMP_97(bool) = TMP_95 && TMP_96,TMP_98(bool) = now < round2,TMP_99(bool) = TMP_97 && TMP_98,CONDITION TMP_99,TMP_100(bool) = INTERNAL_CALL, DarkPay.distr(address,uint256)(investor,tokens),TMP_101(bool) = msg.value >= bonusCond1,CONDITION TMP_101,TMP_102(bool) = INTERNAL_CALL, DarkPay.distr(address,uint256)(investor,bonus),TMP_103(bool) = INTERNAL_CALL, DarkPay.distr(address,uint256)(investor,tokens),TMP_104(bool) = msg.value >= requestMinimum,TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104),TMP_106(bool) = totalDistributed >= totalSupply,CONDITION TMP_106,distributionFinished(bool) := True(bool),Transfer dest:multisig value:msg.value,MODIFIER_CALL, DarkPay.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->53;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bonusCond1 = 1000000000000000000 / 10

IRs:
TMP_45(uint256) = 1000000000000000000 / 10
bonusCond1(uint256) := TMP_45(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bonusCond2 = 1000000000000000000

IRs:
bonusCond2(uint256) := 1000000000000000000(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
bonusCond3 = 5000000000000000000

IRs:
bonusCond3(uint256) := 5000000000000000000(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_47(uint256) = TMP_46 / 1000000000000000000
tokens(uint256) := TMP_47(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now < round1 && now < round2

IRs:
TMP_48(bool) = msg.value >= requestMinimum
TMP_49(bool) = now < deadline
TMP_50(bool) = TMP_48 && TMP_49
TMP_51(bool) = now < round1
TMP_52(bool) = TMP_50 && TMP_51
TMP_53(bool) = now < round2
TMP_54(bool) = TMP_52 && TMP_53
CONDITION TMP_54""];
9->10[label=""True""];
9->19[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
msg.value >= bonusCond1 && msg.value < bonusCond2

IRs:
TMP_55(bool) = msg.value >= bonusCond1
TMP_56(bool) = msg.value < bonusCond2
TMP_57(bool) = TMP_55 && TMP_56
CONDITION TMP_57""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
countbonus = tokens * 5 / 100

IRs:
TMP_58(uint256) = tokens * 5
TMP_59(uint256) = TMP_58 / 100
countbonus(uint256) := TMP_59(uint256)""];
11->18;
12[label=""Node Type: IF 12

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_60(bool) = msg.value >= bonusCond2
TMP_61(bool) = msg.value < bonusCond3
TMP_62(bool) = TMP_60 && TMP_61
CONDITION TMP_62""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
countbonus = tokens * 10 / 100

IRs:
TMP_63(uint256) = tokens * 10
TMP_64(uint256) = TMP_63 / 100
countbonus(uint256) := TMP_64(uint256)""];
13->17;
14[label=""Node Type: IF 14

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_65(bool) = msg.value >= bonusCond3
CONDITION TMP_65""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
countbonus = tokens * 15 / 100

IRs:
TMP_66(uint256) = tokens * 15
TMP_67(uint256) = TMP_66 / 100
countbonus(uint256) := TMP_67(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->28;
19[label=""Node Type: IF 19

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now > round1 && now < round2

IRs:
TMP_68(bool) = msg.value >= requestMinimum
TMP_69(bool) = now < deadline
TMP_70(bool) = TMP_68 && TMP_69
TMP_71(bool) = now > round1
TMP_72(bool) = TMP_70 && TMP_71
TMP_73(bool) = now < round2
TMP_74(bool) = TMP_72 && TMP_73
CONDITION TMP_74""];
19->20[label=""True""];
19->26[label=""False""];
20[label=""Node Type: IF 20

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_75(bool) = msg.value >= bonusCond2
TMP_76(bool) = msg.value < bonusCond3
TMP_77(bool) = TMP_75 && TMP_76
CONDITION TMP_77""];
20->21[label=""True""];
20->22[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
countbonus = tokens * 5 / 100

IRs:
TMP_78(uint256) = tokens * 5
TMP_79(uint256) = TMP_78 / 100
countbonus(uint256) := TMP_79(uint256)""];
21->25;
22[label=""Node Type: IF 22

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_80(bool) = msg.value >= bonusCond3
CONDITION TMP_80""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
countbonus = tokens * 10 / 100

IRs:
TMP_81(uint256) = tokens * 10
TMP_82(uint256) = TMP_81 / 100
countbonus(uint256) := TMP_82(uint256)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->27;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
bonus = tokens + countbonus

IRs:
TMP_83(uint256) = tokens + countbonus
bonus(uint256) := TMP_83(uint256)""];
29->30;
30[label=""Node Type: IF 30

EXPRESSION:
tokens == 0

IRs:
TMP_84(bool) = tokens == 0
CONDITION TMP_84""];
30->31[label=""True""];
30->38[label=""False""];
31[label=""Node Type: NEW VARIABLE 31

EXPRESSION:
valdrop = 50e8

IRs:
valdrop(uint256) := 5000000000(uint256)""];
31->32;
32[label=""Node Type: IF 32

EXPRESSION:
Claimed[investor] == false && progress0drop <= target0drop

IRs:
REF_12(bool) -> Claimed[investor]
TMP_85(bool) = REF_12 == False
TMP_86(bool) = progress0drop <= target0drop
TMP_87(bool) = TMP_85 && TMP_86
CONDITION TMP_87""];
32->33[label=""True""];
32->36[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
distr(investor,valdrop)

IRs:
TMP_88(bool) = INTERNAL_CALL, DarkPay.distr(address,uint256)(investor,valdrop)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
Claimed[investor] = true

IRs:
REF_13(bool) -> Claimed[investor]
REF_13(bool) (->Claimed) := True(bool)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
progress0drop ++

IRs:
TMP_89(uint256) := progress0drop(uint256)
progress0drop(uint256) = progress0drop + 1""];
35->37;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_90(bool) = msg.value >= requestMinimum
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
36->37;
37[label=""Node Type: END_IF 37
""];
37->48;
38[label=""Node Type: IF 38

EXPRESSION:
tokens > 0 && msg.value >= requestMinimum

IRs:
TMP_92(bool) = tokens > 0
TMP_93(bool) = msg.value >= requestMinimum
TMP_94(bool) = TMP_92 && TMP_93
CONDITION TMP_94""];
38->39[label=""True""];
38->46[label=""False""];
39[label=""Node Type: IF 39

EXPRESSION:
now >= deadline && now >= round1 && now < round2

IRs:
TMP_95(bool) = now >= deadline
TMP_96(bool) = now >= round1
TMP_97(bool) = TMP_95 && TMP_96
TMP_98(bool) = now < round2
TMP_99(bool) = TMP_97 && TMP_98
CONDITION TMP_99""];
39->40[label=""True""];
39->41[label=""False""];
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_100(bool) = INTERNAL_CALL, DarkPay.distr(address,uint256)(investor,tokens)""];
40->45;
41[label=""Node Type: IF 41

EXPRESSION:
msg.value >= bonusCond1

IRs:
TMP_101(bool) = msg.value >= bonusCond1
CONDITION TMP_101""];
41->42[label=""True""];
41->43[label=""False""];
42[label=""Node Type: EXPRESSION 42

EXPRESSION:
distr(investor,bonus)

IRs:
TMP_102(bool) = INTERNAL_CALL, DarkPay.distr(address,uint256)(investor,bonus)""];
42->44;
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_103(bool) = INTERNAL_CALL, DarkPay.distr(address,uint256)(investor,tokens)""];
43->44;
44[label=""Node Type: END_IF 44
""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->47;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_104(bool) = msg.value >= requestMinimum
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: IF 49

EXPRESSION:
totalDistributed >= totalSupply

IRs:
TMP_106(bool) = totalDistributed >= totalSupply
CONDITION TMP_106""];
49->50[label=""True""];
49->51[label=""False""];
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
multisig.transfer(msg.value)

IRs:
Transfer dest:multisig value:msg.value""];
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, DarkPay.canDistr()()""];
53->1;
}
",0,0,1,0,"canDistr();tokens = 0;bonus = 0;countbonus = 0;bonusCond1 = 1000000000000000000 / 10;bonusCond2 = 1000000000000000000;bonusCond3 = 5000000000000000000;tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;investor = msg.sender;msg.value >= requestMinimum && now < deadline && now < round1 && now < round2;msg.value >= bonusCond1 && msg.value < bonusCond2;msg.value >= requestMinimum && now < deadline && now > round1 && now < round2;countbonus = tokens * 5 / 100;msg.value >= bonusCond2 && msg.value < bonusCond3;;countbonus = tokens * 10 / 100;msg.value >= bonusCond3;;countbonus = tokens * 15 / 100;;;msg.value >= bonusCond2 && msg.value < bonusCond3;countbonus = 0;countbonus = tokens * 5 / 100;msg.value >= bonusCond3;;countbonus = tokens * 10 / 100;;;bonus = tokens + countbonus;tokens == 0;valdrop = 50e8;tokens > 0 && msg.value >= requestMinimum;Claimed[investor] == false && progress0drop <= target0drop;distr(investor,valdrop);require(bool)(msg.value >= requestMinimum);Claimed[investor] = true;progress0drop ++;;;now >= deadline && now >= round1 && now < round2;require(bool)(msg.value >= requestMinimum);distr(investor,tokens);msg.value >= bonusCond1;;distr(investor,bonus);distr(investor,tokens);;;totalDistributed >= totalSupply;distributionFinished = true;;multisig.transfer(msg.value)"
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.adminUpdatePayout,2,2,"payStyle(uint256) := _payStyle(uint256),payoutNow(uint256) := _payoutNow(uint256),fixPayAmt(uint256) := _fixPayAmt(uint256),allowsSignup(bool) := _allowsSignup(bool),Emit eUpdatePayout(payStyle,payoutNow,fixPayAmt,allowsSignup,msg.sender),MODIFIER_CALL, KahnDistributionCentre.onlyAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
payStyle = _payStyle

IRs:
payStyle(uint256) := _payStyle(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
payoutNow = _payoutNow

IRs:
payoutNow(uint256) := _payoutNow(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
fixPayAmt = _fixPayAmt

IRs:
fixPayAmt(uint256) := _fixPayAmt(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
allowsSignup = _allowsSignup

IRs:
allowsSignup(bool) := _allowsSignup(bool)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
eUpdatePayout(payStyle,payoutNow,fixPayAmt,allowsSignup,msg.sender)

IRs:
Emit eUpdatePayout(payStyle,payoutNow,fixPayAmt,allowsSignup,msg.sender)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyAdmin()()""];
6->1;
}
",0,1,1,0,"onlyAdmin();payStyle = _payStyle;payoutNow = _payoutNow;fixPayAmt = _fixPayAmt;allowsSignup = _allowsSignup;eUpdatePayout(payStyle,payoutNow,fixPayAmt,allowsSignup,msg.sender)"
./0x01e53a2e7122a63845b1c329d4fce8124dda5b06_ext.sol,Loan.Wthdraw,191,199,"TMP_61(bool) = msg.sender == Creator,CONDITION TMP_61,REF_18(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:Creator value:REF_18","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == Creator

IRs:
TMP_61(bool) = msg.sender == Creator
CONDITION TMP_61""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Creator.transfer(this.balance)

IRs:
REF_18(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:Creator value:REF_18""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,0,1,0,msg.sender == Creator;Creator.transfer(this.balance);
./0x7271f8fdd7693dca37b40403080abe89ae740168_ext.sol,Game.fallback,29,58,"TMP_0(bool) = msg.value == 0,REF_0(address) -> last.depositor,TMP_1(bool) = msg.sender == REF_0,TMP_2(bool) = TMP_0 && TMP_1,CONDITION TMP_2,TMP_3(uint256) = SOLIDITY_CALL gasleft()(),TMP_4(bool) = TMP_3 >= 220000,TMP_5(None) = SOLIDITY_CALL require(bool,string)(TMP_4,We require more gas!),REF_1(uint256) -> last.blockNumber,TMP_6(uint256) = REF_1 + 258,TMP_7(bool) = TMP_6 < block.number,TMP_8(None) = SOLIDITY_CALL require(bool,string)(TMP_7,Last depositor should wait 258 blocks (~0.2 hour) to claim reward),TMP_9 = CONVERT this to address,TMP_10(uint256) = SOLIDITY_CALL balance(address)(TMP_9),TMP_11 = CONVERT TMP_10 to uint128,money(uint128) := TMP_11(uint128),REF_2(uint256) -> last.expect,TMP_12(bool) = money >= REF_2,CONDITION TMP_12,REF_3(address) -> last.depositor,REF_5(uint256) -> last.expect,Transfer dest:REF_3 value:REF_5,REF_6(address) -> last.depositor,Transfer dest:REF_6 value:money,last = delete last ,TMP_15(bool) = msg.value > 0,CONDITION TMP_15,TMP_16(uint256) = SOLIDITY_CALL gasleft()(),TMP_17(bool) = TMP_16 >= 220000,TMP_18(None) = SOLIDITY_CALL require(bool,string)(TMP_17,We require more gas!),TMP_19(bool) = msg.value <= MAX_DEPOSIT,TMP_20(bool) = msg.value >= MIN_DEPOSIT,TMP_21(bool) = TMP_19 && TMP_20,TMP_22(None) = SOLIDITY_CALL require(bool,string)(TMP_21,Deposit must be >= 0.01 ETH and <= 1 ETH),TMP_23 = CONVERT msg.value to uint128,TMP_24(uint256) = msg.value * MULTIPLIER,TMP_25(uint256) = TMP_24 / 100,TMP_26 = CONVERT TMP_25 to uint128,TMP_27(Game.Deposit) = new Deposit(msg.sender,TMP_23,TMP_26),REF_9 -> LENGTH queue,TMP_29(uint256) := REF_9(uint256),TMP_30(uint256) = TMP_29 + 1,REF_9(uint256) (->queue) := TMP_30(uint256),REF_10(Game.Deposit) -> queue[TMP_29],REF_10(Game.Deposit) (->queue) := TMP_27(Game.Deposit),REF_11(address) -> last.depositor,REF_11(address) (->last) := msg.sender(address),REF_12(uint256) -> last.expect,TMP_31(uint256) = msg.value * LAST_DEPOSIT_PERCENT,TMP_32(uint256) = TMP_31 / 100,REF_12(-> last) = REF_12 + TMP_32,REF_13(uint256) -> last.blockNumber,REF_13(uint256) (->last) := block.number(uint256),TMP_33(uint256) = msg.value * PROMO_PERCENT,TMP_34(uint256) = TMP_33 / 100,promo(uint256) := TMP_34(uint256),Transfer dest:PROMO value:promo,INTERNAL_CALL, Game.pay()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value == 0 && msg.sender == last.depositor

IRs:
TMP_0(bool) = msg.value == 0
REF_0(address) -> last.depositor
TMP_1(bool) = msg.sender == REF_0
TMP_2(bool) = TMP_0 && TMP_1
CONDITION TMP_2""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(gasleft()() >= 220000,We require more gas!)

IRs:
TMP_3(uint256) = SOLIDITY_CALL gasleft()()
TMP_4(bool) = TMP_3 >= 220000
TMP_5(None) = SOLIDITY_CALL require(bool,string)(TMP_4,We require more gas!)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool,string)(last.blockNumber + 258 < block.number,Last depositor should wait 258 blocks (~0.2 hour) to claim reward)

IRs:
REF_1(uint256) -> last.blockNumber
TMP_6(uint256) = REF_1 + 258
TMP_7(bool) = TMP_6 < block.number
TMP_8(None) = SOLIDITY_CALL require(bool,string)(TMP_7,Last depositor should wait 258 blocks (~0.2 hour) to claim reward)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
money = uint128((address(this).balance))

IRs:
TMP_9 = CONVERT this to address
TMP_10(uint256) = SOLIDITY_CALL balance(address)(TMP_9)
TMP_11 = CONVERT TMP_10 to uint128
money(uint128) := TMP_11(uint128)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
money >= last.expect

IRs:
REF_2(uint256) -> last.expect
TMP_12(bool) = money >= REF_2
CONDITION TMP_12""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
last.depositor.transfer(last.expect)

IRs:
REF_3(address) -> last.depositor
REF_5(uint256) -> last.expect
Transfer dest:REF_3 value:REF_5""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
last.depositor.transfer(money)

IRs:
REF_6(address) -> last.depositor
Transfer dest:REF_6 value:money""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
delete last

IRs:
last = delete last ""];
9->21;
10[label=""Node Type: IF 10

EXPRESSION:
msg.value > 0

IRs:
TMP_15(bool) = msg.value > 0
CONDITION TMP_15""];
10->11[label=""True""];
10->20[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
require(bool,string)(gasleft()() >= 220000,We require more gas!)

IRs:
TMP_16(uint256) = SOLIDITY_CALL gasleft()()
TMP_17(bool) = TMP_16 >= 220000
TMP_18(None) = SOLIDITY_CALL require(bool,string)(TMP_17,We require more gas!)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
require(bool,string)(msg.value <= MAX_DEPOSIT && msg.value >= MIN_DEPOSIT,Deposit must be >= 0.01 ETH and <= 1 ETH)

IRs:
TMP_19(bool) = msg.value <= MAX_DEPOSIT
TMP_20(bool) = msg.value >= MIN_DEPOSIT
TMP_21(bool) = TMP_19 && TMP_20
TMP_22(None) = SOLIDITY_CALL require(bool,string)(TMP_21,Deposit must be >= 0.01 ETH and <= 1 ETH)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
queue.push(Deposit(msg.sender,uint128(msg.value),uint128(msg.value * MULTIPLIER / 100)))

IRs:
TMP_23 = CONVERT msg.value to uint128
TMP_24(uint256) = msg.value * MULTIPLIER
TMP_25(uint256) = TMP_24 / 100
TMP_26 = CONVERT TMP_25 to uint128
TMP_27(Game.Deposit) = new Deposit(msg.sender,TMP_23,TMP_26)
REF_9 -> LENGTH queue
TMP_29(uint256) := REF_9(uint256)
TMP_30(uint256) = TMP_29 + 1
REF_9(uint256) (->queue) := TMP_30(uint256)
REF_10(Game.Deposit) -> queue[TMP_29]
REF_10(Game.Deposit) (->queue) := TMP_27(Game.Deposit)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
last.depositor = msg.sender

IRs:
REF_11(address) -> last.depositor
REF_11(address) (->last) := msg.sender(address)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
last.expect += msg.value * LAST_DEPOSIT_PERCENT / 100

IRs:
REF_12(uint256) -> last.expect
TMP_31(uint256) = msg.value * LAST_DEPOSIT_PERCENT
TMP_32(uint256) = TMP_31 / 100
REF_12(-> last) = REF_12 + TMP_32""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
last.blockNumber = block.number

IRs:
REF_13(uint256) -> last.blockNumber
REF_13(uint256) (->last) := block.number(uint256)""];
16->17;
17[label=""Node Type: NEW VARIABLE 17

EXPRESSION:
promo = msg.value * PROMO_PERCENT / 100

IRs:
TMP_33(uint256) = msg.value * PROMO_PERCENT
TMP_34(uint256) = TMP_33 / 100
promo(uint256) := TMP_34(uint256)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
PROMO.transfer(promo)

IRs:
Transfer dest:PROMO value:promo""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
pay()

IRs:
INTERNAL_CALL, Game.pay()()""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: END_IF 21
""];
}
",0,0,1,0,"msg.value == 0 && msg.sender == last.depositor;require(bool,string)(gasleft()() >= 220000,We require more gas!);msg.value > 0;require(bool,string)(last.blockNumber + 258 < block.number,Last depositor should wait 258 blocks (~0.2 hour) to claim reward);money = uint128((address(this).balance));money >= last.expect;last.depositor.transfer(last.expect);last.depositor.transfer(money);;delete last;;require(bool,string)(gasleft()() >= 220000,We require more gas!);;require(bool,string)(msg.value <= MAX_DEPOSIT && msg.value >= MIN_DEPOSIT,Deposit must be >= 0.01 ETH and <= 1 ETH);queue.push(Deposit(msg.sender,uint128(msg.value),uint128(msg.value * MULTIPLIER / 100)));last.depositor = msg.sender;last.expect += msg.value * LAST_DEPOSIT_PERCENT / 100;last.blockNumber = block.number;promo = msg.value * PROMO_PERCENT / 100;PROMO.transfer(promo);pay()"
./0x4c7f666ca30fe548fbdc08b0308927327f08336d_ext.sol,RefundVault.refund,915,921,"REF_433(RefundVault.State) -> State.Refunding,TMP_766(bool) = state == REF_433,TMP_767(None) = SOLIDITY_CALL require(bool)(TMP_766),REF_434(uint256) -> deposited[investor],depositedValue(uint256) := REF_434(uint256),REF_435(uint256) -> deposited[investor],REF_435(uint256) (->deposited) := 0(uint256),Transfer dest:investor value:depositedValue,Emit Refunded(investor,depositedValue)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Refunding)

IRs:
REF_433(RefundVault.State) -> State.Refunding
TMP_766(bool) = state == REF_433
TMP_767(None) = SOLIDITY_CALL require(bool)(TMP_766)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
depositedValue = deposited[investor]

IRs:
REF_434(uint256) -> deposited[investor]
depositedValue(uint256) := REF_434(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
deposited[investor] = 0

IRs:
REF_435(uint256) -> deposited[investor]
REF_435(uint256) (->deposited) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
investor.transfer(depositedValue)

IRs:
Transfer dest:investor value:depositedValue""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Refunded(investor,depositedValue)

IRs:
Emit Refunded(investor,depositedValue)""];
}
",0,0,1,0,"require(bool)(state == State.Refunding);depositedValue = deposited[investor];deposited[investor] = 0;investor.transfer(depositedValue);Refunded(investor,depositedValue)"
./0x3008a6c26e54399fd0ece8fd2e5e06b3d807509c_ext.sol,AccessService.withdraw,104,116,"TMP_37(bool) = msg.sender == addrFinance,TMP_38(bool) = msg.sender == addrAdmin,TMP_39(bool) = TMP_37 || TMP_38,TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39),TMP_41(bool) = _amount > 0,TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41),REF_0(uint256) = SOLIDITY_CALL balance(address)(this),balance(uint256) := REF_0([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B7C90DC0>]),TMP_43(bool) = _amount < balance,CONDITION TMP_43,Transfer dest:receiver value:_amount,REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:receiver value:REF_3,TMP_46 = CONVERT 0 to address,TMP_47(bool) = _target == TMP_46,CONDITION TMP_47,receiver(address) := addrFinance(address),receiver(address) := _target(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == addrFinance || msg.sender == addrAdmin)

IRs:
TMP_37(bool) = msg.sender == addrFinance
TMP_38(bool) = msg.sender == addrAdmin
TMP_39(bool) = TMP_37 || TMP_38
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amount > 0)

IRs:
TMP_41(bool) = _amount > 0
TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)""];
2->9;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
balance = this.balance

IRs:
REF_0(uint256) = SOLIDITY_CALL balance(address)(this)
balance(uint256) := REF_0([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B7C90DC0>])""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
_amount < balance

IRs:
TMP_43(bool) = _amount < balance
CONDITION TMP_43""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
receiver.transfer(_amount)

IRs:
Transfer dest:receiver value:_amount""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
receiver.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:receiver value:REF_3""];
7->8;
8[label=""Node Type: END_IF 8
""];
9[label=""Node Type: IF 9

EXPRESSION:
_target == address(0)

IRs:
TMP_46 = CONVERT 0 to address
TMP_47(bool) = _target == TMP_46
CONDITION TMP_47""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
receiver = addrFinance

IRs:
receiver(address) := addrFinance(address)""];
10->12;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
receiver = _target

IRs:
receiver(address) := _target(address)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->4;
}
",0,0,1,0,require(bool)(msg.sender == addrFinance || msg.sender == addrAdmin);require(bool)(_amount > 0);_target == address(0);balance = this.balance;_amount < balance;receiver.transfer(_amount);receiver.transfer(this.balance);;receiver = addrFinance;receiver = _target;
./0x345ab5e5f971dbdbc92af2779ce7a8bbf1819e59_ext.sol,TwentyDollars.withdraw,76,81,"REF_6(uint256) -> balances[msg.sender],balance(uint256) := REF_6(uint256),TMP_4(bool) = balance > 0,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_7(uint256) -> balances[msg.sender],REF_7(uint256) (->balances) := 0(uint256),Transfer dest:msg.sender value:balance","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
balance = balances[msg.sender]

IRs:
REF_6(uint256) -> balances[msg.sender]
balance(uint256) := REF_6(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balance > 0)

IRs:
TMP_4(bool) = balance > 0
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = 0

IRs:
REF_7(uint256) -> balances[msg.sender]
REF_7(uint256) (->balances) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(balance)

IRs:
Transfer dest:msg.sender value:balance""];
}
",0,0,1,0,balance = balances[msg.sender];require(bool)(balance > 0);balances[msg.sender] = 0;msg.sender.transfer(balance)
./0xe386b139ed3715ca4b18fd52671bdcea1cdfe4b1_ext.sol,Crowdsale.withdrawFunds,348,355,"REF_58(Stateful.State) -> State.PrivateSale,TMP_158(bool) = state == REF_58,REF_59(Stateful.State) -> State.PreSale,TMP_159(bool) = state == REF_59,TMP_160(bool) = TMP_158 || TMP_159,REF_60(Stateful.State) -> State.Sale,TMP_161(bool) = state == REF_60,TMP_162(bool) = collectedUSDWEI > minimalSuccessUSDWEI,TMP_163(bool) = TMP_161 && TMP_162,TMP_164(bool) = TMP_160 || TMP_163,TMP_165(None) = SOLIDITY_CALL require(bool)(TMP_164),TMP_166(bool) = _value == 0,CONDITION TMP_166,REF_61(uint256) = SOLIDITY_CALL balance(address)(this),_value(uint256) := REF_61([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E32C5C70>]),TMP_169(bool) = LOW_LEVEL_CALL, dest:beneficiary, function:call, arguments:[] value:_value gas:3000000,isSent(bool) := TMP_169(bool),TMP_170(None) = SOLIDITY_CALL require(bool)(isSent),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.PrivateSale || state == State.PreSale || (state == State.Sale && collectedUSDWEI > minimalSuccessUSDWEI))

IRs:
REF_58(Stateful.State) -> State.PrivateSale
TMP_158(bool) = state == REF_58
REF_59(Stateful.State) -> State.PreSale
TMP_159(bool) = state == REF_59
TMP_160(bool) = TMP_158 || TMP_159
REF_60(Stateful.State) -> State.Sale
TMP_161(bool) = state == REF_60
TMP_162(bool) = collectedUSDWEI > minimalSuccessUSDWEI
TMP_163(bool) = TMP_161 && TMP_162
TMP_164(bool) = TMP_160 || TMP_163
TMP_165(None) = SOLIDITY_CALL require(bool)(TMP_164)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
_value == 0

IRs:
TMP_166(bool) = _value == 0
CONDITION TMP_166""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_value = this.balance

IRs:
REF_61(uint256) = SOLIDITY_CALL balance(address)(this)
_value(uint256) := REF_61([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E32C5C70>])""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
isSent = beneficiary.call.gas(3000000).value(_value)()

IRs:
TMP_169(bool) = LOW_LEVEL_CALL, dest:beneficiary, function:call, arguments:[] value:_value gas:3000000
isSent(bool) := TMP_169(bool)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(isSent)

IRs:
TMP_170(None) = SOLIDITY_CALL require(bool)(isSent)""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
7->1;
}
",0,0,1,0,onlyOwner();require(bool)(state == State.PrivateSale || state == State.PreSale || (state == State.Sale && collectedUSDWEI > minimalSuccessUSDWEI));_value == 0;_value = this.balance;;isSent = beneficiary.call.gas(3000000).value(_value)();require(bool)(isSent)
./0xaa652d53909b01c5a6b8e7cd814f9adea18c08f7_ext.sol,TCRSale.ownerSafeWithdrawal,680,685,"TMP_241(None) = SOLIDITY_CALL require(bool)(fundingGoalReached),REF_129(uint256) = SOLIDITY_CALL balance(address)(this),balanceToSend(uint256) := REF_129([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E3A69220>]),Transfer dest:beneficiary value:balanceToSend,Emit FundTransfer(beneficiary,balanceToSend,False),MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, TCRSale.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(fundingGoalReached)

IRs:
TMP_241(None) = SOLIDITY_CALL require(bool)(fundingGoalReached)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
balanceToSend = this.balance

IRs:
REF_129(uint256) = SOLIDITY_CALL balance(address)(this)
balanceToSend(uint256) := REF_129([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E3A69220>])""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
beneficiary.transfer(balanceToSend)

IRs:
Transfer dest:beneficiary value:balanceToSend""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
FundTransfer(beneficiary,balanceToSend,false)

IRs:
Emit FundTransfer(beneficiary,balanceToSend,False)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, TCRSale.nonReentrant()()""];
6->1;
}
",0,0,1,0,"onlyOwner();require(bool)(fundingGoalReached);balanceToSend = this.balance;beneficiary.transfer(balanceToSend);FundTransfer(beneficiary,balanceToSend,false);nonReentrant()"
./0xcf91d43b85a5c53d85c567d4eed972965335aeea_ext.sol,Slaughter3D.sacUp,86,89,"HIGH_LEVEL_CALL, dest:Snip3Dcontract_(Snip3DInterface), function:offerAsSacrifice, arguments:['msg.sender'] value:100000000000000000 ,MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
Snip3Dcontract_.offerAsSacrifice.value(100000000000000000)(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:Snip3Dcontract_(Snip3DInterface), function:offerAsSacrifice, arguments:['msg.sender'] value:100000000000000000 ""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();Snip3Dcontract_.offerAsSacrifice.value(100000000000000000)(msg.sender)
./0xf3391a78b4d53b2a600ad9e663ae00f6d5bb41a4_ext.sol,MillenniumNetwork.withdrawAll,288,292,"myAddress(address) := this(address),TMP_138(uint256) = SOLIDITY_CALL balance(address)(myAddress),etherBalance(uint256) := TMP_138(uint256),Transfer dest:owner value:etherBalance,MODIFIER_CALL, MillenniumNetwork.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
myAddress = this

IRs:
myAddress(address) := this(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
etherBalance = myAddress.balance

IRs:
TMP_138(uint256) = SOLIDITY_CALL balance(address)(myAddress)
etherBalance(uint256) := TMP_138(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(etherBalance)

IRs:
Transfer dest:owner value:etherBalance""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MillenniumNetwork.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();myAddress = this;etherBalance = myAddress.balance;owner.transfer(etherBalance)
./0x1e200a9af1ab6a0d74cd44c489bf65744bc7d961_ext.sol,BountyBG.withdrawFee,42,46,"TMP_0(bool) = _amount <= bountyFeeCount,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),bountyFeeCount(uint256) = bountyFeeCount - _amount,Transfer dest:owner value:_amount,MODIFIER_CALL, BountyBG.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_amount <= bountyFeeCount)

IRs:
TMP_0(bool) = _amount <= bountyFeeCount
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
bountyFeeCount -= _amount

IRs:
bountyFeeCount(uint256) = bountyFeeCount - _amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_amount)

IRs:
Transfer dest:owner value:_amount""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, BountyBG.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();require(bool)(_amount <= bountyFeeCount);bountyFeeCount -= _amount;owner.transfer(_amount)
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.addStaffWhitelist,2,2,"REF_18 -> LENGTH _userlist,TMP_45(bool) = REF_18 > 0,TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45),i(uint256) := 0(uint256),REF_19 -> LENGTH _userlist,TMP_47(bool) = i < REF_19,CONDITION TMP_47,REF_20(address) -> _userlist[i],baddr(address) := REF_20(address),TMP_48 = CONVERT 0 to address,TMP_49(bool) = baddr != TMP_48,CONDITION TMP_49,REF_21(bool) -> staffs[baddr],TMP_50 = UnaryType.BANG REF_21 ,CONDITION TMP_50,REF_22(bool) -> staffs[baddr],REF_22(bool) (->staffs) := True(bool),REF_24 -> LENGTH staffaddress,TMP_53(uint256) := REF_24(uint256),TMP_54(uint256) = TMP_53 + 1,REF_24(uint256) (->staffaddress) := TMP_54(uint256),REF_25(address) -> staffaddress[TMP_53],REF_25(address) (->staffaddress) := baddr(address),TMP_52(None) = TMP_51 - 1,TMP_55(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, KahnDistributionCentre.onlyAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_userlist.length > 0)

IRs:
REF_18 -> LENGTH _userlist
TMP_45(bool) = REF_18 > 0
TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < _userlist.length

IRs:
REF_19 -> LENGTH _userlist
TMP_47(bool) = i < REF_19
CONDITION TMP_47""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
baddr = _userlist[i]

IRs:
REF_20(address) -> _userlist[i]
baddr(address) := REF_20(address)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
baddr != address(0)

IRs:
TMP_48 = CONVERT 0 to address
TMP_49(bool) = baddr != TMP_48
CONDITION TMP_49""];
7->8[label=""True""];
7->12[label=""False""];
8[label=""Node Type: IF 8

EXPRESSION:
! staffs[baddr]

IRs:
REF_21(bool) -> staffs[baddr]
TMP_50 = UnaryType.BANG REF_21 
CONDITION TMP_50""];
8->9[label=""True""];
8->11[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
staffs[baddr] = true

IRs:
REF_22(bool) -> staffs[baddr]
REF_22(bool) (->staffs) := True(bool)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
staffaddress.push(baddr) - 1

IRs:
REF_24 -> LENGTH staffaddress
TMP_53(uint256) := REF_24(uint256)
TMP_54(uint256) = TMP_53 + 1
REF_24(uint256) (->staffaddress) := TMP_54(uint256)
REF_25(address) -> staffaddress[TMP_53]
REF_25(address) (->staffaddress) := baddr(address)
TMP_52(None) = TMP_51 - 1""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
i ++

IRs:
TMP_55(uint256) := i(uint256)
i(uint256) = i + 1""];
13->5;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyAdmin()()""];
14->1;
}
",0,1,1,0,onlyAdmin();require(bool)(_userlist.length > 0);i = 0;;i < _userlist.length;;baddr = _userlist[i];baddr != address(0);! staffs[baddr];;staffs[baddr] = true;;staffaddress.push(baddr) - 1;i ++
./0xce51f6cac9fb2695d944f2d5e2699d68aa7b656e_ext.sol,Locksmith.kill,147,150,"TMP_99(None) = SOLIDITY_CALL require(bool)(didProve),TMP_100(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(didProve)

IRs:
TMP_99(None) = SOLIDITY_CALL require(bool)(didProve)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_100(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();require(bool)(didProve);selfdestruct(address)(owner)
./0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb_ext.sol,OrganizeFunds.withdraw,181,199,"i(uint256) := 0(uint256),TMP_26(bool) = i < activityCount,CONDITION TMP_26,REF_34(OrganizeFunds.ActivityAccount) -> activityAccounts[i],REF_35(address) -> REF_34.addr,addr(address) := REF_35(address),TMP_27(bool) = addr == msg.sender,TMP_28(bool) = msg.sender == owner,TMP_29(bool) = TMP_27 || TMP_28,CONDITION TMP_29,REF_36(OrganizeFunds.ActivityAccount) -> activityAccounts[i],REF_37(uint256) -> REF_36.balance,amount(uint256) := REF_37(uint256),TMP_30(bool) = amount > 0,CONDITION TMP_30,REF_38(OrganizeFunds.ActivityAccount) -> activityAccounts[i],REF_39(uint256) -> REF_38.balance,REF_39(uint256) (->activityAccounts) := 0(uint256),totalFundsWithdrawn(uint256) = totalFundsWithdrawn + amount,TMP_33(bool) = LOW_LEVEL_CALL, dest:addr, function:call, arguments:[] value:amount gas:withdrawGas,TMP_34 = UnaryType.BANG TMP_33 ,CONDITION TMP_34,REF_43(OrganizeFunds.ActivityAccount) -> activityAccounts[i],REF_44(uint256) -> REF_43.balance,REF_44(uint256) (->activityAccounts) := amount(uint256),totalFundsWithdrawn(uint256) = totalFundsWithdrawn - amount,Emit MessageEvent(err: error sending funds),TMP_36(uint256) := i(uint256),i(uint256) = i + 1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < activityCount

IRs:
TMP_26(bool) = i < activityCount
CONDITION TMP_26""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
addr = activityAccounts[i].addr

IRs:
REF_34(OrganizeFunds.ActivityAccount) -> activityAccounts[i]
REF_35(address) -> REF_34.addr
addr(address) := REF_35(address)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
addr == msg.sender || msg.sender == owner

IRs:
TMP_27(bool) = addr == msg.sender
TMP_28(bool) = msg.sender == owner
TMP_29(bool) = TMP_27 || TMP_28
CONDITION TMP_29""];
6->7[label=""True""];
6->18[label=""False""];
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
amount = activityAccounts[i].balance

IRs:
REF_36(OrganizeFunds.ActivityAccount) -> activityAccounts[i]
REF_37(uint256) -> REF_36.balance
amount(uint256) := REF_37(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
amount > 0

IRs:
TMP_30(bool) = amount > 0
CONDITION TMP_30""];
8->9[label=""True""];
8->17[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
activityAccounts[i].balance = 0

IRs:
REF_38(OrganizeFunds.ActivityAccount) -> activityAccounts[i]
REF_39(uint256) -> REF_38.balance
REF_39(uint256) (->activityAccounts) := 0(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
totalFundsWithdrawn += amount

IRs:
totalFundsWithdrawn(uint256) = totalFundsWithdrawn + amount""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
! addr.call.gas(withdrawGas).value(amount)()

IRs:
TMP_33(bool) = LOW_LEVEL_CALL, dest:addr, function:call, arguments:[] value:amount gas:withdrawGas
TMP_34 = UnaryType.BANG TMP_33 
CONDITION TMP_34""];
11->12[label=""True""];
11->16[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
activityAccounts[i].balance = amount

IRs:
REF_43(OrganizeFunds.ActivityAccount) -> activityAccounts[i]
REF_44(uint256) -> REF_43.balance
REF_44(uint256) (->activityAccounts) := amount(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
totalFundsWithdrawn -= amount

IRs:
totalFundsWithdrawn(uint256) = totalFundsWithdrawn - amount""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
MessageEvent(err: error sending funds)

IRs:
Emit MessageEvent(err: error sending funds)""];
14->15;
15[label=""Node Type: RETURN 15
""];
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
i ++

IRs:
TMP_36(uint256) := i(uint256)
i(uint256) = i + 1""];
19->4;
}
",0,0,1,0,i = 0;;i < activityCount;;addr = activityAccounts[i].addr;addr == msg.sender || msg.sender == owner;amount = activityAccounts[i].balance;;amount > 0;activityAccounts[i].balance = 0;;totalFundsWithdrawn += amount;! addr.call.gas(withdrawGas).value(amount)();activityAccounts[i].balance = amount;;totalFundsWithdrawn -= amount;MessageEvent(err: error sending funds);;i ++
./0x6947335452cb7a452fc337c28cb0d597806c7672_ext.sol,SmartWeddingContract.divorce,238,267,"REF_47(bool) -> hasDivorced[msg.sender],TMP_94(bool) = REF_47 == False,TMP_95(None) = SOLIDITY_CALL require(bool,string)(TMP_94,Sender has already approved to divorce!),REF_48(bool) -> hasDivorced[msg.sender],REF_48(bool) (->hasDivorced) := True(bool),Emit DivorceApproved(now,msg.sender),REF_49(bool) -> hasDivorced[husbandAddress],REF_50(bool) -> hasDivorced[wifeAddress],TMP_97(bool) = REF_49 && REF_50,CONDITION TMP_97,divorced(bool) := True(bool),Emit Divorced(now),TMP_99 = CONVERT this to address,TMP_100(uint256) = SOLIDITY_CALL balance(address)(TMP_99),balance(uint256) := TMP_100(uint256),TMP_101(bool) = balance != 0,CONDITION TMP_101,TMP_102(uint256) = balance / 2,balancePerSpouse(uint256) := TMP_102(uint256),Transfer dest:husbandAddress value:balancePerSpouse,Emit FundsSent(now,husbandAddress,balancePerSpouse),Transfer dest:wifeAddress value:balancePerSpouse,Emit FundsSent(now,wifeAddress,balancePerSpouse),MODIFIER_CALL, SmartWeddingContract.onlySpouse()(),MODIFIER_CALL, SmartWeddingContract.isSigned()(),MODIFIER_CALL, SmartWeddingContract.isNotDivorced()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->16;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(hasDivorced[msg.sender] == false,Sender has already approved to divorce!)

IRs:
REF_47(bool) -> hasDivorced[msg.sender]
TMP_94(bool) = REF_47 == False
TMP_95(None) = SOLIDITY_CALL require(bool,string)(TMP_94,Sender has already approved to divorce!)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
hasDivorced[msg.sender] = true

IRs:
REF_48(bool) -> hasDivorced[msg.sender]
REF_48(bool) (->hasDivorced) := True(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
DivorceApproved(now,msg.sender)

IRs:
Emit DivorceApproved(now,msg.sender)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
hasDivorced[husbandAddress] && hasDivorced[wifeAddress]

IRs:
REF_49(bool) -> hasDivorced[husbandAddress]
REF_50(bool) -> hasDivorced[wifeAddress]
TMP_97(bool) = REF_49 && REF_50
CONDITION TMP_97""];
4->5[label=""True""];
4->15[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
divorced = true

IRs:
divorced(bool) := True(bool)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Divorced(now)

IRs:
Emit Divorced(now)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
balance = address(this).balance

IRs:
TMP_99 = CONVERT this to address
TMP_100(uint256) = SOLIDITY_CALL balance(address)(TMP_99)
balance(uint256) := TMP_100(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
balance != 0

IRs:
TMP_101(bool) = balance != 0
CONDITION TMP_101""];
8->9[label=""True""];
8->14[label=""False""];
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
balancePerSpouse = balance / 2

IRs:
TMP_102(uint256) = balance / 2
balancePerSpouse(uint256) := TMP_102(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
husbandAddress.transfer(balancePerSpouse)

IRs:
Transfer dest:husbandAddress value:balancePerSpouse""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
FundsSent(now,husbandAddress,balancePerSpouse)

IRs:
Emit FundsSent(now,husbandAddress,balancePerSpouse)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
wifeAddress.transfer(balancePerSpouse)

IRs:
Transfer dest:wifeAddress value:balancePerSpouse""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
FundsSent(now,wifeAddress,balancePerSpouse)

IRs:
Emit FundsSent(now,wifeAddress,balancePerSpouse)""];
13->14;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: END_IF 15
""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
onlySpouse()

IRs:
MODIFIER_CALL, SmartWeddingContract.onlySpouse()()""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
isSigned()

IRs:
MODIFIER_CALL, SmartWeddingContract.isSigned()()""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
isNotDivorced()

IRs:
MODIFIER_CALL, SmartWeddingContract.isNotDivorced()()""];
18->1;
}
",0,0,1,0,"onlySpouse();require(bool,string)(hasDivorced[msg.sender] == false,Sender has already approved to divorce!);hasDivorced[msg.sender] = true;DivorceApproved(now,msg.sender);hasDivorced[husbandAddress] && hasDivorced[wifeAddress];divorced = true;;Divorced(now);balance = address(this).balance;balance != 0;balancePerSpouse = balance / 2;;husbandAddress.transfer(balancePerSpouse);FundsSent(now,husbandAddress,balancePerSpouse);wifeAddress.transfer(balancePerSpouse);FundsSent(now,wifeAddress,balancePerSpouse);isSigned();isNotDivorced()"
./0xd39ff379cb1f4d6f2aade581c039c15db2cb28f8_ext.sol,BackMeApp.esteem,31,39,"TMP_1 = CONVERT _message to bytes,REF_3 -> LENGTH TMP_1,TMP_2(bool) = REF_3 <= 300,TMP_3(None) = SOLIDITY_CALL assert(bool)(TMP_2),REF_4(BackMeApp.EtherBox) -> etherBoxes[_to],etherBox(BackMeApp.EtherBox) := REF_4(BackMeApp.EtherBox),REF_5(uint256) -> etherBox.expiration,TMP_4(bool) = REF_5 > now,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_6(address) -> etherBox.owner,TMP_6 = CONVERT 0 to address,TMP_7(bool) = REF_6 != TMP_6,TMP_8(None) = SOLIDITY_CALL assert(bool)(TMP_7),REF_7(bytes32) -> nicknames[msg.sender],REF_7(bytes32) (->nicknames) := _nickname(bytes32),REF_8(bytes32) -> etherBox.label,Emit NewEsteem(msg.sender,_nickname,_to,REF_8,_message,msg.value,now),REF_9(address) -> etherBox.owner,Transfer dest:REF_9 value:msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(bytes(_message).length <= 300)

IRs:
TMP_1 = CONVERT _message to bytes
REF_3 -> LENGTH TMP_1
TMP_2(bool) = REF_3 <= 300
TMP_3(None) = SOLIDITY_CALL assert(bool)(TMP_2)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
etherBox = etherBoxes[_to]

IRs:
REF_4(BackMeApp.EtherBox) -> etherBoxes[_to]
etherBox(BackMeApp.EtherBox) := REF_4(BackMeApp.EtherBox)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(etherBox.expiration > now)

IRs:
REF_5(uint256) -> etherBox.expiration
TMP_4(bool) = REF_5 > now
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
assert(bool)(etherBox.owner != address(0))

IRs:
REF_6(address) -> etherBox.owner
TMP_6 = CONVERT 0 to address
TMP_7(bool) = REF_6 != TMP_6
TMP_8(None) = SOLIDITY_CALL assert(bool)(TMP_7)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
nicknames[msg.sender] = _nickname

IRs:
REF_7(bytes32) -> nicknames[msg.sender]
REF_7(bytes32) (->nicknames) := _nickname(bytes32)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
NewEsteem(msg.sender,_nickname,_to,etherBox.label,_message,msg.value,now)

IRs:
REF_8(bytes32) -> etherBox.label
Emit NewEsteem(msg.sender,_nickname,_to,REF_8,_message,msg.value,now)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
etherBox.owner.transfer(msg.value)

IRs:
REF_9(address) -> etherBox.owner
Transfer dest:REF_9 value:msg.value""];
}
",0,0,1,0,"assert(bool)(bytes(_message).length <= 300);etherBox = etherBoxes[_to];require(bool)(etherBox.expiration > now);assert(bool)(etherBox.owner != address(0));nicknames[msg.sender] = _nickname;NewEsteem(msg.sender,_nickname,_to,etherBox.label,_message,msg.value,now);etherBox.owner.transfer(msg.value)"
./0x006ff3494c04680cfbf39b0396054486f3f6ad32_ext.sol,PLAY_NOW.StopGame,29,32,"TMP_9(bool) = msg.sender == questionSender,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_9(bool) = msg.sender == questionSender
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0x1767856bc75cf070de5e6ba3d0c718440f008c66_ext.sol,TimeCapsuleEvent.kill,55,58,"REF_5(uint256) = SOLIDITY_CALL balance(address)(this),TMP_16(bool) = REF_5 == 0,CONDITION TMP_16,TMP_17(None) = SOLIDITY_CALL suicide(address)(msg.sender),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: IF 1

EXPRESSION:
this.balance == 0

IRs:
REF_5(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_16(bool) = REF_5 == 0
CONDITION TMP_16""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
suicide(address)(msg.sender)

IRs:
TMP_17(None) = SOLIDITY_CALL suicide(address)(msg.sender)""];
2->3;
3[label=""Node Type: END_IF 3
""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();this.balance == 0;suicide(address)(msg.sender);
./0x325f89386b72087530440e0bceb8490d78b47f21_ext.sol,EtherStore.changeWrapper,290,294,"TMP_209 = CONVERT EtherWrapper to EthWrapper_Interface,REF_191(uint256) = SOLIDITY_CALL balance(address)(this),HIGH_LEVEL_CALL, dest:TMP_209(EthWrapper_Interface), function:wrapperChanged, arguments:[] value:REF_191 ,Emit WrapperChanged(EtherWrapper,_wrapper),EtherWrapper(address) := _wrapper(address),MODIFIER_CALL, AdminAccess.onlyAdmin(uint8)(2),MODIFIER_CALL, EtherStore.WrapperEnabled()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
EthWrapper_Interface(EtherWrapper).wrapperChanged.value(this.balance)()

IRs:
TMP_209 = CONVERT EtherWrapper to EthWrapper_Interface
REF_191(uint256) = SOLIDITY_CALL balance(address)(this)
HIGH_LEVEL_CALL, dest:TMP_209(EthWrapper_Interface), function:wrapperChanged, arguments:[] value:REF_191 ""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
WrapperChanged(EtherWrapper,_wrapper)

IRs:
Emit WrapperChanged(EtherWrapper,_wrapper)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
EtherWrapper = _wrapper

IRs:
EtherWrapper(address) := _wrapper(address)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyAdmin(2)

IRs:
MODIFIER_CALL, AdminAccess.onlyAdmin(uint8)(2)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
WrapperEnabled()

IRs:
MODIFIER_CALL, EtherStore.WrapperEnabled()()""];
5->1;
}
",1,0,1,0,"onlyAdmin(2);EthWrapper_Interface(EtherWrapper).wrapperChanged.value(this.balance)();WrapperChanged(EtherWrapper,_wrapper);EtherWrapper = _wrapper;WrapperEnabled()"
./0x8cd06b5c327b0e277a7f6b08b9acea4d8ee36180_ext.sol,JungleScratch.chargeOwe,192,203,"REF_94(JungleScratch.Game) -> TicketPool[secretKey_D_hash],REF_95(bool) -> REF_94.isPay,TMP_165 = UnaryType.BANG REF_95 ,TMP_166(None) = SOLIDITY_CALL require(bool)(TMP_165),REF_96(JungleScratch.Game) -> TicketPool[secretKey_D_hash],REF_97(bool) -> REF_96.isPlay,TMP_167(None) = SOLIDITY_CALL require(bool)(REF_97),REF_98(JungleScratch.Game) -> TicketPool[secretKey_D_hash],REF_99(uint256) -> REF_98.Result,TMP_168(bool) = REF_99 != 0,TMP_169(None) = SOLIDITY_CALL require(bool)(TMP_168),TMP_170 = CONVERT this to address,TMP_171(uint256) = SOLIDITY_CALL balance(address)(TMP_170),REF_100(JungleScratch.Game) -> TicketPool[secretKey_D_hash],REF_101(uint256) -> REF_100.Result,TMP_172(bool) = TMP_171 >= REF_101,CONDITION TMP_172,REF_102(JungleScratch.Game) -> TicketPool[secretKey_D_hash],REF_103(address) -> REF_102.Buyer,REF_105(JungleScratch.Game) -> TicketPool[secretKey_D_hash],REF_106(uint256) -> REF_105.Result,TMP_173 = SEND dest:REF_103 value:REF_106,CONDITION TMP_173,REF_107(JungleScratch.Game) -> TicketPool[secretKey_D_hash],REF_108(bool) -> REF_107.isPay,REF_108(bool) (->TicketPool) := True(bool),REF_109(JungleScratch.Game) -> TicketPool[secretKey_D_hash],REF_110(address) -> REF_109.Buyer,REF_111(JungleScratch.Game) -> TicketPool[secretKey_D_hash],REF_112(uint256) -> REF_111.Result,Emit OwePay(secretKey_D_hash,REF_110,REF_112)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! TicketPool[secretKey_D_hash].isPay)

IRs:
REF_94(JungleScratch.Game) -> TicketPool[secretKey_D_hash]
REF_95(bool) -> REF_94.isPay
TMP_165 = UnaryType.BANG REF_95 
TMP_166(None) = SOLIDITY_CALL require(bool)(TMP_165)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(TicketPool[secretKey_D_hash].isPlay)

IRs:
REF_96(JungleScratch.Game) -> TicketPool[secretKey_D_hash]
REF_97(bool) -> REF_96.isPlay
TMP_167(None) = SOLIDITY_CALL require(bool)(REF_97)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(TicketPool[secretKey_D_hash].Result != 0)

IRs:
REF_98(JungleScratch.Game) -> TicketPool[secretKey_D_hash]
REF_99(uint256) -> REF_98.Result
TMP_168(bool) = REF_99 != 0
TMP_169(None) = SOLIDITY_CALL require(bool)(TMP_168)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
address(this).balance >= TicketPool[secretKey_D_hash].Result

IRs:
TMP_170 = CONVERT this to address
TMP_171(uint256) = SOLIDITY_CALL balance(address)(TMP_170)
REF_100(JungleScratch.Game) -> TicketPool[secretKey_D_hash]
REF_101(uint256) -> REF_100.Result
TMP_172(bool) = TMP_171 >= REF_101
CONDITION TMP_172""];
4->5[label=""True""];
4->9[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
TicketPool[secretKey_D_hash].Buyer.send(TicketPool[secretKey_D_hash].Result)

IRs:
REF_102(JungleScratch.Game) -> TicketPool[secretKey_D_hash]
REF_103(address) -> REF_102.Buyer
REF_105(JungleScratch.Game) -> TicketPool[secretKey_D_hash]
REF_106(uint256) -> REF_105.Result
TMP_173 = SEND dest:REF_103 value:REF_106
CONDITION TMP_173""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
TicketPool[secretKey_D_hash].isPay = true

IRs:
REF_107(JungleScratch.Game) -> TicketPool[secretKey_D_hash]
REF_108(bool) -> REF_107.isPay
REF_108(bool) (->TicketPool) := True(bool)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
OwePay(secretKey_D_hash,TicketPool[secretKey_D_hash].Buyer,TicketPool[secretKey_D_hash].Result)

IRs:
REF_109(JungleScratch.Game) -> TicketPool[secretKey_D_hash]
REF_110(address) -> REF_109.Buyer
REF_111(JungleScratch.Game) -> TicketPool[secretKey_D_hash]
REF_112(uint256) -> REF_111.Result
Emit OwePay(secretKey_D_hash,REF_110,REF_112)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
}
",0,0,1,0,"require(bool)(! TicketPool[secretKey_D_hash].isPay);require(bool)(TicketPool[secretKey_D_hash].isPlay);require(bool)(TicketPool[secretKey_D_hash].Result != 0);address(this).balance >= TicketPool[secretKey_D_hash].Result;TicketPool[secretKey_D_hash].Buyer.send(TicketPool[secretKey_D_hash].Result);;TicketPool[secretKey_D_hash].isPay = true;;OwePay(secretKey_D_hash,TicketPool[secretKey_D_hash].Buyer,TicketPool[secretKey_D_hash].Result)"
./0x83d3abc4e75885db350ace57f99c3a3e00286fe8_ext.sol,BetaCoin.withdraw,214,218,"REF_92(uint256) = SOLIDITY_CALL balance(address)(this),etherBalance(uint256) := REF_92([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E2536FD0>]),owner(address) := msg.sender(address),Transfer dest:owner value:etherBalance,MODIFIER_CALL, BetaCoin.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
etherBalance = this.balance

IRs:
REF_92(uint256) = SOLIDITY_CALL balance(address)(this)
etherBalance(uint256) := REF_92([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E2536FD0>])""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(etherBalance)

IRs:
Transfer dest:owner value:etherBalance""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, BetaCoin.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();etherBalance = this.balance;owner = msg.sender;owner.transfer(etherBalance)
./0x6ace03f517ae15f1a8d1b6811d23f7aa8c295be0_ext.sol,RefundVault.close,154,159,"REF_5(RefundVault.State) -> State.Active,TMP_39(bool) = state == REF_5,TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39),REF_6(RefundVault.State) -> State.Closed,state(RefundVault.State) := REF_6(RefundVault.State),Emit Closed(),TMP_42 = CONVERT this to address,TMP_43(uint256) = SOLIDITY_CALL balance(address)(TMP_42),Transfer dest:wallet value:TMP_43,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_5(RefundVault.State) -> State.Active
TMP_39(bool) = state == REF_5
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
state = State.Closed

IRs:
REF_6(RefundVault.State) -> State.Closed
state(RefundVault.State) := REF_6(RefundVault.State)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Closed()

IRs:
Emit Closed()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
wallet.transfer(address(this).balance)

IRs:
TMP_42 = CONVERT this to address
TMP_43(uint256) = SOLIDITY_CALL balance(address)(TMP_42)
Transfer dest:wallet value:TMP_43""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();require(bool)(state == State.Active);state = State.Closed;Closed();wallet.transfer(address(this).balance)
./0xb387be1e10d56bd7c6849b7be9d6aad564854d72_ext.sol,Alfa_quiZ.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37_ext.sol,WhaleGiveaway1.withdraw,25,31,"TMP_3(bool) = msg.sender == 698670862888103124090043688033161627232733560907,CONDITION TMP_3,Owner(address) := 698670862888103124090043688033161627232733560907(address),TMP_4(bool) = msg.sender == Owner,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_5(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:Owner value:REF_5","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == 0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b

IRs:
TMP_3(bool) = msg.sender == 698670862888103124090043688033161627232733560907
CONDITION TMP_3""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Owner = 0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b

IRs:
Owner(address) := 698670862888103124090043688033161627232733560907(address)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(msg.sender == Owner)

IRs:
TMP_4(bool) = msg.sender == Owner
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Owner.transfer(this.balance)

IRs:
REF_5(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:Owner value:REF_5""];
}
",0,0,1,0,msg.sender == 0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;Owner = 0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;;require(bool)(msg.sender == Owner);Owner.transfer(this.balance)
./0x1bee0ba6c6dee64b3ea062ba2f779e0e8ff4d733_ext.sol,SIMPLECOIN.pullEtherFromContractAfterPreICOPrivate,382,395,"CONDITION isPreICOPrivateOpened,TMP_139(None) = SOLIDITY_CALL revert()(),TMP_140 = UnaryType.BANG isPreICOPrivateClosed ,CONDITION TMP_140,TMP_141(None) = SOLIDITY_CALL revert()(),CONDITION isPreICOPublicOpened,TMP_142(None) = SOLIDITY_CALL revert()(),CONDITION isPreICOPublicClosed,TMP_143(None) = SOLIDITY_CALL revert()(),CONDITION isICOOpened,TMP_144(None) = SOLIDITY_CALL revert()(),CONDITION isICOClosed,TMP_145(None) = SOLIDITY_CALL revert()(),REF_62(uint256) = SOLIDITY_CALL balance(address)(this),TMP_146 = SEND dest:TEAM_WALLET value:REF_62,TMP_147 = UnaryType.BANG TMP_146 ,CONDITION TMP_147,TMP_148(None) = SOLIDITY_CALL revert()(),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->22;
1[label=""Node Type: IF 1

EXPRESSION:
isPreICOPrivateOpened

IRs:
CONDITION isPreICOPrivateOpened""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_139(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
! isPreICOPrivateClosed

IRs:
TMP_140 = UnaryType.BANG isPreICOPrivateClosed 
CONDITION TMP_140""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
revert()()

IRs:
TMP_141(None) = SOLIDITY_CALL revert()()""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
isPreICOPublicOpened

IRs:
CONDITION isPreICOPublicOpened""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
revert()()

IRs:
TMP_142(None) = SOLIDITY_CALL revert()()""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
isPreICOPublicClosed

IRs:
CONDITION isPreICOPublicClosed""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
revert()()

IRs:
TMP_143(None) = SOLIDITY_CALL revert()()""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
isICOOpened

IRs:
CONDITION isICOOpened""];
13->14[label=""True""];
13->15[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
revert()()

IRs:
TMP_144(None) = SOLIDITY_CALL revert()()""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: IF 16

EXPRESSION:
isICOClosed

IRs:
CONDITION isICOClosed""];
16->17[label=""True""];
16->18[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
revert()()

IRs:
TMP_145(None) = SOLIDITY_CALL revert()()""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: IF 19

EXPRESSION:
! TEAM_WALLET.send(this.balance)

IRs:
REF_62(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_146 = SEND dest:TEAM_WALLET value:REF_62
TMP_147 = UnaryType.BANG TMP_146 
CONDITION TMP_147""];
19->20[label=""True""];
19->21[label=""False""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
revert()()

IRs:
TMP_148(None) = SOLIDITY_CALL revert()()""];
20->21;
21[label=""Node Type: END_IF 21
""];
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
22->1;
}
",0,0,1,0,onlyOwner();isPreICOPrivateOpened;revert()();;! isPreICOPrivateClosed;revert()();;isPreICOPublicOpened;revert()();;isPreICOPublicClosed;revert()();;isICOOpened;revert()();;isICOClosed;revert()();;! TEAM_WALLET.send(this.balance);revert()();
./0x7fceafdefc16b0f703a43ffb0451ddd2a7cbd6dc_ext.sol,alfa_Quiz.Stop,26,28,"REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3,MODIFIER_CALL, alfa_Quiz.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, alfa_Quiz.isAdmin()()""];
2->1;
}
",0,0,1,0,isAdmin();msg.sender.transfer(this.balance)
./0x2aaefbac989f8951436c36474c304af7bf31bb26_ext.sol,Broker.claimBrokerFee,242,248,"REF_34(uint256) -> BrokerIncoming[msg.sender],fee(uint256) := REF_34(uint256),TMP_209(bool) = fee > 0,TMP_210(None) = SOLIDITY_CALL require(bool)(TMP_209),Transfer dest:msg.sender value:fee,REF_36(uint256) -> BrokerIncoming[msg.sender],REF_36(uint256) (->BrokerIncoming) := 0(uint256),Emit BrokerFeeClaim(msg.sender,fee),MODIFIER_CALL, Administration.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
fee = BrokerIncoming[msg.sender]

IRs:
REF_34(uint256) -> BrokerIncoming[msg.sender]
fee(uint256) := REF_34(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(fee > 0)

IRs:
TMP_209(bool) = fee > 0
TMP_210(None) = SOLIDITY_CALL require(bool)(TMP_209)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(fee)

IRs:
Transfer dest:msg.sender value:fee""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
BrokerIncoming[msg.sender] = 0

IRs:
REF_36(uint256) -> BrokerIncoming[msg.sender]
REF_36(uint256) (->BrokerIncoming) := 0(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
BrokerFeeClaim(msg.sender,fee)

IRs:
Emit BrokerFeeClaim(msg.sender,fee)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Administration.whenNotPaused()()""];
6->1;
}
",0,0,1,0,"whenNotPaused();fee = BrokerIncoming[msg.sender];require(bool)(fee > 0);msg.sender.transfer(fee);BrokerIncoming[msg.sender] = 0;BrokerFeeClaim(msg.sender,fee)"
./0x1f4215fe007ee5b170391241656a28a8bd13826e_ext.sol,VVToken.executeTransaction,254,260,"TMP_153(bool) = INTERNAL_CALL, VVToken.isConfirmed(bytes32)(TransHash),CONDITION TMP_153,REF_103(VVToken.Transaction) -> Transactions[TransHash],REF_104(bool) -> REF_103.executed,REF_104(bool) (->Transactions) := True(bool),REF_105(VVToken.Transaction) -> Transactions[TransHash],REF_106(address) -> REF_105.destination,REF_109(VVToken.Transaction) -> Transactions[TransHash],REF_110(uint256) -> REF_109.value,REF_111(VVToken.Transaction) -> Transactions[TransHash],REF_112(bytes) -> REF_111.data,TMP_155(bool) = LOW_LEVEL_CALL, dest:REF_106, function:call, arguments:['REF_112'] value:REF_110 ,TMP_156(None) = SOLIDITY_CALL require(bool)(TMP_155),Emit Execution(TransHash),MODIFIER_CALL, VVToken.notExecuted(bytes32)(TransHash)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: IF 1

EXPRESSION:
isConfirmed(TransHash)

IRs:
TMP_153(bool) = INTERNAL_CALL, VVToken.isConfirmed(bytes32)(TransHash)
CONDITION TMP_153""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Transactions[TransHash].executed = true

IRs:
REF_103(VVToken.Transaction) -> Transactions[TransHash]
REF_104(bool) -> REF_103.executed
REF_104(bool) (->Transactions) := True(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data))

IRs:
REF_105(VVToken.Transaction) -> Transactions[TransHash]
REF_106(address) -> REF_105.destination
REF_109(VVToken.Transaction) -> Transactions[TransHash]
REF_110(uint256) -> REF_109.value
REF_111(VVToken.Transaction) -> Transactions[TransHash]
REF_112(bytes) -> REF_111.data
TMP_155(bool) = LOW_LEVEL_CALL, dest:REF_106, function:call, arguments:['REF_112'] value:REF_110 
TMP_156(None) = SOLIDITY_CALL require(bool)(TMP_155)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Execution(TransHash)

IRs:
Emit Execution(TransHash)""];
4->5;
5[label=""Node Type: END_IF 5
""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
notExecuted(TransHash)

IRs:
MODIFIER_CALL, VVToken.notExecuted(bytes32)(TransHash)""];
6->1;
}
",0,0,1,0,notExecuted(TransHash);isConfirmed(TransHash);Transactions[TransHash].executed = true;;require(bool)(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));Execution(TransHash)
./0x777777764382a3ae5e7631570583893bfdea7e05_ext.sol,Destructible.destroy,103,105,"TMP_25(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_25(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0xee7477b1c42d173c0791cecf2592f6a8a4c16b0a_ext.sol,BiddingBase.withdraw,107,120,"REF_0(uint256) -> pendingReturns[msg.sender],amount(uint256) := REF_0(uint256),TMP_34(bool) = amount > 0,TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34),totalReturns(uint256) = totalReturns - amount,REF_1(uint256) -> pendingReturns[msg.sender],REF_1(-> pendingReturns) = REF_1 - amount,Transfer dest:msg.sender value:amount,Emit Withdraw(msg.sender,amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
amount = pendingReturns[msg.sender]

IRs:
REF_0(uint256) -> pendingReturns[msg.sender]
amount(uint256) := REF_0(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_34(bool) = amount > 0
TMP_35(None) = SOLIDITY_CALL require(bool)(TMP_34)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalReturns -= amount

IRs:
totalReturns(uint256) = totalReturns - amount""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
pendingReturns[msg.sender] -= amount

IRs:
REF_1(uint256) -> pendingReturns[msg.sender]
REF_1(-> pendingReturns) = REF_1 - amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Withdraw(msg.sender,amount)

IRs:
Emit Withdraw(msg.sender,amount)""];
}
",0,0,1,0,"amount = pendingReturns[msg.sender];require(bool)(amount > 0);totalReturns -= amount;pendingReturns[msg.sender] -= amount;msg.sender.transfer(amount);Withdraw(msg.sender,amount)"
./0x35bab7165a301e99c75c3e59b48817856b4d5e5c_ext.sol,Bet.withdraw,498,503,"TMP_158(None) = SOLIDITY_CALL require(bool)(isBetClosed),TMP_159 = CONVERT this to address,TMP_160(uint256) = SOLIDITY_CALL balance(address)(TMP_159),_balance(uint256) := TMP_160(uint256),REF_89(address) -> betInfo.dealer,Transfer dest:REF_89 value:_balance,REF_91(address) -> betInfo.dealer,Emit LogDealerWithdraw(REF_91,_balance)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isBetClosed)

IRs:
TMP_158(None) = SOLIDITY_CALL require(bool)(isBetClosed)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
_balance = address(this).balance

IRs:
TMP_159 = CONVERT this to address
TMP_160(uint256) = SOLIDITY_CALL balance(address)(TMP_159)
_balance(uint256) := TMP_160(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
betInfo.dealer.transfer(_balance)

IRs:
REF_89(address) -> betInfo.dealer
Transfer dest:REF_89 value:_balance""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
LogDealerWithdraw(betInfo.dealer,_balance)

IRs:
REF_91(address) -> betInfo.dealer
Emit LogDealerWithdraw(REF_91,_balance)""];
}
",0,0,1,0,"require(bool)(isBetClosed);_balance = address(this).balance;betInfo.dealer.transfer(_balance);LogDealerWithdraw(betInfo.dealer,_balance)"
./0x4ee1ba168551379fd8a59e2e918ff9ee109a6abf_ext.sol,PlayerBook.registerNameCore,385,412,"REF_105(uint256) -> pIDxName_[_name],TMP_80(bool) = REF_105 != 0,CONDITION TMP_80,REF_106(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_107(bool) -> REF_106[_name],TMP_81(bool) = REF_107 == True,TMP_82(None) = SOLIDITY_CALL require(bool,string)(TMP_81,sorry that names already taken),REF_108(PlayerBook.Player) -> plyr_[_pID],REF_109(bytes32) -> REF_108.name,REF_109(bytes32) (->plyr_) := _name(bytes32),REF_110(uint256) -> pIDxName_[_name],REF_110(uint256) (->pIDxName_) := _pID(uint256),REF_111(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_112(bool) -> REF_111[_name],TMP_83(bool) = REF_112 == False,CONDITION TMP_83,REF_113(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_114(bool) -> REF_113[_name],REF_114(bool) (->plyrNames_) := True(bool),REF_115(PlayerBook.Player) -> plyr_[_pID],REF_116(uint256) -> REF_115.names,TMP_84(uint256) := REF_116(uint256),REF_116(-> plyr_) = REF_116 + 1,REF_117(mapping(uint256 => bytes32)) -> plyrNameList_[_pID],REF_118(PlayerBook.Player) -> plyr_[_pID],REF_119(uint256) -> REF_118.names,REF_120(bytes32) -> REF_117[REF_119],REF_120(bytes32) (->plyrNameList_) := _name(bytes32),TMP_85 = CONVERT this to address,TMP_86(uint256) = SOLIDITY_CALL balance(address)(TMP_85),HIGH_LEVEL_CALL, dest:TeamDreamHub_(TeamDreamHubInterface), function:deposit, arguments:[] value:TMP_86 ,TMP_89(bool) = _all == True,CONDITION TMP_89,i(uint256) := 1(uint256),TMP_90(bool) = i <= gID_,CONDITION TMP_90,REF_123(PlayerBookReceiverInterface) -> games_[i],HIGH_LEVEL_CALL, dest:REF_123(PlayerBookReceiverInterface), function:receivePlayerInfo, arguments:['_pID', '_addr', '_name', '_affID']  ,TMP_92(uint256) := i(uint256),i(uint256) = i + 1,REF_125(PlayerBook.Player) -> plyr_[_affID],REF_126(address) -> REF_125.addr,REF_127(PlayerBook.Player) -> plyr_[_affID],REF_128(bytes32) -> REF_127.name,Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_126,REF_128,msg.value,now)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
pIDxName_[_name] != 0

IRs:
REF_105(uint256) -> pIDxName_[_name]
TMP_80(bool) = REF_105 != 0
CONDITION TMP_80""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(plyrNames_[_pID][_name] == true,sorry that names already taken)

IRs:
REF_106(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_107(bool) -> REF_106[_name]
TMP_81(bool) = REF_107 == True
TMP_82(None) = SOLIDITY_CALL require(bool,string)(TMP_81,sorry that names already taken)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
plyr_[_pID].name = _name

IRs:
REF_108(PlayerBook.Player) -> plyr_[_pID]
REF_109(bytes32) -> REF_108.name
REF_109(bytes32) (->plyr_) := _name(bytes32)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
pIDxName_[_name] = _pID

IRs:
REF_110(uint256) -> pIDxName_[_name]
REF_110(uint256) (->pIDxName_) := _pID(uint256)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
plyrNames_[_pID][_name] == false

IRs:
REF_111(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_112(bool) -> REF_111[_name]
TMP_83(bool) = REF_112 == False
CONDITION TMP_83""];
6->7[label=""True""];
6->10[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
plyrNames_[_pID][_name] = true

IRs:
REF_113(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_114(bool) -> REF_113[_name]
REF_114(bool) (->plyrNames_) := True(bool)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
plyr_[_pID].names ++

IRs:
REF_115(PlayerBook.Player) -> plyr_[_pID]
REF_116(uint256) -> REF_115.names
TMP_84(uint256) := REF_116(uint256)
REF_116(-> plyr_) = REF_116 + 1""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
plyrNameList_[_pID][plyr_[_pID].names] = _name

IRs:
REF_117(mapping(uint256 => bytes32)) -> plyrNameList_[_pID]
REF_118(PlayerBook.Player) -> plyr_[_pID]
REF_119(uint256) -> REF_118.names
REF_120(bytes32) -> REF_117[REF_119]
REF_120(bytes32) (->plyrNameList_) := _name(bytes32)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
TeamDreamHub_.deposit.value(address(this).balance)()

IRs:
TMP_85 = CONVERT this to address
TMP_86(uint256) = SOLIDITY_CALL balance(address)(TMP_85)
HIGH_LEVEL_CALL, dest:TeamDreamHub_(TeamDreamHubInterface), function:deposit, arguments:[] value:TMP_86 ""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
_all == true

IRs:
TMP_89(bool) = _all == True
CONDITION TMP_89""];
12->15[label=""True""];
12->19[label=""False""];
13[label=""Node Type: BEGIN_LOOP 13
""];
13->16;
14[label=""Node Type: END_LOOP 14
""];
14->19;
15[label=""Node Type: NEW VARIABLE 15

EXPRESSION:
i = 1

IRs:
i(uint256) := 1(uint256)""];
15->13;
16[label=""Node Type: IF_LOOP 16

EXPRESSION:
i <= gID_

IRs:
TMP_90(bool) = i <= gID_
CONDITION TMP_90""];
16->17[label=""True""];
16->14[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
games_[i].receivePlayerInfo(_pID,_addr,_name,_affID)

IRs:
REF_123(PlayerBookReceiverInterface) -> games_[i]
HIGH_LEVEL_CALL, dest:REF_123(PlayerBookReceiverInterface), function:receivePlayerInfo, arguments:['_pID', '_addr', '_name', '_affID']  ""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
i ++

IRs:
TMP_92(uint256) := i(uint256)
i(uint256) = i + 1""];
18->16;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,msg.value,now)

IRs:
REF_125(PlayerBook.Player) -> plyr_[_affID]
REF_126(address) -> REF_125.addr
REF_127(PlayerBook.Player) -> plyr_[_affID]
REF_128(bytes32) -> REF_127.name
Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_126,REF_128,msg.value,now)""];
}
",0,0,1,0,"pIDxName_[_name] != 0;require(bool,string)(plyrNames_[_pID][_name] == true,sorry that names already taken);;plyr_[_pID].name = _name;pIDxName_[_name] = _pID;plyrNames_[_pID][_name] == false;plyrNames_[_pID][_name] = true;;plyr_[_pID].names ++;plyrNameList_[_pID][plyr_[_pID].names] = _name;TeamDreamHub_.deposit.value(address(this).balance)();_all == true;i = 1;;;i <= gID_;;games_[i].receivePlayerInfo(_pID,_addr,_name,_affID);i ++;onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,msg.value,now)"
./0x56b7f2a2d6f70d88b991e6c7b8005e0a13a9b379_ext.sol,CryptoCurrencyExchange.safeWithdrawal,304,309,"TMP_97(bool) = _value == 0,CONDITION TMP_97,TMP_98 = CONVERT this to address,TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98),Transfer dest:owner value:TMP_99,Transfer dest:owner value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_97(bool) = _value == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_98 = CONVERT this to address
TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98)
Transfer dest:owner value:TMP_99""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_value == 0;owner.transfer(address(this).balance);owner.transfer(_value);
./0x6bfe93d41c21dc9b72ac5785c12aa400bf205b31_ext.sol,Zedd.withdraw,277,280,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, Zedd.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Zedd.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x5c3536c7cd64c3bcb6ea01c00c2919bcd5053aba_ext.sol,BlastBox.withdraw,300,303,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, BlastBox.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, BlastBox.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0xee58ee0b1519bb47801812a3a9c83ab600c63d81_ext.sol,PrivatePaymentProcessor.withdrawRefund,778,795,"REF_53(PrivatePaymentProcessor.Withdraw) -> withdrawals[_orderId],withdraw(PrivatePaymentProcessor.Withdraw) := REF_53(PrivatePaymentProcessor.Withdraw),REF_54(PrivatePaymentProcessor.WithdrawState) -> WithdrawState.Pending,REF_55(PrivatePaymentProcessor.WithdrawState) -> withdraw.state,TMP_300(bool) = REF_54 == REF_55,TMP_301(None) = SOLIDITY_CALL require(bool)(TMP_300),REF_56(address) -> withdraw.clientAddress,clientAddress(address) := REF_56(address),REF_57(uint256) -> withdraw.amount,amount(uint256) := REF_57(uint256),REF_58(PrivatePaymentProcessor.WithdrawState) -> withdraw.state,REF_59(PrivatePaymentProcessor.WithdrawState) -> WithdrawState.Withdrawn,REF_58(PrivatePaymentProcessor.WithdrawState) (->withdraw) := REF_59(PrivatePaymentProcessor.WithdrawState),Transfer dest:clientAddress value:amount,Emit PaymentWithdrawn(_orderId,clientAddress,amount),MODIFIER_CALL, Pausable.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
withdraw = withdrawals[_orderId]

IRs:
REF_53(PrivatePaymentProcessor.Withdraw) -> withdrawals[_orderId]
withdraw(PrivatePaymentProcessor.Withdraw) := REF_53(PrivatePaymentProcessor.Withdraw)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(WithdrawState.Pending == withdraw.state)

IRs:
REF_54(PrivatePaymentProcessor.WithdrawState) -> WithdrawState.Pending
REF_55(PrivatePaymentProcessor.WithdrawState) -> withdraw.state
TMP_300(bool) = REF_54 == REF_55
TMP_301(None) = SOLIDITY_CALL require(bool)(TMP_300)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
clientAddress = withdraw.clientAddress

IRs:
REF_56(address) -> withdraw.clientAddress
clientAddress(address) := REF_56(address)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
amount = withdraw.amount

IRs:
REF_57(uint256) -> withdraw.amount
amount(uint256) := REF_57(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
withdraw.state = WithdrawState.Withdrawn

IRs:
REF_58(PrivatePaymentProcessor.WithdrawState) -> withdraw.state
REF_59(PrivatePaymentProcessor.WithdrawState) -> WithdrawState.Withdrawn
REF_58(PrivatePaymentProcessor.WithdrawState) (->withdraw) := REF_59(PrivatePaymentProcessor.WithdrawState)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
clientAddress.transfer(amount)

IRs:
Transfer dest:clientAddress value:amount""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
PaymentWithdrawn(_orderId,clientAddress,amount)

IRs:
Emit PaymentWithdrawn(_orderId,clientAddress,amount)""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
8->1;
}
",0,0,1,0,"whenNotPaused();withdraw = withdrawals[_orderId];require(bool)(WithdrawState.Pending == withdraw.state);clientAddress = withdraw.clientAddress;amount = withdraw.amount;withdraw.state = WithdrawState.Withdrawn;clientAddress.transfer(amount);PaymentWithdrawn(_orderId,clientAddress,amount)"
./0x2628e13a3cbdc52ed96b4b8d6b1041d3ef3a409e_ext.sol,Participant.processPayment,130,144,"TMP_50(bool) = msg.value == daily,TMP_51(None) = SOLIDITY_CALL require(bool,string)(TMP_50,Invalid value),TMP_52 = CONVERT smartolution to SmartolutionInterface,TMP_53 = CONVERT this to address,TUPLE_0(uint256,uint256,uint256) = HIGH_LEVEL_CALL, dest:TMP_52(SmartolutionInterface), function:users, arguments:['TMP_53']  ,indexBefore(uint256)= UNPACK TUPLE_0 index: 1 ,TMP_55(bool) = LOW_LEVEL_CALL, dest:smartolution, function:call, arguments:[] value:msg.value ,TMP_56 = CONVERT smartolution to SmartolutionInterface,TMP_57 = CONVERT this to address,TUPLE_1(uint256,uint256,uint256) = HIGH_LEVEL_CALL, dest:TMP_56(SmartolutionInterface), function:users, arguments:['TMP_57']  ,index(uint256)= UNPACK TUPLE_1 index: 1 ,TMP_58(bool) = index != indexBefore,TMP_59(None) = SOLIDITY_CALL require(bool,string)(TMP_58,Smartolution rejected that payment, too soon or not enough ether),TMP_60 = CONVERT this to address,TMP_61(uint256) = SOLIDITY_CALL balance(address)(TMP_60),TMP_62 = SEND dest:owner value:TMP_61,TMP_63(bool) = index == 45,RETURN TMP_63","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(msg.value == daily,Invalid value)

IRs:
TMP_50(bool) = msg.value == daily
TMP_51(None) = SOLIDITY_CALL require(bool,string)(TMP_50,Invalid value)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2
""];
2->3;
3[label=""Node Type: NEW VARIABLE 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
(None,indexBefore,None) = SmartolutionInterface(smartolution).users(address(this))

IRs:
TMP_52 = CONVERT smartolution to SmartolutionInterface
TMP_53 = CONVERT this to address
TUPLE_0(uint256,uint256,uint256) = HIGH_LEVEL_CALL, dest:TMP_52(SmartolutionInterface), function:users, arguments:['TMP_53']  
indexBefore(uint256)= UNPACK TUPLE_0 index: 1 ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
smartolution.call.value(msg.value)()

IRs:
TMP_55(bool) = LOW_LEVEL_CALL, dest:smartolution, function:call, arguments:[] value:msg.value ""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
(None,index,None) = SmartolutionInterface(smartolution).users(address(this))

IRs:
TMP_56 = CONVERT smartolution to SmartolutionInterface
TMP_57 = CONVERT this to address
TUPLE_1(uint256,uint256,uint256) = HIGH_LEVEL_CALL, dest:TMP_56(SmartolutionInterface), function:users, arguments:['TMP_57']  
index(uint256)= UNPACK TUPLE_1 index: 1 ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool,string)(index != indexBefore,Smartolution rejected that payment, too soon or not enough ether)

IRs:
TMP_58(bool) = index != indexBefore
TMP_59(None) = SOLIDITY_CALL require(bool,string)(TMP_58,Smartolution rejected that payment, too soon or not enough ether)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
owner.send(address(this).balance)

IRs:
TMP_60 = CONVERT this to address
TMP_61(uint256) = SOLIDITY_CALL balance(address)(TMP_60)
TMP_62 = SEND dest:owner value:TMP_61""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
index == 45

IRs:
TMP_63(bool) = index == 45
RETURN TMP_63""];
}
",0,0,1,0,"require(bool,string)(msg.value == daily,Invalid value);;;(None,indexBefore,None) = SmartolutionInterface(smartolution).users(address(this));smartolution.call.value(msg.value)();(None,index,None) = SmartolutionInterface(smartolution).users(address(this));require(bool,string)(index != indexBefore,Smartolution rejected that payment, too soon or not enough ether);owner.send(address(this).balance);index == 45"
./0xeaac4254f43b1802a32c2b2eeb0241ddc39eb561_ext.sol,Hanabira.getTokens,174,233,"tokens(uint256) := 0(uint256),bonus(uint256) := 0(uint256),countbonus(uint256) := 0(uint256),TMP_45(uint256) = 1000000000000000000 / 2,bonusCond1(uint256) := TMP_45(uint256),bonusCond2(uint256) := 1000000000000000000(uint256),bonusCond3(uint256) := 3000000000000000000(uint256),TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_47(uint256) = TMP_46 / 1000000000000000000,tokens(uint256) := TMP_47(uint256),investor(address) := msg.sender(address),TMP_48(bool) = msg.value >= requestMinimum,TMP_49(bool) = now < deadline,TMP_50(bool) = TMP_48 && TMP_49,TMP_51(bool) = now < round1,TMP_52(bool) = TMP_50 && TMP_51,TMP_53(bool) = now < round2,TMP_54(bool) = TMP_52 && TMP_53,CONDITION TMP_54,TMP_55(bool) = msg.value >= bonusCond1,TMP_56(bool) = msg.value < bonusCond2,TMP_57(bool) = TMP_55 && TMP_56,CONDITION TMP_57,TMP_58(uint256) = tokens * 10,TMP_59(uint256) = TMP_58 / 100,countbonus(uint256) := TMP_59(uint256),TMP_60(bool) = msg.value >= bonusCond2,TMP_61(bool) = msg.value < bonusCond3,TMP_62(bool) = TMP_60 && TMP_61,CONDITION TMP_62,TMP_63(uint256) = tokens * 50,TMP_64(uint256) = TMP_63 / 100,countbonus(uint256) := TMP_64(uint256),TMP_65(bool) = msg.value >= bonusCond3,CONDITION TMP_65,TMP_66(uint256) = tokens * 75,TMP_67(uint256) = TMP_66 / 100,countbonus(uint256) := TMP_67(uint256),TMP_68(bool) = msg.value >= requestMinimum,TMP_69(bool) = now < deadline,TMP_70(bool) = TMP_68 && TMP_69,TMP_71(bool) = now > round1,TMP_72(bool) = TMP_70 && TMP_71,TMP_73(bool) = now < round2,TMP_74(bool) = TMP_72 && TMP_73,CONDITION TMP_74,TMP_75(bool) = msg.value >= bonusCond2,TMP_76(bool) = msg.value < bonusCond3,TMP_77(bool) = TMP_75 && TMP_76,CONDITION TMP_77,TMP_78(uint256) = tokens * 25,TMP_79(uint256) = TMP_78 / 100,countbonus(uint256) := TMP_79(uint256),TMP_80(bool) = msg.value >= bonusCond3,CONDITION TMP_80,TMP_81(uint256) = tokens * 50,TMP_82(uint256) = TMP_81 / 100,countbonus(uint256) := TMP_82(uint256),countbonus(uint256) := 0(uint256),TMP_83(uint256) = tokens + countbonus,bonus(uint256) := TMP_83(uint256),TMP_84(bool) = tokens == 0,CONDITION TMP_84,valdrop(uint256) := 66688800000000(uint256),REF_12(bool) -> Claimed[investor],TMP_85(bool) = REF_12 == False,TMP_86(bool) = progress0drop <= target0drop,TMP_87(bool) = TMP_85 && TMP_86,CONDITION TMP_87,TMP_88(bool) = INTERNAL_CALL, Hanabira.distr(address,uint256)(investor,valdrop),REF_13(bool) -> Claimed[investor],REF_13(bool) (->Claimed) := True(bool),TMP_89(uint256) := progress0drop(uint256),progress0drop(uint256) = progress0drop + 1,TMP_90(bool) = msg.value >= requestMinimum,TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),TMP_92(bool) = tokens > 0,TMP_93(bool) = msg.value >= requestMinimum,TMP_94(bool) = TMP_92 && TMP_93,CONDITION TMP_94,TMP_95(bool) = now >= deadline,TMP_96(bool) = now >= round1,TMP_97(bool) = TMP_95 && TMP_96,TMP_98(bool) = now < round2,TMP_99(bool) = TMP_97 && TMP_98,CONDITION TMP_99,TMP_100(bool) = INTERNAL_CALL, Hanabira.distr(address,uint256)(investor,tokens),TMP_101(bool) = msg.value >= bonusCond1,CONDITION TMP_101,TMP_102(bool) = INTERNAL_CALL, Hanabira.distr(address,uint256)(investor,bonus),TMP_103(bool) = INTERNAL_CALL, Hanabira.distr(address,uint256)(investor,tokens),TMP_104(bool) = msg.value >= requestMinimum,TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104),TMP_106(bool) = totalDistributed >= totalSupply,CONDITION TMP_106,distributionFinished(bool) := True(bool),Transfer dest:multisig value:msg.value,MODIFIER_CALL, Hanabira.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->53;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bonusCond1 = 1000000000000000000 / 2

IRs:
TMP_45(uint256) = 1000000000000000000 / 2
bonusCond1(uint256) := TMP_45(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bonusCond2 = 1000000000000000000

IRs:
bonusCond2(uint256) := 1000000000000000000(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
bonusCond3 = 3000000000000000000

IRs:
bonusCond3(uint256) := 3000000000000000000(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_47(uint256) = TMP_46 / 1000000000000000000
tokens(uint256) := TMP_47(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now < round1 && now < round2

IRs:
TMP_48(bool) = msg.value >= requestMinimum
TMP_49(bool) = now < deadline
TMP_50(bool) = TMP_48 && TMP_49
TMP_51(bool) = now < round1
TMP_52(bool) = TMP_50 && TMP_51
TMP_53(bool) = now < round2
TMP_54(bool) = TMP_52 && TMP_53
CONDITION TMP_54""];
9->10[label=""True""];
9->19[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
msg.value >= bonusCond1 && msg.value < bonusCond2

IRs:
TMP_55(bool) = msg.value >= bonusCond1
TMP_56(bool) = msg.value < bonusCond2
TMP_57(bool) = TMP_55 && TMP_56
CONDITION TMP_57""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
countbonus = tokens * 10 / 100

IRs:
TMP_58(uint256) = tokens * 10
TMP_59(uint256) = TMP_58 / 100
countbonus(uint256) := TMP_59(uint256)""];
11->18;
12[label=""Node Type: IF 12

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_60(bool) = msg.value >= bonusCond2
TMP_61(bool) = msg.value < bonusCond3
TMP_62(bool) = TMP_60 && TMP_61
CONDITION TMP_62""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
countbonus = tokens * 50 / 100

IRs:
TMP_63(uint256) = tokens * 50
TMP_64(uint256) = TMP_63 / 100
countbonus(uint256) := TMP_64(uint256)""];
13->17;
14[label=""Node Type: IF 14

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_65(bool) = msg.value >= bonusCond3
CONDITION TMP_65""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
countbonus = tokens * 75 / 100

IRs:
TMP_66(uint256) = tokens * 75
TMP_67(uint256) = TMP_66 / 100
countbonus(uint256) := TMP_67(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->28;
19[label=""Node Type: IF 19

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now > round1 && now < round2

IRs:
TMP_68(bool) = msg.value >= requestMinimum
TMP_69(bool) = now < deadline
TMP_70(bool) = TMP_68 && TMP_69
TMP_71(bool) = now > round1
TMP_72(bool) = TMP_70 && TMP_71
TMP_73(bool) = now < round2
TMP_74(bool) = TMP_72 && TMP_73
CONDITION TMP_74""];
19->20[label=""True""];
19->26[label=""False""];
20[label=""Node Type: IF 20

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_75(bool) = msg.value >= bonusCond2
TMP_76(bool) = msg.value < bonusCond3
TMP_77(bool) = TMP_75 && TMP_76
CONDITION TMP_77""];
20->21[label=""True""];
20->22[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
countbonus = tokens * 25 / 100

IRs:
TMP_78(uint256) = tokens * 25
TMP_79(uint256) = TMP_78 / 100
countbonus(uint256) := TMP_79(uint256)""];
21->25;
22[label=""Node Type: IF 22

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_80(bool) = msg.value >= bonusCond3
CONDITION TMP_80""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
countbonus = tokens * 50 / 100

IRs:
TMP_81(uint256) = tokens * 50
TMP_82(uint256) = TMP_81 / 100
countbonus(uint256) := TMP_82(uint256)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->27;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
bonus = tokens + countbonus

IRs:
TMP_83(uint256) = tokens + countbonus
bonus(uint256) := TMP_83(uint256)""];
29->30;
30[label=""Node Type: IF 30

EXPRESSION:
tokens == 0

IRs:
TMP_84(bool) = tokens == 0
CONDITION TMP_84""];
30->31[label=""True""];
30->38[label=""False""];
31[label=""Node Type: NEW VARIABLE 31

EXPRESSION:
valdrop = 666888e8

IRs:
valdrop(uint256) := 66688800000000(uint256)""];
31->32;
32[label=""Node Type: IF 32

EXPRESSION:
Claimed[investor] == false && progress0drop <= target0drop

IRs:
REF_12(bool) -> Claimed[investor]
TMP_85(bool) = REF_12 == False
TMP_86(bool) = progress0drop <= target0drop
TMP_87(bool) = TMP_85 && TMP_86
CONDITION TMP_87""];
32->33[label=""True""];
32->36[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
distr(investor,valdrop)

IRs:
TMP_88(bool) = INTERNAL_CALL, Hanabira.distr(address,uint256)(investor,valdrop)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
Claimed[investor] = true

IRs:
REF_13(bool) -> Claimed[investor]
REF_13(bool) (->Claimed) := True(bool)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
progress0drop ++

IRs:
TMP_89(uint256) := progress0drop(uint256)
progress0drop(uint256) = progress0drop + 1""];
35->37;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_90(bool) = msg.value >= requestMinimum
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
36->37;
37[label=""Node Type: END_IF 37
""];
37->48;
38[label=""Node Type: IF 38

EXPRESSION:
tokens > 0 && msg.value >= requestMinimum

IRs:
TMP_92(bool) = tokens > 0
TMP_93(bool) = msg.value >= requestMinimum
TMP_94(bool) = TMP_92 && TMP_93
CONDITION TMP_94""];
38->39[label=""True""];
38->46[label=""False""];
39[label=""Node Type: IF 39

EXPRESSION:
now >= deadline && now >= round1 && now < round2

IRs:
TMP_95(bool) = now >= deadline
TMP_96(bool) = now >= round1
TMP_97(bool) = TMP_95 && TMP_96
TMP_98(bool) = now < round2
TMP_99(bool) = TMP_97 && TMP_98
CONDITION TMP_99""];
39->40[label=""True""];
39->41[label=""False""];
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_100(bool) = INTERNAL_CALL, Hanabira.distr(address,uint256)(investor,tokens)""];
40->45;
41[label=""Node Type: IF 41

EXPRESSION:
msg.value >= bonusCond1

IRs:
TMP_101(bool) = msg.value >= bonusCond1
CONDITION TMP_101""];
41->42[label=""True""];
41->43[label=""False""];
42[label=""Node Type: EXPRESSION 42

EXPRESSION:
distr(investor,bonus)

IRs:
TMP_102(bool) = INTERNAL_CALL, Hanabira.distr(address,uint256)(investor,bonus)""];
42->44;
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_103(bool) = INTERNAL_CALL, Hanabira.distr(address,uint256)(investor,tokens)""];
43->44;
44[label=""Node Type: END_IF 44
""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->47;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_104(bool) = msg.value >= requestMinimum
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: IF 49

EXPRESSION:
totalDistributed >= totalSupply

IRs:
TMP_106(bool) = totalDistributed >= totalSupply
CONDITION TMP_106""];
49->50[label=""True""];
49->51[label=""False""];
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
multisig.transfer(msg.value)

IRs:
Transfer dest:multisig value:msg.value""];
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, Hanabira.canDistr()()""];
53->1;
}
",0,0,1,0,"canDistr();tokens = 0;bonus = 0;countbonus = 0;bonusCond1 = 1000000000000000000 / 2;bonusCond2 = 1000000000000000000;bonusCond3 = 3000000000000000000;tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;investor = msg.sender;msg.value >= requestMinimum && now < deadline && now < round1 && now < round2;msg.value >= bonusCond1 && msg.value < bonusCond2;msg.value >= requestMinimum && now < deadline && now > round1 && now < round2;countbonus = tokens * 10 / 100;msg.value >= bonusCond2 && msg.value < bonusCond3;;countbonus = tokens * 50 / 100;msg.value >= bonusCond3;;countbonus = tokens * 75 / 100;;;msg.value >= bonusCond2 && msg.value < bonusCond3;countbonus = 0;countbonus = tokens * 25 / 100;msg.value >= bonusCond3;;countbonus = tokens * 50 / 100;;;bonus = tokens + countbonus;tokens == 0;valdrop = 666888e8;tokens > 0 && msg.value >= requestMinimum;Claimed[investor] == false && progress0drop <= target0drop;distr(investor,valdrop);require(bool)(msg.value >= requestMinimum);Claimed[investor] = true;progress0drop ++;;;now >= deadline && now >= round1 && now < round2;require(bool)(msg.value >= requestMinimum);distr(investor,tokens);msg.value >= bonusCond1;;distr(investor,bonus);distr(investor,tokens);;;totalDistributed >= totalSupply;distributionFinished = true;;multisig.transfer(msg.value)"
./0x287fc5e0c7055660b2d05b4718a049141bb7e1ee_ext.sol,Bqt_Token.withdraw,156,162,"REF_1(uint256) = SOLIDITY_CALL balance(address)(this),balance(uint256) := REF_1([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E2C6D040>]),TMP_16(bool) = _amount > 0,CONDITION TMP_16,balance(uint256) := _amount(uint256),TMP_17 = SEND dest:owner value:balance,RETURN True,MODIFIER_CALL, Bqt_Token.onlyOwner()(),RETURN result","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
balance = this.balance

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
balance(uint256) := REF_1([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E2C6D040>])""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_amount > 0

IRs:
TMP_16(bool) = _amount > 0
CONDITION TMP_16""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balance = _amount

IRs:
balance(uint256) := _amount(uint256)""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
owner.send(balance)

IRs:
TMP_17 = SEND dest:owner value:balance""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Bqt_Token.onlyOwner()()""];
8->1;
9[label=""Node Type: RETURN 9

EXPRESSION:
result

IRs:
RETURN result""];
}
",0,0,1,0,onlyOwner();;balance = this.balance;_amount > 0;balance = _amount;;owner.send(balance);true;result
./0x0cfa149c0a843e1f8d9bc5c6e6bebf901845cebe_ext.sol,ENVELOPE.GetGift,36,45,"TMP_7(bytes32) = SOLIDITY_CALL keccak256()(pass),TMP_8(bool) = hashPass == TMP_7,CONDITION TMP_8,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1,MODIFIER_CALL, ENVELOPE.canOpen()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: IF 1

EXPRESSION:
hashPass == keccak256()(pass)

IRs:
TMP_7(bytes32) = SOLIDITY_CALL keccak256()(pass)
TMP_8(bool) = hashPass == TMP_7
CONDITION TMP_8""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
2->3;
3[label=""Node Type: END_IF 3
""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
canOpen()

IRs:
MODIFIER_CALL, ENVELOPE.canOpen()()""];
4->1;
}
",0,0,1,0,canOpen();hashPass == keccak256()(pass);msg.sender.transfer(this.balance);
./0xf1171e1e8df34ab97832342c7cbf04d9121a1ac3_ext.sol,CSportsAuth.withdrawBalance,167,169,"TMP_31 = CONVERT this to address,TMP_32(uint256) = SOLIDITY_CALL balance(address)(TMP_31),Transfer dest:cfoAddress value:TMP_32,MODIFIER_CALL, CSportsAuth.onlyCFO()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
cfoAddress.transfer(address(this).balance)

IRs:
TMP_31 = CONVERT this to address
TMP_32(uint256) = SOLIDITY_CALL balance(address)(TMP_31)
Transfer dest:cfoAddress value:TMP_32""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyCFO()

IRs:
MODIFIER_CALL, CSportsAuth.onlyCFO()()""];
2->1;
}
",0,0,1,0,onlyCFO();cfoAddress.transfer(address(this).balance)
./0xdcb5410ef70f59a5a2839fc6d4d0b2ca981f5e2d_ext.sol,CoinMmc.withDraw,434,442,"TMP_131(bool) = msg.sender == admin_address,TMP_132(bool) = msg.sender == direct_drop_withdraw_address,TMP_133(bool) = TMP_131 || TMP_132,TMP_134(None) = SOLIDITY_CALL require(bool)(TMP_133),TMP_135 = CONVERT this to address,TMP_136(uint256) = SOLIDITY_CALL balance(address)(TMP_135),TMP_137(bool) = TMP_136 > 0,TMP_138(None) = SOLIDITY_CALL require(bool)(TMP_137),TMP_139 = CONVERT this to address,TMP_140(uint256) = SOLIDITY_CALL balance(address)(TMP_139),Transfer dest:direct_drop_withdraw_address value:TMP_140","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == admin_address || msg.sender == direct_drop_withdraw_address)

IRs:
TMP_131(bool) = msg.sender == admin_address
TMP_132(bool) = msg.sender == direct_drop_withdraw_address
TMP_133(bool) = TMP_131 || TMP_132
TMP_134(None) = SOLIDITY_CALL require(bool)(TMP_133)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(address(this).balance > 0)

IRs:
TMP_135 = CONVERT this to address
TMP_136(uint256) = SOLIDITY_CALL balance(address)(TMP_135)
TMP_137(bool) = TMP_136 > 0
TMP_138(None) = SOLIDITY_CALL require(bool)(TMP_137)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
direct_drop_withdraw_address.transfer(address(this).balance)

IRs:
TMP_139 = CONVERT this to address
TMP_140(uint256) = SOLIDITY_CALL balance(address)(TMP_139)
Transfer dest:direct_drop_withdraw_address value:TMP_140""];
}
",0,0,1,0,require(bool)(msg.sender == admin_address || msg.sender == direct_drop_withdraw_address);require(bool)(address(this).balance > 0);direct_drop_withdraw_address.transfer(address(this).balance)
./0x2cf02304f36effd519be79850d21335684c6073e_ext.sol,AccEthRegCenter.TransferToAllAccounts,77,92,"i(uint256) := 0(uint256),REF_23 -> LENGTH recieverList,TMP_27(bool) = i < REF_23,CONDITION TMP_27,REF_24(string) -> recieverList[i],REF_25(AccEthRegCenter.User) -> recievermap[REF_24],REF_26(bool) -> REF_25.lastTransfer,REF_26(bool) (->recievermap) := False(bool),REF_27(string) -> recieverList[i],REF_28(AccEthRegCenter.User) -> recievermap[REF_27],REF_29(address) -> REF_28.useraddress,to(address) := REF_29(address),REF_30(string) -> recieverList[i],REF_31(AccEthRegCenter.User) -> recievermap[REF_30],REF_32(uint256) -> REF_31.useramount,val(uint256) := REF_32(uint256),TMP_28 = CONVERT this to address,TMP_29(uint256) = SOLIDITY_CALL balance(address)(TMP_28),TMP_30(bool) = TMP_29 >= val,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),TMP_32(bool) = val > 0,CONDITION TMP_32,Transfer dest:to value:val,Emit TransferTo(to,val),REF_34(string) -> recieverList[i],REF_35(AccEthRegCenter.User) -> recievermap[REF_34],REF_36(bool) -> REF_35.lastTransfer,REF_36(bool) (->recievermap) := True(bool),TMP_35(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->15;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < recieverList.length

IRs:
REF_23 -> LENGTH recieverList
TMP_27(bool) = i < REF_23
CONDITION TMP_27""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
recievermap[recieverList[i]].lastTransfer = false

IRs:
REF_24(string) -> recieverList[i]
REF_25(AccEthRegCenter.User) -> recievermap[REF_24]
REF_26(bool) -> REF_25.lastTransfer
REF_26(bool) (->recievermap) := False(bool)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
to = recievermap[recieverList[i]].useraddress

IRs:
REF_27(string) -> recieverList[i]
REF_28(AccEthRegCenter.User) -> recievermap[REF_27]
REF_29(address) -> REF_28.useraddress
to(address) := REF_29(address)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
val = recievermap[recieverList[i]].useramount

IRs:
REF_30(string) -> recieverList[i]
REF_31(AccEthRegCenter.User) -> recievermap[REF_30]
REF_32(uint256) -> REF_31.useramount
val(uint256) := REF_32(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(address(this).balance >= val)

IRs:
TMP_28 = CONVERT this to address
TMP_29(uint256) = SOLIDITY_CALL balance(address)(TMP_28)
TMP_30(bool) = TMP_29 >= val
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
val > 0

IRs:
TMP_32(bool) = val > 0
CONDITION TMP_32""];
9->10[label=""True""];
9->13[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
to.transfer(val)

IRs:
Transfer dest:to value:val""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
TransferTo(to,val)

IRs:
Emit TransferTo(to,val)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
recievermap[recieverList[i]].lastTransfer = true

IRs:
REF_34(string) -> recieverList[i]
REF_35(AccEthRegCenter.User) -> recievermap[REF_34]
REF_36(bool) -> REF_35.lastTransfer
REF_36(bool) (->recievermap) := True(bool)""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
i ++

IRs:
TMP_35(uint256) := i(uint256)
i(uint256) = i + 1""];
14->4;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
15->3;
}
",0,0,1,0,"onlyOwner();;i < recieverList.length;;i = 0;recievermap[recieverList[i]].lastTransfer = false;to = recievermap[recieverList[i]].useraddress;val = recievermap[recieverList[i]].useramount;require(bool)(address(this).balance >= val);val > 0;to.transfer(val);;TransferTo(to,val);recievermap[recieverList[i]].lastTransfer = true;i ++"
./0x7909209a3d78a66f6d71885f10b6ea7c6c58177b_ext.sol,Try_Me.StopGame,37,44,"TMP_9(bool) = msg.sender == questionSender,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_9(bool) = msg.sender == questionSender
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0xec9a75a532311b6102d91d439e1db055dc9414d9_ext.sol,PD88.withdraw,262,273,"TMP_152(uint256) = INTERNAL_CALL, PD88.getMyRevenue(uint256)(_round),_revenue(uint256) := TMP_152(uint256),REF_89(uint256) -> MyreferredRevenue[msg.sender],_revenueRef(uint256) := REF_89(uint256),REF_90(mapping(address => uint256)) -> RoundMyPayMask[_round],REF_91(uint256) -> REF_90[msg.sender],REF_91(-> RoundMyPayMask) = REF_91 + _revenue,REF_92(uint256) -> MyreferredRevenue[msg.sender],REF_92(uint256) (->MyreferredRevenue) := 0(uint256),TMP_153(uint256) = _revenue + _revenueRef,Transfer dest:msg.sender value:TMP_153,Emit withdrawRefEvent(msg.sender,_revenue),Emit withdrawEvent(msg.sender,_revenue,_round),MODIFIER_CALL, PD88.isHuman()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_revenue = getMyRevenue(_round)

IRs:
TMP_152(uint256) = INTERNAL_CALL, PD88.getMyRevenue(uint256)(_round)
_revenue(uint256) := TMP_152(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
_revenueRef = MyreferredRevenue[msg.sender]

IRs:
REF_89(uint256) -> MyreferredRevenue[msg.sender]
_revenueRef(uint256) := REF_89(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
RoundMyPayMask[_round][msg.sender] += _revenue

IRs:
REF_90(mapping(address => uint256)) -> RoundMyPayMask[_round]
REF_91(uint256) -> REF_90[msg.sender]
REF_91(-> RoundMyPayMask) = REF_91 + _revenue""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
MyreferredRevenue[msg.sender] = 0

IRs:
REF_92(uint256) -> MyreferredRevenue[msg.sender]
REF_92(uint256) (->MyreferredRevenue) := 0(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(_revenue + _revenueRef)

IRs:
TMP_153(uint256) = _revenue + _revenueRef
Transfer dest:msg.sender value:TMP_153""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
withdrawRefEvent(msg.sender,_revenue)

IRs:
Emit withdrawRefEvent(msg.sender,_revenue)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
withdrawEvent(msg.sender,_revenue,_round)

IRs:
Emit withdrawEvent(msg.sender,_revenue,_round)""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
isHuman()

IRs:
MODIFIER_CALL, PD88.isHuman()()""];
8->1;
}
",0,0,1,0,"isHuman();_revenue = getMyRevenue(_round);_revenueRef = MyreferredRevenue[msg.sender];RoundMyPayMask[_round][msg.sender] += _revenue;MyreferredRevenue[msg.sender] = 0;msg.sender.transfer(_revenue + _revenueRef);withdrawRefEvent(msg.sender,_revenue);withdrawEvent(msg.sender,_revenue,_round)"
./0xb429ecbd7cda1cb82cbe0ae9044310d2f74de67c_ext.sol,SmzTradingContract.fallback,30,63,"TMP_2(bool) = msg.sender == END_ADDRESS,TMP_3(bool) = msg.value == END_AMOUNT,TMP_4(bool) = TMP_2 && TMP_3,CONDITION TMP_4,ended(bool) := True(bool),REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:RECEIVER_ADDRESS value:REF_1,TMP_6 = UnaryType.BANG ended ,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),TMP_8(bool) = msg.value == ACCEPTED_AMOUNT,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),REF_2(bool) -> addressesAllowed[msg.sender],TMP_10(bool) = REF_2 == True,TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10),REF_3(bool) -> addressesDeposited[msg.sender],TMP_12(bool) = REF_3 == False,TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12),REF_4(bool) -> addressesDeposited[msg.sender],REF_4(bool) (->addressesDeposited) := True(bool),REF_5(bool) -> addressesAllowed[msg.sender],REF_5(bool) (->addressesAllowed) := False(bool),REF_6(uint256) = SOLIDITY_CALL balance(address)(this),TMP_14(bool) = REF_6 >= RECEIVER_PAYOUT_THRESHOLD,CONDITION TMP_14,REF_8(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:RECEIVER_ADDRESS value:REF_8","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == END_ADDRESS && msg.value == END_AMOUNT

IRs:
TMP_2(bool) = msg.sender == END_ADDRESS
TMP_3(bool) = msg.value == END_AMOUNT
TMP_4(bool) = TMP_2 && TMP_3
CONDITION TMP_4""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ended = true

IRs:
ended(bool) := True(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
RECEIVER_ADDRESS.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:RECEIVER_ADDRESS value:REF_1""];
3->4;
4[label=""Node Type: RETURN 4
""];
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(! ended)

IRs:
TMP_6 = UnaryType.BANG ended 
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(msg.value == ACCEPTED_AMOUNT)

IRs:
TMP_8(bool) = msg.value == ACCEPTED_AMOUNT
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(addressesAllowed[msg.sender] == true)

IRs:
REF_2(bool) -> addressesAllowed[msg.sender]
TMP_10(bool) = REF_2 == True
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(addressesDeposited[msg.sender] == false)

IRs:
REF_3(bool) -> addressesDeposited[msg.sender]
TMP_12(bool) = REF_3 == False
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
addressesDeposited[msg.sender] = true

IRs:
REF_4(bool) -> addressesDeposited[msg.sender]
REF_4(bool) (->addressesDeposited) := True(bool)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
addressesAllowed[msg.sender] = false

IRs:
REF_5(bool) -> addressesAllowed[msg.sender]
REF_5(bool) (->addressesAllowed) := False(bool)""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
this.balance >= RECEIVER_PAYOUT_THRESHOLD

IRs:
REF_6(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_14(bool) = REF_6 >= RECEIVER_PAYOUT_THRESHOLD
CONDITION TMP_14""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
RECEIVER_ADDRESS.transfer(this.balance)

IRs:
REF_8(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:RECEIVER_ADDRESS value:REF_8""];
13->14;
14[label=""Node Type: END_IF 14
""];
}
",0,0,1,0,msg.sender == END_ADDRESS && msg.value == END_AMOUNT;ended = true;;RECEIVER_ADDRESS.transfer(this.balance);;require(bool)(! ended);require(bool)(msg.value == ACCEPTED_AMOUNT);require(bool)(addressesAllowed[msg.sender] == true);require(bool)(addressesDeposited[msg.sender] == false);addressesDeposited[msg.sender] = true;addressesAllowed[msg.sender] = false;this.balance >= RECEIVER_PAYOUT_THRESHOLD;RECEIVER_ADDRESS.transfer(this.balance);
./0x28e0d54349c00607505aadc713147140fb60ea12_ext.sol,TheQuizGame.Try,5,12,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0xbd6a3418cb51418c94cc11d2d49012a2b79e10fe_ext.sol,WeaponSales.withdrawBalance,256,260,"REF_166(uint256) = SOLIDITY_CALL balance(address)(this),TMP_280(bool) = _amount <= REF_166,TMP_281(None) = SOLIDITY_CALL require(bool)(TMP_280),Transfer dest:msg.sender value:_amount,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_amount <= this.balance)

IRs:
REF_166(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_280(bool) = _amount <= REF_166
TMP_281(None) = SOLIDITY_CALL require(bool)(TMP_280)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(_amount)

IRs:
Transfer dest:msg.sender value:_amount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();require(bool)(_amount <= this.balance);msg.sender.transfer(_amount)
./0x4c60e311d8fba04e313f7e7b3dec61b3028726d1_ext.sol,EtherWorldCup.pullRipCord,659,670,"REF_202 -> LENGTH playerList,players(uint256) := REF_202(uint256),i(uint256) := 0(uint256),TMP_105(bool) = i < players,CONDITION TMP_105,REF_203(address) -> playerList[i],_toRefund(address) := REF_203(address),TMP_106 = SEND dest:_toRefund value:191710000000000000,Emit RipcordRefund(_toRefund),TMP_108(uint256) := i(uint256),i(uint256) = i + 1,TMP_109(None) = SOLIDITY_CALL selfdestruct(address)(administrator),MODIFIER_CALL, EtherWorldCup.isAdministrator()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
players = playerList.length

IRs:
REF_202 -> LENGTH playerList
players(uint256) := REF_202(uint256)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
3->10;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < players

IRs:
TMP_105(bool) = i < players
CONDITION TMP_105""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
_toRefund = playerList[i]

IRs:
REF_203(address) -> playerList[i]
_toRefund(address) := REF_203(address)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
_toRefund.send(191710000000000000)

IRs:
TMP_106 = SEND dest:_toRefund value:191710000000000000""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
RipcordRefund(_toRefund)

IRs:
Emit RipcordRefund(_toRefund)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
i ++

IRs:
TMP_108(uint256) := i(uint256)
i(uint256) = i + 1""];
9->5;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
selfdestruct(address)(administrator)

IRs:
TMP_109(None) = SOLIDITY_CALL selfdestruct(address)(administrator)""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
isAdministrator()

IRs:
MODIFIER_CALL, EtherWorldCup.isAdministrator()()""];
11->1;
}
",0,0,1,0,isAdministrator();players = playerList.length;i = 0;;i < players;;selfdestruct(address)(administrator);_toRefund = playerList[i];_toRefund.send(191710000000000000);RipcordRefund(_toRefund);i ++
./0x333b20d643b58263e1558de655fda9cf7d07c401_ext.sol,RefundVault.refund,400,406,"REF_157(RefundVault.State) -> State.Refunding,TMP_182(bool) = state == REF_157,TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182),REF_158(uint256) -> deposited[investor],depositedValue(uint256) := REF_158(uint256),REF_159(uint256) -> deposited[investor],REF_159(uint256) (->deposited) := 0(uint256),Transfer dest:investor value:depositedValue,Emit Refunded(investor,depositedValue)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Refunding)

IRs:
REF_157(RefundVault.State) -> State.Refunding
TMP_182(bool) = state == REF_157
TMP_183(None) = SOLIDITY_CALL require(bool)(TMP_182)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
depositedValue = deposited[investor]

IRs:
REF_158(uint256) -> deposited[investor]
depositedValue(uint256) := REF_158(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
deposited[investor] = 0

IRs:
REF_159(uint256) -> deposited[investor]
REF_159(uint256) (->deposited) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
investor.transfer(depositedValue)

IRs:
Transfer dest:investor value:depositedValue""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Refunded(investor,depositedValue)

IRs:
Emit Refunded(investor,depositedValue)""];
}
",0,0,1,0,"require(bool)(state == State.Refunding);depositedValue = deposited[investor];deposited[investor] = 0;investor.transfer(depositedValue);Refunded(investor,depositedValue)"
./0x5c8951c94b059900d05b10d592b44c78574196c5_ext.sol,EtherCityToken._payout,392,398,"TMP_101 = CONVERT 0 to address,TMP_102(bool) = _to == TMP_101,CONDITION TMP_102,REF_47(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:ceoAddress value:REF_47,REF_49(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:_to value:REF_49","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_to == address(0)

IRs:
TMP_101 = CONVERT 0 to address
TMP_102(bool) = _to == TMP_101
CONDITION TMP_102""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ceoAddress.transfer(this.balance)

IRs:
REF_47(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:ceoAddress value:REF_47""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_to.transfer(this.balance)

IRs:
REF_49(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:_to value:REF_49""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,_to == address(0);ceoAddress.transfer(this.balance);_to.transfer(this.balance);
./0xf2d54d17d3dc3810a0d62042a0b381df122ed162_ext.sol,BeercoinICO.withdraw,167,175,"REF_4(uint256) -> balanceOf[msg.sender],amount(uint256) := REF_4(uint256),TMP_47(bool) = amount > 0,TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47),REF_5(uint256) -> balanceOf[msg.sender],REF_5(uint256) (->balanceOf) := 0(uint256),Transfer dest:msg.sender value:amount,Emit FundTransfer(msg.sender,amount,False),MODIFIER_CALL, BeercoinICO.goalNotReached()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
amount = balanceOf[msg.sender]

IRs:
REF_4(uint256) -> balanceOf[msg.sender]
amount(uint256) := REF_4(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_47(bool) = amount > 0
TMP_48(None) = SOLIDITY_CALL require(bool)(TMP_47)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[msg.sender] = 0

IRs:
REF_5(uint256) -> balanceOf[msg.sender]
REF_5(uint256) (->balanceOf) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
FundTransfer(msg.sender,amount,false)

IRs:
Emit FundTransfer(msg.sender,amount,False)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
goalNotReached()

IRs:
MODIFIER_CALL, BeercoinICO.goalNotReached()()""];
6->1;
}
",0,0,1,0,"goalNotReached();amount = balanceOf[msg.sender];require(bool)(amount > 0);balanceOf[msg.sender] = 0;msg.sender.transfer(amount);FundTransfer(msg.sender,amount,false)"
./0xec7ba2ff3c46b9417d34ca9941ae2f62268c5add_ext.sol,AllYours.kill,142,158,"TMP_20(bool) = _owner == msg.sender,CONDITION TMP_20,TMP_21 = CONVERT this to address,TMP_22(uint256) = SOLIDITY_CALL balance(address)(TMP_21),Transfer dest:_platformAddress value:TMP_22,TMP_24(None) = SOLIDITY_CALL selfdestruct(address)(_owner)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_owner == msg.sender

IRs:
TMP_20(bool) = _owner == msg.sender
CONDITION TMP_20""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_platformAddress.transfer(address(this).balance)

IRs:
TMP_21 = CONVERT this to address
TMP_22(uint256) = SOLIDITY_CALL balance(address)(TMP_21)
Transfer dest:_platformAddress value:TMP_22""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
selfdestruct(address)(_owner)

IRs:
TMP_24(None) = SOLIDITY_CALL selfdestruct(address)(_owner)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,_owner == msg.sender;_platformAddress.transfer(address(this).balance);;selfdestruct(address)(_owner)
./0xcf377dfd654676940e2b5a87cf2673def25aeaed_ext.sol,GreenEthereusPromo.withdrawBalance,89,91,"TMP_13 = CONVERT this to address,TMP_14(uint256) = SOLIDITY_CALL balance(address)(TMP_13),Transfer dest:owner value:TMP_14,MODIFIER_CALL, GreenEthereusPromo.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_13 = CONVERT this to address
TMP_14(uint256) = SOLIDITY_CALL balance(address)(TMP_13)
Transfer dest:owner value:TMP_14""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, GreenEthereusPromo.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();owner.transfer(address(this).balance)
./0x4176f0f2b7c95486a5ae06e3d1b29201a42e7630_ext.sol,Bounty0xEscrow.distributeTokenToAddress,266,279,"TMP_76 = CONVERT 0 to address,TMP_77(bool) = _hunter != TMP_76,TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77),REF_22(mapping(address => uint256)) -> tokens[_token],REF_23(uint256) -> REF_22[_host],TMP_79(bool) = REF_23 >= _amount,TMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79),REF_24(mapping(address => uint256)) -> tokens[_token],REF_25(uint256) -> REF_24[_host],REF_27(mapping(address => uint256)) -> tokens[_token],REF_28(uint256) -> REF_27[_host],TMP_81(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_amount'] ,REF_25(uint256) (->tokens) := TMP_81(uint256),TMP_82 = CONVERT 0 to address,TMP_83(bool) = _token == TMP_82,CONDITION TMP_83,TMP_84 = SEND dest:_hunter value:_amount,TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84),TMP_86 = CONVERT _token to ERC20,TMP_87(bool) = HIGH_LEVEL_CALL, dest:TMP_86(ERC20), function:transfer, arguments:['_hunter', '_amount']  ,TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87),Emit Distribution(_token,_host,_hunter,_amount),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_hunter != address(0))

IRs:
TMP_76 = CONVERT 0 to address
TMP_77(bool) = _hunter != TMP_76
TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(tokens[_token][_host] >= _amount)

IRs:
REF_22(mapping(address => uint256)) -> tokens[_token]
REF_23(uint256) -> REF_22[_host]
TMP_79(bool) = REF_23 >= _amount
TMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tokens[_token][_host] = SafeMath.sub(tokens[_token][_host],_amount)

IRs:
REF_24(mapping(address => uint256)) -> tokens[_token]
REF_25(uint256) -> REF_24[_host]
REF_27(mapping(address => uint256)) -> tokens[_token]
REF_28(uint256) -> REF_27[_host]
TMP_81(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_amount'] 
REF_25(uint256) (->tokens) := TMP_81(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
_token == address(0)

IRs:
TMP_82 = CONVERT 0 to address
TMP_83(bool) = _token == TMP_82
CONDITION TMP_83""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(_hunter.send(_amount))

IRs:
TMP_84 = SEND dest:_hunter value:_amount
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)""];
5->7;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(ERC20(_token).transfer(_hunter,_amount))

IRs:
TMP_86 = CONVERT _token to ERC20
TMP_87(bool) = HIGH_LEVEL_CALL, dest:TMP_86(ERC20), function:transfer, arguments:['_hunter', '_amount']  
TMP_88(None) = SOLIDITY_CALL require(bool)(TMP_87)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Distribution(_token,_host,_hunter,_amount)

IRs:
Emit Distribution(_token,_host,_hunter,_amount)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
9->1;
}
",1,0,1,0,"onlyOwner();require(bool)(_hunter != address(0));require(bool)(tokens[_token][_host] >= _amount);tokens[_token][_host] = SafeMath.sub(tokens[_token][_host],_amount);_token == address(0);require(bool)(_hunter.send(_amount));require(bool)(ERC20(_token).transfer(_hunter,_amount));;Distribution(_token,_host,_hunter,_amount)"
./0x6b62f10b1d042d3ed601899ca25f80f9dbc92644_ext.sol,TwoCoinsOneMoonGame.withdraw,100,110,"REF_10(uint256) -> balance[feeCollector],TMP_20(bool) = REF_10 != 0,CONDITION TMP_20,REF_11(uint256) -> balance[feeCollector],fee(uint256) := REF_11(uint256),REF_12(uint256) -> balance[feeCollector],REF_12(uint256) (->balance) := 0(uint256),TMP_22(bool) = LOW_LEVEL_CALL, dest:feeCollector, function:call, arguments:[] value:fee ,REF_15(uint256) -> balance[msg.sender],amount(uint256) := REF_15(uint256),REF_16(uint256) -> balance[msg.sender],REF_16(uint256) (->balance) := 0(uint256),Transfer dest:msg.sender value:amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
balance[feeCollector] != 0

IRs:
REF_10(uint256) -> balance[feeCollector]
TMP_20(bool) = REF_10 != 0
CONDITION TMP_20""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
fee = balance[feeCollector]

IRs:
REF_11(uint256) -> balance[feeCollector]
fee(uint256) := REF_11(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balance[feeCollector] = 0

IRs:
REF_12(uint256) -> balance[feeCollector]
REF_12(uint256) (->balance) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
feeCollector.call.value(fee)()

IRs:
TMP_22(bool) = LOW_LEVEL_CALL, dest:feeCollector, function:call, arguments:[] value:fee ""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
amount = balance[msg.sender]

IRs:
REF_15(uint256) -> balance[msg.sender]
amount(uint256) := REF_15(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balance[msg.sender] = 0

IRs:
REF_16(uint256) -> balance[msg.sender]
REF_16(uint256) (->balance) := 0(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
}
",0,0,1,0,balance[feeCollector] != 0;fee = balance[feeCollector];;balance[feeCollector] = 0;feeCollector.call.value(fee)();amount = balance[msg.sender];balance[msg.sender] = 0;msg.sender.transfer(amount)
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.removeUserWhitelist,2,2,"REF_47 -> LENGTH _userlist,TMP_102(bool) = REF_47 > 0,TMP_103(None) = SOLIDITY_CALL require(bool)(TMP_102),i(uint256) := 0(uint256),REF_48 -> LENGTH _userlist,TMP_104(bool) = i < REF_48,CONDITION TMP_104,REF_49(address) -> _userlist[i],baddr(address) := REF_49(address),TMP_105 = CONVERT 0 to address,TMP_106(bool) = baddr != TMP_105,REF_50(KahnDistributionCentre.User) -> bounties[baddr],REF_51(address) -> REF_50.user_address,TMP_107(bool) = REF_51 == baddr,TMP_108(bool) = TMP_106 && TMP_107,CONDITION TMP_108,REF_52(KahnDistributionCentre.User) -> bounties[baddr],REF_53(bool) -> REF_52.status,REF_53(bool) (->bounties) := False(bool),REF_54(bool) -> signups[baddr],REF_54(bool) (->signups) := False(bool),TMP_109(uint256) := userSignupCount(uint256),userSignupCount(uint256) = userSignupCount - 1,TMP_110(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, KahnDistributionCentre.onlyStaffs()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->13;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_userlist.length > 0)

IRs:
REF_47 -> LENGTH _userlist
TMP_102(bool) = REF_47 > 0
TMP_103(None) = SOLIDITY_CALL require(bool)(TMP_102)""];
1->4;
2[label=""Node Type: BEGIN_LOOP 2
""];
2->5;
3[label=""Node Type: END_LOOP 3
""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
4->2;
5[label=""Node Type: IF_LOOP 5

EXPRESSION:
i < _userlist.length

IRs:
REF_48 -> LENGTH _userlist
TMP_104(bool) = i < REF_48
CONDITION TMP_104""];
5->6[label=""True""];
5->3[label=""False""];
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
baddr = _userlist[i]

IRs:
REF_49(address) -> _userlist[i]
baddr(address) := REF_49(address)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
baddr != address(0) && bounties[baddr].user_address == baddr

IRs:
TMP_105 = CONVERT 0 to address
TMP_106(bool) = baddr != TMP_105
REF_50(KahnDistributionCentre.User) -> bounties[baddr]
REF_51(address) -> REF_50.user_address
TMP_107(bool) = REF_51 == baddr
TMP_108(bool) = TMP_106 && TMP_107
CONDITION TMP_108""];
7->8[label=""True""];
7->11[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
bounties[baddr].status = false

IRs:
REF_52(KahnDistributionCentre.User) -> bounties[baddr]
REF_53(bool) -> REF_52.status
REF_53(bool) (->bounties) := False(bool)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
signups[baddr] = false

IRs:
REF_54(bool) -> signups[baddr]
REF_54(bool) (->signups) := False(bool)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
userSignupCount --

IRs:
TMP_109(uint256) := userSignupCount(uint256)
userSignupCount(uint256) = userSignupCount - 1""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_110(uint256) := i(uint256)
i(uint256) = i + 1""];
12->5;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
onlyStaffs()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyStaffs()()""];
13->1;
}
",0,1,1,0,onlyStaffs();require(bool)(_userlist.length > 0);i = 0;;i < _userlist.length;;baddr = _userlist[i];baddr != address(0) && bounties[baddr].user_address == baddr;bounties[baddr].status = false;;signups[baddr] = false;userSignupCount --;i ++
./0x1fdedef5c2da1ed9db44d80003a9592dfa18163c_ext.sol,Syndicate.claimPlayerProfit,117,124,"REF_14(Syndicate.somePlayer) -> allPlayers[msg.sender],REF_15(uint256) -> REF_14.profitShare,TMP_19(bool) = REF_15 == 0,CONDITION TMP_19,TMP_20(None) = SOLIDITY_CALL revert()(),REF_16(Syndicate.somePlayer) -> allPlayers[msg.sender],REF_17(uint256) -> REF_16.profitShare,profitShare(uint256) := REF_17(uint256),TMP_21(bool) = profitShare > 0,CONDITION TMP_21,REF_18(Syndicate.somePlayer) -> allPlayers[msg.sender],REF_19(uint256) -> REF_18.profitShare,REF_19(uint256) (->allPlayers) := 0(uint256),Transfer dest:msg.sender value:profitShare","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
allPlayers[msg.sender].profitShare == 0

IRs:
REF_14(Syndicate.somePlayer) -> allPlayers[msg.sender]
REF_15(uint256) -> REF_14.profitShare
TMP_19(bool) = REF_15 == 0
CONDITION TMP_19""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_20(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
profitShare = allPlayers[msg.sender].profitShare

IRs:
REF_16(Syndicate.somePlayer) -> allPlayers[msg.sender]
REF_17(uint256) -> REF_16.profitShare
profitShare(uint256) := REF_17(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
profitShare > 0

IRs:
TMP_21(bool) = profitShare > 0
CONDITION TMP_21""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allPlayers[msg.sender].profitShare = 0

IRs:
REF_18(Syndicate.somePlayer) -> allPlayers[msg.sender]
REF_19(uint256) -> REF_18.profitShare
REF_19(uint256) (->allPlayers) := 0(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
msg.sender.transfer(profitShare)

IRs:
Transfer dest:msg.sender value:profitShare""];
7->8;
8[label=""Node Type: END_IF 8
""];
}
",0,0,1,0,allPlayers[msg.sender].profitShare == 0;revert()();;profitShare = allPlayers[msg.sender].profitShare;profitShare > 0;allPlayers[msg.sender].profitShare = 0;;msg.sender.transfer(profitShare)
./0xf2017c92b068935bf56fea38f9d2c01f184ef14c_ext.sol,WorldToken.safeWithdrawal,304,309,"TMP_97(bool) = _value == 0,CONDITION TMP_97,TMP_98 = CONVERT this to address,TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98),Transfer dest:owner value:TMP_99,Transfer dest:owner value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_97(bool) = _value == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_98 = CONVERT this to address
TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98)
Transfer dest:owner value:TMP_99""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_value == 0;owner.transfer(address(this).balance);owner.transfer(_value);
./0x44cf74e16bd4dfcf38cec1236f5cb7e92a4f9edf_ext.sol,BC_GAME.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 400000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 400000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 400000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 400000000000000000;msg.sender.transfer(this.balance);
./0x5a889cba88c2c7cc67652c2de4e46fc4b9aba9ce_ext.sol,DSG_Turntable.sendOwnerDeposit,222,233,"TMP_253(bool) = paused == True,TMP_254(None) = SOLIDITY_CALL require(bool,string)(TMP_253,Game was not stopped),TMP_255(uint256) = INTERNAL_CALL, DSG_Turntable.getContractBalance()(),contractBalance(uint256) := TMP_255(uint256),TMP_256(bool) = contractBalance >= ownerDeposit,CONDITION TMP_256,Transfer dest:recipient value:ownerDeposit,Transfer dest:recipient value:contractBalance,jackpotBalance = delete jackpotBalance ,ownerDeposit = delete ownerDeposit ,MODIFIER_CALL, DSG_Turntable.onlyOwners()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(paused == true,Game was not stopped)

IRs:
TMP_253(bool) = paused == True
TMP_254(None) = SOLIDITY_CALL require(bool,string)(TMP_253,Game was not stopped)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
contractBalance = getContractBalance()

IRs:
TMP_255(uint256) = INTERNAL_CALL, DSG_Turntable.getContractBalance()()
contractBalance(uint256) := TMP_255(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
contractBalance >= ownerDeposit

IRs:
TMP_256(bool) = contractBalance >= ownerDeposit
CONDITION TMP_256""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
recipient.transfer(ownerDeposit)

IRs:
Transfer dest:recipient value:ownerDeposit""];
4->6;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
recipient.transfer(contractBalance)

IRs:
Transfer dest:recipient value:contractBalance""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
delete jackpotBalance

IRs:
jackpotBalance = delete jackpotBalance ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
delete ownerDeposit

IRs:
ownerDeposit = delete ownerDeposit ""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwners()

IRs:
MODIFIER_CALL, DSG_Turntable.onlyOwners()()""];
9->1;
}
",0,0,1,0,"onlyOwners();require(bool,string)(paused == true,Game was not stopped);contractBalance = getContractBalance();contractBalance >= ownerDeposit;recipient.transfer(ownerDeposit);recipient.transfer(contractBalance);;delete jackpotBalance;delete ownerDeposit"
./0x70fa6e7cf0ecf0e97415f3abbbc8eb67e0c2c588_ext.sol,MyAdvancedToken.selfdestructs,257,259,TMP_93(None) = SOLIDITY_CALL selfdestruct(address)(owner),"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_93(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
}
",0,0,1,0,selfdestruct(address)(owner)
./0x5838f878000fe44b6f6c677bbf839e12f097c147_ext.sol,Q_GAME.Try,5,12,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 2000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 2000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 2000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 2000000000000000000;msg.sender.transfer(this.balance);
./0x1b332629b45136a3614fafcd927c8ea31d7cd717_ext.sol,Bandit.ownerRefundPlayer,2337,2344,"TMP_1742 = SEND dest:sendTo value:originalPlayerBetValue,TMP_1743 = UnaryType.BANG TMP_1742 ,CONDITION TMP_1743,Emit LogRefund(originalPlayerBetId,sendTo,originalPlayerBetValue),MODIFIER_CALL, Bandit.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
! sendTo.send(originalPlayerBetValue)

IRs:
TMP_1742 = SEND dest:sendTo value:originalPlayerBetValue
TMP_1743 = UnaryType.BANG TMP_1742 
CONDITION TMP_1743""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
LogRefund(originalPlayerBetId,sendTo,originalPlayerBetValue)

IRs:
Emit LogRefund(originalPlayerBetId,sendTo,originalPlayerBetValue)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Bandit.onlyOwner()()""];
5->1;
}
",0,0,1,0,"onlyOwner();! sendTo.send(originalPlayerBetValue);;;LogRefund(originalPlayerBetId,sendTo,originalPlayerBetValue)"
./0x3688587725ed6dda84bcd25aeeb04997415da50a_ext.sol,BFreeContract.withdraw,427,434,"REF_92(uint256) = SOLIDITY_CALL balance(address)(this),contractbalance(uint256) := REF_92([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E3F11A60>]),sender(address) := msg.sender(address),TMP_216(bool) = contractbalance >= summeInWei,TMP_217(None) = SOLIDITY_CALL require(bool)(TMP_216),TMP_218(None) = SOLIDITY_CALL require(bool)(minimalGoalReached),Emit withdrawed(sender,summeInWei,wei withdrawed),Transfer dest:sender value:summeInWei,MODIFIER_CALL, owned.isOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
contractbalance = this.balance

IRs:
REF_92(uint256) = SOLIDITY_CALL balance(address)(this)
contractbalance(uint256) := REF_92([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E3F11A60>])""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
sender = msg.sender

IRs:
sender(address) := msg.sender(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(contractbalance >= summeInWei)

IRs:
TMP_216(bool) = contractbalance >= summeInWei
TMP_217(None) = SOLIDITY_CALL require(bool)(TMP_216)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(minimalGoalReached)

IRs:
TMP_218(None) = SOLIDITY_CALL require(bool)(minimalGoalReached)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
withdrawed(sender,summeInWei,wei withdrawed)

IRs:
Emit withdrawed(sender,summeInWei,wei withdrawed)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
sender.transfer(summeInWei)

IRs:
Transfer dest:sender value:summeInWei""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
isOwner()

IRs:
MODIFIER_CALL, owned.isOwner()()""];
7->1;
}
",0,0,1,0,"isOwner();contractbalance = this.balance;sender = msg.sender;require(bool)(contractbalance >= summeInWei);require(bool)(minimalGoalReached);withdrawed(sender,summeInWei,wei withdrawed);sender.transfer(summeInWei)"
./0x18da8521c333aed9de8f512e847734cb7be42e38_ext.sol,Crowdsale.finalize,310,325,"TMP_128(bool) = now < endTime,CONDITION TMP_128,TMP_129(bool) = coinSentToEther == MAX_CAP,CONDITION TMP_129,TMP_130(bool) = coinSentToEther < MIN_CAP,TMP_131(uint256) = endTime + 259200,TMP_132(bool) = now < TMP_131,TMP_133(bool) = TMP_130 && TMP_132,CONDITION TMP_133,REF_94(uint256) = SOLIDITY_CALL balance(address)(this),TMP_134 = SEND dest:multisigEther value:REF_94,TMP_135 = UnaryType.BANG TMP_134 ,CONDITION TMP_135,TMP_136(uint256) = HIGH_LEVEL_CALL, dest:coin(ProjectX), function:balanceOf, arguments:['this']  ,remains(uint256) := TMP_136(uint256),TMP_137(bool) = remains > 0,CONDITION TMP_137,TMP_138(bool) = HIGH_LEVEL_CALL, dest:coin(ProjectX), function:burn, arguments:['remains']  ,TMP_139 = UnaryType.BANG TMP_138 ,CONDITION TMP_139,crowdsaleClosed(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->19;
1[label=""Node Type: IF 1

EXPRESSION:
now < endTime

IRs:
TMP_128(bool) = now < endTime
CONDITION TMP_128""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
coinSentToEther == MAX_CAP

IRs:
TMP_129(bool) = coinSentToEther == MAX_CAP
CONDITION TMP_129""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: THROW 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
coinSentToEther < MIN_CAP && now < endTime + 259200

IRs:
TMP_130(bool) = coinSentToEther < MIN_CAP
TMP_131(uint256) = endTime + 259200
TMP_132(bool) = now < TMP_131
TMP_133(bool) = TMP_130 && TMP_132
CONDITION TMP_133""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: THROW 7
""];
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
! multisigEther.send(this.balance)

IRs:
REF_94(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_134 = SEND dest:multisigEther value:REF_94
TMP_135 = UnaryType.BANG TMP_134 
CONDITION TMP_135""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: THROW 10
""];
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
remains = coin.balanceOf(this)

IRs:
TMP_136(uint256) = HIGH_LEVEL_CALL, dest:coin(ProjectX), function:balanceOf, arguments:['this']  
remains(uint256) := TMP_136(uint256)""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
remains > 0

IRs:
TMP_137(bool) = remains > 0
CONDITION TMP_137""];
13->14[label=""True""];
13->17[label=""False""];
14[label=""Node Type: IF 14

EXPRESSION:
! coin.burn(remains)

IRs:
TMP_138(bool) = HIGH_LEVEL_CALL, dest:coin(ProjectX), function:burn, arguments:['remains']  
TMP_139 = UnaryType.BANG TMP_138 
CONDITION TMP_139""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: THROW 15
""];
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
crowdsaleClosed = true

IRs:
crowdsaleClosed(bool) := True(bool)""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
19->1;
}
",1,0,1,0,onlyOwner();now < endTime;coinSentToEther == MAX_CAP;;;;coinSentToEther < MIN_CAP && now < endTime + 259200;;;! multisigEther.send(this.balance);;;remains = coin.balanceOf(this);remains > 0;! coin.burn(remains);;;;crowdsaleClosed = true
./0x72f1295238a6a0d95631ad9f81b829c486861057_ext.sol,Simpl_quiz.Stop,28,30,"REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3,MODIFIER_CALL, Simpl_quiz.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, Simpl_quiz.isAdmin()()""];
2->1;
}
",0,0,1,0,isAdmin();msg.sender.transfer(this.balance)
./0x25d3b1550e518ba8d7581cad811285e005902faa_ext.sol,SheetMusic.transferMilestone,385,393,"TMP_31 = CONVERT this to address,TMP_32(uint256) = SOLIDITY_CALL balance(address)(TMP_31),balance(uint256) := TMP_32(uint256),Transfer dest:donatee value:balance,Emit DonationTransfered(donatee,balance)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
balance = address(this).balance

IRs:
TMP_31 = CONVERT this to address
TMP_32(uint256) = SOLIDITY_CALL balance(address)(TMP_31)
balance(uint256) := TMP_32(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
donatee.transfer(balance)

IRs:
Transfer dest:donatee value:balance""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
DonationTransfered(donatee,balance)

IRs:
Emit DonationTransfered(donatee,balance)""];
}
",0,0,1,0,"balance = address(this).balance;donatee.transfer(balance);DonationTransfered(donatee,balance)"
./0xe1dbbce4570b815b6ce3434bb3097dc9f453c565_ext.sol,MobiusRED.withdrawReturns,353,373,"REF_49(MobiusRED.MobiusRound) -> rounds[latestRoundID],rnd(MobiusRED.MobiusRound) := REF_49(MobiusRED.MobiusRound),REF_50 -> LENGTH rounds,TMP_134(bool) = REF_50 > 1,CONDITION TMP_134,TMP_135(uint256) = latestRoundID - 1,TMP_136(bool) = INTERNAL_CALL, MobiusRED.hasReturns(address,uint256)(msg.sender,TMP_135),CONDITION TMP_136,TMP_137(uint256) = latestRoundID - 1,REF_51(MobiusRED.MobiusRound) -> rounds[TMP_137],prevRnd(MobiusRED.MobiusRound) := REF_51(MobiusRED.MobiusRound),INTERNAL_CALL, MobiusRED._updateReturns(address,MobiusRED.MobiusRound)(msg.sender,prevRnd),INTERNAL_CALL, MobiusRED._updateReturns(address,MobiusRED.MobiusRound)(msg.sender,rnd),REF_52(MobiusRED.Vault) -> vaults[msg.sender],REF_53(uint256) -> REF_52.totalReturns,amount(uint256) := REF_53(uint256),TMP_140(bool) = amount > 0,TMP_141(None) = SOLIDITY_CALL require(bool,string)(TMP_140,Nothing to withdraw!),TMP_142(uint256) = INTERNAL_CALL, DSMath.sub(uint256,uint256)(unclaimedReturns,amount),unclaimedReturns(uint256) := TMP_142(uint256),REF_54(MobiusRED.Vault) -> vaults[msg.sender],REF_55(uint256) -> REF_54.totalReturns,REF_55(uint256) (->vaults) := 0(uint256),REF_56(MobiusRED.Vault) -> vaults[msg.sender],REF_57(uint256) -> REF_56.refReturns,REF_57(uint256) (->vaults) := 0(uint256),REF_58(mapping(address => MobiusRED.Investor)) -> rnd.investors,REF_59(MobiusRED.Investor) -> REF_58[msg.sender],REF_60(uint256) -> REF_59.lastCumulativeReturnsPoints,REF_61(uint256) -> rnd.cumulativeReturnsPoints,REF_60(uint256) (->rnd) := REF_61(uint256),Transfer dest:msg.sender value:amount,Emit ReturnsWithdrawn(msg.sender,amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
rnd = rounds[latestRoundID]

IRs:
REF_49(MobiusRED.MobiusRound) -> rounds[latestRoundID]
rnd(MobiusRED.MobiusRound) := REF_49(MobiusRED.MobiusRound)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
rounds.length > 1

IRs:
REF_50 -> LENGTH rounds
TMP_134(bool) = REF_50 > 1
CONDITION TMP_134""];
2->3[label=""True""];
2->7[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
hasReturns(msg.sender,latestRoundID - 1)

IRs:
TMP_135(uint256) = latestRoundID - 1
TMP_136(bool) = INTERNAL_CALL, MobiusRED.hasReturns(address,uint256)(msg.sender,TMP_135)
CONDITION TMP_136""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
prevRnd = rounds[latestRoundID - 1]

IRs:
TMP_137(uint256) = latestRoundID - 1
REF_51(MobiusRED.MobiusRound) -> rounds[TMP_137]
prevRnd(MobiusRED.MobiusRound) := REF_51(MobiusRED.MobiusRound)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_updateReturns(msg.sender,prevRnd)

IRs:
INTERNAL_CALL, MobiusRED._updateReturns(address,MobiusRED.MobiusRound)(msg.sender,prevRnd)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
_updateReturns(msg.sender,rnd)

IRs:
INTERNAL_CALL, MobiusRED._updateReturns(address,MobiusRED.MobiusRound)(msg.sender,rnd)""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
amount = vaults[msg.sender].totalReturns

IRs:
REF_52(MobiusRED.Vault) -> vaults[msg.sender]
REF_53(uint256) -> REF_52.totalReturns
amount(uint256) := REF_53(uint256)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
require(bool,string)(amount > 0,Nothing to withdraw!)

IRs:
TMP_140(bool) = amount > 0
TMP_141(None) = SOLIDITY_CALL require(bool,string)(TMP_140,Nothing to withdraw!)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
unclaimedReturns = sub(unclaimedReturns,amount)

IRs:
TMP_142(uint256) = INTERNAL_CALL, DSMath.sub(uint256,uint256)(unclaimedReturns,amount)
unclaimedReturns(uint256) := TMP_142(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
vaults[msg.sender].totalReturns = 0

IRs:
REF_54(MobiusRED.Vault) -> vaults[msg.sender]
REF_55(uint256) -> REF_54.totalReturns
REF_55(uint256) (->vaults) := 0(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
vaults[msg.sender].refReturns = 0

IRs:
REF_56(MobiusRED.Vault) -> vaults[msg.sender]
REF_57(uint256) -> REF_56.refReturns
REF_57(uint256) (->vaults) := 0(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
rnd.investors[msg.sender].lastCumulativeReturnsPoints = rnd.cumulativeReturnsPoints

IRs:
REF_58(mapping(address => MobiusRED.Investor)) -> rnd.investors
REF_59(MobiusRED.Investor) -> REF_58[msg.sender]
REF_60(uint256) -> REF_59.lastCumulativeReturnsPoints
REF_61(uint256) -> rnd.cumulativeReturnsPoints
REF_60(uint256) (->rnd) := REF_61(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
ReturnsWithdrawn(msg.sender,amount)

IRs:
Emit ReturnsWithdrawn(msg.sender,amount)""];
}
",0,0,1,0,"rnd = rounds[latestRoundID];rounds.length > 1;hasReturns(msg.sender,latestRoundID - 1);;prevRnd = rounds[latestRoundID - 1];;_updateReturns(msg.sender,prevRnd);_updateReturns(msg.sender,rnd);amount = vaults[msg.sender].totalReturns;require(bool,string)(amount > 0,Nothing to withdraw!);unclaimedReturns = sub(unclaimedReturns,amount);vaults[msg.sender].totalReturns = 0;vaults[msg.sender].refReturns = 0;rnd.investors[msg.sender].lastCumulativeReturnsPoints = rnd.cumulativeReturnsPoints;msg.sender.transfer(amount);ReturnsWithdrawn(msg.sender,amount)"
./0x873e4037cfacfaa6837c913604c2de51f2b179d0_ext.sol,IRideSale.kill,56,58,"TMP_8(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, IRideSale.isCreator()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_8(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isCreator()

IRs:
MODIFIER_CALL, IRideSale.isCreator()()""];
2->1;
}
",0,0,1,0,isCreator();selfdestruct(address)(owner)
./0x1fdedef5c2da1ed9db44d80003a9592dfa18163c_ext.sol,Syndicate.claimPlayerWinnings,127,134,"REF_21(Syndicate.somePlayer) -> allPlayers[msg.sender],REF_22(uint256) -> REF_21.winnings,TMP_23(bool) = REF_22 == 0,CONDITION TMP_23,TMP_24(None) = SOLIDITY_CALL revert()(),REF_23(Syndicate.somePlayer) -> allPlayers[msg.sender],REF_24(uint256) -> REF_23.winnings,winnings(uint256) := REF_24(uint256),TMP_25(bool) = winnings > 0,CONDITION TMP_25,REF_25(Syndicate.somePlayer) -> allPlayers[msg.sender],REF_26(uint256) -> REF_25.winnings,REF_26(uint256) (->allPlayers) := 0(uint256),Transfer dest:msg.sender value:winnings","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
allPlayers[msg.sender].winnings == 0

IRs:
REF_21(Syndicate.somePlayer) -> allPlayers[msg.sender]
REF_22(uint256) -> REF_21.winnings
TMP_23(bool) = REF_22 == 0
CONDITION TMP_23""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_24(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
winnings = allPlayers[msg.sender].winnings

IRs:
REF_23(Syndicate.somePlayer) -> allPlayers[msg.sender]
REF_24(uint256) -> REF_23.winnings
winnings(uint256) := REF_24(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
winnings > 0

IRs:
TMP_25(bool) = winnings > 0
CONDITION TMP_25""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allPlayers[msg.sender].winnings = 0

IRs:
REF_25(Syndicate.somePlayer) -> allPlayers[msg.sender]
REF_26(uint256) -> REF_25.winnings
REF_26(uint256) (->allPlayers) := 0(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
msg.sender.transfer(winnings)

IRs:
Transfer dest:msg.sender value:winnings""];
7->8;
8[label=""Node Type: END_IF 8
""];
}
",0,0,1,0,allPlayers[msg.sender].winnings == 0;revert()();;winnings = allPlayers[msg.sender].winnings;winnings > 0;allPlayers[msg.sender].winnings = 0;;msg.sender.transfer(winnings)
./0x1c3bed5bd4b0e6a8389efd0d2876f948a907ab5b_ext.sol,MiniMeToken.fallback,492,495,"TMP_124(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller),TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124),TMP_126 = CONVERT controller to TokenController,TMP_128(bool) = HIGH_LEVEL_CALL, dest:TMP_126(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value ,TMP_129(None) = SOLIDITY_CALL require(bool)(TMP_128)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isContract(controller))

IRs:
TMP_124(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)
TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))

IRs:
TMP_126 = CONVERT controller to TokenController
TMP_128(bool) = HIGH_LEVEL_CALL, dest:TMP_126(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value 
TMP_129(None) = SOLIDITY_CALL require(bool)(TMP_128)""];
}
",0,0,1,0,require(bool)(isContract(controller));require(bool)(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))
./0x26b5962250b779ab0f33970738a46fcfb00a70b9_ext.sol,NewLottery.shutdown,79,82,"TMP_17(None) = SOLIDITY_CALL suicide(address)(msg.sender),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
suicide(address)(msg.sender)

IRs:
TMP_17(None) = SOLIDITY_CALL suicide(address)(msg.sender)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();suicide(address)(msg.sender)
./0x3688587725ed6dda84bcd25aeeb04997415da50a_ext.sol,BFreeContract.withdraw,427,434,"REF_92(uint256) = SOLIDITY_CALL balance(address)(this),contractbalance(uint256) := REF_92([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B73326D0>]),sender(address) := msg.sender(address),TMP_216(bool) = contractbalance >= summeInWei,TMP_217(None) = SOLIDITY_CALL require(bool)(TMP_216),TMP_218(None) = SOLIDITY_CALL require(bool)(minimalGoalReached),Emit withdrawed(sender,summeInWei,wei withdrawed),Transfer dest:sender value:summeInWei,MODIFIER_CALL, owned.isOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
contractbalance = this.balance

IRs:
REF_92(uint256) = SOLIDITY_CALL balance(address)(this)
contractbalance(uint256) := REF_92([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B73326D0>])""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
sender = msg.sender

IRs:
sender(address) := msg.sender(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(contractbalance >= summeInWei)

IRs:
TMP_216(bool) = contractbalance >= summeInWei
TMP_217(None) = SOLIDITY_CALL require(bool)(TMP_216)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(minimalGoalReached)

IRs:
TMP_218(None) = SOLIDITY_CALL require(bool)(minimalGoalReached)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
withdrawed(sender,summeInWei,wei withdrawed)

IRs:
Emit withdrawed(sender,summeInWei,wei withdrawed)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
sender.transfer(summeInWei)

IRs:
Transfer dest:sender value:summeInWei""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
isOwner()

IRs:
MODIFIER_CALL, owned.isOwner()()""];
7->1;
}
",0,0,1,0,"isOwner();contractbalance = this.balance;sender = msg.sender;require(bool)(contractbalance >= summeInWei);require(bool)(minimalGoalReached);withdrawed(sender,summeInWei,wei withdrawed);sender.transfer(summeInWei)"
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.fallback,2,2,"REF_103(bool) -> blacklist[msg.sender],TMP_159 = UnaryType.BANG REF_103 ,TMP_160(None) = SOLIDITY_CALL require(bool)(TMP_159),TMP_161(bool) = payoutNow == 0,CONDITION TMP_161,TMP_162(None) = SOLIDITY_CALL require(bool)(allowsSignup),INTERNAL_CALL, KahnDistributionCentre.singleUserSignUp(address)(msg.sender),TMP_164(bool) = payoutNow == 1,CONDITION TMP_164,TMP_165(None) = SOLIDITY_CALL require(bool)(allowsSignup),TMP_166(bool) = payoutNow == 2,CONDITION TMP_166,INTERNAL_CALL, KahnDistributionCentre.claimTokens(address)(msg.sender),TMP_168(bool) = payoutNow == 3,CONDITION TMP_168,INTERNAL_CALL, KahnDistributionCentre.claimImmediateTokens(address)(msg.sender),MODIFIER_CALL, KahnDistributionCentre.ifNotStartExp()(),MODIFIER_CALL, KahnDistributionCentre.ifNotPaused()(),MODIFIER_CALL, KahnDistributionCentre.ifNotBlacklisted()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->15;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! blacklist[msg.sender])

IRs:
REF_103(bool) -> blacklist[msg.sender]
TMP_159 = UnaryType.BANG REF_103 
TMP_160(None) = SOLIDITY_CALL require(bool)(TMP_159)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
payoutNow == 0

IRs:
TMP_161(bool) = payoutNow == 0
CONDITION TMP_161""];
2->3[label=""True""];
2->5[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(allowsSignup)

IRs:
TMP_162(None) = SOLIDITY_CALL require(bool)(allowsSignup)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
singleUserSignUp(msg.sender)

IRs:
INTERNAL_CALL, KahnDistributionCentre.singleUserSignUp(address)(msg.sender)""];
4->14;
5[label=""Node Type: IF 5

EXPRESSION:
payoutNow == 1

IRs:
TMP_164(bool) = payoutNow == 1
CONDITION TMP_164""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(allowsSignup)

IRs:
TMP_165(None) = SOLIDITY_CALL require(bool)(allowsSignup)""];
6->13;
7[label=""Node Type: IF 7

EXPRESSION:
payoutNow == 2

IRs:
TMP_166(bool) = payoutNow == 2
CONDITION TMP_166""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
claimTokens(msg.sender)

IRs:
INTERNAL_CALL, KahnDistributionCentre.claimTokens(address)(msg.sender)""];
8->12;
9[label=""Node Type: IF 9

EXPRESSION:
payoutNow == 3

IRs:
TMP_168(bool) = payoutNow == 3
CONDITION TMP_168""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
claimImmediateTokens(msg.sender)

IRs:
INTERNAL_CALL, KahnDistributionCentre.claimImmediateTokens(address)(msg.sender)""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: END_IF 14
""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
ifNotStartExp()

IRs:
MODIFIER_CALL, KahnDistributionCentre.ifNotStartExp()()""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
ifNotPaused()

IRs:
MODIFIER_CALL, KahnDistributionCentre.ifNotPaused()()""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
ifNotBlacklisted()

IRs:
MODIFIER_CALL, KahnDistributionCentre.ifNotBlacklisted()()""];
17->1;
}
",0,1,1,0,ifNotStartExp();require(bool)(! blacklist[msg.sender]);payoutNow == 0;require(bool)(allowsSignup);payoutNow == 1;singleUserSignUp(msg.sender);;require(bool)(allowsSignup);payoutNow == 2;;claimTokens(msg.sender);payoutNow == 3;;claimImmediateTokens(msg.sender);;ifNotPaused();ifNotBlacklisted()
./0x1f313e1015d362a50a16a479f857637bbb36a353_ext.sol,LineOfTransfers.transferTo,36,42,"REF_0(uint256) -> values[index],amount(uint256) := REF_0(uint256),REF_1(address) -> accounts[index],Transfer dest:REF_1 value:amount,REF_3(address) -> accounts[index],Emit Transfer(REF_3,amount),RETURN True,MODIFIER_CALL, LineOfTransfers.existingIndex(uint256)(index),MODIFIER_CALL, LineOfTransfers.hasBalance(uint256)(index)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
amount = values[index]

IRs:
REF_0(uint256) -> values[index]
amount(uint256) := REF_0(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
accounts[index].transfer(amount)

IRs:
REF_1(address) -> accounts[index]
Transfer dest:REF_1 value:amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Transfer(accounts[index],amount)

IRs:
REF_3(address) -> accounts[index]
Emit Transfer(REF_3,amount)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
existingIndex(index)

IRs:
MODIFIER_CALL, LineOfTransfers.existingIndex(uint256)(index)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
hasBalance(index)

IRs:
MODIFIER_CALL, LineOfTransfers.hasBalance(uint256)(index)""];
6->1;
}
",0,0,1,0,"existingIndex(index);amount = values[index];accounts[index].transfer(amount);Transfer(accounts[index],amount);true;hasBalance(index)"
./0x5bf5436b367de54860d1b0be31203349a4d5caa7_ext.sol,CryptoCarAuction.getasall,253,257,"myAddress(address) := this(address),TMP_85(uint256) = SOLIDITY_CALL balance(address)(myAddress),etherBalance(uint256) := TMP_85(uint256),Transfer dest:owner value:etherBalance,MODIFIER_CALL, CryptoCarAuction.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
myAddress = this

IRs:
myAddress(address) := this(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
etherBalance = myAddress.balance

IRs:
TMP_85(uint256) = SOLIDITY_CALL balance(address)(myAddress)
etherBalance(uint256) := TMP_85(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(etherBalance)

IRs:
Transfer dest:owner value:etherBalance""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, CryptoCarAuction.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();myAddress = this;etherBalance = myAddress.balance;owner.transfer(etherBalance)
./0xce51f6cac9fb2695d944f2d5e2699d68aa7b656e_ext.sol,Locksmith.sendTo,136,141,"TMP_88(None) = SOLIDITY_CALL require(bool)(didProve),REF_15(uint256) = SOLIDITY_CALL balance(address)(this),TMP_89(bool) = REF_15 >= value,TMP_90(bool) = value > 0,TMP_91(bool) = TMP_89 && TMP_90,TMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91),TMP_93 = SEND dest:_to value:value,TMP_94(None) = SOLIDITY_CALL require(bool)(TMP_93),INTERNAL_CALL, Locksmith.logEvent()(),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(didProve)

IRs:
TMP_88(None) = SOLIDITY_CALL require(bool)(didProve)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(this.balance >= value && value > 0)

IRs:
REF_15(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_89(bool) = REF_15 >= value
TMP_90(bool) = value > 0
TMP_91(bool) = TMP_89 && TMP_90
TMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(_to.send(value))

IRs:
TMP_93 = SEND dest:_to value:value
TMP_94(None) = SOLIDITY_CALL require(bool)(TMP_93)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
logEvent()

IRs:
INTERNAL_CALL, Locksmith.logEvent()()""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();require(bool)(didProve);require(bool)(this.balance >= value && value > 0);require(bool)(_to.send(value));logEvent()
./0x46822ac3bc32db7ebd9845da3fe0886f824e9edf_ext.sol,EBSCSale.safeWithdrawal,681,691,"TMP_241 = UnaryType.BANG fundingGoalReached ,CONDITION TMP_241,REF_131(uint256) -> balanceOf[msg.sender],amount(uint256) := REF_131(uint256),REF_132(uint256) -> balanceOf[msg.sender],REF_132(uint256) (->balanceOf) := 0(uint256),TMP_242(bool) = amount > 0,CONDITION TMP_242,Transfer dest:msg.sender value:amount,Emit FundTransfer(msg.sender,amount,False),TMP_245(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['refundAmount', 'amount'] ,refundAmount(uint256) := TMP_245(uint256),MODIFIER_CALL, EBSCSale.afterDeadline()(),MODIFIER_CALL, EBSCSale.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: IF 1

EXPRESSION:
! fundingGoalReached

IRs:
TMP_241 = UnaryType.BANG fundingGoalReached 
CONDITION TMP_241""];
1->2[label=""True""];
1->9[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = balanceOf[msg.sender]

IRs:
REF_131(uint256) -> balanceOf[msg.sender]
amount(uint256) := REF_131(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[msg.sender] = 0

IRs:
REF_132(uint256) -> balanceOf[msg.sender]
REF_132(uint256) (->balanceOf) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
amount > 0

IRs:
TMP_242(bool) = amount > 0
CONDITION TMP_242""];
4->5[label=""True""];
4->8[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
FundTransfer(msg.sender,amount,false)

IRs:
Emit FundTransfer(msg.sender,amount,False)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
refundAmount = refundAmount.add(amount)

IRs:
TMP_245(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['refundAmount', 'amount'] 
refundAmount(uint256) := TMP_245(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
afterDeadline()

IRs:
MODIFIER_CALL, EBSCSale.afterDeadline()()""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, EBSCSale.nonReentrant()()""];
11->1;
}
",0,0,1,0,"afterDeadline();! fundingGoalReached;amount = balanceOf[msg.sender];;balanceOf[msg.sender] = 0;amount > 0;msg.sender.transfer(amount);;FundTransfer(msg.sender,amount,false);refundAmount = refundAmount.add(amount);nonReentrant()"
./0x548d32216d01617452892ea360bfce9ce8dc9729_ext.sol,ChemistryCore.withdrawAll,560,562,"REF_164(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:owner value:REF_164,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(this.balance)

IRs:
REF_164(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:owner value:REF_164""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();owner.transfer(this.balance)
./0xec91fcca41e8ab83dd5bc2bbcc2ffb71e314ba25_ext.sol,TaolCash.withdrawAll,290,294,"myAddress(address) := this(address),TMP_138(uint256) = SOLIDITY_CALL balance(address)(myAddress),etherBalance(uint256) := TMP_138(uint256),Transfer dest:owner value:etherBalance,MODIFIER_CALL, TaolCash.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
myAddress = this

IRs:
myAddress(address) := this(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
etherBalance = myAddress.balance

IRs:
TMP_138(uint256) = SOLIDITY_CALL balance(address)(myAddress)
etherBalance(uint256) := TMP_138(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(etherBalance)

IRs:
Transfer dest:owner value:etherBalance""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, TaolCash.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();myAddress = this;etherBalance = myAddress.balance;owner.transfer(etherBalance)
./0x18da8521c333aed9de8f512e847734cb7be42e38_ext.sol,Crowdsale.finalize,310,325,"TMP_128(bool) = now < endTime,CONDITION TMP_128,TMP_129(bool) = coinSentToEther == MAX_CAP,CONDITION TMP_129,TMP_130(bool) = coinSentToEther < MIN_CAP,TMP_131(uint256) = endTime + 259200,TMP_132(bool) = now < TMP_131,TMP_133(bool) = TMP_130 && TMP_132,CONDITION TMP_133,REF_94(uint256) = SOLIDITY_CALL balance(address)(this),TMP_134 = SEND dest:multisigEther value:REF_94,TMP_135 = UnaryType.BANG TMP_134 ,CONDITION TMP_135,TMP_136(uint256) = HIGH_LEVEL_CALL, dest:coin(ProjectX), function:balanceOf, arguments:['this']  ,remains(uint256) := TMP_136(uint256),TMP_137(bool) = remains > 0,CONDITION TMP_137,TMP_138(bool) = HIGH_LEVEL_CALL, dest:coin(ProjectX), function:burn, arguments:['remains']  ,TMP_139 = UnaryType.BANG TMP_138 ,CONDITION TMP_139,crowdsaleClosed(bool) := True(bool),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->19;
1[label=""Node Type: IF 1

EXPRESSION:
now < endTime

IRs:
TMP_128(bool) = now < endTime
CONDITION TMP_128""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
coinSentToEther == MAX_CAP

IRs:
TMP_129(bool) = coinSentToEther == MAX_CAP
CONDITION TMP_129""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: THROW 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
coinSentToEther < MIN_CAP && now < endTime + 259200

IRs:
TMP_130(bool) = coinSentToEther < MIN_CAP
TMP_131(uint256) = endTime + 259200
TMP_132(bool) = now < TMP_131
TMP_133(bool) = TMP_130 && TMP_132
CONDITION TMP_133""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: THROW 7
""];
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
! multisigEther.send(this.balance)

IRs:
REF_94(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_134 = SEND dest:multisigEther value:REF_94
TMP_135 = UnaryType.BANG TMP_134 
CONDITION TMP_135""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: THROW 10
""];
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
remains = coin.balanceOf(this)

IRs:
TMP_136(uint256) = HIGH_LEVEL_CALL, dest:coin(ProjectX), function:balanceOf, arguments:['this']  
remains(uint256) := TMP_136(uint256)""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
remains > 0

IRs:
TMP_137(bool) = remains > 0
CONDITION TMP_137""];
13->14[label=""True""];
13->17[label=""False""];
14[label=""Node Type: IF 14

EXPRESSION:
! coin.burn(remains)

IRs:
TMP_138(bool) = HIGH_LEVEL_CALL, dest:coin(ProjectX), function:burn, arguments:['remains']  
TMP_139 = UnaryType.BANG TMP_138 
CONDITION TMP_139""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: THROW 15
""];
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
crowdsaleClosed = true

IRs:
crowdsaleClosed(bool) := True(bool)""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
19->1;
}
",1,0,1,0,onlyOwner();now < endTime;coinSentToEther == MAX_CAP;;;;coinSentToEther < MIN_CAP && now < endTime + 259200;;;! multisigEther.send(this.balance);;;remains = coin.balanceOf(this);remains > 0;! coin.burn(remains);;;;crowdsaleClosed = true
./0xf5587929c51017cfa8d0ead672fcc6b39f1496b0_ext.sol,RippleCredit.getTokens,182,245,"tokens(uint256) := 0(uint256),bonus(uint256) := 0(uint256),countbonus(uint256) := 0(uint256),TMP_45(uint256) = 5000000000000000000 / 100,bonusCond1(uint256) := TMP_45(uint256),TMP_46(uint256) = 1000000000000000000 / 10,bonusCond2(uint256) := TMP_46(uint256),TMP_47(uint256) = 5000000000000000000 / 10,bonusCond3(uint256) := TMP_47(uint256),bonusCond4(uint256) := 1000000000000000000(uint256),TMP_48(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_49(uint256) = TMP_48 / 1000000000000000000,tokens(uint256) := TMP_49(uint256),investor(address) := msg.sender(address),TMP_50(bool) = msg.value >= requestMinimum,TMP_51(bool) = now < deadline,TMP_52(bool) = TMP_50 && TMP_51,TMP_53(bool) = now < round1,TMP_54(bool) = TMP_52 && TMP_53,TMP_55(bool) = now < round2,TMP_56(bool) = TMP_54 && TMP_55,CONDITION TMP_56,TMP_57(bool) = msg.value >= bonusCond1,TMP_58(bool) = msg.value < bonusCond2,TMP_59(bool) = TMP_57 && TMP_58,CONDITION TMP_59,TMP_60(uint256) = tokens * 10,TMP_61(uint256) = TMP_60 / 100,countbonus(uint256) := TMP_61(uint256),TMP_62(bool) = msg.value >= bonusCond2,TMP_63(bool) = msg.value < bonusCond3,TMP_64(bool) = TMP_62 && TMP_63,CONDITION TMP_64,TMP_65(uint256) = tokens * 20,TMP_66(uint256) = TMP_65 / 100,countbonus(uint256) := TMP_66(uint256),TMP_67(bool) = msg.value >= bonusCond3,TMP_68(bool) = msg.value < bonusCond4,TMP_69(bool) = TMP_67 && TMP_68,CONDITION TMP_69,TMP_70(uint256) = tokens * 35,TMP_71(uint256) = TMP_70 / 100,countbonus(uint256) := TMP_71(uint256),TMP_72(bool) = msg.value >= bonusCond4,CONDITION TMP_72,TMP_73(uint256) = tokens * 50,TMP_74(uint256) = TMP_73 / 100,countbonus(uint256) := TMP_74(uint256),TMP_75(bool) = msg.value >= requestMinimum,TMP_76(bool) = now < deadline,TMP_77(bool) = TMP_75 && TMP_76,TMP_78(bool) = now > round1,TMP_79(bool) = TMP_77 && TMP_78,TMP_80(bool) = now < round2,TMP_81(bool) = TMP_79 && TMP_80,CONDITION TMP_81,TMP_82(bool) = msg.value >= bonusCond2,TMP_83(bool) = msg.value < bonusCond3,TMP_84(bool) = TMP_82 && TMP_83,CONDITION TMP_84,TMP_85(uint256) = tokens * 2,TMP_86(uint256) = TMP_85 / 100,countbonus(uint256) := TMP_86(uint256),TMP_87(bool) = msg.value >= bonusCond3,CONDITION TMP_87,TMP_88(uint256) = tokens * 3,TMP_89(uint256) = TMP_88 / 100,countbonus(uint256) := TMP_89(uint256),countbonus(uint256) := 0(uint256),TMP_90(uint256) = tokens + countbonus,bonus(uint256) := TMP_90(uint256),TMP_91(bool) = tokens == 0,CONDITION TMP_91,valdrop(uint256) := 100000000(uint256),REF_12(bool) -> Claimed[investor],TMP_92(bool) = REF_12 == False,TMP_93(bool) = progress0drop <= target0drop,TMP_94(bool) = TMP_92 && TMP_93,CONDITION TMP_94,TMP_95(bool) = INTERNAL_CALL, RippleCredit.distr(address,uint256)(investor,valdrop),REF_13(bool) -> Claimed[investor],REF_13(bool) (->Claimed) := True(bool),TMP_96(uint256) := progress0drop(uint256),progress0drop(uint256) = progress0drop + 1,TMP_97(bool) = msg.value >= requestMinimum,TMP_98(None) = SOLIDITY_CALL require(bool)(TMP_97),TMP_99(bool) = tokens > 0,TMP_100(bool) = msg.value >= requestMinimum,TMP_101(bool) = TMP_99 && TMP_100,CONDITION TMP_101,TMP_102(bool) = now >= deadline,TMP_103(bool) = now >= round1,TMP_104(bool) = TMP_102 && TMP_103,TMP_105(bool) = now < round2,TMP_106(bool) = TMP_104 && TMP_105,CONDITION TMP_106,TMP_107(bool) = INTERNAL_CALL, RippleCredit.distr(address,uint256)(investor,tokens),TMP_108(bool) = msg.value >= bonusCond1,CONDITION TMP_108,TMP_109(bool) = INTERNAL_CALL, RippleCredit.distr(address,uint256)(investor,bonus),TMP_110(bool) = INTERNAL_CALL, RippleCredit.distr(address,uint256)(investor,tokens),TMP_111(bool) = msg.value >= requestMinimum,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113(bool) = totalDistributed >= totalSupply,CONDITION TMP_113,distributionFinished(bool) := True(bool),Transfer dest:multisig value:msg.value,MODIFIER_CALL, RippleCredit.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->57;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bonusCond1 = 5000000000000000000 / 100

IRs:
TMP_45(uint256) = 5000000000000000000 / 100
bonusCond1(uint256) := TMP_45(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bonusCond2 = 1000000000000000000 / 10

IRs:
TMP_46(uint256) = 1000000000000000000 / 10
bonusCond2(uint256) := TMP_46(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
bonusCond3 = 5000000000000000000 / 10

IRs:
TMP_47(uint256) = 5000000000000000000 / 10
bonusCond3(uint256) := TMP_47(uint256)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
bonusCond4 = 1000000000000000000

IRs:
bonusCond4(uint256) := 1000000000000000000(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_48(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_49(uint256) = TMP_48 / 1000000000000000000
tokens(uint256) := TMP_49(uint256)""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now < round1 && now < round2

IRs:
TMP_50(bool) = msg.value >= requestMinimum
TMP_51(bool) = now < deadline
TMP_52(bool) = TMP_50 && TMP_51
TMP_53(bool) = now < round1
TMP_54(bool) = TMP_52 && TMP_53
TMP_55(bool) = now < round2
TMP_56(bool) = TMP_54 && TMP_55
CONDITION TMP_56""];
10->11[label=""True""];
10->23[label=""False""];
11[label=""Node Type: IF 11

EXPRESSION:
msg.value >= bonusCond1 && msg.value < bonusCond2

IRs:
TMP_57(bool) = msg.value >= bonusCond1
TMP_58(bool) = msg.value < bonusCond2
TMP_59(bool) = TMP_57 && TMP_58
CONDITION TMP_59""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
countbonus = tokens * 10 / 100

IRs:
TMP_60(uint256) = tokens * 10
TMP_61(uint256) = TMP_60 / 100
countbonus(uint256) := TMP_61(uint256)""];
12->22;
13[label=""Node Type: IF 13

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_62(bool) = msg.value >= bonusCond2
TMP_63(bool) = msg.value < bonusCond3
TMP_64(bool) = TMP_62 && TMP_63
CONDITION TMP_64""];
13->14[label=""True""];
13->15[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
countbonus = tokens * 20 / 100

IRs:
TMP_65(uint256) = tokens * 20
TMP_66(uint256) = TMP_65 / 100
countbonus(uint256) := TMP_66(uint256)""];
14->21;
15[label=""Node Type: IF 15

EXPRESSION:
msg.value >= bonusCond3 && msg.value < bonusCond4

IRs:
TMP_67(bool) = msg.value >= bonusCond3
TMP_68(bool) = msg.value < bonusCond4
TMP_69(bool) = TMP_67 && TMP_68
CONDITION TMP_69""];
15->16[label=""True""];
15->17[label=""False""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
countbonus = tokens * 35 / 100

IRs:
TMP_70(uint256) = tokens * 35
TMP_71(uint256) = TMP_70 / 100
countbonus(uint256) := TMP_71(uint256)""];
16->20;
17[label=""Node Type: IF 17

EXPRESSION:
msg.value >= bonusCond4

IRs:
TMP_72(bool) = msg.value >= bonusCond4
CONDITION TMP_72""];
17->18[label=""True""];
17->19[label=""False""];
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
countbonus = tokens * 50 / 100

IRs:
TMP_73(uint256) = tokens * 50
TMP_74(uint256) = TMP_73 / 100
countbonus(uint256) := TMP_74(uint256)""];
18->19;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: END_IF 21
""];
21->22;
22[label=""Node Type: END_IF 22
""];
22->32;
23[label=""Node Type: IF 23

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now > round1 && now < round2

IRs:
TMP_75(bool) = msg.value >= requestMinimum
TMP_76(bool) = now < deadline
TMP_77(bool) = TMP_75 && TMP_76
TMP_78(bool) = now > round1
TMP_79(bool) = TMP_77 && TMP_78
TMP_80(bool) = now < round2
TMP_81(bool) = TMP_79 && TMP_80
CONDITION TMP_81""];
23->24[label=""True""];
23->30[label=""False""];
24[label=""Node Type: IF 24

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_82(bool) = msg.value >= bonusCond2
TMP_83(bool) = msg.value < bonusCond3
TMP_84(bool) = TMP_82 && TMP_83
CONDITION TMP_84""];
24->25[label=""True""];
24->26[label=""False""];
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
countbonus = tokens * 2 / 100

IRs:
TMP_85(uint256) = tokens * 2
TMP_86(uint256) = TMP_85 / 100
countbonus(uint256) := TMP_86(uint256)""];
25->29;
26[label=""Node Type: IF 26

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_87(bool) = msg.value >= bonusCond3
CONDITION TMP_87""];
26->27[label=""True""];
26->28[label=""False""];
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
countbonus = tokens * 3 / 100

IRs:
TMP_88(uint256) = tokens * 3
TMP_89(uint256) = TMP_88 / 100
countbonus(uint256) := TMP_89(uint256)""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: END_IF 29
""];
29->31;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
30->31;
31[label=""Node Type: END_IF 31
""];
31->32;
32[label=""Node Type: END_IF 32
""];
32->33;
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
bonus = tokens + countbonus

IRs:
TMP_90(uint256) = tokens + countbonus
bonus(uint256) := TMP_90(uint256)""];
33->34;
34[label=""Node Type: IF 34

EXPRESSION:
tokens == 0

IRs:
TMP_91(bool) = tokens == 0
CONDITION TMP_91""];
34->35[label=""True""];
34->42[label=""False""];
35[label=""Node Type: NEW VARIABLE 35

EXPRESSION:
valdrop = 1e8

IRs:
valdrop(uint256) := 100000000(uint256)""];
35->36;
36[label=""Node Type: IF 36

EXPRESSION:
Claimed[investor] == false && progress0drop <= target0drop

IRs:
REF_12(bool) -> Claimed[investor]
TMP_92(bool) = REF_12 == False
TMP_93(bool) = progress0drop <= target0drop
TMP_94(bool) = TMP_92 && TMP_93
CONDITION TMP_94""];
36->37[label=""True""];
36->40[label=""False""];
37[label=""Node Type: EXPRESSION 37

EXPRESSION:
distr(investor,valdrop)

IRs:
TMP_95(bool) = INTERNAL_CALL, RippleCredit.distr(address,uint256)(investor,valdrop)""];
37->38;
38[label=""Node Type: EXPRESSION 38

EXPRESSION:
Claimed[investor] = true

IRs:
REF_13(bool) -> Claimed[investor]
REF_13(bool) (->Claimed) := True(bool)""];
38->39;
39[label=""Node Type: EXPRESSION 39

EXPRESSION:
progress0drop ++

IRs:
TMP_96(uint256) := progress0drop(uint256)
progress0drop(uint256) = progress0drop + 1""];
39->41;
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_97(bool) = msg.value >= requestMinimum
TMP_98(None) = SOLIDITY_CALL require(bool)(TMP_97)""];
40->41;
41[label=""Node Type: END_IF 41
""];
41->52;
42[label=""Node Type: IF 42

EXPRESSION:
tokens > 0 && msg.value >= requestMinimum

IRs:
TMP_99(bool) = tokens > 0
TMP_100(bool) = msg.value >= requestMinimum
TMP_101(bool) = TMP_99 && TMP_100
CONDITION TMP_101""];
42->43[label=""True""];
42->50[label=""False""];
43[label=""Node Type: IF 43

EXPRESSION:
now >= deadline && now >= round1 && now < round2

IRs:
TMP_102(bool) = now >= deadline
TMP_103(bool) = now >= round1
TMP_104(bool) = TMP_102 && TMP_103
TMP_105(bool) = now < round2
TMP_106(bool) = TMP_104 && TMP_105
CONDITION TMP_106""];
43->44[label=""True""];
43->45[label=""False""];
44[label=""Node Type: EXPRESSION 44

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_107(bool) = INTERNAL_CALL, RippleCredit.distr(address,uint256)(investor,tokens)""];
44->49;
45[label=""Node Type: IF 45

EXPRESSION:
msg.value >= bonusCond1

IRs:
TMP_108(bool) = msg.value >= bonusCond1
CONDITION TMP_108""];
45->46[label=""True""];
45->47[label=""False""];
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
distr(investor,bonus)

IRs:
TMP_109(bool) = INTERNAL_CALL, RippleCredit.distr(address,uint256)(investor,bonus)""];
46->48;
47[label=""Node Type: EXPRESSION 47

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_110(bool) = INTERNAL_CALL, RippleCredit.distr(address,uint256)(investor,tokens)""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: END_IF 49
""];
49->51;
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_111(bool) = msg.value >= requestMinimum
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: END_IF 52
""];
52->53;
53[label=""Node Type: IF 53

EXPRESSION:
totalDistributed >= totalSupply

IRs:
TMP_113(bool) = totalDistributed >= totalSupply
CONDITION TMP_113""];
53->54[label=""True""];
53->55[label=""False""];
54[label=""Node Type: EXPRESSION 54

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)""];
54->55;
55[label=""Node Type: END_IF 55
""];
55->56;
56[label=""Node Type: EXPRESSION 56

EXPRESSION:
multisig.transfer(msg.value)

IRs:
Transfer dest:multisig value:msg.value""];
57[label=""Node Type: EXPRESSION 57

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, RippleCredit.canDistr()()""];
57->1;
}
",0,0,1,0,"canDistr();tokens = 0;bonus = 0;countbonus = 0;bonusCond1 = 5000000000000000000 / 100;bonusCond2 = 1000000000000000000 / 10;bonusCond3 = 5000000000000000000 / 10;bonusCond4 = 1000000000000000000;tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;investor = msg.sender;msg.value >= requestMinimum && now < deadline && now < round1 && now < round2;msg.value >= bonusCond1 && msg.value < bonusCond2;msg.value >= requestMinimum && now < deadline && now > round1 && now < round2;countbonus = tokens * 10 / 100;msg.value >= bonusCond2 && msg.value < bonusCond3;;countbonus = tokens * 20 / 100;msg.value >= bonusCond3 && msg.value < bonusCond4;;countbonus = tokens * 35 / 100;msg.value >= bonusCond4;;countbonus = tokens * 50 / 100;;;msg.value >= bonusCond2 && msg.value < bonusCond3;countbonus = 0;countbonus = tokens * 2 / 100;msg.value >= bonusCond3;;countbonus = tokens * 3 / 100;;;bonus = tokens + countbonus;tokens == 0;valdrop = 1e8;tokens > 0 && msg.value >= requestMinimum;Claimed[investor] == false && progress0drop <= target0drop;distr(investor,valdrop);require(bool)(msg.value >= requestMinimum);Claimed[investor] = true;progress0drop ++;;;now >= deadline && now >= round1 && now < round2;require(bool)(msg.value >= requestMinimum);distr(investor,tokens);msg.value >= bonusCond1;;distr(investor,bonus);distr(investor,tokens);;;totalDistributed >= totalSupply;distributionFinished = true;;multisig.transfer(msg.value)"
./0x330bebabc9a2a4136e3d1cb38ca521f5a95aec2e_ext.sol,KoreaShow.claimTokens,664,674,"TMP_184(bool) = _token == 0,CONDITION TMP_184,REF_72(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:controller value:REF_72,TMP_186 = CONVERT _token to ERC20Token,token(ERC20Token) := TMP_186(ERC20Token),TMP_187(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_187(uint256),TMP_188(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:transfer, arguments:['controller', 'balance']  ,Emit ClaimedTokens(_token,controller,balance),MODIFIER_CALL, Controlled.onlyController()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_184(bool) = _token == 0
CONDITION TMP_184""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_72(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_72""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
token = ERC20Token(_token)

IRs:
TMP_186 = CONVERT _token to ERC20Token
token(ERC20Token) := TMP_186(ERC20Token)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_187(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_187(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_188(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:transfer, arguments:['controller', 'balance']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()""];
9->1;
}
",1,0,1,0,"onlyController();_token == 0x0;controller.transfer(this.balance);;;token = ERC20Token(_token);balance = token.balanceOf(this);token.transfer(controller,balance);ClaimedTokens(_token,controller,balance)"
./0xebcf88fb2783bbb75b12df3f33627efa894afea4_ext.sol,SPACEDICE.collect,104,107,"TMP_72 = CONVERT this to address,TMP_73(uint256) = SOLIDITY_CALL balance(address)(TMP_72),TMP_74(bool) = TMP_73 > _amount,TMP_75(None) = SOLIDITY_CALL require(bool)(TMP_74),Transfer dest:owner value:_amount,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(address(this).balance > _amount)

IRs:
TMP_72 = CONVERT this to address
TMP_73(uint256) = SOLIDITY_CALL balance(address)(TMP_72)
TMP_74(bool) = TMP_73 > _amount
TMP_75(None) = SOLIDITY_CALL require(bool)(TMP_74)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(_amount)

IRs:
Transfer dest:owner value:_amount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();require(bool)(address(this).balance > _amount);owner.transfer(_amount)
./0x402cd1fa4ba4296f5503d1e86214b77ec7cfe840_ext.sol,Crowdsale.safeWithdrawal,98,119,"TMP_45 = UnaryType.BANG fundingGoalReached ,CONDITION TMP_45,REF_6(uint256) -> balanceOf[msg.sender],amount(uint256) := REF_6(uint256),REF_7(uint256) -> balanceOf[msg.sender],REF_7(uint256) (->balanceOf) := 0(uint256),TMP_46(bool) = amount > 0,CONDITION TMP_46,TMP_47 = SEND dest:msg.sender value:amount,CONDITION TMP_47,Emit FundTransfer(msg.sender,amount,False),REF_9(uint256) -> balanceOf[msg.sender],REF_9(uint256) (->balanceOf) := amount(uint256),TMP_49(bool) = beneficiary == msg.sender,TMP_50(bool) = fundingGoalReached && TMP_49,CONDITION TMP_50,TMP_51 = SEND dest:beneficiary value:amountRaised,CONDITION TMP_51,Emit FundTransfer(beneficiary,amountRaised,False),fundingGoalReached(bool) := False(bool),MODIFIER_CALL, Crowdsale.afterDeadline()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->17;
1[label=""Node Type: IF 1

EXPRESSION:
! fundingGoalReached

IRs:
TMP_45 = UnaryType.BANG fundingGoalReached 
CONDITION TMP_45""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = balanceOf[msg.sender]

IRs:
REF_6(uint256) -> balanceOf[msg.sender]
amount(uint256) := REF_6(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[msg.sender] = 0

IRs:
REF_7(uint256) -> balanceOf[msg.sender]
REF_7(uint256) (->balanceOf) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
amount > 0

IRs:
TMP_46(bool) = amount > 0
CONDITION TMP_46""];
4->5[label=""True""];
4->9[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
msg.sender.send(amount)

IRs:
TMP_47 = SEND dest:msg.sender value:amount
CONDITION TMP_47""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
FundTransfer(msg.sender,amount,false)

IRs:
Emit FundTransfer(msg.sender,amount,False)""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balanceOf[msg.sender] = amount

IRs:
REF_9(uint256) -> balanceOf[msg.sender]
REF_9(uint256) (->balanceOf) := amount(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
fundingGoalReached && beneficiary == msg.sender

IRs:
TMP_49(bool) = beneficiary == msg.sender
TMP_50(bool) = fundingGoalReached && TMP_49
CONDITION TMP_50""];
11->12[label=""True""];
11->16[label=""False""];
12[label=""Node Type: IF 12

EXPRESSION:
beneficiary.send(amountRaised)

IRs:
TMP_51 = SEND dest:beneficiary value:amountRaised
CONDITION TMP_51""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
FundTransfer(beneficiary,amountRaised,false)

IRs:
Emit FundTransfer(beneficiary,amountRaised,False)""];
13->15;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
fundingGoalReached = false

IRs:
fundingGoalReached(bool) := False(bool)""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: END_IF 16
""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
afterDeadline()

IRs:
MODIFIER_CALL, Crowdsale.afterDeadline()()""];
17->1;
}
",0,0,1,0,"afterDeadline();! fundingGoalReached;amount = balanceOf[msg.sender];;balanceOf[msg.sender] = 0;amount > 0;msg.sender.send(amount);;FundTransfer(msg.sender,amount,false);balanceOf[msg.sender] = amount;;fundingGoalReached && beneficiary == msg.sender;beneficiary.send(amountRaised);;FundTransfer(beneficiary,amountRaised,false);fundingGoalReached = false;"
./0x7287bef78619e10c32a1eee82046fa3c4a29f17d_ext.sol,CryptoPornSmartContract._payout,358,364,"REF_51(uint256) = SOLIDITY_CALL balance(address)(this),TMP_84(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['REF_51', '4'] ,amount(uint256) := TMP_84(uint256),REF_52(address) -> cooAddresses[0],Transfer dest:REF_52 value:amount,REF_54(address) -> cooAddresses[1],Transfer dest:REF_54 value:amount,REF_56(address) -> cooAddresses[2],Transfer dest:REF_56 value:amount,REF_58(address) -> cooAddresses[3],Transfer dest:REF_58 value:amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
amount = SafeMath.div(this.balance,4)

IRs:
REF_51(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_84(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['REF_51', '4'] 
amount(uint256) := TMP_84(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
cooAddresses[0].transfer(amount)

IRs:
REF_52(address) -> cooAddresses[0]
Transfer dest:REF_52 value:amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
cooAddresses[1].transfer(amount)

IRs:
REF_54(address) -> cooAddresses[1]
Transfer dest:REF_54 value:amount""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
cooAddresses[2].transfer(amount)

IRs:
REF_56(address) -> cooAddresses[2]
Transfer dest:REF_56 value:amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
cooAddresses[3].transfer(amount)

IRs:
REF_58(address) -> cooAddresses[3]
Transfer dest:REF_58 value:amount""];
}
",0,0,1,0,"amount = SafeMath.div(this.balance,4);cooAddresses[0].transfer(amount);cooAddresses[1].transfer(amount);cooAddresses[2].transfer(amount);cooAddresses[3].transfer(amount)"
./0x6c1bcb34142bffd35f57db626e0ac427af616a4d_ext.sol,EnjinBuyer.withdraw,69,95,"TMP_33(bool) = bought_tokens || kill_switch,TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33),TMP_35(bool) = user != sale,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),REF_14(uint256) -> balances_after_buy[user],TMP_37(bool) = REF_14 > 0,TMP_38(bool) = user != sale,TMP_39(bool) = TMP_37 && TMP_38,CONDITION TMP_39,REF_15(uint256) -> balances_after_buy[user],eth_to_withdraw_after_buy(uint256) := REF_15(uint256),REF_16(uint256) -> balances_after_buy[user],REF_16(uint256) (->balances_after_buy) := 0(uint256),Transfer dest:user value:eth_to_withdraw_after_buy,REF_18(uint256) -> balances[user],TMP_41(bool) = REF_18 == 0,CONDITION TMP_41,TMP_42 = UnaryType.BANG bought_tokens ,TMP_43(bool) = TMP_42 || refunded,CONDITION TMP_43,REF_19(uint256) -> balances[user],eth_to_withdraw(uint256) := REF_19(uint256),REF_20(uint256) -> balances[user],REF_20(uint256) (->balances) := 0(uint256),Transfer dest:user value:eth_to_withdraw,TMP_45(None) = SOLIDITY_CALL require(bool)(token_set),TMP_46 = CONVERT this to address,TMP_47(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['TMP_46']  ,contract_token_balance(uint256) := TMP_47(uint256),TMP_48(bool) = contract_token_balance != 0,TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48),REF_23(uint256) -> balances[user],TMP_50(uint256) = REF_23 * contract_token_balance,TMP_51(uint256) = TMP_50 / contract_eth_value,tokens_to_withdraw(uint256) := TMP_51(uint256),REF_24(uint256) -> balances[user],contract_eth_value(uint256) = contract_eth_value - REF_24,REF_25(uint256) -> balances[user],REF_25(uint256) (->balances) := 0(uint256),TMP_52(uint256) = tokens_to_withdraw / 100,fee(uint256) := TMP_52(uint256),TMP_53(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['developer', 'fee']  ,TMP_54(None) = SOLIDITY_CALL require(bool)(TMP_53),TMP_55(uint256) = tokens_to_withdraw - fee,TMP_56(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['user', 'TMP_55']  ,TMP_57(None) = SOLIDITY_CALL require(bool)(TMP_56)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(bought_tokens || kill_switch)

IRs:
TMP_33(bool) = bought_tokens || kill_switch
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(user != sale)

IRs:
TMP_35(bool) = user != sale
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
balances_after_buy[user] > 0 && user != sale

IRs:
REF_14(uint256) -> balances_after_buy[user]
TMP_37(bool) = REF_14 > 0
TMP_38(bool) = user != sale
TMP_39(bool) = TMP_37 && TMP_38
CONDITION TMP_39""];
3->4[label=""True""];
3->7[label=""False""];
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
eth_to_withdraw_after_buy = balances_after_buy[user]

IRs:
REF_15(uint256) -> balances_after_buy[user]
eth_to_withdraw_after_buy(uint256) := REF_15(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances_after_buy[user] = 0

IRs:
REF_16(uint256) -> balances_after_buy[user]
REF_16(uint256) (->balances_after_buy) := 0(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
user.transfer(eth_to_withdraw_after_buy)

IRs:
Transfer dest:user value:eth_to_withdraw_after_buy""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
balances[user] == 0

IRs:
REF_18(uint256) -> balances[user]
TMP_41(bool) = REF_18 == 0
CONDITION TMP_41""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: RETURN 9
""];
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
! bought_tokens || refunded

IRs:
TMP_42 = UnaryType.BANG bought_tokens 
TMP_43(bool) = TMP_42 || refunded
CONDITION TMP_43""];
11->12[label=""True""];
11->15[label=""False""];
12[label=""Node Type: NEW VARIABLE 12

EXPRESSION:
eth_to_withdraw = balances[user]

IRs:
REF_19(uint256) -> balances[user]
eth_to_withdraw(uint256) := REF_19(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
balances[user] = 0

IRs:
REF_20(uint256) -> balances[user]
REF_20(uint256) (->balances) := 0(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
user.transfer(eth_to_withdraw)

IRs:
Transfer dest:user value:eth_to_withdraw""];
14->24;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
require(bool)(token_set)

IRs:
TMP_45(None) = SOLIDITY_CALL require(bool)(token_set)""];
15->16;
16[label=""Node Type: NEW VARIABLE 16

EXPRESSION:
contract_token_balance = token.balanceOf(address(this))

IRs:
TMP_46 = CONVERT this to address
TMP_47(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['TMP_46']  
contract_token_balance(uint256) := TMP_47(uint256)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
require(bool)(contract_token_balance != 0)

IRs:
TMP_48(bool) = contract_token_balance != 0
TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48)""];
17->18;
18[label=""Node Type: NEW VARIABLE 18

EXPRESSION:
tokens_to_withdraw = (balances[user] * contract_token_balance) / contract_eth_value

IRs:
REF_23(uint256) -> balances[user]
TMP_50(uint256) = REF_23 * contract_token_balance
TMP_51(uint256) = TMP_50 / contract_eth_value
tokens_to_withdraw(uint256) := TMP_51(uint256)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
contract_eth_value -= balances[user]

IRs:
REF_24(uint256) -> balances[user]
contract_eth_value(uint256) = contract_eth_value - REF_24""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
balances[user] = 0

IRs:
REF_25(uint256) -> balances[user]
REF_25(uint256) (->balances) := 0(uint256)""];
20->21;
21[label=""Node Type: NEW VARIABLE 21

EXPRESSION:
fee = tokens_to_withdraw / 100

IRs:
TMP_52(uint256) = tokens_to_withdraw / 100
fee(uint256) := TMP_52(uint256)""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
require(bool)(token.transfer(developer,fee))

IRs:
TMP_53(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['developer', 'fee']  
TMP_54(None) = SOLIDITY_CALL require(bool)(TMP_53)""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
require(bool)(token.transfer(user,tokens_to_withdraw - fee))

IRs:
TMP_55(uint256) = tokens_to_withdraw - fee
TMP_56(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['user', 'TMP_55']  
TMP_57(None) = SOLIDITY_CALL require(bool)(TMP_56)""];
23->24;
24[label=""Node Type: END_IF 24
""];
}
",0,1,1,0,"require(bool)(bought_tokens || kill_switch);require(bool)(user != sale);balances_after_buy[user] > 0 && user != sale;eth_to_withdraw_after_buy = balances_after_buy[user];;balances_after_buy[user] = 0;user.transfer(eth_to_withdraw_after_buy);balances[user] == 0;;;! bought_tokens || refunded;eth_to_withdraw = balances[user];require(bool)(token_set);balances[user] = 0;user.transfer(eth_to_withdraw);;contract_token_balance = token.balanceOf(address(this));require(bool)(contract_token_balance != 0);tokens_to_withdraw = (balances[user] * contract_token_balance) / contract_eth_value;contract_eth_value -= balances[user];balances[user] = 0;fee = tokens_to_withdraw / 100;require(bool)(token.transfer(developer,fee));require(bool)(token.transfer(user,tokens_to_withdraw - fee))"
./0xeef93ec835c7921038d55ee096671a94e961709b_ext.sol,RefundVault.refund,645,651,"REF_257(RefundVault.State) -> State.Refunding,TMP_436(bool) = state == REF_257,TMP_437(None) = SOLIDITY_CALL require(bool)(TMP_436),REF_258(uint256) -> deposited[investor],depositedValue(uint256) := REF_258(uint256),REF_259(uint256) -> deposited[investor],REF_259(uint256) (->deposited) := 0(uint256),Transfer dest:investor value:depositedValue,Emit Refunded(investor,depositedValue)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Refunding)

IRs:
REF_257(RefundVault.State) -> State.Refunding
TMP_436(bool) = state == REF_257
TMP_437(None) = SOLIDITY_CALL require(bool)(TMP_436)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
depositedValue = deposited[investor]

IRs:
REF_258(uint256) -> deposited[investor]
depositedValue(uint256) := REF_258(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
deposited[investor] = 0

IRs:
REF_259(uint256) -> deposited[investor]
REF_259(uint256) (->deposited) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
investor.transfer(depositedValue)

IRs:
Transfer dest:investor value:depositedValue""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Refunded(investor,depositedValue)

IRs:
Emit Refunded(investor,depositedValue)""];
}
",0,0,1,0,"require(bool)(state == State.Refunding);depositedValue = deposited[investor];deposited[investor] = 0;investor.transfer(depositedValue);Refunded(investor,depositedValue)"
./0xc849a5fff9befa297d1c3a772bafac9f3c9004ec_ext.sol,Bounty0xEscrow.distributeTokenToAddress,202,212,"TMP_76 = CONVERT 0 to address,TMP_77(bool) = _hunter != TMP_76,TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77),REF_22(mapping(address => uint256)) -> tokens[_token],REF_23(uint256) -> REF_22[_host],TMP_79(bool) = REF_23 >= _amount,TMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79),REF_24(mapping(address => uint256)) -> tokens[_token],REF_25(uint256) -> REF_24[_host],REF_27(mapping(address => uint256)) -> tokens[_token],REF_28(uint256) -> REF_27[_host],TMP_81(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_amount'] ,REF_25(uint256) (->tokens) := TMP_81(uint256),TMP_82 = CONVERT 0 to address,TMP_83(bool) = _token == TMP_82,CONDITION TMP_83,TMP_84 = SEND dest:_hunter value:_amount,TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84),TMP_86 = CONVERT _token to ERC20,HIGH_LEVEL_CALL, dest:TMP_86(ERC20), function:transfer, arguments:['_hunter', '_amount']  ,Emit Distribution(_token,_host,_hunter,_amount),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_hunter != address(0))

IRs:
TMP_76 = CONVERT 0 to address
TMP_77(bool) = _hunter != TMP_76
TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(tokens[_token][_host] >= _amount)

IRs:
REF_22(mapping(address => uint256)) -> tokens[_token]
REF_23(uint256) -> REF_22[_host]
TMP_79(bool) = REF_23 >= _amount
TMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tokens[_token][_host] = SafeMath.sub(tokens[_token][_host],_amount)

IRs:
REF_24(mapping(address => uint256)) -> tokens[_token]
REF_25(uint256) -> REF_24[_host]
REF_27(mapping(address => uint256)) -> tokens[_token]
REF_28(uint256) -> REF_27[_host]
TMP_81(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_amount'] 
REF_25(uint256) (->tokens) := TMP_81(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
_token == address(0)

IRs:
TMP_82 = CONVERT 0 to address
TMP_83(bool) = _token == TMP_82
CONDITION TMP_83""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(_hunter.send(_amount))

IRs:
TMP_84 = SEND dest:_hunter value:_amount
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)""];
5->7;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
ERC20(_token).transfer(_hunter,_amount)

IRs:
TMP_86 = CONVERT _token to ERC20
HIGH_LEVEL_CALL, dest:TMP_86(ERC20), function:transfer, arguments:['_hunter', '_amount']  ""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Distribution(_token,_host,_hunter,_amount)

IRs:
Emit Distribution(_token,_host,_hunter,_amount)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
9->1;
}
",1,0,1,0,"onlyOwner();require(bool)(_hunter != address(0));require(bool)(tokens[_token][_host] >= _amount);tokens[_token][_host] = SafeMath.sub(tokens[_token][_host],_amount);_token == address(0);require(bool)(_hunter.send(_amount));ERC20(_token).transfer(_hunter,_amount);;Distribution(_token,_host,_hunter,_amount)"
./0xc4aad17558fa95c8937d0856b2dad74c1a7a095f_ext.sol,RefundVault.close,117,122,"REF_5(RefundVault.State) -> State.Active,TMP_33(bool) = state == REF_5,TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33),REF_6(RefundVault.State) -> State.Closed,state(RefundVault.State) := REF_6(RefundVault.State),Emit Closed(),REF_8(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:wallet value:REF_8,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_5(RefundVault.State) -> State.Active
TMP_33(bool) = state == REF_5
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
state = State.Closed

IRs:
REF_6(RefundVault.State) -> State.Closed
state(RefundVault.State) := REF_6(RefundVault.State)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Closed()

IRs:
Emit Closed()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
wallet.transfer(this.balance)

IRs:
REF_8(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:wallet value:REF_8""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();require(bool)(state == State.Active);state = State.Closed;Closed();wallet.transfer(this.balance)
./0x5592a2704ba651f8af4cb6f330415f9877483ad2_ext.sol,NamiMultiSigWallet.executeTransaction,214,229,"TMP_50(bool) = INTERNAL_CALL, NamiMultiSigWallet.isConfirmed(uint256)(transactionId),CONDITION TMP_50,REF_31(NamiMultiSigWallet.Transaction) -> transactions[transactionId],REF_32(bool) -> REF_31.executed,REF_32(bool) (->transactions) := True(bool),REF_33(NamiMultiSigWallet.Transaction) -> transactions[transactionId],REF_34(address) -> REF_33.destination,REF_37(NamiMultiSigWallet.Transaction) -> transactions[transactionId],REF_38(uint256) -> REF_37.value,REF_39(NamiMultiSigWallet.Transaction) -> transactions[transactionId],REF_40(bytes) -> REF_39.data,TMP_52(bool) = LOW_LEVEL_CALL, dest:REF_34, function:call, arguments:['REF_40'] value:REF_38 ,CONDITION TMP_52,Emit Execution(transactionId),Emit ExecutionFailure(transactionId),REF_41(NamiMultiSigWallet.Transaction) -> transactions[transactionId],REF_42(bool) -> REF_41.executed,REF_42(bool) (->transactions) := False(bool),MODIFIER_CALL, NamiMultiSigWallet.notExecuted(uint256)(transactionId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
isConfirmed(transactionId)

IRs:
TMP_50(bool) = INTERNAL_CALL, NamiMultiSigWallet.isConfirmed(uint256)(transactionId)
CONDITION TMP_50""];
1->2[label=""True""];
1->8[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
transactions[transactionId].executed = true

IRs:
REF_31(NamiMultiSigWallet.Transaction) -> transactions[transactionId]
REF_32(bool) -> REF_31.executed
REF_32(bool) (->transactions) := True(bool)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data)

IRs:
REF_33(NamiMultiSigWallet.Transaction) -> transactions[transactionId]
REF_34(address) -> REF_33.destination
REF_37(NamiMultiSigWallet.Transaction) -> transactions[transactionId]
REF_38(uint256) -> REF_37.value
REF_39(NamiMultiSigWallet.Transaction) -> transactions[transactionId]
REF_40(bytes) -> REF_39.data
TMP_52(bool) = LOW_LEVEL_CALL, dest:REF_34, function:call, arguments:['REF_40'] value:REF_38 
CONDITION TMP_52""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Execution(transactionId)

IRs:
Emit Execution(transactionId)""];
4->7;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
ExecutionFailure(transactionId)

IRs:
Emit ExecutionFailure(transactionId)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
transactions[transactionId].executed = false

IRs:
REF_41(NamiMultiSigWallet.Transaction) -> transactions[transactionId]
REF_42(bool) -> REF_41.executed
REF_42(bool) (->transactions) := False(bool)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: END_IF 8
""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, NamiMultiSigWallet.notExecuted(uint256)(transactionId)""];
9->1;
}
",0,0,1,0,notExecuted(transactionId);isConfirmed(transactionId);transactions[transactionId].executed = true;;transactions[transactionId].destination.call.value(transactions[transactionId].value)(transactions[transactionId].data);Execution(transactionId);ExecutionFailure(transactionId);;transactions[transactionId].executed = false
./0x728781e75735dc0962df3a51d7ef47e798a7107e_ext.sol,WolkTGE.refund,269,279,"REF_93(uint256) -> contribution[msg.sender],TMP_250(bool) = REF_93 > 0,TMP_251 = UnaryType.BANG allSaleCompleted ,TMP_252(bool) = TMP_250 && TMP_251,TMP_253(bool) = totalTokens < tokenGenerationMin,TMP_254(bool) = TMP_252 && TMP_253,TMP_255(bool) = block.number > end_block,TMP_256(bool) = TMP_254 && TMP_255,TMP_257(None) = SOLIDITY_CALL require(bool)(TMP_256),REF_94(uint256) -> balances[msg.sender],tokenBalance(uint256) := REF_94(uint256),REF_95(uint256) -> contribution[msg.sender],refundBalance(uint256) := REF_95(uint256),REF_96(uint256) -> balances[msg.sender],REF_96(uint256) (->balances) := 0(uint256),REF_97(uint256) -> contribution[msg.sender],REF_97(uint256) (->contribution) := 0(uint256),TMP_258(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(totalTokens,tokenBalance),totalTokens(uint256) := TMP_258(uint256),Emit WolkDestroyed(msg.sender,tokenBalance),Emit LogRefund(msg.sender,refundBalance),Transfer dest:msg.sender value:refundBalance","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((contribution[msg.sender] > 0) && (! allSaleCompleted) && (totalTokens < tokenGenerationMin) && (block.number > end_block))

IRs:
REF_93(uint256) -> contribution[msg.sender]
TMP_250(bool) = REF_93 > 0
TMP_251 = UnaryType.BANG allSaleCompleted 
TMP_252(bool) = TMP_250 && TMP_251
TMP_253(bool) = totalTokens < tokenGenerationMin
TMP_254(bool) = TMP_252 && TMP_253
TMP_255(bool) = block.number > end_block
TMP_256(bool) = TMP_254 && TMP_255
TMP_257(None) = SOLIDITY_CALL require(bool)(TMP_256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
tokenBalance = balances[msg.sender]

IRs:
REF_94(uint256) -> balances[msg.sender]
tokenBalance(uint256) := REF_94(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
refundBalance = contribution[msg.sender]

IRs:
REF_95(uint256) -> contribution[msg.sender]
refundBalance(uint256) := REF_95(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[msg.sender] = 0

IRs:
REF_96(uint256) -> balances[msg.sender]
REF_96(uint256) (->balances) := 0(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
contribution[msg.sender] = 0

IRs:
REF_97(uint256) -> contribution[msg.sender]
REF_97(uint256) (->contribution) := 0(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
totalTokens = safeSub(totalTokens,tokenBalance)

IRs:
TMP_258(uint256) = INTERNAL_CALL, SafeMath.safeSub(uint256,uint256)(totalTokens,tokenBalance)
totalTokens(uint256) := TMP_258(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
WolkDestroyed(msg.sender,tokenBalance)

IRs:
Emit WolkDestroyed(msg.sender,tokenBalance)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
LogRefund(msg.sender,refundBalance)

IRs:
Emit LogRefund(msg.sender,refundBalance)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
msg.sender.transfer(refundBalance)

IRs:
Transfer dest:msg.sender value:refundBalance""];
}
",0,0,1,0,"require(bool)((contribution[msg.sender] > 0) && (! allSaleCompleted) && (totalTokens < tokenGenerationMin) && (block.number > end_block));tokenBalance = balances[msg.sender];refundBalance = contribution[msg.sender];balances[msg.sender] = 0;contribution[msg.sender] = 0;totalTokens = safeSub(totalTokens,tokenBalance);WolkDestroyed(msg.sender,tokenBalance);LogRefund(msg.sender,refundBalance);msg.sender.transfer(refundBalance)"
./0x67d9be79f2f13b7d3c9684d3782bc646f5ba6d63_ext.sol,MilinfinityToken.withdraw,300,303,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, MilinfinityToken.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MilinfinityToken.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x9214ec02cb71cba0ada6896b8da260736a67ab10_ext.sol,MiniMeToken.claimTokens,535,545,"TMP_130(bool) = _token == 0,CONDITION TMP_130,REF_58(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:controller value:REF_58,TMP_132 = CONVERT _token to MiniMeToken,token(MiniMeToken) := TMP_132(MiniMeToken),TMP_133(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_133(uint256),TMP_134(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  ,Emit ClaimedTokens(_token,controller,balance),MODIFIER_CALL, Controlled.onlyController()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_130(bool) = _token == 0
CONDITION TMP_130""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_58(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_58""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
token = MiniMeToken(_token)

IRs:
TMP_132 = CONVERT _token to MiniMeToken
token(MiniMeToken) := TMP_132(MiniMeToken)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_133(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_133(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_134(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()""];
9->1;
}
",0,0,1,0,"onlyController();_token == 0x0;controller.transfer(this.balance);;;token = MiniMeToken(_token);balance = token.balanceOf(this);token.transfer(controller,balance);ClaimedTokens(_token,controller,balance)"
./0xf4c3a48f27666ef8bedab8d73c0117e1aeaf1ba0_ext.sol,ItemMarket.Payout,173,187,"REF_5(ItemMarket.Item) -> Items[id],UsedItem(ItemMarket.Item) := REF_5(ItemMarket.Item),REF_6(uint256) -> UsedItem.amount,Paid(uint256) := REF_6(uint256),REF_7(uint256) -> UsedItem.amount,REF_7(uint256) (->UsedItem) := 0(uint256),REF_8(address) -> UsedItem.owner,Transfer dest:REF_8 value:Paid,REF_10(address) -> UsedItem.owner,TMP_73 = CONVERT 0 to address,REF_10(address) (->UsedItem) := TMP_73(address),REF_11(uint256) -> UsedItem.price,REF_12(uint256) -> UsedItem.minPrice,REF_11(uint256) (->UsedItem) := REF_12(uint256),REF_13(uint256) -> UsedItem.timestamp,REF_13(uint256) (->UsedItem) := 0(uint256),Emit ItemWon(id)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
UsedItem = Items[id]

IRs:
REF_5(ItemMarket.Item) -> Items[id]
UsedItem(ItemMarket.Item) := REF_5(ItemMarket.Item)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
Paid = UsedItem.amount

IRs:
REF_6(uint256) -> UsedItem.amount
Paid(uint256) := REF_6(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
UsedItem.amount = 0

IRs:
REF_7(uint256) -> UsedItem.amount
REF_7(uint256) (->UsedItem) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
UsedItem.owner.transfer(Paid)

IRs:
REF_8(address) -> UsedItem.owner
Transfer dest:REF_8 value:Paid""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
UsedItem.owner = address(0)

IRs:
REF_10(address) -> UsedItem.owner
TMP_73 = CONVERT 0 to address
REF_10(address) (->UsedItem) := TMP_73(address)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
UsedItem.price = UsedItem.minPrice

IRs:
REF_11(uint256) -> UsedItem.price
REF_12(uint256) -> UsedItem.minPrice
REF_11(uint256) (->UsedItem) := REF_12(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
UsedItem.timestamp = 0

IRs:
REF_13(uint256) -> UsedItem.timestamp
REF_13(uint256) (->UsedItem) := 0(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ItemWon(id)

IRs:
Emit ItemWon(id)""];
}
",0,0,1,0,UsedItem = Items[id];Paid = UsedItem.amount;UsedItem.amount = 0;UsedItem.owner.transfer(Paid);UsedItem.owner = address(0);UsedItem.price = UsedItem.minPrice;UsedItem.timestamp = 0;ItemWon(id)
./0x217aff4ee5bc1dfcabd8d5c3a36e0b430b02ab9d_ext.sol,ETher_game.Stop,28,30,"REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3,MODIFIER_CALL, ETher_game.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, ETher_game.isAdmin()()""];
2->1;
}
",0,0,1,0,isAdmin();msg.sender.transfer(this.balance)
./0xa44fb3aa5c8465512b806145a8f9b60e74f3f851_ext.sol,PITSTOP.withdraw,294,297,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, PITSTOP.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, PITSTOP.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x55914aad05640d89448a7803a03ed0eabcbc6a22_ext.sol,EthereumCrystal.withdraw,300,303,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, EthereumCrystal.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, EthereumCrystal.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0xf5587929c51017cfa8d0ead672fcc6b39f1496b0_ext.sol,RippleCredit.getTokens,182,245,"tokens(uint256) := 0(uint256),bonus(uint256) := 0(uint256),countbonus(uint256) := 0(uint256),TMP_45(uint256) = 5000000000000000000 / 100,bonusCond1(uint256) := TMP_45(uint256),TMP_46(uint256) = 1000000000000000000 / 10,bonusCond2(uint256) := TMP_46(uint256),TMP_47(uint256) = 5000000000000000000 / 10,bonusCond3(uint256) := TMP_47(uint256),bonusCond4(uint256) := 1000000000000000000(uint256),TMP_48(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_49(uint256) = TMP_48 / 1000000000000000000,tokens(uint256) := TMP_49(uint256),investor(address) := msg.sender(address),TMP_50(bool) = msg.value >= requestMinimum,TMP_51(bool) = now < deadline,TMP_52(bool) = TMP_50 && TMP_51,TMP_53(bool) = now < round1,TMP_54(bool) = TMP_52 && TMP_53,TMP_55(bool) = now < round2,TMP_56(bool) = TMP_54 && TMP_55,CONDITION TMP_56,TMP_57(bool) = msg.value >= bonusCond1,TMP_58(bool) = msg.value < bonusCond2,TMP_59(bool) = TMP_57 && TMP_58,CONDITION TMP_59,TMP_60(uint256) = tokens * 10,TMP_61(uint256) = TMP_60 / 100,countbonus(uint256) := TMP_61(uint256),TMP_62(bool) = msg.value >= bonusCond2,TMP_63(bool) = msg.value < bonusCond3,TMP_64(bool) = TMP_62 && TMP_63,CONDITION TMP_64,TMP_65(uint256) = tokens * 20,TMP_66(uint256) = TMP_65 / 100,countbonus(uint256) := TMP_66(uint256),TMP_67(bool) = msg.value >= bonusCond3,TMP_68(bool) = msg.value < bonusCond4,TMP_69(bool) = TMP_67 && TMP_68,CONDITION TMP_69,TMP_70(uint256) = tokens * 35,TMP_71(uint256) = TMP_70 / 100,countbonus(uint256) := TMP_71(uint256),TMP_72(bool) = msg.value >= bonusCond4,CONDITION TMP_72,TMP_73(uint256) = tokens * 50,TMP_74(uint256) = TMP_73 / 100,countbonus(uint256) := TMP_74(uint256),TMP_75(bool) = msg.value >= requestMinimum,TMP_76(bool) = now < deadline,TMP_77(bool) = TMP_75 && TMP_76,TMP_78(bool) = now > round1,TMP_79(bool) = TMP_77 && TMP_78,TMP_80(bool) = now < round2,TMP_81(bool) = TMP_79 && TMP_80,CONDITION TMP_81,TMP_82(bool) = msg.value >= bonusCond2,TMP_83(bool) = msg.value < bonusCond3,TMP_84(bool) = TMP_82 && TMP_83,CONDITION TMP_84,TMP_85(uint256) = tokens * 2,TMP_86(uint256) = TMP_85 / 100,countbonus(uint256) := TMP_86(uint256),TMP_87(bool) = msg.value >= bonusCond3,CONDITION TMP_87,TMP_88(uint256) = tokens * 3,TMP_89(uint256) = TMP_88 / 100,countbonus(uint256) := TMP_89(uint256),countbonus(uint256) := 0(uint256),TMP_90(uint256) = tokens + countbonus,bonus(uint256) := TMP_90(uint256),TMP_91(bool) = tokens == 0,CONDITION TMP_91,valdrop(uint256) := 100000000(uint256),REF_12(bool) -> Claimed[investor],TMP_92(bool) = REF_12 == False,TMP_93(bool) = progress0drop <= target0drop,TMP_94(bool) = TMP_92 && TMP_93,CONDITION TMP_94,TMP_95(bool) = INTERNAL_CALL, RippleCredit.distr(address,uint256)(investor,valdrop),REF_13(bool) -> Claimed[investor],REF_13(bool) (->Claimed) := True(bool),TMP_96(uint256) := progress0drop(uint256),progress0drop(uint256) = progress0drop + 1,TMP_97(bool) = msg.value >= requestMinimum,TMP_98(None) = SOLIDITY_CALL require(bool)(TMP_97),TMP_99(bool) = tokens > 0,TMP_100(bool) = msg.value >= requestMinimum,TMP_101(bool) = TMP_99 && TMP_100,CONDITION TMP_101,TMP_102(bool) = now >= deadline,TMP_103(bool) = now >= round1,TMP_104(bool) = TMP_102 && TMP_103,TMP_105(bool) = now < round2,TMP_106(bool) = TMP_104 && TMP_105,CONDITION TMP_106,TMP_107(bool) = INTERNAL_CALL, RippleCredit.distr(address,uint256)(investor,tokens),TMP_108(bool) = msg.value >= bonusCond1,CONDITION TMP_108,TMP_109(bool) = INTERNAL_CALL, RippleCredit.distr(address,uint256)(investor,bonus),TMP_110(bool) = INTERNAL_CALL, RippleCredit.distr(address,uint256)(investor,tokens),TMP_111(bool) = msg.value >= requestMinimum,TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111),TMP_113(bool) = totalDistributed >= totalSupply,CONDITION TMP_113,distributionFinished(bool) := True(bool),Transfer dest:multisig value:msg.value,MODIFIER_CALL, RippleCredit.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->57;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bonusCond1 = 5000000000000000000 / 100

IRs:
TMP_45(uint256) = 5000000000000000000 / 100
bonusCond1(uint256) := TMP_45(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bonusCond2 = 1000000000000000000 / 10

IRs:
TMP_46(uint256) = 1000000000000000000 / 10
bonusCond2(uint256) := TMP_46(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
bonusCond3 = 5000000000000000000 / 10

IRs:
TMP_47(uint256) = 5000000000000000000 / 10
bonusCond3(uint256) := TMP_47(uint256)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
bonusCond4 = 1000000000000000000

IRs:
bonusCond4(uint256) := 1000000000000000000(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_48(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_49(uint256) = TMP_48 / 1000000000000000000
tokens(uint256) := TMP_49(uint256)""];
8->9;
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now < round1 && now < round2

IRs:
TMP_50(bool) = msg.value >= requestMinimum
TMP_51(bool) = now < deadline
TMP_52(bool) = TMP_50 && TMP_51
TMP_53(bool) = now < round1
TMP_54(bool) = TMP_52 && TMP_53
TMP_55(bool) = now < round2
TMP_56(bool) = TMP_54 && TMP_55
CONDITION TMP_56""];
10->11[label=""True""];
10->23[label=""False""];
11[label=""Node Type: IF 11

EXPRESSION:
msg.value >= bonusCond1 && msg.value < bonusCond2

IRs:
TMP_57(bool) = msg.value >= bonusCond1
TMP_58(bool) = msg.value < bonusCond2
TMP_59(bool) = TMP_57 && TMP_58
CONDITION TMP_59""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
countbonus = tokens * 10 / 100

IRs:
TMP_60(uint256) = tokens * 10
TMP_61(uint256) = TMP_60 / 100
countbonus(uint256) := TMP_61(uint256)""];
12->22;
13[label=""Node Type: IF 13

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_62(bool) = msg.value >= bonusCond2
TMP_63(bool) = msg.value < bonusCond3
TMP_64(bool) = TMP_62 && TMP_63
CONDITION TMP_64""];
13->14[label=""True""];
13->15[label=""False""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
countbonus = tokens * 20 / 100

IRs:
TMP_65(uint256) = tokens * 20
TMP_66(uint256) = TMP_65 / 100
countbonus(uint256) := TMP_66(uint256)""];
14->21;
15[label=""Node Type: IF 15

EXPRESSION:
msg.value >= bonusCond3 && msg.value < bonusCond4

IRs:
TMP_67(bool) = msg.value >= bonusCond3
TMP_68(bool) = msg.value < bonusCond4
TMP_69(bool) = TMP_67 && TMP_68
CONDITION TMP_69""];
15->16[label=""True""];
15->17[label=""False""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
countbonus = tokens * 35 / 100

IRs:
TMP_70(uint256) = tokens * 35
TMP_71(uint256) = TMP_70 / 100
countbonus(uint256) := TMP_71(uint256)""];
16->20;
17[label=""Node Type: IF 17

EXPRESSION:
msg.value >= bonusCond4

IRs:
TMP_72(bool) = msg.value >= bonusCond4
CONDITION TMP_72""];
17->18[label=""True""];
17->19[label=""False""];
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
countbonus = tokens * 50 / 100

IRs:
TMP_73(uint256) = tokens * 50
TMP_74(uint256) = TMP_73 / 100
countbonus(uint256) := TMP_74(uint256)""];
18->19;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: END_IF 21
""];
21->22;
22[label=""Node Type: END_IF 22
""];
22->32;
23[label=""Node Type: IF 23

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now > round1 && now < round2

IRs:
TMP_75(bool) = msg.value >= requestMinimum
TMP_76(bool) = now < deadline
TMP_77(bool) = TMP_75 && TMP_76
TMP_78(bool) = now > round1
TMP_79(bool) = TMP_77 && TMP_78
TMP_80(bool) = now < round2
TMP_81(bool) = TMP_79 && TMP_80
CONDITION TMP_81""];
23->24[label=""True""];
23->30[label=""False""];
24[label=""Node Type: IF 24

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_82(bool) = msg.value >= bonusCond2
TMP_83(bool) = msg.value < bonusCond3
TMP_84(bool) = TMP_82 && TMP_83
CONDITION TMP_84""];
24->25[label=""True""];
24->26[label=""False""];
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
countbonus = tokens * 2 / 100

IRs:
TMP_85(uint256) = tokens * 2
TMP_86(uint256) = TMP_85 / 100
countbonus(uint256) := TMP_86(uint256)""];
25->29;
26[label=""Node Type: IF 26

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_87(bool) = msg.value >= bonusCond3
CONDITION TMP_87""];
26->27[label=""True""];
26->28[label=""False""];
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
countbonus = tokens * 3 / 100

IRs:
TMP_88(uint256) = tokens * 3
TMP_89(uint256) = TMP_88 / 100
countbonus(uint256) := TMP_89(uint256)""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: END_IF 29
""];
29->31;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
30->31;
31[label=""Node Type: END_IF 31
""];
31->32;
32[label=""Node Type: END_IF 32
""];
32->33;
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
bonus = tokens + countbonus

IRs:
TMP_90(uint256) = tokens + countbonus
bonus(uint256) := TMP_90(uint256)""];
33->34;
34[label=""Node Type: IF 34

EXPRESSION:
tokens == 0

IRs:
TMP_91(bool) = tokens == 0
CONDITION TMP_91""];
34->35[label=""True""];
34->42[label=""False""];
35[label=""Node Type: NEW VARIABLE 35

EXPRESSION:
valdrop = 1e8

IRs:
valdrop(uint256) := 100000000(uint256)""];
35->36;
36[label=""Node Type: IF 36

EXPRESSION:
Claimed[investor] == false && progress0drop <= target0drop

IRs:
REF_12(bool) -> Claimed[investor]
TMP_92(bool) = REF_12 == False
TMP_93(bool) = progress0drop <= target0drop
TMP_94(bool) = TMP_92 && TMP_93
CONDITION TMP_94""];
36->37[label=""True""];
36->40[label=""False""];
37[label=""Node Type: EXPRESSION 37

EXPRESSION:
distr(investor,valdrop)

IRs:
TMP_95(bool) = INTERNAL_CALL, RippleCredit.distr(address,uint256)(investor,valdrop)""];
37->38;
38[label=""Node Type: EXPRESSION 38

EXPRESSION:
Claimed[investor] = true

IRs:
REF_13(bool) -> Claimed[investor]
REF_13(bool) (->Claimed) := True(bool)""];
38->39;
39[label=""Node Type: EXPRESSION 39

EXPRESSION:
progress0drop ++

IRs:
TMP_96(uint256) := progress0drop(uint256)
progress0drop(uint256) = progress0drop + 1""];
39->41;
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_97(bool) = msg.value >= requestMinimum
TMP_98(None) = SOLIDITY_CALL require(bool)(TMP_97)""];
40->41;
41[label=""Node Type: END_IF 41
""];
41->52;
42[label=""Node Type: IF 42

EXPRESSION:
tokens > 0 && msg.value >= requestMinimum

IRs:
TMP_99(bool) = tokens > 0
TMP_100(bool) = msg.value >= requestMinimum
TMP_101(bool) = TMP_99 && TMP_100
CONDITION TMP_101""];
42->43[label=""True""];
42->50[label=""False""];
43[label=""Node Type: IF 43

EXPRESSION:
now >= deadline && now >= round1 && now < round2

IRs:
TMP_102(bool) = now >= deadline
TMP_103(bool) = now >= round1
TMP_104(bool) = TMP_102 && TMP_103
TMP_105(bool) = now < round2
TMP_106(bool) = TMP_104 && TMP_105
CONDITION TMP_106""];
43->44[label=""True""];
43->45[label=""False""];
44[label=""Node Type: EXPRESSION 44

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_107(bool) = INTERNAL_CALL, RippleCredit.distr(address,uint256)(investor,tokens)""];
44->49;
45[label=""Node Type: IF 45

EXPRESSION:
msg.value >= bonusCond1

IRs:
TMP_108(bool) = msg.value >= bonusCond1
CONDITION TMP_108""];
45->46[label=""True""];
45->47[label=""False""];
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
distr(investor,bonus)

IRs:
TMP_109(bool) = INTERNAL_CALL, RippleCredit.distr(address,uint256)(investor,bonus)""];
46->48;
47[label=""Node Type: EXPRESSION 47

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_110(bool) = INTERNAL_CALL, RippleCredit.distr(address,uint256)(investor,tokens)""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: END_IF 49
""];
49->51;
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_111(bool) = msg.value >= requestMinimum
TMP_112(None) = SOLIDITY_CALL require(bool)(TMP_111)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: END_IF 52
""];
52->53;
53[label=""Node Type: IF 53

EXPRESSION:
totalDistributed >= totalSupply

IRs:
TMP_113(bool) = totalDistributed >= totalSupply
CONDITION TMP_113""];
53->54[label=""True""];
53->55[label=""False""];
54[label=""Node Type: EXPRESSION 54

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)""];
54->55;
55[label=""Node Type: END_IF 55
""];
55->56;
56[label=""Node Type: EXPRESSION 56

EXPRESSION:
multisig.transfer(msg.value)

IRs:
Transfer dest:multisig value:msg.value""];
57[label=""Node Type: EXPRESSION 57

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, RippleCredit.canDistr()()""];
57->1;
}
",0,0,1,0,"canDistr();tokens = 0;bonus = 0;countbonus = 0;bonusCond1 = 5000000000000000000 / 100;bonusCond2 = 1000000000000000000 / 10;bonusCond3 = 5000000000000000000 / 10;bonusCond4 = 1000000000000000000;tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;investor = msg.sender;msg.value >= requestMinimum && now < deadline && now < round1 && now < round2;msg.value >= bonusCond1 && msg.value < bonusCond2;msg.value >= requestMinimum && now < deadline && now > round1 && now < round2;countbonus = tokens * 10 / 100;msg.value >= bonusCond2 && msg.value < bonusCond3;;countbonus = tokens * 20 / 100;msg.value >= bonusCond3 && msg.value < bonusCond4;;countbonus = tokens * 35 / 100;msg.value >= bonusCond4;;countbonus = tokens * 50 / 100;;;msg.value >= bonusCond2 && msg.value < bonusCond3;countbonus = 0;countbonus = tokens * 2 / 100;msg.value >= bonusCond3;;countbonus = tokens * 3 / 100;;;bonus = tokens + countbonus;tokens == 0;valdrop = 1e8;tokens > 0 && msg.value >= requestMinimum;Claimed[investor] == false && progress0drop <= target0drop;distr(investor,valdrop);require(bool)(msg.value >= requestMinimum);Claimed[investor] = true;progress0drop ++;;;now >= deadline && now >= round1 && now < round2;require(bool)(msg.value >= requestMinimum);distr(investor,tokens);msg.value >= bonusCond1;;distr(investor,bonus);distr(investor,tokens);;;totalDistributed >= totalSupply;distributionFinished = true;;multisig.transfer(msg.value)"
./0xaab606817809841e8b1168be8779eeaf6744ef64_ext.sol,DividendToken.requestUnclaimed,641,648,"TMP_240(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['dividendEndTime', 'claimTimeout'] ,TMP_241(bool) = block.timestamp >= TMP_240,TMP_242(None) = SOLIDITY_CALL require(bool)(TMP_241),TMP_243 = CONVERT this to address,TMP_244(uint256) = SOLIDITY_CALL balance(address)(TMP_243),Transfer dest:msg.sender value:TMP_244,TMP_246 = CONVERT this to address,TMP_247(uint256) = SOLIDITY_CALL balance(address)(TMP_246),Emit Reclaimed(TMP_247,dividendEndTime,block.timestamp),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(block.timestamp >= dividendEndTime.sub(claimTimeout))

IRs:
TMP_240(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['dividendEndTime', 'claimTimeout'] 
TMP_241(bool) = block.timestamp >= TMP_240
TMP_242(None) = SOLIDITY_CALL require(bool)(TMP_241)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_243 = CONVERT this to address
TMP_244(uint256) = SOLIDITY_CALL balance(address)(TMP_243)
Transfer dest:msg.sender value:TMP_244""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Reclaimed(address(this).balance,dividendEndTime,block.timestamp)

IRs:
TMP_246 = CONVERT this to address
TMP_247(uint256) = SOLIDITY_CALL balance(address)(TMP_246)
Emit Reclaimed(TMP_247,dividendEndTime,block.timestamp)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->1;
}
",0,0,1,0,"onlyOwner();require(bool)(block.timestamp >= dividendEndTime.sub(claimTimeout));msg.sender.transfer(address(this).balance);Reclaimed(address(this).balance,dividendEndTime,block.timestamp)"
./0xf0344800bd3ffa687e4d780357961b28995a5f46_ext.sol,QUIZ_GAME.Play,5,14,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x692b856117039d424cfac420f93ab2451f3c9eb5_ext.sol,RunAway.withdraw,372,385,"_customerAddress(address) := msg.sender(address),REF_68(uint256) -> income_[_customerAddress],myIncome(uint256) := REF_68(uint256),REF_69(uint256) -> income_[_customerAddress],REF_69(uint256) (->income_) := 0(uint256),Transfer dest:_customerAddress value:myIncome,Emit onWithdraw(_customerAddress,myIncome),MODIFIER_CALL, RunAway.isActivated()(),MODIFIER_CALL, RunAway.onlyHuman()(),MODIFIER_CALL, RunAway.checkRoundStatus()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
myIncome = income_[_customerAddress]

IRs:
REF_68(uint256) -> income_[_customerAddress]
myIncome(uint256) := REF_68(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
income_[_customerAddress] = 0

IRs:
REF_69(uint256) -> income_[_customerAddress]
REF_69(uint256) (->income_) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
_customerAddress.transfer(myIncome)

IRs:
Transfer dest:_customerAddress value:myIncome""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onWithdraw(_customerAddress,myIncome)

IRs:
Emit onWithdraw(_customerAddress,myIncome)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
isActivated()

IRs:
MODIFIER_CALL, RunAway.isActivated()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyHuman()

IRs:
MODIFIER_CALL, RunAway.onlyHuman()()""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
checkRoundStatus()

IRs:
MODIFIER_CALL, RunAway.checkRoundStatus()()""];
8->1;
}
",0,0,1,0,"isActivated();_customerAddress = msg.sender;myIncome = income_[_customerAddress];income_[_customerAddress] = 0;_customerAddress.transfer(myIncome);onWithdraw(_customerAddress,myIncome);onlyHuman();checkRoundStatus()"
./0xd74ac22ffc06d6f96cb41eef4e0fdb836889c3ff_ext.sol,AHF_PreSale.fallback,79,91,"TMP_17(bool) = tokenPrice > 0,TMP_18(bool) = fundingEnabled && TMP_17,TMP_19(bool) = msg.value >= tokenPrice,TMP_20(bool) = TMP_18 && TMP_19,TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20),totalCollected(uint256) = totalCollected + msg.value,Transfer dest:vaultAddress value:msg.value,TMP_23(uint256) = 10 ** 18,TMP_24(uint256) = msg.value * TMP_23,TMP_25(uint256) = TMP_24 / tokenPrice,tokens(uint256) := TMP_25(uint256),TMP_26(bool) = HIGH_LEVEL_CALL, dest:tokenContract(ERC20Interface), function:transfer, arguments:['msg.sender', 'tokens']  ,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(fundingEnabled && (tokenPrice > 0) && (msg.value >= tokenPrice))

IRs:
TMP_17(bool) = tokenPrice > 0
TMP_18(bool) = fundingEnabled && TMP_17
TMP_19(bool) = msg.value >= tokenPrice
TMP_20(bool) = TMP_18 && TMP_19
TMP_21(None) = SOLIDITY_CALL require(bool)(TMP_20)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
totalCollected += msg.value

IRs:
totalCollected(uint256) = totalCollected + msg.value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
vaultAddress.transfer(msg.value)

IRs:
Transfer dest:vaultAddress value:msg.value""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
tokens = (msg.value * 10 ** 18) / tokenPrice

IRs:
TMP_23(uint256) = 10 ** 18
TMP_24(uint256) = msg.value * TMP_23
TMP_25(uint256) = TMP_24 / tokenPrice
tokens(uint256) := TMP_25(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(tokenContract.transfer(msg.sender,tokens))

IRs:
TMP_26(bool) = HIGH_LEVEL_CALL, dest:tokenContract(ERC20Interface), function:transfer, arguments:['msg.sender', 'tokens']  
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
5->6;
6[label=""Node Type: RETURN 6
""];
}
",0,0,1,0,"require(bool)(fundingEnabled && (tokenPrice > 0) && (msg.value >= tokenPrice));totalCollected += msg.value;vaultAddress.transfer(msg.value);tokens = (msg.value * 10 ** 18) / tokenPrice;require(bool)(tokenContract.transfer(msg.sender,tokens));"
./0xed2725cdfc48a24aa71d9b9621d431db0705a55a_ext.sol,MiniMeToken.claimTokens,602,612,"TMP_150(bool) = _token == 0,CONDITION TMP_150,REF_58(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:controller value:REF_58,TMP_152 = CONVERT _token to MiniMeToken,token(MiniMeToken) := TMP_152(MiniMeToken),TMP_153(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_153(uint256),TMP_154(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  ,Emit ClaimedTokens(_token,controller,balance),MODIFIER_CALL, Controlled.onlyController()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_150(bool) = _token == 0
CONDITION TMP_150""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_58(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_58""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
token = MiniMeToken(_token)

IRs:
TMP_152 = CONVERT _token to MiniMeToken
token(MiniMeToken) := TMP_152(MiniMeToken)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_153(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_153(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_154(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()""];
9->1;
}
",0,0,1,0,"onlyController();_token == 0x0;controller.transfer(this.balance);;;token = MiniMeToken(_token);balance = token.balanceOf(this);token.transfer(controller,balance);ClaimedTokens(_token,controller,balance)"
./0x21ae174c592cbb476819344a895d0e9219f5cc79_ext.sol,BO3KMain.withdraw,440,477,"REF_269(mapping(address => BO3Kdatasets.Player)) -> player[_roundID],REF_270(BO3Kdatasets.Player) -> REF_269[msg.sender],REF_271(bool) -> REF_270.hasRegistered,TMP_159(bool) = REF_271 == True,TMP_160(None) = SOLIDITY_CALL require(bool,string)(TMP_159,Not Registered Before),REF_272(mapping(address => BO3Kdatasets.Player)) -> player[_roundID],REF_273(BO3Kdatasets.Player) -> REF_272[msg.sender],REF_274(uint256) -> REF_273.discountRevenue,_discountRevenue(uint256) := REF_274(uint256),REF_275(mapping(address => BO3Kdatasets.Player)) -> player[_roundID],REF_276(BO3Kdatasets.Player) -> REF_275[msg.sender],REF_277(uint256) -> REF_276.refferedRevenue,_refferedRevenue(uint256) := REF_277(uint256),REF_278(mapping(address => BO3Kdatasets.Player)) -> player[_roundID],REF_279(BO3Kdatasets.Player) -> REF_278[msg.sender],REF_280(uint256) -> REF_279.win,_winRevenue(uint256) := REF_280(uint256),TMP_161(uint256) = INTERNAL_CALL, BO3KMain.getFlagRevenue(uint256)(_roundID),_flagRevenue(uint256) := TMP_161(uint256),TMP_162(bool) = INTERNAL_CALL, BO3KMain.isLegalTime(uint256)(now),REF_281(BO3Kdatasets.Round) -> round[_roundID],REF_282(bool) -> REF_281.ended,TMP_163 = UnaryType.BANG REF_282 ,TMP_164(bool) = TMP_162 && TMP_163,CONDITION TMP_164,TMP_165(uint256) = _discountRevenue + _refferedRevenue,TMP_166(uint256) = TMP_165 + _winRevenue,TMP_167(uint256) = TMP_166 + _flagRevenue,Transfer dest:msg.sender value:TMP_167,TMP_169(uint256) = INTERNAL_CALL, BO3KMain.getTeamBonus(uint256)(_roundID),TMP_170(uint256) = TMP_169 + _discountRevenue,TMP_171(uint256) = TMP_170 + _refferedRevenue,TMP_172(uint256) = TMP_171 + _winRevenue,TMP_173(uint256) = TMP_172 + _flagRevenue,Transfer dest:msg.sender value:TMP_173,REF_285(mapping(address => BO3Kdatasets.Player)) -> player[_roundID],REF_286(BO3Kdatasets.Player) -> REF_285[msg.sender],REF_287(uint256) -> REF_286.discountRevenue,REF_287(uint256) (->player) := 0(uint256),REF_288(mapping(address => BO3Kdatasets.Player)) -> player[_roundID],REF_289(BO3Kdatasets.Player) -> REF_288[msg.sender],REF_290(uint256) -> REF_289.refferedRevenue,REF_290(uint256) (->player) := 0(uint256),REF_291(mapping(address => BO3Kdatasets.Player)) -> player[_roundID],REF_292(BO3Kdatasets.Player) -> REF_291[msg.sender],REF_293(uint256) -> REF_292.win,REF_293(uint256) (->player) := 0(uint256),REF_294(mapping(address => BO3Kdatasets.Player)) -> player[_roundID],REF_295(BO3Kdatasets.Player) -> REF_294[msg.sender],REF_296(uint256) -> REF_295.payMask,REF_298(mapping(address => BO3Kdatasets.Player)) -> player[_roundID],REF_299(BO3Kdatasets.Player) -> REF_298[msg.sender],REF_300(uint256) -> REF_299.payMask,TMP_175(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_flagRevenue', 'REF_300'] ,REF_296(uint256) (->player) := TMP_175(uint256),REF_301(mapping(address => BO3Kdatasets.Player)) -> player[_roundID],REF_302(BO3Kdatasets.Player) -> REF_301[msg.sender],REF_303(bool) -> REF_302.isWithdrawed,REF_303(bool) (->player) := True(bool),Emit onWithdraw(msg.sender,_discountRevenue,_refferedRevenue,_winRevenue,_flagRevenue),MODIFIER_CALL, BO3KMain.isActivated()(),MODIFIER_CALL, BO3KMain.isHuman()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->16;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(player[_roundID][msg.sender].hasRegistered == true,Not Registered Before)

IRs:
REF_269(mapping(address => BO3Kdatasets.Player)) -> player[_roundID]
REF_270(BO3Kdatasets.Player) -> REF_269[msg.sender]
REF_271(bool) -> REF_270.hasRegistered
TMP_159(bool) = REF_271 == True
TMP_160(None) = SOLIDITY_CALL require(bool,string)(TMP_159,Not Registered Before)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
_discountRevenue = player[_roundID][msg.sender].discountRevenue

IRs:
REF_272(mapping(address => BO3Kdatasets.Player)) -> player[_roundID]
REF_273(BO3Kdatasets.Player) -> REF_272[msg.sender]
REF_274(uint256) -> REF_273.discountRevenue
_discountRevenue(uint256) := REF_274(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
_refferedRevenue = player[_roundID][msg.sender].refferedRevenue

IRs:
REF_275(mapping(address => BO3Kdatasets.Player)) -> player[_roundID]
REF_276(BO3Kdatasets.Player) -> REF_275[msg.sender]
REF_277(uint256) -> REF_276.refferedRevenue
_refferedRevenue(uint256) := REF_277(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
_winRevenue = player[_roundID][msg.sender].win

IRs:
REF_278(mapping(address => BO3Kdatasets.Player)) -> player[_roundID]
REF_279(BO3Kdatasets.Player) -> REF_278[msg.sender]
REF_280(uint256) -> REF_279.win
_winRevenue(uint256) := REF_280(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
_flagRevenue = getFlagRevenue(_roundID)

IRs:
TMP_161(uint256) = INTERNAL_CALL, BO3KMain.getFlagRevenue(uint256)(_roundID)
_flagRevenue(uint256) := TMP_161(uint256)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
isLegalTime(now) && ! round[_roundID].ended

IRs:
TMP_162(bool) = INTERNAL_CALL, BO3KMain.isLegalTime(uint256)(now)
REF_281(BO3Kdatasets.Round) -> round[_roundID]
REF_282(bool) -> REF_281.ended
TMP_163 = UnaryType.BANG REF_282 
TMP_164(bool) = TMP_162 && TMP_163
CONDITION TMP_164""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
msg.sender.transfer(_discountRevenue + _refferedRevenue + _winRevenue + _flagRevenue)

IRs:
TMP_165(uint256) = _discountRevenue + _refferedRevenue
TMP_166(uint256) = TMP_165 + _winRevenue
TMP_167(uint256) = TMP_166 + _flagRevenue
Transfer dest:msg.sender value:TMP_167""];
7->9;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
msg.sender.transfer(getTeamBonus(_roundID) + _discountRevenue + _refferedRevenue + _winRevenue + _flagRevenue)

IRs:
TMP_169(uint256) = INTERNAL_CALL, BO3KMain.getTeamBonus(uint256)(_roundID)
TMP_170(uint256) = TMP_169 + _discountRevenue
TMP_171(uint256) = TMP_170 + _refferedRevenue
TMP_172(uint256) = TMP_171 + _winRevenue
TMP_173(uint256) = TMP_172 + _flagRevenue
Transfer dest:msg.sender value:TMP_173""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
player[_roundID][msg.sender].discountRevenue = 0

IRs:
REF_285(mapping(address => BO3Kdatasets.Player)) -> player[_roundID]
REF_286(BO3Kdatasets.Player) -> REF_285[msg.sender]
REF_287(uint256) -> REF_286.discountRevenue
REF_287(uint256) (->player) := 0(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
player[_roundID][msg.sender].refferedRevenue = 0

IRs:
REF_288(mapping(address => BO3Kdatasets.Player)) -> player[_roundID]
REF_289(BO3Kdatasets.Player) -> REF_288[msg.sender]
REF_290(uint256) -> REF_289.refferedRevenue
REF_290(uint256) (->player) := 0(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
player[_roundID][msg.sender].win = 0

IRs:
REF_291(mapping(address => BO3Kdatasets.Player)) -> player[_roundID]
REF_292(BO3Kdatasets.Player) -> REF_291[msg.sender]
REF_293(uint256) -> REF_292.win
REF_293(uint256) (->player) := 0(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
player[_roundID][msg.sender].payMask = _flagRevenue.add(player[_roundID][msg.sender].payMask)

IRs:
REF_294(mapping(address => BO3Kdatasets.Player)) -> player[_roundID]
REF_295(BO3Kdatasets.Player) -> REF_294[msg.sender]
REF_296(uint256) -> REF_295.payMask
REF_298(mapping(address => BO3Kdatasets.Player)) -> player[_roundID]
REF_299(BO3Kdatasets.Player) -> REF_298[msg.sender]
REF_300(uint256) -> REF_299.payMask
TMP_175(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['_flagRevenue', 'REF_300'] 
REF_296(uint256) (->player) := TMP_175(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
player[_roundID][msg.sender].isWithdrawed = true

IRs:
REF_301(mapping(address => BO3Kdatasets.Player)) -> player[_roundID]
REF_302(BO3Kdatasets.Player) -> REF_301[msg.sender]
REF_303(bool) -> REF_302.isWithdrawed
REF_303(bool) (->player) := True(bool)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
BO3Kevents.onWithdraw(msg.sender,_discountRevenue,_refferedRevenue,_winRevenue,_flagRevenue)

IRs:
Emit onWithdraw(msg.sender,_discountRevenue,_refferedRevenue,_winRevenue,_flagRevenue)""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
isActivated()

IRs:
MODIFIER_CALL, BO3KMain.isActivated()()""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
isHuman()

IRs:
MODIFIER_CALL, BO3KMain.isHuman()()""];
17->1;
}
",0,0,1,0,"isActivated();require(bool,string)(player[_roundID][msg.sender].hasRegistered == true,Not Registered Before);_discountRevenue = player[_roundID][msg.sender].discountRevenue;_refferedRevenue = player[_roundID][msg.sender].refferedRevenue;_winRevenue = player[_roundID][msg.sender].win;_flagRevenue = getFlagRevenue(_roundID);isLegalTime(now) && ! round[_roundID].ended;msg.sender.transfer(_discountRevenue + _refferedRevenue + _winRevenue + _flagRevenue);msg.sender.transfer(getTeamBonus(_roundID) + _discountRevenue + _refferedRevenue + _winRevenue + _flagRevenue);;player[_roundID][msg.sender].discountRevenue = 0;player[_roundID][msg.sender].refferedRevenue = 0;player[_roundID][msg.sender].win = 0;player[_roundID][msg.sender].payMask = _flagRevenue.add(player[_roundID][msg.sender].payMask);player[_roundID][msg.sender].isWithdrawed = true;BO3Kevents.onWithdraw(msg.sender,_discountRevenue,_refferedRevenue,_winRevenue,_flagRevenue);isHuman()"
./0x845bfe096fbe3eabe473edc3953d8af1b19bbbc7_ext.sol,IndTokenPayment.withdrawEther,239,244,"TMP_40 = CONVERT this to address,TMP_41(uint256) = SOLIDITY_CALL balance(address)(TMP_40),TMP_42(bool) = TMP_41 > 0,CONDITION TMP_42,TMP_43 = CONVERT this to address,TMP_44(uint256) = SOLIDITY_CALL balance(address)(TMP_43),Transfer dest:destinationWallet value:TMP_44,RETURN True,MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, ReentrancyGuard.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
address(this).balance > 0

IRs:
TMP_40 = CONVERT this to address
TMP_41(uint256) = SOLIDITY_CALL balance(address)(TMP_40)
TMP_42(bool) = TMP_41 > 0
CONDITION TMP_42""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
destinationWallet.transfer(address(this).balance)

IRs:
TMP_43 = CONVERT this to address
TMP_44(uint256) = SOLIDITY_CALL balance(address)(TMP_43)
Transfer dest:destinationWallet value:TMP_44""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, ReentrancyGuard.nonReentrant()()""];
6->1;
}
",0,0,1,0,onlyOwner();address(this).balance > 0;destinationWallet.transfer(address(this).balance);;true;nonReentrant()
./0xdb1c55f6926e7d847ddf8678905ad871a68199d2_ext.sol,FreeEth.withdraw,19,25,"TMP_3(bool) = msg.sender == 445595336767664093905509552867253539640539564207,CONDITION TMP_3,Owner(address) := 445595336767664093905509552867253539640539564207(address),TMP_4(bool) = msg.sender == Owner,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_5(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:Owner value:REF_5","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == 0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af

IRs:
TMP_3(bool) = msg.sender == 445595336767664093905509552867253539640539564207
CONDITION TMP_3""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Owner = 0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af

IRs:
Owner(address) := 445595336767664093905509552867253539640539564207(address)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(msg.sender == Owner)

IRs:
TMP_4(bool) = msg.sender == Owner
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Owner.transfer(this.balance)

IRs:
REF_5(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:Owner value:REF_5""];
}
",0,0,1,0,msg.sender == 0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af;Owner = 0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af;;require(bool)(msg.sender == Owner);Owner.transfer(this.balance)
./0x38e308c4ac50fd6c31c5f53d7b25f25116d80a3a_ext.sol,ScriniumPresale.changeOwner,47,55,"TMP_3(bool) = msg.value >= howManyEtherInWeiToBecomeOwner,CONDITION TMP_3,Transfer dest:owner value:msg.value,REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:owner value:REF_3,owner(address) := _newowner(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value >= howManyEtherInWeiToBecomeOwner

IRs:
TMP_3(bool) = msg.value >= howManyEtherInWeiToBecomeOwner
CONDITION TMP_3""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(msg.value)

IRs:
Transfer dest:owner value:msg.value""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:owner value:REF_3""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
owner = _newowner

IRs:
owner(address) := _newowner(address)""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,0,1,0,msg.value >= howManyEtherInWeiToBecomeOwner;owner.transfer(msg.value);;owner.transfer(this.balance);owner = _newowner
./0x5c15d6ac5db1a093ad57c383ffe11bde48b8241e_ext.sol,PerfectCoinControl.killMe,117,119,"TMP_88(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_88(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0x5aeb706c39a76c31fa89bf726de1a6f7d6bc1a51_ext.sol,EtherColor._payout,394,400,"TMP_110 = CONVERT 0 to address,TMP_111(bool) = _to == TMP_110,CONDITION TMP_111,REF_58(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:ceoAddress value:REF_58,REF_60(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:_to value:REF_60","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_to == address(0)

IRs:
TMP_110 = CONVERT 0 to address
TMP_111(bool) = _to == TMP_110
CONDITION TMP_111""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ceoAddress.transfer(this.balance)

IRs:
REF_58(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:ceoAddress value:REF_58""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_to.transfer(this.balance)

IRs:
REF_60(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:_to value:REF_60""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,_to == address(0);ceoAddress.transfer(this.balance);_to.transfer(this.balance);
./0x5b5a39a9a08725aca0f699e5cc9f6e81f95ff6d8_ext.sol,SPACEDICE.collect,118,121,"TMP_69 = CONVERT this to address,TMP_70(uint256) = SOLIDITY_CALL balance(address)(TMP_69),TMP_71(bool) = TMP_70 > _amount,TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71),Transfer dest:owner value:_amount,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(address(this).balance > _amount)

IRs:
TMP_69 = CONVERT this to address
TMP_70(uint256) = SOLIDITY_CALL balance(address)(TMP_69)
TMP_71(bool) = TMP_70 > _amount
TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(_amount)

IRs:
Transfer dest:owner value:_amount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();require(bool)(address(this).balance > _amount);owner.transfer(_amount)
./0x6c1bcb34142bffd35f57db626e0ac427af616a4d_ext.sol,EnjinBuyer.purchase_tokens,97,106,"TMP_58(bool) = msg.sender == developer,TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58),REF_28(uint256) = SOLIDITY_CALL balance(address)(this),TMP_60(bool) = REF_28 < eth_minimum,CONDITION TMP_60,CONDITION kill_switch,TMP_61(bool) = sale != 0,TMP_62(None) = SOLIDITY_CALL require(bool)(TMP_61),bought_tokens(bool) := True(bool),REF_29(uint256) = SOLIDITY_CALL balance(address)(this),contract_eth_value(uint256) := REF_29([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188C3280100>]),TMP_64(bool) = LOW_LEVEL_CALL, dest:sale, function:call, arguments:[] value:contract_eth_value ,TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64),REF_32(uint256) = SOLIDITY_CALL balance(address)(this),TMP_66(bool) = REF_32 == 0,TMP_67(None) = SOLIDITY_CALL require(bool)(TMP_66)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == developer)

IRs:
TMP_58(bool) = msg.sender == developer
TMP_59(None) = SOLIDITY_CALL require(bool)(TMP_58)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
this.balance < eth_minimum

IRs:
REF_28(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_60(bool) = REF_28 < eth_minimum
CONDITION TMP_60""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
kill_switch

IRs:
CONDITION kill_switch""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: RETURN 6
""];
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(sale != 0x0)

IRs:
TMP_61(bool) = sale != 0
TMP_62(None) = SOLIDITY_CALL require(bool)(TMP_61)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
bought_tokens = true

IRs:
bought_tokens(bool) := True(bool)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
contract_eth_value = this.balance

IRs:
REF_29(uint256) = SOLIDITY_CALL balance(address)(this)
contract_eth_value(uint256) := REF_29([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188C3280100>])""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
require(bool)(sale.call.value(contract_eth_value)())

IRs:
TMP_64(bool) = LOW_LEVEL_CALL, dest:sale, function:call, arguments:[] value:contract_eth_value 
TMP_65(None) = SOLIDITY_CALL require(bool)(TMP_64)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
require(bool)(this.balance == 0)

IRs:
REF_32(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_66(bool) = REF_32 == 0
TMP_67(None) = SOLIDITY_CALL require(bool)(TMP_66)""];
}
",0,0,1,0,require(bool)(msg.sender == developer);this.balance < eth_minimum;;;kill_switch;;;require(bool)(sale != 0x0);bought_tokens = true;contract_eth_value = this.balance;require(bool)(sale.call.value(contract_eth_value)());require(bool)(this.balance == 0)
./0x70f187ea2ebcf5b94aa7819f41c92f9a9dc4c200_ext.sol,LifePasswordAI.safeWithdrawal,304,309,"TMP_97(bool) = _value == 0,CONDITION TMP_97,TMP_98 = CONVERT this to address,TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98),Transfer dest:owner value:TMP_99,Transfer dest:owner value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_97(bool) = _value == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_98 = CONVERT this to address
TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98)
Transfer dest:owner value:TMP_99""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_value == 0;owner.transfer(address(this).balance);owner.transfer(_value);
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.claimTokens,2,2,"TMP_193(bool) = msg.value >= mineth,TMP_194(None) = SOLIDITY_CALL require(bool)(TMP_193),TMP_195 = CONVERT 0 to address,TMP_196(bool) = _beneficiary != TMP_195,TMP_197(None) = SOLIDITY_CALL require(bool)(TMP_196),REF_113(bool) -> blacklist[msg.sender],TMP_198 = UnaryType.BANG REF_113 ,TMP_199(None) = SOLIDITY_CALL require(bool)(TMP_198),REF_114(bool) -> isProcess[_beneficiary],TMP_200 = UnaryType.BANG REF_114 ,TMP_201(None) = SOLIDITY_CALL require(bool)(TMP_200),REF_115(bool) -> signups[_beneficiary],TMP_202(None) = SOLIDITY_CALL require(bool)(REF_115),TMP_203(uint256) = INTERNAL_CALL, KahnDistributionCentre.getReward(address)(_beneficiary),rewardAmount(uint256) := TMP_203(uint256),TMP_204(bool) = rewardAmount > 0,TMP_205(None) = SOLIDITY_CALL require(bool)(TMP_204),TMP_206(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  ,taBal(uint256) := TMP_206(uint256),TMP_207(bool) = rewardAmount <= taBal,TMP_208(None) = SOLIDITY_CALL require(bool)(TMP_207),REF_117(bool) -> isProcess[_beneficiary],REF_117(bool) (->isProcess) := True(bool),TMP_209(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['_beneficiary', 'rewardAmount']  ,REF_119(KahnDistributionCentre.User) -> bounties[_beneficiary],REF_120(uint256) -> REF_119.reward_amount,REF_120(uint256) (->bounties) := 0(uint256),REF_121(KahnDistributionCentre.User) -> bounties[_beneficiary],REF_122(bool) -> REF_121.status,REF_122(bool) (->bounties) := True(bool),REF_123(KahnDistributionCentre.User) -> bounties[_beneficiary],REF_124(uint256) -> REF_123.paid_time,REF_124(uint256) (->bounties) := now(uint256),REF_125(bool) -> isProcess[_beneficiary],REF_125(bool) (->isProcess) := False(bool),TMP_210(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['userClaimAmt', 'rewardAmount'] ,userClaimAmt(uint256) := TMP_210(uint256),INTERNAL_CALL, KahnDistributionCentre.forwardWei()(),Emit eTokenClaim(_beneficiary,rewardAmount),MODIFIER_CALL, KahnDistributionCentre.ifNotStartExp()(),MODIFIER_CALL, KahnDistributionCentre.ifNotPaused()(),MODIFIER_CALL, KahnDistributionCentre.ifNotBlacklisted()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->19;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= mineth)

IRs:
TMP_193(bool) = msg.value >= mineth
TMP_194(None) = SOLIDITY_CALL require(bool)(TMP_193)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_beneficiary != address(0))

IRs:
TMP_195 = CONVERT 0 to address
TMP_196(bool) = _beneficiary != TMP_195
TMP_197(None) = SOLIDITY_CALL require(bool)(TMP_196)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(! blacklist[msg.sender])

IRs:
REF_113(bool) -> blacklist[msg.sender]
TMP_198 = UnaryType.BANG REF_113 
TMP_199(None) = SOLIDITY_CALL require(bool)(TMP_198)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(! isProcess[_beneficiary])

IRs:
REF_114(bool) -> isProcess[_beneficiary]
TMP_200 = UnaryType.BANG REF_114 
TMP_201(None) = SOLIDITY_CALL require(bool)(TMP_200)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(signups[_beneficiary])

IRs:
REF_115(bool) -> signups[_beneficiary]
TMP_202(None) = SOLIDITY_CALL require(bool)(REF_115)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
rewardAmount = getReward(_beneficiary)

IRs:
TMP_203(uint256) = INTERNAL_CALL, KahnDistributionCentre.getReward(address)(_beneficiary)
rewardAmount(uint256) := TMP_203(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(rewardAmount > 0)

IRs:
TMP_204(bool) = rewardAmount > 0
TMP_205(None) = SOLIDITY_CALL require(bool)(TMP_204)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
taBal = token.balanceOf(this)

IRs:
TMP_206(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  
taBal(uint256) := TMP_206(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(rewardAmount <= taBal)

IRs:
TMP_207(bool) = rewardAmount <= taBal
TMP_208(None) = SOLIDITY_CALL require(bool)(TMP_207)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
isProcess[_beneficiary] = true

IRs:
REF_117(bool) -> isProcess[_beneficiary]
REF_117(bool) (->isProcess) := True(bool)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
token.transfer(_beneficiary,rewardAmount)

IRs:
TMP_209(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['_beneficiary', 'rewardAmount']  ""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
bounties[_beneficiary].reward_amount = 0

IRs:
REF_119(KahnDistributionCentre.User) -> bounties[_beneficiary]
REF_120(uint256) -> REF_119.reward_amount
REF_120(uint256) (->bounties) := 0(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
bounties[_beneficiary].status = true

IRs:
REF_121(KahnDistributionCentre.User) -> bounties[_beneficiary]
REF_122(bool) -> REF_121.status
REF_122(bool) (->bounties) := True(bool)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
bounties[_beneficiary].paid_time = now

IRs:
REF_123(KahnDistributionCentre.User) -> bounties[_beneficiary]
REF_124(uint256) -> REF_123.paid_time
REF_124(uint256) (->bounties) := now(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
isProcess[_beneficiary] = false

IRs:
REF_125(bool) -> isProcess[_beneficiary]
REF_125(bool) (->isProcess) := False(bool)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
userClaimAmt = userClaimAmt.add(rewardAmount)

IRs:
TMP_210(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['userClaimAmt', 'rewardAmount'] 
userClaimAmt(uint256) := TMP_210(uint256)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
forwardWei()

IRs:
INTERNAL_CALL, KahnDistributionCentre.forwardWei()()""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
eTokenClaim(_beneficiary,rewardAmount)

IRs:
Emit eTokenClaim(_beneficiary,rewardAmount)""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
ifNotStartExp()

IRs:
MODIFIER_CALL, KahnDistributionCentre.ifNotStartExp()()""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
ifNotPaused()

IRs:
MODIFIER_CALL, KahnDistributionCentre.ifNotPaused()()""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
ifNotBlacklisted()

IRs:
MODIFIER_CALL, KahnDistributionCentre.ifNotBlacklisted()()""];
21->1;
}
",0,1,1,0,"ifNotStartExp();require(bool)(msg.value >= mineth);require(bool)(_beneficiary != address(0));require(bool)(! blacklist[msg.sender]);require(bool)(! isProcess[_beneficiary]);require(bool)(signups[_beneficiary]);rewardAmount = getReward(_beneficiary);require(bool)(rewardAmount > 0);taBal = token.balanceOf(this);require(bool)(rewardAmount <= taBal);isProcess[_beneficiary] = true;token.transfer(_beneficiary,rewardAmount);bounties[_beneficiary].reward_amount = 0;bounties[_beneficiary].status = true;bounties[_beneficiary].paid_time = now;isProcess[_beneficiary] = false;userClaimAmt = userClaimAmt.add(rewardAmount);forwardWei();eTokenClaim(_beneficiary,rewardAmount);ifNotPaused();ifNotBlacklisted()"
./0x8d4b2cffe2dcbbf06eaa5920401db86ca5fb8177_ext.sol,RefundVault.close,569,574,"REF_157(RefundVault.State) -> State.Active,TMP_201(bool) = state == REF_157,TMP_202(None) = SOLIDITY_CALL require(bool)(TMP_201),REF_158(RefundVault.State) -> State.Closed,state(RefundVault.State) := REF_158(RefundVault.State),Emit Closed(),REF_160(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:wallet value:REF_160,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_157(RefundVault.State) -> State.Active
TMP_201(bool) = state == REF_157
TMP_202(None) = SOLIDITY_CALL require(bool)(TMP_201)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
state = State.Closed

IRs:
REF_158(RefundVault.State) -> State.Closed
state(RefundVault.State) := REF_158(RefundVault.State)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Closed()

IRs:
Emit Closed()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
wallet.transfer(this.balance)

IRs:
REF_160(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:wallet value:REF_160""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();require(bool)(state == State.Active);state = State.Closed;Closed();wallet.transfer(this.balance)
./0x720608228bda773fe22e816ee72463040f11c19e_ext.sol,Presale.withdraw,579,584,"TMP_313(None) = SOLIDITY_CALL require(bool)(softcapAchieved),TMP_314(bool) = owner == msg.sender,TMP_315(None) = SOLIDITY_CALL require(bool)(TMP_314),INTERNAL_CALL, Presale.withdrawDev()(),REF_173(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:wallet value:REF_173","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(softcapAchieved)

IRs:
TMP_313(None) = SOLIDITY_CALL require(bool)(softcapAchieved)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(owner == msg.sender)

IRs:
TMP_314(bool) = owner == msg.sender
TMP_315(None) = SOLIDITY_CALL require(bool)(TMP_314)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
withdrawDev()

IRs:
INTERNAL_CALL, Presale.withdrawDev()()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
wallet.transfer(this.balance)

IRs:
REF_173(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:wallet value:REF_173""];
}
",0,0,1,0,require(bool)(softcapAchieved);require(bool)(owner == msg.sender);withdrawDev();wallet.transfer(this.balance)
./0x5c15d6ac5db1a093ad57c383ffe11bde48b8241e_ext.sol,PerfectCoinControl.withdraw,114,116,"REF_37(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:owner value:REF_37,MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(this.balance)

IRs:
REF_37(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:owner value:REF_37""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();owner.transfer(this.balance)
./0x45afe0ff6a92bc9f346fc440a9d2a881d42094ff_ext.sol,Destructible.destroy,343,345,"TMP_192(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_192(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0x7609a798cf9e86622364326f5d1e523a030e19b4_ext.sol,XenoxToken.withdrawAll,296,300,"myAddress(address) := this(address),TMP_141(uint256) = SOLIDITY_CALL balance(address)(myAddress),etherBalance(uint256) := TMP_141(uint256),Transfer dest:owner value:etherBalance,MODIFIER_CALL, XenoxToken.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
myAddress = this

IRs:
myAddress(address) := this(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
etherBalance = myAddress.balance

IRs:
TMP_141(uint256) = SOLIDITY_CALL balance(address)(myAddress)
etherBalance(uint256) := TMP_141(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(etherBalance)

IRs:
Transfer dest:owner value:etherBalance""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, XenoxToken.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();myAddress = this;etherBalance = myAddress.balance;owner.transfer(etherBalance)
./0xef5eb9a12981bfbcdc5648ad7852f298c091cbc5_ext.sol,Exash.getTokens,174,233,"tokens(uint256) := 0(uint256),bonus(uint256) := 0(uint256),countbonus(uint256) := 0(uint256),TMP_45(uint256) = 1000000000000000000 / 2,bonusCond1(uint256) := TMP_45(uint256),bonusCond2(uint256) := 1000000000000000000(uint256),bonusCond3(uint256) := 3000000000000000000(uint256),TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_47(uint256) = TMP_46 / 1000000000000000000,tokens(uint256) := TMP_47(uint256),investor(address) := msg.sender(address),TMP_48(bool) = msg.value >= requestMinimum,TMP_49(bool) = now < deadline,TMP_50(bool) = TMP_48 && TMP_49,TMP_51(bool) = now < round1,TMP_52(bool) = TMP_50 && TMP_51,TMP_53(bool) = now < round2,TMP_54(bool) = TMP_52 && TMP_53,CONDITION TMP_54,TMP_55(bool) = msg.value >= bonusCond1,TMP_56(bool) = msg.value < bonusCond2,TMP_57(bool) = TMP_55 && TMP_56,CONDITION TMP_57,TMP_58(uint256) = tokens * 4,TMP_59(uint256) = TMP_58 / 100,countbonus(uint256) := TMP_59(uint256),TMP_60(bool) = msg.value >= bonusCond2,TMP_61(bool) = msg.value < bonusCond3,TMP_62(bool) = TMP_60 && TMP_61,CONDITION TMP_62,TMP_63(uint256) = tokens * 8,TMP_64(uint256) = TMP_63 / 100,countbonus(uint256) := TMP_64(uint256),TMP_65(bool) = msg.value >= bonusCond3,CONDITION TMP_65,TMP_66(uint256) = tokens * 12,TMP_67(uint256) = TMP_66 / 100,countbonus(uint256) := TMP_67(uint256),TMP_68(bool) = msg.value >= requestMinimum,TMP_69(bool) = now < deadline,TMP_70(bool) = TMP_68 && TMP_69,TMP_71(bool) = now > round1,TMP_72(bool) = TMP_70 && TMP_71,TMP_73(bool) = now < round2,TMP_74(bool) = TMP_72 && TMP_73,CONDITION TMP_74,TMP_75(bool) = msg.value >= bonusCond2,TMP_76(bool) = msg.value < bonusCond3,TMP_77(bool) = TMP_75 && TMP_76,CONDITION TMP_77,TMP_78(uint256) = tokens * 8,TMP_79(uint256) = TMP_78 / 100,countbonus(uint256) := TMP_79(uint256),TMP_80(bool) = msg.value >= bonusCond3,CONDITION TMP_80,TMP_81(uint256) = tokens * 12,TMP_82(uint256) = TMP_81 / 100,countbonus(uint256) := TMP_82(uint256),countbonus(uint256) := 0(uint256),TMP_83(uint256) = tokens + countbonus,bonus(uint256) := TMP_83(uint256),TMP_84(bool) = tokens == 0,CONDITION TMP_84,valdrop(uint256) := 500000000000(uint256),REF_12(bool) -> Claimed[investor],TMP_85(bool) = REF_12 == False,TMP_86(bool) = progress0drop <= target0drop,TMP_87(bool) = TMP_85 && TMP_86,CONDITION TMP_87,TMP_88(bool) = INTERNAL_CALL, Exash.distr(address,uint256)(investor,valdrop),REF_13(bool) -> Claimed[investor],REF_13(bool) (->Claimed) := True(bool),TMP_89(uint256) := progress0drop(uint256),progress0drop(uint256) = progress0drop + 1,TMP_90(bool) = msg.value >= requestMinimum,TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),TMP_92(bool) = tokens > 0,TMP_93(bool) = msg.value >= requestMinimum,TMP_94(bool) = TMP_92 && TMP_93,CONDITION TMP_94,TMP_95(bool) = now >= deadline,TMP_96(bool) = now >= round1,TMP_97(bool) = TMP_95 && TMP_96,TMP_98(bool) = now < round2,TMP_99(bool) = TMP_97 && TMP_98,CONDITION TMP_99,TMP_100(bool) = INTERNAL_CALL, Exash.distr(address,uint256)(investor,tokens),TMP_101(bool) = msg.value >= bonusCond1,CONDITION TMP_101,TMP_102(bool) = INTERNAL_CALL, Exash.distr(address,uint256)(investor,bonus),TMP_103(bool) = INTERNAL_CALL, Exash.distr(address,uint256)(investor,tokens),TMP_104(bool) = msg.value >= requestMinimum,TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104),TMP_106(bool) = totalDistributed >= totalSupply,CONDITION TMP_106,distributionFinished(bool) := True(bool),Transfer dest:multisig value:msg.value,MODIFIER_CALL, Exash.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->53;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bonusCond1 = 1000000000000000000 / 2

IRs:
TMP_45(uint256) = 1000000000000000000 / 2
bonusCond1(uint256) := TMP_45(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bonusCond2 = 1000000000000000000

IRs:
bonusCond2(uint256) := 1000000000000000000(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
bonusCond3 = 3000000000000000000

IRs:
bonusCond3(uint256) := 3000000000000000000(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_47(uint256) = TMP_46 / 1000000000000000000
tokens(uint256) := TMP_47(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now < round1 && now < round2

IRs:
TMP_48(bool) = msg.value >= requestMinimum
TMP_49(bool) = now < deadline
TMP_50(bool) = TMP_48 && TMP_49
TMP_51(bool) = now < round1
TMP_52(bool) = TMP_50 && TMP_51
TMP_53(bool) = now < round2
TMP_54(bool) = TMP_52 && TMP_53
CONDITION TMP_54""];
9->10[label=""True""];
9->19[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
msg.value >= bonusCond1 && msg.value < bonusCond2

IRs:
TMP_55(bool) = msg.value >= bonusCond1
TMP_56(bool) = msg.value < bonusCond2
TMP_57(bool) = TMP_55 && TMP_56
CONDITION TMP_57""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
countbonus = tokens * 4 / 100

IRs:
TMP_58(uint256) = tokens * 4
TMP_59(uint256) = TMP_58 / 100
countbonus(uint256) := TMP_59(uint256)""];
11->18;
12[label=""Node Type: IF 12

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_60(bool) = msg.value >= bonusCond2
TMP_61(bool) = msg.value < bonusCond3
TMP_62(bool) = TMP_60 && TMP_61
CONDITION TMP_62""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
countbonus = tokens * 8 / 100

IRs:
TMP_63(uint256) = tokens * 8
TMP_64(uint256) = TMP_63 / 100
countbonus(uint256) := TMP_64(uint256)""];
13->17;
14[label=""Node Type: IF 14

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_65(bool) = msg.value >= bonusCond3
CONDITION TMP_65""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
countbonus = tokens * 12 / 100

IRs:
TMP_66(uint256) = tokens * 12
TMP_67(uint256) = TMP_66 / 100
countbonus(uint256) := TMP_67(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->28;
19[label=""Node Type: IF 19

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now > round1 && now < round2

IRs:
TMP_68(bool) = msg.value >= requestMinimum
TMP_69(bool) = now < deadline
TMP_70(bool) = TMP_68 && TMP_69
TMP_71(bool) = now > round1
TMP_72(bool) = TMP_70 && TMP_71
TMP_73(bool) = now < round2
TMP_74(bool) = TMP_72 && TMP_73
CONDITION TMP_74""];
19->20[label=""True""];
19->26[label=""False""];
20[label=""Node Type: IF 20

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_75(bool) = msg.value >= bonusCond2
TMP_76(bool) = msg.value < bonusCond3
TMP_77(bool) = TMP_75 && TMP_76
CONDITION TMP_77""];
20->21[label=""True""];
20->22[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
countbonus = tokens * 8 / 100

IRs:
TMP_78(uint256) = tokens * 8
TMP_79(uint256) = TMP_78 / 100
countbonus(uint256) := TMP_79(uint256)""];
21->25;
22[label=""Node Type: IF 22

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_80(bool) = msg.value >= bonusCond3
CONDITION TMP_80""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
countbonus = tokens * 12 / 100

IRs:
TMP_81(uint256) = tokens * 12
TMP_82(uint256) = TMP_81 / 100
countbonus(uint256) := TMP_82(uint256)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->27;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
bonus = tokens + countbonus

IRs:
TMP_83(uint256) = tokens + countbonus
bonus(uint256) := TMP_83(uint256)""];
29->30;
30[label=""Node Type: IF 30

EXPRESSION:
tokens == 0

IRs:
TMP_84(bool) = tokens == 0
CONDITION TMP_84""];
30->31[label=""True""];
30->38[label=""False""];
31[label=""Node Type: NEW VARIABLE 31

EXPRESSION:
valdrop = 5000e8

IRs:
valdrop(uint256) := 500000000000(uint256)""];
31->32;
32[label=""Node Type: IF 32

EXPRESSION:
Claimed[investor] == false && progress0drop <= target0drop

IRs:
REF_12(bool) -> Claimed[investor]
TMP_85(bool) = REF_12 == False
TMP_86(bool) = progress0drop <= target0drop
TMP_87(bool) = TMP_85 && TMP_86
CONDITION TMP_87""];
32->33[label=""True""];
32->36[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
distr(investor,valdrop)

IRs:
TMP_88(bool) = INTERNAL_CALL, Exash.distr(address,uint256)(investor,valdrop)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
Claimed[investor] = true

IRs:
REF_13(bool) -> Claimed[investor]
REF_13(bool) (->Claimed) := True(bool)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
progress0drop ++

IRs:
TMP_89(uint256) := progress0drop(uint256)
progress0drop(uint256) = progress0drop + 1""];
35->37;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_90(bool) = msg.value >= requestMinimum
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
36->37;
37[label=""Node Type: END_IF 37
""];
37->48;
38[label=""Node Type: IF 38

EXPRESSION:
tokens > 0 && msg.value >= requestMinimum

IRs:
TMP_92(bool) = tokens > 0
TMP_93(bool) = msg.value >= requestMinimum
TMP_94(bool) = TMP_92 && TMP_93
CONDITION TMP_94""];
38->39[label=""True""];
38->46[label=""False""];
39[label=""Node Type: IF 39

EXPRESSION:
now >= deadline && now >= round1 && now < round2

IRs:
TMP_95(bool) = now >= deadline
TMP_96(bool) = now >= round1
TMP_97(bool) = TMP_95 && TMP_96
TMP_98(bool) = now < round2
TMP_99(bool) = TMP_97 && TMP_98
CONDITION TMP_99""];
39->40[label=""True""];
39->41[label=""False""];
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_100(bool) = INTERNAL_CALL, Exash.distr(address,uint256)(investor,tokens)""];
40->45;
41[label=""Node Type: IF 41

EXPRESSION:
msg.value >= bonusCond1

IRs:
TMP_101(bool) = msg.value >= bonusCond1
CONDITION TMP_101""];
41->42[label=""True""];
41->43[label=""False""];
42[label=""Node Type: EXPRESSION 42

EXPRESSION:
distr(investor,bonus)

IRs:
TMP_102(bool) = INTERNAL_CALL, Exash.distr(address,uint256)(investor,bonus)""];
42->44;
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_103(bool) = INTERNAL_CALL, Exash.distr(address,uint256)(investor,tokens)""];
43->44;
44[label=""Node Type: END_IF 44
""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->47;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_104(bool) = msg.value >= requestMinimum
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: IF 49

EXPRESSION:
totalDistributed >= totalSupply

IRs:
TMP_106(bool) = totalDistributed >= totalSupply
CONDITION TMP_106""];
49->50[label=""True""];
49->51[label=""False""];
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
multisig.transfer(msg.value)

IRs:
Transfer dest:multisig value:msg.value""];
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, Exash.canDistr()()""];
53->1;
}
",0,0,1,0,"canDistr();tokens = 0;bonus = 0;countbonus = 0;bonusCond1 = 1000000000000000000 / 2;bonusCond2 = 1000000000000000000;bonusCond3 = 3000000000000000000;tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;investor = msg.sender;msg.value >= requestMinimum && now < deadline && now < round1 && now < round2;msg.value >= bonusCond1 && msg.value < bonusCond2;msg.value >= requestMinimum && now < deadline && now > round1 && now < round2;countbonus = tokens * 4 / 100;msg.value >= bonusCond2 && msg.value < bonusCond3;;countbonus = tokens * 8 / 100;msg.value >= bonusCond3;;countbonus = tokens * 12 / 100;;;msg.value >= bonusCond2 && msg.value < bonusCond3;countbonus = 0;countbonus = tokens * 8 / 100;msg.value >= bonusCond3;;countbonus = tokens * 12 / 100;;;bonus = tokens + countbonus;tokens == 0;valdrop = 5000e8;tokens > 0 && msg.value >= requestMinimum;Claimed[investor] == false && progress0drop <= target0drop;distr(investor,valdrop);require(bool)(msg.value >= requestMinimum);Claimed[investor] = true;progress0drop ++;;;now >= deadline && now >= round1 && now < round2;require(bool)(msg.value >= requestMinimum);distr(investor,tokens);msg.value >= bonusCond1;;distr(investor,bonus);distr(investor,tokens);;;totalDistributed >= totalSupply;distributionFinished = true;;multisig.transfer(msg.value)"
./0x5149474fd339e95271304b5b28f6e456a24c0e25_ext.sol,MNSPAY.safeWithdrawal,304,309,"TMP_97(bool) = _value == 0,CONDITION TMP_97,TMP_98 = CONVERT this to address,TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98),Transfer dest:owner value:TMP_99,Transfer dest:owner value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_97(bool) = _value == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_98 = CONVERT this to address
TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98)
Transfer dest:owner value:TMP_99""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_value == 0;owner.transfer(address(this).balance);owner.transfer(_value);
./0x006ff3494c04680cfbf39b0396054486f3f6ad32_ext.sol,PLAY_NOW.StopGame,29,32,"TMP_9(bool) = msg.sender == questionSender,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_9(bool) = msg.sender == questionSender
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0x2992221bc5f79681635c2b490cca47cac0a2bd7c_ext.sol,try_me.Try,5,12,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 2000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 2000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 2000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 2000000000000000000;msg.sender.transfer(this.balance);
./0xc849a5fff9befa297d1c3a772bafac9f3c9004ec_ext.sol,Bounty0xEscrow.distributeTokenToAddress,202,212,"TMP_76 = CONVERT 0 to address,TMP_77(bool) = _hunter != TMP_76,TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77),REF_22(mapping(address => uint256)) -> tokens[_token],REF_23(uint256) -> REF_22[_host],TMP_79(bool) = REF_23 >= _amount,TMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79),REF_24(mapping(address => uint256)) -> tokens[_token],REF_25(uint256) -> REF_24[_host],REF_27(mapping(address => uint256)) -> tokens[_token],REF_28(uint256) -> REF_27[_host],TMP_81(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_amount'] ,REF_25(uint256) (->tokens) := TMP_81(uint256),TMP_82 = CONVERT 0 to address,TMP_83(bool) = _token == TMP_82,CONDITION TMP_83,TMP_84 = SEND dest:_hunter value:_amount,TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84),TMP_86 = CONVERT _token to ERC20,HIGH_LEVEL_CALL, dest:TMP_86(ERC20), function:transfer, arguments:['_hunter', '_amount']  ,Emit Distribution(_token,_host,_hunter,_amount),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_hunter != address(0))

IRs:
TMP_76 = CONVERT 0 to address
TMP_77(bool) = _hunter != TMP_76
TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(tokens[_token][_host] >= _amount)

IRs:
REF_22(mapping(address => uint256)) -> tokens[_token]
REF_23(uint256) -> REF_22[_host]
TMP_79(bool) = REF_23 >= _amount
TMP_80(None) = SOLIDITY_CALL require(bool)(TMP_79)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tokens[_token][_host] = SafeMath.sub(tokens[_token][_host],_amount)

IRs:
REF_24(mapping(address => uint256)) -> tokens[_token]
REF_25(uint256) -> REF_24[_host]
REF_27(mapping(address => uint256)) -> tokens[_token]
REF_28(uint256) -> REF_27[_host]
TMP_81(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_28', '_amount'] 
REF_25(uint256) (->tokens) := TMP_81(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
_token == address(0)

IRs:
TMP_82 = CONVERT 0 to address
TMP_83(bool) = _token == TMP_82
CONDITION TMP_83""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(_hunter.send(_amount))

IRs:
TMP_84 = SEND dest:_hunter value:_amount
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)""];
5->7;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
ERC20(_token).transfer(_hunter,_amount)

IRs:
TMP_86 = CONVERT _token to ERC20
HIGH_LEVEL_CALL, dest:TMP_86(ERC20), function:transfer, arguments:['_hunter', '_amount']  ""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Distribution(_token,_host,_hunter,_amount)

IRs:
Emit Distribution(_token,_host,_hunter,_amount)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
9->1;
}
",1,0,1,0,"onlyOwner();require(bool)(_hunter != address(0));require(bool)(tokens[_token][_host] >= _amount);tokens[_token][_host] = SafeMath.sub(tokens[_token][_host],_amount);_token == address(0);require(bool)(_hunter.send(_amount));ERC20(_token).transfer(_hunter,_amount);;Distribution(_token,_host,_hunter,_amount)"
./0xeb62b8c5c4f0f5d59a7f060554c13e8f38f4de9f_ext.sol,HODL.end,7,10,"TMP_0(bool) = msg.sender == hodl,CONDITION TMP_0,TMP_1(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == hodl

IRs:
TMP_0(bool) = msg.sender == hodl
CONDITION TMP_0""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(msg.sender)

IRs:
TMP_1(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,0,1,0,msg.sender == hodl;selfdestruct(address)(msg.sender);
./0xecec76db2f65a2669437b2bca5703c7e07b8d12a_ext.sol,play_with_me.StopGame,33,36,"TMP_10(bool) = msg.sender == questionSender,TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_10(bool) = msg.sender == questionSender
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0x56609c7dcb32cbedf7c5896cbb29b227bf4ec6a1_ext.sol,EFTCrowdsale.fallback,64,99,"TMP_12(bool) = msg.value > 0,TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12),TMP_14(bool) = now > startDate,TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14),TMP_16(bool) = now < endDate,TMP_17(None) = SOLIDITY_CALL require(bool)(TMP_16),TMP_18(uint256) = msg.value * price,amount(uint256) := TMP_18(uint256),TMP_19(uint256) = amount / 5,_amount(uint256) := TMP_19(uint256),TMP_20(bool) = now > 1518307200,TMP_21(bool) = now < 1519862401,TMP_22(bool) = TMP_20 && TMP_21,CONDITION TMP_22,amount(uint256) = amount + amount,TMP_23(bool) = now > 1519862400,TMP_24(bool) = now < 1522537201,TMP_25(bool) = TMP_23 && TMP_24,CONDITION TMP_25,TMP_26(uint256) = _amount * 15,amount(uint256) = amount + TMP_26,TMP_27(bool) = now > 1522537200,TMP_28(bool) = now < 1525129201,TMP_29(bool) = TMP_27 && TMP_28,CONDITION TMP_29,TMP_30(uint256) = _amount * 10,amount(uint256) = amount + TMP_30,TMP_31(bool) = now > 1525129200,TMP_32(bool) = now < 1527807601,TMP_33(bool) = TMP_31 && TMP_32,CONDITION TMP_33,TMP_34(uint256) = _amount * 5,amount(uint256) = amount + TMP_34,TMP_35(bool) = now > 1527807600,TMP_36(bool) = now < 1530399600,TMP_37(bool) = TMP_35 && TMP_36,CONDITION TMP_37,TMP_38(uint256) = _amount * 2,amount(uint256) = amount + TMP_38,HIGH_LEVEL_CALL, dest:tokenReward(Token), function:transfer, arguments:['msg.sender', 'amount']  ,Emit FundTransfer(msg.sender,amount,True),Transfer dest:owner value:msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value > 0)

IRs:
TMP_12(bool) = msg.value > 0
TMP_13(None) = SOLIDITY_CALL require(bool)(TMP_12)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(now > startDate)

IRs:
TMP_14(bool) = now > startDate
TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(now < endDate)

IRs:
TMP_16(bool) = now < endDate
TMP_17(None) = SOLIDITY_CALL require(bool)(TMP_16)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
amount = msg.value * price

IRs:
TMP_18(uint256) = msg.value * price
amount(uint256) := TMP_18(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
_amount = amount / 5

IRs:
TMP_19(uint256) = amount / 5
_amount(uint256) := TMP_19(uint256)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
now > 1518307200 && now < 1519862401

IRs:
TMP_20(bool) = now > 1518307200
TMP_21(bool) = now < 1519862401
TMP_22(bool) = TMP_20 && TMP_21
CONDITION TMP_22""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
amount += amount

IRs:
amount(uint256) = amount + amount""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
now > 1519862400 && now < 1522537201

IRs:
TMP_23(bool) = now > 1519862400
TMP_24(bool) = now < 1522537201
TMP_25(bool) = TMP_23 && TMP_24
CONDITION TMP_25""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
amount += _amount * 15

IRs:
TMP_26(uint256) = _amount * 15
amount(uint256) = amount + TMP_26""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
now > 1522537200 && now < 1525129201

IRs:
TMP_27(bool) = now > 1522537200
TMP_28(bool) = now < 1525129201
TMP_29(bool) = TMP_27 && TMP_28
CONDITION TMP_29""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
amount += _amount * 10

IRs:
TMP_30(uint256) = _amount * 10
amount(uint256) = amount + TMP_30""];
13->14;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: IF 15

EXPRESSION:
now > 1525129200 && now < 1527807601

IRs:
TMP_31(bool) = now > 1525129200
TMP_32(bool) = now < 1527807601
TMP_33(bool) = TMP_31 && TMP_32
CONDITION TMP_33""];
15->16[label=""True""];
15->17[label=""False""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
amount += _amount * 5

IRs:
TMP_34(uint256) = _amount * 5
amount(uint256) = amount + TMP_34""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: IF 18

EXPRESSION:
now > 1527807600 && now < 1530399600

IRs:
TMP_35(bool) = now > 1527807600
TMP_36(bool) = now < 1530399600
TMP_37(bool) = TMP_35 && TMP_36
CONDITION TMP_37""];
18->19[label=""True""];
18->20[label=""False""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
amount += _amount * 2

IRs:
TMP_38(uint256) = _amount * 2
amount(uint256) = amount + TMP_38""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
tokenReward.transfer(msg.sender,amount)

IRs:
HIGH_LEVEL_CALL, dest:tokenReward(Token), function:transfer, arguments:['msg.sender', 'amount']  ""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
FundTransfer(msg.sender,amount,true)

IRs:
Emit FundTransfer(msg.sender,amount,True)""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
owner.transfer(msg.value)

IRs:
Transfer dest:owner value:msg.value""];
}
",0,0,1,0,"require(bool)(msg.value > 0);require(bool)(now > startDate);require(bool)(now < endDate);amount = msg.value * price;_amount = amount / 5;now > 1518307200 && now < 1519862401;amount += amount;;now > 1519862400 && now < 1522537201;amount += _amount * 15;;now > 1522537200 && now < 1525129201;amount += _amount * 10;;now > 1525129200 && now < 1527807601;amount += _amount * 5;;now > 1527807600 && now < 1530399600;amount += _amount * 2;;tokenReward.transfer(msg.sender,amount);FundTransfer(msg.sender,amount,true);owner.transfer(msg.value)"
./0x2ada0cddb716033e52c3d591ad12a59103230e52_ext.sol,SGEICO.kill,56,58,"TMP_8(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, SGEICO.isCreator()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_8(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isCreator()

IRs:
MODIFIER_CALL, SGEICO.isCreator()()""];
2->1;
}
",0,0,1,0,isCreator();selfdestruct(address)(owner)
./0xf4f5271c9d6f23cc00f93625b502f88d289a1607_ext.sol,WithdrawConfirmation.executeWithdraw,196,207,"TMP_49(bool) = INTERNAL_CALL, WithdrawConfirmation.isConfirmed(uint256)(withdrawId),CONDITION TMP_49,REF_24(WithdrawConfirmation.Withdraw) -> withdraws[withdrawId],with(WithdrawConfirmation.Withdraw) := REF_24(WithdrawConfirmation.Withdraw),REF_25(bool) -> with.executed,REF_25(bool) (->with) := True(bool),REF_26(address) -> with.destination,REF_28(uint256) -> with.value,TMP_50 = SEND dest:REF_26 value:REF_28,CONDITION TMP_50,Emit Execution(withdrawId),Emit ExecutionFailure(withdrawId),REF_29(bool) -> with.executed,REF_29(bool) (->with) := False(bool),MODIFIER_CALL, WithdrawConfirmation.ownerExists(address)(msg.sender),MODIFIER_CALL, WithdrawConfirmation.confirmed(uint256,address)(withdrawId,msg.sender),MODIFIER_CALL, WithdrawConfirmation.notExecuted(uint256)(withdrawId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: IF 1

EXPRESSION:
isConfirmed(withdrawId)

IRs:
TMP_49(bool) = INTERNAL_CALL, WithdrawConfirmation.isConfirmed(uint256)(withdrawId)
CONDITION TMP_49""];
1->2[label=""True""];
1->9[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
with = withdraws[withdrawId]

IRs:
REF_24(WithdrawConfirmation.Withdraw) -> withdraws[withdrawId]
with(WithdrawConfirmation.Withdraw) := REF_24(WithdrawConfirmation.Withdraw)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
with.executed = true

IRs:
REF_25(bool) -> with.executed
REF_25(bool) (->with) := True(bool)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
with.destination.send(with.value)

IRs:
REF_26(address) -> with.destination
REF_28(uint256) -> with.value
TMP_50 = SEND dest:REF_26 value:REF_28
CONDITION TMP_50""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Execution(withdrawId)

IRs:
Emit Execution(withdrawId)""];
5->8;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
ExecutionFailure(withdrawId)

IRs:
Emit ExecutionFailure(withdrawId)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
with.executed = false

IRs:
REF_29(bool) -> with.executed
REF_29(bool) (->with) := False(bool)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, WithdrawConfirmation.ownerExists(address)(msg.sender)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
confirmed(withdrawId,msg.sender)

IRs:
MODIFIER_CALL, WithdrawConfirmation.confirmed(uint256,address)(withdrawId,msg.sender)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
notExecuted(withdrawId)

IRs:
MODIFIER_CALL, WithdrawConfirmation.notExecuted(uint256)(withdrawId)""];
12->1;
}
",0,0,1,0,"ownerExists(msg.sender);isConfirmed(withdrawId);with = withdraws[withdrawId];;with.executed = true;with.destination.send(with.value);Execution(withdrawId);ExecutionFailure(withdrawId);;with.executed = false;confirmed(withdrawId,msg.sender);notExecuted(withdrawId)"
./0xd1ceeeef70c61da45800bd81be3352160ad72f2a_ext.sol,Dice2Win.sendFunds,336,342,"TMP_126 = SEND dest:beneficiary value:amount,CONDITION TMP_126,Emit Payment(beneficiary,successLogAmount),Emit FailedPayment(beneficiary,amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
beneficiary.send(amount)

IRs:
TMP_126 = SEND dest:beneficiary value:amount
CONDITION TMP_126""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Payment(beneficiary,successLogAmount)

IRs:
Emit Payment(beneficiary,successLogAmount)""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
FailedPayment(beneficiary,amount)

IRs:
Emit FailedPayment(beneficiary,amount)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,"beneficiary.send(amount);Payment(beneficiary,successLogAmount);FailedPayment(beneficiary,amount);"
./0x55ae5792903b179915e10065e26610435832a3f7_ext.sol,CofounditICO.claimEthIfFailed,131,140,"TMP_37(bool) = block.number <= endBlock,TMP_38(bool) = totalEthRaised >= minEthToRaise,TMP_39(bool) = TMP_37 || TMP_38,CONDITION TMP_39,REF_6(uint256) -> participantContribution[msg.sender],TMP_40(bool) = REF_6 == 0,CONDITION TMP_40,REF_7(bool) -> hasClaimedEthWhenFail[msg.sender],CONDITION REF_7,REF_8(uint256) -> participantContribution[msg.sender],ethContributed(uint256) := REF_8(uint256),REF_9(bool) -> hasClaimedEthWhenFail[msg.sender],REF_9(bool) (->hasClaimedEthWhenFail) := True(bool),TMP_41 = SEND dest:msg.sender value:ethContributed,TMP_42 = UnaryType.BANG TMP_41 ,CONDITION TMP_42,Emit ErrorSendingETH(msg.sender,ethContributed)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
block.number <= endBlock || totalEthRaised >= minEthToRaise

IRs:
TMP_37(bool) = block.number <= endBlock
TMP_38(bool) = totalEthRaised >= minEthToRaise
TMP_39(bool) = TMP_37 || TMP_38
CONDITION TMP_39""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
participantContribution[msg.sender] == 0

IRs:
REF_6(uint256) -> participantContribution[msg.sender]
TMP_40(bool) = REF_6 == 0
CONDITION TMP_40""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: THROW 5
""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
hasClaimedEthWhenFail[msg.sender]

IRs:
REF_7(bool) -> hasClaimedEthWhenFail[msg.sender]
CONDITION REF_7""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: THROW 8
""];
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
ethContributed = participantContribution[msg.sender]

IRs:
REF_8(uint256) -> participantContribution[msg.sender]
ethContributed(uint256) := REF_8(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
hasClaimedEthWhenFail[msg.sender] = true

IRs:
REF_9(bool) -> hasClaimedEthWhenFail[msg.sender]
REF_9(bool) (->hasClaimedEthWhenFail) := True(bool)""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
! msg.sender.send(ethContributed)

IRs:
TMP_41 = SEND dest:msg.sender value:ethContributed
TMP_42 = UnaryType.BANG TMP_41 
CONDITION TMP_42""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
ErrorSendingETH(msg.sender,ethContributed)

IRs:
Emit ErrorSendingETH(msg.sender,ethContributed)""];
13->14;
14[label=""Node Type: END_IF 14
""];
}
",0,0,1,0,"block.number <= endBlock || totalEthRaised >= minEthToRaise;;;participantContribution[msg.sender] == 0;;;hasClaimedEthWhenFail[msg.sender];;;ethContributed = participantContribution[msg.sender];hasClaimedEthWhenFail[msg.sender] = true;! msg.sender.send(ethContributed);ErrorSendingETH(msg.sender,ethContributed);"
./0x70ab487ec48b4b9571d346348da0f10737d48a54_ext.sol,PredictionHandshake.refund,471,504,"REF_289(PredictionHandshake.Market) -> markets[hid],m(PredictionHandshake.Market) := REF_289(PredictionHandshake.Market),REF_290(uint256) -> m.state,TMP_120(bool) = REF_290 == 1,REF_291(uint256) -> m.outcome,TMP_121(bool) = REF_291 == 3,TMP_122(bool) = TMP_120 || TMP_121,TMP_123(None) = SOLIDITY_CALL require(bool)(TMP_122),REF_292(uint256) -> m.reportTime,TMP_124(bool) = now > REF_292,TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124),REF_293(mapping(address => mapping(uint256 => PredictionHandshake.Order))) -> m.matched,REF_294(mapping(uint256 => PredictionHandshake.Order)) -> REF_293[msg.sender],REF_295(PredictionHandshake.Order) -> REF_294[1],REF_296(uint256) -> REF_295.stake,amt(uint256) = amt + REF_296,REF_297(mapping(address => mapping(uint256 => PredictionHandshake.Order))) -> m.matched,REF_298(mapping(uint256 => PredictionHandshake.Order)) -> REF_297[msg.sender],REF_299(PredictionHandshake.Order) -> REF_298[2],REF_300(uint256) -> REF_299.stake,amt(uint256) = amt + REF_300,REF_301(mapping(address => mapping(uint256 => PredictionHandshake.Order))) -> m.open,REF_302(mapping(uint256 => PredictionHandshake.Order)) -> REF_301[msg.sender],REF_303(PredictionHandshake.Order) -> REF_302[1],REF_304(uint256) -> REF_303.stake,amt(uint256) = amt + REF_304,REF_305(mapping(address => mapping(uint256 => PredictionHandshake.Order))) -> m.open,REF_306(mapping(uint256 => PredictionHandshake.Order)) -> REF_305[msg.sender],REF_307(PredictionHandshake.Order) -> REF_306[2],REF_308(uint256) -> REF_307.stake,amt(uint256) = amt + REF_308,TMP_126(bool) = amt > 0,TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126),REF_309(mapping(address => mapping(uint256 => PredictionHandshake.Order))) -> m.matched,REF_310(mapping(uint256 => PredictionHandshake.Order)) -> REF_309[msg.sender],REF_311(PredictionHandshake.Order) -> REF_310[1],REF_312(uint256) -> REF_311.stake,REF_312(uint256) (->m) := 0(uint256),REF_313(mapping(address => mapping(uint256 => PredictionHandshake.Order))) -> m.matched,REF_314(mapping(uint256 => PredictionHandshake.Order)) -> REF_313[msg.sender],REF_315(PredictionHandshake.Order) -> REF_314[2],REF_316(uint256) -> REF_315.stake,REF_316(uint256) (->m) := 0(uint256),REF_317(mapping(address => mapping(uint256 => PredictionHandshake.Order))) -> m.open,REF_318(mapping(uint256 => PredictionHandshake.Order)) -> REF_317[msg.sender],REF_319(PredictionHandshake.Order) -> REF_318[1],REF_320(uint256) -> REF_319.stake,REF_320(uint256) (->m) := 0(uint256),REF_321(mapping(address => mapping(uint256 => PredictionHandshake.Order))) -> m.open,REF_322(mapping(uint256 => PredictionHandshake.Order)) -> REF_321[msg.sender],REF_323(PredictionHandshake.Order) -> REF_322[2],REF_324(uint256) -> REF_323.stake,REF_324(uint256) (->m) := 0(uint256),REF_325(PredictionHandshake.Trial) -> trial[msg.sender],REF_326(bool) -> REF_325.valid,TMP_128 = UnaryType.BANG REF_326 ,CONDITION TMP_128,Transfer dest:msg.sender value:amt,REF_328(PredictionHandshake.Trial) -> trial[msg.sender],REF_329(mapping(uint256 => uint256)) -> REF_328.totalStakes,REF_330(uint256) -> REF_329[hid],trialAmt(uint256) := REF_330(uint256),TMP_130(uint256) = amt - trialAmt,amt(uint256) := TMP_130(uint256),TMP_131(bool) = amt > 0,TMP_132(None) = SOLIDITY_CALL require(bool)(TMP_131),Transfer dest:msg.sender value:amt,Emit __refund(hid,offchain),Emit __test__refund(amt),MODIFIER_CALL, PredictionHandshake.onlyPredictor(uint256)(hid)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->23;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
m = markets[hid]

IRs:
REF_289(PredictionHandshake.Market) -> markets[hid]
m(PredictionHandshake.Market) := REF_289(PredictionHandshake.Market)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(m.state == 1 || m.outcome == 3)

IRs:
REF_290(uint256) -> m.state
TMP_120(bool) = REF_290 == 1
REF_291(uint256) -> m.outcome
TMP_121(bool) = REF_291 == 3
TMP_122(bool) = TMP_120 || TMP_121
TMP_123(None) = SOLIDITY_CALL require(bool)(TMP_122)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(now > m.reportTime)

IRs:
REF_292(uint256) -> m.reportTime
TMP_124(bool) = now > REF_292
TMP_125(None) = SOLIDITY_CALL require(bool)(TMP_124)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
amt += m.matched[msg.sender][1].stake

IRs:
REF_293(mapping(address => mapping(uint256 => PredictionHandshake.Order))) -> m.matched
REF_294(mapping(uint256 => PredictionHandshake.Order)) -> REF_293[msg.sender]
REF_295(PredictionHandshake.Order) -> REF_294[1]
REF_296(uint256) -> REF_295.stake
amt(uint256) = amt + REF_296""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
amt += m.matched[msg.sender][2].stake

IRs:
REF_297(mapping(address => mapping(uint256 => PredictionHandshake.Order))) -> m.matched
REF_298(mapping(uint256 => PredictionHandshake.Order)) -> REF_297[msg.sender]
REF_299(PredictionHandshake.Order) -> REF_298[2]
REF_300(uint256) -> REF_299.stake
amt(uint256) = amt + REF_300""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
amt += m.open[msg.sender][1].stake

IRs:
REF_301(mapping(address => mapping(uint256 => PredictionHandshake.Order))) -> m.open
REF_302(mapping(uint256 => PredictionHandshake.Order)) -> REF_301[msg.sender]
REF_303(PredictionHandshake.Order) -> REF_302[1]
REF_304(uint256) -> REF_303.stake
amt(uint256) = amt + REF_304""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
amt += m.open[msg.sender][2].stake

IRs:
REF_305(mapping(address => mapping(uint256 => PredictionHandshake.Order))) -> m.open
REF_306(mapping(uint256 => PredictionHandshake.Order)) -> REF_305[msg.sender]
REF_307(PredictionHandshake.Order) -> REF_306[2]
REF_308(uint256) -> REF_307.stake
amt(uint256) = amt + REF_308""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(amt > 0)

IRs:
TMP_126(bool) = amt > 0
TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
m.matched[msg.sender][1].stake = 0

IRs:
REF_309(mapping(address => mapping(uint256 => PredictionHandshake.Order))) -> m.matched
REF_310(mapping(uint256 => PredictionHandshake.Order)) -> REF_309[msg.sender]
REF_311(PredictionHandshake.Order) -> REF_310[1]
REF_312(uint256) -> REF_311.stake
REF_312(uint256) (->m) := 0(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
m.matched[msg.sender][2].stake = 0

IRs:
REF_313(mapping(address => mapping(uint256 => PredictionHandshake.Order))) -> m.matched
REF_314(mapping(uint256 => PredictionHandshake.Order)) -> REF_313[msg.sender]
REF_315(PredictionHandshake.Order) -> REF_314[2]
REF_316(uint256) -> REF_315.stake
REF_316(uint256) (->m) := 0(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
m.open[msg.sender][1].stake = 0

IRs:
REF_317(mapping(address => mapping(uint256 => PredictionHandshake.Order))) -> m.open
REF_318(mapping(uint256 => PredictionHandshake.Order)) -> REF_317[msg.sender]
REF_319(PredictionHandshake.Order) -> REF_318[1]
REF_320(uint256) -> REF_319.stake
REF_320(uint256) (->m) := 0(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
m.open[msg.sender][2].stake = 0

IRs:
REF_321(mapping(address => mapping(uint256 => PredictionHandshake.Order))) -> m.open
REF_322(mapping(uint256 => PredictionHandshake.Order)) -> REF_321[msg.sender]
REF_323(PredictionHandshake.Order) -> REF_322[2]
REF_324(uint256) -> REF_323.stake
REF_324(uint256) (->m) := 0(uint256)""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
! (trial[msg.sender].valid)

IRs:
REF_325(PredictionHandshake.Trial) -> trial[msg.sender]
REF_326(bool) -> REF_325.valid
TMP_128 = UnaryType.BANG REF_326 
CONDITION TMP_128""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
msg.sender.transfer(amt)

IRs:
Transfer dest:msg.sender value:amt""];
15->20;
16[label=""Node Type: NEW VARIABLE 16

EXPRESSION:
trialAmt = trial[msg.sender].totalStakes[hid]

IRs:
REF_328(PredictionHandshake.Trial) -> trial[msg.sender]
REF_329(mapping(uint256 => uint256)) -> REF_328.totalStakes
REF_330(uint256) -> REF_329[hid]
trialAmt(uint256) := REF_330(uint256)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
amt = amt - trialAmt

IRs:
TMP_130(uint256) = amt - trialAmt
amt(uint256) := TMP_130(uint256)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
require(bool)(amt > 0)

IRs:
TMP_131(bool) = amt > 0
TMP_132(None) = SOLIDITY_CALL require(bool)(TMP_131)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
msg.sender.transfer(amt)

IRs:
Transfer dest:msg.sender value:amt""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
__refund(hid,offchain)

IRs:
Emit __refund(hid,offchain)""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
__test__refund(amt)

IRs:
Emit __test__refund(amt)""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
onlyPredictor(hid)

IRs:
MODIFIER_CALL, PredictionHandshake.onlyPredictor(uint256)(hid)""];
23->1;
}
",0,0,1,0,"onlyPredictor(hid);m = markets[hid];require(bool)(m.state == 1 || m.outcome == 3);require(bool)(now > m.reportTime);;amt += m.matched[msg.sender][1].stake;amt += m.matched[msg.sender][2].stake;amt += m.open[msg.sender][1].stake;amt += m.open[msg.sender][2].stake;require(bool)(amt > 0);m.matched[msg.sender][1].stake = 0;m.matched[msg.sender][2].stake = 0;m.open[msg.sender][1].stake = 0;m.open[msg.sender][2].stake = 0;! (trial[msg.sender].valid);msg.sender.transfer(amt);trialAmt = trial[msg.sender].totalStakes[hid];;amt = amt - trialAmt;require(bool)(amt > 0);msg.sender.transfer(amt);__refund(hid,offchain);__test__refund(amt)"
./0xda830afa460526071d3d149e898fead664f0a4bb_ext.sol,MiniMeToken.claimTokens,604,614,"TMP_157(bool) = _token == 0,CONDITION TMP_157,REF_58(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:controller value:REF_58,TMP_159 = CONVERT _token to MiniMeToken,token(MiniMeToken) := TMP_159(MiniMeToken),TMP_160(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_160(uint256),TMP_161(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  ,Emit ClaimedTokens(_token,controller,balance),MODIFIER_CALL, Controlled.onlyController()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_157(bool) = _token == 0
CONDITION TMP_157""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_58(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_58""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
token = MiniMeToken(_token)

IRs:
TMP_159 = CONVERT _token to MiniMeToken
token(MiniMeToken) := TMP_159(MiniMeToken)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_160(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_160(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_161(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()""];
9->1;
}
",0,0,1,0,"onlyController();_token == 0x0;controller.transfer(this.balance);;;token = MiniMeToken(_token);balance = token.balanceOf(this);token.transfer(controller,balance);ClaimedTokens(_token,controller,balance)"
./0x50a667b73223bc612bcc43200120b5c46ee6b4e9_ext.sol,RCpro.withdraw,555,557,"Transfer dest:to value:value,MODIFIER_CALL, RCpro.onlyTokenSaleOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
to.transfer(value)

IRs:
Transfer dest:to value:value""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyTokenSaleOwner()

IRs:
MODIFIER_CALL, RCpro.onlyTokenSaleOwner()()""];
2->1;
}
",0,0,1,0,onlyTokenSaleOwner();to.transfer(value)
./0x39de38ba63d172b962db2fc2ee5e4376287c50bf_ext.sol,ImmlaIco.returnFundsFor,448,457,"TMP_187 = CONVERT this to address,TMP_188(bool) = msg.sender == TMP_187,TMP_189(bool) = msg.sender == icoManager,TMP_190(bool) = TMP_188 || TMP_189,TMP_191(bool) = msg.sender == _account,TMP_192(bool) = TMP_190 || TMP_191,TMP_193(None) = SOLIDITY_CALL assert(bool)(TMP_192),TMP_194(bool) = soldTokensOnIco < minIcoTokenLimit,TMP_195(None) = SOLIDITY_CALL assert(bool)(TMP_194),REF_75(uint256) -> balances[_account],TMP_196(bool) = REF_75 > 0,TMP_197(None) = SOLIDITY_CALL assert(bool)(TMP_196),REF_77(uint256) -> balances[_account],Transfer dest:_account value:REF_77,REF_78(uint256) -> balances[_account],REF_78(uint256) (->balances) := 0(uint256),Emit ReturnFundsFor(_account),MODIFIER_CALL, ImmlaIco.onGoalAchievedOrDeadline()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(msg.sender == address(this) || msg.sender == icoManager || msg.sender == _account)

IRs:
TMP_187 = CONVERT this to address
TMP_188(bool) = msg.sender == TMP_187
TMP_189(bool) = msg.sender == icoManager
TMP_190(bool) = TMP_188 || TMP_189
TMP_191(bool) = msg.sender == _account
TMP_192(bool) = TMP_190 || TMP_191
TMP_193(None) = SOLIDITY_CALL assert(bool)(TMP_192)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(soldTokensOnIco < minIcoTokenLimit)

IRs:
TMP_194(bool) = soldTokensOnIco < minIcoTokenLimit
TMP_195(None) = SOLIDITY_CALL assert(bool)(TMP_194)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
assert(bool)(balances[_account] > 0)

IRs:
REF_75(uint256) -> balances[_account]
TMP_196(bool) = REF_75 > 0
TMP_197(None) = SOLIDITY_CALL assert(bool)(TMP_196)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
_account.transfer(balances[_account])

IRs:
REF_77(uint256) -> balances[_account]
Transfer dest:_account value:REF_77""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
balances[_account] = 0

IRs:
REF_78(uint256) -> balances[_account]
REF_78(uint256) (->balances) := 0(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
ReturnFundsFor(_account)

IRs:
Emit ReturnFundsFor(_account)""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onGoalAchievedOrDeadline()

IRs:
MODIFIER_CALL, ImmlaIco.onGoalAchievedOrDeadline()()""];
7->1;
}
",0,0,1,0,onGoalAchievedOrDeadline();assert(bool)(msg.sender == address(this) || msg.sender == icoManager || msg.sender == _account);assert(bool)(soldTokensOnIco < minIcoTokenLimit);assert(bool)(balances[_account] > 0);_account.transfer(balances[_account]);balances[_account] = 0;ReturnFundsFor(_account)
./0x4c7c98c4d64c29ef8103b005eeccf5145cfdf8c1_ext.sol,Savings.kill,46,50,"TMP_13(bool) = INTERNAL_CALL, Ownable.isOwner()(),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),TMP_14(bool) = REF_3 == 0,TMP_15(bool) = TMP_13 && TMP_14,CONDITION TMP_15,TMP_16(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
isOwner() && this.balance == 0

IRs:
TMP_13(bool) = INTERNAL_CALL, Ownable.isOwner()()
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_14(bool) = REF_3 == 0
TMP_15(bool) = TMP_13 && TMP_14
CONDITION TMP_15""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(msg.sender)

IRs:
TMP_16(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,0,1,0,isOwner() && this.balance == 0;selfdestruct(address)(msg.sender);
./0xd587cb111d3e506ffafdf4b1c5d19008086c4e5a_ext.sol,IartistChain.fallback,147,151,"TMP_79 = SEND dest:owner value:msg.value,TMP_80(uint256) = msg.value * buyPrice,amount(uint256) := TMP_80(uint256),INTERNAL_CALL, IartistChain._transfer(address,address,uint256)(owner,msg.sender,amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.send(msg.value)

IRs:
TMP_79 = SEND dest:owner value:msg.value""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = msg.value * buyPrice

IRs:
TMP_80(uint256) = msg.value * buyPrice
amount(uint256) := TMP_80(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_transfer(owner,msg.sender,amount)

IRs:
INTERNAL_CALL, IartistChain._transfer(address,address,uint256)(owner,msg.sender,amount)""];
}
",0,0,1,0,"owner.send(msg.value);amount = msg.value * buyPrice;_transfer(owner,msg.sender,amount)"
./0xbf2000b42c1ba2eb9e5163a0b7e2fe987ed124b4_ext.sol,SeedCrowdsaleContract.processTransaction,211,239,"TMP_59(uint256) = INTERNAL_CALL, SeedCrowdsaleContract.calculateMaxContribution(address)(_contributor),maxContribution(uint256) := TMP_59(uint256),contributionAmount(uint256) := _amount(uint256),returnAmount(uint256) := 0(uint256),TMP_60(bool) = maxContribution < _amount,CONDITION TMP_60,contributionAmount(uint256) := maxContribution(uint256),TMP_61(uint256) = _amount - maxContribution,returnAmount(uint256) := TMP_61(uint256),TMP_62(uint256) = ethRaised + contributionAmount,TMP_63(bool) = TMP_62 >= minCap,TMP_64(bool) = minCap > ethRaised,TMP_65(bool) = TMP_63 && TMP_64,CONDITION TMP_65,Emit MinCapReached(block.timestamp),REF_18(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor],REF_19(uint256) -> REF_18.contributionAmount,TMP_67(bool) = REF_19 == 0,CONDITION TMP_67,REF_20(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor],REF_21(uint256) -> REF_20.contributionAmount,REF_21(uint256) (->contributorList) := contributionAmount(uint256),REF_22(address) -> contributorIndexes[nextContributorIndex],REF_22(address) (->contributorIndexes) := _contributor(address),TMP_68(uint256) := nextContributorIndex(uint256),nextContributorIndex(uint256) = nextContributorIndex + 1,REF_23(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor],REF_24(uint256) -> REF_23.contributionAmount,REF_24(-> contributorList) = REF_24 + contributionAmount,ethRaised(uint256) = ethRaised + contributionAmount,Emit ContributionMade(msg.sender,contributionAmount),TMP_70(bool) = returnAmount != 0,CONDITION TMP_70,Transfer dest:_contributor value:returnAmount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
maxContribution = calculateMaxContribution(_contributor)

IRs:
TMP_59(uint256) = INTERNAL_CALL, SeedCrowdsaleContract.calculateMaxContribution(address)(_contributor)
maxContribution(uint256) := TMP_59(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
contributionAmount = _amount

IRs:
contributionAmount(uint256) := _amount(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
returnAmount = 0

IRs:
returnAmount(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
maxContribution < _amount

IRs:
TMP_60(bool) = maxContribution < _amount
CONDITION TMP_60""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
contributionAmount = maxContribution

IRs:
contributionAmount(uint256) := maxContribution(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
returnAmount = _amount - maxContribution

IRs:
TMP_61(uint256) = _amount - maxContribution
returnAmount(uint256) := TMP_61(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
ethRaised + contributionAmount >= minCap && minCap > ethRaised

IRs:
TMP_62(uint256) = ethRaised + contributionAmount
TMP_63(bool) = TMP_62 >= minCap
TMP_64(bool) = minCap > ethRaised
TMP_65(bool) = TMP_63 && TMP_64
CONDITION TMP_65""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
MinCapReached(block.timestamp)

IRs:
Emit MinCapReached(block.timestamp)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
contributorList[_contributor].contributionAmount == 0

IRs:
REF_18(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor]
REF_19(uint256) -> REF_18.contributionAmount
TMP_67(bool) = REF_19 == 0
CONDITION TMP_67""];
11->12[label=""True""];
11->15[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
contributorList[_contributor].contributionAmount = contributionAmount

IRs:
REF_20(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor]
REF_21(uint256) -> REF_20.contributionAmount
REF_21(uint256) (->contributorList) := contributionAmount(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
contributorIndexes[nextContributorIndex] = _contributor

IRs:
REF_22(address) -> contributorIndexes[nextContributorIndex]
REF_22(address) (->contributorIndexes) := _contributor(address)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
nextContributorIndex ++

IRs:
TMP_68(uint256) := nextContributorIndex(uint256)
nextContributorIndex(uint256) = nextContributorIndex + 1""];
14->16;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
contributorList[_contributor].contributionAmount += contributionAmount

IRs:
REF_23(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor]
REF_24(uint256) -> REF_23.contributionAmount
REF_24(-> contributorList) = REF_24 + contributionAmount""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
ethRaised += contributionAmount

IRs:
ethRaised(uint256) = ethRaised + contributionAmount""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
ContributionMade(msg.sender,contributionAmount)

IRs:
Emit ContributionMade(msg.sender,contributionAmount)""];
18->19;
19[label=""Node Type: IF 19

EXPRESSION:
returnAmount != 0

IRs:
TMP_70(bool) = returnAmount != 0
CONDITION TMP_70""];
19->20[label=""True""];
19->21[label=""False""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
_contributor.transfer(returnAmount)

IRs:
Transfer dest:_contributor value:returnAmount""];
20->21;
21[label=""Node Type: END_IF 21
""];
}
",0,1,1,0,"maxContribution = calculateMaxContribution(_contributor);contributionAmount = _amount;returnAmount = 0;maxContribution < _amount;contributionAmount = maxContribution;;returnAmount = _amount - maxContribution;ethRaised + contributionAmount >= minCap && minCap > ethRaised;MinCapReached(block.timestamp);;contributorList[_contributor].contributionAmount == 0;contributorList[_contributor].contributionAmount = contributionAmount;contributorList[_contributor].contributionAmount += contributionAmount;contributorIndexes[nextContributorIndex] = _contributor;nextContributorIndex ++;;ethRaised += contributionAmount;ContributionMade(msg.sender,contributionAmount);returnAmount != 0;_contributor.transfer(returnAmount);"
./0xef5eb9a12981bfbcdc5648ad7852f298c091cbc5_ext.sol,Exash.withdraw,291,294,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, Exash.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Exash.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x574fb6d9d090042a04d0d12a4e87217f8303a5ca_ext.sol,HelloGoldSale.complete,900,913,"TMP_551(bool) = INTERNAL_CALL, HelloGoldSale.success()(),CONDITION TMP_551,REF_191(uint256) = SOLIDITY_CALL balance(address)(this),val(uint256) := REF_191([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188BA5BF1C0>]),TMP_552(bool) = val > 0,CONDITION TMP_552,TMP_553 = SEND dest:multiSig value:val,TMP_554 = UnaryType.BANG TMP_553 ,CONDITION TMP_554,TMP_555(None) = SOLIDITY_CALL log0(bytes32)(cannot withdraw),TMP_556(None) = SOLIDITY_CALL log0(bytes32)(funds withdrawn),TMP_557(None) = SOLIDITY_CALL log0(bytes32)(nothing to withdraw),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: IF 1

EXPRESSION:
success()

IRs:
TMP_551(bool) = INTERNAL_CALL, HelloGoldSale.success()()
CONDITION TMP_551""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
val = this.balance

IRs:
REF_191(uint256) = SOLIDITY_CALL balance(address)(this)
val(uint256) := REF_191([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188BA5BF1C0>])""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
val > 0

IRs:
TMP_552(bool) = val > 0
CONDITION TMP_552""];
3->4[label=""True""];
3->8[label=""False""];
4[label=""Node Type: IF 4

EXPRESSION:
! multiSig.send(val)

IRs:
TMP_553 = SEND dest:multiSig value:val
TMP_554 = UnaryType.BANG TMP_553 
CONDITION TMP_554""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
log0(bytes32)(cannot withdraw)

IRs:
TMP_555(None) = SOLIDITY_CALL log0(bytes32)(cannot withdraw)""];
5->7;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
log0(bytes32)(funds withdrawn)

IRs:
TMP_556(None) = SOLIDITY_CALL log0(bytes32)(funds withdrawn)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->9;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
log0(bytes32)(nothing to withdraw)

IRs:
TMP_557(None) = SOLIDITY_CALL log0(bytes32)(nothing to withdraw)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: END_IF 10
""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
11->1;
}
",0,0,1,0,onlyOwner();success();val = this.balance;;val > 0;! multiSig.send(val);log0(bytes32)(nothing to withdraw);log0(bytes32)(cannot withdraw);log0(bytes32)(funds withdrawn);;
./0x54d445898cbafb7cf48597e495251183207767ae_ext.sol,FasterProfit.fallback,31,90,"TMP_0(bool) = msg.value == 0,REF_0(address) -> last.depositor,TMP_1(bool) = msg.sender == REF_0,TMP_2(bool) = TMP_0 && TMP_1,CONDITION TMP_2,TMP_3(uint256) = SOLIDITY_CALL gasleft()(),TMP_4(bool) = TMP_3 >= 220000,TMP_5(None) = SOLIDITY_CALL require(bool,string)(TMP_4,We require more gas!),REF_1(uint256) -> last.blockNumber,TMP_6(uint256) = REF_1 + 45,TMP_7(bool) = TMP_6 < block.number,TMP_8(None) = SOLIDITY_CALL require(bool,string)(TMP_7,Last depositor should wait 45 blocks (~10 minutes) to claim reward),TMP_9 = CONVERT this to address,TMP_10(uint256) = SOLIDITY_CALL balance(address)(TMP_9),TMP_11 = CONVERT TMP_10 to uint128,money(uint128) := TMP_11(uint128),REF_2(uint256) -> last.expect,TMP_12(bool) = money >= REF_2,CONDITION TMP_12,REF_3(address) -> last.depositor,REF_5(uint256) -> last.expect,Transfer dest:REF_3 value:REF_5,REF_6(address) -> last.depositor,Transfer dest:REF_6 value:money,last = delete last ,TMP_15(bool) = msg.value > 0,CONDITION TMP_15,TMP_16(uint256) = SOLIDITY_CALL gasleft()(),TMP_17(bool) = TMP_16 >= 220000,TMP_18(None) = SOLIDITY_CALL require(bool,string)(TMP_17,We require more gas!),TMP_19(bool) = msg.value <= MAX_DEPOSIT,TMP_20(bool) = msg.value >= MIN_DEPOSIT,TMP_21(bool) = TMP_19 && TMP_20,TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21),TMP_23 = CONVERT msg.value to uint128,TMP_24(uint256) = msg.value * MULTIPLIER,TMP_25(uint256) = TMP_24 / 100,TMP_26 = CONVERT TMP_25 to uint128,TMP_27(FasterProfit.Deposit) = new Deposit(msg.sender,TMP_23,TMP_26),REF_9 -> LENGTH queue,TMP_29(uint256) := REF_9(uint256),TMP_30(uint256) = TMP_29 + 1,REF_9(uint256) (->queue) := TMP_30(uint256),REF_10(FasterProfit.Deposit) -> queue[TMP_29],REF_10(FasterProfit.Deposit) (->queue) := TMP_27(FasterProfit.Deposit),REF_11(address) -> last.depositor,REF_11(address) (->last) := msg.sender(address),REF_12(uint256) -> last.expect,TMP_31(uint256) = msg.value * LAST_DEPOSIT_PERCENT,TMP_32(uint256) = TMP_31 / 100,REF_12(-> last) = REF_12 + TMP_32,REF_13(uint256) -> last.blockNumber,REF_13(uint256) (->last) := block.number(uint256),txnCount(uint256) = txnCount + 1,TMP_33(bool) = txnCount >= 1800,CONDITION TMP_33,MIN_DEPOSIT(uint256) := 100000000000000000(uint256),TMP_34(bool) = txnCount >= 1600,CONDITION TMP_34,MIN_DEPOSIT(uint256) := 90000000000000000(uint256),TMP_35(bool) = txnCount >= 1400,CONDITION TMP_35,MIN_DEPOSIT(uint256) := 80000000000000000(uint256),TMP_36(bool) = txnCount >= 1200,CONDITION TMP_36,MIN_DEPOSIT(uint256) := 70000000000000000(uint256),TMP_37(bool) = txnCount >= 1000,CONDITION TMP_37,MIN_DEPOSIT(uint256) := 60000000000000000(uint256),TMP_38(bool) = txnCount >= 800,CONDITION TMP_38,MIN_DEPOSIT(uint256) := 50000000000000000(uint256),TMP_39(bool) = txnCount >= 600,CONDITION TMP_39,MIN_DEPOSIT(uint256) := 40000000000000000(uint256),TMP_40(bool) = txnCount >= 400,CONDITION TMP_40,MIN_DEPOSIT(uint256) := 30000000000000000(uint256),TMP_41(bool) = txnCount >= 200,CONDITION TMP_41,MIN_DEPOSIT(uint256) := 20000000000000000(uint256),MIN_DEPOSIT(uint256) := 10000000000000000(uint256),TMP_42(uint256) = msg.value * PROMO_PERCENT,TMP_43(uint256) = TMP_42 / 10000,promo(uint256) := TMP_43(uint256),TMP_44 = CONVERT this to address,TMP_45(uint256) = SOLIDITY_CALL balance(address)(TMP_44),TMP_46 = CONVERT TMP_45 to uint128,contractBalance(uint128) := TMP_46(uint128),TMP_47(bool) = contractBalance >= promo,CONDITION TMP_47,Transfer dest:PROMO value:promo,Transfer dest:PROMO value:contractBalance,PROMO_PERCENT(uint256) = PROMO_PERCENT + 5,INTERNAL_CALL, FasterProfit.pay()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value == 0 && msg.sender == last.depositor

IRs:
TMP_0(bool) = msg.value == 0
REF_0(address) -> last.depositor
TMP_1(bool) = msg.sender == REF_0
TMP_2(bool) = TMP_0 && TMP_1
CONDITION TMP_2""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(gasleft()() >= 220000,We require more gas!)

IRs:
TMP_3(uint256) = SOLIDITY_CALL gasleft()()
TMP_4(bool) = TMP_3 >= 220000
TMP_5(None) = SOLIDITY_CALL require(bool,string)(TMP_4,We require more gas!)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool,string)(last.blockNumber + 45 < block.number,Last depositor should wait 45 blocks (~10 minutes) to claim reward)

IRs:
REF_1(uint256) -> last.blockNumber
TMP_6(uint256) = REF_1 + 45
TMP_7(bool) = TMP_6 < block.number
TMP_8(None) = SOLIDITY_CALL require(bool,string)(TMP_7,Last depositor should wait 45 blocks (~10 minutes) to claim reward)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
money = uint128((address(this).balance))

IRs:
TMP_9 = CONVERT this to address
TMP_10(uint256) = SOLIDITY_CALL balance(address)(TMP_9)
TMP_11 = CONVERT TMP_10 to uint128
money(uint128) := TMP_11(uint128)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
money >= last.expect

IRs:
REF_2(uint256) -> last.expect
TMP_12(bool) = money >= REF_2
CONDITION TMP_12""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
last.depositor.transfer(last.expect)

IRs:
REF_3(address) -> last.depositor
REF_5(uint256) -> last.expect
Transfer dest:REF_3 value:REF_5""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
last.depositor.transfer(money)

IRs:
REF_6(address) -> last.depositor
Transfer dest:REF_6 value:money""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
delete last

IRs:
last = delete last ""];
9->55;
10[label=""Node Type: IF 10

EXPRESSION:
msg.value > 0

IRs:
TMP_15(bool) = msg.value > 0
CONDITION TMP_15""];
10->11[label=""True""];
10->54[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
require(bool,string)(gasleft()() >= 220000,We require more gas!)

IRs:
TMP_16(uint256) = SOLIDITY_CALL gasleft()()
TMP_17(bool) = TMP_16 >= 220000
TMP_18(None) = SOLIDITY_CALL require(bool,string)(TMP_17,We require more gas!)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
require(bool)(msg.value <= MAX_DEPOSIT && msg.value >= MIN_DEPOSIT)

IRs:
TMP_19(bool) = msg.value <= MAX_DEPOSIT
TMP_20(bool) = msg.value >= MIN_DEPOSIT
TMP_21(bool) = TMP_19 && TMP_20
TMP_22(None) = SOLIDITY_CALL require(bool)(TMP_21)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
queue.push(Deposit(msg.sender,uint128(msg.value),uint128(msg.value * MULTIPLIER / 100)))

IRs:
TMP_23 = CONVERT msg.value to uint128
TMP_24(uint256) = msg.value * MULTIPLIER
TMP_25(uint256) = TMP_24 / 100
TMP_26 = CONVERT TMP_25 to uint128
TMP_27(FasterProfit.Deposit) = new Deposit(msg.sender,TMP_23,TMP_26)
REF_9 -> LENGTH queue
TMP_29(uint256) := REF_9(uint256)
TMP_30(uint256) = TMP_29 + 1
REF_9(uint256) (->queue) := TMP_30(uint256)
REF_10(FasterProfit.Deposit) -> queue[TMP_29]
REF_10(FasterProfit.Deposit) (->queue) := TMP_27(FasterProfit.Deposit)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
last.depositor = msg.sender

IRs:
REF_11(address) -> last.depositor
REF_11(address) (->last) := msg.sender(address)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
last.expect += msg.value * LAST_DEPOSIT_PERCENT / 100

IRs:
REF_12(uint256) -> last.expect
TMP_31(uint256) = msg.value * LAST_DEPOSIT_PERCENT
TMP_32(uint256) = TMP_31 / 100
REF_12(-> last) = REF_12 + TMP_32""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
last.blockNumber = block.number

IRs:
REF_13(uint256) -> last.blockNumber
REF_13(uint256) (->last) := block.number(uint256)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
txnCount += 1

IRs:
txnCount(uint256) = txnCount + 1""];
17->18;
18[label=""Node Type: IF 18

EXPRESSION:
txnCount >= 1800

IRs:
TMP_33(bool) = txnCount >= 1800
CONDITION TMP_33""];
18->19[label=""True""];
18->20[label=""False""];
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
MIN_DEPOSIT = 100000000000000000

IRs:
MIN_DEPOSIT(uint256) := 100000000000000000(uint256)""];
19->45;
20[label=""Node Type: IF 20

EXPRESSION:
txnCount >= 1600

IRs:
TMP_34(bool) = txnCount >= 1600
CONDITION TMP_34""];
20->21[label=""True""];
20->22[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
MIN_DEPOSIT = 90000000000000000

IRs:
MIN_DEPOSIT(uint256) := 90000000000000000(uint256)""];
21->44;
22[label=""Node Type: IF 22

EXPRESSION:
txnCount >= 1400

IRs:
TMP_35(bool) = txnCount >= 1400
CONDITION TMP_35""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
MIN_DEPOSIT = 80000000000000000

IRs:
MIN_DEPOSIT(uint256) := 80000000000000000(uint256)""];
23->43;
24[label=""Node Type: IF 24

EXPRESSION:
txnCount >= 1200

IRs:
TMP_36(bool) = txnCount >= 1200
CONDITION TMP_36""];
24->25[label=""True""];
24->26[label=""False""];
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
MIN_DEPOSIT = 70000000000000000

IRs:
MIN_DEPOSIT(uint256) := 70000000000000000(uint256)""];
25->42;
26[label=""Node Type: IF 26

EXPRESSION:
txnCount >= 1000

IRs:
TMP_37(bool) = txnCount >= 1000
CONDITION TMP_37""];
26->27[label=""True""];
26->28[label=""False""];
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
MIN_DEPOSIT = 60000000000000000

IRs:
MIN_DEPOSIT(uint256) := 60000000000000000(uint256)""];
27->41;
28[label=""Node Type: IF 28

EXPRESSION:
txnCount >= 800

IRs:
TMP_38(bool) = txnCount >= 800
CONDITION TMP_38""];
28->29[label=""True""];
28->30[label=""False""];
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
MIN_DEPOSIT = 50000000000000000

IRs:
MIN_DEPOSIT(uint256) := 50000000000000000(uint256)""];
29->40;
30[label=""Node Type: IF 30

EXPRESSION:
txnCount >= 600

IRs:
TMP_39(bool) = txnCount >= 600
CONDITION TMP_39""];
30->31[label=""True""];
30->32[label=""False""];
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
MIN_DEPOSIT = 40000000000000000

IRs:
MIN_DEPOSIT(uint256) := 40000000000000000(uint256)""];
31->39;
32[label=""Node Type: IF 32

EXPRESSION:
txnCount >= 400

IRs:
TMP_40(bool) = txnCount >= 400
CONDITION TMP_40""];
32->33[label=""True""];
32->34[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
MIN_DEPOSIT = 30000000000000000

IRs:
MIN_DEPOSIT(uint256) := 30000000000000000(uint256)""];
33->38;
34[label=""Node Type: IF 34

EXPRESSION:
txnCount >= 200

IRs:
TMP_41(bool) = txnCount >= 200
CONDITION TMP_41""];
34->35[label=""True""];
34->36[label=""False""];
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
MIN_DEPOSIT = 20000000000000000

IRs:
MIN_DEPOSIT(uint256) := 20000000000000000(uint256)""];
35->37;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
MIN_DEPOSIT = 10000000000000000

IRs:
MIN_DEPOSIT(uint256) := 10000000000000000(uint256)""];
36->37;
37[label=""Node Type: END_IF 37
""];
37->38;
38[label=""Node Type: END_IF 38
""];
38->39;
39[label=""Node Type: END_IF 39
""];
39->40;
40[label=""Node Type: END_IF 40
""];
40->41;
41[label=""Node Type: END_IF 41
""];
41->42;
42[label=""Node Type: END_IF 42
""];
42->43;
43[label=""Node Type: END_IF 43
""];
43->44;
44[label=""Node Type: END_IF 44
""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->46;
46[label=""Node Type: NEW VARIABLE 46

EXPRESSION:
promo = msg.value * PROMO_PERCENT / 10000

IRs:
TMP_42(uint256) = msg.value * PROMO_PERCENT
TMP_43(uint256) = TMP_42 / 10000
promo(uint256) := TMP_43(uint256)""];
46->47;
47[label=""Node Type: NEW VARIABLE 47

EXPRESSION:
contractBalance = uint128((address(this).balance))

IRs:
TMP_44 = CONVERT this to address
TMP_45(uint256) = SOLIDITY_CALL balance(address)(TMP_44)
TMP_46 = CONVERT TMP_45 to uint128
contractBalance(uint128) := TMP_46(uint128)""];
47->48;
48[label=""Node Type: IF 48

EXPRESSION:
contractBalance >= promo

IRs:
TMP_47(bool) = contractBalance >= promo
CONDITION TMP_47""];
48->49[label=""True""];
48->50[label=""False""];
49[label=""Node Type: EXPRESSION 49

EXPRESSION:
PROMO.transfer(promo)

IRs:
Transfer dest:PROMO value:promo""];
49->51;
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
PROMO.transfer(contractBalance)

IRs:
Transfer dest:PROMO value:contractBalance""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
PROMO_PERCENT += 5

IRs:
PROMO_PERCENT(uint256) = PROMO_PERCENT + 5""];
52->53;
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
pay()

IRs:
INTERNAL_CALL, FasterProfit.pay()()""];
53->54;
54[label=""Node Type: END_IF 54
""];
54->55;
55[label=""Node Type: END_IF 55
""];
}
",0,0,1,0,"msg.value == 0 && msg.sender == last.depositor;require(bool,string)(gasleft()() >= 220000,We require more gas!);msg.value > 0;require(bool,string)(last.blockNumber + 45 < block.number,Last depositor should wait 45 blocks (~10 minutes) to claim reward);money = uint128((address(this).balance));money >= last.expect;last.depositor.transfer(last.expect);last.depositor.transfer(money);;delete last;;require(bool,string)(gasleft()() >= 220000,We require more gas!);;require(bool)(msg.value <= MAX_DEPOSIT && msg.value >= MIN_DEPOSIT);queue.push(Deposit(msg.sender,uint128(msg.value),uint128(msg.value * MULTIPLIER / 100)));last.depositor = msg.sender;last.expect += msg.value * LAST_DEPOSIT_PERCENT / 100;last.blockNumber = block.number;txnCount += 1;txnCount >= 1800;MIN_DEPOSIT = 100000000000000000;txnCount >= 1600;;MIN_DEPOSIT = 90000000000000000;txnCount >= 1400;;MIN_DEPOSIT = 80000000000000000;txnCount >= 1200;;MIN_DEPOSIT = 70000000000000000;txnCount >= 1000;;MIN_DEPOSIT = 60000000000000000;txnCount >= 800;;MIN_DEPOSIT = 50000000000000000;txnCount >= 600;;MIN_DEPOSIT = 40000000000000000;txnCount >= 400;;MIN_DEPOSIT = 30000000000000000;txnCount >= 200;;MIN_DEPOSIT = 20000000000000000;MIN_DEPOSIT = 10000000000000000;;promo = msg.value * PROMO_PERCENT / 10000;contractBalance = uint128((address(this).balance));contractBalance >= promo;PROMO.transfer(promo);PROMO.transfer(contractBalance);;PROMO_PERCENT += 5;pay()"
./0x3008a6c26e54399fd0ece8fd2e5e06b3d807509c_ext.sol,AccessService.withdraw,104,116,"TMP_37(bool) = msg.sender == addrFinance,TMP_38(bool) = msg.sender == addrAdmin,TMP_39(bool) = TMP_37 || TMP_38,TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39),TMP_41(bool) = _amount > 0,TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41),REF_0(uint256) = SOLIDITY_CALL balance(address)(this),balance(uint256) := REF_0([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E2F93D30>]),TMP_43(bool) = _amount < balance,CONDITION TMP_43,Transfer dest:receiver value:_amount,REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:receiver value:REF_3,TMP_46 = CONVERT 0 to address,TMP_47(bool) = _target == TMP_46,CONDITION TMP_47,receiver(address) := addrFinance(address),receiver(address) := _target(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == addrFinance || msg.sender == addrAdmin)

IRs:
TMP_37(bool) = msg.sender == addrFinance
TMP_38(bool) = msg.sender == addrAdmin
TMP_39(bool) = TMP_37 || TMP_38
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amount > 0)

IRs:
TMP_41(bool) = _amount > 0
TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)""];
2->9;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
balance = this.balance

IRs:
REF_0(uint256) = SOLIDITY_CALL balance(address)(this)
balance(uint256) := REF_0([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E2F93D30>])""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
_amount < balance

IRs:
TMP_43(bool) = _amount < balance
CONDITION TMP_43""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
receiver.transfer(_amount)

IRs:
Transfer dest:receiver value:_amount""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
receiver.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:receiver value:REF_3""];
7->8;
8[label=""Node Type: END_IF 8
""];
9[label=""Node Type: IF 9

EXPRESSION:
_target == address(0)

IRs:
TMP_46 = CONVERT 0 to address
TMP_47(bool) = _target == TMP_46
CONDITION TMP_47""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
receiver = addrFinance

IRs:
receiver(address) := addrFinance(address)""];
10->12;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
receiver = _target

IRs:
receiver(address) := _target(address)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->4;
}
",0,0,1,0,require(bool)(msg.sender == addrFinance || msg.sender == addrAdmin);require(bool)(_amount > 0);_target == address(0);balance = this.balance;_amount < balance;receiver.transfer(_amount);receiver.transfer(this.balance);;receiver = addrFinance;receiver = _target;
./0x5a757fb240ac70dbead4f9e1508f24a91da70ee5_ext.sol,SilentToken.withdraw,302,305,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, SilentToken.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, SilentToken.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x27369e8f43f44c26853a46da7e6cb52d203b59ce_ext.sol,AgileCycleWithAssistance.failSafe,802,812,"TMP_372(bool) = msg.sender == operator,CONDITION TMP_372,saveMe(bool) := True(bool),TMP_373(bool) = msg.sender == juryOperator,CONDITION TMP_373,TMP_374(bool) = saveMe == True,TMP_375(None) = SOLIDITY_CALL require(bool)(TMP_374),TMP_376 = CONVERT this to address,TMP_377(uint256) = SOLIDITY_CALL balance(address)(TMP_376),TMP_378 = SEND dest:juryOperator value:TMP_377,TMP_379(None) = SOLIDITY_CALL require(bool)(TMP_378),TMP_380(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:balanceOf, arguments:['this']  ,allTheLockedTokens(uint256) := TMP_380(uint256),TMP_381(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transfer, arguments:['juryOperator', 'allTheLockedTokens']  ,TMP_382(None) = SOLIDITY_CALL require(bool)(TMP_381)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == operator

IRs:
TMP_372(bool) = msg.sender == operator
CONDITION TMP_372""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
saveMe = true

IRs:
saveMe(bool) := True(bool)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
msg.sender == juryOperator

IRs:
TMP_373(bool) = msg.sender == juryOperator
CONDITION TMP_373""];
4->5[label=""True""];
4->9[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(saveMe == true)

IRs:
TMP_374(bool) = saveMe == True
TMP_375(None) = SOLIDITY_CALL require(bool)(TMP_374)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(juryOperator.send(address(this).balance))

IRs:
TMP_376 = CONVERT this to address
TMP_377(uint256) = SOLIDITY_CALL balance(address)(TMP_376)
TMP_378 = SEND dest:juryOperator value:TMP_377
TMP_379(None) = SOLIDITY_CALL require(bool)(TMP_378)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
allTheLockedTokens = token.balanceOf(this)

IRs:
TMP_380(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:balanceOf, arguments:['this']  
allTheLockedTokens(uint256) := TMP_380(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(token.transfer(juryOperator,allTheLockedTokens))

IRs:
TMP_381(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transfer, arguments:['juryOperator', 'allTheLockedTokens']  
TMP_382(None) = SOLIDITY_CALL require(bool)(TMP_381)""];
8->9;
9[label=""Node Type: END_IF 9
""];
}
",0,0,1,0,"msg.sender == operator;saveMe = true;;msg.sender == juryOperator;require(bool)(saveMe == true);;require(bool)(juryOperator.send(address(this).balance));allTheLockedTokens = token.balanceOf(this);require(bool)(token.transfer(juryOperator,allTheLockedTokens))"
./0x889a32263d237872b4f7985ead9c29ebfe8b464d_ext.sol,CaviarToken.killContract,59,65,"TMP_6(bool) = msg.sender == owner,TMP_7(bool) = msg.value >= howManyEtherInWeiToKillContract,TMP_8(bool) = TMP_6 || TMP_7,CONDITION TMP_8,TMP_9(None) = SOLIDITY_CALL selfdestruct(address)(owner)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == owner || msg.value >= howManyEtherInWeiToKillContract

IRs:
TMP_6(bool) = msg.sender == owner
TMP_7(bool) = msg.value >= howManyEtherInWeiToKillContract
TMP_8(bool) = TMP_6 || TMP_7
CONDITION TMP_8""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_9(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,0,1,0,msg.sender == owner || msg.value >= howManyEtherInWeiToKillContract;selfdestruct(address)(owner);
./0xd64ad4eefaacb96a0865687cfeef4c4a2cfbfef2_ext.sol,Lotthereum.withdraw,251,259,"TMP_90(uint256) = INTERNAL_CALL, Lotthereum.getBalance()(),amount(uint256) := TMP_90(uint256),TMP_91(bool) = amount > 0,CONDITION TMP_91,REF_104(uint256) -> balances[msg.sender],REF_104(uint256) (->balances) := 0(uint256),Transfer dest:msg.sender value:amount,RETURN amount,RETURN 0","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
amount = getBalance()

IRs:
TMP_90(uint256) = INTERNAL_CALL, Lotthereum.getBalance()()
amount(uint256) := TMP_90(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
amount > 0

IRs:
TMP_91(bool) = amount > 0
CONDITION TMP_91""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = 0

IRs:
REF_104(uint256) -> balances[msg.sender]
REF_104(uint256) (->balances) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
amount

IRs:
RETURN amount""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
0

IRs:
RETURN 0""];
}
",0,0,1,0,amount = getBalance();amount > 0;balances[msg.sender] = 0;;msg.sender.transfer(amount);amount;0
./0xf2eefee3c99cdb30c11d57b487a16690e813309b_ext.sol,SlotMachine.withdraw,64,70,"REF_1(uint256) -> pendingWithdrawals[msg.sender],amount(uint256) := REF_1(uint256),REF_2(uint256) -> pendingWithdrawals[msg.sender],REF_2(uint256) (->pendingWithdrawals) := 0(uint256),Transfer dest:msg.sender value:amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
amount = pendingWithdrawals[msg.sender]

IRs:
REF_1(uint256) -> pendingWithdrawals[msg.sender]
amount(uint256) := REF_1(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
pendingWithdrawals[msg.sender] = 0

IRs:
REF_2(uint256) -> pendingWithdrawals[msg.sender]
REF_2(uint256) (->pendingWithdrawals) := 0(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
}
",0,0,1,0,amount = pendingWithdrawals[msg.sender];pendingWithdrawals[msg.sender] = 0;msg.sender.transfer(amount)
./0x588f4ee97a2085c95420a45684a898d4b5906ba1_ext.sol,SPAM.fallback,192,198,"REF_7(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:owner value:REF_7,Emit Message(Thanks for your donation.)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(this.balance)

IRs:
REF_7(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:owner value:REF_7""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Message(Thanks for your donation.)

IRs:
Emit Message(Thanks for your donation.)""];
}
",0,0,1,0,owner.transfer(this.balance);Message(Thanks for your donation.)
./0x704079e823e42a936bbaac5163434c2515473836_ext.sol,CONUNDRUM.StopGame,35,41,"TMP_9(bool) = msg.sender == questionSender,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_9(bool) = msg.sender == questionSender
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0x33b44a1d150f3feaa40503ad20a75634adc39b18_ext.sol,TimeCapsule.kill,36,39,"TMP_11(bool) = INTERNAL_CALL, Ownable.isOwner()(),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),TMP_12(bool) = REF_3 == 0,TMP_13(bool) = TMP_11 && TMP_12,CONDITION TMP_13,TMP_14(None) = SOLIDITY_CALL suicide(address)(msg.sender)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
isOwner() && this.balance == 0

IRs:
TMP_11(bool) = INTERNAL_CALL, Ownable.isOwner()()
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_12(bool) = REF_3 == 0
TMP_13(bool) = TMP_11 && TMP_12
CONDITION TMP_13""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
suicide(address)(msg.sender)

IRs:
TMP_14(None) = SOLIDITY_CALL suicide(address)(msg.sender)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,0,1,0,isOwner() && this.balance == 0;suicide(address)(msg.sender);
./0xf1add8bf553d0066be17768d6816f3730c476237_ext.sol,EasySmartolution.processPayment,90,99,"REF_10(address) -> participants[_address],TMP_38 = CONVERT REF_10 to Participant,participant(Participant) := TMP_38(Participant),TMP_39(uint256) = HIGH_LEVEL_CALL, dest:participant(Participant), function:daily, arguments:[]  ,TMP_41(bool) = HIGH_LEVEL_CALL, dest:participant(Participant), function:processPayment, arguments:[] value:TMP_39 ,done(bool) := TMP_41(bool),CONDITION done,REF_14(address) -> participants[_address],TMP_42 = CONVERT 0 to address,REF_14(address) (->participants) := TMP_42(address),Emit ParticipantRemoved(_address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
participant = Participant(participants[_address])

IRs:
REF_10(address) -> participants[_address]
TMP_38 = CONVERT REF_10 to Participant
participant(Participant) := TMP_38(Participant)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
done = participant.processPayment.value(participant.daily())()

IRs:
TMP_39(uint256) = HIGH_LEVEL_CALL, dest:participant(Participant), function:daily, arguments:[]  
TMP_41(bool) = HIGH_LEVEL_CALL, dest:participant(Participant), function:processPayment, arguments:[] value:TMP_39 
done(bool) := TMP_41(bool)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
done

IRs:
CONDITION done""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
participants[_address] = address(0)

IRs:
REF_14(address) -> participants[_address]
TMP_42 = CONVERT 0 to address
REF_14(address) (->participants) := TMP_42(address)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
ParticipantRemoved(_address)

IRs:
Emit ParticipantRemoved(_address)""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",1,0,1,0,participant = Participant(participants[_address]);done = participant.processPayment.value(participant.daily())();done;participants[_address] = address(0);;ParticipantRemoved(_address)
./0x0e0a86c97a07856d68bf3387aeb9430dbab93245_ext.sol,InterbetCore.payMaker,367,394,"fullyWithdrawn(bool) := False(bool),REF_139(bool) -> makerBet.makerFundWithdrawn,TMP_193 = UnaryType.BANG REF_139 ,CONDITION TMP_193,REF_140(bool) -> makerBet.makerFundWithdrawn,REF_140(bool) (->makerBet) := True(bool),payout(uint256) := 0(uint256),REF_141(InterbetCore.BetOutcome) -> makerBet.outcome,REF_142(InterbetCore.BetOutcome) -> BetOutcome.MakerWin,TMP_194(bool) = REF_141 == REF_142,CONDITION TMP_194,REF_143(uint256) -> makerBet.totalStake,REF_144(InterbetCore.Verifier) -> makerBet.trustedVerifier,REF_145(uint256) -> REF_144.feeRate,TMP_195(uint256) = INTERNAL_CALL, InterbetCore.mul(uint256,uint256)(REF_143,REF_145),TMP_196(uint256) = 10 ** feeRateDecimals,TMP_197(uint256) = TMP_196 * 100,TMP_198(uint256) = TMP_195 / TMP_197,trustedVerifierFeeMakerWin(uint256) := TMP_198(uint256),REF_146(uint256) -> makerBet.totalFund,REF_147(uint256) -> makerBet.totalStake,TMP_199(uint256) = INTERNAL_CALL, InterbetCore.add(uint256,uint256)(REF_146,REF_147),TMP_200(uint256) = INTERNAL_CALL, InterbetCore.sub(uint256,uint256)(TMP_199,trustedVerifierFeeMakerWin),payout(uint256) := TMP_200(uint256),REF_148(InterbetCore.BetOutcome) -> makerBet.outcome,REF_149(InterbetCore.BetOutcome) -> BetOutcome.TakerWin,TMP_201(bool) = REF_148 == REF_149,CONDITION TMP_201,REF_150(uint256) -> makerBet.totalFund,REF_151(uint256) -> makerBet.reservedFund,TMP_202(uint256) = INTERNAL_CALL, InterbetCore.sub(uint256,uint256)(REF_150,REF_151),payout(uint256) := TMP_202(uint256),REF_152(InterbetCore.BetOutcome) -> makerBet.outcome,REF_153(InterbetCore.BetOutcome) -> BetOutcome.Draw,TMP_203(bool) = REF_152 == REF_153,REF_154(InterbetCore.BetOutcome) -> makerBet.outcome,REF_155(InterbetCore.BetOutcome) -> BetOutcome.Canceled,TMP_204(bool) = REF_154 == REF_155,TMP_205(bool) = TMP_203 || TMP_204,CONDITION TMP_205,REF_156(uint256) -> makerBet.totalFund,payout(uint256) := REF_156(uint256),TMP_206(bool) = payout > 0,CONDITION TMP_206,fullyWithdrawn(bool) := True(bool),REF_157(address) -> makerBet.maker,TMP_207 = SEND dest:REF_157 value:payout,TMP_208 = UnaryType.BANG TMP_207 ,CONDITION TMP_208,REF_159(bool) -> makerBet.makerFundWithdrawn,REF_159(bool) (->makerBet) := False(bool),fullyWithdrawn(bool) := False(bool),RETURN fullyWithdrawn,RETURN fullyWithdrawn","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
fullyWithdrawn = false

IRs:
fullyWithdrawn(bool) := False(bool)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
! makerBet.makerFundWithdrawn

IRs:
REF_139(bool) -> makerBet.makerFundWithdrawn
TMP_193 = UnaryType.BANG REF_139 
CONDITION TMP_193""];
2->3[label=""True""];
2->22[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
makerBet.makerFundWithdrawn = true

IRs:
REF_140(bool) -> makerBet.makerFundWithdrawn
REF_140(bool) (->makerBet) := True(bool)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
payout = 0

IRs:
payout(uint256) := 0(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
makerBet.outcome == BetOutcome.MakerWin

IRs:
REF_141(InterbetCore.BetOutcome) -> makerBet.outcome
REF_142(InterbetCore.BetOutcome) -> BetOutcome.MakerWin
TMP_194(bool) = REF_141 == REF_142
CONDITION TMP_194""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
trustedVerifierFeeMakerWin = mul(makerBet.totalStake,makerBet.trustedVerifier.feeRate) / ((10 ** feeRateDecimals) * 100)

IRs:
REF_143(uint256) -> makerBet.totalStake
REF_144(InterbetCore.Verifier) -> makerBet.trustedVerifier
REF_145(uint256) -> REF_144.feeRate
TMP_195(uint256) = INTERNAL_CALL, InterbetCore.mul(uint256,uint256)(REF_143,REF_145)
TMP_196(uint256) = 10 ** feeRateDecimals
TMP_197(uint256) = TMP_196 * 100
TMP_198(uint256) = TMP_195 / TMP_197
trustedVerifierFeeMakerWin(uint256) := TMP_198(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
payout = sub(add(makerBet.totalFund,makerBet.totalStake),trustedVerifierFeeMakerWin)

IRs:
REF_146(uint256) -> makerBet.totalFund
REF_147(uint256) -> makerBet.totalStake
TMP_199(uint256) = INTERNAL_CALL, InterbetCore.add(uint256,uint256)(REF_146,REF_147)
TMP_200(uint256) = INTERNAL_CALL, InterbetCore.sub(uint256,uint256)(TMP_199,trustedVerifierFeeMakerWin)
payout(uint256) := TMP_200(uint256)""];
7->14;
8[label=""Node Type: IF 8

EXPRESSION:
makerBet.outcome == BetOutcome.TakerWin

IRs:
REF_148(InterbetCore.BetOutcome) -> makerBet.outcome
REF_149(InterbetCore.BetOutcome) -> BetOutcome.TakerWin
TMP_201(bool) = REF_148 == REF_149
CONDITION TMP_201""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
payout = sub(makerBet.totalFund,makerBet.reservedFund)

IRs:
REF_150(uint256) -> makerBet.totalFund
REF_151(uint256) -> makerBet.reservedFund
TMP_202(uint256) = INTERNAL_CALL, InterbetCore.sub(uint256,uint256)(REF_150,REF_151)
payout(uint256) := TMP_202(uint256)""];
9->13;
10[label=""Node Type: IF 10

EXPRESSION:
makerBet.outcome == BetOutcome.Draw || makerBet.outcome == BetOutcome.Canceled

IRs:
REF_152(InterbetCore.BetOutcome) -> makerBet.outcome
REF_153(InterbetCore.BetOutcome) -> BetOutcome.Draw
TMP_203(bool) = REF_152 == REF_153
REF_154(InterbetCore.BetOutcome) -> makerBet.outcome
REF_155(InterbetCore.BetOutcome) -> BetOutcome.Canceled
TMP_204(bool) = REF_154 == REF_155
TMP_205(bool) = TMP_203 || TMP_204
CONDITION TMP_205""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
payout = makerBet.totalFund

IRs:
REF_156(uint256) -> makerBet.totalFund
payout(uint256) := REF_156(uint256)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: END_IF 14
""];
14->15;
15[label=""Node Type: IF 15

EXPRESSION:
payout > 0

IRs:
TMP_206(bool) = payout > 0
CONDITION TMP_206""];
15->16[label=""True""];
15->21[label=""False""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
fullyWithdrawn = true

IRs:
fullyWithdrawn(bool) := True(bool)""];
16->17;
17[label=""Node Type: IF 17

EXPRESSION:
! makerBet.maker.send(payout)

IRs:
REF_157(address) -> makerBet.maker
TMP_207 = SEND dest:REF_157 value:payout
TMP_208 = UnaryType.BANG TMP_207 
CONDITION TMP_208""];
17->18[label=""True""];
17->20[label=""False""];
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
makerBet.makerFundWithdrawn = false

IRs:
REF_159(bool) -> makerBet.makerFundWithdrawn
REF_159(bool) (->makerBet) := False(bool)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
fullyWithdrawn = false

IRs:
fullyWithdrawn(bool) := False(bool)""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: END_IF 21
""];
21->22;
22[label=""Node Type: END_IF 22
""];
22->23;
23[label=""Node Type: RETURN 23

EXPRESSION:
fullyWithdrawn

IRs:
RETURN fullyWithdrawn""];
24[label=""Node Type: RETURN 24

EXPRESSION:
fullyWithdrawn

IRs:
RETURN fullyWithdrawn""];
}
",0,0,1,0,"fullyWithdrawn = false;! makerBet.makerFundWithdrawn;makerBet.makerFundWithdrawn = true;;payout = 0;makerBet.outcome == BetOutcome.MakerWin;trustedVerifierFeeMakerWin = mul(makerBet.totalStake,makerBet.trustedVerifier.feeRate) / ((10 ** feeRateDecimals) * 100);makerBet.outcome == BetOutcome.TakerWin;payout = sub(add(makerBet.totalFund,makerBet.totalStake),trustedVerifierFeeMakerWin);;payout = sub(makerBet.totalFund,makerBet.reservedFund);makerBet.outcome == BetOutcome.Draw || makerBet.outcome == BetOutcome.Canceled;;payout = makerBet.totalFund;;payout > 0;fullyWithdrawn = true;;! makerBet.maker.send(payout);makerBet.makerFundWithdrawn = false;;fullyWithdrawn = false;fullyWithdrawn;fullyWithdrawn"
./0x6dbb4e882f967432fc0f9200e9ca577c916d8a68_ext.sol,Bussiness.removePrice,109,114,"TMP_32(address) = HIGH_LEVEL_CALL, dest:erc721Address(IERC721), function:ownerOf, arguments:['tokenId']  ,TMP_33(bool) = TMP_32 == msg.sender,TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33),REF_15(Bussiness.Price) -> prices[tokenId],REF_16(uint256) -> REF_15.fee,TMP_35(bool) = REF_16 > 0,CONDITION TMP_35,REF_18(Bussiness.Price) -> prices[tokenId],REF_19(uint256) -> REF_18.fee,Transfer dest:msg.sender value:REF_19,INTERNAL_CALL, Bussiness.resetPrice(uint256)(tokenId),REF_20(Bussiness.Price) -> prices[tokenId],REF_21(uint256) -> REF_20.price,RETURN REF_21","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(erc721Address.ownerOf(tokenId) == msg.sender)

IRs:
TMP_32(address) = HIGH_LEVEL_CALL, dest:erc721Address(IERC721), function:ownerOf, arguments:['tokenId']  
TMP_33(bool) = TMP_32 == msg.sender
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
prices[tokenId].fee > 0

IRs:
REF_15(Bussiness.Price) -> prices[tokenId]
REF_16(uint256) -> REF_15.fee
TMP_35(bool) = REF_16 > 0
CONDITION TMP_35""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(prices[tokenId].fee)

IRs:
REF_18(Bussiness.Price) -> prices[tokenId]
REF_19(uint256) -> REF_18.fee
Transfer dest:msg.sender value:REF_19""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
resetPrice(tokenId)

IRs:
INTERNAL_CALL, Bussiness.resetPrice(uint256)(tokenId)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
prices[tokenId].price

IRs:
REF_20(Bussiness.Price) -> prices[tokenId]
REF_21(uint256) -> REF_20.price
RETURN REF_21""];
}
",1,0,1,0,require(bool)(erc721Address.ownerOf(tokenId) == msg.sender);prices[tokenId].fee > 0;msg.sender.transfer(prices[tokenId].fee);;resetPrice(tokenId);prices[tokenId].price
./0x4ee1d7720a04072142b2efc9d2c7d5d77ad63939_ext.sol,ARXpresale.refund,233,249,"TMP_158(bool) = amountRaisedInWei < fundingMinCapInWei,TMP_159(bool) = TMP_158 && isPresaleClosed,TMP_160(bool) = block.number > fundingEndBlock,TMP_161(bool) = TMP_159 && TMP_160,REF_5(uint256) -> fundValue[msg.sender],TMP_162(bool) = REF_5 > 0,TMP_163(bool) = TMP_161 && TMP_162,TMP_164(None) = SOLIDITY_CALL require(bool)(TMP_163),REF_6(uint256) -> fundValue[msg.sender],ethRefund(uint256) := REF_6(uint256),REF_7(uint256) -> balances[msg.sender],REF_7(uint256) (->balances) := 0(uint256),REF_8(uint256) -> fundValue[msg.sender],REF_8(uint256) (->fundValue) := 0(uint256),Emit Burn(msg.sender,ethRefund),Transfer dest:msg.sender value:ethRefund,Emit Refund(msg.sender,ethRefund)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((amountRaisedInWei < fundingMinCapInWei) && (isPresaleClosed) && (block.number > fundingEndBlock) && (fundValue[msg.sender] > 0))

IRs:
TMP_158(bool) = amountRaisedInWei < fundingMinCapInWei
TMP_159(bool) = TMP_158 && isPresaleClosed
TMP_160(bool) = block.number > fundingEndBlock
TMP_161(bool) = TMP_159 && TMP_160
REF_5(uint256) -> fundValue[msg.sender]
TMP_162(bool) = REF_5 > 0
TMP_163(bool) = TMP_161 && TMP_162
TMP_164(None) = SOLIDITY_CALL require(bool)(TMP_163)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
ethRefund = fundValue[msg.sender]

IRs:
REF_6(uint256) -> fundValue[msg.sender]
ethRefund(uint256) := REF_6(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = 0

IRs:
REF_7(uint256) -> balances[msg.sender]
REF_7(uint256) (->balances) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
fundValue[msg.sender] = 0

IRs:
REF_8(uint256) -> fundValue[msg.sender]
REF_8(uint256) (->fundValue) := 0(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Burn(msg.sender,ethRefund)

IRs:
Emit Burn(msg.sender,ethRefund)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
msg.sender.transfer(ethRefund)

IRs:
Transfer dest:msg.sender value:ethRefund""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Refund(msg.sender,ethRefund)

IRs:
Emit Refund(msg.sender,ethRefund)""];
}
",0,0,1,0,"require(bool)((amountRaisedInWei < fundingMinCapInWei) && (isPresaleClosed) && (block.number > fundingEndBlock) && (fundValue[msg.sender] > 0));ethRefund = fundValue[msg.sender];balances[msg.sender] = 0;fundValue[msg.sender] = 0;Burn(msg.sender,ethRefund);msg.sender.transfer(ethRefund);Refund(msg.sender,ethRefund)"
./0xa181b8c9f6b43b8252c6c9826cf5feba362b542e_ext.sol,CryptoStamps._payout,682,688,"TMP_138 = CONVERT 0 to address,TMP_139(bool) = _to == TMP_138,CONDITION TMP_139,REF_45(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:ceoAddress value:REF_45,REF_47(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:_to value:REF_47","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_to == address(0)

IRs:
TMP_138 = CONVERT 0 to address
TMP_139(bool) = _to == TMP_138
CONDITION TMP_139""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ceoAddress.transfer(this.balance)

IRs:
REF_45(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:ceoAddress value:REF_45""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_to.transfer(this.balance)

IRs:
REF_47(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:_to value:REF_47""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,_to == address(0);ceoAddress.transfer(this.balance);_to.transfer(this.balance);
./0x6e776e93291620dac8f3dde4a0b98c42a5359293_ext.sol,RefundVault.close,608,613,"REF_118(RefundVault.State) -> State.Active,TMP_255(bool) = state == REF_118,TMP_256(None) = SOLIDITY_CALL require(bool)(TMP_255),REF_119(RefundVault.State) -> State.Closed,state(RefundVault.State) := REF_119(RefundVault.State),Emit Closed(),REF_121(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:wallet value:REF_121,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_118(RefundVault.State) -> State.Active
TMP_255(bool) = state == REF_118
TMP_256(None) = SOLIDITY_CALL require(bool)(TMP_255)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
state = State.Closed

IRs:
REF_119(RefundVault.State) -> State.Closed
state(RefundVault.State) := REF_119(RefundVault.State)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Closed()

IRs:
Emit Closed()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
wallet.transfer(this.balance)

IRs:
REF_121(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:wallet value:REF_121""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();require(bool)(state == State.Active);state = State.Closed;Closed();wallet.transfer(this.balance)
./0x72ebd62060f78d91dc4bc33e8d88f39307365f87_ext.sol,SEA.withdrawEther,146,151,"TMP_103(bool) = msg.sender == owner,TMP_104(None) = SOLIDITY_CALL require(bool)(TMP_103),Transfer dest:owner value:amount,Emit Withdraw(msg.sender,amount),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_103(bool) = msg.sender == owner
TMP_104(None) = SOLIDITY_CALL require(bool)(TMP_103)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(amount)

IRs:
Transfer dest:owner value:amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Withdraw(msg.sender,amount)

IRs:
Emit Withdraw(msg.sender,amount)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: RETURN 5

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,0,1,0,"require(bool)(msg.sender == owner);owner.transfer(amount);Withdraw(msg.sender,amount);true;success"
./0xd37df7051977462c84d2a89cd78a0a91ff85d645_ext.sol,MultiSigWallet.executeTransaction,436,457,"TMP_50(bool) = INTERNAL_CALL, MultiSigWallet.isConfirmed(uint256)(transactionId),CONDITION TMP_50,REF_31(MultiSigWallet.Transaction) -> transactions[transactionId],txn(MultiSigWallet.Transaction) := REF_31(MultiSigWallet.Transaction),REF_32(bool) -> txn.executed,REF_32(bool) (->txn) := True(bool),REF_33(address) -> txn.destination,REF_34(uint256) -> txn.value,REF_35(bytes) -> txn.data,REF_36 -> LENGTH REF_35,REF_37(bytes) -> txn.data,TMP_51(bool) = INTERNAL_CALL, MultiSigWallet.external_call(address,uint256,uint256,bytes)(REF_33,REF_34,REF_36,REF_37),CONDITION TMP_51,Emit Execution(transactionId),Emit ExecutionFailure(transactionId),REF_38(bool) -> txn.executed,REF_38(bool) (->txn) := False(bool),MODIFIER_CALL, MultiSigWallet.ownerExists(address)(msg.sender),MODIFIER_CALL, MultiSigWallet.confirmed(uint256,address)(transactionId,msg.sender),MODIFIER_CALL, MultiSigWallet.notExecuted(uint256)(transactionId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: IF 1

EXPRESSION:
isConfirmed(transactionId)

IRs:
TMP_50(bool) = INTERNAL_CALL, MultiSigWallet.isConfirmed(uint256)(transactionId)
CONDITION TMP_50""];
1->2[label=""True""];
1->9[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
txn = transactions[transactionId]

IRs:
REF_31(MultiSigWallet.Transaction) -> transactions[transactionId]
txn(MultiSigWallet.Transaction) := REF_31(MultiSigWallet.Transaction)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
txn.executed = true

IRs:
REF_32(bool) -> txn.executed
REF_32(bool) (->txn) := True(bool)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
external_call(txn.destination,txn.value,txn.data.length,txn.data)

IRs:
REF_33(address) -> txn.destination
REF_34(uint256) -> txn.value
REF_35(bytes) -> txn.data
REF_36 -> LENGTH REF_35
REF_37(bytes) -> txn.data
TMP_51(bool) = INTERNAL_CALL, MultiSigWallet.external_call(address,uint256,uint256,bytes)(REF_33,REF_34,REF_36,REF_37)
CONDITION TMP_51""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Execution(transactionId)

IRs:
Emit Execution(transactionId)""];
5->8;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
ExecutionFailure(transactionId)

IRs:
Emit ExecutionFailure(transactionId)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
txn.executed = false

IRs:
REF_38(bool) -> txn.executed
REF_38(bool) (->txn) := False(bool)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerExists(address)(msg.sender)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
confirmed(transactionId,msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.confirmed(uint256,address)(transactionId,msg.sender)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, MultiSigWallet.notExecuted(uint256)(transactionId)""];
12->1;
}
",0,0,1,0,"ownerExists(msg.sender);isConfirmed(transactionId);txn = transactions[transactionId];;txn.executed = true;external_call(txn.destination,txn.value,txn.data.length,txn.data);Execution(transactionId);ExecutionFailure(transactionId);;txn.executed = false;confirmed(transactionId,msg.sender);notExecuted(transactionId)"
./0x845bfe096fbe3eabe473edc3953d8af1b19bbbc7_ext.sol,IndTokenPayment.convertToInd,218,226,"TMP_28 = CONVERT 1381834877007002704778750137294666429536329601642 to IBancorNetwork,bancorNetwork(IBancorNetwork) := TMP_28(IBancorNetwork),minReturn(uint256) := 0(uint256),TMP_30(uint256) = HIGH_LEVEL_CALL, dest:bancorNetwork(IBancorNetwork), function:convertFor, arguments:['path', 'msg.value', 'minReturn', 'destinationWallet'] value:msg.value ,convTokens(uint256) := TMP_30(uint256),Emit conversionSucceded(msg.sender,msg.value,destinationWallet,convTokens),MODIFIER_CALL, ReentrancyGuard.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
bancorNetwork = IBancorNetwork(0xF20b9e713A33F61fA38792d2aFaF1cD30339126A)

IRs:
TMP_28 = CONVERT 1381834877007002704778750137294666429536329601642 to IBancorNetwork
bancorNetwork(IBancorNetwork) := TMP_28(IBancorNetwork)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
minReturn = 0

IRs:
minReturn(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
convTokens = bancorNetwork.convertFor.value(msg.value)(path,msg.value,minReturn,destinationWallet)

IRs:
TMP_30(uint256) = HIGH_LEVEL_CALL, dest:bancorNetwork(IBancorNetwork), function:convertFor, arguments:['path', 'msg.value', 'minReturn', 'destinationWallet'] value:msg.value 
convTokens(uint256) := TMP_30(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
conversionSucceded(msg.sender,msg.value,destinationWallet,convTokens)

IRs:
Emit conversionSucceded(msg.sender,msg.value,destinationWallet,convTokens)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, ReentrancyGuard.nonReentrant()()""];
5->1;
}
",0,0,1,0,"nonReentrant();bancorNetwork = IBancorNetwork(0xF20b9e713A33F61fA38792d2aFaF1cD30339126A);minReturn = 0;convTokens = bancorNetwork.convertFor.value(msg.value)(path,msg.value,minReturn,destinationWallet);conversionSucceded(msg.sender,msg.value,destinationWallet,convTokens)"
./0x1d9be4a5681374c54b1821d0beac3a678ad128a4_ext.sol,StorageController.withdrawEth,748,754,"TMP_465(uint256) = 0 * 1000000000000000000,TMP_466(bool) = _value >= TMP_465,TMP_467(None) = SOLIDITY_CALL require(bool)(TMP_466),REF_134(uint256) = SOLIDITY_CALL balance(address)(this),TMP_468(bool) = REF_134 < _value,CONDITION TMP_468,REF_135(uint256) = SOLIDITY_CALL balance(address)(this),_value(uint256) := REF_135([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B93D0700>]),Transfer dest:_userAddress value:_value,MODIFIER_CALL, StorageController.onlyManagerOrCreator()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value >= 0.1 * 1000000000000000000)

IRs:
TMP_465(uint256) = 0 * 1000000000000000000
TMP_466(bool) = _value >= TMP_465
TMP_467(None) = SOLIDITY_CALL require(bool)(TMP_466)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
this.balance < _value

IRs:
REF_134(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_468(bool) = REF_134 < _value
CONDITION TMP_468""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_value = this.balance

IRs:
REF_135(uint256) = SOLIDITY_CALL balance(address)(this)
_value(uint256) := REF_135([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B93D0700>])""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_userAddress.transfer(_value)

IRs:
Transfer dest:_userAddress value:_value""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyManagerOrCreator()

IRs:
MODIFIER_CALL, StorageController.onlyManagerOrCreator()()""];
6->1;
}
",0,0,1,0,onlyManagerOrCreator();require(bool)(_value >= 0.1 * 1000000000000000000);this.balance < _value;_value = this.balance;;_userAddress.transfer(_value)
./0x86c6a7ee4ec24d25456580d81f7e8f486186ec91_ext.sol,Coin.kill,61,64,"TMP_6(bool) = workingState == False,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),TMP_8(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Coin.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(workingState == false)

IRs:
TMP_6(bool) = workingState == False
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_8(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Coin.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();require(bool)(workingState == false);selfdestruct(address)(owner)
./0xdb09aba26e7a54f95951defc0a56b7f11a5ef023_ext.sol,Presale.emergencyWithdrawal,365,367,"Transfer dest:withdrawAddress value:_amount,MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, Haltable.onlyInEmergency()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
withdrawAddress.transfer(_amount)

IRs:
Transfer dest:withdrawAddress value:_amount""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyInEmergency()

IRs:
MODIFIER_CALL, Haltable.onlyInEmergency()()""];
3->1;
}
",0,0,1,0,onlyOwner();withdrawAddress.transfer(_amount);onlyInEmergency()
./0x46d1ebf7bb93044e078e0496e4661ec772607d9d_ext.sol,TTCSale.ownerSafeWithdrawal,661,666,"TMP_236(None) = SOLIDITY_CALL require(bool)(fundingGoalReached),REF_131(uint256) = SOLIDITY_CALL balance(address)(this),balanceToSend(uint256) := REF_131([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E3CF0640>]),Transfer dest:beneficiary value:balanceToSend,Emit FundTransfer(beneficiary,balanceToSend,False),MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, TTCSale.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(fundingGoalReached)

IRs:
TMP_236(None) = SOLIDITY_CALL require(bool)(fundingGoalReached)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
balanceToSend = this.balance

IRs:
REF_131(uint256) = SOLIDITY_CALL balance(address)(this)
balanceToSend(uint256) := REF_131([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E3CF0640>])""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
beneficiary.transfer(balanceToSend)

IRs:
Transfer dest:beneficiary value:balanceToSend""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
FundTransfer(beneficiary,balanceToSend,false)

IRs:
Emit FundTransfer(beneficiary,balanceToSend,False)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, TTCSale.nonReentrant()()""];
6->1;
}
",0,0,1,0,"onlyOwner();require(bool)(fundingGoalReached);balanceToSend = this.balance;beneficiary.transfer(balanceToSend);FundTransfer(beneficiary,balanceToSend,false);nonReentrant()"
./0x533ec971484b1014215422010978e892eacac430_ext.sol,MortifyAsset.withdraw,294,297,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, MortifyAsset.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MortifyAsset.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x93143d3e34a50aebab466368c3455fd858f77ad3_ext.sol,FourOutOfFive.claimReward,116,148,"REF_25(FourOutOfFive.GroupData) -> Groups[_groupId],REF_26(bool) -> REF_25.completed,TMP_36(bool) = REF_26 == True,TMP_37(None) = SOLIDITY_CALL require(bool,string)(TMP_36,Groups is not completed),REF_27(FourOutOfFive.GroupData) -> Groups[_groupId],REF_28(uint8) -> REF_27.rewardsAvailable,TMP_38(bool) = REF_28 > 0,TMP_39(None) = SOLIDITY_CALL require(bool,string)(TMP_38,No reward found.),i(uint8) := 0(uint256),REF_29(FourOutOfFive.GroupData) -> Groups[_groupId],REF_30(address[]) -> REF_29.participants,REF_31 -> LENGTH REF_30,TMP_40(bool) = i < REF_31,CONDITION TMP_40,REF_32(FourOutOfFive.GroupData) -> Groups[_groupId],REF_33(address[]) -> REF_32.participants,REF_34(address) -> REF_33[i],TMP_41(bool) = REF_34 == msg.sender,CONDITION TMP_41,rewardsTotal(uint8) = rewardsTotal + 1,TMP_42(uint8) := i(uint8),i(uint8) = i + 1,j(uint8) := 0(uint256),REF_35(FourOutOfFive.GroupData) -> Groups[_groupId],REF_36(address[]) -> REF_35.rewardedParticipants,REF_37 -> LENGTH REF_36,TMP_43(bool) = j < REF_37,CONDITION TMP_43,REF_38(FourOutOfFive.GroupData) -> Groups[_groupId],REF_39(address[]) -> REF_38.rewardedParticipants,REF_40(address) -> REF_39[j],TMP_44(bool) = REF_40 == msg.sender,CONDITION TMP_44,rewardsClaimed(uint8) = rewardsClaimed + 1,TMP_45(uint8) := j(uint8),j(uint8) = j + 1,TMP_46(bool) = rewardsTotal > rewardsClaimed,TMP_47(None) = SOLIDITY_CALL require(bool,string)(TMP_46,No rewards found for this user),REF_41(FourOutOfFive.GroupData) -> Groups[_groupId],REF_42(address[]) -> REF_41.rewardedParticipants,REF_44 -> LENGTH REF_42,TMP_49(uint256) := REF_44(uint256),TMP_50(uint256) = TMP_49 + 1,REF_44(uint256) (->Groups) := TMP_50(uint256),REF_45(address) -> REF_42[TMP_49],REF_45(address) (->Groups) := msg.sender(address),REF_46(FourOutOfFive.GroupData) -> Groups[_groupId],REF_47(uint256) -> REF_46.rewardSize,Emit RewardClaimed(_groupId,msg.sender,REF_47,block.timestamp),REF_48(FourOutOfFive.GroupData) -> Groups[_groupId],REF_49(uint8) -> REF_48.rewardsAvailable,REF_49(-> Groups) = REF_49 - 1,REF_51(FourOutOfFive.GroupData) -> Groups[_groupId],REF_52(uint256) -> REF_51.rewardSize,Transfer dest:msg.sender value:REF_52","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(Groups[_groupId].completed == true,Groups is not completed)

IRs:
REF_25(FourOutOfFive.GroupData) -> Groups[_groupId]
REF_26(bool) -> REF_25.completed
TMP_36(bool) = REF_26 == True
TMP_37(None) = SOLIDITY_CALL require(bool,string)(TMP_36,Groups is not completed)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(Groups[_groupId].rewardsAvailable > 0,No reward found.)

IRs:
REF_27(FourOutOfFive.GroupData) -> Groups[_groupId]
REF_28(uint8) -> REF_27.rewardsAvailable
TMP_38(bool) = REF_28 > 0
TMP_39(None) = SOLIDITY_CALL require(bool,string)(TMP_38,No reward found.)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4
""];
4->7;
5[label=""Node Type: BEGIN_LOOP 5
""];
5->8;
6[label=""Node Type: END_LOOP 6
""];
6->15;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)""];
7->5;
8[label=""Node Type: IF_LOOP 8

EXPRESSION:
i < Groups[_groupId].participants.length

IRs:
REF_29(FourOutOfFive.GroupData) -> Groups[_groupId]
REF_30(address[]) -> REF_29.participants
REF_31 -> LENGTH REF_30
TMP_40(bool) = i < REF_31
CONDITION TMP_40""];
8->9[label=""True""];
8->6[label=""False""];
9[label=""Node Type: IF 9

EXPRESSION:
Groups[_groupId].participants[i] == msg.sender

IRs:
REF_32(FourOutOfFive.GroupData) -> Groups[_groupId]
REF_33(address[]) -> REF_32.participants
REF_34(address) -> REF_33[i]
TMP_41(bool) = REF_34 == msg.sender
CONDITION TMP_41""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
rewardsTotal += 1

IRs:
rewardsTotal(uint8) = rewardsTotal + 1""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_42(uint8) := i(uint8)
i(uint8) = i + 1""];
12->8;
13[label=""Node Type: BEGIN_LOOP 13
""];
13->16;
14[label=""Node Type: END_LOOP 14
""];
14->21;
15[label=""Node Type: NEW VARIABLE 15

EXPRESSION:
j = 0

IRs:
j(uint8) := 0(uint256)""];
15->13;
16[label=""Node Type: IF_LOOP 16

EXPRESSION:
j < Groups[_groupId].rewardedParticipants.length

IRs:
REF_35(FourOutOfFive.GroupData) -> Groups[_groupId]
REF_36(address[]) -> REF_35.rewardedParticipants
REF_37 -> LENGTH REF_36
TMP_43(bool) = j < REF_37
CONDITION TMP_43""];
16->17[label=""True""];
16->14[label=""False""];
17[label=""Node Type: IF 17

EXPRESSION:
Groups[_groupId].rewardedParticipants[j] == msg.sender

IRs:
REF_38(FourOutOfFive.GroupData) -> Groups[_groupId]
REF_39(address[]) -> REF_38.rewardedParticipants
REF_40(address) -> REF_39[j]
TMP_44(bool) = REF_40 == msg.sender
CONDITION TMP_44""];
17->18[label=""True""];
17->19[label=""False""];
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
rewardsClaimed += 1

IRs:
rewardsClaimed(uint8) = rewardsClaimed + 1""];
18->19;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
j ++

IRs:
TMP_45(uint8) := j(uint8)
j(uint8) = j + 1""];
20->16;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
require(bool,string)(rewardsTotal > rewardsClaimed,No rewards found for this user)

IRs:
TMP_46(bool) = rewardsTotal > rewardsClaimed
TMP_47(None) = SOLIDITY_CALL require(bool,string)(TMP_46,No rewards found for this user)""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
Groups[_groupId].rewardedParticipants.push(msg.sender)

IRs:
REF_41(FourOutOfFive.GroupData) -> Groups[_groupId]
REF_42(address[]) -> REF_41.rewardedParticipants
REF_44 -> LENGTH REF_42
TMP_49(uint256) := REF_44(uint256)
TMP_50(uint256) = TMP_49 + 1
REF_44(uint256) (->Groups) := TMP_50(uint256)
REF_45(address) -> REF_42[TMP_49]
REF_45(address) (->Groups) := msg.sender(address)""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
RewardClaimed(_groupId,msg.sender,Groups[_groupId].rewardSize,block.timestamp)

IRs:
REF_46(FourOutOfFive.GroupData) -> Groups[_groupId]
REF_47(uint256) -> REF_46.rewardSize
Emit RewardClaimed(_groupId,msg.sender,REF_47,block.timestamp)""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
Groups[_groupId].rewardsAvailable -= 1

IRs:
REF_48(FourOutOfFive.GroupData) -> Groups[_groupId]
REF_49(uint8) -> REF_48.rewardsAvailable
REF_49(-> Groups) = REF_49 - 1""];
24->25;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
msg.sender.transfer(Groups[_groupId].rewardSize)

IRs:
REF_51(FourOutOfFive.GroupData) -> Groups[_groupId]
REF_52(uint256) -> REF_51.rewardSize
Transfer dest:msg.sender value:REF_52""];
}
",0,0,1,0,"require(bool,string)(Groups[_groupId].completed == true,Groups is not completed);require(bool,string)(Groups[_groupId].rewardsAvailable > 0,No reward found.);;;i = 0;;i < Groups[_groupId].participants.length;;j = 0;Groups[_groupId].participants[i] == msg.sender;rewardsTotal += 1;;i ++;;j < Groups[_groupId].rewardedParticipants.length;;require(bool,string)(rewardsTotal > rewardsClaimed,No rewards found for this user);Groups[_groupId].rewardedParticipants[j] == msg.sender;rewardsClaimed += 1;;j ++;Groups[_groupId].rewardedParticipants.push(msg.sender);RewardClaimed(_groupId,msg.sender,Groups[_groupId].rewardSize,block.timestamp);Groups[_groupId].rewardsAvailable -= 1;msg.sender.transfer(Groups[_groupId].rewardSize)"
./0xd64e5b228561225b437dc38b81891c15fe98cfee_ext.sol,NYXAccount.transferByOwner,110,121,"REF_4(NYXAccount.Stages) -> Stages.Normal,TMP_6(bool) = stage == REF_4,TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6),REF_5(uint256) = SOLIDITY_CALL balance(address)(this),TMP_8(bool) = amount <= REF_5,TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8),TMP_10 = CONVERT 0 to address,TMP_11(bool) = recipient != TMP_10,TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11),Transfer dest:recipient value:amount,lastExpenseTime(uint256) := now(uint256),MODIFIER_CALL, NYXAccount.onlyByOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(stage == Stages.Normal)

IRs:
REF_4(NYXAccount.Stages) -> Stages.Normal
TMP_6(bool) = stage == REF_4
TMP_7(None) = SOLIDITY_CALL require(bool)(TMP_6)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(amount <= this.balance)

IRs:
REF_5(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_8(bool) = amount <= REF_5
TMP_9(None) = SOLIDITY_CALL require(bool)(TMP_8)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(recipient != address(0x0))

IRs:
TMP_10 = CONVERT 0 to address
TMP_11(bool) = recipient != TMP_10
TMP_12(None) = SOLIDITY_CALL require(bool)(TMP_11)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
recipient.transfer(amount)

IRs:
Transfer dest:recipient value:amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
lastExpenseTime = now

IRs:
lastExpenseTime(uint256) := now(uint256)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyByOwner()

IRs:
MODIFIER_CALL, NYXAccount.onlyByOwner()()""];
6->1;
}
",0,0,1,0,onlyByOwner();require(bool)(stage == Stages.Normal);require(bool)(amount <= this.balance);require(bool)(recipient != address(0x0));recipient.transfer(amount);lastExpenseTime = now
./0x5a8658de344972fc8b6b6a01cd87a64bc7420a38_ext.sol,EPXCrowdsale.refund,232,252,"TMP_144(bool) = amountRaisedInWei < fundingMinCapInWei,TMP_145(bool) = TMP_144 && isCrowdSaleClosed,TMP_146(bool) = block.number > fundingEndBlock,TMP_147(bool) = TMP_145 && TMP_146,REF_5(uint256) -> usersEPXfundValue[msg.sender],TMP_148(bool) = REF_5 > 0,TMP_149(bool) = TMP_147 && TMP_148,TMP_150(None) = SOLIDITY_CALL require(bool)(TMP_149),REF_6(uint256) -> usersEPXfundValue[msg.sender],ethRefund(uint256) := REF_6(uint256),REF_7(uint256) -> balancesArray[msg.sender],REF_7(uint256) (->balancesArray) := 0(uint256),REF_8(uint256) -> usersEPXfundValue[msg.sender],REF_8(uint256) (->usersEPXfundValue) := 0(uint256),REF_9(uint256) -> usersEPXfundValue[msg.sender],Emit Burn(msg.sender,REF_9),Transfer dest:msg.sender value:ethRefund,Emit Refund(msg.sender,ethRefund)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((amountRaisedInWei < fundingMinCapInWei) && (isCrowdSaleClosed) && (block.number > fundingEndBlock) && (usersEPXfundValue[msg.sender] > 0))

IRs:
TMP_144(bool) = amountRaisedInWei < fundingMinCapInWei
TMP_145(bool) = TMP_144 && isCrowdSaleClosed
TMP_146(bool) = block.number > fundingEndBlock
TMP_147(bool) = TMP_145 && TMP_146
REF_5(uint256) -> usersEPXfundValue[msg.sender]
TMP_148(bool) = REF_5 > 0
TMP_149(bool) = TMP_147 && TMP_148
TMP_150(None) = SOLIDITY_CALL require(bool)(TMP_149)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
ethRefund = usersEPXfundValue[msg.sender]

IRs:
REF_6(uint256) -> usersEPXfundValue[msg.sender]
ethRefund(uint256) := REF_6(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balancesArray[msg.sender] = 0

IRs:
REF_7(uint256) -> balancesArray[msg.sender]
REF_7(uint256) (->balancesArray) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
usersEPXfundValue[msg.sender] = 0

IRs:
REF_8(uint256) -> usersEPXfundValue[msg.sender]
REF_8(uint256) (->usersEPXfundValue) := 0(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Burn(msg.sender,usersEPXfundValue[msg.sender])

IRs:
REF_9(uint256) -> usersEPXfundValue[msg.sender]
Emit Burn(msg.sender,REF_9)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
msg.sender.transfer(ethRefund)

IRs:
Transfer dest:msg.sender value:ethRefund""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
Refund(msg.sender,ethRefund)

IRs:
Emit Refund(msg.sender,ethRefund)""];
}
",0,0,1,0,"require(bool)((amountRaisedInWei < fundingMinCapInWei) && (isCrowdSaleClosed) && (block.number > fundingEndBlock) && (usersEPXfundValue[msg.sender] > 0));ethRefund = usersEPXfundValue[msg.sender];balancesArray[msg.sender] = 0;usersEPXfundValue[msg.sender] = 0;Burn(msg.sender,usersEPXfundValue[msg.sender]);msg.sender.transfer(ethRefund);Refund(msg.sender,ethRefund)"
./0x45afe0ff6a92bc9f346fc440a9d2a881d42094ff_ext.sol,Destructible.destroy,343,345,"TMP_192(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_192(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0x4c747b6ac42118186d83dac6a2e3994284711334_ext.sol,Allfa_QUiZ.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x7fceafdefc16b0f703a43ffb0451ddd2a7cbd6dc_ext.sol,alfa_Quiz.Try,3,11,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x791af5fcb5198c9f469d66b934864dab43d7f044_ext.sol,Verus.getTokens,182,242,"tokens(uint256) := 0(uint256),bonus(uint256) := 0(uint256),countbonus(uint256) := 0(uint256),TMP_45(uint256) = 1000000000000000000 / 10,bonusCond1(uint256) := TMP_45(uint256),bonusCond2(uint256) := 1000000000000000000(uint256),bonusCond3(uint256) := 5000000000000000000(uint256),TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_47(uint256) = TMP_46 / 1000000000000000000,tokens(uint256) := TMP_47(uint256),investor(address) := msg.sender(address),TMP_48(bool) = msg.value >= requestMinimum,TMP_49(bool) = now < deadline,TMP_50(bool) = TMP_48 && TMP_49,TMP_51(bool) = now < round1,TMP_52(bool) = TMP_50 && TMP_51,TMP_53(bool) = now < round2,TMP_54(bool) = TMP_52 && TMP_53,CONDITION TMP_54,TMP_55(bool) = msg.value >= bonusCond1,TMP_56(bool) = msg.value < bonusCond2,TMP_57(bool) = TMP_55 && TMP_56,CONDITION TMP_57,TMP_58(uint256) = tokens * 20,TMP_59(uint256) = TMP_58 / 100,countbonus(uint256) := TMP_59(uint256),TMP_60(bool) = msg.value >= bonusCond2,TMP_61(bool) = msg.value < bonusCond3,TMP_62(bool) = TMP_60 && TMP_61,CONDITION TMP_62,TMP_63(uint256) = tokens * 20,TMP_64(uint256) = TMP_63 / 100,countbonus(uint256) := TMP_64(uint256),TMP_65(bool) = msg.value >= bonusCond3,CONDITION TMP_65,TMP_66(uint256) = tokens * 20,TMP_67(uint256) = TMP_66 / 100,countbonus(uint256) := TMP_67(uint256),TMP_68(bool) = msg.value >= requestMinimum,TMP_69(bool) = now < deadline,TMP_70(bool) = TMP_68 && TMP_69,TMP_71(bool) = now > round1,TMP_72(bool) = TMP_70 && TMP_71,TMP_73(bool) = now < round2,TMP_74(bool) = TMP_72 && TMP_73,CONDITION TMP_74,TMP_75(bool) = msg.value >= bonusCond2,TMP_76(bool) = msg.value < bonusCond3,TMP_77(bool) = TMP_75 && TMP_76,CONDITION TMP_77,TMP_78(uint256) = tokens * 20,TMP_79(uint256) = TMP_78 / 100,countbonus(uint256) := TMP_79(uint256),TMP_80(bool) = msg.value >= bonusCond3,CONDITION TMP_80,TMP_81(uint256) = tokens * 20,TMP_82(uint256) = TMP_81 / 100,countbonus(uint256) := TMP_82(uint256),countbonus(uint256) := 0(uint256),TMP_83(uint256) = tokens + countbonus,bonus(uint256) := TMP_83(uint256),TMP_84(bool) = tokens == 0,CONDITION TMP_84,valdrop(uint256) := 750000000000000000000(uint256),REF_12(bool) -> Claimed[investor],TMP_85(bool) = REF_12 == False,TMP_86(bool) = progress0drop <= target0drop,TMP_87(bool) = TMP_85 && TMP_86,CONDITION TMP_87,TMP_88(bool) = INTERNAL_CALL, Verus.distr(address,uint256)(investor,valdrop),REF_13(bool) -> Claimed[investor],REF_13(bool) (->Claimed) := True(bool),TMP_89(uint256) := progress0drop(uint256),progress0drop(uint256) = progress0drop + 1,TMP_90(bool) = msg.value >= requestMinimum,TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),TMP_92(bool) = tokens > 0,TMP_93(bool) = msg.value >= requestMinimum,TMP_94(bool) = TMP_92 && TMP_93,CONDITION TMP_94,TMP_95(bool) = now >= deadline,TMP_96(bool) = now >= round1,TMP_97(bool) = TMP_95 && TMP_96,TMP_98(bool) = now < round2,TMP_99(bool) = TMP_97 && TMP_98,CONDITION TMP_99,TMP_100(bool) = INTERNAL_CALL, Verus.distr(address,uint256)(investor,tokens),TMP_101(bool) = msg.value >= bonusCond1,CONDITION TMP_101,TMP_102(bool) = INTERNAL_CALL, Verus.distr(address,uint256)(investor,bonus),TMP_103(bool) = INTERNAL_CALL, Verus.distr(address,uint256)(investor,tokens),TMP_104(bool) = msg.value >= requestMinimum,TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104),TMP_106(bool) = totalDistributed >= totalSupply,CONDITION TMP_106,distributionFinished(bool) := True(bool),Transfer dest:multisig value:msg.value,MODIFIER_CALL, Verus.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->53;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bonusCond1 = 1000000000000000000 / 10

IRs:
TMP_45(uint256) = 1000000000000000000 / 10
bonusCond1(uint256) := TMP_45(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bonusCond2 = 1000000000000000000

IRs:
bonusCond2(uint256) := 1000000000000000000(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
bonusCond3 = 5000000000000000000

IRs:
bonusCond3(uint256) := 5000000000000000000(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_47(uint256) = TMP_46 / 1000000000000000000
tokens(uint256) := TMP_47(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now < round1 && now < round2

IRs:
TMP_48(bool) = msg.value >= requestMinimum
TMP_49(bool) = now < deadline
TMP_50(bool) = TMP_48 && TMP_49
TMP_51(bool) = now < round1
TMP_52(bool) = TMP_50 && TMP_51
TMP_53(bool) = now < round2
TMP_54(bool) = TMP_52 && TMP_53
CONDITION TMP_54""];
9->10[label=""True""];
9->19[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
msg.value >= bonusCond1 && msg.value < bonusCond2

IRs:
TMP_55(bool) = msg.value >= bonusCond1
TMP_56(bool) = msg.value < bonusCond2
TMP_57(bool) = TMP_55 && TMP_56
CONDITION TMP_57""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
countbonus = tokens * 20 / 100

IRs:
TMP_58(uint256) = tokens * 20
TMP_59(uint256) = TMP_58 / 100
countbonus(uint256) := TMP_59(uint256)""];
11->18;
12[label=""Node Type: IF 12

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_60(bool) = msg.value >= bonusCond2
TMP_61(bool) = msg.value < bonusCond3
TMP_62(bool) = TMP_60 && TMP_61
CONDITION TMP_62""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
countbonus = tokens * 20 / 100

IRs:
TMP_63(uint256) = tokens * 20
TMP_64(uint256) = TMP_63 / 100
countbonus(uint256) := TMP_64(uint256)""];
13->17;
14[label=""Node Type: IF 14

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_65(bool) = msg.value >= bonusCond3
CONDITION TMP_65""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
countbonus = tokens * 20 / 100

IRs:
TMP_66(uint256) = tokens * 20
TMP_67(uint256) = TMP_66 / 100
countbonus(uint256) := TMP_67(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->28;
19[label=""Node Type: IF 19

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now > round1 && now < round2

IRs:
TMP_68(bool) = msg.value >= requestMinimum
TMP_69(bool) = now < deadline
TMP_70(bool) = TMP_68 && TMP_69
TMP_71(bool) = now > round1
TMP_72(bool) = TMP_70 && TMP_71
TMP_73(bool) = now < round2
TMP_74(bool) = TMP_72 && TMP_73
CONDITION TMP_74""];
19->20[label=""True""];
19->26[label=""False""];
20[label=""Node Type: IF 20

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_75(bool) = msg.value >= bonusCond2
TMP_76(bool) = msg.value < bonusCond3
TMP_77(bool) = TMP_75 && TMP_76
CONDITION TMP_77""];
20->21[label=""True""];
20->22[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
countbonus = tokens * 20 / 100

IRs:
TMP_78(uint256) = tokens * 20
TMP_79(uint256) = TMP_78 / 100
countbonus(uint256) := TMP_79(uint256)""];
21->25;
22[label=""Node Type: IF 22

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_80(bool) = msg.value >= bonusCond3
CONDITION TMP_80""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
countbonus = tokens * 20 / 100

IRs:
TMP_81(uint256) = tokens * 20
TMP_82(uint256) = TMP_81 / 100
countbonus(uint256) := TMP_82(uint256)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->27;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
bonus = tokens + countbonus

IRs:
TMP_83(uint256) = tokens + countbonus
bonus(uint256) := TMP_83(uint256)""];
29->30;
30[label=""Node Type: IF 30

EXPRESSION:
tokens == 0

IRs:
TMP_84(bool) = tokens == 0
CONDITION TMP_84""];
30->31[label=""True""];
30->38[label=""False""];
31[label=""Node Type: NEW VARIABLE 31

EXPRESSION:
valdrop = 750e18

IRs:
valdrop(uint256) := 750000000000000000000(uint256)""];
31->32;
32[label=""Node Type: IF 32

EXPRESSION:
Claimed[investor] == false && progress0drop <= target0drop

IRs:
REF_12(bool) -> Claimed[investor]
TMP_85(bool) = REF_12 == False
TMP_86(bool) = progress0drop <= target0drop
TMP_87(bool) = TMP_85 && TMP_86
CONDITION TMP_87""];
32->33[label=""True""];
32->36[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
distr(investor,valdrop)

IRs:
TMP_88(bool) = INTERNAL_CALL, Verus.distr(address,uint256)(investor,valdrop)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
Claimed[investor] = true

IRs:
REF_13(bool) -> Claimed[investor]
REF_13(bool) (->Claimed) := True(bool)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
progress0drop ++

IRs:
TMP_89(uint256) := progress0drop(uint256)
progress0drop(uint256) = progress0drop + 1""];
35->37;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_90(bool) = msg.value >= requestMinimum
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
36->37;
37[label=""Node Type: END_IF 37
""];
37->48;
38[label=""Node Type: IF 38

EXPRESSION:
tokens > 0 && msg.value >= requestMinimum

IRs:
TMP_92(bool) = tokens > 0
TMP_93(bool) = msg.value >= requestMinimum
TMP_94(bool) = TMP_92 && TMP_93
CONDITION TMP_94""];
38->39[label=""True""];
38->46[label=""False""];
39[label=""Node Type: IF 39

EXPRESSION:
now >= deadline && now >= round1 && now < round2

IRs:
TMP_95(bool) = now >= deadline
TMP_96(bool) = now >= round1
TMP_97(bool) = TMP_95 && TMP_96
TMP_98(bool) = now < round2
TMP_99(bool) = TMP_97 && TMP_98
CONDITION TMP_99""];
39->40[label=""True""];
39->41[label=""False""];
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_100(bool) = INTERNAL_CALL, Verus.distr(address,uint256)(investor,tokens)""];
40->45;
41[label=""Node Type: IF 41

EXPRESSION:
msg.value >= bonusCond1

IRs:
TMP_101(bool) = msg.value >= bonusCond1
CONDITION TMP_101""];
41->42[label=""True""];
41->43[label=""False""];
42[label=""Node Type: EXPRESSION 42

EXPRESSION:
distr(investor,bonus)

IRs:
TMP_102(bool) = INTERNAL_CALL, Verus.distr(address,uint256)(investor,bonus)""];
42->44;
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_103(bool) = INTERNAL_CALL, Verus.distr(address,uint256)(investor,tokens)""];
43->44;
44[label=""Node Type: END_IF 44
""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->47;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_104(bool) = msg.value >= requestMinimum
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: IF 49

EXPRESSION:
totalDistributed >= totalSupply

IRs:
TMP_106(bool) = totalDistributed >= totalSupply
CONDITION TMP_106""];
49->50[label=""True""];
49->51[label=""False""];
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
multisig.transfer(msg.value)

IRs:
Transfer dest:multisig value:msg.value""];
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, Verus.canDistr()()""];
53->1;
}
",0,0,1,0,"canDistr();tokens = 0;bonus = 0;countbonus = 0;bonusCond1 = 1000000000000000000 / 10;bonusCond2 = 1000000000000000000;bonusCond3 = 5000000000000000000;tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;investor = msg.sender;msg.value >= requestMinimum && now < deadline && now < round1 && now < round2;msg.value >= bonusCond1 && msg.value < bonusCond2;msg.value >= requestMinimum && now < deadline && now > round1 && now < round2;countbonus = tokens * 20 / 100;msg.value >= bonusCond2 && msg.value < bonusCond3;;countbonus = tokens * 20 / 100;msg.value >= bonusCond3;;countbonus = tokens * 20 / 100;;;msg.value >= bonusCond2 && msg.value < bonusCond3;countbonus = 0;countbonus = tokens * 20 / 100;msg.value >= bonusCond3;;countbonus = tokens * 20 / 100;;;bonus = tokens + countbonus;tokens == 0;valdrop = 750e18;tokens > 0 && msg.value >= requestMinimum;Claimed[investor] == false && progress0drop <= target0drop;distr(investor,valdrop);require(bool)(msg.value >= requestMinimum);Claimed[investor] = true;progress0drop ++;;;now >= deadline && now >= round1 && now < round2;require(bool)(msg.value >= requestMinimum);distr(investor,tokens);msg.value >= bonusCond1;;distr(investor,bonus);distr(investor,tokens);;;totalDistributed >= totalSupply;distributionFinished = true;;multisig.transfer(msg.value)"
./0x402cd1fa4ba4296f5503d1e86214b77ec7cfe840_ext.sol,Crowdsale.safeWithdrawal,98,119,"TMP_45 = UnaryType.BANG fundingGoalReached ,CONDITION TMP_45,REF_6(uint256) -> balanceOf[msg.sender],amount(uint256) := REF_6(uint256),REF_7(uint256) -> balanceOf[msg.sender],REF_7(uint256) (->balanceOf) := 0(uint256),TMP_46(bool) = amount > 0,CONDITION TMP_46,TMP_47 = SEND dest:msg.sender value:amount,CONDITION TMP_47,Emit FundTransfer(msg.sender,amount,False),REF_9(uint256) -> balanceOf[msg.sender],REF_9(uint256) (->balanceOf) := amount(uint256),TMP_49(bool) = beneficiary == msg.sender,TMP_50(bool) = fundingGoalReached && TMP_49,CONDITION TMP_50,TMP_51 = SEND dest:beneficiary value:amountRaised,CONDITION TMP_51,Emit FundTransfer(beneficiary,amountRaised,False),fundingGoalReached(bool) := False(bool),MODIFIER_CALL, Crowdsale.afterDeadline()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->17;
1[label=""Node Type: IF 1

EXPRESSION:
! fundingGoalReached

IRs:
TMP_45 = UnaryType.BANG fundingGoalReached 
CONDITION TMP_45""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = balanceOf[msg.sender]

IRs:
REF_6(uint256) -> balanceOf[msg.sender]
amount(uint256) := REF_6(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[msg.sender] = 0

IRs:
REF_7(uint256) -> balanceOf[msg.sender]
REF_7(uint256) (->balanceOf) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
amount > 0

IRs:
TMP_46(bool) = amount > 0
CONDITION TMP_46""];
4->5[label=""True""];
4->9[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
msg.sender.send(amount)

IRs:
TMP_47 = SEND dest:msg.sender value:amount
CONDITION TMP_47""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
FundTransfer(msg.sender,amount,false)

IRs:
Emit FundTransfer(msg.sender,amount,False)""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balanceOf[msg.sender] = amount

IRs:
REF_9(uint256) -> balanceOf[msg.sender]
REF_9(uint256) (->balanceOf) := amount(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
fundingGoalReached && beneficiary == msg.sender

IRs:
TMP_49(bool) = beneficiary == msg.sender
TMP_50(bool) = fundingGoalReached && TMP_49
CONDITION TMP_50""];
11->12[label=""True""];
11->16[label=""False""];
12[label=""Node Type: IF 12

EXPRESSION:
beneficiary.send(amountRaised)

IRs:
TMP_51 = SEND dest:beneficiary value:amountRaised
CONDITION TMP_51""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
FundTransfer(beneficiary,amountRaised,false)

IRs:
Emit FundTransfer(beneficiary,amountRaised,False)""];
13->15;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
fundingGoalReached = false

IRs:
fundingGoalReached(bool) := False(bool)""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: END_IF 16
""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
afterDeadline()

IRs:
MODIFIER_CALL, Crowdsale.afterDeadline()()""];
17->1;
}
",0,0,1,0,"afterDeadline();! fundingGoalReached;amount = balanceOf[msg.sender];;balanceOf[msg.sender] = 0;amount > 0;msg.sender.send(amount);;FundTransfer(msg.sender,amount,false);balanceOf[msg.sender] = amount;;fundingGoalReached && beneficiary == msg.sender;beneficiary.send(amountRaised);;FundTransfer(beneficiary,amountRaised,false);fundingGoalReached = false;"
./0xeb0335a35d10cab0c0d615d999d657a50cfd44f0_ext.sol,asssderf.fallback,7,22,"REF_0(uint256) -> hodlers[msg.sender],REF_0(-> hodlers) = REF_0 + msg.value,Emit Hodl(msg.sender,msg.value),TMP_1(bool) = msg.value == 0,CONDITION TMP_1,TMP_2(bool) = block.timestamp > partyTime,REF_1(uint256) -> hodlers[msg.sender],TMP_3(bool) = REF_1 > 0,TMP_4(bool) = TMP_2 && TMP_3,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_2(uint256) -> hodlers[msg.sender],value(uint256) := REF_2(uint256),REF_3(uint256) -> hodlers[msg.sender],REF_3(uint256) (->hodlers) := 0(uint256),Transfer dest:msg.sender value:value,Emit Party(msg.sender,value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
hodlers[msg.sender] += msg.value

IRs:
REF_0(uint256) -> hodlers[msg.sender]
REF_0(-> hodlers) = REF_0 + msg.value""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Hodl(msg.sender,msg.value)

IRs:
Emit Hodl(msg.sender,msg.value)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
msg.value == 0

IRs:
TMP_1(bool) = msg.value == 0
CONDITION TMP_1""];
3->4[label=""True""];
3->9[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(block.timestamp > partyTime && hodlers[msg.sender] > 0)

IRs:
TMP_2(bool) = block.timestamp > partyTime
REF_1(uint256) -> hodlers[msg.sender]
TMP_3(bool) = REF_1 > 0
TMP_4(bool) = TMP_2 && TMP_3
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
value = hodlers[msg.sender]

IRs:
REF_2(uint256) -> hodlers[msg.sender]
value(uint256) := REF_2(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
hodlers[msg.sender] = 0

IRs:
REF_3(uint256) -> hodlers[msg.sender]
REF_3(uint256) (->hodlers) := 0(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
msg.sender.transfer(value)

IRs:
Transfer dest:msg.sender value:value""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Party(msg.sender,value)

IRs:
Emit Party(msg.sender,value)""];
8->9;
9[label=""Node Type: END_IF 9
""];
}
",0,0,1,0,"hodlers[msg.sender] += msg.value;Hodl(msg.sender,msg.value);msg.value == 0;require(bool)(block.timestamp > partyTime && hodlers[msg.sender] > 0);;value = hodlers[msg.sender];hodlers[msg.sender] = 0;msg.sender.transfer(value);Party(msg.sender,value)"
./0xf11e1de7d9876a10b0742da19232f42456ead843_ext.sol,DXEACoin.withdraw,297,300,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, DXEACoin.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, DXEACoin.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x2f5c8d7259b48078c0b6c0a7cf6269e3817680e5_ext.sol,Refund.cancelRefund,95,101,"REF_8(uint256) -> refunds[_buyer],money(uint256) := REF_8(uint256),TMP_44(bool) = money > 0,TMP_45(None) = SOLIDITY_CALL require(bool,string)(TMP_44,money > 0),REF_9(uint256) -> refunds[_buyer],REF_9(uint256) (->refunds) := 0(uint256),Transfer dest:owner value:money,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
money = refunds[_buyer]

IRs:
REF_8(uint256) -> refunds[_buyer]
money(uint256) := REF_8(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(money > 0,money > 0)

IRs:
TMP_44(bool) = money > 0
TMP_45(None) = SOLIDITY_CALL require(bool,string)(TMP_44,money > 0)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
refunds[_buyer] = 0

IRs:
REF_9(uint256) -> refunds[_buyer]
REF_9(uint256) (->refunds) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
owner.transfer(money)

IRs:
Transfer dest:owner value:money""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,"onlyOwner();money = refunds[_buyer];require(bool,string)(money > 0,money > 0);refunds[_buyer] = 0;owner.transfer(money)"
./0xf1171e1e8df34ab97832342c7cbf04d9121a1ac3_ext.sol,CSportsAuth.withdrawBalance,167,169,"TMP_31 = CONVERT this to address,TMP_32(uint256) = SOLIDITY_CALL balance(address)(TMP_31),Transfer dest:cfoAddress value:TMP_32,MODIFIER_CALL, CSportsAuth.onlyCFO()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
cfoAddress.transfer(address(this).balance)

IRs:
TMP_31 = CONVERT this to address
TMP_32(uint256) = SOLIDITY_CALL balance(address)(TMP_31)
Transfer dest:cfoAddress value:TMP_32""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyCFO()

IRs:
MODIFIER_CALL, CSportsAuth.onlyCFO()()""];
2->1;
}
",0,0,1,0,onlyCFO();cfoAddress.transfer(address(this).balance)
./0x264979ffd35d608e69b69681f4bbcba9877e6c4a_ext.sol,qz_game.Try,5,12,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x26b5bf54e03bb6d42c27ef4364f72a2bf1eff3d2_ext.sol,CryptoBeauty.purchase,206,274,"REF_32(address) -> beautyToOwner[_tokenId],oldOwner(address) := REF_32(address),REF_33(CryptoBeauty.Beauty) -> beauties[_tokenId],REF_34(uint256) -> REF_33.price,sellingPrice(uint256) := REF_34(uint256),newOwner(address) := msg.sender(address),TMP_67(bool) = oldOwner != newOwner,TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67),TMP_69 = CONVERT 0 to address,TMP_70(bool) = newOwner != TMP_69,TMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70),TMP_72(bool) = msg.value >= sellingPrice,TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72),TMP_74(bool) = sellingPrice < increaseLimit1,CONDITION TMP_74,TMP_75(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['sellingPrice', '5'] ,TMP_76(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_75', '100'] ,devCut(uint256) := TMP_76(uint256),TMP_77(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['sellingPrice', '200'] ,TMP_78(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_77', '95'] ,nextPrice(uint256) := TMP_78(uint256),TMP_79(bool) = sellingPrice < increaseLimit2,CONDITION TMP_79,TMP_80(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['sellingPrice', '4'] ,TMP_81(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_80', '100'] ,devCut(uint256) := TMP_81(uint256),TMP_82(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['sellingPrice', '135'] ,TMP_83(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_82', '96'] ,nextPrice(uint256) := TMP_83(uint256),TMP_84(bool) = sellingPrice < increaseLimit3,CONDITION TMP_84,TMP_85(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['sellingPrice', '3'] ,TMP_86(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_85', '100'] ,devCut(uint256) := TMP_86(uint256),TMP_87(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['sellingPrice', '125'] ,TMP_88(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_87', '97'] ,nextPrice(uint256) := TMP_88(uint256),TMP_89(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['sellingPrice', '2'] ,TMP_90(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_89', '100'] ,devCut(uint256) := TMP_90(uint256),TMP_91(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['sellingPrice', '115'] ,TMP_92(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_91', '98'] ,nextPrice(uint256) := TMP_92(uint256),TMP_93(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.value', 'sellingPrice'] ,excess(uint256) := TMP_93(uint256),TMP_94(bool) = charityEnabled == True,CONDITION TMP_94,REF_52(address) -> charities[_charityId],charity(address) := REF_52(address),TMP_95 = CONVERT 0 to address,TMP_96(bool) = charity != TMP_95,TMP_97(None) = SOLIDITY_CALL require(bool)(TMP_96),TMP_98(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['sellingPrice', '1'] ,TMP_99(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_98', '100'] ,TMP_100 = CONVERT TMP_99 to uint256,donate(uint256) := TMP_100(uint256),Transfer dest:charity value:donate,REF_56(CryptoBeauty.Beauty) -> beauties[_tokenId],REF_57(uint256) -> REF_56.price,REF_57(uint256) (->beauties) := nextPrice(uint256),REF_58(CryptoBeauty.Beauty) -> beauties[_tokenId],REF_59(uint256) -> REF_58.maxPrice,REF_59(uint256) (->beauties) := nextPrice(uint256),INTERNAL_CALL, CryptoBeauty._transfer(address,address,uint256)(oldOwner,newOwner,_tokenId),TMP_103 = CONVERT this to address,TMP_104(bool) = oldOwner != TMP_103,CONDITION TMP_104,TMP_105(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['sellingPrice', 'devCut'] ,Transfer dest:oldOwner value:TMP_105,REF_62(CryptoBeauty.Beauty) -> beauties[_tokenId],REF_63(uint256) -> REF_62.price,Emit Purchase(_tokenId,sellingPrice,REF_63,oldOwner,newOwner,_charityId),TMP_108(bool) = excess > 0,CONDITION TMP_108,Transfer dest:newOwner value:excess","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
oldOwner = beautyToOwner[_tokenId]

IRs:
REF_32(address) -> beautyToOwner[_tokenId]
oldOwner(address) := REF_32(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
sellingPrice = beauties[_tokenId].price

IRs:
REF_33(CryptoBeauty.Beauty) -> beauties[_tokenId]
REF_34(uint256) -> REF_33.price
sellingPrice(uint256) := REF_34(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
newOwner = msg.sender

IRs:
newOwner(address) := msg.sender(address)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(oldOwner != newOwner)

IRs:
TMP_67(bool) = oldOwner != newOwner
TMP_68(None) = SOLIDITY_CALL require(bool)(TMP_67)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(newOwner != address(0))

IRs:
TMP_69 = CONVERT 0 to address
TMP_70(bool) = newOwner != TMP_69
TMP_71(None) = SOLIDITY_CALL require(bool)(TMP_70)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(msg.value >= sellingPrice)

IRs:
TMP_72(bool) = msg.value >= sellingPrice
TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7
""];
7->8;
8[label=""Node Type: NEW VARIABLE 8
""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
sellingPrice < increaseLimit1

IRs:
TMP_74(bool) = sellingPrice < increaseLimit1
CONDITION TMP_74""];
9->10[label=""True""];
9->12[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
devCut = SafeMath.div(SafeMath.mul(sellingPrice,5),100)

IRs:
TMP_75(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['sellingPrice', '5'] 
TMP_76(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_75', '100'] 
devCut(uint256) := TMP_76(uint256)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
nextPrice = SafeMath.div(SafeMath.mul(sellingPrice,200),95)

IRs:
TMP_77(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['sellingPrice', '200'] 
TMP_78(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_77', '95'] 
nextPrice(uint256) := TMP_78(uint256)""];
11->22;
12[label=""Node Type: IF 12

EXPRESSION:
sellingPrice < increaseLimit2

IRs:
TMP_79(bool) = sellingPrice < increaseLimit2
CONDITION TMP_79""];
12->13[label=""True""];
12->15[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
devCut = SafeMath.div(SafeMath.mul(sellingPrice,4),100)

IRs:
TMP_80(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['sellingPrice', '4'] 
TMP_81(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_80', '100'] 
devCut(uint256) := TMP_81(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
nextPrice = SafeMath.div(SafeMath.mul(sellingPrice,135),96)

IRs:
TMP_82(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['sellingPrice', '135'] 
TMP_83(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_82', '96'] 
nextPrice(uint256) := TMP_83(uint256)""];
14->21;
15[label=""Node Type: IF 15

EXPRESSION:
sellingPrice < increaseLimit3

IRs:
TMP_84(bool) = sellingPrice < increaseLimit3
CONDITION TMP_84""];
15->16[label=""True""];
15->18[label=""False""];
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
devCut = SafeMath.div(SafeMath.mul(sellingPrice,3),100)

IRs:
TMP_85(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['sellingPrice', '3'] 
TMP_86(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_85', '100'] 
devCut(uint256) := TMP_86(uint256)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
nextPrice = SafeMath.div(SafeMath.mul(sellingPrice,125),97)

IRs:
TMP_87(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['sellingPrice', '125'] 
TMP_88(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_87', '97'] 
nextPrice(uint256) := TMP_88(uint256)""];
17->20;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
devCut = SafeMath.div(SafeMath.mul(sellingPrice,2),100)

IRs:
TMP_89(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['sellingPrice', '2'] 
TMP_90(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_89', '100'] 
devCut(uint256) := TMP_90(uint256)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
nextPrice = SafeMath.div(SafeMath.mul(sellingPrice,115),98)

IRs:
TMP_91(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['sellingPrice', '115'] 
TMP_92(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_91', '98'] 
nextPrice(uint256) := TMP_92(uint256)""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: END_IF 21
""];
21->22;
22[label=""Node Type: END_IF 22
""];
22->23;
23[label=""Node Type: NEW VARIABLE 23

EXPRESSION:
excess = SafeMath.sub(msg.value,sellingPrice)

IRs:
TMP_93(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.value', 'sellingPrice'] 
excess(uint256) := TMP_93(uint256)""];
23->24;
24[label=""Node Type: IF 24

EXPRESSION:
charityEnabled == true

IRs:
TMP_94(bool) = charityEnabled == True
CONDITION TMP_94""];
24->25[label=""True""];
24->29[label=""False""];
25[label=""Node Type: NEW VARIABLE 25

EXPRESSION:
charity = charities[_charityId]

IRs:
REF_52(address) -> charities[_charityId]
charity(address) := REF_52(address)""];
25->26;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
require(bool)(charity != address(0))

IRs:
TMP_95 = CONVERT 0 to address
TMP_96(bool) = charity != TMP_95
TMP_97(None) = SOLIDITY_CALL require(bool)(TMP_96)""];
26->27;
27[label=""Node Type: NEW VARIABLE 27

EXPRESSION:
donate = uint256(SafeMath.div(SafeMath.mul(sellingPrice,1),100))

IRs:
TMP_98(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['sellingPrice', '1'] 
TMP_99(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_98', '100'] 
TMP_100 = CONVERT TMP_99 to uint256
donate(uint256) := TMP_100(uint256)""];
27->28;
28[label=""Node Type: EXPRESSION 28

EXPRESSION:
charity.transfer(donate)

IRs:
Transfer dest:charity value:donate""];
28->29;
29[label=""Node Type: END_IF 29
""];
29->30;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
beauties[_tokenId].price = nextPrice

IRs:
REF_56(CryptoBeauty.Beauty) -> beauties[_tokenId]
REF_57(uint256) -> REF_56.price
REF_57(uint256) (->beauties) := nextPrice(uint256)""];
30->31;
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
beauties[_tokenId].maxPrice = nextPrice

IRs:
REF_58(CryptoBeauty.Beauty) -> beauties[_tokenId]
REF_59(uint256) -> REF_58.maxPrice
REF_59(uint256) (->beauties) := nextPrice(uint256)""];
31->32;
32[label=""Node Type: EXPRESSION 32

EXPRESSION:
_transfer(oldOwner,newOwner,_tokenId)

IRs:
INTERNAL_CALL, CryptoBeauty._transfer(address,address,uint256)(oldOwner,newOwner,_tokenId)""];
32->33;
33[label=""Node Type: IF 33

EXPRESSION:
oldOwner != address(this)

IRs:
TMP_103 = CONVERT this to address
TMP_104(bool) = oldOwner != TMP_103
CONDITION TMP_104""];
33->34[label=""True""];
33->35[label=""False""];
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
oldOwner.transfer(SafeMath.sub(sellingPrice,devCut))

IRs:
TMP_105(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['sellingPrice', 'devCut'] 
Transfer dest:oldOwner value:TMP_105""];
34->35;
35[label=""Node Type: END_IF 35
""];
35->36;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
Purchase(_tokenId,sellingPrice,beauties[_tokenId].price,oldOwner,newOwner,_charityId)

IRs:
REF_62(CryptoBeauty.Beauty) -> beauties[_tokenId]
REF_63(uint256) -> REF_62.price
Emit Purchase(_tokenId,sellingPrice,REF_63,oldOwner,newOwner,_charityId)""];
36->37;
37[label=""Node Type: IF 37

EXPRESSION:
excess > 0

IRs:
TMP_108(bool) = excess > 0
CONDITION TMP_108""];
37->38[label=""True""];
37->39[label=""False""];
38[label=""Node Type: EXPRESSION 38

EXPRESSION:
newOwner.transfer(excess)

IRs:
Transfer dest:newOwner value:excess""];
38->39;
39[label=""Node Type: END_IF 39
""];
}
",0,0,1,0,"oldOwner = beautyToOwner[_tokenId];sellingPrice = beauties[_tokenId].price;newOwner = msg.sender;require(bool)(oldOwner != newOwner);require(bool)(newOwner != address(0));require(bool)(msg.value >= sellingPrice);;;sellingPrice < increaseLimit1;devCut = SafeMath.div(SafeMath.mul(sellingPrice,5),100);sellingPrice < increaseLimit2;nextPrice = SafeMath.div(SafeMath.mul(sellingPrice,200),95);;devCut = SafeMath.div(SafeMath.mul(sellingPrice,4),100);sellingPrice < increaseLimit3;nextPrice = SafeMath.div(SafeMath.mul(sellingPrice,135),96);;devCut = SafeMath.div(SafeMath.mul(sellingPrice,3),100);devCut = SafeMath.div(SafeMath.mul(sellingPrice,2),100);nextPrice = SafeMath.div(SafeMath.mul(sellingPrice,125),97);;nextPrice = SafeMath.div(SafeMath.mul(sellingPrice,115),98);excess = SafeMath.sub(msg.value,sellingPrice);charityEnabled == true;charity = charities[_charityId];;require(bool)(charity != address(0));donate = uint256(SafeMath.div(SafeMath.mul(sellingPrice,1),100));charity.transfer(donate);beauties[_tokenId].price = nextPrice;beauties[_tokenId].maxPrice = nextPrice;_transfer(oldOwner,newOwner,_tokenId);oldOwner != address(this);oldOwner.transfer(SafeMath.sub(sellingPrice,devCut));;Purchase(_tokenId,sellingPrice,beauties[_tokenId].price,oldOwner,newOwner,_charityId);excess > 0;newOwner.transfer(excess);"
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.ownerUpdateToken,2,2,"token(ERC20) := _token(ERC20),wallet(address) := _wallet(address),Emit eWalletChange(wallet,msg.sender),MODIFIER_CALL, KahnDistributionCentre.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
token = _token

IRs:
token(ERC20) := _token(ERC20)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
eWalletChange(wallet,msg.sender)

IRs:
Emit eWalletChange(wallet,msg.sender)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyOwner()()""];
4->1;
}
",0,1,1,0,"onlyOwner();token = _token;wallet = _wallet;eWalletChange(wallet,msg.sender)"
./0x360abb53840302d4b4b119d2004a856f1151366b_ext.sol,BaseContract.transferOnWallet,371,381,"TMP_309(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', '84'] ,TMP_310(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_309', '100'] ,value84(uint256) := TMP_310(uint256),TMP_311(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', '79'] ,TMP_312(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_311', '100'] ,val79(uint256) := TMP_312(uint256),TMP_313(uint256) = msg.value - value84,Transfer dest:wallet1 value:TMP_313,TMP_315(uint256) = msg.value - val79,Transfer dest:wallet2 value:TMP_315,TMP_317(uint256) = msg.value - val79,Transfer dest:wallet3 value:TMP_317,TMP_319(uint256) = msg.value - val79,Transfer dest:wallet4 value:TMP_319,TMP_321(uint256) = msg.value - val79,Transfer dest:wallet5 value:TMP_321","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
value84 = msg.value.mul(84).div(100)

IRs:
TMP_309(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', '84'] 
TMP_310(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_309', '100'] 
value84(uint256) := TMP_310(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
val79 = msg.value.mul(79).div(100)

IRs:
TMP_311(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['msg.value', '79'] 
TMP_312(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.div(uint256,uint256), arguments:['TMP_311', '100'] 
val79(uint256) := TMP_312(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
wallet1.transfer(msg.value - value84)

IRs:
TMP_313(uint256) = msg.value - value84
Transfer dest:wallet1 value:TMP_313""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
wallet2.transfer(msg.value - val79)

IRs:
TMP_315(uint256) = msg.value - val79
Transfer dest:wallet2 value:TMP_315""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
wallet3.transfer(msg.value - val79)

IRs:
TMP_317(uint256) = msg.value - val79
Transfer dest:wallet3 value:TMP_317""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
wallet4.transfer(msg.value - val79)

IRs:
TMP_319(uint256) = msg.value - val79
Transfer dest:wallet4 value:TMP_319""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
wallet5.transfer(msg.value - val79)

IRs:
TMP_321(uint256) = msg.value - val79
Transfer dest:wallet5 value:TMP_321""];
}
",0,0,1,0,value84 = msg.value.mul(84).div(100);val79 = msg.value.mul(79).div(100);wallet1.transfer(msg.value - value84);wallet2.transfer(msg.value - val79);wallet3.transfer(msg.value - val79);wallet4.transfer(msg.value - val79);wallet5.transfer(msg.value - val79)
./0x0dea9b8e6bf08d6859e29256942916f0cfb884fb_ext.sol,CryptoAllStars._payout,349,355,"TMP_90 = CONVERT 0 to address,TMP_91(bool) = _to == TMP_90,CONDITION TMP_91,REF_38(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:ceo value:REF_38,REF_40(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:_to value:REF_40","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_to == address(0)

IRs:
TMP_90 = CONVERT 0 to address
TMP_91(bool) = _to == TMP_90
CONDITION TMP_91""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ceo.transfer(this.balance)

IRs:
REF_38(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:ceo value:REF_38""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_to.transfer(this.balance)

IRs:
REF_40(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:_to value:REF_40""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,_to == address(0);ceo.transfer(this.balance);_to.transfer(this.balance);
./0x0d61178ce25bf05c5b19dc56f30e0f10cbbe9f2b_ext.sol,Lottery.buyTickets,90,118,"TMP_19(bool) = msg.value >= ticketPrice,TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19),customerAddress(address) := msg.sender(address),TMP_22(uint256) = HIGH_LEVEL_CALL, dest:contractCall(_Contract), function:buy, arguments:['customerAddress'] value:msg.value ,REF_2 -> LENGTH entries,TMP_23(bool) = entryCounter == REF_2,CONDITION TMP_23,REF_4 -> LENGTH entries,TMP_25(uint256) := REF_4(uint256),TMP_26(uint256) = TMP_25 + 1,REF_4(uint256) (->entries) := TMP_26(uint256),REF_5(address) -> entries[TMP_25],REF_5(address) (->entries) := customerAddress(address),REF_6(address) -> entries[entryCounter],REF_6(address) (->entries) := customerAddress(address),TMP_27(uint256) := entryCounter(uint256),entryCounter(uint256) = entryCounter + 1,Emit BoughtTicket(msg.value,msg.sender,entryCounter),TMP_29(bool) = entryCounter >= automaticThreshold,CONDITION TMP_29,HIGH_LEVEL_CALL, dest:contractCall(_Contract), function:exit, arguments:[]  ,INTERNAL_CALL, Lottery.giveawayFee()(),TMP_32(address) = INTERNAL_CALL, Lottery.payWinner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= ticketPrice)

IRs:
TMP_19(bool) = msg.value >= ticketPrice
TMP_20(None) = SOLIDITY_CALL require(bool)(TMP_19)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
customerAddress = msg.sender

IRs:
customerAddress(address) := msg.sender(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
contractCall.buy.value(msg.value)(customerAddress)

IRs:
TMP_22(uint256) = HIGH_LEVEL_CALL, dest:contractCall(_Contract), function:buy, arguments:['customerAddress'] value:msg.value ""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
entryCounter == (entries.length)

IRs:
REF_2 -> LENGTH entries
TMP_23(bool) = entryCounter == REF_2
CONDITION TMP_23""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
entries.push(customerAddress)

IRs:
REF_4 -> LENGTH entries
TMP_25(uint256) := REF_4(uint256)
TMP_26(uint256) = TMP_25 + 1
REF_4(uint256) (->entries) := TMP_26(uint256)
REF_5(address) -> entries[TMP_25]
REF_5(address) (->entries) := customerAddress(address)""];
5->7;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
entries[entryCounter] = customerAddress

IRs:
REF_6(address) -> entries[entryCounter]
REF_6(address) (->entries) := customerAddress(address)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
entryCounter ++

IRs:
TMP_27(uint256) := entryCounter(uint256)
entryCounter(uint256) = entryCounter + 1""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
BoughtTicket(msg.value,msg.sender,entryCounter)

IRs:
Emit BoughtTicket(msg.value,msg.sender,entryCounter)""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
entryCounter >= automaticThreshold

IRs:
TMP_29(bool) = entryCounter >= automaticThreshold
CONDITION TMP_29""];
10->11[label=""True""];
10->14[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
contractCall.exit()

IRs:
HIGH_LEVEL_CALL, dest:contractCall(_Contract), function:exit, arguments:[]  ""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
giveawayFee()

IRs:
INTERNAL_CALL, Lottery.giveawayFee()()""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
payWinner()

IRs:
TMP_32(address) = INTERNAL_CALL, Lottery.payWinner()()""];
13->14;
14[label=""Node Type: END_IF 14
""];
}
",1,0,1,0,"require(bool)(msg.value >= ticketPrice);customerAddress = msg.sender;contractCall.buy.value(msg.value)(customerAddress);entryCounter == (entries.length);entries.push(customerAddress);entries[entryCounter] = customerAddress;;entryCounter ++;BoughtTicket(msg.value,msg.sender,entryCounter);entryCounter >= automaticThreshold;contractCall.exit();;giveawayFee();payWinner()"
./0x330bebabc9a2a4136e3d1cb38ca521f5a95aec2e_ext.sol,Token.claimTokens,449,459,"TMP_97(bool) = _token == 0,CONDITION TMP_97,REF_59(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:controller value:REF_59,TMP_99 = CONVERT _token to Token,token(Token) := TMP_99(Token),TMP_100(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_100(uint256),TMP_101(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transfer, arguments:['controller', 'balance']  ,Emit ClaimedTokens(_token,controller,balance),MODIFIER_CALL, Controlled.onlyController()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_97(bool) = _token == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_59(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_59""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
token = Token(_token)

IRs:
TMP_99 = CONVERT _token to Token
token(Token) := TMP_99(Token)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_100(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_100(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_101(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transfer, arguments:['controller', 'balance']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()""];
9->1;
}
",0,0,1,0,"onlyController();_token == 0x0;controller.transfer(this.balance);;;token = Token(_token);balance = token.balanceOf(this);token.transfer(controller,balance);ClaimedTokens(_token,controller,balance)"
./0x00539863217abd04b374a422c855e4c71ed1019a_ext.sol,Storage.sendEthTo,35,40,"storedAmount(uint256) := 0(uint256),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:to value:REF_3,MODIFIER_CALL, Storage.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
storedAmount = 0

IRs:
storedAmount(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
to.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:to value:REF_3""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Storage.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();storedAmount = 0;to.transfer(this.balance)
./0x05b04cb2c29691d3f9ce74e6aa3c69548da3bee2_ext.sol,EtherStateEquivalentToken.withdrawAmount,103,116,"TMP_32(bool) = amount > 0,TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32),TMP_34(None) = SOLIDITY_CALL require(bool)(softCapReached),REF_11(uint256) -> refBalance[msg.sender],value(uint256) := REF_11(uint256),TMP_35(bool) = value >= amount,TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35),REF_12(uint256) -> refBalance[msg.sender],TMP_37(uint256) = value - amount,REF_12(uint256) (->refBalance) := TMP_37(uint256),Transfer dest:msg.sender value:amount,Emit OnWithdraw(msg.sender,amount,now)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(amount > 0)

IRs:
TMP_32(bool) = amount > 0
TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(softCapReached)

IRs:
TMP_34(None) = SOLIDITY_CALL require(bool)(softCapReached)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
value = refBalance[msg.sender]

IRs:
REF_11(uint256) -> refBalance[msg.sender]
value(uint256) := REF_11(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(value >= amount)

IRs:
TMP_35(bool) = value >= amount
TMP_36(None) = SOLIDITY_CALL require(bool)(TMP_35)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
refBalance[msg.sender] = value - amount

IRs:
REF_12(uint256) -> refBalance[msg.sender]
TMP_37(uint256) = value - amount
REF_12(uint256) (->refBalance) := TMP_37(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
OnWithdraw(msg.sender,amount,now)

IRs:
Emit OnWithdraw(msg.sender,amount,now)""];
}
",0,0,1,0,"require(bool)(amount > 0);require(bool)(softCapReached);value = refBalance[msg.sender];require(bool)(value >= amount);refBalance[msg.sender] = value - amount;msg.sender.transfer(amount);OnWithdraw(msg.sender,amount,now)"
./0x1c0a9bbaddb924b42e3145610960dde119779560_ext.sol,RDFDM.haraKiri,357,359,"TMP_117(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, RDFDM.ownerOnly()(),MODIFIER_CALL, RDFDM.unlockedOnly()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_117(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ownerOnly()

IRs:
MODIFIER_CALL, RDFDM.ownerOnly()()""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
unlockedOnly()

IRs:
MODIFIER_CALL, RDFDM.unlockedOnly()()""];
3->1;
}
",0,0,1,0,ownerOnly();selfdestruct(address)(owner);unlockedOnly()
./0x3a9c0090e0d8d26f5eb83cacbc6361c2d305a500_ext.sol,Crowdsale.refund,650,656,"TMP_458(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSoldTokens', 'unconfirmedSum'] ,TMP_459(bool) = TMP_458 < softcap,TMP_460(bool) = now > endIcoMainSale,TMP_461(bool) = TMP_459 && TMP_460,TMP_462(None) = SOLIDITY_CALL require(bool)(TMP_461),REF_266(uint256) -> balances[msg.sender],TMP_463(bool) = REF_266 > 0,TMP_464(None) = SOLIDITY_CALL require(bool)(TMP_463),REF_267(uint256) -> balances[msg.sender],value(uint256) := REF_267(uint256),REF_268(uint256) -> balances[msg.sender],REF_268(uint256) (->balances) := 0(uint256),Transfer dest:msg.sender value:value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(totalSoldTokens.sub(unconfirmedSum) < softcap && now > endIcoMainSale)

IRs:
TMP_458(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalSoldTokens', 'unconfirmedSum'] 
TMP_459(bool) = TMP_458 < softcap
TMP_460(bool) = now > endIcoMainSale
TMP_461(bool) = TMP_459 && TMP_460
TMP_462(None) = SOLIDITY_CALL require(bool)(TMP_461)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[msg.sender] > 0)

IRs:
REF_266(uint256) -> balances[msg.sender]
TMP_463(bool) = REF_266 > 0
TMP_464(None) = SOLIDITY_CALL require(bool)(TMP_463)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
value = balances[msg.sender]

IRs:
REF_267(uint256) -> balances[msg.sender]
value(uint256) := REF_267(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balances[msg.sender] = 0

IRs:
REF_268(uint256) -> balances[msg.sender]
REF_268(uint256) (->balances) := 0(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(value)

IRs:
Transfer dest:msg.sender value:value""];
}
",0,0,1,0,require(bool)(totalSoldTokens.sub(unconfirmedSum) < softcap && now > endIcoMainSale);require(bool)(balances[msg.sender] > 0);value = balances[msg.sender];balances[msg.sender] = 0;msg.sender.transfer(value)
./0x299187bb996599f7fc82df025ee8964cafe3085a_ext.sol,Challenge.withdraw,15,22,"TMP_0 = CONVERT this to address,TMP_1(uint256) = SOLIDITY_CALL balance(address)(TMP_0),TMP_2(bool) = TMP_1 > 0,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),TMP_4 = CONVERT this to address,TMP_5(uint256) = SOLIDITY_CALL balance(address)(TMP_4),TMP_6(bool) = TMP_5 > 10000000000000000,CONDITION TMP_6,TMP_7 = CONVERT this to address,TMP_8(uint256) = SOLIDITY_CALL balance(address)(TMP_7),TMP_9(uint256) = TMP_8 - 10000000000000000,Transfer dest:previous_owner value:TMP_9,TMP_11 = CONVERT this to address,TMP_12(uint256) = SOLIDITY_CALL balance(address)(TMP_11),Transfer dest:creator value:TMP_12","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(address(this).balance > 0)

IRs:
TMP_0 = CONVERT this to address
TMP_1(uint256) = SOLIDITY_CALL balance(address)(TMP_0)
TMP_2(bool) = TMP_1 > 0
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
address(this).balance > 10000000000000000

IRs:
TMP_4 = CONVERT this to address
TMP_5(uint256) = SOLIDITY_CALL balance(address)(TMP_4)
TMP_6(bool) = TMP_5 > 10000000000000000
CONDITION TMP_6""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
previous_owner.transfer(address(this).balance - 10000000000000000)

IRs:
TMP_7 = CONVERT this to address
TMP_8(uint256) = SOLIDITY_CALL balance(address)(TMP_7)
TMP_9(uint256) = TMP_8 - 10000000000000000
Transfer dest:previous_owner value:TMP_9""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
creator.transfer(address(this).balance)

IRs:
TMP_11 = CONVERT this to address
TMP_12(uint256) = SOLIDITY_CALL balance(address)(TMP_11)
Transfer dest:creator value:TMP_12""];
}
",0,0,1,0,require(bool)(address(this).balance > 0);address(this).balance > 10000000000000000;previous_owner.transfer(address(this).balance - 10000000000000000);;creator.transfer(address(this).balance)
./0x129e719c424a7a6fbdeb7ca3d65186892d54ea8c_ext.sol,QUIZ_GAME.StopGame,34,40,"TMP_9(bool) = msg.sender == questionSender,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_9(bool) = msg.sender == questionSender
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0xc7f4ade4874e06a20fab9c5dc4f1dd8b6d85faf2_ext.sol,Pie.withdraw,24,30,"TMP_3(bool) = msg.sender == 180985605343785956359124651641875257890221489366,CONDITION TMP_3,Owner(address) := 180985605343785956359124651641875257890221489366(address),TMP_4(bool) = msg.sender == Owner,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_5(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:Owner value:REF_5","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == 0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6

IRs:
TMP_3(bool) = msg.sender == 180985605343785956359124651641875257890221489366
CONDITION TMP_3""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Owner = 0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6

IRs:
Owner(address) := 180985605343785956359124651641875257890221489366(address)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(msg.sender == Owner)

IRs:
TMP_4(bool) = msg.sender == Owner
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Owner.transfer(this.balance)

IRs:
REF_5(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:Owner value:REF_5""];
}
",0,0,1,0,msg.sender == 0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;Owner = 0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;;require(bool)(msg.sender == Owner);Owner.transfer(this.balance)
./0x56f7f046398e8572d79c17960673889e1f61134b_ext.sol,t_game.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x6a435b5207c4eb8189046e5929f282de55769e34_ext.sol,FacilityChain.withdrawAll,288,292,"myAddress(address) := this(address),TMP_138(uint256) = SOLIDITY_CALL balance(address)(myAddress),etherBalance(uint256) := TMP_138(uint256),Transfer dest:owner value:etherBalance,MODIFIER_CALL, FacilityChain.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
myAddress = this

IRs:
myAddress(address) := this(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
etherBalance = myAddress.balance

IRs:
TMP_138(uint256) = SOLIDITY_CALL balance(address)(myAddress)
etherBalance(uint256) := TMP_138(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(etherBalance)

IRs:
Transfer dest:owner value:etherBalance""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, FacilityChain.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();myAddress = this;etherBalance = myAddress.balance;owner.transfer(etherBalance)
./0x20f5559b14b98a0f6f61b7dc9a75dcdfe6f61f86_ext.sol,IDCSale.withdrawEther,490,496,"TMP_343(bool) = _ethers > 0,TMP_344 = CONVERT this to address,TMP_345(uint256) = SOLIDITY_CALL balance(address)(TMP_344),TMP_346(bool) = _ethers <= TMP_345,TMP_347(bool) = TMP_343 && TMP_346,TMP_348(None) = SOLIDITY_CALL require(bool)(TMP_347),Transfer dest:beneficiary value:_ethers,Emit WithdrawEther(beneficiary,_ethers),RETURN True,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_ethers > 0 && _ethers <= address(this).balance)

IRs:
TMP_343(bool) = _ethers > 0
TMP_344 = CONVERT this to address
TMP_345(uint256) = SOLIDITY_CALL balance(address)(TMP_344)
TMP_346(bool) = _ethers <= TMP_345
TMP_347(bool) = TMP_343 && TMP_346
TMP_348(None) = SOLIDITY_CALL require(bool)(TMP_347)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
beneficiary.transfer(_ethers)

IRs:
Transfer dest:beneficiary value:_ethers""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
WithdrawEther(beneficiary,_ethers)

IRs:
Emit WithdrawEther(beneficiary,_ethers)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,"onlyOwner();require(bool)(_ethers > 0 && _ethers <= address(this).balance);beneficiary.transfer(_ethers);WithdrawEther(beneficiary,_ethers);true"
./0xa2201234a4652a704f5539058ccb9ab6ebcd486b_ext.sol,MultiSigWallet.executeTransaction,229,243,"TMP_68(bool) = INTERNAL_CALL, MultiSigWallet.isConfirmed(uint256)(transactionId),CONDITION TMP_68,REF_44(MultiSigWallet.Transaction) -> transactions[transactionId],tx(MultiSigWallet.Transaction) := REF_44(MultiSigWallet.Transaction),REF_45(bool) -> tx.executed,REF_45(bool) (->tx) := True(bool),REF_46(address) -> tx.destination,REF_49(uint256) -> tx.value,REF_50(bytes) -> tx.data,TMP_70(bool) = LOW_LEVEL_CALL, dest:REF_46, function:call, arguments:['REF_50'] value:REF_49 ,CONDITION TMP_70,Emit Execution(transactionId),Emit ExecutionFailure(transactionId),REF_51(bool) -> tx.executed,REF_51(bool) (->tx) := False(bool),MODIFIER_CALL, MultiSigWallet.notExecuted(uint256)(transactionId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: IF 1

EXPRESSION:
isConfirmed(transactionId)

IRs:
TMP_68(bool) = INTERNAL_CALL, MultiSigWallet.isConfirmed(uint256)(transactionId)
CONDITION TMP_68""];
1->2[label=""True""];
1->9[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
tx = transactions[transactionId]

IRs:
REF_44(MultiSigWallet.Transaction) -> transactions[transactionId]
tx(MultiSigWallet.Transaction) := REF_44(MultiSigWallet.Transaction)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
tx.executed = true

IRs:
REF_45(bool) -> tx.executed
REF_45(bool) (->tx) := True(bool)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
tx.destination.call.value(tx.value)(tx.data)

IRs:
REF_46(address) -> tx.destination
REF_49(uint256) -> tx.value
REF_50(bytes) -> tx.data
TMP_70(bool) = LOW_LEVEL_CALL, dest:REF_46, function:call, arguments:['REF_50'] value:REF_49 
CONDITION TMP_70""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Execution(transactionId)

IRs:
Emit Execution(transactionId)""];
5->8;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
ExecutionFailure(transactionId)

IRs:
Emit ExecutionFailure(transactionId)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tx.executed = false

IRs:
REF_51(bool) -> tx.executed
REF_51(bool) (->tx) := False(bool)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, MultiSigWallet.notExecuted(uint256)(transactionId)""];
10->1;
}
",0,0,1,0,notExecuted(transactionId);isConfirmed(transactionId);tx = transactions[transactionId];;tx.executed = true;tx.destination.call.value(tx.value)(tx.data);Execution(transactionId);ExecutionFailure(transactionId);;tx.executed = false
./0x1e1fe9186c223ee1679634e3cfb7c03276b19493_ext.sol,WaterCrowdsale.safeWithdrawal,151,174,"TMP_54(bool) = weiRaised < fundingGoal,TMP_55(bool) = weiRaised < minimumFundingGoal,TMP_56(bool) = TMP_54 && TMP_55,CONDITION TMP_56,REF_3(uint256) -> balanceOf[msg.sender],amount(uint256) := REF_3(uint256),REF_4(uint256) -> balanceOf[msg.sender],REF_4(uint256) (->balanceOf) := 0(uint256),TMP_57(bool) = amount > 0,CONDITION TMP_57,TMP_58 = SEND dest:msg.sender value:amount,CONDITION TMP_58,Emit FundTransfer(msg.sender,amount,False),REF_6(uint256) -> balanceOf[msg.sender],REF_6(uint256) (->balanceOf) := amount(uint256),TMP_60(bool) = weiRaised >= fundingGoal,TMP_61(bool) = weiRaised >= minimumFundingGoal,TMP_62(bool) = TMP_60 || TMP_61,TMP_63(bool) = wallet == msg.sender,TMP_64(bool) = TMP_62 && TMP_63,CONDITION TMP_64,TMP_65 = SEND dest:wallet value:weiRaised,CONDITION TMP_65,Emit FundTransfer(wallet,weiRaised,False),Emit GoalReached(wallet,weiRaised),fundingGoalReached(bool) := False(bool),MODIFIER_CALL, WaterCrowdsale.afterDeadline()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->18;
1[label=""Node Type: IF 1

EXPRESSION:
weiRaised < fundingGoal && weiRaised < minimumFundingGoal

IRs:
TMP_54(bool) = weiRaised < fundingGoal
TMP_55(bool) = weiRaised < minimumFundingGoal
TMP_56(bool) = TMP_54 && TMP_55
CONDITION TMP_56""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = balanceOf[msg.sender]

IRs:
REF_3(uint256) -> balanceOf[msg.sender]
amount(uint256) := REF_3(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[msg.sender] = 0

IRs:
REF_4(uint256) -> balanceOf[msg.sender]
REF_4(uint256) (->balanceOf) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
amount > 0

IRs:
TMP_57(bool) = amount > 0
CONDITION TMP_57""];
4->5[label=""True""];
4->9[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
msg.sender.send(amount)

IRs:
TMP_58 = SEND dest:msg.sender value:amount
CONDITION TMP_58""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
FundTransfer(msg.sender,amount,false)

IRs:
Emit FundTransfer(msg.sender,amount,False)""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balanceOf[msg.sender] = amount

IRs:
REF_6(uint256) -> balanceOf[msg.sender]
REF_6(uint256) (->balanceOf) := amount(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
(weiRaised >= fundingGoal || weiRaised >= minimumFundingGoal) && wallet == msg.sender

IRs:
TMP_60(bool) = weiRaised >= fundingGoal
TMP_61(bool) = weiRaised >= minimumFundingGoal
TMP_62(bool) = TMP_60 || TMP_61
TMP_63(bool) = wallet == msg.sender
TMP_64(bool) = TMP_62 && TMP_63
CONDITION TMP_64""];
11->12[label=""True""];
11->17[label=""False""];
12[label=""Node Type: IF 12

EXPRESSION:
wallet.send(weiRaised)

IRs:
TMP_65 = SEND dest:wallet value:weiRaised
CONDITION TMP_65""];
12->13[label=""True""];
12->15[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
FundTransfer(wallet,weiRaised,false)

IRs:
Emit FundTransfer(wallet,weiRaised,False)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
GoalReached(wallet,weiRaised)

IRs:
Emit GoalReached(wallet,weiRaised)""];
14->16;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
fundingGoalReached = false

IRs:
fundingGoalReached(bool) := False(bool)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
afterDeadline()

IRs:
MODIFIER_CALL, WaterCrowdsale.afterDeadline()()""];
18->1;
}
",0,0,1,0,"afterDeadline();weiRaised < fundingGoal && weiRaised < minimumFundingGoal;amount = balanceOf[msg.sender];;balanceOf[msg.sender] = 0;amount > 0;msg.sender.send(amount);;FundTransfer(msg.sender,amount,false);balanceOf[msg.sender] = amount;;(weiRaised >= fundingGoal || weiRaised >= minimumFundingGoal) && wallet == msg.sender;wallet.send(weiRaised);;FundTransfer(wallet,weiRaised,false);fundingGoalReached = false;GoalReached(wallet,weiRaised);"
./0x412d9b16117acc557d6a51a93d907bd33526cd77_ext.sol,GCASH_ERC20.withdraw,300,303,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, GCASH_ERC20.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, GCASH_ERC20.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0xd7faef6fd3d3e22037619a756221e38f7f2c9c62_ext.sol,Blogger.requestRefund,56,69,"REF_5(bool) -> didGive[msg.sender],TMP_8(None) = SOLIDITY_CALL require(bool)(REF_5),REF_6(Blogger.Donate) -> donationRecords[msg.sender],record(Blogger.Donate) := REF_6(Blogger.Donate),REF_7(address) -> record.funder,TMP_9(bool) = REF_7 == msg.sender,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_8(address) -> record.funder,REF_10(uint256) -> record.value,Transfer dest:REF_8 value:REF_10,REF_11(bool) -> didGive[msg.sender],REF_11(bool) (->didGive) := False(bool),TMP_12(Blogger.Donate) = new Donate(0,0),clearRecords(Blogger.Donate) := TMP_12(Blogger.Donate),REF_12(Blogger.Donate) -> donationRecords[msg.sender],REF_12(Blogger.Donate) (->donationRecords) := clearRecords(Blogger.Donate)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(didGive[msg.sender])

IRs:
REF_5(bool) -> didGive[msg.sender]
TMP_8(None) = SOLIDITY_CALL require(bool)(REF_5)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
record = donationRecords[msg.sender]

IRs:
REF_6(Blogger.Donate) -> donationRecords[msg.sender]
record(Blogger.Donate) := REF_6(Blogger.Donate)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(record.funder == msg.sender)

IRs:
REF_7(address) -> record.funder
TMP_9(bool) = REF_7 == msg.sender
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
record.funder.transfer(record.value)

IRs:
REF_8(address) -> record.funder
REF_10(uint256) -> record.value
Transfer dest:REF_8 value:REF_10""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
didGive[msg.sender] = false

IRs:
REF_11(bool) -> didGive[msg.sender]
REF_11(bool) (->didGive) := False(bool)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
clearRecords = Donate({funder:0,value:0})

IRs:
TMP_12(Blogger.Donate) = new Donate(0,0)
clearRecords(Blogger.Donate) := TMP_12(Blogger.Donate)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
donationRecords[msg.sender] = clearRecords

IRs:
REF_12(Blogger.Donate) -> donationRecords[msg.sender]
REF_12(Blogger.Donate) (->donationRecords) := clearRecords(Blogger.Donate)""];
}
",0,0,1,0,"require(bool)(didGive[msg.sender]);record = donationRecords[msg.sender];require(bool)(record.funder == msg.sender);record.funder.transfer(record.value);didGive[msg.sender] = false;clearRecords = Donate({funder:0,value:0});donationRecords[msg.sender] = clearRecords"
./0x50a667b73223bc612bcc43200120b5c46ee6b4e9_ext.sol,RC.withdraw,351,353,"Transfer dest:to value:value,MODIFIER_CALL, RC.onlyTokenSaleOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
to.transfer(value)

IRs:
Transfer dest:to value:value""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyTokenSaleOwner()

IRs:
MODIFIER_CALL, RC.onlyTokenSaleOwner()()""];
2->1;
}
",0,0,1,0,onlyTokenSaleOwner();to.transfer(value)
./0xb402be8db1d9eb2beedfe2c8a6c38a604e9f13c6_ext.sol,depositofferToken.finaliseICO,550,563,"TMP_117(bool) = INTERNAL_CALL, depositofferToken.fundSucceeded()(),TMP_118(None) = SOLIDITY_CALL require(bool)(TMP_117),icoSuccessful(bool) := True(bool),REF_56(uint256) = SOLIDITY_CALL balance(address)(this),Emit FundsTransferred(fundWallet,REF_56),REF_58(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:fundWallet value:REF_58,RETURN True,MODIFIER_CALL, depositofferToken.onlyOwner()(),MODIFIER_CALL, ReentryProtected.preventReentry()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(fundSucceeded())

IRs:
TMP_117(bool) = INTERNAL_CALL, depositofferToken.fundSucceeded()()
TMP_118(None) = SOLIDITY_CALL require(bool)(TMP_117)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
icoSuccessful = true

IRs:
icoSuccessful(bool) := True(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
FundsTransferred(fundWallet,this.balance)

IRs:
REF_56(uint256) = SOLIDITY_CALL balance(address)(this)
Emit FundsTransferred(fundWallet,REF_56)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
fundWallet.transfer(this.balance)

IRs:
REF_58(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:fundWallet value:REF_58""];
4->5;
5[label=""Node Type: RETURN 5

EXPRESSION:
true

IRs:
RETURN True""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, depositofferToken.onlyOwner()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
preventReentry()

IRs:
MODIFIER_CALL, ReentryProtected.preventReentry()()""];
7->1;
}
",0,0,1,0,"onlyOwner();require(bool)(fundSucceeded());icoSuccessful = true;FundsTransferred(fundWallet,this.balance);fundWallet.transfer(this.balance);true;preventReentry()"
./0xd0306dd978c2deced267a29b25290f353149450a_ext.sol,Slaughter3D.withdraw,346,358,"INTERNAL_CALL, Slaughter3D.tryFinalizeStage()(),REF_72(uint256) -> playerVault[msg.sender],amount(uint256) := REF_72(uint256),REF_73(uint256) -> playerVault[msg.sender],REF_73(uint256) (->playerVault) := 0(uint256),Emit EarningsWithdrawn(msg.sender,amount),Transfer dest:msg.sender value:amount,MODIFIER_CALL, Slaughter3D.hasEarnings()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
tryFinalizeStage()

IRs:
INTERNAL_CALL, Slaughter3D.tryFinalizeStage()()""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = playerVault[msg.sender]

IRs:
REF_72(uint256) -> playerVault[msg.sender]
amount(uint256) := REF_72(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
playerVault[msg.sender] = 0

IRs:
REF_73(uint256) -> playerVault[msg.sender]
REF_73(uint256) (->playerVault) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
EarningsWithdrawn(msg.sender,amount)

IRs:
Emit EarningsWithdrawn(msg.sender,amount)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
hasEarnings()

IRs:
MODIFIER_CALL, Slaughter3D.hasEarnings()()""];
6->1;
}
",0,0,1,0,"hasEarnings();tryFinalizeStage();amount = playerVault[msg.sender];playerVault[msg.sender] = 0;EarningsWithdrawn(msg.sender,amount);msg.sender.transfer(amount)"
./0xd3a97d46fd0c28a5a035a4e0813afe7c2c1376bd_ext.sol,InterCrypto.recover,231,240,"REF_34(uint256) -> recoverable[msg.sender],amount(uint256) := REF_34(uint256),REF_35(uint256) -> recoverable[msg.sender],REF_35(uint256) (->recoverable) := 0(uint256),TMP_161 = SEND dest:msg.sender value:amount,CONDITION TMP_161,Emit Recovered(msg.sender,amount),REF_37(uint256) -> recoverable[msg.sender],REF_37(uint256) (->recoverable) := amount(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
amount = recoverable[msg.sender]

IRs:
REF_34(uint256) -> recoverable[msg.sender]
amount(uint256) := REF_34(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
recoverable[msg.sender] = 0

IRs:
REF_35(uint256) -> recoverable[msg.sender]
REF_35(uint256) (->recoverable) := 0(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
msg.sender.send(amount)

IRs:
TMP_161 = SEND dest:msg.sender value:amount
CONDITION TMP_161""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Recovered(msg.sender,amount)

IRs:
Emit Recovered(msg.sender,amount)""];
4->6;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
recoverable[msg.sender] = amount

IRs:
REF_37(uint256) -> recoverable[msg.sender]
REF_37(uint256) (->recoverable) := amount(uint256)""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,0,1,0,"amount = recoverable[msg.sender];recoverable[msg.sender] = 0;msg.sender.send(amount);Recovered(msg.sender,amount);recoverable[msg.sender] = amount;"
./0x00346fddca107aec034a367b7324f0d6419bf4b9_ext.sol,Crowdsale.safeWithdrawal,74,95,"TMP_11 = UnaryType.BANG fundingGoalReached ,CONDITION TMP_11,REF_2(uint256) -> balanceOf[msg.sender],amount(uint256) := REF_2(uint256),REF_3(uint256) -> balanceOf[msg.sender],REF_3(uint256) (->balanceOf) := 0(uint256),TMP_12(bool) = amount > 0,CONDITION TMP_12,TMP_13 = SEND dest:msg.sender value:amount,CONDITION TMP_13,Emit FundTransfer(msg.sender,amount,False),REF_5(uint256) -> balanceOf[msg.sender],REF_5(uint256) (->balanceOf) := amount(uint256),TMP_15(bool) = beneficiary == msg.sender,TMP_16(bool) = fundingGoalReached && TMP_15,CONDITION TMP_16,TMP_17 = SEND dest:beneficiary value:amountRaised,CONDITION TMP_17,Emit FundTransfer(beneficiary,amountRaised,False),fundingGoalReached(bool) := False(bool),MODIFIER_CALL, Crowdsale.afterDeadline()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->17;
1[label=""Node Type: IF 1

EXPRESSION:
! fundingGoalReached

IRs:
TMP_11 = UnaryType.BANG fundingGoalReached 
CONDITION TMP_11""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = balanceOf[msg.sender]

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
amount(uint256) := REF_2(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[msg.sender] = 0

IRs:
REF_3(uint256) -> balanceOf[msg.sender]
REF_3(uint256) (->balanceOf) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
amount > 0

IRs:
TMP_12(bool) = amount > 0
CONDITION TMP_12""];
4->5[label=""True""];
4->9[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
msg.sender.send(amount)

IRs:
TMP_13 = SEND dest:msg.sender value:amount
CONDITION TMP_13""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
FundTransfer(msg.sender,amount,false)

IRs:
Emit FundTransfer(msg.sender,amount,False)""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balanceOf[msg.sender] = amount

IRs:
REF_5(uint256) -> balanceOf[msg.sender]
REF_5(uint256) (->balanceOf) := amount(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
fundingGoalReached && beneficiary == msg.sender

IRs:
TMP_15(bool) = beneficiary == msg.sender
TMP_16(bool) = fundingGoalReached && TMP_15
CONDITION TMP_16""];
11->12[label=""True""];
11->16[label=""False""];
12[label=""Node Type: IF 12

EXPRESSION:
beneficiary.send(amountRaised)

IRs:
TMP_17 = SEND dest:beneficiary value:amountRaised
CONDITION TMP_17""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
FundTransfer(beneficiary,amountRaised,false)

IRs:
Emit FundTransfer(beneficiary,amountRaised,False)""];
13->15;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
fundingGoalReached = false

IRs:
fundingGoalReached(bool) := False(bool)""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: END_IF 16
""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
afterDeadline()

IRs:
MODIFIER_CALL, Crowdsale.afterDeadline()()""];
17->1;
}
",0,0,1,0,"afterDeadline();! fundingGoalReached;amount = balanceOf[msg.sender];;balanceOf[msg.sender] = 0;amount > 0;msg.sender.send(amount);;FundTransfer(msg.sender,amount,false);balanceOf[msg.sender] = amount;;fundingGoalReached && beneficiary == msg.sender;beneficiary.send(amountRaised);;FundTransfer(beneficiary,amountRaised,false);fundingGoalReached = false;"
./0x6f8544edb3f513845135b0efa907f4b6b9c2c92e_ext.sol,BW.kill,740,742,"TMP_368(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, BW.isOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_368(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isOwner()

IRs:
MODIFIER_CALL, BW.isOwner()()""];
2->1;
}
",0,0,1,0,isOwner();selfdestruct(address)(owner)
./0x288d045357ac63438278af0b5b84d677713e7c30_ext.sol,Destructible.destroyAndSend,179,181,"TMP_54(None) = SOLIDITY_CALL selfdestruct(address)(_recipient),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(_recipient)

IRs:
TMP_54(None) = SOLIDITY_CALL selfdestruct(address)(_recipient)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(_recipient)
./0x48ee772b8c8927d8d32afc8961fbc177fb723637_ext.sol,Contribution.fallback,228,235,"TMP_150 = UnaryType.BANG isPause ,TMP_151(None) = SOLIDITY_CALL require(bool)(TMP_150),TMP_152 = UnaryType.BANG isFinalize ,TMP_153(None) = SOLIDITY_CALL require(bool)(TMP_152),TMP_154(bool) = msg.value >= MIN_FUND,TMP_155(None) = SOLIDITY_CALL require(bool)(TMP_154),Transfer dest:ethFundDeposit value:msg.value,TMP_157(uint256) = INTERNAL_CALL, Contribution.today()(),INTERNAL_CALL, Contribution.buy(uint256,address,uint256)(TMP_157,msg.sender,msg.value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isPause)

IRs:
TMP_150 = UnaryType.BANG isPause 
TMP_151(None) = SOLIDITY_CALL require(bool)(TMP_150)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(! isFinalize)

IRs:
TMP_152 = UnaryType.BANG isFinalize 
TMP_153(None) = SOLIDITY_CALL require(bool)(TMP_152)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(msg.value >= MIN_FUND)

IRs:
TMP_154(bool) = msg.value >= MIN_FUND
TMP_155(None) = SOLIDITY_CALL require(bool)(TMP_154)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ethFundDeposit.transfer(msg.value)

IRs:
Transfer dest:ethFundDeposit value:msg.value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
buy(today(),msg.sender,msg.value)

IRs:
TMP_157(uint256) = INTERNAL_CALL, Contribution.today()()
INTERNAL_CALL, Contribution.buy(uint256,address,uint256)(TMP_157,msg.sender,msg.value)""];
}
",0,0,1,0,"require(bool)(! isPause);require(bool)(! isFinalize);require(bool)(msg.value >= MIN_FUND);ethFundDeposit.transfer(msg.value);buy(today(),msg.sender,msg.value)"
./0xd67aa6a98e99f979f23bf0da772d113fe6dbe50a_ext.sol,Crowdsale.fallback,106,125,"TMP_14 = UnaryType.BANG crowdsaleClosed ,TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14),TMP_16(bool) = now <= deadline,TMP_17(None) = SOLIDITY_CALL require(bool)(TMP_16),amount(uint256) := msg.value(uint256),REF_1(uint256) -> balanceOf[msg.sender],REF_1(-> balanceOf) = REF_1 + amount,amountRaised(uint256) = amountRaised + amount,allAmountRaised(uint256) = allAmountRaised + amount,TMP_18(uint256) = amount / price,HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['msg.sender', 'TMP_18']  ,Emit FundTransfer(msg.sender,amount,True),TMP_21(bool) = amountRaised >= limitTransfer,CONDITION TMP_21,TMP_22 = SEND dest:beneficiary value:amountRaised,CONDITION TMP_22,amountRaised(uint256) := 0(uint256),Emit FundTransfer(beneficiary,amountRaised,False)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! crowdsaleClosed)

IRs:
TMP_14 = UnaryType.BANG crowdsaleClosed 
TMP_15(None) = SOLIDITY_CALL require(bool)(TMP_14)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(now <= deadline)

IRs:
TMP_16(bool) = now <= deadline
TMP_17(None) = SOLIDITY_CALL require(bool)(TMP_16)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
amount = msg.value

IRs:
amount(uint256) := msg.value(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
balanceOf[msg.sender] += amount

IRs:
REF_1(uint256) -> balanceOf[msg.sender]
REF_1(-> balanceOf) = REF_1 + amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
amountRaised += amount

IRs:
amountRaised(uint256) = amountRaised + amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
allAmountRaised += amount

IRs:
allAmountRaised(uint256) = allAmountRaised + amount""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokenReward.transfer(msg.sender,amount / price)

IRs:
TMP_18(uint256) = amount / price
HIGH_LEVEL_CALL, dest:tokenReward(token), function:transfer, arguments:['msg.sender', 'TMP_18']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
FundTransfer(msg.sender,amount,true)

IRs:
Emit FundTransfer(msg.sender,amount,True)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
amountRaised >= limitTransfer

IRs:
TMP_21(bool) = amountRaised >= limitTransfer
CONDITION TMP_21""];
9->10[label=""True""];
9->14[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
beneficiary.send(amountRaised)

IRs:
TMP_22 = SEND dest:beneficiary value:amountRaised
CONDITION TMP_22""];
10->11[label=""True""];
10->13[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
amountRaised = 0

IRs:
amountRaised(uint256) := 0(uint256)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
FundTransfer(beneficiary,amountRaised,false)

IRs:
Emit FundTransfer(beneficiary,amountRaised,False)""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: END_IF 14
""];
}
",0,0,1,0,"require(bool)(! crowdsaleClosed);require(bool)(now <= deadline);amount = msg.value;balanceOf[msg.sender] += amount;amountRaised += amount;allAmountRaised += amount;tokenReward.transfer(msg.sender,amount / price);FundTransfer(msg.sender,amount,true);amountRaised >= limitTransfer;beneficiary.send(amountRaised);;amountRaised = 0;;FundTransfer(beneficiary,amountRaised,false)"
./0x211f01e59b425253c0a0e9a7bf612605b42ce82c_ext.sol,Pinakion.claimTokens,511,521,"TMP_129(bool) = _token == 0,CONDITION TMP_129,REF_56(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:controller value:REF_56,TMP_131 = CONVERT _token to Pinakion,token(Pinakion) := TMP_131(Pinakion),TMP_132(uint256) = HIGH_LEVEL_CALL, dest:token(Pinakion), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_132(uint256),TMP_133(bool) = HIGH_LEVEL_CALL, dest:token(Pinakion), function:transfer, arguments:['controller', 'balance']  ,Emit ClaimedTokens(_token,controller,balance),MODIFIER_CALL, Controlled.onlyController()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_129(bool) = _token == 0
CONDITION TMP_129""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_56(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_56""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
token = Pinakion(_token)

IRs:
TMP_131 = CONVERT _token to Pinakion
token(Pinakion) := TMP_131(Pinakion)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_132(uint256) = HIGH_LEVEL_CALL, dest:token(Pinakion), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_132(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_133(bool) = HIGH_LEVEL_CALL, dest:token(Pinakion), function:transfer, arguments:['controller', 'balance']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()""];
9->1;
}
",0,0,1,0,"onlyController();_token == 0x0;controller.transfer(this.balance);;;token = Pinakion(_token);balance = token.balanceOf(this);token.transfer(controller,balance);ClaimedTokens(_token,controller,balance)"
./0x75cb629408d1ea387df0a1f755e0bc371a5fa036_ext.sol,GoodLuckCasino.ownerWithdraw,169,173,"TMP_44 = CONVERT this to address,TMP_45(uint256) = SOLIDITY_CALL balance(address)(TMP_44),TMP_46(bool) = TMP_45 > _val,TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46),Transfer dest:_to value:_val,Emit LOG_OwnerWithdraw(_to,_val),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(address(this).balance > _val)

IRs:
TMP_44 = CONVERT this to address
TMP_45(uint256) = SOLIDITY_CALL balance(address)(TMP_44)
TMP_46(bool) = TMP_45 > _val
TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_to.transfer(_val)

IRs:
Transfer dest:_to value:_val""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
LOG_OwnerWithdraw(_to,_val)

IRs:
Emit LOG_OwnerWithdraw(_to,_val)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->1;
}
",0,0,1,0,"onlyOwner();require(bool)(address(this).balance > _val);_to.transfer(_val);LOG_OwnerWithdraw(_to,_val)"
./0x4055bd5a000d97bfca86d71386dc85001eb738f6_ext.sol,Imt.getEth,45,53,"TMP_28(bool) = _price > 0,CONDITION TMP_28,TMP_29 = CONVERT this to address,TMP_30(uint256) = SOLIDITY_CALL balance(address)(TMP_29),TMP_31(bool) = TMP_30 >= _price,CONDITION TMP_31,Transfer dest:owner value:_price,TMP_33 = CONVERT this to address,TMP_34(uint256) = SOLIDITY_CALL balance(address)(TMP_33),Transfer dest:owner value:TMP_34,MODIFIER_CALL, Imt.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: IF 1

EXPRESSION:
_price > 0

IRs:
TMP_28(bool) = _price > 0
CONDITION TMP_28""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
address(this).balance >= _price

IRs:
TMP_29 = CONVERT this to address
TMP_30(uint256) = SOLIDITY_CALL balance(address)(TMP_29)
TMP_31(bool) = TMP_30 >= _price
CONDITION TMP_31""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_price)

IRs:
Transfer dest:owner value:_price""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->6;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_33 = CONVERT this to address
TMP_34(uint256) = SOLIDITY_CALL balance(address)(TMP_33)
Transfer dest:owner value:TMP_34""];
5->6;
6[label=""Node Type: END_IF 6
""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Imt.onlyOwner()()""];
7->1;
}
",0,0,1,0,onlyOwner();_price > 0;address(this).balance >= _price;owner.transfer(address(this).balance);owner.transfer(_price);;
./0xecfeb4a1bb01e0a9530b40fd6bbe3954529393ec_ext.sol,EnJoy.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0xec7ba2ff3c46b9417d34ca9941ae2f62268c5add_ext.sol,AllYours.kill,142,158,"TMP_20(bool) = _owner == msg.sender,CONDITION TMP_20,TMP_21 = CONVERT this to address,TMP_22(uint256) = SOLIDITY_CALL balance(address)(TMP_21),Transfer dest:_platformAddress value:TMP_22,TMP_24(None) = SOLIDITY_CALL selfdestruct(address)(_owner)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_owner == msg.sender

IRs:
TMP_20(bool) = _owner == msg.sender
CONDITION TMP_20""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_platformAddress.transfer(address(this).balance)

IRs:
TMP_21 = CONVERT this to address
TMP_22(uint256) = SOLIDITY_CALL balance(address)(TMP_21)
Transfer dest:_platformAddress value:TMP_22""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
selfdestruct(address)(_owner)

IRs:
TMP_24(None) = SOLIDITY_CALL selfdestruct(address)(_owner)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,_owner == msg.sender;_platformAddress.transfer(address(this).balance);;selfdestruct(address)(_owner)
./0x2732dd0f79f6cf4f257232ea2291ffbab2c18c15_ext.sol,CoinFlipperDSG.sendOwnerDeposit,130,141,"TMP_122(bool) = paused == True,TMP_123(None) = SOLIDITY_CALL require(bool,string)(TMP_122,Game was not stopped),TMP_124(uint256) = INTERNAL_CALL, CoinFlipperDSG.getContractBalance()(),contractBalance(uint256) := TMP_124(uint256),TMP_125(bool) = contractBalance >= ownerDeposit,CONDITION TMP_125,Transfer dest:recipient value:ownerDeposit,Transfer dest:recipient value:contractBalance,jackpotBalance = delete jackpotBalance ,ownerDeposit = delete ownerDeposit ,MODIFIER_CALL, CoinFlipperDSG.onlyOwners()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(paused == true,Game was not stopped)

IRs:
TMP_122(bool) = paused == True
TMP_123(None) = SOLIDITY_CALL require(bool,string)(TMP_122,Game was not stopped)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
contractBalance = getContractBalance()

IRs:
TMP_124(uint256) = INTERNAL_CALL, CoinFlipperDSG.getContractBalance()()
contractBalance(uint256) := TMP_124(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
contractBalance >= ownerDeposit

IRs:
TMP_125(bool) = contractBalance >= ownerDeposit
CONDITION TMP_125""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
recipient.transfer(ownerDeposit)

IRs:
Transfer dest:recipient value:ownerDeposit""];
4->6;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
recipient.transfer(contractBalance)

IRs:
Transfer dest:recipient value:contractBalance""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
delete jackpotBalance

IRs:
jackpotBalance = delete jackpotBalance ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
delete ownerDeposit

IRs:
ownerDeposit = delete ownerDeposit ""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyOwners()

IRs:
MODIFIER_CALL, CoinFlipperDSG.onlyOwners()()""];
9->1;
}
",0,0,1,0,"onlyOwners();require(bool,string)(paused == true,Game was not stopped);contractBalance = getContractBalance();contractBalance >= ownerDeposit;recipient.transfer(ownerDeposit);recipient.transfer(contractBalance);;delete jackpotBalance;delete ownerDeposit"
./0xd64ad4eefaacb96a0865687cfeef4c4a2cfbfef2_ext.sol,Mortal.kill,65,68,"TMP_25(bool) = msg.sender == owner,CONDITION TMP_25,TMP_26(None) = SOLIDITY_CALL selfdestruct(address)(owner)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_25(bool) = msg.sender == owner
CONDITION TMP_25""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_26(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,0,1,0,msg.sender == owner;selfdestruct(address)(owner);
./0x00416b9d728069edb0ceb04bc2b203fa7336d1f1_ext.sol,SeedCrowdsaleContract.processTransaction,211,239,"TMP_59(uint256) = INTERNAL_CALL, SeedCrowdsaleContract.calculateMaxContribution(address)(_contributor),maxContribution(uint256) := TMP_59(uint256),contributionAmount(uint256) := _amount(uint256),returnAmount(uint256) := 0(uint256),TMP_60(bool) = maxContribution < _amount,CONDITION TMP_60,contributionAmount(uint256) := maxContribution(uint256),TMP_61(uint256) = _amount - maxContribution,returnAmount(uint256) := TMP_61(uint256),TMP_62(uint256) = ethRaised + contributionAmount,TMP_63(bool) = TMP_62 >= minCap,TMP_64(bool) = minCap > ethRaised,TMP_65(bool) = TMP_63 && TMP_64,CONDITION TMP_65,Emit MinCapReached(block.timestamp),REF_18(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor],REF_19(uint256) -> REF_18.contributionAmount,TMP_67(bool) = REF_19 == 0,CONDITION TMP_67,REF_20(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor],REF_21(uint256) -> REF_20.contributionAmount,REF_21(uint256) (->contributorList) := contributionAmount(uint256),REF_22(address) -> contributorIndexes[nextContributorIndex],REF_22(address) (->contributorIndexes) := _contributor(address),TMP_68(uint256) := nextContributorIndex(uint256),nextContributorIndex(uint256) = nextContributorIndex + 1,REF_23(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor],REF_24(uint256) -> REF_23.contributionAmount,REF_24(-> contributorList) = REF_24 + contributionAmount,ethRaised(uint256) = ethRaised + contributionAmount,Emit ContributionMade(msg.sender,contributionAmount),TMP_70(bool) = returnAmount != 0,CONDITION TMP_70,Transfer dest:_contributor value:returnAmount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
maxContribution = calculateMaxContribution(_contributor)

IRs:
TMP_59(uint256) = INTERNAL_CALL, SeedCrowdsaleContract.calculateMaxContribution(address)(_contributor)
maxContribution(uint256) := TMP_59(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
contributionAmount = _amount

IRs:
contributionAmount(uint256) := _amount(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
returnAmount = 0

IRs:
returnAmount(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
maxContribution < _amount

IRs:
TMP_60(bool) = maxContribution < _amount
CONDITION TMP_60""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
contributionAmount = maxContribution

IRs:
contributionAmount(uint256) := maxContribution(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
returnAmount = _amount - maxContribution

IRs:
TMP_61(uint256) = _amount - maxContribution
returnAmount(uint256) := TMP_61(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
ethRaised + contributionAmount >= minCap && minCap > ethRaised

IRs:
TMP_62(uint256) = ethRaised + contributionAmount
TMP_63(bool) = TMP_62 >= minCap
TMP_64(bool) = minCap > ethRaised
TMP_65(bool) = TMP_63 && TMP_64
CONDITION TMP_65""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
MinCapReached(block.timestamp)

IRs:
Emit MinCapReached(block.timestamp)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
contributorList[_contributor].contributionAmount == 0

IRs:
REF_18(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor]
REF_19(uint256) -> REF_18.contributionAmount
TMP_67(bool) = REF_19 == 0
CONDITION TMP_67""];
11->12[label=""True""];
11->15[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
contributorList[_contributor].contributionAmount = contributionAmount

IRs:
REF_20(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor]
REF_21(uint256) -> REF_20.contributionAmount
REF_21(uint256) (->contributorList) := contributionAmount(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
contributorIndexes[nextContributorIndex] = _contributor

IRs:
REF_22(address) -> contributorIndexes[nextContributorIndex]
REF_22(address) (->contributorIndexes) := _contributor(address)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
nextContributorIndex ++

IRs:
TMP_68(uint256) := nextContributorIndex(uint256)
nextContributorIndex(uint256) = nextContributorIndex + 1""];
14->16;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
contributorList[_contributor].contributionAmount += contributionAmount

IRs:
REF_23(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor]
REF_24(uint256) -> REF_23.contributionAmount
REF_24(-> contributorList) = REF_24 + contributionAmount""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
ethRaised += contributionAmount

IRs:
ethRaised(uint256) = ethRaised + contributionAmount""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
ContributionMade(msg.sender,contributionAmount)

IRs:
Emit ContributionMade(msg.sender,contributionAmount)""];
18->19;
19[label=""Node Type: IF 19

EXPRESSION:
returnAmount != 0

IRs:
TMP_70(bool) = returnAmount != 0
CONDITION TMP_70""];
19->20[label=""True""];
19->21[label=""False""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
_contributor.transfer(returnAmount)

IRs:
Transfer dest:_contributor value:returnAmount""];
20->21;
21[label=""Node Type: END_IF 21
""];
}
",0,1,1,0,"maxContribution = calculateMaxContribution(_contributor);contributionAmount = _amount;returnAmount = 0;maxContribution < _amount;contributionAmount = maxContribution;;returnAmount = _amount - maxContribution;ethRaised + contributionAmount >= minCap && minCap > ethRaised;MinCapReached(block.timestamp);;contributorList[_contributor].contributionAmount == 0;contributorList[_contributor].contributionAmount = contributionAmount;contributorList[_contributor].contributionAmount += contributionAmount;contributorIndexes[nextContributorIndex] = _contributor;nextContributorIndex ++;;ethRaised += contributionAmount;ContributionMade(msg.sender,contributionAmount);returnAmount != 0;_contributor.transfer(returnAmount);"
./0x83e969a451253f1026e388ba2e3eef6aaa4cbca4_ext.sol,MultiSigWallet.executeTransaction,436,457,"TMP_50(bool) = INTERNAL_CALL, MultiSigWallet.isConfirmed(uint256)(transactionId),CONDITION TMP_50,REF_31(MultiSigWallet.Transaction) -> transactions[transactionId],txn(MultiSigWallet.Transaction) := REF_31(MultiSigWallet.Transaction),REF_32(bool) -> txn.executed,REF_32(bool) (->txn) := True(bool),REF_33(address) -> txn.destination,REF_34(uint256) -> txn.value,REF_35(bytes) -> txn.data,REF_36 -> LENGTH REF_35,REF_37(bytes) -> txn.data,TMP_51(bool) = INTERNAL_CALL, MultiSigWallet.external_call(address,uint256,uint256,bytes)(REF_33,REF_34,REF_36,REF_37),CONDITION TMP_51,Emit Execution(transactionId),Emit ExecutionFailure(transactionId),REF_38(bool) -> txn.executed,REF_38(bool) (->txn) := False(bool),MODIFIER_CALL, MultiSigWallet.ownerExists(address)(msg.sender),MODIFIER_CALL, MultiSigWallet.confirmed(uint256,address)(transactionId,msg.sender),MODIFIER_CALL, MultiSigWallet.notExecuted(uint256)(transactionId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: IF 1

EXPRESSION:
isConfirmed(transactionId)

IRs:
TMP_50(bool) = INTERNAL_CALL, MultiSigWallet.isConfirmed(uint256)(transactionId)
CONDITION TMP_50""];
1->2[label=""True""];
1->9[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
txn = transactions[transactionId]

IRs:
REF_31(MultiSigWallet.Transaction) -> transactions[transactionId]
txn(MultiSigWallet.Transaction) := REF_31(MultiSigWallet.Transaction)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
txn.executed = true

IRs:
REF_32(bool) -> txn.executed
REF_32(bool) (->txn) := True(bool)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
external_call(txn.destination,txn.value,txn.data.length,txn.data)

IRs:
REF_33(address) -> txn.destination
REF_34(uint256) -> txn.value
REF_35(bytes) -> txn.data
REF_36 -> LENGTH REF_35
REF_37(bytes) -> txn.data
TMP_51(bool) = INTERNAL_CALL, MultiSigWallet.external_call(address,uint256,uint256,bytes)(REF_33,REF_34,REF_36,REF_37)
CONDITION TMP_51""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Execution(transactionId)

IRs:
Emit Execution(transactionId)""];
5->8;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
ExecutionFailure(transactionId)

IRs:
Emit ExecutionFailure(transactionId)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
txn.executed = false

IRs:
REF_38(bool) -> txn.executed
REF_38(bool) (->txn) := False(bool)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
ownerExists(msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.ownerExists(address)(msg.sender)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
confirmed(transactionId,msg.sender)

IRs:
MODIFIER_CALL, MultiSigWallet.confirmed(uint256,address)(transactionId,msg.sender)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
notExecuted(transactionId)

IRs:
MODIFIER_CALL, MultiSigWallet.notExecuted(uint256)(transactionId)""];
12->1;
}
",0,0,1,0,"ownerExists(msg.sender);isConfirmed(transactionId);txn = transactions[transactionId];;txn.executed = true;external_call(txn.destination,txn.value,txn.data.length,txn.data);Execution(transactionId);ExecutionFailure(transactionId);;txn.executed = false;confirmed(transactionId,msg.sender);notExecuted(transactionId)"
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.chkStaff,2,2,"REF_88(bool) -> staffs[_address],RETURN REF_88,MODIFIER_CALL, KahnDistributionCentre.onlyAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: RETURN 1

EXPRESSION:
staffs[_address]

IRs:
REF_88(bool) -> staffs[_address]
RETURN REF_88""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyAdmin()()""];
2->1;
}
",0,1,1,0,onlyAdmin();staffs[_address]
./0x025dce2d39a46296766db7cac8c322e8f59cd5d9_ext.sol,EthToSmthSwaps.withdr,204,207,"TMP_77(bool) = msg.sender == owner,TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77),Transfer dest:owner value:amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_77(bool) = msg.sender == owner
TMP_78(None) = SOLIDITY_CALL require(bool)(TMP_77)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(amount)

IRs:
Transfer dest:owner value:amount""];
}
",0,0,1,0,require(bool)(msg.sender == owner);owner.transfer(amount)
./0xc55a13e36d93371a5b036a21d913a31cd2804ba4_ext.sol,NoteOfExchange.getTokens,194,211,"tokens(uint256) := 0(uint256),investor(address) := msg.sender(address),etherValue(uint256) := msg.value(uint256),TMP_38(bool) = etherValue >= minContribution,CONDITION TMP_38,Transfer dest:owner value:etherValue,TMP_40(bool) = EthGetFinished == False,TMP_41(None) = SOLIDITY_CALL require(bool)(TMP_40),TMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_43(uint256) = TMP_42 / 1000000000000000000,tokens(uint256) := TMP_43(uint256),TMP_44(bool) = tokens >= 0,CONDITION TMP_44,TMP_45(bool) = INTERNAL_CALL, NoteOfExchange.distr(address,uint256)(investor,tokens),TMP_46(bool) = airdropBy0EthFinished == False,REF_9(bool) -> joinOnce[investor],TMP_47(bool) = REF_9 != True,TMP_48(bool) = TMP_46 && TMP_47,TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48),TMP_50(bool) = INTERNAL_CALL, NoteOfExchange.distr(address,uint256)(investor,airdropBy0Eth),REF_10(bool) -> joinOnce[investor],REF_10(bool) (->joinOnce) := True(bool),MODIFIER_CALL, NoteOfExchange.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->15;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
etherValue = msg.value

IRs:
etherValue(uint256) := msg.value(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
etherValue >= minContribution

IRs:
TMP_38(bool) = etherValue >= minContribution
CONDITION TMP_38""];
4->5[label=""True""];
4->11[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
owner.transfer(etherValue)

IRs:
Transfer dest:owner value:etherValue""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(EthGetFinished == false)

IRs:
TMP_40(bool) = EthGetFinished == False
TMP_41(None) = SOLIDITY_CALL require(bool)(TMP_40)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_42(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_43(uint256) = TMP_42 / 1000000000000000000
tokens(uint256) := TMP_43(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
tokens >= 0

IRs:
TMP_44(bool) = tokens >= 0
CONDITION TMP_44""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_45(bool) = INTERNAL_CALL, NoteOfExchange.distr(address,uint256)(investor,tokens)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->14;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
require(bool)(airdropBy0EthFinished == false && joinOnce[investor] != true)

IRs:
TMP_46(bool) = airdropBy0EthFinished == False
REF_9(bool) -> joinOnce[investor]
TMP_47(bool) = REF_9 != True
TMP_48(bool) = TMP_46 && TMP_47
TMP_49(None) = SOLIDITY_CALL require(bool)(TMP_48)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
distr(investor,airdropBy0Eth)

IRs:
TMP_50(bool) = INTERNAL_CALL, NoteOfExchange.distr(address,uint256)(investor,airdropBy0Eth)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
joinOnce[investor] = true

IRs:
REF_10(bool) -> joinOnce[investor]
REF_10(bool) (->joinOnce) := True(bool)""];
13->14;
14[label=""Node Type: END_IF 14
""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, NoteOfExchange.canDistr()()""];
15->1;
}
",0,0,1,0,"canDistr();tokens = 0;investor = msg.sender;etherValue = msg.value;etherValue >= minContribution;owner.transfer(etherValue);require(bool)(airdropBy0EthFinished == false && joinOnce[investor] != true);require(bool)(EthGetFinished == false);tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;tokens >= 0;distr(investor,tokens);;;distr(investor,airdropBy0Eth);joinOnce[investor] = true"
./0x000621424c60951cb69e9d75d64b79813846d498_ext.sol,HasNoEther.reclaimEther,101,103,"REF_1(uint256) = SOLIDITY_CALL balance(address)(this),TMP_32 = SEND dest:owner value:REF_1,TMP_33(None) = SOLIDITY_CALL assert(bool)(TMP_32),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(owner.send(this.balance))

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_32 = SEND dest:owner value:REF_1
TMP_33(None) = SOLIDITY_CALL assert(bool)(TMP_32)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();assert(bool)(owner.send(this.balance))
./0xd41d48be0a81690a785bf1df336163f7b78eadca_ext.sol,Crypland.ownerDestroy,71,73,"TMP_6(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Crypland.whenOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_6(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
whenOwner()

IRs:
MODIFIER_CALL, Crypland.whenOwner()()""];
2->1;
}
",0,0,1,0,whenOwner();selfdestruct(address)(owner)
./0xcf91d43b85a5c53d85c567d4eed972965335aeea_ext.sol,Slaughter3D.fetchBalance,98,101,"TMP_28 = CONVERT this to address,TMP_29(uint256) = SOLIDITY_CALL balance(address)(TMP_28),Transfer dest:msg.sender value:TMP_29,MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_28 = CONVERT this to address
TMP_29(uint256) = SOLIDITY_CALL balance(address)(TMP_28)
Transfer dest:msg.sender value:TMP_29""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();msg.sender.transfer(address(this).balance)
./0x1ca6a09e02480be25c10284372cd21fde7d35a79_ext.sol,ExhibationLinkingCoin.destruct,546,555,"TMP_207(bool) = msg.sender != owner,CONDITION TMP_207,TMP_208(None) = SOLIDITY_CALL revert()(),TMP_209(None) = SOLIDITY_CALL selfdestruct(address)(owner)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender != owner

IRs:
TMP_207(bool) = msg.sender != owner
CONDITION TMP_207""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_208(None) = SOLIDITY_CALL revert()()""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_209(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,msg.sender != owner;revert()();selfdestruct(address)(owner);
./0x3ac0d29eaf16eb423e07387274a05a1e16a8472b_ext.sol,LuckyNumber.kill,38,41,"TMP_1(bool) = msg.sender == owner,CONDITION TMP_1,TMP_2(None) = SOLIDITY_CALL selfdestruct(address)(owner)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_1(bool) = msg.sender == owner
CONDITION TMP_1""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_2(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,0,1,0,msg.sender == owner;selfdestruct(address)(owner);
./0xc398891b43f1b91158dca87c63a88b80d000c248_ext.sol,IBIT.withdraw,291,294,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, IBIT.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, IBIT.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x18aaad578e74913df4255c126f2a0bd9e3399ec7_ext.sol,test_contract.StopGame,33,36,"TMP_10(bool) = msg.sender == questionSender,TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_10(bool) = msg.sender == questionSender
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0xecfeb4a1bb01e0a9530b40fd6bbe3954529393ec_ext.sol,EnJoy.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x376cbf6b8b7583f52192009e0cee250855ca9ea5_ext.sol,TTCSale.ownerSafeWithdrawal,660,665,"TMP_236(None) = SOLIDITY_CALL require(bool)(fundingGoalReached),REF_131(uint256) = SOLIDITY_CALL balance(address)(this),balanceToSend(uint256) := REF_131([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E59D36D0>]),Transfer dest:beneficiary value:balanceToSend,Emit FundTransfer(beneficiary,balanceToSend,False),MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, TTCSale.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(fundingGoalReached)

IRs:
TMP_236(None) = SOLIDITY_CALL require(bool)(fundingGoalReached)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
balanceToSend = this.balance

IRs:
REF_131(uint256) = SOLIDITY_CALL balance(address)(this)
balanceToSend(uint256) := REF_131([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E59D36D0>])""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
beneficiary.transfer(balanceToSend)

IRs:
Transfer dest:beneficiary value:balanceToSend""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
FundTransfer(beneficiary,balanceToSend,false)

IRs:
Emit FundTransfer(beneficiary,balanceToSend,False)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, TTCSale.nonReentrant()()""];
6->1;
}
",0,0,1,0,"onlyOwner();require(bool)(fundingGoalReached);balanceToSend = this.balance;beneficiary.transfer(balanceToSend);FundTransfer(beneficiary,balanceToSend,false);nonReentrant()"
./0x9b2f30c69f31559c99a04dcdfa19de1b1cf9d265_ext.sol,Destructible.destroy,112,114,"TMP_30(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_30(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0xc710772a16fd040ed9c63de0679a57410981e3fc_ext.sol,EthVault.withdraw,82,90,"TMP_34(bool) = INTERNAL_CALL, EthVault.WithdrawEnabled()(),CONDITION TMP_34,REF_5(uint256) -> Deposits[msg.sender],max(uint256) := REF_5(uint256),TMP_35(bool) = max > 0,TMP_36(bool) = amount <= max,TMP_37(bool) = TMP_35 && TMP_36,CONDITION TMP_37,Transfer dest:to value:amount,Emit Withdrawal(to,amount),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: IF 1

EXPRESSION:
WithdrawEnabled()

IRs:
TMP_34(bool) = INTERNAL_CALL, EthVault.WithdrawEnabled()()
CONDITION TMP_34""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
max = Deposits[msg.sender]

IRs:
REF_5(uint256) -> Deposits[msg.sender]
max(uint256) := REF_5(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
max > 0 && amount <= max

IRs:
TMP_35(bool) = max > 0
TMP_36(bool) = amount <= max
TMP_37(bool) = TMP_35 && TMP_36
CONDITION TMP_37""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
to.transfer(amount)

IRs:
Transfer dest:to value:amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Withdrawal(to,amount)

IRs:
Emit Withdrawal(to,amount)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: END_IF 7
""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
8->1;
}
",0,0,1,0,"onlyOwner();WithdrawEnabled();max = Deposits[msg.sender];;max > 0 && amount <= max;to.transfer(amount);;Withdrawal(to,amount)"
./0x269b4c23ddab676e2869ae72cd6ae4f24bdfea45_ext.sol,IRBPreRefundVault.withdraw,502,509,"REF_114(IRBPreRefundVault.State) -> State.Active,TMP_161(bool) = state == REF_114,TMP_162(None) = SOLIDITY_CALL require(bool)(TMP_161),TMP_163(bool) = totalDeposited >= value,TMP_164(None) = SOLIDITY_CALL require(bool)(TMP_163),TMP_165(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalDeposited', 'value'] ,totalDeposited(uint256) := TMP_165(uint256),Transfer dest:wallet value:value,Emit Withdrawal(wallet,value),RETURN True,MODIFIER_CALL, IRBPreRefundVault.onlyCrowdsaleContract()(),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_114(IRBPreRefundVault.State) -> State.Active
TMP_161(bool) = state == REF_114
TMP_162(None) = SOLIDITY_CALL require(bool)(TMP_161)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(totalDeposited >= value)

IRs:
TMP_163(bool) = totalDeposited >= value
TMP_164(None) = SOLIDITY_CALL require(bool)(TMP_163)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalDeposited = totalDeposited.sub(value)

IRs:
TMP_165(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['totalDeposited', 'value'] 
totalDeposited(uint256) := TMP_165(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
wallet.transfer(value)

IRs:
Transfer dest:wallet value:value""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Withdrawal(wallet,value)

IRs:
Emit Withdrawal(wallet,value)""];
5->6;
6[label=""Node Type: RETURN 6

EXPRESSION:
true

IRs:
RETURN True""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyCrowdsaleContract()

IRs:
MODIFIER_CALL, IRBPreRefundVault.onlyCrowdsaleContract()()""];
7->1;
8[label=""Node Type: RETURN 8

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,0,1,0,"onlyCrowdsaleContract();require(bool)(state == State.Active);require(bool)(totalDeposited >= value);totalDeposited = totalDeposited.sub(value);wallet.transfer(value);Withdrawal(wallet,value);true;success"
./0x17478cc05e51da20a27bbdf66fbe4a16aae81842_ext.sol,AuctionPotato.withdraw,215,266,"TMP_46(bool) = blockerWithdraw == False,TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46),blockerWithdraw(bool) := True(bool),CONDITION canceled,withdrawalAccount(address) := msg.sender(address),REF_17(uint256) -> fundsByBidder[withdrawalAccount],withdrawalAmount(uint256) := REF_17(uint256),REF_18(uint256) -> fundsByBidder[withdrawalAccount],REF_18(uint256) (->fundsByBidder) := 0(uint256),TMP_48(bool) = ownerHasWithdrawn == False,TMP_49(bool) = msg.sender == owner,TMP_50(bool) = TMP_48 && TMP_49,TMP_51(bool) = canceled == True,TMP_52(bool) = now > endTime,TMP_53(bool) = TMP_51 || TMP_52,TMP_54(bool) = TMP_50 && TMP_53,CONDITION TMP_54,withdrawalAccount(address) := owner(address),TMP_55(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['highestBindingBid', 'oldPotato'] ,withdrawalAmount(uint256) := TMP_55(uint256),ownerHasWithdrawn(bool) := True(bool),REF_20(uint256) -> fundsByBidder[withdrawalAccount],REF_20(uint256) (->fundsByBidder) := 0(uint256),TMP_56 = UnaryType.BANG canceled ,TMP_57(bool) = msg.sender != highestBidder,TMP_58(bool) = msg.sender != owner,TMP_59(bool) = TMP_57 && TMP_58,TMP_60(bool) = TMP_56 && TMP_59,CONDITION TMP_60,withdrawalAccount(address) := msg.sender(address),REF_21(uint256) -> fundsByBidder[withdrawalAccount],withdrawalAmount(uint256) := REF_21(uint256),REF_22(uint256) -> fundsByBidder[withdrawalAccount],REF_22(uint256) (->fundsByBidder) := 0(uint256),TMP_61 = UnaryType.BANG canceled ,TMP_62(bool) = msg.sender == highestBidder,TMP_63(bool) = TMP_61 && TMP_62,TMP_64(bool) = msg.sender != owner,TMP_65(bool) = TMP_63 && TMP_64,CONDITION TMP_65,withdrawalAccount(address) := msg.sender(address),REF_23(uint256) -> fundsByBidder[withdrawalAccount],TMP_66(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_23', 'oldHighestBindingBid'] ,withdrawalAmount(uint256) := TMP_66(uint256),REF_25(uint256) -> fundsByBidder[withdrawalAccount],REF_26(uint256) -> fundsByBidder[withdrawalAccount],TMP_67(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_26', 'withdrawalAmount'] ,REF_25(uint256) (->fundsByBidder) := TMP_67(uint256),TMP_68(bool) = withdrawalAmount == 0,CONDITION TMP_68,TMP_69(None) = SOLIDITY_CALL revert()(),Transfer dest:msg.sender value:withdrawalAmount,Emit LogWithdrawal(msg.sender,withdrawalAccount,withdrawalAmount),blockerWithdraw(bool) := False(bool),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(blockerWithdraw == false)

IRs:
TMP_46(bool) = blockerWithdraw == False
TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
blockerWithdraw = true

IRs:
blockerWithdraw(bool) := True(bool)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4
""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
canceled

IRs:
CONDITION canceled""];
5->6[label=""True""];
5->9[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
withdrawalAccount = msg.sender

IRs:
withdrawalAccount(address) := msg.sender(address)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
withdrawalAmount = fundsByBidder[withdrawalAccount]

IRs:
REF_17(uint256) -> fundsByBidder[withdrawalAccount]
withdrawalAmount(uint256) := REF_17(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
fundsByBidder[withdrawalAccount] = 0

IRs:
REF_18(uint256) -> fundsByBidder[withdrawalAccount]
REF_18(uint256) (->fundsByBidder) := 0(uint256)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
ownerHasWithdrawn == false && msg.sender == owner && (canceled == true || now > endTime)

IRs:
TMP_48(bool) = ownerHasWithdrawn == False
TMP_49(bool) = msg.sender == owner
TMP_50(bool) = TMP_48 && TMP_49
TMP_51(bool) = canceled == True
TMP_52(bool) = now > endTime
TMP_53(bool) = TMP_51 || TMP_52
TMP_54(bool) = TMP_50 && TMP_53
CONDITION TMP_54""];
10->11[label=""True""];
10->15[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
withdrawalAccount = owner

IRs:
withdrawalAccount(address) := owner(address)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
withdrawalAmount = highestBindingBid.sub(oldPotato)

IRs:
TMP_55(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['highestBindingBid', 'oldPotato'] 
withdrawalAmount(uint256) := TMP_55(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
ownerHasWithdrawn = true

IRs:
ownerHasWithdrawn(bool) := True(bool)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
fundsByBidder[withdrawalAccount] = 0

IRs:
REF_20(uint256) -> fundsByBidder[withdrawalAccount]
REF_20(uint256) (->fundsByBidder) := 0(uint256)""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: IF 16

EXPRESSION:
! canceled && (msg.sender != highestBidder && msg.sender != owner)

IRs:
TMP_56 = UnaryType.BANG canceled 
TMP_57(bool) = msg.sender != highestBidder
TMP_58(bool) = msg.sender != owner
TMP_59(bool) = TMP_57 && TMP_58
TMP_60(bool) = TMP_56 && TMP_59
CONDITION TMP_60""];
16->17[label=""True""];
16->20[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
withdrawalAccount = msg.sender

IRs:
withdrawalAccount(address) := msg.sender(address)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
withdrawalAmount = fundsByBidder[withdrawalAccount]

IRs:
REF_21(uint256) -> fundsByBidder[withdrawalAccount]
withdrawalAmount(uint256) := REF_21(uint256)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
fundsByBidder[withdrawalAccount] = 0

IRs:
REF_22(uint256) -> fundsByBidder[withdrawalAccount]
REF_22(uint256) (->fundsByBidder) := 0(uint256)""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: IF 21

EXPRESSION:
! canceled && msg.sender == highestBidder && msg.sender != owner

IRs:
TMP_61 = UnaryType.BANG canceled 
TMP_62(bool) = msg.sender == highestBidder
TMP_63(bool) = TMP_61 && TMP_62
TMP_64(bool) = msg.sender != owner
TMP_65(bool) = TMP_63 && TMP_64
CONDITION TMP_65""];
21->22[label=""True""];
21->25[label=""False""];
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
withdrawalAccount = msg.sender

IRs:
withdrawalAccount(address) := msg.sender(address)""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
withdrawalAmount = fundsByBidder[withdrawalAccount].sub(oldHighestBindingBid)

IRs:
REF_23(uint256) -> fundsByBidder[withdrawalAccount]
TMP_66(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_23', 'oldHighestBindingBid'] 
withdrawalAmount(uint256) := TMP_66(uint256)""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
fundsByBidder[withdrawalAccount] = fundsByBidder[withdrawalAccount].sub(withdrawalAmount)

IRs:
REF_25(uint256) -> fundsByBidder[withdrawalAccount]
REF_26(uint256) -> fundsByBidder[withdrawalAccount]
TMP_67(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_26', 'withdrawalAmount'] 
REF_25(uint256) (->fundsByBidder) := TMP_67(uint256)""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->26;
26[label=""Node Type: IF 26

EXPRESSION:
withdrawalAmount == 0

IRs:
TMP_68(bool) = withdrawalAmount == 0
CONDITION TMP_68""];
26->27[label=""True""];
26->28[label=""False""];
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
revert()()

IRs:
TMP_69(None) = SOLIDITY_CALL revert()()""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
msg.sender.transfer(withdrawalAmount)

IRs:
Transfer dest:msg.sender value:withdrawalAmount""];
29->30;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
LogWithdrawal(msg.sender,withdrawalAccount,withdrawalAmount)

IRs:
Emit LogWithdrawal(msg.sender,withdrawalAccount,withdrawalAmount)""];
30->31;
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
blockerWithdraw = false

IRs:
blockerWithdraw(bool) := False(bool)""];
31->32;
32[label=""Node Type: RETURN 32

EXPRESSION:
true

IRs:
RETURN True""];
33[label=""Node Type: RETURN 33

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,0,1,0,"require(bool)(blockerWithdraw == false);blockerWithdraw = true;;;canceled;withdrawalAccount = msg.sender;;withdrawalAmount = fundsByBidder[withdrawalAccount];fundsByBidder[withdrawalAccount] = 0;ownerHasWithdrawn == false && msg.sender == owner && (canceled == true || now > endTime);withdrawalAccount = owner;;withdrawalAmount = highestBindingBid.sub(oldPotato);ownerHasWithdrawn = true;fundsByBidder[withdrawalAccount] = 0;! canceled && (msg.sender != highestBidder && msg.sender != owner);withdrawalAccount = msg.sender;;withdrawalAmount = fundsByBidder[withdrawalAccount];fundsByBidder[withdrawalAccount] = 0;! canceled && msg.sender == highestBidder && msg.sender != owner;withdrawalAccount = msg.sender;;withdrawalAmount = fundsByBidder[withdrawalAccount].sub(oldHighestBindingBid);fundsByBidder[withdrawalAccount] = fundsByBidder[withdrawalAccount].sub(withdrawalAmount);withdrawalAmount == 0;revert()();;msg.sender.transfer(withdrawalAmount);LogWithdrawal(msg.sender,withdrawalAccount,withdrawalAmount);blockerWithdraw = false;true;success"
./0xf4c3a48f27666ef8bedab8d73c0117e1aeaf1ba0_ext.sol,ItemMarket.fallback,266,271,"TMP_124(bool) = msg.value > 0,CONDITION TMP_124,Transfer dest:msg.sender value:msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value > 0

IRs:
TMP_124(bool) = msg.value > 0
CONDITION TMP_124""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(msg.value)

IRs:
Transfer dest:msg.sender value:msg.value""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,0,1,0,msg.value > 0;msg.sender.transfer(msg.value);
./0x945f171de4ea81a213dcc7a1e8c4f6feb3b4b806_ext.sol,ECP_Token.withdraw,105,115,"TMP_13(bool) = msg.sender == owner,TMP_14(bool) = msg.sender == bkaddress,TMP_15(bool) = TMP_13 || TMP_14,CONDITION TMP_15,Transfer dest:benAddress value:amountWith,TMP_17(None) = SOLIDITY_CALL revert()(),MODIFIER_CALL, ECP_Token.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
(msg.sender == owner) || (msg.sender == bkaddress)

IRs:
TMP_13(bool) = msg.sender == owner
TMP_14(bool) = msg.sender == bkaddress
TMP_15(bool) = TMP_13 || TMP_14
CONDITION TMP_15""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
benAddress.transfer(amountWith)

IRs:
Transfer dest:benAddress value:amountWith""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
revert()()

IRs:
TMP_17(None) = SOLIDITY_CALL revert()()""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ECP_Token.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();(msg.sender == owner) || (msg.sender == bkaddress);benAddress.transfer(amountWith);revert()();
./0x50a667b73223bc612bcc43200120b5c46ee6b4e9_ext.sol,RCpro.refundEther,549,553,"REF_140(uint256) -> etherUser[to],Transfer dest:to value:REF_140,REF_141(uint256) -> etherUser[to],REF_141(uint256) (->etherUser) := 0(uint256),REF_142(uint256) -> pendingTokenUser[to],REF_142(uint256) (->pendingTokenUser) := 0(uint256),MODIFIER_CALL, RCpro.onlyTokenSaleOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
to.transfer(etherUser[to])

IRs:
REF_140(uint256) -> etherUser[to]
Transfer dest:to value:REF_140""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
etherUser[to] = 0

IRs:
REF_141(uint256) -> etherUser[to]
REF_141(uint256) (->etherUser) := 0(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
pendingTokenUser[to] = 0

IRs:
REF_142(uint256) -> pendingTokenUser[to]
REF_142(uint256) (->pendingTokenUser) := 0(uint256)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyTokenSaleOwner()

IRs:
MODIFIER_CALL, RCpro.onlyTokenSaleOwner()()""];
4->1;
}
",0,0,1,0,onlyTokenSaleOwner();to.transfer(etherUser[to]);etherUser[to] = 0;pendingTokenUser[to] = 0
./0xf29a03e88c425116c979892d475f5cddf1f742ce_ext.sol,Crowdsale.destroyAndSend,97,99,"TMP_27(None) = SOLIDITY_CALL selfdestruct(address)(_recipient),MODIFIER_CALL, Crowdsale.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(_recipient)

IRs:
TMP_27(None) = SOLIDITY_CALL selfdestruct(address)(_recipient)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Crowdsale.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(_recipient)
./0x0460dcb54214fdf68302b4c733ad7ed827dd6592_ext.sol,evequiz.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x733237b46b1fd6bd3266c9b6daae1c018a9d9493_ext.sol,TFTOKEN.safeWithdrawal,304,309,"TMP_97(bool) = _value == 0,CONDITION TMP_97,TMP_98 = CONVERT this to address,TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98),Transfer dest:owner value:TMP_99,Transfer dest:owner value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_97(bool) = _value == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_98 = CONVERT this to address
TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98)
Transfer dest:owner value:TMP_99""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_value == 0;owner.transfer(address(this).balance);owner.transfer(_value);
./0x029606e5ec44cad1346d6a1273a53b971fa93ad6_ext.sol,Owned.Terminate,69,72,"TMP_14(None) = SOLIDITY_CALL selfdestruct(address)(Owner),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(Owner)

IRs:
TMP_14(None) = SOLIDITY_CALL selfdestruct(address)(Owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(Owner)
./0x1d91b86e5c7b5e85a61eaaea9762958747712826_ext.sol,Token.fallback,377,382,"TMP_71(bool) = INTERNAL_CALL, Token.isContract(address)(controller),TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71),TMP_73 = CONVERT controller to TokenController,TMP_75(bool) = HIGH_LEVEL_CALL, dest:TMP_73(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value ,proxyPayment(bool) := TMP_75(bool),TMP_76(None) = SOLIDITY_CALL require(bool)(proxyPayment)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isContract(controller))

IRs:
TMP_71(bool) = INTERNAL_CALL, Token.isContract(address)(controller)
TMP_72(None) = SOLIDITY_CALL require(bool)(TMP_71)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
proxyPayment = TokenController(controller).proxyPayment.value(msg.value)(msg.sender)

IRs:
TMP_73 = CONVERT controller to TokenController
TMP_75(bool) = HIGH_LEVEL_CALL, dest:TMP_73(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value 
proxyPayment(bool) := TMP_75(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(proxyPayment)

IRs:
TMP_76(None) = SOLIDITY_CALL require(bool)(proxyPayment)""];
}
",0,0,1,0,require(bool)(isContract(controller));proxyPayment = TokenController(controller).proxyPayment.value(msg.value)(msg.sender);require(bool)(proxyPayment)
./0x50a667b73223bc612bcc43200120b5c46ee6b4e9_ext.sol,RCpro.refundEther,549,553,"REF_140(uint256) -> etherUser[to],Transfer dest:to value:REF_140,REF_141(uint256) -> etherUser[to],REF_141(uint256) (->etherUser) := 0(uint256),REF_142(uint256) -> pendingTokenUser[to],REF_142(uint256) (->pendingTokenUser) := 0(uint256),MODIFIER_CALL, RCpro.onlyTokenSaleOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
to.transfer(etherUser[to])

IRs:
REF_140(uint256) -> etherUser[to]
Transfer dest:to value:REF_140""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
etherUser[to] = 0

IRs:
REF_141(uint256) -> etherUser[to]
REF_141(uint256) (->etherUser) := 0(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
pendingTokenUser[to] = 0

IRs:
REF_142(uint256) -> pendingTokenUser[to]
REF_142(uint256) (->pendingTokenUser) := 0(uint256)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyTokenSaleOwner()

IRs:
MODIFIER_CALL, RCpro.onlyTokenSaleOwner()()""];
4->1;
}
",0,0,1,0,onlyTokenSaleOwner();to.transfer(etherUser[to]);etherUser[to] = 0;pendingTokenUser[to] = 0
./0x6f84faf2ce621f5a4ba161f055a56daffbf78b04_ext.sol,Destructible.destroy,350,352,"TMP_168(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_168(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0x2736d225f85740f42d17987100dc8d58e9e16252_ext.sol,ServerRegistry.cancelUnregisteringServer,154,172,"REF_42(ServerRegistry.In3Server) -> servers[_serverIndex],server(ServerRegistry.In3Server) := REF_42(ServerRegistry.In3Server),REF_43(address) -> server.unregisterCaller,TMP_43 = CONVERT 0 to address,TMP_44(bool) = REF_43 != TMP_43,REF_44(address) -> server.owner,TMP_45(bool) = REF_44 == msg.sender,TMP_46(bool) = TMP_44 && TMP_45,TMP_47(None) = SOLIDITY_CALL require(bool,string)(TMP_46,only the owner is allowed to cancel unregister),REF_45(address) -> server.unregisterCaller,REF_46(address) -> server.owner,TMP_48(bool) = REF_45 != REF_46,CONDITION TMP_48,REF_47(address) -> server.owner,REF_49(uint128) -> server.unregisterDeposit,Transfer dest:REF_47 value:REF_49,REF_50(address) -> server.unregisterCaller,TMP_50 = CONVERT 0 to address,REF_50(address) (->server) := TMP_50(address),REF_51(uint128) -> server.unregisterTime,REF_51(uint128) (->server) := 0(uint256),REF_52(uint128) -> server.unregisterDeposit,REF_52(uint128) (->server) := 0(uint256),REF_53(string) -> server.url,REF_54(address) -> server.owner,Emit LogServerUnregisterCanceled(REF_53,REF_54)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
server = servers[_serverIndex]

IRs:
REF_42(ServerRegistry.In3Server) -> servers[_serverIndex]
server(ServerRegistry.In3Server) := REF_42(ServerRegistry.In3Server)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(server.unregisterCaller != address(0) && server.owner == msg.sender,only the owner is allowed to cancel unregister)

IRs:
REF_43(address) -> server.unregisterCaller
TMP_43 = CONVERT 0 to address
TMP_44(bool) = REF_43 != TMP_43
REF_44(address) -> server.owner
TMP_45(bool) = REF_44 == msg.sender
TMP_46(bool) = TMP_44 && TMP_45
TMP_47(None) = SOLIDITY_CALL require(bool,string)(TMP_46,only the owner is allowed to cancel unregister)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
server.unregisterCaller != server.owner

IRs:
REF_45(address) -> server.unregisterCaller
REF_46(address) -> server.owner
TMP_48(bool) = REF_45 != REF_46
CONDITION TMP_48""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
server.owner.transfer(server.unregisterDeposit)

IRs:
REF_47(address) -> server.owner
REF_49(uint128) -> server.unregisterDeposit
Transfer dest:REF_47 value:REF_49""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
server.unregisterCaller = address(0)

IRs:
REF_50(address) -> server.unregisterCaller
TMP_50 = CONVERT 0 to address
REF_50(address) (->server) := TMP_50(address)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
server.unregisterTime = 0

IRs:
REF_51(uint128) -> server.unregisterTime
REF_51(uint128) (->server) := 0(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
server.unregisterDeposit = 0

IRs:
REF_52(uint128) -> server.unregisterDeposit
REF_52(uint128) (->server) := 0(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
LogServerUnregisterCanceled(server.url,server.owner)

IRs:
REF_53(string) -> server.url
REF_54(address) -> server.owner
Emit LogServerUnregisterCanceled(REF_53,REF_54)""];
}
",0,0,1,0,"server = servers[_serverIndex];require(bool,string)(server.unregisterCaller != address(0) && server.owner == msg.sender,only the owner is allowed to cancel unregister);server.unregisterCaller != server.owner;server.owner.transfer(server.unregisterDeposit);;server.unregisterCaller = address(0);server.unregisterTime = 0;server.unregisterDeposit = 0;LogServerUnregisterCanceled(server.url,server.owner)"
./0x32ceb540334300bcd53836a25a4bd64d607babd8_ext.sol,BetGame.claimTokens,552,564,"TMP_188(bool) = _token == 0,CONDITION TMP_188,REF_242(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:owner value:REF_242,TMP_190 = CONVERT _token to ERC20,token(ERC20) := TMP_190(ERC20),TMP_191(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_191(uint256),TMP_192(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['owner', 'balance']  ,Emit ClaimedTokens(_token,owner,balance),MODIFIER_CALL, DSAuth.auth()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_188(bool) = _token == 0
CONDITION TMP_188""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(this.balance)

IRs:
REF_242(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:owner value:REF_242""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
token = ERC20(_token)

IRs:
TMP_190 = CONVERT _token to ERC20
token(ERC20) := TMP_190(ERC20)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_191(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_191(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(owner,balance)

IRs:
TMP_192(bool) = HIGH_LEVEL_CALL, dest:token(ERC20), function:transfer, arguments:['owner', 'balance']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,owner,balance)

IRs:
Emit ClaimedTokens(_token,owner,balance)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
9->1;
}
",0,0,1,0,"auth();_token == 0x0;owner.transfer(this.balance);;;token = ERC20(_token);balance = token.balanceOf(this);token.transfer(owner,balance);ClaimedTokens(_token,owner,balance)"
./0x8b548505babfd983fc45210499b44e340bb85d76_ext.sol,Hedgely.withdraw,432,438,"REF_104(uint256) = SOLIDITY_CALL balance(address)(this),TMP_146(bool) = amount <= REF_104,TMP_147(None) = SOLIDITY_CALL require(bool)(TMP_146),TMP_148(bool) = amount == 0,CONDITION TMP_148,REF_105(uint256) = SOLIDITY_CALL balance(address)(this),amount(uint256) := REF_105([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E3532C40>]),Transfer dest:owner value:amount,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(amount <= this.balance)

IRs:
REF_104(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_146(bool) = amount <= REF_104
TMP_147(None) = SOLIDITY_CALL require(bool)(TMP_146)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
amount == 0

IRs:
TMP_148(bool) = amount == 0
CONDITION TMP_148""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
amount = this.balance

IRs:
REF_105(uint256) = SOLIDITY_CALL balance(address)(this)
amount(uint256) := REF_105([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E3532C40>])""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
owner.transfer(amount)

IRs:
Transfer dest:owner value:amount""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
6->1;
}
",0,0,1,0,onlyOwner();require(bool)(amount <= this.balance);amount == 0;amount = this.balance;;owner.transfer(amount)
./0x0254ffd95dd7c8e27d4c7a32e24464196efcc852_ext.sol,BEATA.safeWithdrawal,304,309,"TMP_97(bool) = _value == 0,CONDITION TMP_97,TMP_98 = CONVERT this to address,TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98),Transfer dest:owner value:TMP_99,Transfer dest:owner value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_97(bool) = _value == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_98 = CONVERT this to address
TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98)
Transfer dest:owner value:TMP_99""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_value == 0;owner.transfer(address(this).balance);owner.transfer(_value);
./0xc5005344d52758ee2264be257a198b50f884711b_ext.sol,illume.withdrawAll,290,294,"myAddress(address) := this(address),TMP_138(uint256) = SOLIDITY_CALL balance(address)(myAddress),etherBalance(uint256) := TMP_138(uint256),Transfer dest:owner value:etherBalance,MODIFIER_CALL, illume.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
myAddress = this

IRs:
myAddress(address) := this(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
etherBalance = myAddress.balance

IRs:
TMP_138(uint256) = SOLIDITY_CALL balance(address)(myAddress)
etherBalance(uint256) := TMP_138(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(etherBalance)

IRs:
Transfer dest:owner value:etherBalance""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, illume.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();myAddress = this;etherBalance = myAddress.balance;owner.transfer(etherBalance)
./0x533ec971484b1014215422010978e892eacac430_ext.sol,MortifyAsset.withdrawAll,288,292,"myAddress(address) := this(address),TMP_138(uint256) = SOLIDITY_CALL balance(address)(myAddress),etherBalance(uint256) := TMP_138(uint256),Transfer dest:owner value:etherBalance,MODIFIER_CALL, MortifyAsset.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
myAddress = this

IRs:
myAddress(address) := this(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
etherBalance = myAddress.balance

IRs:
TMP_138(uint256) = SOLIDITY_CALL balance(address)(myAddress)
etherBalance(uint256) := TMP_138(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(etherBalance)

IRs:
Transfer dest:owner value:etherBalance""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MortifyAsset.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();myAddress = this;etherBalance = myAddress.balance;owner.transfer(etherBalance)
./0x5b2028602af2693d50b4157f4acf84d632ec8208_ext.sol,Savings.withdraw,37,45,"TMP_6(bool) = INTERNAL_CALL, Ownable.isOwner()(),TMP_7(bool) = now >= openDate,TMP_8(bool) = TMP_6 && TMP_7,CONDITION TMP_8,REF_1(uint256) -> deposits[msg.sender],max(uint256) := REF_1(uint256),TMP_9(bool) = amount <= max,TMP_10(bool) = max > 0,TMP_11(bool) = TMP_9 && TMP_10,CONDITION TMP_11,Transfer dest:msg.sender value:amount,Emit Withdrawal(msg.sender,amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
isOwner() && now >= openDate

IRs:
TMP_6(bool) = INTERNAL_CALL, Ownable.isOwner()()
TMP_7(bool) = now >= openDate
TMP_8(bool) = TMP_6 && TMP_7
CONDITION TMP_8""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
max = deposits[msg.sender]

IRs:
REF_1(uint256) -> deposits[msg.sender]
max(uint256) := REF_1(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
amount <= max && max > 0

IRs:
TMP_9(bool) = amount <= max
TMP_10(bool) = max > 0
TMP_11(bool) = TMP_9 && TMP_10
CONDITION TMP_11""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Withdrawal(msg.sender,amount)

IRs:
Emit Withdrawal(msg.sender,amount)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: END_IF 7
""];
}
",0,0,1,0,"isOwner() && now >= openDate;max = deposits[msg.sender];;amount <= max && max > 0;msg.sender.transfer(amount);;Withdrawal(msg.sender,amount)"
./0xecbd0854075009d23360c62da07047efc2312144_ext.sol,Crowdsale.safeWithdrawal,71,92,"TMP_13 = UnaryType.BANG fundingGoalReached ,CONDITION TMP_13,REF_2(uint256) -> balanceOf[msg.sender],amount(uint256) := REF_2(uint256),REF_3(uint256) -> balanceOf[msg.sender],REF_3(uint256) (->balanceOf) := 0(uint256),TMP_14(bool) = amount > 0,CONDITION TMP_14,TMP_15 = SEND dest:msg.sender value:amount,CONDITION TMP_15,Emit FundTransfer(msg.sender,amount,False),REF_5(uint256) -> balanceOf[msg.sender],REF_5(uint256) (->balanceOf) := amount(uint256),TMP_17(bool) = beneficiary == msg.sender,TMP_18(bool) = fundingGoalReached && TMP_17,CONDITION TMP_18,TMP_19 = SEND dest:beneficiary value:amountRaised,CONDITION TMP_19,Emit FundTransfer(beneficiary,amountRaised,False),fundingGoalReached(bool) := False(bool),MODIFIER_CALL, Crowdsale.afterDeadline()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->17;
1[label=""Node Type: IF 1

EXPRESSION:
! fundingGoalReached

IRs:
TMP_13 = UnaryType.BANG fundingGoalReached 
CONDITION TMP_13""];
1->2[label=""True""];
1->10[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = balanceOf[msg.sender]

IRs:
REF_2(uint256) -> balanceOf[msg.sender]
amount(uint256) := REF_2(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[msg.sender] = 0

IRs:
REF_3(uint256) -> balanceOf[msg.sender]
REF_3(uint256) (->balanceOf) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
amount > 0

IRs:
TMP_14(bool) = amount > 0
CONDITION TMP_14""];
4->5[label=""True""];
4->9[label=""False""];
5[label=""Node Type: IF 5

EXPRESSION:
msg.sender.send(amount)

IRs:
TMP_15 = SEND dest:msg.sender value:amount
CONDITION TMP_15""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
FundTransfer(msg.sender,amount,false)

IRs:
Emit FundTransfer(msg.sender,amount,False)""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
balanceOf[msg.sender] = amount

IRs:
REF_5(uint256) -> balanceOf[msg.sender]
REF_5(uint256) (->balanceOf) := amount(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
fundingGoalReached && beneficiary == msg.sender

IRs:
TMP_17(bool) = beneficiary == msg.sender
TMP_18(bool) = fundingGoalReached && TMP_17
CONDITION TMP_18""];
11->12[label=""True""];
11->16[label=""False""];
12[label=""Node Type: IF 12

EXPRESSION:
beneficiary.send(amountRaised)

IRs:
TMP_19 = SEND dest:beneficiary value:amountRaised
CONDITION TMP_19""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
FundTransfer(beneficiary,amountRaised,false)

IRs:
Emit FundTransfer(beneficiary,amountRaised,False)""];
13->15;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
fundingGoalReached = false

IRs:
fundingGoalReached(bool) := False(bool)""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: END_IF 16
""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
afterDeadline()

IRs:
MODIFIER_CALL, Crowdsale.afterDeadline()()""];
17->1;
}
",0,0,1,0,"afterDeadline();! fundingGoalReached;amount = balanceOf[msg.sender];;balanceOf[msg.sender] = 0;amount > 0;msg.sender.send(amount);;FundTransfer(msg.sender,amount,false);balanceOf[msg.sender] = amount;;fundingGoalReached && beneficiary == msg.sender;beneficiary.send(amountRaised);;FundTransfer(beneficiary,amountRaised,false);fundingGoalReached = false;"
./0xead7adf1bf0df9f03b15429d82ea1f70ebd619f1_ext.sol,Crowdsale.withdrawFunds,132,151,"TMP_39 = UnaryType.BANG preICOWithdrawn ,TMP_40(bool) = TMP_39 && preICOClosed,TMP_41 = UnaryType.BANG ICOWithdrawn ,TMP_42(bool) = TMP_41 && ICOClosed,TMP_43(bool) = TMP_40 || TMP_42,TMP_44(None) = SOLIDITY_CALL require(bool)(TMP_43),TMP_45 = UnaryType.BANG preICOWithdrawn ,TMP_46(bool) = TMP_45 && preICOClosed,CONDITION TMP_46,TMP_47 = SEND dest:beneficiary value:preICORaised,CONDITION TMP_47,preICOWithdrawn(bool) := True(bool),Emit FundTransfer(beneficiary,preICORaised,False),TMP_49 = UnaryType.BANG ICOWithdrawn ,TMP_50(bool) = TMP_49 && ICOClosed,CONDITION TMP_50,TMP_51 = SEND dest:beneficiary value:ICORaised,CONDITION TMP_51,ICOWithdrawn(bool) := True(bool),Emit FundTransfer(beneficiary,ICORaised,False),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->14;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)((! preICOWithdrawn && preICOClosed) || (! ICOWithdrawn && ICOClosed))

IRs:
TMP_39 = UnaryType.BANG preICOWithdrawn 
TMP_40(bool) = TMP_39 && preICOClosed
TMP_41 = UnaryType.BANG ICOWithdrawn 
TMP_42(bool) = TMP_41 && ICOClosed
TMP_43(bool) = TMP_40 || TMP_42
TMP_44(None) = SOLIDITY_CALL require(bool)(TMP_43)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
! preICOWithdrawn && preICOClosed

IRs:
TMP_45 = UnaryType.BANG preICOWithdrawn 
TMP_46(bool) = TMP_45 && preICOClosed
CONDITION TMP_46""];
2->3[label=""True""];
2->7[label=""False""];
3[label=""Node Type: IF 3

EXPRESSION:
beneficiary.send(preICORaised)

IRs:
TMP_47 = SEND dest:beneficiary value:preICORaised
CONDITION TMP_47""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
preICOWithdrawn = true

IRs:
preICOWithdrawn(bool) := True(bool)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
FundTransfer(beneficiary,preICORaised,false)

IRs:
Emit FundTransfer(beneficiary,preICORaised,False)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
! ICOWithdrawn && ICOClosed

IRs:
TMP_49 = UnaryType.BANG ICOWithdrawn 
TMP_50(bool) = TMP_49 && ICOClosed
CONDITION TMP_50""];
8->9[label=""True""];
8->13[label=""False""];
9[label=""Node Type: IF 9

EXPRESSION:
beneficiary.send(ICORaised)

IRs:
TMP_51 = SEND dest:beneficiary value:ICORaised
CONDITION TMP_51""];
9->10[label=""True""];
9->12[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
ICOWithdrawn = true

IRs:
ICOWithdrawn(bool) := True(bool)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
FundTransfer(beneficiary,ICORaised,false)

IRs:
Emit FundTransfer(beneficiary,ICORaised,False)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: END_IF 13
""];
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
14->1;
}
",0,0,1,0,"onlyOwner();require(bool)((! preICOWithdrawn && preICOClosed) || (! ICOWithdrawn && ICOClosed));! preICOWithdrawn && preICOClosed;beneficiary.send(preICORaised);;preICOWithdrawn = true;;FundTransfer(beneficiary,preICORaised,false);! ICOWithdrawn && ICOClosed;beneficiary.send(ICORaised);;ICOWithdrawn = true;;FundTransfer(beneficiary,ICORaised,false)"
./0xeece3bfd3c83715f1f801dfa6b735ac9093c5bc3_ext.sol,SecuritySale.withdraw,231,233,"TMP_73 = CONVERT this to address,TMP_74(uint256) = SOLIDITY_CALL balance(address)(TMP_73),Transfer dest:msg.sender value:TMP_74,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(address(this).balance)

IRs:
TMP_73 = CONVERT this to address
TMP_74(uint256) = SOLIDITY_CALL balance(address)(TMP_73)
Transfer dest:msg.sender value:TMP_74""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();msg.sender.transfer(address(this).balance)
./0x3ac86159fad58c90aaea1c61974d69d4f8ce8e77_ext.sol,Crowdsale.sendOracleData,837,843,"TMP_306(bool) = msg.value != 0,CONDITION TMP_306,Transfer dest:wrapper value:msg.value,HIGH_LEVEL_CALL, dest:wrapper(WrapperOraclize), function:update, arguments:['URL', 'json(https://api.kraken.com/0/public/Ticker?pair=ETHUSD).result.XETHZUSD.c.0']  ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value != 0

IRs:
TMP_306(bool) = msg.value != 0
CONDITION TMP_306""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
wrapper.transfer(msg.value)

IRs:
Transfer dest:wrapper value:msg.value""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
wrapper.update(URL,json(https://api.kraken.com/0/public/Ticker?pair=ETHUSD).result.XETHZUSD.c.0)

IRs:
HIGH_LEVEL_CALL, dest:wrapper(WrapperOraclize), function:update, arguments:['URL', 'json(https://api.kraken.com/0/public/Ticker?pair=ETHUSD).result.XETHZUSD.c.0']  ""];
}
",0,0,1,0,"msg.value != 0;wrapper.transfer(msg.value);;wrapper.update(URL,json(https://api.kraken.com/0/public/Ticker?pair=ETHUSD).result.XETHZUSD.c.0)"
./0x2af8b34f04e93c79ee3a1f300a019f29869d896a_ext.sol,SiliconValleyToken.withdrawAmount,685,701,"wallet(address) := owner(address),CONDITION acceptAdminWithdraw,wallet(address) := msg.sender(address),TMP_657 = CONVERT this to address,TMP_658(uint256) = SOLIDITY_CALL balance(address)(TMP_657),Emit Withdraw(msg.sender,wallet,TMP_658),TMP_660 = CONVERT this to address,TMP_661(uint256) = SOLIDITY_CALL balance(address)(TMP_660),Transfer dest:wallet value:TMP_661,RETURN True,REF_318(Authorizable.Level) -> Level.ADMIN,MODIFIER_CALL, Authorizable.authLevel(Authorizable.Level)(REF_318),TMP_664 = CONVERT this to address,TMP_665(uint256) = SOLIDITY_CALL balance(address)(TMP_664),MODIFIER_CALL, Utils.greaterThanZero(uint256)(TMP_665),MODIFIER_CALL, Utils.greaterThanZero(uint256)(_amount),MODIFIER_CALL, Utils.validBalanceThis(uint256)(_amount),RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wallet = owner

IRs:
wallet(address) := owner(address)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
acceptAdminWithdraw

IRs:
CONDITION acceptAdminWithdraw""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
wallet = msg.sender

IRs:
wallet(address) := msg.sender(address)""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Withdraw(msg.sender,wallet,address(this).balance)

IRs:
TMP_657 = CONVERT this to address
TMP_658(uint256) = SOLIDITY_CALL balance(address)(TMP_657)
Emit Withdraw(msg.sender,wallet,TMP_658)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
wallet.transfer(address(this).balance)

IRs:
TMP_660 = CONVERT this to address
TMP_661(uint256) = SOLIDITY_CALL balance(address)(TMP_660)
Transfer dest:wallet value:TMP_661""];
6->7;
7[label=""Node Type: RETURN 7

EXPRESSION:
true

IRs:
RETURN True""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
authLevel(Level.ADMIN)

IRs:
REF_318(Authorizable.Level) -> Level.ADMIN
MODIFIER_CALL, Authorizable.authLevel(Authorizable.Level)(REF_318)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
greaterThanZero(address(this).balance)

IRs:
TMP_664 = CONVERT this to address
TMP_665(uint256) = SOLIDITY_CALL balance(address)(TMP_664)
MODIFIER_CALL, Utils.greaterThanZero(uint256)(TMP_665)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
greaterThanZero(_amount)

IRs:
MODIFIER_CALL, Utils.greaterThanZero(uint256)(_amount)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
validBalanceThis(_amount)

IRs:
MODIFIER_CALL, Utils.validBalanceThis(uint256)(_amount)""];
11->1;
12[label=""Node Type: RETURN 12

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,0,1,0,"authLevel(Level.ADMIN);wallet = owner;acceptAdminWithdraw;wallet = msg.sender;;Withdraw(msg.sender,wallet,address(this).balance);wallet.transfer(address(this).balance);true;greaterThanZero(address(this).balance);greaterThanZero(_amount);validBalanceThis(_amount);success"
./0x5314dd28de3f215647b64ccb3701e6098a80d080_ext.sol,CryptoAtomsLogic.autoRentByAtom,361,366,"TMP_162(bool) = newAtomFee == msg.value,TMP_163(None) = SOLIDITY_CALL require(bool)(TMP_162),Transfer dest:CaDataAddress value:newAtomFee,TMP_165(uint256) = HIGH_LEVEL_CALL, dest:CaCoreContract(CaCoreInterface), function:createCombinedAtom, arguments:['_atomId', '_ownedId']  ,id(uint256) := TMP_165(uint256),Emit NewAutoRentAtom(msg.sender,id),MODIFIER_CALL, CryptoAtomsLogic.onlyActive()(),MODIFIER_CALL, CryptoAtomsLogic.beDifferent(uint256,uint256)(_atomId,_ownedId),MODIFIER_CALL, CryptoAtomsLogic.onlyOwnerOf(uint256,bool)(_atomId,True),MODIFIER_CALL, CryptoAtomsLogic.onlyOwnerOf(uint256,bool)(_ownedId,True),MODIFIER_CALL, CryptoAtomsLogic.onlyReady(uint256)(_atomId),MODIFIER_CALL, CryptoAtomsLogic.onlyReady(uint256)(_ownedId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(newAtomFee == msg.value)

IRs:
TMP_162(bool) = newAtomFee == msg.value
TMP_163(None) = SOLIDITY_CALL require(bool)(TMP_162)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
CaDataAddress.transfer(newAtomFee)

IRs:
Transfer dest:CaDataAddress value:newAtomFee""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
id = CaCoreContract.createCombinedAtom(_atomId,_ownedId)

IRs:
TMP_165(uint256) = HIGH_LEVEL_CALL, dest:CaCoreContract(CaCoreInterface), function:createCombinedAtom, arguments:['_atomId', '_ownedId']  
id(uint256) := TMP_165(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
NewAutoRentAtom(msg.sender,id)

IRs:
Emit NewAutoRentAtom(msg.sender,id)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyActive()

IRs:
MODIFIER_CALL, CryptoAtomsLogic.onlyActive()()""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
beDifferent(_atomId,_ownedId)

IRs:
MODIFIER_CALL, CryptoAtomsLogic.beDifferent(uint256,uint256)(_atomId,_ownedId)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwnerOf(_atomId,true)

IRs:
MODIFIER_CALL, CryptoAtomsLogic.onlyOwnerOf(uint256,bool)(_atomId,True)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwnerOf(_ownedId,true)

IRs:
MODIFIER_CALL, CryptoAtomsLogic.onlyOwnerOf(uint256,bool)(_ownedId,True)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyReady(_atomId)

IRs:
MODIFIER_CALL, CryptoAtomsLogic.onlyReady(uint256)(_atomId)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyReady(_ownedId)

IRs:
MODIFIER_CALL, CryptoAtomsLogic.onlyReady(uint256)(_ownedId)""];
10->1;
}
",0,0,1,0,"onlyActive();require(bool)(newAtomFee == msg.value);CaDataAddress.transfer(newAtomFee);id = CaCoreContract.createCombinedAtom(_atomId,_ownedId);NewAutoRentAtom(msg.sender,id);beDifferent(_atomId,_ownedId);onlyOwnerOf(_atomId,true);onlyOwnerOf(_ownedId,true);onlyReady(_atomId);onlyReady(_ownedId)"
./0x4bfed6f4fd57a1709b469e1a8918c6921e82a4f9_ext.sol,ALFA_QUIZ.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x379f2596d4c4a417ef1023b81c8b9ff5419b13d4_ext.sol,EncryptedToken.selfdestructs,162,164,"TMP_88(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_88(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0xef078a64e1593afee09912d18097bc49fa74c7a9_ext.sol,ETHER_Game.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x46c9f93c3249c430c6ca19f02240ef9e038ba9d1_ext.sol,FundForwarder.fallback,254,262,"amount(uint256) := msg.value(uint256),TMP_75(bool) = HIGH_LEVEL_CALL, dest:beneficiary(Campaign), function:proxyPayment, arguments:['msg.sender'] value:amount ,TMP_76(None) = SOLIDITY_CALL require(bool)(TMP_75),Emit FundsSent(msg.sender,amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1
""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
amount = msg.value

IRs:
amount(uint256) := msg.value(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(beneficiary.proxyPayment.value(amount)(msg.sender))

IRs:
TMP_75(bool) = HIGH_LEVEL_CALL, dest:beneficiary(Campaign), function:proxyPayment, arguments:['msg.sender'] value:amount 
TMP_76(None) = SOLIDITY_CALL require(bool)(TMP_75)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
FundsSent(msg.sender,amount)

IRs:
Emit FundsSent(msg.sender,amount)""];
}
",0,0,1,0,";amount = msg.value;require(bool)(beneficiary.proxyPayment.value(amount)(msg.sender));FundsSent(msg.sender,amount)"
./0x4d3b775a793aa40e52e5ebd76d1904318fcf4989_ext.sol,TokenERC20.fallback,54,63,"TMP_15(bool) = amount <= 50000000000000000000000000,TMP_16(bool) = now <= 1540051199,TMP_17(bool) = TMP_15 && TMP_16,CONDITION TMP_17,TMP_18(uint256) = msg.value / 2,Transfer dest:addr2 value:TMP_18,TMP_20(uint256) = msg.value / 2,Transfer dest:addr value:TMP_20,TMP_22(uint256) = msg.value * bili,a(uint256) := TMP_22(uint256),TMP_23(uint256) = amount + a,amount(uint256) := TMP_23(uint256),TMP_24(bool) = HIGH_LEVEL_CALL, dest:tokenReward(token), function:setxiudao, arguments:['msg.sender', 'a', 'True']  ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
amount <= 50000000000000000000000000 && now <= 1540051199

IRs:
TMP_15(bool) = amount <= 50000000000000000000000000
TMP_16(bool) = now <= 1540051199
TMP_17(bool) = TMP_15 && TMP_16
CONDITION TMP_17""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
addr2.transfer(msg.value / 2)

IRs:
TMP_18(uint256) = msg.value / 2
Transfer dest:addr2 value:TMP_18""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
addr.transfer(msg.value / 2)

IRs:
TMP_20(uint256) = msg.value / 2
Transfer dest:addr value:TMP_20""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
a = msg.value * bili

IRs:
TMP_22(uint256) = msg.value * bili
a(uint256) := TMP_22(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
amount = amount + a

IRs:
TMP_23(uint256) = amount + a
amount(uint256) := TMP_23(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
tokenReward.setxiudao(msg.sender,a,true)

IRs:
TMP_24(bool) = HIGH_LEVEL_CALL, dest:tokenReward(token), function:setxiudao, arguments:['msg.sender', 'a', 'True']  ""];
6->7;
7[label=""Node Type: END_IF 7
""];
}
",0,0,1,0,"amount <= 50000000000000000000000000 && now <= 1540051199;addr2.transfer(msg.value / 2);;addr.transfer(msg.value / 2);a = msg.value * bili;amount = amount + a;tokenReward.setxiudao(msg.sender,a,true)"
./0x410af23334e26aa13c1f3e630bae006bdd313264_ext.sol,ClearToken.requestRefund,534,544,"REF_142(uint256) -> ethPossibleRefunds[msg.sender],TMP_172(bool) = REF_142 > 0,TMP_173(None) = SOLIDITY_CALL require(bool)(TMP_172),REF_143(uint256) -> ethPossibleRefunds[msg.sender],payout(uint256) := REF_143(uint256),REF_144(uint256) -> ethPossibleRefunds[msg.sender],REF_144(uint256) (->ethPossibleRefunds) := 0(uint256),Transfer dest:msg.sender value:payout,REF_146(ClearToken.States) -> States.Underfunded,MODIFIER_CALL, ClearToken.requireState(ClearToken.States)(REF_146)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(ethPossibleRefunds[msg.sender] > 0)

IRs:
REF_142(uint256) -> ethPossibleRefunds[msg.sender]
TMP_172(bool) = REF_142 > 0
TMP_173(None) = SOLIDITY_CALL require(bool)(TMP_172)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
payout = ethPossibleRefunds[msg.sender]

IRs:
REF_143(uint256) -> ethPossibleRefunds[msg.sender]
payout(uint256) := REF_143(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
ethPossibleRefunds[msg.sender] = 0

IRs:
REF_144(uint256) -> ethPossibleRefunds[msg.sender]
REF_144(uint256) (->ethPossibleRefunds) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(payout)

IRs:
Transfer dest:msg.sender value:payout""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
requireState(States.Underfunded)

IRs:
REF_146(ClearToken.States) -> States.Underfunded
MODIFIER_CALL, ClearToken.requireState(ClearToken.States)(REF_146)""];
5->1;
}
",0,0,1,0,requireState(States.Underfunded);require(bool)(ethPossibleRefunds[msg.sender] > 0);payout = ethPossibleRefunds[msg.sender];ethPossibleRefunds[msg.sender] = 0;msg.sender.transfer(payout)
./0x299187bb996599f7fc82df025ee8964cafe3085a_ext.sol,Challenge.withdraw,15,22,"TMP_0 = CONVERT this to address,TMP_1(uint256) = SOLIDITY_CALL balance(address)(TMP_0),TMP_2(bool) = TMP_1 > 0,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),TMP_4 = CONVERT this to address,TMP_5(uint256) = SOLIDITY_CALL balance(address)(TMP_4),TMP_6(bool) = TMP_5 > 10000000000000000,CONDITION TMP_6,TMP_7 = CONVERT this to address,TMP_8(uint256) = SOLIDITY_CALL balance(address)(TMP_7),TMP_9(uint256) = TMP_8 - 10000000000000000,Transfer dest:previous_owner value:TMP_9,TMP_11 = CONVERT this to address,TMP_12(uint256) = SOLIDITY_CALL balance(address)(TMP_11),Transfer dest:creator value:TMP_12","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(address(this).balance > 0)

IRs:
TMP_0 = CONVERT this to address
TMP_1(uint256) = SOLIDITY_CALL balance(address)(TMP_0)
TMP_2(bool) = TMP_1 > 0
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
address(this).balance > 10000000000000000

IRs:
TMP_4 = CONVERT this to address
TMP_5(uint256) = SOLIDITY_CALL balance(address)(TMP_4)
TMP_6(bool) = TMP_5 > 10000000000000000
CONDITION TMP_6""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
previous_owner.transfer(address(this).balance - 10000000000000000)

IRs:
TMP_7 = CONVERT this to address
TMP_8(uint256) = SOLIDITY_CALL balance(address)(TMP_7)
TMP_9(uint256) = TMP_8 - 10000000000000000
Transfer dest:previous_owner value:TMP_9""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
creator.transfer(address(this).balance)

IRs:
TMP_11 = CONVERT this to address
TMP_12(uint256) = SOLIDITY_CALL balance(address)(TMP_11)
Transfer dest:creator value:TMP_12""];
}
",0,0,1,0,require(bool)(address(this).balance > 0);address(this).balance > 10000000000000000;previous_owner.transfer(address(this).balance - 10000000000000000);;creator.transfer(address(this).balance)
./0x365ec7b439abcc8a3a2c4289f0868a4adcd996e9_ext.sol,EtherRacingCore.cashOut,274,289,"TMP_46(bool) = _amount >= 0,TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46),TMP_48 = CONVERT _amount to uint128,TMP_49 = CONVERT TMP_48 to uint256,TMP_50(bool) = _amount == TMP_49,TMP_51(None) = SOLIDITY_CALL require(bool)(TMP_50),REF_1(uint256) = SOLIDITY_CALL balance(address)(this),TMP_52(bool) = REF_1 >= _amount,TMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52),REF_2(uint256) -> balances[msg.sender],TMP_54(bool) = REF_2 >= _amount,TMP_55(None) = SOLIDITY_CALL require(bool)(TMP_54),TMP_56(bool) = _amount == 0,CONDITION TMP_56,REF_3(uint256) -> balances[msg.sender],_amount(uint256) := REF_3(uint256),REF_4(uint256) -> balances[msg.sender],REF_4(-> balances) = REF_4 - _amount,TMP_57 = SEND dest:msg.sender value:_amount,TMP_58 = UnaryType.BANG TMP_57 ,CONDITION TMP_58,REF_6(uint256) -> balances[msg.sender],REF_6(-> balances) = REF_6 + _amount,Emit EventCashOut(msg.sender,_amount),MODIFIER_CALL, Pausable.whenNotPaused()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->13;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_amount >= 0)

IRs:
TMP_46(bool) = _amount >= 0
TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amount == uint256(uint128(_amount)))

IRs:
TMP_48 = CONVERT _amount to uint128
TMP_49 = CONVERT TMP_48 to uint256
TMP_50(bool) = _amount == TMP_49
TMP_51(None) = SOLIDITY_CALL require(bool)(TMP_50)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(this.balance >= _amount)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_52(bool) = REF_1 >= _amount
TMP_53(None) = SOLIDITY_CALL require(bool)(TMP_52)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(balances[msg.sender] >= _amount)

IRs:
REF_2(uint256) -> balances[msg.sender]
TMP_54(bool) = REF_2 >= _amount
TMP_55(None) = SOLIDITY_CALL require(bool)(TMP_54)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
_amount == 0

IRs:
TMP_56(bool) = _amount == 0
CONDITION TMP_56""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
_amount = balances[msg.sender]

IRs:
REF_3(uint256) -> balances[msg.sender]
_amount(uint256) := REF_3(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[msg.sender] -= _amount

IRs:
REF_4(uint256) -> balances[msg.sender]
REF_4(-> balances) = REF_4 - _amount""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
! msg.sender.send(_amount)

IRs:
TMP_57 = SEND dest:msg.sender value:_amount
TMP_58 = UnaryType.BANG TMP_57 
CONDITION TMP_58""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
balances[msg.sender] += _amount

IRs:
REF_6(uint256) -> balances[msg.sender]
REF_6(-> balances) = REF_6 + _amount""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
EventCashOut(msg.sender,_amount)

IRs:
Emit EventCashOut(msg.sender,_amount)""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
whenNotPaused()

IRs:
MODIFIER_CALL, Pausable.whenNotPaused()()""];
13->1;
}
",0,0,1,0,"whenNotPaused();require(bool)(_amount >= 0);require(bool)(_amount == uint256(uint128(_amount)));require(bool)(this.balance >= _amount);require(bool)(balances[msg.sender] >= _amount);_amount == 0;_amount = balances[msg.sender];;balances[msg.sender] -= _amount;! msg.sender.send(_amount);balances[msg.sender] += _amount;;EventCashOut(msg.sender,_amount)"
./0xf28460e6c571f1d1e481c81dd84973f9b00e1b7b_ext.sol,KpopItem.withdraw,215,220,"TMP_83(bool) = INTERNAL_CALL, KpopItem.isNullAddress(address)(_to),TMP_84 = UnaryType.BANG TMP_83 ,TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84),REF_35(uint256) = SOLIDITY_CALL balance(address)(this),TMP_86(bool) = _amount <= REF_35,TMP_87(None) = SOLIDITY_CALL require(bool)(TMP_86),Transfer dest:_to value:_amount,MODIFIER_CALL, KpopItem.onlyAuthors()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isNullAddress(_to))

IRs:
TMP_83(bool) = INTERNAL_CALL, KpopItem.isNullAddress(address)(_to)
TMP_84 = UnaryType.BANG TMP_83 
TMP_85(None) = SOLIDITY_CALL require(bool)(TMP_84)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amount <= this.balance)

IRs:
REF_35(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_86(bool) = _amount <= REF_35
TMP_87(None) = SOLIDITY_CALL require(bool)(TMP_86)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_to.transfer(_amount)

IRs:
Transfer dest:_to value:_amount""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyAuthors()

IRs:
MODIFIER_CALL, KpopItem.onlyAuthors()()""];
4->1;
}
",0,0,1,0,onlyAuthors();require(bool)(! isNullAddress(_to));require(bool)(_amount <= this.balance);_to.transfer(_amount)
./0x4209f9bbb4e4dd48dbd84701fcaaab1d492b5a05_ext.sol,AccessService.withdraw,107,119,"TMP_37(bool) = msg.sender == addrFinance,TMP_38(bool) = msg.sender == addrAdmin,TMP_39(bool) = TMP_37 || TMP_38,TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39),TMP_41(bool) = _amount > 0,TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41),REF_0(uint256) = SOLIDITY_CALL balance(address)(this),balance(uint256) := REF_0([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B61EB280>]),TMP_43(bool) = _amount < balance,CONDITION TMP_43,Transfer dest:receiver value:_amount,REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:receiver value:REF_3,TMP_46 = CONVERT 0 to address,TMP_47(bool) = _target == TMP_46,CONDITION TMP_47,receiver(address) := addrFinance(address),receiver(address) := _target(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == addrFinance || msg.sender == addrAdmin)

IRs:
TMP_37(bool) = msg.sender == addrFinance
TMP_38(bool) = msg.sender == addrAdmin
TMP_39(bool) = TMP_37 || TMP_38
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amount > 0)

IRs:
TMP_41(bool) = _amount > 0
TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)""];
2->9;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
balance = this.balance

IRs:
REF_0(uint256) = SOLIDITY_CALL balance(address)(this)
balance(uint256) := REF_0([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B61EB280>])""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
_amount < balance

IRs:
TMP_43(bool) = _amount < balance
CONDITION TMP_43""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
receiver.transfer(_amount)

IRs:
Transfer dest:receiver value:_amount""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
receiver.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:receiver value:REF_3""];
7->8;
8[label=""Node Type: END_IF 8
""];
9[label=""Node Type: IF 9

EXPRESSION:
_target == address(0)

IRs:
TMP_46 = CONVERT 0 to address
TMP_47(bool) = _target == TMP_46
CONDITION TMP_47""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
receiver = addrFinance

IRs:
receiver(address) := addrFinance(address)""];
10->12;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
receiver = _target

IRs:
receiver(address) := _target(address)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->4;
}
",0,0,1,0,require(bool)(msg.sender == addrFinance || msg.sender == addrAdmin);require(bool)(_amount > 0);_target == address(0);balance = this.balance;_amount < balance;receiver.transfer(_amount);receiver.transfer(this.balance);;receiver = addrFinance;receiver = _target;
./0x1847825ea569501ca50dee126d31ea95f6c62a87_ext.sol,LinCrowdSale.safeWithdrawal,603,634,"TMP_195 = UnaryType.BANG SoftCapReached ,CONDITION TMP_195,REF_131(LinCrowdSale.Investor) -> Inverstors[msg.sender],REF_132(uint256) -> REF_131.EthAmount,amount(uint256) := REF_132(uint256),REF_133(LinCrowdSale.Investor) -> Inverstors[msg.sender],REF_134(uint256) -> REF_133.EthAmount,REF_134(uint256) (->Inverstors) := 0(uint256),TMP_196(bool) = amount > 0,CONDITION TMP_196,Transfer dest:msg.sender value:amount,TMP_198(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['RefundAmount', 'amount'] ,RefundAmount(uint256) := TMP_198(uint256),Emit SucessWithdraw(msg.sender,amount,now),Emit FailsafeWithdrawal(msg.sender,amount,now),TMP_201(None) = SOLIDITY_CALL revert()(),Emit safeWithdrawalTry(msg.sender),MODIFIER_CALL, LinCrowdSale.afterDeadline()(),MODIFIER_CALL, LinCrowdSale.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->13;
1[label=""Node Type: IF 1

EXPRESSION:
! SoftCapReached

IRs:
TMP_195 = UnaryType.BANG SoftCapReached 
CONDITION TMP_195""];
1->2[label=""True""];
1->11[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = Inverstors[msg.sender].EthAmount

IRs:
REF_131(LinCrowdSale.Investor) -> Inverstors[msg.sender]
REF_132(uint256) -> REF_131.EthAmount
amount(uint256) := REF_132(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Inverstors[msg.sender].EthAmount = 0

IRs:
REF_133(LinCrowdSale.Investor) -> Inverstors[msg.sender]
REF_134(uint256) -> REF_133.EthAmount
REF_134(uint256) (->Inverstors) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
amount > 0

IRs:
TMP_196(bool) = amount > 0
CONDITION TMP_196""];
4->5[label=""True""];
4->8[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
RefundAmount = RefundAmount.add(amount)

IRs:
TMP_198(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['RefundAmount', 'amount'] 
RefundAmount(uint256) := TMP_198(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
SucessWithdraw(msg.sender,amount,now)

IRs:
Emit SucessWithdraw(msg.sender,amount,now)""];
7->10;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
FailsafeWithdrawal(msg.sender,amount,now)

IRs:
Emit FailsafeWithdrawal(msg.sender,amount,now)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
revert()()

IRs:
TMP_201(None) = SOLIDITY_CALL revert()()""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->12;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
safeWithdrawalTry(msg.sender)

IRs:
Emit safeWithdrawalTry(msg.sender)""];
11->12;
12[label=""Node Type: END_IF 12
""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
afterDeadline()

IRs:
MODIFIER_CALL, LinCrowdSale.afterDeadline()()""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, LinCrowdSale.nonReentrant()()""];
14->1;
}
",0,0,1,0,"afterDeadline();! SoftCapReached;amount = Inverstors[msg.sender].EthAmount;safeWithdrawalTry(msg.sender);Inverstors[msg.sender].EthAmount = 0;amount > 0;msg.sender.transfer(amount);FailsafeWithdrawal(msg.sender,amount,now);RefundAmount = RefundAmount.add(amount);SucessWithdraw(msg.sender,amount,now);;revert()();;nonReentrant()"
./0x009ef15c147ff4c0eb373e1abd2f4d184e5cb916_ext.sol,CampaignContract.killContract,252,254,"TMP_97(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender),MODIFIER_CALL, CampaignContract.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(msg.sender)

IRs:
TMP_97(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, CampaignContract.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(msg.sender)
./0x2d04c7051112c47ee74a41c723f791b499aa6b1a_ext.sol,YHToken.withdrawForBet,685,697,"INTERNAL_CALL, YHToken.combineBonuses(address)(addr),REF_284(YHToken.User) -> users_[addr],REF_285(uint256) -> REF_284.extraEarnings,extraEarnings(uint256) := REF_285(uint256),TMP_264(bool) = extraEarnings >= value,CONDITION TMP_264,REF_286(YHToken.User) -> users_[addr],REF_287(uint256) -> REF_286.extraEarnings,REF_287(-> users_) = REF_287 - value,REF_288(YHToken.User) -> users_[addr],REF_289(uint256) -> REF_288.extraEarnings,REF_289(uint256) (->users_) := 0(uint256),TMP_265(uint256) = value - extraEarnings,remain(uint256) := TMP_265(uint256),REF_290(YHToken.User) -> users_[addr],REF_291(uint256) -> REF_290.bonusEarnings,TMP_266(bool) = REF_291 >= remain,TMP_267(None) = SOLIDITY_CALL require(bool)(TMP_266),REF_292(YHToken.User) -> users_[addr],REF_293(uint256) -> REF_292.bonusEarnings,REF_293(-> users_) = REF_293 - remain,HIGH_LEVEL_CALL, dest:Lottery(LotteryInterface), function:deposit, arguments:[] value:value ,MODIFIER_CALL, YHToken.isLottery()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->11;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
combineBonuses(addr)

IRs:
INTERNAL_CALL, YHToken.combineBonuses(address)(addr)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
extraEarnings = users_[addr].extraEarnings

IRs:
REF_284(YHToken.User) -> users_[addr]
REF_285(uint256) -> REF_284.extraEarnings
extraEarnings(uint256) := REF_285(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
extraEarnings >= value

IRs:
TMP_264(bool) = extraEarnings >= value
CONDITION TMP_264""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
users_[addr].extraEarnings -= value

IRs:
REF_286(YHToken.User) -> users_[addr]
REF_287(uint256) -> REF_286.extraEarnings
REF_287(-> users_) = REF_287 - value""];
4->9;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
users_[addr].extraEarnings = 0

IRs:
REF_288(YHToken.User) -> users_[addr]
REF_289(uint256) -> REF_288.extraEarnings
REF_289(uint256) (->users_) := 0(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
remain = value - extraEarnings

IRs:
TMP_265(uint256) = value - extraEarnings
remain(uint256) := TMP_265(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(users_[addr].bonusEarnings >= remain)

IRs:
REF_290(YHToken.User) -> users_[addr]
REF_291(uint256) -> REF_290.bonusEarnings
TMP_266(bool) = REF_291 >= remain
TMP_267(None) = SOLIDITY_CALL require(bool)(TMP_266)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
users_[addr].bonusEarnings -= remain

IRs:
REF_292(YHToken.User) -> users_[addr]
REF_293(uint256) -> REF_292.bonusEarnings
REF_293(-> users_) = REF_293 - remain""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
Lottery.deposit.value(value)()

IRs:
HIGH_LEVEL_CALL, dest:Lottery(LotteryInterface), function:deposit, arguments:[] value:value ""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
isLottery()

IRs:
MODIFIER_CALL, YHToken.isLottery()()""];
11->1;
}
",0,0,1,0,isLottery();combineBonuses(addr);extraEarnings = users_[addr].extraEarnings;extraEarnings >= value;users_[addr].extraEarnings -= value;users_[addr].extraEarnings = 0;;remain = value - extraEarnings;require(bool)(users_[addr].bonusEarnings >= remain);users_[addr].bonusEarnings -= remain;Lottery.deposit.value(value)()
./0xfef5497bc53a69875e02ae5b14eeff668f09a729_ext.sol,Infinity.limitAmount,288,305,"_amount(uint256) := msg.value(uint256),REF_70 -> LENGTH amountLimit,TMP_55(bool) = REF_70 > _sId,CONDITION TMP_55,REF_71(mapping(uint256 => Indatasets.Stage)) -> stage[_rId],REF_72(Indatasets.Stage) -> REF_71[_sId],REF_73(uint256) -> REF_72.targetAmount,REF_75(uint256) -> amountLimit[_sId],TMP_56(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_73', 'REF_75'] ,TMP_57(uint256) = TMP_56 / 1000,REF_77(mapping(uint256 => mapping(address => uint256))) -> playerStageAmount[_rId],REF_78(mapping(address => uint256)) -> REF_77[_sId],REF_79(uint256) -> REF_78[msg.sender],TMP_58(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_57', 'REF_79'] ,_amount(uint256) := TMP_58(uint256),REF_80(mapping(uint256 => Indatasets.Stage)) -> stage[_rId],REF_81(Indatasets.Stage) -> REF_80[_sId],REF_82(uint256) -> REF_81.targetAmount,TMP_59(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_82', '500'] ,TMP_60(uint256) = TMP_59 / 1000,REF_85(mapping(uint256 => mapping(address => uint256))) -> playerStageAmount[_rId],REF_86(mapping(address => uint256)) -> REF_85[_sId],REF_87(uint256) -> REF_86[msg.sender],TMP_61(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_60', 'REF_87'] ,_amount(uint256) := TMP_61(uint256),TMP_62(bool) = _amount >= msg.value,CONDITION TMP_62,RETURN msg.value,TMP_63(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.value', '_amount'] ,Transfer dest:msg.sender value:TMP_63,RETURN _amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_amount = msg.value

IRs:
_amount(uint256) := msg.value(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
amountLimit.length > _sId

IRs:
REF_70 -> LENGTH amountLimit
TMP_55(bool) = REF_70 > _sId
CONDITION TMP_55""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_amount = ((stage[_rId][_sId].targetAmount.mul(amountLimit[_sId])) / 1000).sub(playerStageAmount[_rId][_sId][msg.sender])

IRs:
REF_71(mapping(uint256 => Indatasets.Stage)) -> stage[_rId]
REF_72(Indatasets.Stage) -> REF_71[_sId]
REF_73(uint256) -> REF_72.targetAmount
REF_75(uint256) -> amountLimit[_sId]
TMP_56(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_73', 'REF_75'] 
TMP_57(uint256) = TMP_56 / 1000
REF_77(mapping(uint256 => mapping(address => uint256))) -> playerStageAmount[_rId]
REF_78(mapping(address => uint256)) -> REF_77[_sId]
REF_79(uint256) -> REF_78[msg.sender]
TMP_58(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_57', 'REF_79'] 
_amount(uint256) := TMP_58(uint256)""];
3->5;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
_amount = ((stage[_rId][_sId].targetAmount.mul(500)) / 1000).sub(playerStageAmount[_rId][_sId][msg.sender])

IRs:
REF_80(mapping(uint256 => Indatasets.Stage)) -> stage[_rId]
REF_81(Indatasets.Stage) -> REF_80[_sId]
REF_82(uint256) -> REF_81.targetAmount
TMP_59(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['REF_82', '500'] 
TMP_60(uint256) = TMP_59 / 1000
REF_85(mapping(uint256 => mapping(address => uint256))) -> playerStageAmount[_rId]
REF_86(mapping(address => uint256)) -> REF_85[_sId]
REF_87(uint256) -> REF_86[msg.sender]
TMP_61(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['TMP_60', 'REF_87'] 
_amount(uint256) := TMP_61(uint256)""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
_amount >= msg.value

IRs:
TMP_62(bool) = _amount >= msg.value
CONDITION TMP_62""];
6->7[label=""True""];
6->8[label=""False""];
7[label=""Node Type: RETURN 7

EXPRESSION:
msg.value

IRs:
RETURN msg.value""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
msg.sender.transfer(msg.value.sub(_amount))

IRs:
TMP_63(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.value', '_amount'] 
Transfer dest:msg.sender value:TMP_63""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: RETURN 10

EXPRESSION:
_amount

IRs:
RETURN _amount""];
}
",0,0,1,0,_amount = msg.value;amountLimit.length > _sId;_amount = ((stage[_rId][_sId].targetAmount.mul(amountLimit[_sId])) / 1000).sub(playerStageAmount[_rId][_sId][msg.sender]);_amount = ((stage[_rId][_sId].targetAmount.mul(500)) / 1000).sub(playerStageAmount[_rId][_sId][msg.sender]);;_amount >= msg.value;msg.value;msg.sender.transfer(msg.value.sub(_amount));;_amount
./0xd7f4aea7c2b8d633d88c449eab91d7d5ef89427e_ext.sol,EDAX.getTokens,178,237,"tokens(uint256) := 0(uint256),bonus(uint256) := 0(uint256),countbonus(uint256) := 0(uint256),TMP_45(uint256) = 1000000000000000000 / 5,bonusCond1(uint256) := TMP_45(uint256),bonusCond2(uint256) := 1000000000000000000(uint256),bonusCond3(uint256) := 3000000000000000000(uint256),TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_47(uint256) = TMP_46 / 1000000000000000000,tokens(uint256) := TMP_47(uint256),investor(address) := msg.sender(address),TMP_48(bool) = msg.value >= requestMinimum,TMP_49(bool) = now < deadline,TMP_50(bool) = TMP_48 && TMP_49,TMP_51(bool) = now < round1,TMP_52(bool) = TMP_50 && TMP_51,TMP_53(bool) = now < round2,TMP_54(bool) = TMP_52 && TMP_53,CONDITION TMP_54,TMP_55(bool) = msg.value >= bonusCond1,TMP_56(bool) = msg.value < bonusCond2,TMP_57(bool) = TMP_55 && TMP_56,CONDITION TMP_57,TMP_58(uint256) = tokens * 10,TMP_59(uint256) = TMP_58 / 100,countbonus(uint256) := TMP_59(uint256),TMP_60(bool) = msg.value >= bonusCond2,TMP_61(bool) = msg.value < bonusCond3,TMP_62(bool) = TMP_60 && TMP_61,CONDITION TMP_62,TMP_63(uint256) = tokens * 50,TMP_64(uint256) = TMP_63 / 100,countbonus(uint256) := TMP_64(uint256),TMP_65(bool) = msg.value >= bonusCond3,CONDITION TMP_65,TMP_66(uint256) = tokens * 75,TMP_67(uint256) = TMP_66 / 100,countbonus(uint256) := TMP_67(uint256),TMP_68(bool) = msg.value >= requestMinimum,TMP_69(bool) = now < deadline,TMP_70(bool) = TMP_68 && TMP_69,TMP_71(bool) = now > round1,TMP_72(bool) = TMP_70 && TMP_71,TMP_73(bool) = now < round2,TMP_74(bool) = TMP_72 && TMP_73,CONDITION TMP_74,TMP_75(bool) = msg.value >= bonusCond2,TMP_76(bool) = msg.value < bonusCond3,TMP_77(bool) = TMP_75 && TMP_76,CONDITION TMP_77,TMP_78(uint256) = tokens * 25,TMP_79(uint256) = TMP_78 / 100,countbonus(uint256) := TMP_79(uint256),TMP_80(bool) = msg.value >= bonusCond3,CONDITION TMP_80,TMP_81(uint256) = tokens * 50,TMP_82(uint256) = TMP_81 / 100,countbonus(uint256) := TMP_82(uint256),countbonus(uint256) := 0(uint256),TMP_83(uint256) = tokens + countbonus,bonus(uint256) := TMP_83(uint256),TMP_84(bool) = tokens == 0,CONDITION TMP_84,valdrop(uint256) := 10000000000(uint256),REF_12(bool) -> Claimed[investor],TMP_85(bool) = REF_12 == False,TMP_86(bool) = progress0drop <= target0drop,TMP_87(bool) = TMP_85 && TMP_86,CONDITION TMP_87,TMP_88(bool) = INTERNAL_CALL, EDAX.distr(address,uint256)(investor,valdrop),REF_13(bool) -> Claimed[investor],REF_13(bool) (->Claimed) := True(bool),TMP_89(uint256) := progress0drop(uint256),progress0drop(uint256) = progress0drop + 1,TMP_90(bool) = msg.value >= requestMinimum,TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),TMP_92(bool) = tokens > 0,TMP_93(bool) = msg.value >= requestMinimum,TMP_94(bool) = TMP_92 && TMP_93,CONDITION TMP_94,TMP_95(bool) = now >= deadline,TMP_96(bool) = now >= round1,TMP_97(bool) = TMP_95 && TMP_96,TMP_98(bool) = now < round2,TMP_99(bool) = TMP_97 && TMP_98,CONDITION TMP_99,TMP_100(bool) = INTERNAL_CALL, EDAX.distr(address,uint256)(investor,tokens),TMP_101(bool) = msg.value >= bonusCond1,CONDITION TMP_101,TMP_102(bool) = INTERNAL_CALL, EDAX.distr(address,uint256)(investor,bonus),TMP_103(bool) = INTERNAL_CALL, EDAX.distr(address,uint256)(investor,tokens),TMP_104(bool) = msg.value >= requestMinimum,TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104),TMP_106(bool) = totalDistributed >= totalSupply,CONDITION TMP_106,distributionFinished(bool) := True(bool),Transfer dest:multisig value:msg.value,MODIFIER_CALL, EDAX.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->53;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bonusCond1 = 1000000000000000000 / 5

IRs:
TMP_45(uint256) = 1000000000000000000 / 5
bonusCond1(uint256) := TMP_45(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bonusCond2 = 1000000000000000000

IRs:
bonusCond2(uint256) := 1000000000000000000(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
bonusCond3 = 3000000000000000000

IRs:
bonusCond3(uint256) := 3000000000000000000(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_47(uint256) = TMP_46 / 1000000000000000000
tokens(uint256) := TMP_47(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now < round1 && now < round2

IRs:
TMP_48(bool) = msg.value >= requestMinimum
TMP_49(bool) = now < deadline
TMP_50(bool) = TMP_48 && TMP_49
TMP_51(bool) = now < round1
TMP_52(bool) = TMP_50 && TMP_51
TMP_53(bool) = now < round2
TMP_54(bool) = TMP_52 && TMP_53
CONDITION TMP_54""];
9->10[label=""True""];
9->19[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
msg.value >= bonusCond1 && msg.value < bonusCond2

IRs:
TMP_55(bool) = msg.value >= bonusCond1
TMP_56(bool) = msg.value < bonusCond2
TMP_57(bool) = TMP_55 && TMP_56
CONDITION TMP_57""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
countbonus = tokens * 10 / 100

IRs:
TMP_58(uint256) = tokens * 10
TMP_59(uint256) = TMP_58 / 100
countbonus(uint256) := TMP_59(uint256)""];
11->18;
12[label=""Node Type: IF 12

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_60(bool) = msg.value >= bonusCond2
TMP_61(bool) = msg.value < bonusCond3
TMP_62(bool) = TMP_60 && TMP_61
CONDITION TMP_62""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
countbonus = tokens * 50 / 100

IRs:
TMP_63(uint256) = tokens * 50
TMP_64(uint256) = TMP_63 / 100
countbonus(uint256) := TMP_64(uint256)""];
13->17;
14[label=""Node Type: IF 14

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_65(bool) = msg.value >= bonusCond3
CONDITION TMP_65""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
countbonus = tokens * 75 / 100

IRs:
TMP_66(uint256) = tokens * 75
TMP_67(uint256) = TMP_66 / 100
countbonus(uint256) := TMP_67(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->28;
19[label=""Node Type: IF 19

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now > round1 && now < round2

IRs:
TMP_68(bool) = msg.value >= requestMinimum
TMP_69(bool) = now < deadline
TMP_70(bool) = TMP_68 && TMP_69
TMP_71(bool) = now > round1
TMP_72(bool) = TMP_70 && TMP_71
TMP_73(bool) = now < round2
TMP_74(bool) = TMP_72 && TMP_73
CONDITION TMP_74""];
19->20[label=""True""];
19->26[label=""False""];
20[label=""Node Type: IF 20

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_75(bool) = msg.value >= bonusCond2
TMP_76(bool) = msg.value < bonusCond3
TMP_77(bool) = TMP_75 && TMP_76
CONDITION TMP_77""];
20->21[label=""True""];
20->22[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
countbonus = tokens * 25 / 100

IRs:
TMP_78(uint256) = tokens * 25
TMP_79(uint256) = TMP_78 / 100
countbonus(uint256) := TMP_79(uint256)""];
21->25;
22[label=""Node Type: IF 22

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_80(bool) = msg.value >= bonusCond3
CONDITION TMP_80""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
countbonus = tokens * 50 / 100

IRs:
TMP_81(uint256) = tokens * 50
TMP_82(uint256) = TMP_81 / 100
countbonus(uint256) := TMP_82(uint256)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->27;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
bonus = tokens + countbonus

IRs:
TMP_83(uint256) = tokens + countbonus
bonus(uint256) := TMP_83(uint256)""];
29->30;
30[label=""Node Type: IF 30

EXPRESSION:
tokens == 0

IRs:
TMP_84(bool) = tokens == 0
CONDITION TMP_84""];
30->31[label=""True""];
30->38[label=""False""];
31[label=""Node Type: NEW VARIABLE 31

EXPRESSION:
valdrop = 100e8

IRs:
valdrop(uint256) := 10000000000(uint256)""];
31->32;
32[label=""Node Type: IF 32

EXPRESSION:
Claimed[investor] == false && progress0drop <= target0drop

IRs:
REF_12(bool) -> Claimed[investor]
TMP_85(bool) = REF_12 == False
TMP_86(bool) = progress0drop <= target0drop
TMP_87(bool) = TMP_85 && TMP_86
CONDITION TMP_87""];
32->33[label=""True""];
32->36[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
distr(investor,valdrop)

IRs:
TMP_88(bool) = INTERNAL_CALL, EDAX.distr(address,uint256)(investor,valdrop)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
Claimed[investor] = true

IRs:
REF_13(bool) -> Claimed[investor]
REF_13(bool) (->Claimed) := True(bool)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
progress0drop ++

IRs:
TMP_89(uint256) := progress0drop(uint256)
progress0drop(uint256) = progress0drop + 1""];
35->37;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_90(bool) = msg.value >= requestMinimum
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
36->37;
37[label=""Node Type: END_IF 37
""];
37->48;
38[label=""Node Type: IF 38

EXPRESSION:
tokens > 0 && msg.value >= requestMinimum

IRs:
TMP_92(bool) = tokens > 0
TMP_93(bool) = msg.value >= requestMinimum
TMP_94(bool) = TMP_92 && TMP_93
CONDITION TMP_94""];
38->39[label=""True""];
38->46[label=""False""];
39[label=""Node Type: IF 39

EXPRESSION:
now >= deadline && now >= round1 && now < round2

IRs:
TMP_95(bool) = now >= deadline
TMP_96(bool) = now >= round1
TMP_97(bool) = TMP_95 && TMP_96
TMP_98(bool) = now < round2
TMP_99(bool) = TMP_97 && TMP_98
CONDITION TMP_99""];
39->40[label=""True""];
39->41[label=""False""];
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_100(bool) = INTERNAL_CALL, EDAX.distr(address,uint256)(investor,tokens)""];
40->45;
41[label=""Node Type: IF 41

EXPRESSION:
msg.value >= bonusCond1

IRs:
TMP_101(bool) = msg.value >= bonusCond1
CONDITION TMP_101""];
41->42[label=""True""];
41->43[label=""False""];
42[label=""Node Type: EXPRESSION 42

EXPRESSION:
distr(investor,bonus)

IRs:
TMP_102(bool) = INTERNAL_CALL, EDAX.distr(address,uint256)(investor,bonus)""];
42->44;
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_103(bool) = INTERNAL_CALL, EDAX.distr(address,uint256)(investor,tokens)""];
43->44;
44[label=""Node Type: END_IF 44
""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->47;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_104(bool) = msg.value >= requestMinimum
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: IF 49

EXPRESSION:
totalDistributed >= totalSupply

IRs:
TMP_106(bool) = totalDistributed >= totalSupply
CONDITION TMP_106""];
49->50[label=""True""];
49->51[label=""False""];
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
multisig.transfer(msg.value)

IRs:
Transfer dest:multisig value:msg.value""];
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, EDAX.canDistr()()""];
53->1;
}
",0,0,1,0,"canDistr();tokens = 0;bonus = 0;countbonus = 0;bonusCond1 = 1000000000000000000 / 5;bonusCond2 = 1000000000000000000;bonusCond3 = 3000000000000000000;tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;investor = msg.sender;msg.value >= requestMinimum && now < deadline && now < round1 && now < round2;msg.value >= bonusCond1 && msg.value < bonusCond2;msg.value >= requestMinimum && now < deadline && now > round1 && now < round2;countbonus = tokens * 10 / 100;msg.value >= bonusCond2 && msg.value < bonusCond3;;countbonus = tokens * 50 / 100;msg.value >= bonusCond3;;countbonus = tokens * 75 / 100;;;msg.value >= bonusCond2 && msg.value < bonusCond3;countbonus = 0;countbonus = tokens * 25 / 100;msg.value >= bonusCond3;;countbonus = tokens * 50 / 100;;;bonus = tokens + countbonus;tokens == 0;valdrop = 100e8;tokens > 0 && msg.value >= requestMinimum;Claimed[investor] == false && progress0drop <= target0drop;distr(investor,valdrop);require(bool)(msg.value >= requestMinimum);Claimed[investor] = true;progress0drop ++;;;now >= deadline && now >= round1 && now < round2;require(bool)(msg.value >= requestMinimum);distr(investor,tokens);msg.value >= bonusCond1;;distr(investor,bonus);distr(investor,tokens);;;totalDistributed >= totalSupply;distributionFinished = true;;multisig.transfer(msg.value)"
./0xef078a64e1593afee09912d18097bc49fa74c7a9_ext.sol,ETHER_Game.Stop,28,30,"REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3,MODIFIER_CALL, ETHER_Game.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, ETHER_Game.isAdmin()()""];
2->1;
}
",0,0,1,0,isAdmin();msg.sender.transfer(this.balance)
./0x41104edb2cefbb66cc28b17d507f0b4ba559f455_ext.sol,CrowdsaleToken.endIco,320,327,"REF_115(CrowdsaleToken.Stages) -> Stages.icoEnd,currentStage(CrowdsaleToken.Stages) := REF_115(CrowdsaleToken.Stages),TMP_120(bool) = remainingTokens > 0,CONDITION TMP_120,REF_116(uint256) -> balances[owner],REF_117(uint256) -> balances[owner],TMP_121(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_117', 'remainingTokens'] ,REF_116(uint256) (->balances) := TMP_121(uint256),TMP_122 = CONVERT this to address,TMP_123(uint256) = SOLIDITY_CALL balance(address)(TMP_122),Transfer dest:owner value:TMP_123","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
currentStage = Stages.icoEnd

IRs:
REF_115(CrowdsaleToken.Stages) -> Stages.icoEnd
currentStage(CrowdsaleToken.Stages) := REF_115(CrowdsaleToken.Stages)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
remainingTokens > 0

IRs:
TMP_120(bool) = remainingTokens > 0
CONDITION TMP_120""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[owner] = balances[owner].add(remainingTokens)

IRs:
REF_116(uint256) -> balances[owner]
REF_117(uint256) -> balances[owner]
TMP_121(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_117', 'remainingTokens'] 
REF_116(uint256) (->balances) := TMP_121(uint256)""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_122 = CONVERT this to address
TMP_123(uint256) = SOLIDITY_CALL balance(address)(TMP_122)
Transfer dest:owner value:TMP_123""];
}
",0,0,1,0,currentStage = Stages.icoEnd;remainingTokens > 0;balances[owner] = balances[owner].add(remainingTokens);;owner.transfer(address(this).balance)
./0x297ac8bc7540bc241f065fcc22c570b40170b573_ext.sol,TraceTokenSale.withdraw,559,564,"TMP_256(bool) = INTERNAL_CALL, TraceTokenSale.softCapReached()(),TMP_257(None) = SOLIDITY_CALL require(bool)(TMP_256),REF_175(uint256) = SOLIDITY_CALL balance(address)(this),TMP_258(bool) = REF_175 > 0,TMP_259(None) = SOLIDITY_CALL require(bool)(TMP_258),REF_177(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:wallet value:REF_177,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(softCapReached())

IRs:
TMP_256(bool) = INTERNAL_CALL, TraceTokenSale.softCapReached()()
TMP_257(None) = SOLIDITY_CALL require(bool)(TMP_256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(this.balance > 0)

IRs:
REF_175(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_258(bool) = REF_175 > 0
TMP_259(None) = SOLIDITY_CALL require(bool)(TMP_258)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
wallet.transfer(this.balance)

IRs:
REF_177(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:wallet value:REF_177""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();require(bool)(softCapReached());require(bool)(this.balance > 0);wallet.transfer(this.balance)
./0xb42ce9d2a22061b7d5e569753f92edbaa2dad37b_ext.sol,Exchanger.sell,245,258,"TMP_67(uint256) = HIGH_LEVEL_CALL, dest:tokenContract(ITradeableAsset), function:totalSupply, arguments:[]  ,TMP_68 = CONVERT this to address,TMP_69(uint256) = SOLIDITY_CALL balance(address)(TMP_68),TMP_70(uint256) = HIGH_LEVEL_CALL, dest:formulaContract(IYeekFormula), function:calculateSaleReturn, arguments:['TMP_67', 'TMP_69', 'weight', 'quantity']  ,amountInWei(uint256) := TMP_70(uint256),TMP_71(None) = SOLIDITY_CALL require(bool)(enabled),TMP_72(bool) = amountInWei >= minSaleReturn,TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72),TMP_74 = CONVERT this to address,TMP_75(uint256) = SOLIDITY_CALL balance(address)(TMP_74),TMP_76(bool) = amountInWei <= TMP_75,TMP_77(None) = SOLIDITY_CALL require(bool)(TMP_76),TMP_78(bool) = HIGH_LEVEL_CALL, dest:tokenContract(ITradeableAsset), function:transferFrom, arguments:['msg.sender', 'this', 'quantity']  ,TMP_79(None) = SOLIDITY_CALL require(bool)(TMP_78),Emit Sell(msg.sender,quantity,amountInWei),Transfer dest:msg.sender value:amountInWei","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
amountInWei = formulaContract.calculateSaleReturn(tokenContract.totalSupply(),address(this).balance,weight,quantity)

IRs:
TMP_67(uint256) = HIGH_LEVEL_CALL, dest:tokenContract(ITradeableAsset), function:totalSupply, arguments:[]  
TMP_68 = CONVERT this to address
TMP_69(uint256) = SOLIDITY_CALL balance(address)(TMP_68)
TMP_70(uint256) = HIGH_LEVEL_CALL, dest:formulaContract(IYeekFormula), function:calculateSaleReturn, arguments:['TMP_67', 'TMP_69', 'weight', 'quantity']  
amountInWei(uint256) := TMP_70(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(enabled)

IRs:
TMP_71(None) = SOLIDITY_CALL require(bool)(enabled)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(amountInWei >= minSaleReturn)

IRs:
TMP_72(bool) = amountInWei >= minSaleReturn
TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(amountInWei <= address(this).balance)

IRs:
TMP_74 = CONVERT this to address
TMP_75(uint256) = SOLIDITY_CALL balance(address)(TMP_74)
TMP_76(bool) = amountInWei <= TMP_75
TMP_77(None) = SOLIDITY_CALL require(bool)(TMP_76)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(tokenContract.transferFrom(msg.sender,this,quantity))

IRs:
TMP_78(bool) = HIGH_LEVEL_CALL, dest:tokenContract(ITradeableAsset), function:transferFrom, arguments:['msg.sender', 'this', 'quantity']  
TMP_79(None) = SOLIDITY_CALL require(bool)(TMP_78)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Sell(msg.sender,quantity,amountInWei)

IRs:
Emit Sell(msg.sender,quantity,amountInWei)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
msg.sender.transfer(amountInWei)

IRs:
Transfer dest:msg.sender value:amountInWei""];
}
",0,0,1,0,"amountInWei = formulaContract.calculateSaleReturn(tokenContract.totalSupply(),address(this).balance,weight,quantity);require(bool)(enabled);require(bool)(amountInWei >= minSaleReturn);require(bool)(amountInWei <= address(this).balance);require(bool)(tokenContract.transferFrom(msg.sender,this,quantity));Sell(msg.sender,quantity,amountInWei);msg.sender.transfer(amountInWei)"
./0x5211475520dc4a13fee1cc7c2c0c1167998bcbb8_ext.sol,AuctionContract.closeAuction,139,163,"TMP_45(None) = SOLIDITY_CALL assert(bool)(isActive),TMP_46(bool) = auctionCloseBlock < block.number,TMP_47(None) = SOLIDITY_CALL assert(bool)(TMP_46),TMP_48(bool) = msg.sender == winner,TMP_49(None) = SOLIDITY_CALL assert(bool)(TMP_48),Transfer dest:msg.sender value:prize,TMP_51 = CONVERT auctioneerAddress to Auctioneer,auctioneer(Auctioneer) := TMP_51(Auctioneer),TMP_52 = CONVERT 0 to address,TMP_53(bool) = firstBidder != TMP_52,CONDITION TMP_53,REF_11(uint256) -> bettingMap[firstBidder],firstValue(uint256) := REF_11(uint256),TMP_54(bool) = firstValue >= minimalPrize,CONDITION TMP_54,TMP_56(address) = HIGH_LEVEL_CALL, dest:auctioneer(Auctioneer), function:createAuctionContract, arguments:[] value:firstValue ,firstContract(address) := TMP_56(address),firstBetContract(address) := firstContract(address),TMP_57 = CONVERT 0 to address,TMP_58(bool) = secondBidder != TMP_57,CONDITION TMP_58,REF_14(uint256) -> bettingMap[secondBidder],secondValue(uint256) := REF_14(uint256),TMP_59(bool) = secondValue >= minimalPrize,CONDITION TMP_59,TMP_61(address) = HIGH_LEVEL_CALL, dest:auctioneer(Auctioneer), function:createAuctionContract, arguments:[] value:secondValue ,secondContract(address) := TMP_61(address),secondBetContract(address) := secondContract(address),isActive(bool) := False(bool)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
assert(bool)(isActive)

IRs:
TMP_45(None) = SOLIDITY_CALL assert(bool)(isActive)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
assert(bool)(auctionCloseBlock < block.number)

IRs:
TMP_46(bool) = auctionCloseBlock < block.number
TMP_47(None) = SOLIDITY_CALL assert(bool)(TMP_46)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
assert(bool)(msg.sender == winner)

IRs:
TMP_48(bool) = msg.sender == winner
TMP_49(None) = SOLIDITY_CALL assert(bool)(TMP_48)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(prize)

IRs:
Transfer dest:msg.sender value:prize""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
auctioneer = Auctioneer(auctioneerAddress)

IRs:
TMP_51 = CONVERT auctioneerAddress to Auctioneer
auctioneer(Auctioneer) := TMP_51(Auctioneer)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
firstBidder != address(0)

IRs:
TMP_52 = CONVERT 0 to address
TMP_53(bool) = firstBidder != TMP_52
CONDITION TMP_53""];
6->7[label=""True""];
6->12[label=""False""];
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
firstValue = bettingMap[firstBidder]

IRs:
REF_11(uint256) -> bettingMap[firstBidder]
firstValue(uint256) := REF_11(uint256)""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
firstValue >= minimalPrize

IRs:
TMP_54(bool) = firstValue >= minimalPrize
CONDITION TMP_54""];
8->9[label=""True""];
8->11[label=""False""];
9[label=""Node Type: NEW VARIABLE 9

EXPRESSION:
firstContract = auctioneer.createAuctionContract.value(firstValue)()

IRs:
TMP_56(address) = HIGH_LEVEL_CALL, dest:auctioneer(Auctioneer), function:createAuctionContract, arguments:[] value:firstValue 
firstContract(address) := TMP_56(address)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
firstBetContract = firstContract

IRs:
firstBetContract(address) := firstContract(address)""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->13;
13[label=""Node Type: IF 13

EXPRESSION:
secondBidder != address(0)

IRs:
TMP_57 = CONVERT 0 to address
TMP_58(bool) = secondBidder != TMP_57
CONDITION TMP_58""];
13->14[label=""True""];
13->19[label=""False""];
14[label=""Node Type: NEW VARIABLE 14

EXPRESSION:
secondValue = bettingMap[secondBidder]

IRs:
REF_14(uint256) -> bettingMap[secondBidder]
secondValue(uint256) := REF_14(uint256)""];
14->15;
15[label=""Node Type: IF 15

EXPRESSION:
secondValue >= minimalPrize

IRs:
TMP_59(bool) = secondValue >= minimalPrize
CONDITION TMP_59""];
15->16[label=""True""];
15->18[label=""False""];
16[label=""Node Type: NEW VARIABLE 16

EXPRESSION:
secondContract = auctioneer.createAuctionContract.value(secondValue)()

IRs:
TMP_61(address) = HIGH_LEVEL_CALL, dest:auctioneer(Auctioneer), function:createAuctionContract, arguments:[] value:secondValue 
secondContract(address) := TMP_61(address)""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
secondBetContract = secondContract

IRs:
secondBetContract(address) := secondContract(address)""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->19;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
isActive = false

IRs:
isActive(bool) := False(bool)""];
}
",1,0,1,0,assert(bool)(isActive);assert(bool)(auctionCloseBlock < block.number);assert(bool)(msg.sender == winner);msg.sender.transfer(prize);auctioneer = Auctioneer(auctioneerAddress);firstBidder != address(0);firstValue = bettingMap[firstBidder];;firstValue >= minimalPrize;firstContract = auctioneer.createAuctionContract.value(firstValue)();;firstBetContract = firstContract;secondBidder != address(0);secondValue = bettingMap[secondBidder];;secondValue >= minimalPrize;secondContract = auctioneer.createAuctionContract.value(secondValue)();;secondBetContract = secondContract;isActive = false
./0x4c7c98c4d64c29ef8103b005eeccf5145cfdf8c1_ext.sol,Savings.withdraw,37,44,"TMP_6(bool) = INTERNAL_CALL, Ownable.isOwner()(),TMP_7(bool) = now >= openDate,TMP_8(bool) = TMP_6 && TMP_7,CONDITION TMP_8,REF_1(uint256) -> deposits[msg.sender],max(uint256) := REF_1(uint256),TMP_9(bool) = amount <= max,TMP_10(bool) = max > 0,TMP_11(bool) = TMP_9 && TMP_10,CONDITION TMP_11,Transfer dest:msg.sender value:amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
isOwner() && now >= openDate

IRs:
TMP_6(bool) = INTERNAL_CALL, Ownable.isOwner()()
TMP_7(bool) = now >= openDate
TMP_8(bool) = TMP_6 && TMP_7
CONDITION TMP_8""];
1->2[label=""True""];
1->6[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
max = deposits[msg.sender]

IRs:
REF_1(uint256) -> deposits[msg.sender]
max(uint256) := REF_1(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
amount <= max && max > 0

IRs:
TMP_9(bool) = amount <= max
TMP_10(bool) = max > 0
TMP_11(bool) = TMP_9 && TMP_10
CONDITION TMP_11""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
4->5;
5[label=""Node Type: END_IF 5
""];
5->6;
6[label=""Node Type: END_IF 6
""];
}
",0,0,1,0,isOwner() && now >= openDate;max = deposits[msg.sender];;amount <= max && max > 0;msg.sender.transfer(amount);
./0x468b9ec0747e3da866a06a10cff67d4f49ad9765_ext.sol,ProofOfLongHodlV2.closeGame,219,222,"REF_99(uint256) = SOLIDITY_CALL balance(address)(this),etherBalance(uint256) := REF_99([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B957F670>]),Transfer dest:owner value:etherBalance,MODIFIER_CALL, ProofOfLongHodlV2.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
etherBalance = this.balance

IRs:
REF_99(uint256) = SOLIDITY_CALL balance(address)(this)
etherBalance(uint256) := REF_99([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B957F670>])""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(etherBalance)

IRs:
Transfer dest:owner value:etherBalance""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, ProofOfLongHodlV2.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();etherBalance = this.balance;owner.transfer(etherBalance)
./0x7982a79ee90eb3682dcee66e47ba79c1cba44062_ext.sol,FlowerCore.withdrawBalance,971,979,"TMP_1853 = CONVERT this to address,TMP_1854(uint256) = SOLIDITY_CALL balance(address)(TMP_1853),balance(uint256) := TMP_1854(uint256),TMP_1855(bool) = balance > 0,CONDITION TMP_1855,Transfer dest:rootAddress value:balance,MODIFIER_CALL, FlowerAdminAccess.onlyAdministrator()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
balance = address(this).balance

IRs:
TMP_1853 = CONVERT this to address
TMP_1854(uint256) = SOLIDITY_CALL balance(address)(TMP_1853)
balance(uint256) := TMP_1854(uint256)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
balance > 0

IRs:
TMP_1855(bool) = balance > 0
CONDITION TMP_1855""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
rootAddress.transfer(balance)

IRs:
Transfer dest:rootAddress value:balance""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyAdministrator()

IRs:
MODIFIER_CALL, FlowerAdminAccess.onlyAdministrator()()""];
5->1;
}
",0,0,1,0,onlyAdministrator();balance = address(this).balance;balance > 0;rootAddress.transfer(balance);
./0x574fb6d9d090042a04d0d12a4e87217f8303a5ca_ext.sol,HelloGoldSale.withdraw,890,898,"TMP_548(bool) = INTERNAL_CALL, HelloGoldSale.failed()(),CONDITION TMP_548,REF_187(uint256) -> deposits[msg.sender],TMP_549(bool) = REF_187 > 0,CONDITION TMP_549,REF_188(uint256) -> deposits[msg.sender],val(uint256) := REF_188(uint256),REF_189(uint256) -> deposits[msg.sender],REF_189(uint256) (->deposits) := 0(uint256),Transfer dest:msg.sender value:val","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
failed()

IRs:
TMP_548(bool) = INTERNAL_CALL, HelloGoldSale.failed()()
CONDITION TMP_548""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: IF 2

EXPRESSION:
deposits[msg.sender] > 0

IRs:
REF_187(uint256) -> deposits[msg.sender]
TMP_549(bool) = REF_187 > 0
CONDITION TMP_549""];
2->3[label=""True""];
2->6[label=""False""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
val = deposits[msg.sender]

IRs:
REF_188(uint256) -> deposits[msg.sender]
val(uint256) := REF_188(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
deposits[msg.sender] = 0

IRs:
REF_189(uint256) -> deposits[msg.sender]
REF_189(uint256) (->deposits) := 0(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(val)

IRs:
Transfer dest:msg.sender value:val""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: END_IF 7
""];
}
",0,0,1,0,failed();deposits[msg.sender] > 0;;val = deposits[msg.sender];;deposits[msg.sender] = 0;msg.sender.transfer(val)
./0x4ee1d7720a04072142b2efc9d2c7d5d77ad63939_ext.sol,ARXpresale.beneficiaryMultiSigWithdraw,203,206,"TMP_133(bool) = amountRaisedInWei >= fundingMinCapInWei,TMP_134(None) = SOLIDITY_CALL require(bool)(TMP_133),Transfer dest:beneficiaryWallet value:_amount,MODIFIER_CALL, owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(amountRaisedInWei >= fundingMinCapInWei)

IRs:
TMP_133(bool) = amountRaisedInWei >= fundingMinCapInWei
TMP_134(None) = SOLIDITY_CALL require(bool)(TMP_133)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
beneficiaryWallet.transfer(_amount)

IRs:
Transfer dest:beneficiaryWallet value:_amount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, owned.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();require(bool)(amountRaisedInWei >= fundingMinCapInWei);beneficiaryWallet.transfer(_amount)
./0xa2038ce672658f492fcd9e4fdaa1a3c530011a8a_ext.sol,MultiHolderVault.close,236,241,"REF_50(RefundVault.State) -> State.Active,TMP_107(bool) = state == REF_50,TMP_108(None) = SOLIDITY_CALL require(bool)(TMP_107),REF_51(RefundVault.State) -> State.Closed,state(RefundVault.State) := REF_51(RefundVault.State),Emit Closed(),TMP_110 = CONVERT this to address,TMP_111(uint256) = SOLIDITY_CALL balance(address)(TMP_110),Transfer dest:wallet value:TMP_111,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_50(RefundVault.State) -> State.Active
TMP_107(bool) = state == REF_50
TMP_108(None) = SOLIDITY_CALL require(bool)(TMP_107)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
state = State.Closed

IRs:
REF_51(RefundVault.State) -> State.Closed
state(RefundVault.State) := REF_51(RefundVault.State)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Closed()

IRs:
Emit Closed()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
wallet.transfer(address(this).balance)

IRs:
TMP_110 = CONVERT this to address
TMP_111(uint256) = SOLIDITY_CALL balance(address)(TMP_110)
Transfer dest:wallet value:TMP_111""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();require(bool)(state == State.Active);state = State.Closed;Closed();wallet.transfer(address(this).balance)
./0x720608228bda773fe22e816ee72463040f11c19e_ext.sol,Presale.withdraw,579,584,"TMP_313(None) = SOLIDITY_CALL require(bool)(softcapAchieved),TMP_314(bool) = owner == msg.sender,TMP_315(None) = SOLIDITY_CALL require(bool)(TMP_314),INTERNAL_CALL, Presale.withdrawDev()(),REF_173(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:wallet value:REF_173","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(softcapAchieved)

IRs:
TMP_313(None) = SOLIDITY_CALL require(bool)(softcapAchieved)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(owner == msg.sender)

IRs:
TMP_314(bool) = owner == msg.sender
TMP_315(None) = SOLIDITY_CALL require(bool)(TMP_314)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
withdrawDev()

IRs:
INTERNAL_CALL, Presale.withdrawDev()()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
wallet.transfer(this.balance)

IRs:
REF_173(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:wallet value:REF_173""];
}
",0,0,1,0,require(bool)(softcapAchieved);require(bool)(owner == msg.sender);withdrawDev();wallet.transfer(this.balance)
./0x93143d3e34a50aebab466368c3455fd858f77ad3_ext.sol,FourOutOfFive.claimReward,116,148,"REF_25(FourOutOfFive.GroupData) -> Groups[_groupId],REF_26(bool) -> REF_25.completed,TMP_36(bool) = REF_26 == True,TMP_37(None) = SOLIDITY_CALL require(bool,string)(TMP_36,Groups is not completed),REF_27(FourOutOfFive.GroupData) -> Groups[_groupId],REF_28(uint8) -> REF_27.rewardsAvailable,TMP_38(bool) = REF_28 > 0,TMP_39(None) = SOLIDITY_CALL require(bool,string)(TMP_38,No reward found.),i(uint8) := 0(uint256),REF_29(FourOutOfFive.GroupData) -> Groups[_groupId],REF_30(address[]) -> REF_29.participants,REF_31 -> LENGTH REF_30,TMP_40(bool) = i < REF_31,CONDITION TMP_40,REF_32(FourOutOfFive.GroupData) -> Groups[_groupId],REF_33(address[]) -> REF_32.participants,REF_34(address) -> REF_33[i],TMP_41(bool) = REF_34 == msg.sender,CONDITION TMP_41,rewardsTotal(uint8) = rewardsTotal + 1,TMP_42(uint8) := i(uint8),i(uint8) = i + 1,j(uint8) := 0(uint256),REF_35(FourOutOfFive.GroupData) -> Groups[_groupId],REF_36(address[]) -> REF_35.rewardedParticipants,REF_37 -> LENGTH REF_36,TMP_43(bool) = j < REF_37,CONDITION TMP_43,REF_38(FourOutOfFive.GroupData) -> Groups[_groupId],REF_39(address[]) -> REF_38.rewardedParticipants,REF_40(address) -> REF_39[j],TMP_44(bool) = REF_40 == msg.sender,CONDITION TMP_44,rewardsClaimed(uint8) = rewardsClaimed + 1,TMP_45(uint8) := j(uint8),j(uint8) = j + 1,TMP_46(bool) = rewardsTotal > rewardsClaimed,TMP_47(None) = SOLIDITY_CALL require(bool,string)(TMP_46,No rewards found for this user),REF_41(FourOutOfFive.GroupData) -> Groups[_groupId],REF_42(address[]) -> REF_41.rewardedParticipants,REF_44 -> LENGTH REF_42,TMP_49(uint256) := REF_44(uint256),TMP_50(uint256) = TMP_49 + 1,REF_44(uint256) (->Groups) := TMP_50(uint256),REF_45(address) -> REF_42[TMP_49],REF_45(address) (->Groups) := msg.sender(address),REF_46(FourOutOfFive.GroupData) -> Groups[_groupId],REF_47(uint256) -> REF_46.rewardSize,Emit RewardClaimed(_groupId,msg.sender,REF_47,block.timestamp),REF_48(FourOutOfFive.GroupData) -> Groups[_groupId],REF_49(uint8) -> REF_48.rewardsAvailable,REF_49(-> Groups) = REF_49 - 1,REF_51(FourOutOfFive.GroupData) -> Groups[_groupId],REF_52(uint256) -> REF_51.rewardSize,Transfer dest:msg.sender value:REF_52","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(Groups[_groupId].completed == true,Groups is not completed)

IRs:
REF_25(FourOutOfFive.GroupData) -> Groups[_groupId]
REF_26(bool) -> REF_25.completed
TMP_36(bool) = REF_26 == True
TMP_37(None) = SOLIDITY_CALL require(bool,string)(TMP_36,Groups is not completed)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(Groups[_groupId].rewardsAvailable > 0,No reward found.)

IRs:
REF_27(FourOutOfFive.GroupData) -> Groups[_groupId]
REF_28(uint8) -> REF_27.rewardsAvailable
TMP_38(bool) = REF_28 > 0
TMP_39(None) = SOLIDITY_CALL require(bool,string)(TMP_38,No reward found.)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4
""];
4->7;
5[label=""Node Type: BEGIN_LOOP 5
""];
5->8;
6[label=""Node Type: END_LOOP 6
""];
6->15;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
i = 0

IRs:
i(uint8) := 0(uint256)""];
7->5;
8[label=""Node Type: IF_LOOP 8

EXPRESSION:
i < Groups[_groupId].participants.length

IRs:
REF_29(FourOutOfFive.GroupData) -> Groups[_groupId]
REF_30(address[]) -> REF_29.participants
REF_31 -> LENGTH REF_30
TMP_40(bool) = i < REF_31
CONDITION TMP_40""];
8->9[label=""True""];
8->6[label=""False""];
9[label=""Node Type: IF 9

EXPRESSION:
Groups[_groupId].participants[i] == msg.sender

IRs:
REF_32(FourOutOfFive.GroupData) -> Groups[_groupId]
REF_33(address[]) -> REF_32.participants
REF_34(address) -> REF_33[i]
TMP_41(bool) = REF_34 == msg.sender
CONDITION TMP_41""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
rewardsTotal += 1

IRs:
rewardsTotal(uint8) = rewardsTotal + 1""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
i ++

IRs:
TMP_42(uint8) := i(uint8)
i(uint8) = i + 1""];
12->8;
13[label=""Node Type: BEGIN_LOOP 13
""];
13->16;
14[label=""Node Type: END_LOOP 14
""];
14->21;
15[label=""Node Type: NEW VARIABLE 15

EXPRESSION:
j = 0

IRs:
j(uint8) := 0(uint256)""];
15->13;
16[label=""Node Type: IF_LOOP 16

EXPRESSION:
j < Groups[_groupId].rewardedParticipants.length

IRs:
REF_35(FourOutOfFive.GroupData) -> Groups[_groupId]
REF_36(address[]) -> REF_35.rewardedParticipants
REF_37 -> LENGTH REF_36
TMP_43(bool) = j < REF_37
CONDITION TMP_43""];
16->17[label=""True""];
16->14[label=""False""];
17[label=""Node Type: IF 17

EXPRESSION:
Groups[_groupId].rewardedParticipants[j] == msg.sender

IRs:
REF_38(FourOutOfFive.GroupData) -> Groups[_groupId]
REF_39(address[]) -> REF_38.rewardedParticipants
REF_40(address) -> REF_39[j]
TMP_44(bool) = REF_40 == msg.sender
CONDITION TMP_44""];
17->18[label=""True""];
17->19[label=""False""];
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
rewardsClaimed += 1

IRs:
rewardsClaimed(uint8) = rewardsClaimed + 1""];
18->19;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
j ++

IRs:
TMP_45(uint8) := j(uint8)
j(uint8) = j + 1""];
20->16;
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
require(bool,string)(rewardsTotal > rewardsClaimed,No rewards found for this user)

IRs:
TMP_46(bool) = rewardsTotal > rewardsClaimed
TMP_47(None) = SOLIDITY_CALL require(bool,string)(TMP_46,No rewards found for this user)""];
21->22;
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
Groups[_groupId].rewardedParticipants.push(msg.sender)

IRs:
REF_41(FourOutOfFive.GroupData) -> Groups[_groupId]
REF_42(address[]) -> REF_41.rewardedParticipants
REF_44 -> LENGTH REF_42
TMP_49(uint256) := REF_44(uint256)
TMP_50(uint256) = TMP_49 + 1
REF_44(uint256) (->Groups) := TMP_50(uint256)
REF_45(address) -> REF_42[TMP_49]
REF_45(address) (->Groups) := msg.sender(address)""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
RewardClaimed(_groupId,msg.sender,Groups[_groupId].rewardSize,block.timestamp)

IRs:
REF_46(FourOutOfFive.GroupData) -> Groups[_groupId]
REF_47(uint256) -> REF_46.rewardSize
Emit RewardClaimed(_groupId,msg.sender,REF_47,block.timestamp)""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
Groups[_groupId].rewardsAvailable -= 1

IRs:
REF_48(FourOutOfFive.GroupData) -> Groups[_groupId]
REF_49(uint8) -> REF_48.rewardsAvailable
REF_49(-> Groups) = REF_49 - 1""];
24->25;
25[label=""Node Type: EXPRESSION 25

EXPRESSION:
msg.sender.transfer(Groups[_groupId].rewardSize)

IRs:
REF_51(FourOutOfFive.GroupData) -> Groups[_groupId]
REF_52(uint256) -> REF_51.rewardSize
Transfer dest:msg.sender value:REF_52""];
}
",0,0,1,0,"require(bool,string)(Groups[_groupId].completed == true,Groups is not completed);require(bool,string)(Groups[_groupId].rewardsAvailable > 0,No reward found.);;;i = 0;;i < Groups[_groupId].participants.length;;j = 0;Groups[_groupId].participants[i] == msg.sender;rewardsTotal += 1;;i ++;;j < Groups[_groupId].rewardedParticipants.length;;require(bool,string)(rewardsTotal > rewardsClaimed,No rewards found for this user);Groups[_groupId].rewardedParticipants[j] == msg.sender;rewardsClaimed += 1;;j ++;Groups[_groupId].rewardedParticipants.push(msg.sender);RewardClaimed(_groupId,msg.sender,Groups[_groupId].rewardSize,block.timestamp);Groups[_groupId].rewardsAvailable -= 1;msg.sender.transfer(Groups[_groupId].rewardSize)"
./0x39f89421c5bf8bb0d855c0216b00b45e3733b515_ext.sol,DINOSale.safeWithdrawal,705,715,"TMP_297 = UnaryType.BANG fundingGoalReached ,CONDITION TMP_297,REF_145(uint256) -> balanceOf[msg.sender],amount(uint256) := REF_145(uint256),REF_146(uint256) -> balanceOf[msg.sender],REF_146(uint256) (->balanceOf) := 0(uint256),TMP_298(bool) = amount > 0,CONDITION TMP_298,Transfer dest:msg.sender value:amount,Emit FundTransfer(msg.sender,amount,False),TMP_301(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['refundAmount', 'amount'] ,refundAmount(uint256) := TMP_301(uint256),MODIFIER_CALL, BaseDINOSale.afterDeadline()(),MODIFIER_CALL, BaseDINOSale.nonReentrant()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: IF 1

EXPRESSION:
! fundingGoalReached

IRs:
TMP_297 = UnaryType.BANG fundingGoalReached 
CONDITION TMP_297""];
1->2[label=""True""];
1->9[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = balanceOf[msg.sender]

IRs:
REF_145(uint256) -> balanceOf[msg.sender]
amount(uint256) := REF_145(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balanceOf[msg.sender] = 0

IRs:
REF_146(uint256) -> balanceOf[msg.sender]
REF_146(uint256) (->balanceOf) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
amount > 0

IRs:
TMP_298(bool) = amount > 0
CONDITION TMP_298""];
4->5[label=""True""];
4->8[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
FundTransfer(msg.sender,amount,false)

IRs:
Emit FundTransfer(msg.sender,amount,False)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
refundAmount = refundAmount.add(amount)

IRs:
TMP_301(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['refundAmount', 'amount'] 
refundAmount(uint256) := TMP_301(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: END_IF 9
""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
afterDeadline()

IRs:
MODIFIER_CALL, BaseDINOSale.afterDeadline()()""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
nonReentrant()

IRs:
MODIFIER_CALL, BaseDINOSale.nonReentrant()()""];
11->1;
}
",0,0,1,0,"afterDeadline();! fundingGoalReached;amount = balanceOf[msg.sender];;balanceOf[msg.sender] = 0;amount > 0;msg.sender.transfer(amount);;FundTransfer(msg.sender,amount,false);refundAmount = refundAmount.add(amount);nonReentrant()"
./0xb42ce9d2a22061b7d5e569753f92edbaa2dad37b_ext.sol,Exchanger.sell,245,258,"TMP_67(uint256) = HIGH_LEVEL_CALL, dest:tokenContract(ITradeableAsset), function:totalSupply, arguments:[]  ,TMP_68 = CONVERT this to address,TMP_69(uint256) = SOLIDITY_CALL balance(address)(TMP_68),TMP_70(uint256) = HIGH_LEVEL_CALL, dest:formulaContract(IYeekFormula), function:calculateSaleReturn, arguments:['TMP_67', 'TMP_69', 'weight', 'quantity']  ,amountInWei(uint256) := TMP_70(uint256),TMP_71(None) = SOLIDITY_CALL require(bool)(enabled),TMP_72(bool) = amountInWei >= minSaleReturn,TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72),TMP_74 = CONVERT this to address,TMP_75(uint256) = SOLIDITY_CALL balance(address)(TMP_74),TMP_76(bool) = amountInWei <= TMP_75,TMP_77(None) = SOLIDITY_CALL require(bool)(TMP_76),TMP_78(bool) = HIGH_LEVEL_CALL, dest:tokenContract(ITradeableAsset), function:transferFrom, arguments:['msg.sender', 'this', 'quantity']  ,TMP_79(None) = SOLIDITY_CALL require(bool)(TMP_78),Emit Sell(msg.sender,quantity,amountInWei),Transfer dest:msg.sender value:amountInWei","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
amountInWei = formulaContract.calculateSaleReturn(tokenContract.totalSupply(),address(this).balance,weight,quantity)

IRs:
TMP_67(uint256) = HIGH_LEVEL_CALL, dest:tokenContract(ITradeableAsset), function:totalSupply, arguments:[]  
TMP_68 = CONVERT this to address
TMP_69(uint256) = SOLIDITY_CALL balance(address)(TMP_68)
TMP_70(uint256) = HIGH_LEVEL_CALL, dest:formulaContract(IYeekFormula), function:calculateSaleReturn, arguments:['TMP_67', 'TMP_69', 'weight', 'quantity']  
amountInWei(uint256) := TMP_70(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(enabled)

IRs:
TMP_71(None) = SOLIDITY_CALL require(bool)(enabled)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(amountInWei >= minSaleReturn)

IRs:
TMP_72(bool) = amountInWei >= minSaleReturn
TMP_73(None) = SOLIDITY_CALL require(bool)(TMP_72)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(amountInWei <= address(this).balance)

IRs:
TMP_74 = CONVERT this to address
TMP_75(uint256) = SOLIDITY_CALL balance(address)(TMP_74)
TMP_76(bool) = amountInWei <= TMP_75
TMP_77(None) = SOLIDITY_CALL require(bool)(TMP_76)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(tokenContract.transferFrom(msg.sender,this,quantity))

IRs:
TMP_78(bool) = HIGH_LEVEL_CALL, dest:tokenContract(ITradeableAsset), function:transferFrom, arguments:['msg.sender', 'this', 'quantity']  
TMP_79(None) = SOLIDITY_CALL require(bool)(TMP_78)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Sell(msg.sender,quantity,amountInWei)

IRs:
Emit Sell(msg.sender,quantity,amountInWei)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
msg.sender.transfer(amountInWei)

IRs:
Transfer dest:msg.sender value:amountInWei""];
}
",0,0,1,0,"amountInWei = formulaContract.calculateSaleReturn(tokenContract.totalSupply(),address(this).balance,weight,quantity);require(bool)(enabled);require(bool)(amountInWei >= minSaleReturn);require(bool)(amountInWei <= address(this).balance);require(bool)(tokenContract.transferFrom(msg.sender,this,quantity));Sell(msg.sender,quantity,amountInWei);msg.sender.transfer(amountInWei)"
./0x7777777189c4e413bbe6ea9df6c2b4f34f53cdd3_ext.sol,Destructible.destroy,103,105,"TMP_25(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_25(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0xeb36a7650ef32f0643d39cf5b7fcefd4319febb9_ext.sol,Cycle.failSafe,665,675,"TMP_272(bool) = msg.sender == operator,CONDITION TMP_272,saveMe(bool) := True(bool),TMP_273(bool) = msg.sender == juryOperator,CONDITION TMP_273,TMP_274(bool) = saveMe == True,TMP_275(None) = SOLIDITY_CALL require(bool)(TMP_274),TMP_276 = CONVERT this to address,TMP_277(uint256) = SOLIDITY_CALL balance(address)(TMP_276),TMP_278 = SEND dest:juryOperator value:TMP_277,TMP_279(None) = SOLIDITY_CALL require(bool)(TMP_278),TMP_280(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:balanceOf, arguments:['this']  ,allTheLockedTokens(uint256) := TMP_280(uint256),TMP_281(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transfer, arguments:['juryOperator', 'allTheLockedTokens']  ,TMP_282(None) = SOLIDITY_CALL require(bool)(TMP_281),MODIFIER_CALL, Cycle.onlyAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == operator

IRs:
TMP_272(bool) = msg.sender == operator
CONDITION TMP_272""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
saveMe = true

IRs:
saveMe(bool) := True(bool)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
msg.sender == juryOperator

IRs:
TMP_273(bool) = msg.sender == juryOperator
CONDITION TMP_273""];
4->5[label=""True""];
4->9[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(saveMe == true)

IRs:
TMP_274(bool) = saveMe == True
TMP_275(None) = SOLIDITY_CALL require(bool)(TMP_274)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
require(bool)(juryOperator.send(address(this).balance))

IRs:
TMP_276 = CONVERT this to address
TMP_277(uint256) = SOLIDITY_CALL balance(address)(TMP_276)
TMP_278 = SEND dest:juryOperator value:TMP_277
TMP_279(None) = SOLIDITY_CALL require(bool)(TMP_278)""];
6->7;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
allTheLockedTokens = token.balanceOf(this)

IRs:
TMP_280(uint256) = HIGH_LEVEL_CALL, dest:token(Token), function:balanceOf, arguments:['this']  
allTheLockedTokens(uint256) := TMP_280(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
require(bool)(token.transfer(juryOperator,allTheLockedTokens))

IRs:
TMP_281(bool) = HIGH_LEVEL_CALL, dest:token(Token), function:transfer, arguments:['juryOperator', 'allTheLockedTokens']  
TMP_282(None) = SOLIDITY_CALL require(bool)(TMP_281)""];
8->9;
9[label=""Node Type: END_IF 9
""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, Cycle.onlyAdmin()()""];
10->1;
}
",0,0,1,0,"onlyAdmin();msg.sender == operator;saveMe = true;;msg.sender == juryOperator;require(bool)(saveMe == true);;require(bool)(juryOperator.send(address(this).balance));allTheLockedTokens = token.balanceOf(this);require(bool)(token.transfer(juryOperator,allTheLockedTokens))"
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.getBountyAddress,2,2,"RETURN bountyaddress,MODIFIER_CALL, KahnDistributionCentre.onlyStaffs()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: RETURN 1

EXPRESSION:
bountyaddress

IRs:
RETURN bountyaddress""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyStaffs()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyStaffs()()""];
2->1;
}
",0,1,1,0,onlyStaffs();bountyaddress
./0xf2b89f45cc4ebbf11a36bdb4a4b24eada8dd30a7_ext.sol,AirDrop.transferEthToOnwer,79,81,"REF_10(uint256) = SOLIDITY_CALL balance(address)(this),TMP_22 = SEND dest:owner value:REF_10,TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(owner.send(this.balance))

IRs:
REF_10(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_22 = SEND dest:owner value:REF_10
TMP_23(None) = SOLIDITY_CALL require(bool)(TMP_22)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();require(bool)(owner.send(this.balance))
./0x0e752b742f744fdc2d93774da44c37b72c3e6952_ext.sol,CraftyCrowdsale.reclaimEther,601,603,"REF_99(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:owner value:REF_99,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(this.balance)

IRs:
REF_99(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:owner value:REF_99""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();owner.transfer(this.balance)
./0xc0a1f89bbcaddab4b736e786b6b16c67bc92ed35_ext.sol,MiniMeToken.claimTokens,587,597,"TMP_120(bool) = _token == 0,CONDITION TMP_120,REF_58(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:controller value:REF_58,TMP_122 = CONVERT _token to ERC20Token,token(ERC20Token) := TMP_122(ERC20Token),TMP_123(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_123(uint256),TMP_124(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:transfer, arguments:['controller', 'balance']  ,Emit ClaimedTokens(_token,controller,balance),MODIFIER_CALL, Controlled.onlyController()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_120(bool) = _token == 0
CONDITION TMP_120""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(this.balance)

IRs:
REF_58(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:controller value:REF_58""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
token = ERC20Token(_token)

IRs:
TMP_122 = CONVERT _token to ERC20Token
token(ERC20Token) := TMP_122(ERC20Token)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_123(uint256) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_123(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_124(bool) = HIGH_LEVEL_CALL, dest:token(ERC20Token), function:transfer, arguments:['controller', 'balance']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()""];
9->1;
}
",0,0,1,0,"onlyController();_token == 0x0;controller.transfer(this.balance);;;token = ERC20Token(_token);balance = token.balanceOf(this);token.transfer(controller,balance);ClaimedTokens(_token,controller,balance)"
./0xf4c3a48f27666ef8bedab8d73c0117e1aeaf1ba0_ext.sol,ItemMarket.Payout,173,187,"REF_5(ItemMarket.Item) -> Items[id],UsedItem(ItemMarket.Item) := REF_5(ItemMarket.Item),REF_6(uint256) -> UsedItem.amount,Paid(uint256) := REF_6(uint256),REF_7(uint256) -> UsedItem.amount,REF_7(uint256) (->UsedItem) := 0(uint256),REF_8(address) -> UsedItem.owner,Transfer dest:REF_8 value:Paid,REF_10(address) -> UsedItem.owner,TMP_73 = CONVERT 0 to address,REF_10(address) (->UsedItem) := TMP_73(address),REF_11(uint256) -> UsedItem.price,REF_12(uint256) -> UsedItem.minPrice,REF_11(uint256) (->UsedItem) := REF_12(uint256),REF_13(uint256) -> UsedItem.timestamp,REF_13(uint256) (->UsedItem) := 0(uint256),Emit ItemWon(id)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
UsedItem = Items[id]

IRs:
REF_5(ItemMarket.Item) -> Items[id]
UsedItem(ItemMarket.Item) := REF_5(ItemMarket.Item)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
Paid = UsedItem.amount

IRs:
REF_6(uint256) -> UsedItem.amount
Paid(uint256) := REF_6(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
UsedItem.amount = 0

IRs:
REF_7(uint256) -> UsedItem.amount
REF_7(uint256) (->UsedItem) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
UsedItem.owner.transfer(Paid)

IRs:
REF_8(address) -> UsedItem.owner
Transfer dest:REF_8 value:Paid""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
UsedItem.owner = address(0)

IRs:
REF_10(address) -> UsedItem.owner
TMP_73 = CONVERT 0 to address
REF_10(address) (->UsedItem) := TMP_73(address)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
UsedItem.price = UsedItem.minPrice

IRs:
REF_11(uint256) -> UsedItem.price
REF_12(uint256) -> UsedItem.minPrice
REF_11(uint256) (->UsedItem) := REF_12(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
UsedItem.timestamp = 0

IRs:
REF_13(uint256) -> UsedItem.timestamp
REF_13(uint256) (->UsedItem) := 0(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ItemWon(id)

IRs:
Emit ItemWon(id)""];
}
",0,0,1,0,UsedItem = Items[id];Paid = UsedItem.amount;UsedItem.amount = 0;UsedItem.owner.transfer(Paid);UsedItem.owner = address(0);UsedItem.price = UsedItem.minPrice;UsedItem.timestamp = 0;ItemWon(id)
./0xd54920cedf704b87342fa26d5773efabf9037a77_ext.sol,CryptoStars.withdrawPartial,376,384,"TMP_112(bool) = msg.sender != owner,CONDITION TMP_112,REF_146(uint256) -> pendingWithdrawals[msg.sender],TMP_113(bool) = withdrawAmount > REF_146,CONDITION TMP_113,REF_147(uint256) -> pendingWithdrawals[msg.sender],REF_147(-> pendingWithdrawals) = REF_147 - withdrawAmount,TMP_114 = SEND dest:msg.sender value:withdrawAmount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender != owner

IRs:
TMP_112(bool) = msg.sender != owner
CONDITION TMP_112""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: THROW 2
""];
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
withdrawAmount > pendingWithdrawals[msg.sender]

IRs:
REF_146(uint256) -> pendingWithdrawals[msg.sender]
TMP_113(bool) = withdrawAmount > REF_146
CONDITION TMP_113""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: THROW 5
""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
pendingWithdrawals[msg.sender] -= withdrawAmount

IRs:
REF_147(uint256) -> pendingWithdrawals[msg.sender]
REF_147(-> pendingWithdrawals) = REF_147 - withdrawAmount""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
msg.sender.send(withdrawAmount)

IRs:
TMP_114 = SEND dest:msg.sender value:withdrawAmount""];
}
",0,0,1,0,msg.sender != owner;;;withdrawAmount > pendingWithdrawals[msg.sender];;;pendingWithdrawals[msg.sender] -= withdrawAmount;msg.sender.send(withdrawAmount)
./0x1b5c8afd9739c3d2af5a4859dec0482a6df7667d_ext.sol,HomesCoin.destroy,91,94,"TMP_33(bool) = msg.sender == owner,TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33),TMP_35(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner)

IRs:
TMP_33(bool) = msg.sender == owner
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(msg.sender)

IRs:
TMP_35(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender)""];
}
",0,0,1,0,require(bool)(msg.sender == owner);selfdestruct(address)(msg.sender)
./0x3688587725ed6dda84bcd25aeeb04997415da50a_ext.sol,BFreeContract.withdraw,427,434,"REF_92(uint256) = SOLIDITY_CALL balance(address)(this),contractbalance(uint256) := REF_92([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B73326D0>]),sender(address) := msg.sender(address),TMP_216(bool) = contractbalance >= summeInWei,TMP_217(None) = SOLIDITY_CALL require(bool)(TMP_216),TMP_218(None) = SOLIDITY_CALL require(bool)(minimalGoalReached),Emit withdrawed(sender,summeInWei,wei withdrawed),Transfer dest:sender value:summeInWei,MODIFIER_CALL, owned.isOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
contractbalance = this.balance

IRs:
REF_92(uint256) = SOLIDITY_CALL balance(address)(this)
contractbalance(uint256) := REF_92([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B73326D0>])""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
sender = msg.sender

IRs:
sender(address) := msg.sender(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(contractbalance >= summeInWei)

IRs:
TMP_216(bool) = contractbalance >= summeInWei
TMP_217(None) = SOLIDITY_CALL require(bool)(TMP_216)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(minimalGoalReached)

IRs:
TMP_218(None) = SOLIDITY_CALL require(bool)(minimalGoalReached)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
withdrawed(sender,summeInWei,wei withdrawed)

IRs:
Emit withdrawed(sender,summeInWei,wei withdrawed)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
sender.transfer(summeInWei)

IRs:
Transfer dest:sender value:summeInWei""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
isOwner()

IRs:
MODIFIER_CALL, owned.isOwner()()""];
7->1;
}
",0,0,1,0,"isOwner();contractbalance = this.balance;sender = msg.sender;require(bool)(contractbalance >= summeInWei);require(bool)(minimalGoalReached);withdrawed(sender,summeInWei,wei withdrawed);sender.transfer(summeInWei)"
./0x4c4757b23526ba13876f8ef3efe973618266e3e8_ext.sol,UZMINI_KO.StopGame,34,40,"TMP_9(bool) = msg.sender == questionSender,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_9(bool) = msg.sender == questionSender
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0xda11e959bcaaba5f88dbf4d866e270c78bc84b76_ext.sol,EBP.withdraw,294,297,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, EBP.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, EBP.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x32d782c283924f1e40b2a839b8121564b7b9142e_ext.sol,SUPER_Q.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 400000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 400000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 400000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 400000000000000000;msg.sender.transfer(this.balance);
./0xd5670cdb0d6e6d9eedfdbaceb97d5774466f0b23_ext.sol,YouCollectBase._payout,196,202,"TMP_92 = CONVERT 0 to address,TMP_93(bool) = _to == TMP_92,CONDITION TMP_93,Transfer dest:ceoAddress value:amount,Transfer dest:_to value:amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_to == address(0)

IRs:
TMP_92 = CONVERT 0 to address
TMP_93(bool) = _to == TMP_92
CONDITION TMP_93""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ceoAddress.transfer(amount)

IRs:
Transfer dest:ceoAddress value:amount""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_to.transfer(amount)

IRs:
Transfer dest:_to value:amount""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,_to == address(0);ceoAddress.transfer(amount);_to.transfer(amount);
./0x58a2263f77e1b23a74a3d99b9d01506da308800b_ext.sol,NetworkTokenPayment.withdrawAll,317,321,"myAddress(address) := this(address),TMP_138(uint256) = SOLIDITY_CALL balance(address)(myAddress),etherBalance(uint256) := TMP_138(uint256),Transfer dest:owner value:etherBalance,MODIFIER_CALL, NetworkTokenPayment.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
myAddress = this

IRs:
myAddress(address) := this(address)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
etherBalance = myAddress.balance

IRs:
TMP_138(uint256) = SOLIDITY_CALL balance(address)(myAddress)
etherBalance(uint256) := TMP_138(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(etherBalance)

IRs:
Transfer dest:owner value:etherBalance""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, NetworkTokenPayment.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();myAddress = this;etherBalance = myAddress.balance;owner.transfer(etherBalance)
./0x6947335452cb7a452fc337c28cb0d597806c7672_ext.sol,SmartWeddingContract.pay,142,150,"TMP_30 = CONVERT 0 to address,TMP_31(bool) = _to != TMP_30,TMP_32(None) = SOLIDITY_CALL require(bool,string)(TMP_31,Sending funds to address zero is prohibited!),TMP_33 = CONVERT this to address,TMP_34(uint256) = SOLIDITY_CALL balance(address)(TMP_33),TMP_35(bool) = _amount <= TMP_34,TMP_36(None) = SOLIDITY_CALL require(bool,string)(TMP_35,Not enough balance available!),Transfer dest:_to value:_amount,Emit FundsSent(now,_to,_amount),MODIFIER_CALL, SmartWeddingContract.onlySpouse()(),MODIFIER_CALL, SmartWeddingContract.isSigned()(),MODIFIER_CALL, SmartWeddingContract.isNotDivorced()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(_to != address(0),Sending funds to address zero is prohibited!)

IRs:
TMP_30 = CONVERT 0 to address
TMP_31(bool) = _to != TMP_30
TMP_32(None) = SOLIDITY_CALL require(bool,string)(TMP_31,Sending funds to address zero is prohibited!)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(_amount <= address(this).balance,Not enough balance available!)

IRs:
TMP_33 = CONVERT this to address
TMP_34(uint256) = SOLIDITY_CALL balance(address)(TMP_33)
TMP_35(bool) = _amount <= TMP_34
TMP_36(None) = SOLIDITY_CALL require(bool,string)(TMP_35,Not enough balance available!)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_to.transfer(_amount)

IRs:
Transfer dest:_to value:_amount""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
FundsSent(now,_to,_amount)

IRs:
Emit FundsSent(now,_to,_amount)""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlySpouse()

IRs:
MODIFIER_CALL, SmartWeddingContract.onlySpouse()()""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
isSigned()

IRs:
MODIFIER_CALL, SmartWeddingContract.isSigned()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
isNotDivorced()

IRs:
MODIFIER_CALL, SmartWeddingContract.isNotDivorced()()""];
7->1;
}
",0,0,1,0,"onlySpouse();require(bool,string)(_to != address(0),Sending funds to address zero is prohibited!);require(bool,string)(_amount <= address(this).balance,Not enough balance available!);_to.transfer(_amount);FundsSent(now,_to,_amount);isSigned();isNotDivorced()"
./0xc3a684140448995f6abeb361c56110207da04d57_ext.sol,SignalsSociety.acceptMembership,87,106,"TMP_37(uint256) = INTERNAL_CALL, Memberships.getMembershipPrice(Memberships.Membership)(membership),TMP_38(uint256) = TMP_37 - discount,price(uint256) := TMP_38(uint256),REF_9(uint256) -> balances[account],TMP_39(bool) = REF_9 >= price,TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39),REF_10(uint256) -> balances[account],REF_10(-> balances) = REF_10 - price,TMP_41(bool) = reseller != 0,CONDITION TMP_41,Transfer dest:reseller value:comission,TMP_43(uint256) = price - comission,Transfer dest:owner value:TMP_43,Transfer dest:owner value:price,Emit MembershipPaid(account,membership,now),MODIFIER_CALL, Ownable.onlyBot()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
price = getMembershipPrice(membership) - discount

IRs:
TMP_37(uint256) = INTERNAL_CALL, Memberships.getMembershipPrice(Memberships.Membership)(membership)
TMP_38(uint256) = TMP_37 - discount
price(uint256) := TMP_38(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[account] >= price)

IRs:
REF_9(uint256) -> balances[account]
TMP_39(bool) = REF_9 >= price
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[account] -= price

IRs:
REF_10(uint256) -> balances[account]
REF_10(-> balances) = REF_10 - price""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
reseller != 0x0

IRs:
TMP_41(bool) = reseller != 0
CONDITION TMP_41""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
reseller.transfer(comission)

IRs:
Transfer dest:reseller value:comission""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
owner.transfer(price - comission)

IRs:
TMP_43(uint256) = price - comission
Transfer dest:owner value:TMP_43""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
owner.transfer(price)

IRs:
Transfer dest:owner value:price""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
MembershipPaid(account,membership,now)

IRs:
Emit MembershipPaid(account,membership,now)""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyBot()

IRs:
MODIFIER_CALL, Ownable.onlyBot()()""];
10->1;
}
",0,0,1,0,"onlyBot();price = getMembershipPrice(membership) - discount;require(bool)(balances[account] >= price);balances[account] -= price;reseller != 0x0;reseller.transfer(comission);owner.transfer(price);owner.transfer(price - comission);;MembershipPaid(account,membership,now)"
./0xa1f1fc153936a3880412743d1b180fa65b63eece_ext.sol,DONC.withdraw,294,297,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, DONC.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, DONC.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x1f4215fe007ee5b170391241656a28a8bd13826e_ext.sol,MultiOwner.kill,80,85,"REF_31(bool) -> RequireDispose[msg.sender],REF_31(bool) (->RequireDispose) := True(bool),TMP_34(bool) = INTERNAL_CALL, MultiOwner.ConfirmDispose()(),CONDITION TMP_34,TMP_35(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender),MODIFIER_CALL, MultiOwner.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
RequireDispose[msg.sender] = true

IRs:
REF_31(bool) -> RequireDispose[msg.sender]
REF_31(bool) (->RequireDispose) := True(bool)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
ConfirmDispose()

IRs:
TMP_34(bool) = INTERNAL_CALL, MultiOwner.ConfirmDispose()()
CONDITION TMP_34""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
selfdestruct(address)(msg.sender)

IRs:
TMP_35(None) = SOLIDITY_CALL selfdestruct(address)(msg.sender)""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, MultiOwner.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();RequireDispose[msg.sender] = true;ConfirmDispose();selfdestruct(address)(msg.sender);
./0x297ac8bc7540bc241f065fcc22c570b40170b573_ext.sol,TraceTokenSale.refund,620,631,"TMP_322(None) = SOLIDITY_CALL require(bool)(refundAllowed),TMP_323(bool) = INTERNAL_CALL, TraceTokenSale.hasEnded()(),TMP_324(None) = SOLIDITY_CALL require(bool)(TMP_323),TMP_325(bool) = INTERNAL_CALL, TraceTokenSale.softCapReached()(),TMP_326 = UnaryType.BANG TMP_325 ,TMP_327(None) = SOLIDITY_CALL require(bool)(TMP_326),REF_218(uint256) -> etherBalances[msg.sender],TMP_328(bool) = REF_218 > 0,TMP_329(None) = SOLIDITY_CALL require(bool)(TMP_328),TMP_330(uint256) = HIGH_LEVEL_CALL, dest:token(TraceToken), function:balanceOf, arguments:['msg.sender']  ,TMP_331(bool) = TMP_330 > 0,TMP_332(None) = SOLIDITY_CALL require(bool)(TMP_331),REF_220(uint256) -> etherBalances[msg.sender],current_balance(uint256) := REF_220(uint256),REF_221(uint256) -> etherBalances[msg.sender],REF_221(uint256) (->etherBalances) := 0(uint256),TMP_333(uint256) = HIGH_LEVEL_CALL, dest:token(TraceToken), function:balanceOf, arguments:['msg.sender']  ,TMP_334(bool) = HIGH_LEVEL_CALL, dest:token(TraceToken), function:transfer, arguments:['this', 'TMP_333']  ,Transfer dest:msg.sender value:current_balance","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(refundAllowed)

IRs:
TMP_322(None) = SOLIDITY_CALL require(bool)(refundAllowed)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(hasEnded())

IRs:
TMP_323(bool) = INTERNAL_CALL, TraceTokenSale.hasEnded()()
TMP_324(None) = SOLIDITY_CALL require(bool)(TMP_323)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(! softCapReached())

IRs:
TMP_325(bool) = INTERNAL_CALL, TraceTokenSale.softCapReached()()
TMP_326 = UnaryType.BANG TMP_325 
TMP_327(None) = SOLIDITY_CALL require(bool)(TMP_326)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(etherBalances[msg.sender] > 0)

IRs:
REF_218(uint256) -> etherBalances[msg.sender]
TMP_328(bool) = REF_218 > 0
TMP_329(None) = SOLIDITY_CALL require(bool)(TMP_328)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(token.balanceOf(msg.sender) > 0)

IRs:
TMP_330(uint256) = HIGH_LEVEL_CALL, dest:token(TraceToken), function:balanceOf, arguments:['msg.sender']  
TMP_331(bool) = TMP_330 > 0
TMP_332(None) = SOLIDITY_CALL require(bool)(TMP_331)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
current_balance = etherBalances[msg.sender]

IRs:
REF_220(uint256) -> etherBalances[msg.sender]
current_balance(uint256) := REF_220(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
etherBalances[msg.sender] = 0

IRs:
REF_221(uint256) -> etherBalances[msg.sender]
REF_221(uint256) (->etherBalances) := 0(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
token.transfer(this,token.balanceOf(msg.sender))

IRs:
TMP_333(uint256) = HIGH_LEVEL_CALL, dest:token(TraceToken), function:balanceOf, arguments:['msg.sender']  
TMP_334(bool) = HIGH_LEVEL_CALL, dest:token(TraceToken), function:transfer, arguments:['this', 'TMP_333']  ""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
msg.sender.transfer(current_balance)

IRs:
Transfer dest:msg.sender value:current_balance""];
}
",0,0,1,0,"require(bool)(refundAllowed);require(bool)(hasEnded());require(bool)(! softCapReached());require(bool)(etherBalances[msg.sender] > 0);require(bool)(token.balanceOf(msg.sender) > 0);current_balance = etherBalances[msg.sender];etherBalances[msg.sender] = 0;token.transfer(this,token.balanceOf(msg.sender));msg.sender.transfer(current_balance)"
./0xb387be1e10d56bd7c6849b7be9d6aad564854d72_ext.sol,Alfa_quiZ.Stop,28,30,"REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3,MODIFIER_CALL, Alfa_quiZ.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, Alfa_quiZ.isAdmin()()""];
2->1;
}
",0,0,1,0,isAdmin();msg.sender.transfer(this.balance)
./0xeed618c15d12c635c3c319aee7bded2e2879aea0_ext.sol,PlayerBook.registerNameCore,291,319,"REF_54(uint256) -> pIDxName_[_name],TMP_59(bool) = REF_54 != 0,CONDITION TMP_59,REF_55(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_56(bool) -> REF_55[_name],TMP_60(bool) = REF_56 == True,TMP_61(None) = SOLIDITY_CALL require(bool,string)(TMP_60,sorry that names already taken),REF_57(PlayerBook.Player) -> plyr_[_pID],REF_58(bytes32) -> REF_57.name,REF_58(bytes32) (->plyr_) := _name(bytes32),REF_59(uint256) -> pIDxName_[_name],REF_59(uint256) (->pIDxName_) := _pID(uint256),REF_60(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_61(bool) -> REF_60[_name],TMP_62(bool) = REF_61 == False,CONDITION TMP_62,REF_62(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_63(bool) -> REF_62[_name],REF_63(bool) (->plyrNames_) := True(bool),REF_64(PlayerBook.Player) -> plyr_[_pID],REF_65(uint256) -> REF_64.names,TMP_63(uint256) := REF_65(uint256),REF_65(-> plyr_) = REF_65 + 1,REF_66(mapping(uint256 => bytes32)) -> plyrNameList_[_pID],REF_67(PlayerBook.Player) -> plyr_[_pID],REF_68(uint256) -> REF_67.names,REF_69(bytes32) -> REF_66[REF_68],REF_69(bytes32) (->plyrNameList_) := _name(bytes32),TMP_64 = CONVERT this to address,TMP_65(uint256) = SOLIDITY_CALL balance(address)(TMP_64),Transfer dest:_owner value:TMP_65,TMP_67(bool) = _all == True,CONDITION TMP_67,i(uint256) := 1(uint256),TMP_68(bool) = i <= gID_,CONDITION TMP_68,REF_71(PlayerBookReceiverInterface) -> games_[i],HIGH_LEVEL_CALL, dest:REF_71(PlayerBookReceiverInterface), function:receivePlayerInfo, arguments:['_pID', '_addr', '_name', '_affID']  ,TMP_70(uint256) := i(uint256),i(uint256) = i + 1,REF_73(PlayerBook.Player) -> plyr_[_affID],REF_74(address) -> REF_73.addr,REF_75(PlayerBook.Player) -> plyr_[_affID],REF_76(bytes32) -> REF_75.name,Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_74,REF_76,msg.value,now)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
pIDxName_[_name] != 0

IRs:
REF_54(uint256) -> pIDxName_[_name]
TMP_59(bool) = REF_54 != 0
CONDITION TMP_59""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(plyrNames_[_pID][_name] == true,sorry that names already taken)

IRs:
REF_55(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_56(bool) -> REF_55[_name]
TMP_60(bool) = REF_56 == True
TMP_61(None) = SOLIDITY_CALL require(bool,string)(TMP_60,sorry that names already taken)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
plyr_[_pID].name = _name

IRs:
REF_57(PlayerBook.Player) -> plyr_[_pID]
REF_58(bytes32) -> REF_57.name
REF_58(bytes32) (->plyr_) := _name(bytes32)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
pIDxName_[_name] = _pID

IRs:
REF_59(uint256) -> pIDxName_[_name]
REF_59(uint256) (->pIDxName_) := _pID(uint256)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
plyrNames_[_pID][_name] == false

IRs:
REF_60(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_61(bool) -> REF_60[_name]
TMP_62(bool) = REF_61 == False
CONDITION TMP_62""];
6->7[label=""True""];
6->10[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
plyrNames_[_pID][_name] = true

IRs:
REF_62(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_63(bool) -> REF_62[_name]
REF_63(bool) (->plyrNames_) := True(bool)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
plyr_[_pID].names ++

IRs:
REF_64(PlayerBook.Player) -> plyr_[_pID]
REF_65(uint256) -> REF_64.names
TMP_63(uint256) := REF_65(uint256)
REF_65(-> plyr_) = REF_65 + 1""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
plyrNameList_[_pID][plyr_[_pID].names] = _name

IRs:
REF_66(mapping(uint256 => bytes32)) -> plyrNameList_[_pID]
REF_67(PlayerBook.Player) -> plyr_[_pID]
REF_68(uint256) -> REF_67.names
REF_69(bytes32) -> REF_66[REF_68]
REF_69(bytes32) (->plyrNameList_) := _name(bytes32)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
_owner.transfer(address(this).balance)

IRs:
TMP_64 = CONVERT this to address
TMP_65(uint256) = SOLIDITY_CALL balance(address)(TMP_64)
Transfer dest:_owner value:TMP_65""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
_all == true

IRs:
TMP_67(bool) = _all == True
CONDITION TMP_67""];
12->15[label=""True""];
12->19[label=""False""];
13[label=""Node Type: BEGIN_LOOP 13
""];
13->16;
14[label=""Node Type: END_LOOP 14
""];
14->19;
15[label=""Node Type: NEW VARIABLE 15

EXPRESSION:
i = 1

IRs:
i(uint256) := 1(uint256)""];
15->13;
16[label=""Node Type: IF_LOOP 16

EXPRESSION:
i <= gID_

IRs:
TMP_68(bool) = i <= gID_
CONDITION TMP_68""];
16->17[label=""True""];
16->14[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
games_[i].receivePlayerInfo(_pID,_addr,_name,_affID)

IRs:
REF_71(PlayerBookReceiverInterface) -> games_[i]
HIGH_LEVEL_CALL, dest:REF_71(PlayerBookReceiverInterface), function:receivePlayerInfo, arguments:['_pID', '_addr', '_name', '_affID']  ""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
i ++

IRs:
TMP_70(uint256) := i(uint256)
i(uint256) = i + 1""];
18->16;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,msg.value,now)

IRs:
REF_73(PlayerBook.Player) -> plyr_[_affID]
REF_74(address) -> REF_73.addr
REF_75(PlayerBook.Player) -> plyr_[_affID]
REF_76(bytes32) -> REF_75.name
Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_74,REF_76,msg.value,now)""];
}
",0,0,1,0,"pIDxName_[_name] != 0;require(bool,string)(plyrNames_[_pID][_name] == true,sorry that names already taken);;plyr_[_pID].name = _name;pIDxName_[_name] = _pID;plyrNames_[_pID][_name] == false;plyrNames_[_pID][_name] = true;;plyr_[_pID].names ++;plyrNameList_[_pID][plyr_[_pID].names] = _name;_owner.transfer(address(this).balance);_all == true;i = 1;;;i <= gID_;;games_[i].receivePlayerInfo(_pID,_addr,_name,_affID);i ++;onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,msg.value,now)"
./0x5bcbb71ef20825120774e35cba72f1a15a9d27ba_ext.sol,ENIGMA.Stop,28,30,"REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3,MODIFIER_CALL, ENIGMA.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, ENIGMA.isAdmin()()""];
2->1;
}
",0,0,1,0,isAdmin();msg.sender.transfer(this.balance)
./0x330ac216a5a8ccd493f3b9e33a524be3c7124217_ext.sol,Bonds.withdraw,262,273,"_customerAddress(address) := msg.sender(address),REF_106(uint256) -> ownerAccounts[_customerAddress],TMP_57(bool) = REF_106 > 0,TMP_58(None) = SOLIDITY_CALL require(bool)(TMP_57),REF_107(uint256) -> ownerAccounts[_customerAddress],_dividends(uint256) := REF_107(uint256),REF_108(uint256) -> ownerAccounts[_customerAddress],REF_108(uint256) (->ownerAccounts) := 0(uint256),Transfer dest:_customerAddress value:_dividends,Emit onWithdraw(_customerAddress,_dividends)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(ownerAccounts[_customerAddress] > 0)

IRs:
REF_106(uint256) -> ownerAccounts[_customerAddress]
TMP_57(bool) = REF_106 > 0
TMP_58(None) = SOLIDITY_CALL require(bool)(TMP_57)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
_dividends = ownerAccounts[_customerAddress]

IRs:
REF_107(uint256) -> ownerAccounts[_customerAddress]
_dividends(uint256) := REF_107(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownerAccounts[_customerAddress] = 0

IRs:
REF_108(uint256) -> ownerAccounts[_customerAddress]
REF_108(uint256) (->ownerAccounts) := 0(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_customerAddress.transfer(_dividends)

IRs:
Transfer dest:_customerAddress value:_dividends""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onWithdraw(_customerAddress,_dividends)

IRs:
Emit onWithdraw(_customerAddress,_dividends)""];
}
",0,0,1,0,"_customerAddress = msg.sender;require(bool)(ownerAccounts[_customerAddress] > 0);_dividends = ownerAccounts[_customerAddress];ownerAccounts[_customerAddress] = 0;_customerAddress.transfer(_dividends);onWithdraw(_customerAddress,_dividends)"
./0x1d9be4a5681374c54b1821d0beac3a678ad128a4_ext.sol,StorageController.withdrawEth,748,754,"TMP_465(uint256) = 0 * 1000000000000000000,TMP_466(bool) = _value >= TMP_465,TMP_467(None) = SOLIDITY_CALL require(bool)(TMP_466),REF_134(uint256) = SOLIDITY_CALL balance(address)(this),TMP_468(bool) = REF_134 < _value,CONDITION TMP_468,REF_135(uint256) = SOLIDITY_CALL balance(address)(this),_value(uint256) := REF_135([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E4AEB130>]),Transfer dest:_userAddress value:_value,MODIFIER_CALL, StorageController.onlyManagerOrCreator()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_value >= 0.1 * 1000000000000000000)

IRs:
TMP_465(uint256) = 0 * 1000000000000000000
TMP_466(bool) = _value >= TMP_465
TMP_467(None) = SOLIDITY_CALL require(bool)(TMP_466)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
this.balance < _value

IRs:
REF_134(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_468(bool) = REF_134 < _value
CONDITION TMP_468""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_value = this.balance

IRs:
REF_135(uint256) = SOLIDITY_CALL balance(address)(this)
_value(uint256) := REF_135([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E4AEB130>])""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_userAddress.transfer(_value)

IRs:
Transfer dest:_userAddress value:_value""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyManagerOrCreator()

IRs:
MODIFIER_CALL, StorageController.onlyManagerOrCreator()()""];
6->1;
}
",0,0,1,0,onlyManagerOrCreator();require(bool)(_value >= 0.1 * 1000000000000000000);this.balance < _value;_value = this.balance;;_userAddress.transfer(_value)
./0xe3ec74dbce6ee1d8680e38714b67ab5535c95bdb_ext.sol,try_it.StopGame,33,36,"TMP_10(bool) = msg.sender == questionSender,TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_10(bool) = msg.sender == questionSender
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0xf2f13b50e63454a5ce255f8355285561c13bb3cc_ext.sol,BNCXCrowdsale.kill,55,58,"TMP_15(bool) = msg.sender == creator,TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15),TMP_17(None) = SOLIDITY_CALL selfdestruct(address)(owner)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == creator)

IRs:
TMP_15(bool) = msg.sender == creator
TMP_16(None) = SOLIDITY_CALL require(bool)(TMP_15)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_17(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
}
",0,0,1,0,require(bool)(msg.sender == creator);selfdestruct(address)(owner)
./0xb620cee6b52f96f3c6b253e6eea556aa2d214a99_ext.sol,DrainMe.callSecondTarget,96,99,"TMP_26(bool) = msg.value >= 5000000000000000,TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26),TMP_29(bool) = LOW_LEVEL_CALL, dest:secondTarget, function:call, arguments:[] value:msg.value ,MODIFIER_CALL, DrainMe.onlyPlayers()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= 5000000000000000)

IRs:
TMP_26(bool) = msg.value >= 5000000000000000
TMP_27(None) = SOLIDITY_CALL require(bool)(TMP_26)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
secondTarget.call.value(msg.value)()

IRs:
TMP_29(bool) = LOW_LEVEL_CALL, dest:secondTarget, function:call, arguments:[] value:msg.value ""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyPlayers()

IRs:
MODIFIER_CALL, DrainMe.onlyPlayers()()""];
3->1;
}
",0,0,1,0,onlyPlayers();require(bool)(msg.value >= 5000000000000000);secondTarget.call.value(msg.value)()
./0x518c55ad0cc887f78e2c7fe23b14c33a34586edc_ext.sol,RefundVault.refund,496,502,"REF_22(RefundVault.State) -> State.Refunding,TMP_168(bool) = state == REF_22,TMP_169(None) = SOLIDITY_CALL require(bool)(TMP_168),REF_23(uint256) -> deposited[investor],depositedValue(uint256) := REF_23(uint256),REF_24(uint256) -> deposited[investor],REF_24(uint256) (->deposited) := 0(uint256),Transfer dest:investor value:depositedValue,Emit Refunded(investor,depositedValue)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Refunding)

IRs:
REF_22(RefundVault.State) -> State.Refunding
TMP_168(bool) = state == REF_22
TMP_169(None) = SOLIDITY_CALL require(bool)(TMP_168)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
depositedValue = deposited[investor]

IRs:
REF_23(uint256) -> deposited[investor]
depositedValue(uint256) := REF_23(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
deposited[investor] = 0

IRs:
REF_24(uint256) -> deposited[investor]
REF_24(uint256) (->deposited) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
investor.transfer(depositedValue)

IRs:
Transfer dest:investor value:depositedValue""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Refunded(investor,depositedValue)

IRs:
Emit Refunded(investor,depositedValue)""];
}
",0,0,1,0,"require(bool)(state == State.Refunding);depositedValue = deposited[investor];deposited[investor] = 0;investor.transfer(depositedValue);Refunded(investor,depositedValue)"
./0x17478cc05e51da20a27bbdf66fbe4a16aae81842_ext.sol,AuctionPotato.withdraw,215,266,"TMP_46(bool) = blockerWithdraw == False,TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46),blockerWithdraw(bool) := True(bool),CONDITION canceled,withdrawalAccount(address) := msg.sender(address),REF_17(uint256) -> fundsByBidder[withdrawalAccount],withdrawalAmount(uint256) := REF_17(uint256),REF_18(uint256) -> fundsByBidder[withdrawalAccount],REF_18(uint256) (->fundsByBidder) := 0(uint256),TMP_48(bool) = ownerHasWithdrawn == False,TMP_49(bool) = msg.sender == owner,TMP_50(bool) = TMP_48 && TMP_49,TMP_51(bool) = canceled == True,TMP_52(bool) = now > endTime,TMP_53(bool) = TMP_51 || TMP_52,TMP_54(bool) = TMP_50 && TMP_53,CONDITION TMP_54,withdrawalAccount(address) := owner(address),TMP_55(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['highestBindingBid', 'oldPotato'] ,withdrawalAmount(uint256) := TMP_55(uint256),ownerHasWithdrawn(bool) := True(bool),REF_20(uint256) -> fundsByBidder[withdrawalAccount],REF_20(uint256) (->fundsByBidder) := 0(uint256),TMP_56 = UnaryType.BANG canceled ,TMP_57(bool) = msg.sender != highestBidder,TMP_58(bool) = msg.sender != owner,TMP_59(bool) = TMP_57 && TMP_58,TMP_60(bool) = TMP_56 && TMP_59,CONDITION TMP_60,withdrawalAccount(address) := msg.sender(address),REF_21(uint256) -> fundsByBidder[withdrawalAccount],withdrawalAmount(uint256) := REF_21(uint256),REF_22(uint256) -> fundsByBidder[withdrawalAccount],REF_22(uint256) (->fundsByBidder) := 0(uint256),TMP_61 = UnaryType.BANG canceled ,TMP_62(bool) = msg.sender == highestBidder,TMP_63(bool) = TMP_61 && TMP_62,TMP_64(bool) = msg.sender != owner,TMP_65(bool) = TMP_63 && TMP_64,CONDITION TMP_65,withdrawalAccount(address) := msg.sender(address),REF_23(uint256) -> fundsByBidder[withdrawalAccount],TMP_66(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_23', 'oldHighestBindingBid'] ,withdrawalAmount(uint256) := TMP_66(uint256),REF_25(uint256) -> fundsByBidder[withdrawalAccount],REF_26(uint256) -> fundsByBidder[withdrawalAccount],TMP_67(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_26', 'withdrawalAmount'] ,REF_25(uint256) (->fundsByBidder) := TMP_67(uint256),TMP_68(bool) = withdrawalAmount == 0,CONDITION TMP_68,TMP_69(None) = SOLIDITY_CALL revert()(),Transfer dest:msg.sender value:withdrawalAmount,Emit LogWithdrawal(msg.sender,withdrawalAccount,withdrawalAmount),blockerWithdraw(bool) := False(bool),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(blockerWithdraw == false)

IRs:
TMP_46(bool) = blockerWithdraw == False
TMP_47(None) = SOLIDITY_CALL require(bool)(TMP_46)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
blockerWithdraw = true

IRs:
blockerWithdraw(bool) := True(bool)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4
""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
canceled

IRs:
CONDITION canceled""];
5->6[label=""True""];
5->9[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
withdrawalAccount = msg.sender

IRs:
withdrawalAccount(address) := msg.sender(address)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
withdrawalAmount = fundsByBidder[withdrawalAccount]

IRs:
REF_17(uint256) -> fundsByBidder[withdrawalAccount]
withdrawalAmount(uint256) := REF_17(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
fundsByBidder[withdrawalAccount] = 0

IRs:
REF_18(uint256) -> fundsByBidder[withdrawalAccount]
REF_18(uint256) (->fundsByBidder) := 0(uint256)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: IF 10

EXPRESSION:
ownerHasWithdrawn == false && msg.sender == owner && (canceled == true || now > endTime)

IRs:
TMP_48(bool) = ownerHasWithdrawn == False
TMP_49(bool) = msg.sender == owner
TMP_50(bool) = TMP_48 && TMP_49
TMP_51(bool) = canceled == True
TMP_52(bool) = now > endTime
TMP_53(bool) = TMP_51 || TMP_52
TMP_54(bool) = TMP_50 && TMP_53
CONDITION TMP_54""];
10->11[label=""True""];
10->15[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
withdrawalAccount = owner

IRs:
withdrawalAccount(address) := owner(address)""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
withdrawalAmount = highestBindingBid.sub(oldPotato)

IRs:
TMP_55(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['highestBindingBid', 'oldPotato'] 
withdrawalAmount(uint256) := TMP_55(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
ownerHasWithdrawn = true

IRs:
ownerHasWithdrawn(bool) := True(bool)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
fundsByBidder[withdrawalAccount] = 0

IRs:
REF_20(uint256) -> fundsByBidder[withdrawalAccount]
REF_20(uint256) (->fundsByBidder) := 0(uint256)""];
14->15;
15[label=""Node Type: END_IF 15
""];
15->16;
16[label=""Node Type: IF 16

EXPRESSION:
! canceled && (msg.sender != highestBidder && msg.sender != owner)

IRs:
TMP_56 = UnaryType.BANG canceled 
TMP_57(bool) = msg.sender != highestBidder
TMP_58(bool) = msg.sender != owner
TMP_59(bool) = TMP_57 && TMP_58
TMP_60(bool) = TMP_56 && TMP_59
CONDITION TMP_60""];
16->17[label=""True""];
16->20[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
withdrawalAccount = msg.sender

IRs:
withdrawalAccount(address) := msg.sender(address)""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
withdrawalAmount = fundsByBidder[withdrawalAccount]

IRs:
REF_21(uint256) -> fundsByBidder[withdrawalAccount]
withdrawalAmount(uint256) := REF_21(uint256)""];
18->19;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
fundsByBidder[withdrawalAccount] = 0

IRs:
REF_22(uint256) -> fundsByBidder[withdrawalAccount]
REF_22(uint256) (->fundsByBidder) := 0(uint256)""];
19->20;
20[label=""Node Type: END_IF 20
""];
20->21;
21[label=""Node Type: IF 21

EXPRESSION:
! canceled && msg.sender == highestBidder && msg.sender != owner

IRs:
TMP_61 = UnaryType.BANG canceled 
TMP_62(bool) = msg.sender == highestBidder
TMP_63(bool) = TMP_61 && TMP_62
TMP_64(bool) = msg.sender != owner
TMP_65(bool) = TMP_63 && TMP_64
CONDITION TMP_65""];
21->22[label=""True""];
21->25[label=""False""];
22[label=""Node Type: EXPRESSION 22

EXPRESSION:
withdrawalAccount = msg.sender

IRs:
withdrawalAccount(address) := msg.sender(address)""];
22->23;
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
withdrawalAmount = fundsByBidder[withdrawalAccount].sub(oldHighestBindingBid)

IRs:
REF_23(uint256) -> fundsByBidder[withdrawalAccount]
TMP_66(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_23', 'oldHighestBindingBid'] 
withdrawalAmount(uint256) := TMP_66(uint256)""];
23->24;
24[label=""Node Type: EXPRESSION 24

EXPRESSION:
fundsByBidder[withdrawalAccount] = fundsByBidder[withdrawalAccount].sub(withdrawalAmount)

IRs:
REF_25(uint256) -> fundsByBidder[withdrawalAccount]
REF_26(uint256) -> fundsByBidder[withdrawalAccount]
TMP_67(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['REF_26', 'withdrawalAmount'] 
REF_25(uint256) (->fundsByBidder) := TMP_67(uint256)""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->26;
26[label=""Node Type: IF 26

EXPRESSION:
withdrawalAmount == 0

IRs:
TMP_68(bool) = withdrawalAmount == 0
CONDITION TMP_68""];
26->27[label=""True""];
26->28[label=""False""];
27[label=""Node Type: EXPRESSION 27

EXPRESSION:
revert()()

IRs:
TMP_69(None) = SOLIDITY_CALL revert()()""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
msg.sender.transfer(withdrawalAmount)

IRs:
Transfer dest:msg.sender value:withdrawalAmount""];
29->30;
30[label=""Node Type: EXPRESSION 30

EXPRESSION:
LogWithdrawal(msg.sender,withdrawalAccount,withdrawalAmount)

IRs:
Emit LogWithdrawal(msg.sender,withdrawalAccount,withdrawalAmount)""];
30->31;
31[label=""Node Type: EXPRESSION 31

EXPRESSION:
blockerWithdraw = false

IRs:
blockerWithdraw(bool) := False(bool)""];
31->32;
32[label=""Node Type: RETURN 32

EXPRESSION:
true

IRs:
RETURN True""];
33[label=""Node Type: RETURN 33

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,0,1,0,"require(bool)(blockerWithdraw == false);blockerWithdraw = true;;;canceled;withdrawalAccount = msg.sender;;withdrawalAmount = fundsByBidder[withdrawalAccount];fundsByBidder[withdrawalAccount] = 0;ownerHasWithdrawn == false && msg.sender == owner && (canceled == true || now > endTime);withdrawalAccount = owner;;withdrawalAmount = highestBindingBid.sub(oldPotato);ownerHasWithdrawn = true;fundsByBidder[withdrawalAccount] = 0;! canceled && (msg.sender != highestBidder && msg.sender != owner);withdrawalAccount = msg.sender;;withdrawalAmount = fundsByBidder[withdrawalAccount];fundsByBidder[withdrawalAccount] = 0;! canceled && msg.sender == highestBidder && msg.sender != owner;withdrawalAccount = msg.sender;;withdrawalAmount = fundsByBidder[withdrawalAccount].sub(oldHighestBindingBid);fundsByBidder[withdrawalAccount] = fundsByBidder[withdrawalAccount].sub(withdrawalAmount);withdrawalAmount == 0;revert()();;msg.sender.transfer(withdrawalAmount);LogWithdrawal(msg.sender,withdrawalAccount,withdrawalAmount);blockerWithdraw = false;true;success"
./0xb4a448387403554616eb5b50aa4c48f75243a015_ext.sol,Mobius2Dv2.withdrawDevShare,1297,1302,"TMP_1060(uint256) = INTERNAL_CALL, DSMath.sub(uint256,uint256)(devBalance,totalPaidOraclize),value(uint256) := TMP_1060(uint256),devBalance(uint256) := 0(uint256),totalPaidOraclize(uint256) := 0(uint256),Transfer dest:msg.sender value:value,MODIFIER_CALL, DSAuth.auth()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
value = sub(devBalance,totalPaidOraclize)

IRs:
TMP_1060(uint256) = INTERNAL_CALL, DSMath.sub(uint256,uint256)(devBalance,totalPaidOraclize)
value(uint256) := TMP_1060(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
devBalance = 0

IRs:
devBalance(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
totalPaidOraclize = 0

IRs:
totalPaidOraclize(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(value)

IRs:
Transfer dest:msg.sender value:value""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
auth()

IRs:
MODIFIER_CALL, DSAuth.auth()()""];
5->1;
}
",1,0,1,0,"auth();value = sub(devBalance,totalPaidOraclize);devBalance = 0;totalPaidOraclize = 0;msg.sender.transfer(value)"
./0x7012ef33dcc79a7341ba05cf2c5699eaaa5e0d7d_ext.sol,Transaction.sendAmount,236,243,"TMP_90(bool) = seller != 0,TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),TMP_92(bool) = msg.sender != seller,TMP_93(None) = SOLIDITY_CALL require(bool)(TMP_92),Transfer dest:seller value:msg.value","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(seller != 0x0)

IRs:
TMP_90(bool) = seller != 0
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender != seller)

IRs:
TMP_92(bool) = msg.sender != seller
TMP_93(None) = SOLIDITY_CALL require(bool)(TMP_92)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
seller.transfer(msg.value)

IRs:
Transfer dest:seller value:msg.value""];
}
",0,0,1,0,require(bool)(seller != 0x0);require(bool)(msg.sender != seller);seller.transfer(msg.value)
./0x6f5ac8fda08c00c38380777f00e265d4951b6f59_ext.sol,QUIZ.StopGame,29,32,"TMP_9(bool) = msg.sender == questionSender,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_9(bool) = msg.sender == questionSender
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0x728781e75735dc0962df3a51d7ef47e798a7107e_ext.sol,WolkExchange.fallback,629,638,"TMP_731(bool) = msg.value > 0,TMP_732(None) = SOLIDITY_CALL require(bool)(TMP_731),TMP_733 = UnaryType.BANG openSaleCompleted ,CONDITION TMP_733,HIGH_LEVEL_CALL, dest:this(address), function:tokenGenerationEvent, arguments:['msg.sender'] value:msg.value ,TMP_736(bool) = block.number >= end_block,CONDITION TMP_736,TMP_738(uint256) = HIGH_LEVEL_CALL, dest:this(address), function:purchaseWolk, arguments:['msg.sender'] value:msg.value ,TMP_739(None) = SOLIDITY_CALL revert()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value > 0)

IRs:
TMP_731(bool) = msg.value > 0
TMP_732(None) = SOLIDITY_CALL require(bool)(TMP_731)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
! openSaleCompleted

IRs:
TMP_733 = UnaryType.BANG openSaleCompleted 
CONDITION TMP_733""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
this.tokenGenerationEvent.value(msg.value)(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:this(address), function:tokenGenerationEvent, arguments:['msg.sender'] value:msg.value ""];
3->8;
4[label=""Node Type: IF 4

EXPRESSION:
block.number >= end_block

IRs:
TMP_736(bool) = block.number >= end_block
CONDITION TMP_736""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
this.purchaseWolk.value(msg.value)(msg.sender)

IRs:
TMP_738(uint256) = HIGH_LEVEL_CALL, dest:this(address), function:purchaseWolk, arguments:['msg.sender'] value:msg.value ""];
5->7;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
revert()()

IRs:
TMP_739(None) = SOLIDITY_CALL revert()()""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: END_IF 8
""];
}
",0,0,1,0,require(bool)(msg.value > 0);! openSaleCompleted;this.tokenGenerationEvent.value(msg.value)(msg.sender);block.number >= end_block;;this.purchaseWolk.value(msg.value)(msg.sender);revert()();
./0x6a5e59fbaea3e07737fbafceb600cbde5a295f24_ext.sol,RefundEscrow.beneficiaryWithdraw,869,872,"REF_143(RefundEscrow.State) -> State.Closed,TMP_341(bool) = state == REF_143,TMP_342(None) = SOLIDITY_CALL require(bool)(TMP_341),TMP_343 = CONVERT this to address,TMP_344(uint256) = SOLIDITY_CALL balance(address)(TMP_343),Transfer dest:beneficiary value:TMP_344","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Closed)

IRs:
REF_143(RefundEscrow.State) -> State.Closed
TMP_341(bool) = state == REF_143
TMP_342(None) = SOLIDITY_CALL require(bool)(TMP_341)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
beneficiary.transfer(address(this).balance)

IRs:
TMP_343 = CONVERT this to address
TMP_344(uint256) = SOLIDITY_CALL balance(address)(TMP_343)
Transfer dest:beneficiary value:TMP_344""];
}
",0,0,1,0,require(bool)(state == State.Closed);beneficiary.transfer(address(this).balance)
./0xdb209c97e0de799bbf14e3377307780ddc26be4e_ext.sol,DarkPay.withdraw,298,301,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, DarkPay.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, DarkPay.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x83d3abc4e75885db350ace57f99c3a3e00286fe8_ext.sol,BetaCoin.withdraw,214,218,"REF_92(uint256) = SOLIDITY_CALL balance(address)(this),etherBalance(uint256) := REF_92([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E2536FD0>]),owner(address) := msg.sender(address),Transfer dest:owner value:etherBalance,MODIFIER_CALL, BetaCoin.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
etherBalance = this.balance

IRs:
REF_92(uint256) = SOLIDITY_CALL balance(address)(this)
etherBalance(uint256) := REF_92([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E2536FD0>])""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
owner = msg.sender

IRs:
owner(address) := msg.sender(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(etherBalance)

IRs:
Transfer dest:owner value:etherBalance""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, BetaCoin.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();etherBalance = this.balance;owner = msg.sender;owner.transfer(etherBalance)
./0x290d7f8b8d7da1e92903405a74667c934ca8f086_ext.sol,Wallet.withdrawTo,46,54,"TMP_10(bool) = INTERNAL_CALL, Wallet.WithdrawalEnabled()(),CONDITION TMP_10,REF_1(uint256) -> Deposits[msg.sender],max(uint256) := REF_1(uint256),TMP_11(bool) = max > 0,TMP_12(bool) = amount <= max,TMP_13(bool) = TMP_11 && TMP_12,CONDITION TMP_13,Transfer dest:to value:amount,Emit Withdrawal(to,amount),MODIFIER_CALL, Wallet.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: IF 1

EXPRESSION:
WithdrawalEnabled()

IRs:
TMP_10(bool) = INTERNAL_CALL, Wallet.WithdrawalEnabled()()
CONDITION TMP_10""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
max = Deposits[msg.sender]

IRs:
REF_1(uint256) -> Deposits[msg.sender]
max(uint256) := REF_1(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
max > 0 && amount <= max

IRs:
TMP_11(bool) = max > 0
TMP_12(bool) = amount <= max
TMP_13(bool) = TMP_11 && TMP_12
CONDITION TMP_13""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
to.transfer(amount)

IRs:
Transfer dest:to value:amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Withdrawal(to,amount)

IRs:
Emit Withdrawal(to,amount)""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: END_IF 7
""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Wallet.onlyOwner()()""];
8->1;
}
",0,0,1,0,"onlyOwner();WithdrawalEnabled();max = Deposits[msg.sender];;max > 0 && amount <= max;to.transfer(amount);;Withdrawal(to,amount)"
./0x508404d6f5342b4a11a08e8be3f9bb2ddbdc189f_ext.sol,EtherItem23._payout,434,440,"TMP_135 = CONVERT 0 to address,TMP_136(bool) = _to == TMP_135,CONDITION TMP_136,REF_52(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:ceoAddress value:REF_52,REF_54(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:_to value:REF_54","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_to == address(0)

IRs:
TMP_135 = CONVERT 0 to address
TMP_136(bool) = _to == TMP_135
CONDITION TMP_136""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ceoAddress.transfer(this.balance)

IRs:
REF_52(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:ceoAddress value:REF_52""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_to.transfer(this.balance)

IRs:
REF_54(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:_to value:REF_54""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,_to == address(0);ceoAddress.transfer(this.balance);_to.transfer(this.balance);
./0xd7b45e0cdae4c65ef2c7e19152eeb3074e20f98f_ext.sol,Owned.kill,32,34,"TMP_0(None) = SOLIDITY_CALL selfdestruct(address)(_owner),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(_owner)

IRs:
TMP_0(None) = SOLIDITY_CALL selfdestruct(address)(_owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(_owner)
./0x0174312e4aef436606ffdeb4d05d22fb68f36ba0_ext.sol,LatiumSeller.withdrawEther,106,114,"TMP_35(bool) = _amount == 0,CONDITION TMP_35,_amount(uint256) := _etherAmount(uint256),TMP_36(bool) = _amount > 0,TMP_37(bool) = _etherAmount >= _amount,TMP_38(bool) = TMP_36 && TMP_37,TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38),_etherAmount(uint256) = _etherAmount - _amount,Transfer dest:msg.sender value:_amount,MODIFIER_CALL, LatiumSeller.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->7;
1[label=""Node Type: IF 1

EXPRESSION:
_amount == 0

IRs:
TMP_35(bool) = _amount == 0
CONDITION TMP_35""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_amount = _etherAmount

IRs:
_amount(uint256) := _etherAmount(uint256)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_amount > 0 && _etherAmount >= _amount)

IRs:
TMP_36(bool) = _amount > 0
TMP_37(bool) = _etherAmount >= _amount
TMP_38(bool) = TMP_36 && TMP_37
TMP_39(None) = SOLIDITY_CALL require(bool)(TMP_38)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_etherAmount -= _amount

IRs:
_etherAmount(uint256) = _etherAmount - _amount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
msg.sender.transfer(_amount)

IRs:
Transfer dest:msg.sender value:_amount""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, LatiumSeller.onlyOwner()()""];
7->1;
}
",0,0,1,0,onlyOwner();_amount == 0;_amount = _etherAmount;;require(bool)(_amount > 0 && _etherAmount >= _amount);_etherAmount -= _amount;msg.sender.transfer(_amount)
./0xed42398a3df99e482039c2aec8000dba75296ee9_ext.sol,enigma.StopGame,32,35,"TMP_10(bool) = msg.sender == questionSender,TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_10(bool) = msg.sender == questionSender
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0x744a31ede5422355d9c2bd8c44c710404336ca84_ext.sol,NFTsCrowdsaleBase._payByEth,766,783,"_ethAmount(uint256) := msg.value(uint256),REF_57(NFTsCrowdsaleBase.Auction) -> tokenIdToAuction[_tokenId],_auction(NFTsCrowdsaleBase.Auction) := REF_57(NFTsCrowdsaleBase.Auction),REF_58(uint256) -> _auction.price,price(uint256) := REF_58(uint256),REF_59(uint256) -> _auction.tokenId,TMP_133(bool) = INTERNAL_CALL, NFTsCrowdsaleBase._isOnAuction(uint256)(REF_59),TMP_134(None) = SOLIDITY_CALL require(bool)(TMP_133),TMP_135(bool) = _ethAmount >= price,TMP_136(None) = SOLIDITY_CALL require(bool)(TMP_135),TMP_137(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_ethAmount', 'price'] ,payExcess(uint256) := TMP_137(uint256),TMP_138(bool) = price > 0,CONDITION TMP_138,REF_61(address) -> _auction.seller,Transfer dest:REF_61 value:price,buyer(address) := msg.sender(address),Transfer dest:buyer value:payExcess,INTERNAL_CALL, NFTsCrowdsaleBase._transfer(address,uint256)(buyer,_tokenId),REF_64(bytes32) -> _auction.id,REF_65(address) -> _auction.seller,REF_66(uint256) -> _auction.price,REF_67(uint256) -> _auction.endAt,REF_68(uint256) -> _auction.tokenId,Emit PayByEth(REF_64,REF_65,msg.sender,REF_66,REF_67,REF_68),REF_69(NFTsCrowdsaleBase.Auction) -> tokenIdToAuction[_tokenId],tokenIdToAuction = delete REF_69 ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_ethAmount = msg.value

IRs:
_ethAmount(uint256) := msg.value(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
_auction = tokenIdToAuction[_tokenId]

IRs:
REF_57(NFTsCrowdsaleBase.Auction) -> tokenIdToAuction[_tokenId]
_auction(NFTsCrowdsaleBase.Auction) := REF_57(NFTsCrowdsaleBase.Auction)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
price = _auction.price

IRs:
REF_58(uint256) -> _auction.price
price(uint256) := REF_58(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(_isOnAuction(_auction.tokenId))

IRs:
REF_59(uint256) -> _auction.tokenId
TMP_133(bool) = INTERNAL_CALL, NFTsCrowdsaleBase._isOnAuction(uint256)(REF_59)
TMP_134(None) = SOLIDITY_CALL require(bool)(TMP_133)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(_ethAmount >= price)

IRs:
TMP_135(bool) = _ethAmount >= price
TMP_136(None) = SOLIDITY_CALL require(bool)(TMP_135)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
payExcess = _ethAmount.sub(price)

IRs:
TMP_137(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['_ethAmount', 'price'] 
payExcess(uint256) := TMP_137(uint256)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
price > 0

IRs:
TMP_138(bool) = price > 0
CONDITION TMP_138""];
7->8[label=""True""];
7->9[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
_auction.seller.transfer(price)

IRs:
REF_61(address) -> _auction.seller
Transfer dest:REF_61 value:price""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: NEW VARIABLE 10

EXPRESSION:
buyer = msg.sender

IRs:
buyer(address) := msg.sender(address)""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
buyer.transfer(payExcess)

IRs:
Transfer dest:buyer value:payExcess""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
_transfer(buyer,_tokenId)

IRs:
INTERNAL_CALL, NFTsCrowdsaleBase._transfer(address,uint256)(buyer,_tokenId)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
PayByEth(_auction.id,_auction.seller,msg.sender,_auction.price,_auction.endAt,_auction.tokenId)

IRs:
REF_64(bytes32) -> _auction.id
REF_65(address) -> _auction.seller
REF_66(uint256) -> _auction.price
REF_67(uint256) -> _auction.endAt
REF_68(uint256) -> _auction.tokenId
Emit PayByEth(REF_64,REF_65,msg.sender,REF_66,REF_67,REF_68)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
delete tokenIdToAuction[_tokenId]

IRs:
REF_69(NFTsCrowdsaleBase.Auction) -> tokenIdToAuction[_tokenId]
tokenIdToAuction = delete REF_69 ""];
}
",0,0,1,0,"_ethAmount = msg.value;_auction = tokenIdToAuction[_tokenId];price = _auction.price;require(bool)(_isOnAuction(_auction.tokenId));require(bool)(_ethAmount >= price);payExcess = _ethAmount.sub(price);price > 0;_auction.seller.transfer(price);;buyer = msg.sender;buyer.transfer(payExcess);_transfer(buyer,_tokenId);PayByEth(_auction.id,_auction.seller,msg.sender,_auction.price,_auction.endAt,_auction.tokenId);delete tokenIdToAuction[_tokenId]"
./0xbf2000b42c1ba2eb9e5163a0b7e2fe987ed124b4_ext.sol,SeedCrowdsaleContract.processTransaction,211,239,"TMP_59(uint256) = INTERNAL_CALL, SeedCrowdsaleContract.calculateMaxContribution(address)(_contributor),maxContribution(uint256) := TMP_59(uint256),contributionAmount(uint256) := _amount(uint256),returnAmount(uint256) := 0(uint256),TMP_60(bool) = maxContribution < _amount,CONDITION TMP_60,contributionAmount(uint256) := maxContribution(uint256),TMP_61(uint256) = _amount - maxContribution,returnAmount(uint256) := TMP_61(uint256),TMP_62(uint256) = ethRaised + contributionAmount,TMP_63(bool) = TMP_62 >= minCap,TMP_64(bool) = minCap > ethRaised,TMP_65(bool) = TMP_63 && TMP_64,CONDITION TMP_65,Emit MinCapReached(block.timestamp),REF_18(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor],REF_19(uint256) -> REF_18.contributionAmount,TMP_67(bool) = REF_19 == 0,CONDITION TMP_67,REF_20(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor],REF_21(uint256) -> REF_20.contributionAmount,REF_21(uint256) (->contributorList) := contributionAmount(uint256),REF_22(address) -> contributorIndexes[nextContributorIndex],REF_22(address) (->contributorIndexes) := _contributor(address),TMP_68(uint256) := nextContributorIndex(uint256),nextContributorIndex(uint256) = nextContributorIndex + 1,REF_23(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor],REF_24(uint256) -> REF_23.contributionAmount,REF_24(-> contributorList) = REF_24 + contributionAmount,ethRaised(uint256) = ethRaised + contributionAmount,Emit ContributionMade(msg.sender,contributionAmount),TMP_70(bool) = returnAmount != 0,CONDITION TMP_70,Transfer dest:_contributor value:returnAmount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
maxContribution = calculateMaxContribution(_contributor)

IRs:
TMP_59(uint256) = INTERNAL_CALL, SeedCrowdsaleContract.calculateMaxContribution(address)(_contributor)
maxContribution(uint256) := TMP_59(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
contributionAmount = _amount

IRs:
contributionAmount(uint256) := _amount(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
returnAmount = 0

IRs:
returnAmount(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
maxContribution < _amount

IRs:
TMP_60(bool) = maxContribution < _amount
CONDITION TMP_60""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
contributionAmount = maxContribution

IRs:
contributionAmount(uint256) := maxContribution(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
returnAmount = _amount - maxContribution

IRs:
TMP_61(uint256) = _amount - maxContribution
returnAmount(uint256) := TMP_61(uint256)""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: IF 8

EXPRESSION:
ethRaised + contributionAmount >= minCap && minCap > ethRaised

IRs:
TMP_62(uint256) = ethRaised + contributionAmount
TMP_63(bool) = TMP_62 >= minCap
TMP_64(bool) = minCap > ethRaised
TMP_65(bool) = TMP_63 && TMP_64
CONDITION TMP_65""];
8->9[label=""True""];
8->10[label=""False""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
MinCapReached(block.timestamp)

IRs:
Emit MinCapReached(block.timestamp)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
contributorList[_contributor].contributionAmount == 0

IRs:
REF_18(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor]
REF_19(uint256) -> REF_18.contributionAmount
TMP_67(bool) = REF_19 == 0
CONDITION TMP_67""];
11->12[label=""True""];
11->15[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
contributorList[_contributor].contributionAmount = contributionAmount

IRs:
REF_20(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor]
REF_21(uint256) -> REF_20.contributionAmount
REF_21(uint256) (->contributorList) := contributionAmount(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
contributorIndexes[nextContributorIndex] = _contributor

IRs:
REF_22(address) -> contributorIndexes[nextContributorIndex]
REF_22(address) (->contributorIndexes) := _contributor(address)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
nextContributorIndex ++

IRs:
TMP_68(uint256) := nextContributorIndex(uint256)
nextContributorIndex(uint256) = nextContributorIndex + 1""];
14->16;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
contributorList[_contributor].contributionAmount += contributionAmount

IRs:
REF_23(SeedCrowdsaleContract.ContributorData) -> contributorList[_contributor]
REF_24(uint256) -> REF_23.contributionAmount
REF_24(-> contributorList) = REF_24 + contributionAmount""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
ethRaised += contributionAmount

IRs:
ethRaised(uint256) = ethRaised + contributionAmount""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
ContributionMade(msg.sender,contributionAmount)

IRs:
Emit ContributionMade(msg.sender,contributionAmount)""];
18->19;
19[label=""Node Type: IF 19

EXPRESSION:
returnAmount != 0

IRs:
TMP_70(bool) = returnAmount != 0
CONDITION TMP_70""];
19->20[label=""True""];
19->21[label=""False""];
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
_contributor.transfer(returnAmount)

IRs:
Transfer dest:_contributor value:returnAmount""];
20->21;
21[label=""Node Type: END_IF 21
""];
}
",0,1,1,0,"maxContribution = calculateMaxContribution(_contributor);contributionAmount = _amount;returnAmount = 0;maxContribution < _amount;contributionAmount = maxContribution;;returnAmount = _amount - maxContribution;ethRaised + contributionAmount >= minCap && minCap > ethRaised;MinCapReached(block.timestamp);;contributorList[_contributor].contributionAmount == 0;contributorList[_contributor].contributionAmount = contributionAmount;contributorList[_contributor].contributionAmount += contributionAmount;contributorIndexes[nextContributorIndex] = _contributor;nextContributorIndex ++;;ethRaised += contributionAmount;ContributionMade(msg.sender,contributionAmount);returnAmount != 0;_contributor.transfer(returnAmount);"
./0xdc8d902c34f2257b8569dc9bc4f58cc149ed6e48_ext.sol,GitmanIssue.recall,24,27,"TMP_3(bool) = msg.sender == mediator,TMP_4(None) = SOLIDITY_CALL require(bool,string)(TMP_3,sender not authorized),TMP_5(None) = SOLIDITY_CALL selfdestruct(address)(parent)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool,string)(msg.sender == mediator,sender not authorized)

IRs:
TMP_3(bool) = msg.sender == mediator
TMP_4(None) = SOLIDITY_CALL require(bool,string)(TMP_3,sender not authorized)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(parent)

IRs:
TMP_5(None) = SOLIDITY_CALL selfdestruct(address)(parent)""];
}
",0,0,1,0,"require(bool,string)(msg.sender == mediator,sender not authorized);selfdestruct(address)(parent)"
./0x03eff7f353aeebea3ac5f23a6e9e844581ff5ef8_ext.sol,PLAY_iQuiz.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 2000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 2000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 2000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 2000000000000000000;msg.sender.transfer(this.balance);
./0x658b3573f8222c2d792ff1199933a88680b12973_ext.sol,AccessService.withdraw,104,116,"TMP_37(bool) = msg.sender == addrFinance,TMP_38(bool) = msg.sender == addrAdmin,TMP_39(bool) = TMP_37 || TMP_38,TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39),TMP_41(bool) = _amount > 0,TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41),REF_0(uint256) = SOLIDITY_CALL balance(address)(this),balance(uint256) := REF_0([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B9A41C10>]),TMP_43(bool) = _amount < balance,CONDITION TMP_43,Transfer dest:receiver value:_amount,REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:receiver value:REF_3,TMP_46 = CONVERT 0 to address,TMP_47(bool) = _target == TMP_46,CONDITION TMP_47,receiver(address) := addrFinance(address),receiver(address) := _target(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == addrFinance || msg.sender == addrAdmin)

IRs:
TMP_37(bool) = msg.sender == addrFinance
TMP_38(bool) = msg.sender == addrAdmin
TMP_39(bool) = TMP_37 || TMP_38
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amount > 0)

IRs:
TMP_41(bool) = _amount > 0
TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)""];
2->9;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
balance = this.balance

IRs:
REF_0(uint256) = SOLIDITY_CALL balance(address)(this)
balance(uint256) := REF_0([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B9A41C10>])""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
_amount < balance

IRs:
TMP_43(bool) = _amount < balance
CONDITION TMP_43""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
receiver.transfer(_amount)

IRs:
Transfer dest:receiver value:_amount""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
receiver.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:receiver value:REF_3""];
7->8;
8[label=""Node Type: END_IF 8
""];
9[label=""Node Type: IF 9

EXPRESSION:
_target == address(0)

IRs:
TMP_46 = CONVERT 0 to address
TMP_47(bool) = _target == TMP_46
CONDITION TMP_47""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
receiver = addrFinance

IRs:
receiver(address) := addrFinance(address)""];
10->12;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
receiver = _target

IRs:
receiver(address) := _target(address)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->4;
}
",0,0,1,0,require(bool)(msg.sender == addrFinance || msg.sender == addrAdmin);require(bool)(_amount > 0);_target == address(0);balance = this.balance;_amount < balance;receiver.transfer(_amount);receiver.transfer(this.balance);;receiver = addrFinance;receiver = _target;
./0x845581267b3ffcde72a1a98efcffee48cb9ae0de_ext.sol,ENIGMA_X.Stop,28,30,"REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3,MODIFIER_CALL, ENIGMA_X.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, ENIGMA_X.isAdmin()()""];
2->1;
}
",0,0,1,0,isAdmin();msg.sender.transfer(this.balance)
./0xece0429a5130ebe0616363939067eefca4fbaceb_ext.sol,MiniMeToken.fallback,529,532,"TMP_126(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller),TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126),TMP_128 = CONVERT controller to TokenController,TMP_130(bool) = HIGH_LEVEL_CALL, dest:TMP_128(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value ,TMP_131(None) = SOLIDITY_CALL require(bool)(TMP_130)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(isContract(controller))

IRs:
TMP_126(bool) = INTERNAL_CALL, MiniMeToken.isContract(address)(controller)
TMP_127(None) = SOLIDITY_CALL require(bool)(TMP_126)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))

IRs:
TMP_128 = CONVERT controller to TokenController
TMP_130(bool) = HIGH_LEVEL_CALL, dest:TMP_128(TokenController), function:proxyPayment, arguments:['msg.sender'] value:msg.value 
TMP_131(None) = SOLIDITY_CALL require(bool)(TMP_130)""];
}
",0,0,1,0,require(bool)(isContract(controller));require(bool)(TokenController(controller).proxyPayment.value(msg.value)(msg.sender))
./0xd14b221dfb7c7a4d19d464e41affe3e2e182c90e_ext.sol,TokenTrader.takerBuyAsset,506,532,"TMP_288(bool) = msg.sender == owner,TMP_289(bool) = sellsTokens || TMP_288,CONDITION TMP_289,TMP_290 = CONVERT exchange to ERC20,TMP_291(bool) = HIGH_LEVEL_CALL, dest:TMP_290(ERC20), function:approve, arguments:['baseowner', 'exchFee']  ,TMP_292(None) = SOLIDITY_CALL require(bool)(TMP_291),TMP_293 = CONVERT exchange to ERC20,TMP_294(bool) = HIGH_LEVEL_CALL, dest:TMP_293(ERC20), function:transfer, arguments:['baseowner', 'exchFee']  ,TMP_295(None) = SOLIDITY_CALL require(bool)(TMP_294),TMP_296(uint256) = msg.value / sellPrice,order(uint256) := TMP_296(uint256),TMP_297 = CONVERT asset to ERC20,TMP_298 = CONVERT this to address,TMP_299(uint256) = HIGH_LEVEL_CALL, dest:TMP_297(ERC20), function:balanceOf, arguments:['TMP_298']  ,TMP_300(uint256) = TMP_299 / units,can_sell(uint256) := TMP_300(uint256),change(uint256) := 0(uint256),TMP_301(uint256) = can_sell * sellPrice,TMP_302(bool) = msg.value > TMP_301,CONDITION TMP_302,TMP_303(uint256) = can_sell * sellPrice,TMP_304(uint256) = msg.value - TMP_303,change(uint256) := TMP_304(uint256),order(uint256) := can_sell(uint256),TMP_305(bool) = change > 0,CONDITION TMP_305,TMP_306 = SEND dest:msg.sender value:change,TMP_307(None) = SOLIDITY_CALL require(bool)(TMP_306),TMP_308(bool) = order > 0,CONDITION TMP_308,TMP_309 = CONVERT asset to ERC20,TMP_310(uint256) = order * units,TMP_311(bool) = HIGH_LEVEL_CALL, dest:TMP_309(ERC20), function:approve, arguments:['msg.sender', 'TMP_310']  ,TMP_312(None) = SOLIDITY_CALL require(bool)(TMP_311),TMP_313 = CONVERT asset to ERC20,TMP_314(uint256) = order * units,TMP_315(bool) = HIGH_LEVEL_CALL, dest:TMP_313(ERC20), function:transfer, arguments:['msg.sender', 'TMP_314']  ,TMP_316(None) = SOLIDITY_CALL require(bool)(TMP_315),TMP_317(uint256) = order * units,Emit TakerBoughtAsset(msg.sender,msg.value,change,TMP_317),TMP_319 = SEND dest:msg.sender value:msg.value,TMP_320(None) = SOLIDITY_CALL require(bool)(TMP_319)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
sellsTokens || msg.sender == owner

IRs:
TMP_288(bool) = msg.sender == owner
TMP_289(bool) = sellsTokens || TMP_288
CONDITION TMP_289""];
1->2[label=""True""];
1->19[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(ERC20(exchange).approve(baseowner,exchFee))

IRs:
TMP_290 = CONVERT exchange to ERC20
TMP_291(bool) = HIGH_LEVEL_CALL, dest:TMP_290(ERC20), function:approve, arguments:['baseowner', 'exchFee']  
TMP_292(None) = SOLIDITY_CALL require(bool)(TMP_291)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(ERC20(exchange).transfer(baseowner,exchFee))

IRs:
TMP_293 = CONVERT exchange to ERC20
TMP_294(bool) = HIGH_LEVEL_CALL, dest:TMP_293(ERC20), function:transfer, arguments:['baseowner', 'exchFee']  
TMP_295(None) = SOLIDITY_CALL require(bool)(TMP_294)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
order = msg.value / sellPrice

IRs:
TMP_296(uint256) = msg.value / sellPrice
order(uint256) := TMP_296(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
can_sell = ERC20(asset).balanceOf(address(this)) / units

IRs:
TMP_297 = CONVERT asset to ERC20
TMP_298 = CONVERT this to address
TMP_299(uint256) = HIGH_LEVEL_CALL, dest:TMP_297(ERC20), function:balanceOf, arguments:['TMP_298']  
TMP_300(uint256) = TMP_299 / units
can_sell(uint256) := TMP_300(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
change = 0

IRs:
change(uint256) := 0(uint256)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
msg.value > (can_sell * sellPrice)

IRs:
TMP_301(uint256) = can_sell * sellPrice
TMP_302(bool) = msg.value > TMP_301
CONDITION TMP_302""];
7->8[label=""True""];
7->10[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
change = msg.value - (can_sell * sellPrice)

IRs:
TMP_303(uint256) = can_sell * sellPrice
TMP_304(uint256) = msg.value - TMP_303
change(uint256) := TMP_304(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
order = can_sell

IRs:
order(uint256) := can_sell(uint256)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: IF 11

EXPRESSION:
change > 0

IRs:
TMP_305(bool) = change > 0
CONDITION TMP_305""];
11->12[label=""True""];
11->13[label=""False""];
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
require(bool)(msg.sender.send(change))

IRs:
TMP_306 = SEND dest:msg.sender value:change
TMP_307(None) = SOLIDITY_CALL require(bool)(TMP_306)""];
12->13;
13[label=""Node Type: END_IF 13
""];
13->14;
14[label=""Node Type: IF 14

EXPRESSION:
order > 0

IRs:
TMP_308(bool) = order > 0
CONDITION TMP_308""];
14->15[label=""True""];
14->17[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
require(bool)(ERC20(asset).approve(msg.sender,order * units))

IRs:
TMP_309 = CONVERT asset to ERC20
TMP_310(uint256) = order * units
TMP_311(bool) = HIGH_LEVEL_CALL, dest:TMP_309(ERC20), function:approve, arguments:['msg.sender', 'TMP_310']  
TMP_312(None) = SOLIDITY_CALL require(bool)(TMP_311)""];
15->16;
16[label=""Node Type: EXPRESSION 16

EXPRESSION:
require(bool)(ERC20(asset).transfer(msg.sender,order * units))

IRs:
TMP_313 = CONVERT asset to ERC20
TMP_314(uint256) = order * units
TMP_315(bool) = HIGH_LEVEL_CALL, dest:TMP_313(ERC20), function:transfer, arguments:['msg.sender', 'TMP_314']  
TMP_316(None) = SOLIDITY_CALL require(bool)(TMP_315)""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
TakerBoughtAsset(msg.sender,msg.value,change,order * units)

IRs:
TMP_317(uint256) = order * units
Emit TakerBoughtAsset(msg.sender,msg.value,change,TMP_317)""];
18->20;
19[label=""Node Type: EXPRESSION 19

EXPRESSION:
require(bool)(msg.sender.send(msg.value))

IRs:
TMP_319 = SEND dest:msg.sender value:msg.value
TMP_320(None) = SOLIDITY_CALL require(bool)(TMP_319)""];
19->20;
20[label=""Node Type: END_IF 20
""];
}
",0,0,1,0,"sellsTokens || msg.sender == owner;require(bool)(ERC20(exchange).approve(baseowner,exchFee));require(bool)(msg.sender.send(msg.value));require(bool)(ERC20(exchange).transfer(baseowner,exchFee));order = msg.value / sellPrice;can_sell = ERC20(asset).balanceOf(address(this)) / units;change = 0;msg.value > (can_sell * sellPrice);change = msg.value - (can_sell * sellPrice);;order = can_sell;change > 0;require(bool)(msg.sender.send(change));;order > 0;require(bool)(ERC20(asset).approve(msg.sender,order * units));;require(bool)(ERC20(asset).transfer(msg.sender,order * units));TakerBoughtAsset(msg.sender,msg.value,change,order * units);"
./0x1eafd303c88b6cd638c77b40596de3dcf001b249_ext.sol,NoOwnerEx.reclaimEther,450,452,"TMP_178 = CONVERT this to address,TMP_179(uint256) = SOLIDITY_CALL balance(address)(TMP_178),Transfer dest:owner value:TMP_179,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_178 = CONVERT this to address
TMP_179(uint256) = SOLIDITY_CALL balance(address)(TMP_178)
Transfer dest:owner value:TMP_179""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();owner.transfer(address(this).balance)
./0xc336e10dee4cab01248cf3b1747b52d78394c77a_ext.sol,HoardPresale.refund,279,289,"TMP_72(bool) = now > freezeEndsAt,REF_27(uint256) -> balances[msg.sender],TMP_73(bool) = REF_27 > 0,TMP_74(bool) = TMP_72 && TMP_73,TMP_75(None) = SOLIDITY_CALL require(bool)(TMP_74),investor(address) := msg.sender(address),REF_28(uint256) -> balances[investor],amount(uint256) := REF_28(uint256),REF_29(uint256) -> balances[investor],balances = delete REF_29 ,Emit Refunded(investor,amount),Transfer dest:investor value:amount","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(now > freezeEndsAt && balances[msg.sender] > 0)

IRs:
TMP_72(bool) = now > freezeEndsAt
REF_27(uint256) -> balances[msg.sender]
TMP_73(bool) = REF_27 > 0
TMP_74(bool) = TMP_72 && TMP_73
TMP_75(None) = SOLIDITY_CALL require(bool)(TMP_74)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
amount = balances[investor]

IRs:
REF_28(uint256) -> balances[investor]
amount(uint256) := REF_28(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
delete balances[investor]

IRs:
REF_29(uint256) -> balances[investor]
balances = delete REF_29 ""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Refunded(investor,amount)

IRs:
Emit Refunded(investor,amount)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
investor.transfer(amount)

IRs:
Transfer dest:investor value:amount""];
}
",0,0,1,0,"require(bool)(now > freezeEndsAt && balances[msg.sender] > 0);investor = msg.sender;amount = balances[investor];delete balances[investor];Refunded(investor,amount);investor.transfer(amount)"
./0x29c690419841e126b74981e4709e43916ac80f64_ext.sol,QQ_game.Try,5,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x6c221dea36d48512947bde8aeb58811db50dbf6f_ext.sol,PartnerContract.fallback,5,13,"TMP_0(bool) = msg.value == 0,CONDITION TMP_0,TMP_1 = CONVERT this to address,TMP_2(uint256) = SOLIDITY_CALL balance(address)(TMP_1),TMP_3(uint256) = TMP_2 / 2,part(uint256) := TMP_3(uint256),TMP_4 = CONVERT 613321645410999227670522552720290887435007262704 to address,Transfer dest:TMP_4 value:part,TMP_6 = CONVERT 1282364471683990131757065389931317769167705180884 to address,Transfer dest:TMP_6 value:part","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.value == 0

IRs:
TMP_0(bool) = msg.value == 0
CONDITION TMP_0""];
1->2[label=""True""];
1->5[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
part = address(this).balance / 2

IRs:
TMP_1 = CONVERT this to address
TMP_2(uint256) = SOLIDITY_CALL balance(address)(TMP_1)
TMP_3(uint256) = TMP_2 / 2
part(uint256) := TMP_3(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
address(0x6B6e4B338b4D5f7D847DaB5492106751C57b7Ff0).transfer(part)

IRs:
TMP_4 = CONVERT 613321645410999227670522552720290887435007262704 to address
Transfer dest:TMP_4 value:part""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
address(0xe09f3630663B6b86e82D750b00206f8F8C6F8aD4).transfer(part)

IRs:
TMP_6 = CONVERT 1282364471683990131757065389931317769167705180884 to address
Transfer dest:TMP_6 value:part""];
4->5;
5[label=""Node Type: END_IF 5
""];
}
",0,0,1,0,msg.value == 0;part = address(this).balance / 2;;address(0x6B6e4B338b4D5f7D847DaB5492106751C57b7Ff0).transfer(part);address(0xe09f3630663B6b86e82D750b00206f8F8C6F8aD4).transfer(part)
./0x330bebabc9a2a4136e3d1cb38ca521f5a95aec2e_ext.sol,KoreaShow.doPayment,580,597,"TMP_147(bool) = msg.value >= 1000000000000000000,TMP_148(bool) = msg.value <= 3000000000000000000,TMP_149(bool) = TMP_147 && TMP_148,TMP_150(None) = SOLIDITY_CALL require(bool)(TMP_149),TMP_151(bool) = endFundingTime > now,TMP_152(None) = SOLIDITY_CALL require(bool)(TMP_151),TMP_153(bool) = totalCollected < maximumFunding,TMP_154(None) = SOLIDITY_CALL require(bool)(TMP_153),TMP_155(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalCollected', 'msg.value'] ,totalCollected(uint256) := TMP_155(uint256),TMP_156 = SEND dest:vaultAddress value:msg.value,TMP_157(None) = SOLIDITY_CALL require(bool)(TMP_156),TMP_158(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEther', 'msg.value'] ,tokenValue(uint256) := TMP_158(uint256),TMP_159(bool) = HIGH_LEVEL_CALL, dest:tokenContract(Token), function:generateTokens, arguments:['_owner', 'tokenValue']  ,TMP_160(None) = SOLIDITY_CALL require(bool)(TMP_159),Emit Payment(_owner,msg.value,tokenValue),RETURN True,RETURN success","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.value >= 1000000000000000000 && msg.value <= 3000000000000000000)

IRs:
TMP_147(bool) = msg.value >= 1000000000000000000
TMP_148(bool) = msg.value <= 3000000000000000000
TMP_149(bool) = TMP_147 && TMP_148
TMP_150(None) = SOLIDITY_CALL require(bool)(TMP_149)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(endFundingTime > now)

IRs:
TMP_151(bool) = endFundingTime > now
TMP_152(None) = SOLIDITY_CALL require(bool)(TMP_151)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(totalCollected < maximumFunding)

IRs:
TMP_153(bool) = totalCollected < maximumFunding
TMP_154(None) = SOLIDITY_CALL require(bool)(TMP_153)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
totalCollected = totalCollected.add(msg.value)

IRs:
TMP_155(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['totalCollected', 'msg.value'] 
totalCollected(uint256) := TMP_155(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(vaultAddress.send(msg.value))

IRs:
TMP_156 = SEND dest:vaultAddress value:msg.value
TMP_157(None) = SOLIDITY_CALL require(bool)(TMP_156)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
tokenValue = tokensPerEther.mul(msg.value)

IRs:
TMP_158(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEther', 'msg.value'] 
tokenValue(uint256) := TMP_158(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
require(bool)(tokenContract.generateTokens(_owner,tokenValue))

IRs:
TMP_159(bool) = HIGH_LEVEL_CALL, dest:tokenContract(Token), function:generateTokens, arguments:['_owner', 'tokenValue']  
TMP_160(None) = SOLIDITY_CALL require(bool)(TMP_159)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
Payment(_owner,msg.value,tokenValue)

IRs:
Emit Payment(_owner,msg.value,tokenValue)""];
8->9;
9[label=""Node Type: RETURN 9

EXPRESSION:
true

IRs:
RETURN True""];
10[label=""Node Type: RETURN 10

EXPRESSION:
success

IRs:
RETURN success""];
}
",0,0,1,0,"require(bool)(msg.value >= 1000000000000000000 && msg.value <= 3000000000000000000);require(bool)(endFundingTime > now);require(bool)(totalCollected < maximumFunding);totalCollected = totalCollected.add(msg.value);require(bool)(vaultAddress.send(msg.value));tokenValue = tokensPerEther.mul(msg.value);require(bool)(tokenContract.generateTokens(_owner,tokenValue));Payment(_owner,msg.value,tokenValue);true;success"
./0x496676b297799eeb9446b9d808c6051d33c6cb58_ext.sol,the_game.Try,6,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 2000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 2000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 2000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 2000000000000000000;msg.sender.transfer(this.balance);
./0x00f9f4f3ced5d4f6aedea8a92414206557df7167_ext.sol,SNL.safeWithdrawal,304,309,"TMP_97(bool) = _value == 0,CONDITION TMP_97,TMP_98 = CONVERT this to address,TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98),Transfer dest:owner value:TMP_99,Transfer dest:owner value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_97(bool) = _value == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_98 = CONVERT this to address
TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98)
Transfer dest:owner value:TMP_99""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_value == 0;owner.transfer(address(this).balance);owner.transfer(_value);
./0x5bf5436b367de54860d1b0be31203349a4d5caa7_ext.sol,CryptoCarAuction.getas,248,251,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, CryptoCarAuction.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, CryptoCarAuction.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x25d3b1550e518ba8d7581cad811285e005902faa_ext.sol,SheetMusic.transferMilestone,385,393,"TMP_31 = CONVERT this to address,TMP_32(uint256) = SOLIDITY_CALL balance(address)(TMP_31),balance(uint256) := TMP_32(uint256),Transfer dest:donatee value:balance,Emit DonationTransfered(donatee,balance)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
balance = address(this).balance

IRs:
TMP_31 = CONVERT this to address
TMP_32(uint256) = SOLIDITY_CALL balance(address)(TMP_31)
balance(uint256) := TMP_32(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
donatee.transfer(balance)

IRs:
Transfer dest:donatee value:balance""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
DonationTransfered(donatee,balance)

IRs:
Emit DonationTransfered(donatee,balance)""];
}
",0,0,1,0,"balance = address(this).balance;donatee.transfer(balance);DonationTransfered(donatee,balance)"
./0xc780b0272bbe7caedb6b47157d88ce51b324da58_ext.sol,CashFlow.withdraw,45,47,"TMP_6 = SEND dest:owner value:amount,TMP_7 = UnaryType.BANG TMP_6 ,CONDITION TMP_7,TMP_8(None) = SOLIDITY_CALL revert()(),MODIFIER_CALL, CashFlow.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: IF 1

EXPRESSION:
! owner.send(amount)

IRs:
TMP_6 = SEND dest:owner value:amount
TMP_7 = UnaryType.BANG TMP_6 
CONDITION TMP_7""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
revert()()

IRs:
TMP_8(None) = SOLIDITY_CALL revert()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, CashFlow.onlyOwner()()""];
4->1;
}
",0,0,1,0,onlyOwner();! owner.send(amount);revert()();
./0x1d4ccc31dab6ea20f461d329a0562c1c58412515_ext.sol,RefundVault.refund,566,572,"REF_66(RefundVault.State) -> State.Refunding,TMP_195(bool) = state == REF_66,TMP_196(None) = SOLIDITY_CALL require(bool)(TMP_195),REF_67(uint256) -> deposited[investor],depositedValue(uint256) := REF_67(uint256),REF_68(uint256) -> deposited[investor],REF_68(uint256) (->deposited) := 0(uint256),Transfer dest:investor value:depositedValue,Emit Refunded(investor,depositedValue)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Refunding)

IRs:
REF_66(RefundVault.State) -> State.Refunding
TMP_195(bool) = state == REF_66
TMP_196(None) = SOLIDITY_CALL require(bool)(TMP_195)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
depositedValue = deposited[investor]

IRs:
REF_67(uint256) -> deposited[investor]
depositedValue(uint256) := REF_67(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
deposited[investor] = 0

IRs:
REF_68(uint256) -> deposited[investor]
REF_68(uint256) (->deposited) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
investor.transfer(depositedValue)

IRs:
Transfer dest:investor value:depositedValue""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Refunded(investor,depositedValue)

IRs:
Emit Refunded(investor,depositedValue)""];
}
",0,0,1,0,"require(bool)(state == State.Refunding);depositedValue = deposited[investor];deposited[investor] = 0;investor.transfer(depositedValue);Refunded(investor,depositedValue)"
./0xeb914da749340266ac474f930c65c2ed4df89922_ext.sol,Destructible.destroy,299,301,"TMP_123(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_123(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0x1ec7345ee1780d847b29f65aa0ecf70cb278966e_ext.sol,EtherTv.withdraw,235,238,"Transfer dest:owner value:devOwed,devOwed(uint256) := 0(uint256),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(devOwed)

IRs:
Transfer dest:owner value:devOwed""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
devOwed = 0

IRs:
devOwed(uint256) := 0(uint256)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();owner.transfer(devOwed);devOwed = 0
./0xaa4250216f77a79fd9983642a987f708f1fe7504_ext.sol,CutiePluginBase.withdraw,300,310,"TMP_51(bool) = msg.sender == owner,TMP_52 = CONVERT coreContract to address,TMP_53(bool) = msg.sender == TMP_52,TMP_54(bool) = TMP_51 || TMP_53,TMP_55(None) = SOLIDITY_CALL require(bool)(TMP_54),TMP_56 = CONVERT this to address,TMP_57(uint256) = SOLIDITY_CALL balance(address)(TMP_56),TMP_58(bool) = TMP_57 > 0,CONDITION TMP_58,TMP_59 = CONVERT coreContract to address,TMP_60 = CONVERT this to address,TMP_61(uint256) = SOLIDITY_CALL balance(address)(TMP_60),Transfer dest:TMP_59 value:TMP_61","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == owner || msg.sender == address(coreContract))

IRs:
TMP_51(bool) = msg.sender == owner
TMP_52 = CONVERT coreContract to address
TMP_53(bool) = msg.sender == TMP_52
TMP_54(bool) = TMP_51 || TMP_53
TMP_55(None) = SOLIDITY_CALL require(bool)(TMP_54)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
address(this).balance > 0

IRs:
TMP_56 = CONVERT this to address
TMP_57(uint256) = SOLIDITY_CALL balance(address)(TMP_56)
TMP_58(bool) = TMP_57 > 0
CONDITION TMP_58""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
address(coreContract).transfer(address(this).balance)

IRs:
TMP_59 = CONVERT coreContract to address
TMP_60 = CONVERT this to address
TMP_61(uint256) = SOLIDITY_CALL balance(address)(TMP_60)
Transfer dest:TMP_59 value:TMP_61""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == owner || msg.sender == address(coreContract));address(this).balance > 0;address(coreContract).transfer(address(this).balance);
./0x5b566b473bb0ea8dc0fc6047dd623e5fa3b42307_ext.sol,Base._userRefund,124,143,"TMP_18(bool) = _to != 0,TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18),INTERNAL_CALL, Base.lock()(),REF_0(uint256) -> userEtherOf[msg.sender],amount(uint256) := REF_0(uint256),TMP_21(bool) = amount > 0,CONDITION TMP_21,REF_1(uint256) -> userEtherOf[msg.sender],REF_1(uint256) (->userEtherOf) := 0(uint256),Transfer dest:_to value:amount,_result(bool) := True(bool),_result(bool) := False(bool),INTERNAL_CALL, Base.unLock()(),RETURN _result","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != 0x0)

IRs:
TMP_18(bool) = _to != 0
TMP_19(None) = SOLIDITY_CALL require(bool)(TMP_18)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
lock()

IRs:
INTERNAL_CALL, Base.lock()()""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
amount = userEtherOf[msg.sender]

IRs:
REF_0(uint256) -> userEtherOf[msg.sender]
amount(uint256) := REF_0(uint256)""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
amount > 0

IRs:
TMP_21(bool) = amount > 0
CONDITION TMP_21""];
4->5[label=""True""];
4->8[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
userEtherOf[msg.sender] = 0

IRs:
REF_1(uint256) -> userEtherOf[msg.sender]
REF_1(uint256) (->userEtherOf) := 0(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
_to.transfer(amount)

IRs:
Transfer dest:_to value:amount""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
_result = true

IRs:
_result(bool) := True(bool)""];
7->9;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
_result = false

IRs:
_result(bool) := False(bool)""];
8->9;
9[label=""Node Type: END_IF 9
""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
unLock()

IRs:
INTERNAL_CALL, Base.unLock()()""];
10->11;
11[label=""Node Type: RETURN 11

EXPRESSION:
_result

IRs:
RETURN _result""];
}
",0,0,1,0,require(bool)(_to != 0x0);lock();amount = userEtherOf[msg.sender];amount > 0;userEtherOf[msg.sender] = 0;_result = false;_to.transfer(amount);_result = true;;unLock();_result
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.ownerUpdateOthers,2,2,"maxSignup(uint256) := _maxno(uint256),contractbacklist(bool) := _isBacklisted(bool),mineth(uint256) := _min_eth(uint256),minsignupeth(uint256) := _minsignupeth(uint256),paidversion(bool) := _paidversion(bool),MODIFIER_CALL, KahnDistributionCentre.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
maxSignup = _maxno

IRs:
maxSignup(uint256) := _maxno(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
contractbacklist = _isBacklisted

IRs:
contractbacklist(bool) := _isBacklisted(bool)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
mineth = _min_eth

IRs:
mineth(uint256) := _min_eth(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
minsignupeth = _minsignupeth

IRs:
minsignupeth(uint256) := _minsignupeth(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
paidversion = _paidversion

IRs:
paidversion(bool) := _paidversion(bool)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyOwner()()""];
6->1;
}
",0,1,1,0,onlyOwner();maxSignup = _maxno;contractbacklist = _isBacklisted;mineth = _min_eth;minsignupeth = _minsignupeth;paidversion = _paidversion
./0x009ef15c147ff4c0eb373e1abd2f4d184e5cb916_ext.sol,CampaignContract.withdrawContribution,177,184,"REF_34(uint256) -> amountAttempted[msg.sender],TMP_55(bool) = REF_34 > 0,TMP_56(None) = SOLIDITY_CALL require(bool)(TMP_55),REF_35(uint256) -> amountAttempted[msg.sender],amount(uint256) := REF_35(uint256),REF_36(uint256) -> amountAttempted[msg.sender],REF_36(uint256) (->amountAttempted) := 0(uint256),Transfer dest:msg.sender value:amount,Emit ContributionWithdrawn(msg.sender,amount),MODIFIER_CALL, CampaignContract.hasKYCInfo(address)(msg.sender)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->6;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(amountAttempted[msg.sender] > 0)

IRs:
REF_34(uint256) -> amountAttempted[msg.sender]
TMP_55(bool) = REF_34 > 0
TMP_56(None) = SOLIDITY_CALL require(bool)(TMP_55)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = amountAttempted[msg.sender]

IRs:
REF_35(uint256) -> amountAttempted[msg.sender]
amount(uint256) := REF_35(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
amountAttempted[msg.sender] = 0

IRs:
REF_36(uint256) -> amountAttempted[msg.sender]
REF_36(uint256) (->amountAttempted) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(amount)

IRs:
Transfer dest:msg.sender value:amount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
ContributionWithdrawn(msg.sender,amount)

IRs:
Emit ContributionWithdrawn(msg.sender,amount)""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
hasKYCInfo(msg.sender)

IRs:
MODIFIER_CALL, CampaignContract.hasKYCInfo(address)(msg.sender)""];
6->1;
}
",0,0,1,0,"hasKYCInfo(msg.sender);require(bool)(amountAttempted[msg.sender] > 0);amount = amountAttempted[msg.sender];amountAttempted[msg.sender] = 0;msg.sender.transfer(amount);ContributionWithdrawn(msg.sender,amount)"
./0x1d899280f446aab65971e41611b5bb5516dd47f9_ext.sol,CryptoMiningWar.upgrade,594,597,"TMP_239(None) = SOLIDITY_CALL selfdestruct(address)(addr),MODIFIER_CALL, CryptoMiningWar.isAdministrator()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(addr)

IRs:
TMP_239(None) = SOLIDITY_CALL selfdestruct(address)(addr)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdministrator()

IRs:
MODIFIER_CALL, CryptoMiningWar.isAdministrator()()""];
2->1;
}
",0,0,1,0,isAdministrator();selfdestruct(address)(addr)
./0xe01ba6c593003b0edcd43b7839a7c36b00a44dfc_ext.sol,SBITokenCrowdsale.safeWithdrawal,429,432,"TMP_148(uint256) = SOLIDITY_CALL balance(address)(crowdsaleAddress),Transfer dest:bank value:TMP_148,TMP_150(uint256) = SOLIDITY_CALL balance(address)(crowdsaleAddress),Emit FundTransfer(crowdsaleAddress,bank,TMP_150),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
bank.transfer(crowdsaleAddress.balance)

IRs:
TMP_148(uint256) = SOLIDITY_CALL balance(address)(crowdsaleAddress)
Transfer dest:bank value:TMP_148""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
FundTransfer(crowdsaleAddress,bank,crowdsaleAddress.balance)

IRs:
TMP_150(uint256) = SOLIDITY_CALL balance(address)(crowdsaleAddress)
Emit FundTransfer(crowdsaleAddress,bank,TMP_150)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
3->1;
}
",0,0,1,0,"onlyOwner();bank.transfer(crowdsaleAddress.balance);FundTransfer(crowdsaleAddress,bank,crowdsaleAddress.balance)"
./0x7fceafdefc16b0f703a43ffb0451ddd2a7cbd6dc_ext.sol,alfa_Quiz.Stop,26,28,"REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3,MODIFIER_CALL, alfa_Quiz.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, alfa_Quiz.isAdmin()()""];
2->1;
}
",0,0,1,0,isAdmin();msg.sender.transfer(this.balance)
./0x2873f3dfa8b9cdcda9b619b0c3a62c2cd9daf5c5_ext.sol,Lottery.pay,242,245,"Transfer dest:_to value:_amount,Emit Transfer(owner_,_to,_amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_to.transfer(_amount)

IRs:
Transfer dest:_to value:_amount""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
Transfer(owner_,_to,_amount)

IRs:
Emit Transfer(owner_,_to,_amount)""];
}
",0,0,1,0,"_to.transfer(_amount);Transfer(owner_,_to,_amount)"
./0x1da73fc09ea07781482994036a0eecc7e6952dfb_ext.sol,TydoIco.refund,186,199,"TMP_73(bool) = state == 2,TMP_74(None) = SOLIDITY_CALL require(bool)(TMP_73),REF_21(uint256) -> balances[msg.sender],tokenAmount(uint256) := REF_21(uint256),TMP_75(bool) = tokenAmount > 0,TMP_76(None) = SOLIDITY_CALL require(bool)(TMP_75),REF_22(uint256) -> ethBalances[msg.sender],weiAmount(uint256) := REF_22(uint256),Transfer dest:msg.sender value:weiAmount,REF_25(uint256) -> balances[msg.sender],TMP_78(bool) = HIGH_LEVEL_CALL, dest:token(AbstractERC20), function:transfer, arguments:['owner', 'REF_25']  ,REF_26(uint256) -> ethBalances[msg.sender],REF_26(uint256) (->ethBalances) := 0(uint256),REF_27(uint256) -> balances[msg.sender],REF_27(uint256) (->balances) := 0(uint256),TMP_79(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['ethCollected', 'weiAmount'] ,ethCollected(uint256) := TMP_79(uint256)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == 2)

IRs:
TMP_73(bool) = state == 2
TMP_74(None) = SOLIDITY_CALL require(bool)(TMP_73)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
tokenAmount = balances[msg.sender]

IRs:
REF_21(uint256) -> balances[msg.sender]
tokenAmount(uint256) := REF_21(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(tokenAmount > 0)

IRs:
TMP_75(bool) = tokenAmount > 0
TMP_76(None) = SOLIDITY_CALL require(bool)(TMP_75)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
weiAmount = ethBalances[msg.sender]

IRs:
REF_22(uint256) -> ethBalances[msg.sender]
weiAmount(uint256) := REF_22(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
msg.sender.transfer(weiAmount)

IRs:
Transfer dest:msg.sender value:weiAmount""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
token.transfer(owner,balances[msg.sender])

IRs:
REF_25(uint256) -> balances[msg.sender]
TMP_78(bool) = HIGH_LEVEL_CALL, dest:token(AbstractERC20), function:transfer, arguments:['owner', 'REF_25']  ""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
ethBalances[msg.sender] = 0

IRs:
REF_26(uint256) -> ethBalances[msg.sender]
REF_26(uint256) (->ethBalances) := 0(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
balances[msg.sender] = 0

IRs:
REF_27(uint256) -> balances[msg.sender]
REF_27(uint256) (->balances) := 0(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
ethCollected = ethCollected.sub(weiAmount)

IRs:
TMP_79(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['ethCollected', 'weiAmount'] 
ethCollected(uint256) := TMP_79(uint256)""];
}
",0,0,1,0,"require(bool)(state == 2);tokenAmount = balances[msg.sender];require(bool)(tokenAmount > 0);weiAmount = ethBalances[msg.sender];msg.sender.transfer(weiAmount);token.transfer(owner,balances[msg.sender]);ethBalances[msg.sender] = 0;balances[msg.sender] = 0;ethCollected = ethCollected.sub(weiAmount)"
./0x50f37df80a4e804a03275b21f83ebf5d5a668d39_ext.sol,AuctionPotato.cancelAuction,252,263,"canceled(bool) := True(bool),Emit LogCanceled(),TMP_71 = CONVERT this to address,TMP_72(uint256) = SOLIDITY_CALL balance(address)(TMP_71),Emit Withdraw(highestBidder,TMP_72),TMP_74 = CONVERT this to address,TMP_75(uint256) = SOLIDITY_CALL balance(address)(TMP_74),Transfer dest:highestBidder value:TMP_75,MODIFIER_CALL, Ownable.onlyOwner()(),MODIFIER_CALL, AuctionPotato.onlyBeforeEnd()(),MODIFIER_CALL, AuctionPotato.onlyNotCanceled()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
canceled = true

IRs:
canceled(bool) := True(bool)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
LogCanceled()

IRs:
Emit LogCanceled()""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Withdraw(highestBidder,address(this).balance)

IRs:
TMP_71 = CONVERT this to address
TMP_72(uint256) = SOLIDITY_CALL balance(address)(TMP_71)
Emit Withdraw(highestBidder,TMP_72)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
highestBidder.transfer(address(this).balance)

IRs:
TMP_74 = CONVERT this to address
TMP_75(uint256) = SOLIDITY_CALL balance(address)(TMP_74)
Transfer dest:highestBidder value:TMP_75""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onlyBeforeEnd()

IRs:
MODIFIER_CALL, AuctionPotato.onlyBeforeEnd()()""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
onlyNotCanceled()

IRs:
MODIFIER_CALL, AuctionPotato.onlyNotCanceled()()""];
7->1;
}
",0,0,1,0,"onlyOwner();canceled = true;LogCanceled();Withdraw(highestBidder,address(this).balance);highestBidder.transfer(address(this).balance);onlyBeforeEnd();onlyNotCanceled()"
./0x56d06701fd44a4a857cb96b266f505a2832950c5_ext.sol,Child.kill,1074,1078,"HIGH_LEVEL_CALL, dest:g_Main(Main), function:ClearAuth, arguments:['this']  ,TMP_917(None) = SOLIDITY_CALL selfdestruct(address)(creator),MODIFIER_CALL, Base.CreatorAble()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
g_Main.ClearAuth(this)

IRs:
HIGH_LEVEL_CALL, dest:g_Main(Main), function:ClearAuth, arguments:['this']  ""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(creator)

IRs:
TMP_917(None) = SOLIDITY_CALL selfdestruct(address)(creator)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
CreatorAble()

IRs:
MODIFIER_CALL, Base.CreatorAble()()""];
3->1;
}
",0,0,1,0,CreatorAble();g_Main.ClearAuth(this);selfdestruct(address)(creator)
./0x18aaad578e74913df4255c126f2a0bd9e3399ec7_ext.sol,test_contract.StopGame,33,36,"TMP_10(bool) = msg.sender == questionSender,TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_10(bool) = msg.sender == questionSender
TMP_11(None) = SOLIDITY_CALL require(bool)(TMP_10)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0xd1ceeee3ecfff60d9532c37c9d24f68ca0e96453_ext.sol,Dice2Win.kill,163,166,"TMP_33(bool) = lockedInBets == 0,TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33),TMP_35(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Dice2Win.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(lockedInBets == 0)

IRs:
TMP_33(bool) = lockedInBets == 0
TMP_34(None) = SOLIDITY_CALL require(bool)(TMP_33)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_35(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Dice2Win.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();require(bool)(lockedInBets == 0);selfdestruct(address)(owner)
./0x17f0badcdf99b0a94429478d2e9ddb1ff13174f7_ext.sol,knf.destroy,257,259,"TMP_64 = CONVERT this to address,TMP_65(bool) = owner != TMP_64,TMP_66(None) = SOLIDITY_CALL require(bool)(TMP_65),TMP_67(None) = SOLIDITY_CALL selfdestruct(address)(control),MODIFIER_CALL, knf.onlyControl()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(owner != address(this))

IRs:
TMP_64 = CONVERT this to address
TMP_65(bool) = owner != TMP_64
TMP_66(None) = SOLIDITY_CALL require(bool)(TMP_65)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
selfdestruct(address)(control)

IRs:
TMP_67(None) = SOLIDITY_CALL selfdestruct(address)(control)""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyControl()

IRs:
MODIFIER_CALL, knf.onlyControl()()""];
3->1;
}
",0,0,1,0,onlyControl();require(bool)(owner != address(this));selfdestruct(address)(control)
./0x5838f878000fe44b6f6c677bbf839e12f097c147_ext.sol,Q_GAME.Try,5,12,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 2000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 2000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 2000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 2000000000000000000;msg.sender.transfer(this.balance);
./0x41a322b28d0ff354040e2cbc676f0320d8c8850d_ext.sol,SupeRare.cancelBid,474,481,"REF_69(address) -> tokenBidder[_tokenId],bidder(address) := REF_69(address),TMP_176(bool) = msg.sender == bidder,TMP_177(None) = SOLIDITY_CALL require(bool)(TMP_176),REF_70(uint256) -> tokenCurrentBid[_tokenId],bidAmount(uint256) := REF_70(uint256),Transfer dest:msg.sender value:bidAmount,INTERNAL_CALL, SupeRare.clearBid(uint256)(_tokenId),Emit CancelBid(bidder,bidAmount,_tokenId)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
bidder = tokenBidder[_tokenId]

IRs:
REF_69(address) -> tokenBidder[_tokenId]
bidder(address) := REF_69(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == bidder)

IRs:
TMP_176(bool) = msg.sender == bidder
TMP_177(None) = SOLIDITY_CALL require(bool)(TMP_176)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
bidAmount = tokenCurrentBid[_tokenId]

IRs:
REF_70(uint256) -> tokenCurrentBid[_tokenId]
bidAmount(uint256) := REF_70(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(bidAmount)

IRs:
Transfer dest:msg.sender value:bidAmount""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
clearBid(_tokenId)

IRs:
INTERNAL_CALL, SupeRare.clearBid(uint256)(_tokenId)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
CancelBid(bidder,bidAmount,_tokenId)

IRs:
Emit CancelBid(bidder,bidAmount,_tokenId)""];
}
",0,0,1,0,"bidder = tokenBidder[_tokenId];require(bool)(msg.sender == bidder);bidAmount = tokenCurrentBid[_tokenId];msg.sender.transfer(bidAmount);clearBid(_tokenId);CancelBid(bidder,bidAmount,_tokenId)"
./0x299187bb996599f7fc82df025ee8964cafe3085a_ext.sol,Challenge.withdraw,15,22,"TMP_0 = CONVERT this to address,TMP_1(uint256) = SOLIDITY_CALL balance(address)(TMP_0),TMP_2(bool) = TMP_1 > 0,TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2),TMP_4 = CONVERT this to address,TMP_5(uint256) = SOLIDITY_CALL balance(address)(TMP_4),TMP_6(bool) = TMP_5 > 10000000000000000,CONDITION TMP_6,TMP_7 = CONVERT this to address,TMP_8(uint256) = SOLIDITY_CALL balance(address)(TMP_7),TMP_9(uint256) = TMP_8 - 10000000000000000,Transfer dest:previous_owner value:TMP_9,TMP_11 = CONVERT this to address,TMP_12(uint256) = SOLIDITY_CALL balance(address)(TMP_11),Transfer dest:creator value:TMP_12","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(address(this).balance > 0)

IRs:
TMP_0 = CONVERT this to address
TMP_1(uint256) = SOLIDITY_CALL balance(address)(TMP_0)
TMP_2(bool) = TMP_1 > 0
TMP_3(None) = SOLIDITY_CALL require(bool)(TMP_2)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
address(this).balance > 10000000000000000

IRs:
TMP_4 = CONVERT this to address
TMP_5(uint256) = SOLIDITY_CALL balance(address)(TMP_4)
TMP_6(bool) = TMP_5 > 10000000000000000
CONDITION TMP_6""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
previous_owner.transfer(address(this).balance - 10000000000000000)

IRs:
TMP_7 = CONVERT this to address
TMP_8(uint256) = SOLIDITY_CALL balance(address)(TMP_7)
TMP_9(uint256) = TMP_8 - 10000000000000000
Transfer dest:previous_owner value:TMP_9""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
creator.transfer(address(this).balance)

IRs:
TMP_11 = CONVERT this to address
TMP_12(uint256) = SOLIDITY_CALL balance(address)(TMP_11)
Transfer dest:creator value:TMP_12""];
}
",0,0,1,0,require(bool)(address(this).balance > 0);address(this).balance > 10000000000000000;previous_owner.transfer(address(this).balance - 10000000000000000);;creator.transfer(address(this).balance)
./0x1e85407e080a5e6d20a3a95fcdddfc32146fc8e5_ext.sol,MiniMeToken.claimTokens,625,635,"TMP_135(bool) = _token == 0,CONDITION TMP_135,TMP_136 = CONVERT this to address,TMP_137(uint256) = SOLIDITY_CALL balance(address)(TMP_136),Transfer dest:controller value:TMP_137,TMP_139 = CONVERT _token to MiniMeToken,token(MiniMeToken) := TMP_139(MiniMeToken),TMP_140(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  ,balance(uint256) := TMP_140(uint256),TMP_141(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  ,Emit ClaimedTokens(_token,controller,balance),MODIFIER_CALL, Controlled.onlyController()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
_token == 0x0

IRs:
TMP_135(bool) = _token == 0
CONDITION TMP_135""];
1->2[label=""True""];
1->4[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
controller.transfer(address(this).balance)

IRs:
TMP_136 = CONVERT this to address
TMP_137(uint256) = SOLIDITY_CALL balance(address)(TMP_136)
Transfer dest:controller value:TMP_137""];
2->3;
3[label=""Node Type: RETURN 3
""];
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
token = MiniMeToken(_token)

IRs:
TMP_139 = CONVERT _token to MiniMeToken
token(MiniMeToken) := TMP_139(MiniMeToken)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
balance = token.balanceOf(this)

IRs:
TMP_140(uint256) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:balanceOf, arguments:['this']  
balance(uint256) := TMP_140(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.transfer(controller,balance)

IRs:
TMP_141(bool) = HIGH_LEVEL_CALL, dest:token(MiniMeToken), function:transfer, arguments:['controller', 'balance']  ""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
ClaimedTokens(_token,controller,balance)

IRs:
Emit ClaimedTokens(_token,controller,balance)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyController()

IRs:
MODIFIER_CALL, Controlled.onlyController()()""];
9->1;
}
",0,0,1,0,"onlyController();_token == 0x0;controller.transfer(address(this).balance);;;token = MiniMeToken(_token);balance = token.balanceOf(this);token.transfer(controller,balance);ClaimedTokens(_token,controller,balance)"
./0x1db9cf016fe7ce4d9f4ba2d8fd2834e72d43198c_ext.sol,LUNO.withdraw,291,294,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, LUNO.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, LUNO.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0xaa3fbfaf03cd50e6a44d27d10eb14333d1c02e52_ext.sol,ETH_GAME.Stop,28,30,"REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3,MODIFIER_CALL, ETH_GAME.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, ETH_GAME.isAdmin()()""];
2->1;
}
",0,0,1,0,isAdmin();msg.sender.transfer(this.balance)
./0x6cd3409ec07e5aa64baaeb08c6a038f30e831090_ext.sol,Destructible.destroy,89,91,"TMP_24(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_24(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0xee58ee0b1519bb47801812a3a9c83ab600c63d81_ext.sol,Destructible.destroy,106,108,"TMP_24(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_24(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0x3686986e559f257cfaccb44f17af5b245e45814f_ext.sol,ZEROtoken.kill,51,51,"TMP_33(bool) = msg.sender == owner,CONDITION TMP_33,TMP_34(None) = SOLIDITY_CALL suicide(address)(owner)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
msg.sender == owner

IRs:
TMP_33(bool) = msg.sender == owner
CONDITION TMP_33""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
suicide(address)(owner)

IRs:
TMP_34(None) = SOLIDITY_CALL suicide(address)(owner)""];
2->3;
3[label=""Node Type: END_IF 3
""];
}
",0,0,1,0,msg.sender == owner;suicide(address)(owner);
./0x5c3536c7cd64c3bcb6ea01c00c2919bcd5053aba_ext.sol,BlastBox.withdraw,300,303,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, BlastBox.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, BlastBox.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x26788f0670bdf9594ba1a677a977e97eb68568db_ext.sol,KahnDistributionCentre.adminUpdateWallet,2,2,"TMP_68 = CONVERT 0 to address,TMP_69(bool) = _wallet != TMP_68,TMP_70(None) = SOLIDITY_CALL require(bool)(TMP_69),wallet(address) := _wallet(address),Emit eWalletChange(wallet,msg.sender),MODIFIER_CALL, KahnDistributionCentre.onlyAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_wallet != address(0))

IRs:
TMP_68 = CONVERT 0 to address
TMP_69(bool) = _wallet != TMP_68
TMP_70(None) = SOLIDITY_CALL require(bool)(TMP_69)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
wallet = _wallet

IRs:
wallet(address) := _wallet(address)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
eWalletChange(wallet,msg.sender)

IRs:
Emit eWalletChange(wallet,msg.sender)""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyAdmin()

IRs:
MODIFIER_CALL, KahnDistributionCentre.onlyAdmin()()""];
4->1;
}
",0,1,1,0,"onlyAdmin();require(bool)(_wallet != address(0));wallet = _wallet;eWalletChange(wallet,msg.sender)"
./0xd587cb111d3e506ffafdf4b1c5d19008086c4e5a_ext.sol,IartistChain.fallback,147,151,"TMP_79 = SEND dest:owner value:msg.value,TMP_80(uint256) = msg.value * buyPrice,amount(uint256) := TMP_80(uint256),INTERNAL_CALL, IartistChain._transfer(address,address,uint256)(owner,msg.sender,amount)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.send(msg.value)

IRs:
TMP_79 = SEND dest:owner value:msg.value""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
amount = msg.value * buyPrice

IRs:
TMP_80(uint256) = msg.value * buyPrice
amount(uint256) := TMP_80(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_transfer(owner,msg.sender,amount)

IRs:
INTERNAL_CALL, IartistChain._transfer(address,address,uint256)(owner,msg.sender,amount)""];
}
",0,0,1,0,"owner.send(msg.value);amount = msg.value * buyPrice;_transfer(owner,msg.sender,amount)"
./0xa41aa09607ca80ee60d2ce166d4c02a71860e5c5_ext.sol,XTVToken.drain,544,546,"TMP_184 = CONVERT this to address,TMP_185(uint256) = SOLIDITY_CALL balance(address)(TMP_184),Transfer dest:owner value:TMP_185,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_184 = CONVERT this to address
TMP_185(uint256) = SOLIDITY_CALL balance(address)(TMP_184)
Transfer dest:owner value:TMP_185""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();owner.transfer(address(this).balance)
./0x5a6dcd18e7e8e7844a8cbb02390c3392e165036a_ext.sol,RubikProtocol.withdraw,289,292,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, RubikProtocol.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, RubikProtocol.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x52629dd14923d9f60deafdd373ff6e1145866f09_ext.sol,LandGrabToken._payout,370,376,"TMP_95 = CONVERT 0 to address,TMP_96(bool) = _to == TMP_95,CONDITION TMP_96,REF_38(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:ceoAddress value:REF_38,REF_40(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:_to value:REF_40","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_to == address(0)

IRs:
TMP_95 = CONVERT 0 to address
TMP_96(bool) = _to == TMP_95
CONDITION TMP_96""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ceoAddress.transfer(this.balance)

IRs:
REF_38(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:ceoAddress value:REF_38""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_to.transfer(this.balance)

IRs:
REF_40(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:_to value:REF_40""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,_to == address(0);ceoAddress.transfer(this.balance);_to.transfer(this.balance);
./0x6ace03f517ae15f1a8d1b6811d23f7aa8c295be0_ext.sol,RefundVault.refund,170,176,"REF_10(RefundVault.State) -> State.Refunding,TMP_50(bool) = state == REF_10,TMP_51(None) = SOLIDITY_CALL require(bool)(TMP_50),REF_11(uint256) -> deposited[investor],depositedValue(uint256) := REF_11(uint256),REF_12(uint256) -> deposited[investor],REF_12(uint256) (->deposited) := 0(uint256),Transfer dest:investor value:depositedValue,Emit Refunded(investor,depositedValue)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Refunding)

IRs:
REF_10(RefundVault.State) -> State.Refunding
TMP_50(bool) = state == REF_10
TMP_51(None) = SOLIDITY_CALL require(bool)(TMP_50)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
depositedValue = deposited[investor]

IRs:
REF_11(uint256) -> deposited[investor]
depositedValue(uint256) := REF_11(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
deposited[investor] = 0

IRs:
REF_12(uint256) -> deposited[investor]
REF_12(uint256) (->deposited) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
investor.transfer(depositedValue)

IRs:
Transfer dest:investor value:depositedValue""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
Refunded(investor,depositedValue)

IRs:
Emit Refunded(investor,depositedValue)""];
}
",0,0,1,0,"require(bool)(state == State.Refunding);depositedValue = deposited[investor];deposited[investor] = 0;investor.transfer(depositedValue);Refunded(investor,depositedValue)"
./0xdfa66ec49cf0102fb8906ee3dd6a70597d9720d4_ext.sol,DEKS.getTokens,174,233,"tokens(uint256) := 0(uint256),bonus(uint256) := 0(uint256),countbonus(uint256) := 0(uint256),TMP_45(uint256) = 1000000000000000000 / 2,bonusCond1(uint256) := TMP_45(uint256),bonusCond2(uint256) := 1000000000000000000(uint256),bonusCond3(uint256) := 3000000000000000000(uint256),TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_47(uint256) = TMP_46 / 1000000000000000000,tokens(uint256) := TMP_47(uint256),investor(address) := msg.sender(address),TMP_48(bool) = msg.value >= requestMinimum,TMP_49(bool) = now < deadline,TMP_50(bool) = TMP_48 && TMP_49,TMP_51(bool) = now < round1,TMP_52(bool) = TMP_50 && TMP_51,TMP_53(bool) = now < round2,TMP_54(bool) = TMP_52 && TMP_53,CONDITION TMP_54,TMP_55(bool) = msg.value >= bonusCond1,TMP_56(bool) = msg.value < bonusCond2,TMP_57(bool) = TMP_55 && TMP_56,CONDITION TMP_57,TMP_58(uint256) = tokens * 10,TMP_59(uint256) = TMP_58 / 100,countbonus(uint256) := TMP_59(uint256),TMP_60(bool) = msg.value >= bonusCond2,TMP_61(bool) = msg.value < bonusCond3,TMP_62(bool) = TMP_60 && TMP_61,CONDITION TMP_62,TMP_63(uint256) = tokens * 50,TMP_64(uint256) = TMP_63 / 100,countbonus(uint256) := TMP_64(uint256),TMP_65(bool) = msg.value >= bonusCond3,CONDITION TMP_65,TMP_66(uint256) = tokens * 75,TMP_67(uint256) = TMP_66 / 100,countbonus(uint256) := TMP_67(uint256),TMP_68(bool) = msg.value >= requestMinimum,TMP_69(bool) = now < deadline,TMP_70(bool) = TMP_68 && TMP_69,TMP_71(bool) = now > round1,TMP_72(bool) = TMP_70 && TMP_71,TMP_73(bool) = now < round2,TMP_74(bool) = TMP_72 && TMP_73,CONDITION TMP_74,TMP_75(bool) = msg.value >= bonusCond2,TMP_76(bool) = msg.value < bonusCond3,TMP_77(bool) = TMP_75 && TMP_76,CONDITION TMP_77,TMP_78(uint256) = tokens * 25,TMP_79(uint256) = TMP_78 / 100,countbonus(uint256) := TMP_79(uint256),TMP_80(bool) = msg.value >= bonusCond3,CONDITION TMP_80,TMP_81(uint256) = tokens * 50,TMP_82(uint256) = TMP_81 / 100,countbonus(uint256) := TMP_82(uint256),countbonus(uint256) := 0(uint256),TMP_83(uint256) = tokens + countbonus,bonus(uint256) := TMP_83(uint256),TMP_84(bool) = tokens == 0,CONDITION TMP_84,valdrop(uint256) := 1000000000(uint256),REF_12(bool) -> Claimed[investor],TMP_85(bool) = REF_12 == False,TMP_86(bool) = progress0drop <= target0drop,TMP_87(bool) = TMP_85 && TMP_86,CONDITION TMP_87,TMP_88(bool) = INTERNAL_CALL, DEKS.distr(address,uint256)(investor,valdrop),REF_13(bool) -> Claimed[investor],REF_13(bool) (->Claimed) := True(bool),TMP_89(uint256) := progress0drop(uint256),progress0drop(uint256) = progress0drop + 1,TMP_90(bool) = msg.value >= requestMinimum,TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),TMP_92(bool) = tokens > 0,TMP_93(bool) = msg.value >= requestMinimum,TMP_94(bool) = TMP_92 && TMP_93,CONDITION TMP_94,TMP_95(bool) = now >= deadline,TMP_96(bool) = now >= round1,TMP_97(bool) = TMP_95 && TMP_96,TMP_98(bool) = now < round2,TMP_99(bool) = TMP_97 && TMP_98,CONDITION TMP_99,TMP_100(bool) = INTERNAL_CALL, DEKS.distr(address,uint256)(investor,tokens),TMP_101(bool) = msg.value >= bonusCond1,CONDITION TMP_101,TMP_102(bool) = INTERNAL_CALL, DEKS.distr(address,uint256)(investor,bonus),TMP_103(bool) = INTERNAL_CALL, DEKS.distr(address,uint256)(investor,tokens),TMP_104(bool) = msg.value >= requestMinimum,TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104),TMP_106(bool) = totalDistributed >= totalSupply,CONDITION TMP_106,distributionFinished(bool) := True(bool),Transfer dest:multisig value:msg.value,MODIFIER_CALL, DEKS.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->53;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bonusCond1 = 1000000000000000000 / 2

IRs:
TMP_45(uint256) = 1000000000000000000 / 2
bonusCond1(uint256) := TMP_45(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bonusCond2 = 1000000000000000000

IRs:
bonusCond2(uint256) := 1000000000000000000(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
bonusCond3 = 3000000000000000000

IRs:
bonusCond3(uint256) := 3000000000000000000(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_47(uint256) = TMP_46 / 1000000000000000000
tokens(uint256) := TMP_47(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now < round1 && now < round2

IRs:
TMP_48(bool) = msg.value >= requestMinimum
TMP_49(bool) = now < deadline
TMP_50(bool) = TMP_48 && TMP_49
TMP_51(bool) = now < round1
TMP_52(bool) = TMP_50 && TMP_51
TMP_53(bool) = now < round2
TMP_54(bool) = TMP_52 && TMP_53
CONDITION TMP_54""];
9->10[label=""True""];
9->19[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
msg.value >= bonusCond1 && msg.value < bonusCond2

IRs:
TMP_55(bool) = msg.value >= bonusCond1
TMP_56(bool) = msg.value < bonusCond2
TMP_57(bool) = TMP_55 && TMP_56
CONDITION TMP_57""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
countbonus = tokens * 10 / 100

IRs:
TMP_58(uint256) = tokens * 10
TMP_59(uint256) = TMP_58 / 100
countbonus(uint256) := TMP_59(uint256)""];
11->18;
12[label=""Node Type: IF 12

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_60(bool) = msg.value >= bonusCond2
TMP_61(bool) = msg.value < bonusCond3
TMP_62(bool) = TMP_60 && TMP_61
CONDITION TMP_62""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
countbonus = tokens * 50 / 100

IRs:
TMP_63(uint256) = tokens * 50
TMP_64(uint256) = TMP_63 / 100
countbonus(uint256) := TMP_64(uint256)""];
13->17;
14[label=""Node Type: IF 14

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_65(bool) = msg.value >= bonusCond3
CONDITION TMP_65""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
countbonus = tokens * 75 / 100

IRs:
TMP_66(uint256) = tokens * 75
TMP_67(uint256) = TMP_66 / 100
countbonus(uint256) := TMP_67(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->28;
19[label=""Node Type: IF 19

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now > round1 && now < round2

IRs:
TMP_68(bool) = msg.value >= requestMinimum
TMP_69(bool) = now < deadline
TMP_70(bool) = TMP_68 && TMP_69
TMP_71(bool) = now > round1
TMP_72(bool) = TMP_70 && TMP_71
TMP_73(bool) = now < round2
TMP_74(bool) = TMP_72 && TMP_73
CONDITION TMP_74""];
19->20[label=""True""];
19->26[label=""False""];
20[label=""Node Type: IF 20

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_75(bool) = msg.value >= bonusCond2
TMP_76(bool) = msg.value < bonusCond3
TMP_77(bool) = TMP_75 && TMP_76
CONDITION TMP_77""];
20->21[label=""True""];
20->22[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
countbonus = tokens * 25 / 100

IRs:
TMP_78(uint256) = tokens * 25
TMP_79(uint256) = TMP_78 / 100
countbonus(uint256) := TMP_79(uint256)""];
21->25;
22[label=""Node Type: IF 22

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_80(bool) = msg.value >= bonusCond3
CONDITION TMP_80""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
countbonus = tokens * 50 / 100

IRs:
TMP_81(uint256) = tokens * 50
TMP_82(uint256) = TMP_81 / 100
countbonus(uint256) := TMP_82(uint256)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->27;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
bonus = tokens + countbonus

IRs:
TMP_83(uint256) = tokens + countbonus
bonus(uint256) := TMP_83(uint256)""];
29->30;
30[label=""Node Type: IF 30

EXPRESSION:
tokens == 0

IRs:
TMP_84(bool) = tokens == 0
CONDITION TMP_84""];
30->31[label=""True""];
30->38[label=""False""];
31[label=""Node Type: NEW VARIABLE 31

EXPRESSION:
valdrop = 10e8

IRs:
valdrop(uint256) := 1000000000(uint256)""];
31->32;
32[label=""Node Type: IF 32

EXPRESSION:
Claimed[investor] == false && progress0drop <= target0drop

IRs:
REF_12(bool) -> Claimed[investor]
TMP_85(bool) = REF_12 == False
TMP_86(bool) = progress0drop <= target0drop
TMP_87(bool) = TMP_85 && TMP_86
CONDITION TMP_87""];
32->33[label=""True""];
32->36[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
distr(investor,valdrop)

IRs:
TMP_88(bool) = INTERNAL_CALL, DEKS.distr(address,uint256)(investor,valdrop)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
Claimed[investor] = true

IRs:
REF_13(bool) -> Claimed[investor]
REF_13(bool) (->Claimed) := True(bool)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
progress0drop ++

IRs:
TMP_89(uint256) := progress0drop(uint256)
progress0drop(uint256) = progress0drop + 1""];
35->37;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_90(bool) = msg.value >= requestMinimum
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
36->37;
37[label=""Node Type: END_IF 37
""];
37->48;
38[label=""Node Type: IF 38

EXPRESSION:
tokens > 0 && msg.value >= requestMinimum

IRs:
TMP_92(bool) = tokens > 0
TMP_93(bool) = msg.value >= requestMinimum
TMP_94(bool) = TMP_92 && TMP_93
CONDITION TMP_94""];
38->39[label=""True""];
38->46[label=""False""];
39[label=""Node Type: IF 39

EXPRESSION:
now >= deadline && now >= round1 && now < round2

IRs:
TMP_95(bool) = now >= deadline
TMP_96(bool) = now >= round1
TMP_97(bool) = TMP_95 && TMP_96
TMP_98(bool) = now < round2
TMP_99(bool) = TMP_97 && TMP_98
CONDITION TMP_99""];
39->40[label=""True""];
39->41[label=""False""];
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_100(bool) = INTERNAL_CALL, DEKS.distr(address,uint256)(investor,tokens)""];
40->45;
41[label=""Node Type: IF 41

EXPRESSION:
msg.value >= bonusCond1

IRs:
TMP_101(bool) = msg.value >= bonusCond1
CONDITION TMP_101""];
41->42[label=""True""];
41->43[label=""False""];
42[label=""Node Type: EXPRESSION 42

EXPRESSION:
distr(investor,bonus)

IRs:
TMP_102(bool) = INTERNAL_CALL, DEKS.distr(address,uint256)(investor,bonus)""];
42->44;
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_103(bool) = INTERNAL_CALL, DEKS.distr(address,uint256)(investor,tokens)""];
43->44;
44[label=""Node Type: END_IF 44
""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->47;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_104(bool) = msg.value >= requestMinimum
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: IF 49

EXPRESSION:
totalDistributed >= totalSupply

IRs:
TMP_106(bool) = totalDistributed >= totalSupply
CONDITION TMP_106""];
49->50[label=""True""];
49->51[label=""False""];
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
multisig.transfer(msg.value)

IRs:
Transfer dest:multisig value:msg.value""];
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, DEKS.canDistr()()""];
53->1;
}
",0,0,1,0,"canDistr();tokens = 0;bonus = 0;countbonus = 0;bonusCond1 = 1000000000000000000 / 2;bonusCond2 = 1000000000000000000;bonusCond3 = 3000000000000000000;tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;investor = msg.sender;msg.value >= requestMinimum && now < deadline && now < round1 && now < round2;msg.value >= bonusCond1 && msg.value < bonusCond2;msg.value >= requestMinimum && now < deadline && now > round1 && now < round2;countbonus = tokens * 10 / 100;msg.value >= bonusCond2 && msg.value < bonusCond3;;countbonus = tokens * 50 / 100;msg.value >= bonusCond3;;countbonus = tokens * 75 / 100;;;msg.value >= bonusCond2 && msg.value < bonusCond3;countbonus = 0;countbonus = tokens * 25 / 100;msg.value >= bonusCond3;;countbonus = tokens * 50 / 100;;;bonus = tokens + countbonus;tokens == 0;valdrop = 10e8;tokens > 0 && msg.value >= requestMinimum;Claimed[investor] == false && progress0drop <= target0drop;distr(investor,valdrop);require(bool)(msg.value >= requestMinimum);Claimed[investor] = true;progress0drop ++;;;now >= deadline && now >= round1 && now < round2;require(bool)(msg.value >= requestMinimum);distr(investor,tokens);msg.value >= bonusCond1;;distr(investor,bonus);distr(investor,tokens);;;totalDistributed >= totalSupply;distributionFinished = true;;multisig.transfer(msg.value)"
./0xee1f0f9731ee93736e219598e6aa441ad36ffc61_ext.sol,ENIGMA.Try,5,12,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 3000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 3000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 3000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 3000000000000000000;msg.sender.transfer(this.balance);
./0x345ab5e5f971dbdbc92af2779ce7a8bbf1819e59_ext.sol,TwentyDollars.withdraw,76,81,"REF_6(uint256) -> balances[msg.sender],balance(uint256) := REF_6(uint256),TMP_4(bool) = balance > 0,TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4),REF_7(uint256) -> balances[msg.sender],REF_7(uint256) (->balances) := 0(uint256),Transfer dest:msg.sender value:balance","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
balance = balances[msg.sender]

IRs:
REF_6(uint256) -> balances[msg.sender]
balance(uint256) := REF_6(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balance > 0)

IRs:
TMP_4(bool) = balance > 0
TMP_5(None) = SOLIDITY_CALL require(bool)(TMP_4)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[msg.sender] = 0

IRs:
REF_7(uint256) -> balances[msg.sender]
REF_7(uint256) (->balances) := 0(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(balance)

IRs:
Transfer dest:msg.sender value:balance""];
}
",0,0,1,0,balance = balances[msg.sender];require(bool)(balance > 0);balances[msg.sender] = 0;msg.sender.transfer(balance)
./0xa28b5854df048bcd5eec522fada1c6b7ea006aae_ext.sol,FIREDICE.collect,192,195,"TMP_93 = CONVERT this to address,TMP_94(uint256) = SOLIDITY_CALL balance(address)(TMP_93),TMP_95(bool) = TMP_94 > _amount,TMP_96(None) = SOLIDITY_CALL require(bool)(TMP_95),Transfer dest:owner value:_amount,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(address(this).balance > _amount)

IRs:
TMP_93 = CONVERT this to address
TMP_94(uint256) = SOLIDITY_CALL balance(address)(TMP_93)
TMP_95(bool) = TMP_94 > _amount
TMP_96(None) = SOLIDITY_CALL require(bool)(TMP_95)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(_amount)

IRs:
Transfer dest:owner value:_amount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();require(bool)(address(this).balance > _amount);owner.transfer(_amount)
./0x347925b22d0217a4797f470faa2afebbdb150b7a_ext.sol,Nanotechnology.getTokens,182,242,"tokens(uint256) := 0(uint256),bonus(uint256) := 0(uint256),countbonus(uint256) := 0(uint256),TMP_45(uint256) = 1000000000000000000 / 10,bonusCond1(uint256) := TMP_45(uint256),bonusCond2(uint256) := 1000000000000000000(uint256),bonusCond3(uint256) := 5000000000000000000(uint256),TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_47(uint256) = TMP_46 / 1000000000000000000,tokens(uint256) := TMP_47(uint256),investor(address) := msg.sender(address),TMP_48(bool) = msg.value >= requestMinimum,TMP_49(bool) = now < deadline,TMP_50(bool) = TMP_48 && TMP_49,TMP_51(bool) = now < round1,TMP_52(bool) = TMP_50 && TMP_51,TMP_53(bool) = now < round2,TMP_54(bool) = TMP_52 && TMP_53,CONDITION TMP_54,TMP_55(bool) = msg.value >= bonusCond1,TMP_56(bool) = msg.value < bonusCond2,TMP_57(bool) = TMP_55 && TMP_56,CONDITION TMP_57,TMP_58(uint256) = tokens * 1,TMP_59(uint256) = TMP_58 / 10,countbonus(uint256) := TMP_59(uint256),TMP_60(bool) = msg.value >= bonusCond2,TMP_61(bool) = msg.value < bonusCond3,TMP_62(bool) = TMP_60 && TMP_61,CONDITION TMP_62,TMP_63(uint256) = tokens * 2,TMP_64(uint256) = TMP_63 / 10,countbonus(uint256) := TMP_64(uint256),TMP_65(bool) = msg.value >= bonusCond3,CONDITION TMP_65,TMP_66(uint256) = tokens * 3,TMP_67(uint256) = TMP_66 / 100,countbonus(uint256) := TMP_67(uint256),TMP_68(bool) = msg.value >= requestMinimum,TMP_69(bool) = now < deadline,TMP_70(bool) = TMP_68 && TMP_69,TMP_71(bool) = now > round1,TMP_72(bool) = TMP_70 && TMP_71,TMP_73(bool) = now < round2,TMP_74(bool) = TMP_72 && TMP_73,CONDITION TMP_74,TMP_75(bool) = msg.value >= bonusCond2,TMP_76(bool) = msg.value < bonusCond3,TMP_77(bool) = TMP_75 && TMP_76,CONDITION TMP_77,TMP_78(uint256) = tokens * 2,TMP_79(uint256) = TMP_78 / 100,countbonus(uint256) := TMP_79(uint256),TMP_80(bool) = msg.value >= bonusCond3,CONDITION TMP_80,TMP_81(uint256) = tokens * 3,TMP_82(uint256) = TMP_81 / 100,countbonus(uint256) := TMP_82(uint256),countbonus(uint256) := 0(uint256),TMP_83(uint256) = tokens + countbonus,bonus(uint256) := TMP_83(uint256),TMP_84(bool) = tokens == 0,CONDITION TMP_84,valdrop(uint256) := 10(uint256),REF_12(bool) -> Claimed[investor],TMP_85(bool) = REF_12 == False,TMP_86(bool) = progress0drop <= target0drop,TMP_87(bool) = TMP_85 && TMP_86,CONDITION TMP_87,TMP_88(bool) = INTERNAL_CALL, Nanotechnology.distr(address,uint256)(investor,valdrop),REF_13(bool) -> Claimed[investor],REF_13(bool) (->Claimed) := True(bool),TMP_89(uint256) := progress0drop(uint256),progress0drop(uint256) = progress0drop + 1,TMP_90(bool) = msg.value >= requestMinimum,TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),TMP_92(bool) = tokens > 0,TMP_93(bool) = msg.value >= requestMinimum,TMP_94(bool) = TMP_92 && TMP_93,CONDITION TMP_94,TMP_95(bool) = now >= deadline,TMP_96(bool) = now >= round1,TMP_97(bool) = TMP_95 && TMP_96,TMP_98(bool) = now < round2,TMP_99(bool) = TMP_97 && TMP_98,CONDITION TMP_99,TMP_100(bool) = INTERNAL_CALL, Nanotechnology.distr(address,uint256)(investor,tokens),TMP_101(bool) = msg.value >= bonusCond1,CONDITION TMP_101,TMP_102(bool) = INTERNAL_CALL, Nanotechnology.distr(address,uint256)(investor,bonus),TMP_103(bool) = INTERNAL_CALL, Nanotechnology.distr(address,uint256)(investor,tokens),TMP_104(bool) = msg.value >= requestMinimum,TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104),TMP_106(bool) = totalDistributed >= totalSupply,CONDITION TMP_106,distributionFinished(bool) := True(bool),Transfer dest:multisig value:msg.value,MODIFIER_CALL, Nanotechnology.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->53;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bonusCond1 = 1000000000000000000 / 10

IRs:
TMP_45(uint256) = 1000000000000000000 / 10
bonusCond1(uint256) := TMP_45(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bonusCond2 = 1000000000000000000

IRs:
bonusCond2(uint256) := 1000000000000000000(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
bonusCond3 = 5000000000000000000

IRs:
bonusCond3(uint256) := 5000000000000000000(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_47(uint256) = TMP_46 / 1000000000000000000
tokens(uint256) := TMP_47(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now < round1 && now < round2

IRs:
TMP_48(bool) = msg.value >= requestMinimum
TMP_49(bool) = now < deadline
TMP_50(bool) = TMP_48 && TMP_49
TMP_51(bool) = now < round1
TMP_52(bool) = TMP_50 && TMP_51
TMP_53(bool) = now < round2
TMP_54(bool) = TMP_52 && TMP_53
CONDITION TMP_54""];
9->10[label=""True""];
9->19[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
msg.value >= bonusCond1 && msg.value < bonusCond2

IRs:
TMP_55(bool) = msg.value >= bonusCond1
TMP_56(bool) = msg.value < bonusCond2
TMP_57(bool) = TMP_55 && TMP_56
CONDITION TMP_57""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
countbonus = tokens * 1 / 10

IRs:
TMP_58(uint256) = tokens * 1
TMP_59(uint256) = TMP_58 / 10
countbonus(uint256) := TMP_59(uint256)""];
11->18;
12[label=""Node Type: IF 12

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_60(bool) = msg.value >= bonusCond2
TMP_61(bool) = msg.value < bonusCond3
TMP_62(bool) = TMP_60 && TMP_61
CONDITION TMP_62""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
countbonus = tokens * 2 / 10

IRs:
TMP_63(uint256) = tokens * 2
TMP_64(uint256) = TMP_63 / 10
countbonus(uint256) := TMP_64(uint256)""];
13->17;
14[label=""Node Type: IF 14

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_65(bool) = msg.value >= bonusCond3
CONDITION TMP_65""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
countbonus = tokens * 3 / 100

IRs:
TMP_66(uint256) = tokens * 3
TMP_67(uint256) = TMP_66 / 100
countbonus(uint256) := TMP_67(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->28;
19[label=""Node Type: IF 19

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now > round1 && now < round2

IRs:
TMP_68(bool) = msg.value >= requestMinimum
TMP_69(bool) = now < deadline
TMP_70(bool) = TMP_68 && TMP_69
TMP_71(bool) = now > round1
TMP_72(bool) = TMP_70 && TMP_71
TMP_73(bool) = now < round2
TMP_74(bool) = TMP_72 && TMP_73
CONDITION TMP_74""];
19->20[label=""True""];
19->26[label=""False""];
20[label=""Node Type: IF 20

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_75(bool) = msg.value >= bonusCond2
TMP_76(bool) = msg.value < bonusCond3
TMP_77(bool) = TMP_75 && TMP_76
CONDITION TMP_77""];
20->21[label=""True""];
20->22[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
countbonus = tokens * 2 / 100

IRs:
TMP_78(uint256) = tokens * 2
TMP_79(uint256) = TMP_78 / 100
countbonus(uint256) := TMP_79(uint256)""];
21->25;
22[label=""Node Type: IF 22

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_80(bool) = msg.value >= bonusCond3
CONDITION TMP_80""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
countbonus = tokens * 3 / 100

IRs:
TMP_81(uint256) = tokens * 3
TMP_82(uint256) = TMP_81 / 100
countbonus(uint256) := TMP_82(uint256)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->27;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
bonus = tokens + countbonus

IRs:
TMP_83(uint256) = tokens + countbonus
bonus(uint256) := TMP_83(uint256)""];
29->30;
30[label=""Node Type: IF 30

EXPRESSION:
tokens == 0

IRs:
TMP_84(bool) = tokens == 0
CONDITION TMP_84""];
30->31[label=""True""];
30->38[label=""False""];
31[label=""Node Type: NEW VARIABLE 31

EXPRESSION:
valdrop = 1e1

IRs:
valdrop(uint256) := 10(uint256)""];
31->32;
32[label=""Node Type: IF 32

EXPRESSION:
Claimed[investor] == false && progress0drop <= target0drop

IRs:
REF_12(bool) -> Claimed[investor]
TMP_85(bool) = REF_12 == False
TMP_86(bool) = progress0drop <= target0drop
TMP_87(bool) = TMP_85 && TMP_86
CONDITION TMP_87""];
32->33[label=""True""];
32->36[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
distr(investor,valdrop)

IRs:
TMP_88(bool) = INTERNAL_CALL, Nanotechnology.distr(address,uint256)(investor,valdrop)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
Claimed[investor] = true

IRs:
REF_13(bool) -> Claimed[investor]
REF_13(bool) (->Claimed) := True(bool)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
progress0drop ++

IRs:
TMP_89(uint256) := progress0drop(uint256)
progress0drop(uint256) = progress0drop + 1""];
35->37;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_90(bool) = msg.value >= requestMinimum
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
36->37;
37[label=""Node Type: END_IF 37
""];
37->48;
38[label=""Node Type: IF 38

EXPRESSION:
tokens > 0 && msg.value >= requestMinimum

IRs:
TMP_92(bool) = tokens > 0
TMP_93(bool) = msg.value >= requestMinimum
TMP_94(bool) = TMP_92 && TMP_93
CONDITION TMP_94""];
38->39[label=""True""];
38->46[label=""False""];
39[label=""Node Type: IF 39

EXPRESSION:
now >= deadline && now >= round1 && now < round2

IRs:
TMP_95(bool) = now >= deadline
TMP_96(bool) = now >= round1
TMP_97(bool) = TMP_95 && TMP_96
TMP_98(bool) = now < round2
TMP_99(bool) = TMP_97 && TMP_98
CONDITION TMP_99""];
39->40[label=""True""];
39->41[label=""False""];
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_100(bool) = INTERNAL_CALL, Nanotechnology.distr(address,uint256)(investor,tokens)""];
40->45;
41[label=""Node Type: IF 41

EXPRESSION:
msg.value >= bonusCond1

IRs:
TMP_101(bool) = msg.value >= bonusCond1
CONDITION TMP_101""];
41->42[label=""True""];
41->43[label=""False""];
42[label=""Node Type: EXPRESSION 42

EXPRESSION:
distr(investor,bonus)

IRs:
TMP_102(bool) = INTERNAL_CALL, Nanotechnology.distr(address,uint256)(investor,bonus)""];
42->44;
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_103(bool) = INTERNAL_CALL, Nanotechnology.distr(address,uint256)(investor,tokens)""];
43->44;
44[label=""Node Type: END_IF 44
""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->47;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_104(bool) = msg.value >= requestMinimum
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: IF 49

EXPRESSION:
totalDistributed >= totalSupply

IRs:
TMP_106(bool) = totalDistributed >= totalSupply
CONDITION TMP_106""];
49->50[label=""True""];
49->51[label=""False""];
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
multisig.transfer(msg.value)

IRs:
Transfer dest:multisig value:msg.value""];
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, Nanotechnology.canDistr()()""];
53->1;
}
",0,0,1,0,"canDistr();tokens = 0;bonus = 0;countbonus = 0;bonusCond1 = 1000000000000000000 / 10;bonusCond2 = 1000000000000000000;bonusCond3 = 5000000000000000000;tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;investor = msg.sender;msg.value >= requestMinimum && now < deadline && now < round1 && now < round2;msg.value >= bonusCond1 && msg.value < bonusCond2;msg.value >= requestMinimum && now < deadline && now > round1 && now < round2;countbonus = tokens * 1 / 10;msg.value >= bonusCond2 && msg.value < bonusCond3;;countbonus = tokens * 2 / 10;msg.value >= bonusCond3;;countbonus = tokens * 3 / 100;;;msg.value >= bonusCond2 && msg.value < bonusCond3;countbonus = 0;countbonus = tokens * 2 / 100;msg.value >= bonusCond3;;countbonus = tokens * 3 / 100;;;bonus = tokens + countbonus;tokens == 0;valdrop = 1e1;tokens > 0 && msg.value >= requestMinimum;Claimed[investor] == false && progress0drop <= target0drop;distr(investor,valdrop);require(bool)(msg.value >= requestMinimum);Claimed[investor] = true;progress0drop ++;;;now >= deadline && now >= round1 && now < round2;require(bool)(msg.value >= requestMinimum);distr(investor,tokens);msg.value >= bonusCond1;;distr(investor,bonus);distr(investor,tokens);;;totalDistributed >= totalSupply;distributionFinished = true;;multisig.transfer(msg.value)"
./0xe3ec74dbce6ee1d8680e38714b67ab5535c95bdb_ext.sol,try_it.Try,6,13,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x0dd88f1d1cbc9bcdda5ddd9e9fc86e8183f8f3b9_ext.sol,XenoxCoin.withdraw,302,305,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, XenoxCoin.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, XenoxCoin.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x8bf1e43e3ca6f5c25c380803154ae687d682ad32_ext.sol,RDFDM.ethToFiat,197,208,"TMP_30(bool) = _charity < charityCount,TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30),REF_24(RDFDM.Charity) -> charities[_charity],REF_25(uint256) -> REF_24.ethBalance,TMP_32(bool) = REF_25 >= _eth,TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32),REF_26(RDFDM.Charity) -> charities[_charity],REF_27(uint256) -> REF_26.ethToFiatPriceAccFiat,REF_27(-> charities) = REF_27 + _fiat,REF_28(RDFDM.Charity) -> charities[_charity],REF_29(uint256) -> REF_28.ethToFiatPriceAccEth,REF_29(-> charities) = REF_29 + _eth,REF_30(RDFDM.Charity) -> charities[_charity],REF_31(uint256) -> REF_30.ethBalance,REF_31(-> charities) = REF_31 - _eth,REF_32(RDFDM.Charity) -> charities[_charity],REF_33(uint256) -> REF_32.fiatBalanceOut,REF_33(-> charities) = REF_33 + _fiat,Transfer dest:msg.sender value:_eth,Emit EthToFiatEvent(_charity,_eth,_fiat),MODIFIER_CALL, RDFDM.managerOnly()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_charity < charityCount)

IRs:
TMP_30(bool) = _charity < charityCount
TMP_31(None) = SOLIDITY_CALL require(bool)(TMP_30)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(charities[_charity].ethBalance >= _eth)

IRs:
REF_24(RDFDM.Charity) -> charities[_charity]
REF_25(uint256) -> REF_24.ethBalance
TMP_32(bool) = REF_25 >= _eth
TMP_33(None) = SOLIDITY_CALL require(bool)(TMP_32)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
charities[_charity].ethToFiatPriceAccFiat += _fiat

IRs:
REF_26(RDFDM.Charity) -> charities[_charity]
REF_27(uint256) -> REF_26.ethToFiatPriceAccFiat
REF_27(-> charities) = REF_27 + _fiat""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
charities[_charity].ethToFiatPriceAccEth += _eth

IRs:
REF_28(RDFDM.Charity) -> charities[_charity]
REF_29(uint256) -> REF_28.ethToFiatPriceAccEth
REF_29(-> charities) = REF_29 + _eth""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
charities[_charity].ethBalance -= _eth

IRs:
REF_30(RDFDM.Charity) -> charities[_charity]
REF_31(uint256) -> REF_30.ethBalance
REF_31(-> charities) = REF_31 - _eth""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
charities[_charity].fiatBalanceOut += _fiat

IRs:
REF_32(RDFDM.Charity) -> charities[_charity]
REF_33(uint256) -> REF_32.fiatBalanceOut
REF_33(-> charities) = REF_33 + _fiat""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
msg.sender.transfer(_eth)

IRs:
Transfer dest:msg.sender value:_eth""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
EthToFiatEvent(_charity,_eth,_fiat)

IRs:
Emit EthToFiatEvent(_charity,_eth,_fiat)""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
managerOnly()

IRs:
MODIFIER_CALL, RDFDM.managerOnly()()""];
9->1;
}
",0,0,1,0,"managerOnly();require(bool)(_charity < charityCount);require(bool)(charities[_charity].ethBalance >= _eth);charities[_charity].ethToFiatPriceAccFiat += _fiat;charities[_charity].ethToFiatPriceAccEth += _eth;charities[_charity].ethBalance -= _eth;charities[_charity].fiatBalanceOut += _fiat;msg.sender.transfer(_eth);EthToFiatEvent(_charity,_eth,_fiat)"
./0xbd6a3418cb51418c94cc11d2d49012a2b79e10fe_ext.sol,WeaponSales.withdrawBalance,256,260,"REF_166(uint256) = SOLIDITY_CALL balance(address)(this),TMP_280(bool) = _amount <= REF_166,TMP_281(None) = SOLIDITY_CALL require(bool)(TMP_280),Transfer dest:msg.sender value:_amount,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_amount <= this.balance)

IRs:
REF_166(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_280(bool) = _amount <= REF_166
TMP_281(None) = SOLIDITY_CALL require(bool)(TMP_280)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(_amount)

IRs:
Transfer dest:msg.sender value:_amount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();require(bool)(_amount <= this.balance);msg.sender.transfer(_amount)
./0x2671bf62fdf173cfcb4b178d1a563ca84a349dc3_ext.sol,D_QUIZ.Stop,26,28,"REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3,MODIFIER_CALL, D_QUIZ.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, D_QUIZ.isAdmin()()""];
2->1;
}
",0,0,1,0,isAdmin();msg.sender.transfer(this.balance)
./0x33147d0f721ddfd82408dd1c890eff4ad7ecd80e_ext.sol,TokenERC20.selfdestructs,215,217,"TMP_93(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_93(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0xd745a7883a6bd19389b6b9dc8580c2ff873f0cd1_ext.sol,Earthpayment.safeWithdrawal,304,309,"TMP_97(bool) = _value == 0,CONDITION TMP_97,TMP_98 = CONVERT this to address,TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98),Transfer dest:owner value:TMP_99,Transfer dest:owner value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_97(bool) = _value == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_98 = CONVERT this to address
TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98)
Transfer dest:owner value:TMP_99""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_value == 0;owner.transfer(address(this).balance);owner.transfer(_value);
./0x555744471e00a4bf8ec403c47e06f38db6096a02_ext.sol,InitialSaleSQD.WithdrawAllETH,541,543,"Transfer dest:beneficiary value:amountRaised,MODIFIER_CALL, InitialSaleSQD.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
beneficiary.transfer(amountRaised)

IRs:
Transfer dest:beneficiary value:amountRaised""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, InitialSaleSQD.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();beneficiary.transfer(amountRaised)
./0x6ceb458fac48cf87b420f23b0d890534655683e0_ext.sol,FrostByte.sendEther,112,117,"Transfer dest:x value:msg.value,INTERNAL_CALL, FBT.refundFees()(),Emit etherSent(msg.value)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
x.transfer(msg.value)

IRs:
Transfer dest:x value:msg.value""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
refundFees()

IRs:
INTERNAL_CALL, FBT.refundFees()()""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
etherSent(msg.value)

IRs:
Emit etherSent(msg.value)""];
}
",0,0,1,0,x.transfer(msg.value);refundFees();etherSent(msg.value)
./0x579fa0a1872459138aad423644c9c5038fa31807_ext.sol,AccessService.withdraw,79,91,"TMP_37(bool) = msg.sender == addrFinance,TMP_38(bool) = msg.sender == addrAdmin,TMP_39(bool) = TMP_37 || TMP_38,TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39),TMP_41(bool) = _amount > 0,TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41),REF_0(uint256) = SOLIDITY_CALL balance(address)(this),balance(uint256) := REF_0([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B6BE4850>]),TMP_43(bool) = _amount < balance,CONDITION TMP_43,Transfer dest:receiver value:_amount,REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:receiver value:REF_3,TMP_46 = CONVERT 0 to address,TMP_47(bool) = _target == TMP_46,CONDITION TMP_47,receiver(address) := addrFinance(address),receiver(address) := _target(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == addrFinance || msg.sender == addrAdmin)

IRs:
TMP_37(bool) = msg.sender == addrFinance
TMP_38(bool) = msg.sender == addrAdmin
TMP_39(bool) = TMP_37 || TMP_38
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amount > 0)

IRs:
TMP_41(bool) = _amount > 0
TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)""];
2->9;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
balance = this.balance

IRs:
REF_0(uint256) = SOLIDITY_CALL balance(address)(this)
balance(uint256) := REF_0([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x00000188B6BE4850>])""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
_amount < balance

IRs:
TMP_43(bool) = _amount < balance
CONDITION TMP_43""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
receiver.transfer(_amount)

IRs:
Transfer dest:receiver value:_amount""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
receiver.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:receiver value:REF_3""];
7->8;
8[label=""Node Type: END_IF 8
""];
9[label=""Node Type: IF 9

EXPRESSION:
_target == address(0)

IRs:
TMP_46 = CONVERT 0 to address
TMP_47(bool) = _target == TMP_46
CONDITION TMP_47""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
receiver = addrFinance

IRs:
receiver(address) := addrFinance(address)""];
10->12;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
receiver = _target

IRs:
receiver(address) := _target(address)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->4;
}
",0,0,1,0,require(bool)(msg.sender == addrFinance || msg.sender == addrAdmin);require(bool)(_amount > 0);_target == address(0);balance = this.balance;_amount < balance;receiver.transfer(_amount);receiver.transfer(this.balance);;receiver = addrFinance;receiver = _target;
./0x53c3c2eae35cbd790c3a90d8f1b2878ba523f01b_ext.sol,GreenEthereusPromo.massSending,73,82,"i(uint256) := 0(uint256),REF_0 -> LENGTH _addresses,TMP_2(bool) = i < REF_0,CONDITION TMP_2,REF_1(address) -> _addresses[i],TMP_3 = SEND dest:REF_1 value:777,REF_3(address) -> _addresses[i],Emit Transfer(0,REF_3,777),TMP_5(uint256) = SOLIDITY_CALL gasleft()(),TMP_6(bool) = TMP_5 <= 50000,CONDITION TMP_6,index(uint256) := i(uint256),TMP_7(uint256) := i(uint256),i(uint256) = i + 1,MODIFIER_CALL, GreenEthereusPromo.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->12;
1[label=""Node Type: BEGIN_LOOP 1
""];
1->4;
2[label=""Node Type: END_LOOP 2
""];
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
i = 0

IRs:
i(uint256) := 0(uint256)""];
3->1;
4[label=""Node Type: IF_LOOP 4

EXPRESSION:
i < _addresses.length

IRs:
REF_0 -> LENGTH _addresses
TMP_2(bool) = i < REF_0
CONDITION TMP_2""];
4->5[label=""True""];
4->2[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_addresses[i].send(777)

IRs:
REF_1(address) -> _addresses[i]
TMP_3 = SEND dest:REF_1 value:777""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
Transfer(0x0,_addresses[i],777)

IRs:
REF_3(address) -> _addresses[i]
Emit Transfer(0,REF_3,777)""];
6->7;
7[label=""Node Type: IF 7

EXPRESSION:
gasleft()() <= 50000

IRs:
TMP_5(uint256) = SOLIDITY_CALL gasleft()()
TMP_6(bool) = TMP_5 <= 50000
CONDITION TMP_6""];
7->8[label=""True""];
7->10[label=""False""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
index = i

IRs:
index(uint256) := i(uint256)""];
8->9;
9[label=""Node Type: BREAK 9
""];
9->2;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
i ++

IRs:
TMP_7(uint256) := i(uint256)
i(uint256) = i + 1""];
11->4;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, GreenEthereusPromo.onlyOwner()()""];
12->3;
}
",0,0,1,0,"onlyOwner();;i < _addresses.length;;i = 0;_addresses[i].send(777);Transfer(0x0,_addresses[i],777);gasleft()() <= 50000;index = i;;;i ++"
./0x3a4b1eca26955fba4b99f78ee36153eacdceae85_ext.sol,EdexStore.withdraw,294,297,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, EdexStore.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, EdexStore.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0x4cda22125752e0f17fe27add1c3f3e9669876c98_ext.sol,PLAY_QZ.Stop,26,28,"REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3,MODIFIER_CALL, PLAY_QZ.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, PLAY_QZ.isAdmin()()""];
2->1;
}
",0,0,1,0,isAdmin();msg.sender.transfer(this.balance)
./0x6a2b112e5314a3462a3df18c0b73a2de14fd6b06_ext.sol,ClockAuction.withdrawBalance,999,1003,"TMP_771 = CONVERT nonFungibleContract to address,nftAddress(address) := TMP_771(address),TMP_772(bool) = msg.sender == owner,TMP_773(bool) = msg.sender == nftAddress,TMP_774(bool) = TMP_772 || TMP_773,TMP_775(None) = SOLIDITY_CALL require(bool)(TMP_774),TMP_776 = CONVERT this to address,TMP_777(uint256) = SOLIDITY_CALL balance(address)(TMP_776),Transfer dest:owner value:TMP_777","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
nftAddress = address(nonFungibleContract)

IRs:
TMP_771 = CONVERT nonFungibleContract to address
nftAddress(address) := TMP_771(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == owner || msg.sender == nftAddress)

IRs:
TMP_772(bool) = msg.sender == owner
TMP_773(bool) = msg.sender == nftAddress
TMP_774(bool) = TMP_772 || TMP_773
TMP_775(None) = SOLIDITY_CALL require(bool)(TMP_774)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_776 = CONVERT this to address
TMP_777(uint256) = SOLIDITY_CALL balance(address)(TMP_776)
Transfer dest:owner value:TMP_777""];
}
",0,0,1,0,nftAddress = address(nonFungibleContract);require(bool)(msg.sender == owner || msg.sender == nftAddress);owner.transfer(address(this).balance)
./0x70d0907b064ab5c86849d391124f62ce9bcbf597_ext.sol,Fastbitcoin.getTokens,181,241,"tokens(uint256) := 0(uint256),bonus(uint256) := 0(uint256),countbonus(uint256) := 0(uint256),TMP_45(uint256) = 1000000000000000000 / 10,bonusCond1(uint256) := TMP_45(uint256),bonusCond2(uint256) := 1000000000000000000(uint256),bonusCond3(uint256) := 5000000000000000000(uint256),TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_47(uint256) = TMP_46 / 1000000000000000000,tokens(uint256) := TMP_47(uint256),investor(address) := msg.sender(address),TMP_48(bool) = msg.value >= requestMinimum,TMP_49(bool) = now < deadline,TMP_50(bool) = TMP_48 && TMP_49,TMP_51(bool) = now < round1,TMP_52(bool) = TMP_50 && TMP_51,TMP_53(bool) = now < round2,TMP_54(bool) = TMP_52 && TMP_53,CONDITION TMP_54,TMP_55(bool) = msg.value >= bonusCond1,TMP_56(bool) = msg.value < bonusCond2,TMP_57(bool) = TMP_55 && TMP_56,CONDITION TMP_57,TMP_58(uint256) = tokens * 5,TMP_59(uint256) = TMP_58 / 100,countbonus(uint256) := TMP_59(uint256),TMP_60(bool) = msg.value >= bonusCond2,TMP_61(bool) = msg.value < bonusCond3,TMP_62(bool) = TMP_60 && TMP_61,CONDITION TMP_62,TMP_63(uint256) = tokens * 10,TMP_64(uint256) = TMP_63 / 100,countbonus(uint256) := TMP_64(uint256),TMP_65(bool) = msg.value >= bonusCond3,CONDITION TMP_65,TMP_66(uint256) = tokens * 15,TMP_67(uint256) = TMP_66 / 100,countbonus(uint256) := TMP_67(uint256),TMP_68(bool) = msg.value >= requestMinimum,TMP_69(bool) = now < deadline,TMP_70(bool) = TMP_68 && TMP_69,TMP_71(bool) = now > round1,TMP_72(bool) = TMP_70 && TMP_71,TMP_73(bool) = now < round2,TMP_74(bool) = TMP_72 && TMP_73,CONDITION TMP_74,TMP_75(bool) = msg.value >= bonusCond2,TMP_76(bool) = msg.value < bonusCond3,TMP_77(bool) = TMP_75 && TMP_76,CONDITION TMP_77,TMP_78(uint256) = tokens * 5,TMP_79(uint256) = TMP_78 / 100,countbonus(uint256) := TMP_79(uint256),TMP_80(bool) = msg.value >= bonusCond3,CONDITION TMP_80,TMP_81(uint256) = tokens * 10,TMP_82(uint256) = TMP_81 / 100,countbonus(uint256) := TMP_82(uint256),countbonus(uint256) := 0(uint256),TMP_83(uint256) = tokens + countbonus,bonus(uint256) := TMP_83(uint256),TMP_84(bool) = tokens == 0,CONDITION TMP_84,valdrop(uint256) := 500000000000(uint256),REF_12(bool) -> Claimed[investor],TMP_85(bool) = REF_12 == False,TMP_86(bool) = progress0drop <= target0drop,TMP_87(bool) = TMP_85 && TMP_86,CONDITION TMP_87,TMP_88(bool) = INTERNAL_CALL, Fastbitcoin.distr(address,uint256)(investor,valdrop),REF_13(bool) -> Claimed[investor],REF_13(bool) (->Claimed) := True(bool),TMP_89(uint256) := progress0drop(uint256),progress0drop(uint256) = progress0drop + 1,TMP_90(bool) = msg.value >= requestMinimum,TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),TMP_92(bool) = tokens > 0,TMP_93(bool) = msg.value >= requestMinimum,TMP_94(bool) = TMP_92 && TMP_93,CONDITION TMP_94,TMP_95(bool) = now >= deadline,TMP_96(bool) = now >= round1,TMP_97(bool) = TMP_95 && TMP_96,TMP_98(bool) = now < round2,TMP_99(bool) = TMP_97 && TMP_98,CONDITION TMP_99,TMP_100(bool) = INTERNAL_CALL, Fastbitcoin.distr(address,uint256)(investor,tokens),TMP_101(bool) = msg.value >= bonusCond1,CONDITION TMP_101,TMP_102(bool) = INTERNAL_CALL, Fastbitcoin.distr(address,uint256)(investor,bonus),TMP_103(bool) = INTERNAL_CALL, Fastbitcoin.distr(address,uint256)(investor,tokens),TMP_104(bool) = msg.value >= requestMinimum,TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104),TMP_106(bool) = totalDistributed >= totalSupply,CONDITION TMP_106,distributionFinished(bool) := True(bool),Transfer dest:multisig value:msg.value,MODIFIER_CALL, Fastbitcoin.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->53;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bonusCond1 = 1000000000000000000 / 10

IRs:
TMP_45(uint256) = 1000000000000000000 / 10
bonusCond1(uint256) := TMP_45(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bonusCond2 = 1000000000000000000

IRs:
bonusCond2(uint256) := 1000000000000000000(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
bonusCond3 = 5000000000000000000

IRs:
bonusCond3(uint256) := 5000000000000000000(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_47(uint256) = TMP_46 / 1000000000000000000
tokens(uint256) := TMP_47(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now < round1 && now < round2

IRs:
TMP_48(bool) = msg.value >= requestMinimum
TMP_49(bool) = now < deadline
TMP_50(bool) = TMP_48 && TMP_49
TMP_51(bool) = now < round1
TMP_52(bool) = TMP_50 && TMP_51
TMP_53(bool) = now < round2
TMP_54(bool) = TMP_52 && TMP_53
CONDITION TMP_54""];
9->10[label=""True""];
9->19[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
msg.value >= bonusCond1 && msg.value < bonusCond2

IRs:
TMP_55(bool) = msg.value >= bonusCond1
TMP_56(bool) = msg.value < bonusCond2
TMP_57(bool) = TMP_55 && TMP_56
CONDITION TMP_57""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
countbonus = tokens * 5 / 100

IRs:
TMP_58(uint256) = tokens * 5
TMP_59(uint256) = TMP_58 / 100
countbonus(uint256) := TMP_59(uint256)""];
11->18;
12[label=""Node Type: IF 12

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_60(bool) = msg.value >= bonusCond2
TMP_61(bool) = msg.value < bonusCond3
TMP_62(bool) = TMP_60 && TMP_61
CONDITION TMP_62""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
countbonus = tokens * 10 / 100

IRs:
TMP_63(uint256) = tokens * 10
TMP_64(uint256) = TMP_63 / 100
countbonus(uint256) := TMP_64(uint256)""];
13->17;
14[label=""Node Type: IF 14

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_65(bool) = msg.value >= bonusCond3
CONDITION TMP_65""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
countbonus = tokens * 15 / 100

IRs:
TMP_66(uint256) = tokens * 15
TMP_67(uint256) = TMP_66 / 100
countbonus(uint256) := TMP_67(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->28;
19[label=""Node Type: IF 19

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now > round1 && now < round2

IRs:
TMP_68(bool) = msg.value >= requestMinimum
TMP_69(bool) = now < deadline
TMP_70(bool) = TMP_68 && TMP_69
TMP_71(bool) = now > round1
TMP_72(bool) = TMP_70 && TMP_71
TMP_73(bool) = now < round2
TMP_74(bool) = TMP_72 && TMP_73
CONDITION TMP_74""];
19->20[label=""True""];
19->26[label=""False""];
20[label=""Node Type: IF 20

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_75(bool) = msg.value >= bonusCond2
TMP_76(bool) = msg.value < bonusCond3
TMP_77(bool) = TMP_75 && TMP_76
CONDITION TMP_77""];
20->21[label=""True""];
20->22[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
countbonus = tokens * 5 / 100

IRs:
TMP_78(uint256) = tokens * 5
TMP_79(uint256) = TMP_78 / 100
countbonus(uint256) := TMP_79(uint256)""];
21->25;
22[label=""Node Type: IF 22

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_80(bool) = msg.value >= bonusCond3
CONDITION TMP_80""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
countbonus = tokens * 10 / 100

IRs:
TMP_81(uint256) = tokens * 10
TMP_82(uint256) = TMP_81 / 100
countbonus(uint256) := TMP_82(uint256)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->27;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
bonus = tokens + countbonus

IRs:
TMP_83(uint256) = tokens + countbonus
bonus(uint256) := TMP_83(uint256)""];
29->30;
30[label=""Node Type: IF 30

EXPRESSION:
tokens == 0

IRs:
TMP_84(bool) = tokens == 0
CONDITION TMP_84""];
30->31[label=""True""];
30->38[label=""False""];
31[label=""Node Type: NEW VARIABLE 31

EXPRESSION:
valdrop = 5000e8

IRs:
valdrop(uint256) := 500000000000(uint256)""];
31->32;
32[label=""Node Type: IF 32

EXPRESSION:
Claimed[investor] == false && progress0drop <= target0drop

IRs:
REF_12(bool) -> Claimed[investor]
TMP_85(bool) = REF_12 == False
TMP_86(bool) = progress0drop <= target0drop
TMP_87(bool) = TMP_85 && TMP_86
CONDITION TMP_87""];
32->33[label=""True""];
32->36[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
distr(investor,valdrop)

IRs:
TMP_88(bool) = INTERNAL_CALL, Fastbitcoin.distr(address,uint256)(investor,valdrop)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
Claimed[investor] = true

IRs:
REF_13(bool) -> Claimed[investor]
REF_13(bool) (->Claimed) := True(bool)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
progress0drop ++

IRs:
TMP_89(uint256) := progress0drop(uint256)
progress0drop(uint256) = progress0drop + 1""];
35->37;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_90(bool) = msg.value >= requestMinimum
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
36->37;
37[label=""Node Type: END_IF 37
""];
37->48;
38[label=""Node Type: IF 38

EXPRESSION:
tokens > 0 && msg.value >= requestMinimum

IRs:
TMP_92(bool) = tokens > 0
TMP_93(bool) = msg.value >= requestMinimum
TMP_94(bool) = TMP_92 && TMP_93
CONDITION TMP_94""];
38->39[label=""True""];
38->46[label=""False""];
39[label=""Node Type: IF 39

EXPRESSION:
now >= deadline && now >= round1 && now < round2

IRs:
TMP_95(bool) = now >= deadline
TMP_96(bool) = now >= round1
TMP_97(bool) = TMP_95 && TMP_96
TMP_98(bool) = now < round2
TMP_99(bool) = TMP_97 && TMP_98
CONDITION TMP_99""];
39->40[label=""True""];
39->41[label=""False""];
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_100(bool) = INTERNAL_CALL, Fastbitcoin.distr(address,uint256)(investor,tokens)""];
40->45;
41[label=""Node Type: IF 41

EXPRESSION:
msg.value >= bonusCond1

IRs:
TMP_101(bool) = msg.value >= bonusCond1
CONDITION TMP_101""];
41->42[label=""True""];
41->43[label=""False""];
42[label=""Node Type: EXPRESSION 42

EXPRESSION:
distr(investor,bonus)

IRs:
TMP_102(bool) = INTERNAL_CALL, Fastbitcoin.distr(address,uint256)(investor,bonus)""];
42->44;
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_103(bool) = INTERNAL_CALL, Fastbitcoin.distr(address,uint256)(investor,tokens)""];
43->44;
44[label=""Node Type: END_IF 44
""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->47;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_104(bool) = msg.value >= requestMinimum
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: IF 49

EXPRESSION:
totalDistributed >= totalSupply

IRs:
TMP_106(bool) = totalDistributed >= totalSupply
CONDITION TMP_106""];
49->50[label=""True""];
49->51[label=""False""];
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
multisig.transfer(msg.value)

IRs:
Transfer dest:multisig value:msg.value""];
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, Fastbitcoin.canDistr()()""];
53->1;
}
",0,0,1,0,"canDistr();tokens = 0;bonus = 0;countbonus = 0;bonusCond1 = 1000000000000000000 / 10;bonusCond2 = 1000000000000000000;bonusCond3 = 5000000000000000000;tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;investor = msg.sender;msg.value >= requestMinimum && now < deadline && now < round1 && now < round2;msg.value >= bonusCond1 && msg.value < bonusCond2;msg.value >= requestMinimum && now < deadline && now > round1 && now < round2;countbonus = tokens * 5 / 100;msg.value >= bonusCond2 && msg.value < bonusCond3;;countbonus = tokens * 10 / 100;msg.value >= bonusCond3;;countbonus = tokens * 15 / 100;;;msg.value >= bonusCond2 && msg.value < bonusCond3;countbonus = 0;countbonus = tokens * 5 / 100;msg.value >= bonusCond3;;countbonus = tokens * 10 / 100;;;bonus = tokens + countbonus;tokens == 0;valdrop = 5000e8;tokens > 0 && msg.value >= requestMinimum;Claimed[investor] == false && progress0drop <= target0drop;distr(investor,valdrop);require(bool)(msg.value >= requestMinimum);Claimed[investor] = true;progress0drop ++;;;now >= deadline && now >= round1 && now < round2;require(bool)(msg.value >= requestMinimum);distr(investor,tokens);msg.value >= bonusCond1;;distr(investor,bonus);distr(investor,tokens);;;totalDistributed >= totalSupply;distributionFinished = true;;multisig.transfer(msg.value)"
./0x313df3fac623a824c8e64b4c47cf62fe0b75809e_ext.sol,TiqpitCrowdsale.refundPreIco,734,746,"TMP_294(None) = SOLIDITY_CALL require(bool)(hasPreIcoFailed),REF_164(TiqpitCrowdsale.Purchase) -> preIcoPurchases[msg.sender],REF_165(uint256) -> REF_164.burnableTiqs,TMP_295(bool) = REF_165 > 0,REF_166(TiqpitCrowdsale.Purchase) -> preIcoPurchases[msg.sender],REF_167(uint256) -> REF_166.refundableWei,TMP_296(bool) = REF_167 > 0,TMP_297(bool) = TMP_295 && TMP_296,TMP_298(None) = SOLIDITY_CALL require(bool)(TMP_297),REF_168(TiqpitCrowdsale.Purchase) -> preIcoPurchases[msg.sender],REF_169(uint256) -> REF_168.refundableWei,amountWei(uint256) := REF_169(uint256),Transfer dest:msg.sender value:amountWei,REF_171(TiqpitCrowdsale.Purchase) -> preIcoPurchases[msg.sender],REF_172(uint256) -> REF_171.refundableWei,REF_172(uint256) (->preIcoPurchases) := 0(uint256),REF_173(TiqpitCrowdsale.Purchase) -> preIcoPurchases[msg.sender],REF_174(uint256) -> REF_173.burnableTiqs,REF_174(uint256) (->preIcoPurchases) := 0(uint256),HIGH_LEVEL_CALL, dest:token(TiqpitToken), function:burnFromAddress, arguments:['msg.sender']  ","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(hasPreIcoFailed)

IRs:
TMP_294(None) = SOLIDITY_CALL require(bool)(hasPreIcoFailed)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(preIcoPurchases[msg.sender].burnableTiqs > 0 && preIcoPurchases[msg.sender].refundableWei > 0)

IRs:
REF_164(TiqpitCrowdsale.Purchase) -> preIcoPurchases[msg.sender]
REF_165(uint256) -> REF_164.burnableTiqs
TMP_295(bool) = REF_165 > 0
REF_166(TiqpitCrowdsale.Purchase) -> preIcoPurchases[msg.sender]
REF_167(uint256) -> REF_166.refundableWei
TMP_296(bool) = REF_167 > 0
TMP_297(bool) = TMP_295 && TMP_296
TMP_298(None) = SOLIDITY_CALL require(bool)(TMP_297)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
amountWei = preIcoPurchases[msg.sender].refundableWei

IRs:
REF_168(TiqpitCrowdsale.Purchase) -> preIcoPurchases[msg.sender]
REF_169(uint256) -> REF_168.refundableWei
amountWei(uint256) := REF_169(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
msg.sender.transfer(amountWei)

IRs:
Transfer dest:msg.sender value:amountWei""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
preIcoPurchases[msg.sender].refundableWei = 0

IRs:
REF_171(TiqpitCrowdsale.Purchase) -> preIcoPurchases[msg.sender]
REF_172(uint256) -> REF_171.refundableWei
REF_172(uint256) (->preIcoPurchases) := 0(uint256)""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
preIcoPurchases[msg.sender].burnableTiqs = 0

IRs:
REF_173(TiqpitCrowdsale.Purchase) -> preIcoPurchases[msg.sender]
REF_174(uint256) -> REF_173.burnableTiqs
REF_174(uint256) (->preIcoPurchases) := 0(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
token.burnFromAddress(msg.sender)

IRs:
HIGH_LEVEL_CALL, dest:token(TiqpitToken), function:burnFromAddress, arguments:['msg.sender']  ""];
}
",0,0,1,0,require(bool)(hasPreIcoFailed);require(bool)(preIcoPurchases[msg.sender].burnableTiqs > 0 && preIcoPurchases[msg.sender].refundableWei > 0);amountWei = preIcoPurchases[msg.sender].refundableWei;msg.sender.transfer(amountWei);preIcoPurchases[msg.sender].refundableWei = 0;preIcoPurchases[msg.sender].burnableTiqs = 0;token.burnFromAddress(msg.sender)
./0x48ee772b8c8927d8d32afc8961fbc177fb723637_ext.sol,Contribution.kill,252,254,"TMP_166(None) = SOLIDITY_CALL selfdestruct(address)(owner),MODIFIER_CALL, Owned.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
selfdestruct(address)(owner)

IRs:
TMP_166(None) = SOLIDITY_CALL selfdestruct(address)(owner)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Owned.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();selfdestruct(address)(owner)
./0x28a40acf39b1d3c932f42dd8068ad00a5ad6448f_ext.sol,LudumToken.finalizeCrowdsale,201,209,"TMP_117 = UnaryType.BANG isFinalized ,TMP_118(None) = SOLIDITY_CALL require(bool)(TMP_117),TMP_119(bool) = msg.sender == ethDepositAddress,TMP_120(None) = SOLIDITY_CALL require(bool)(TMP_119),TMP_121(bool) = now >= crowdsaleEnd,TMP_122(bool) = totalSupply == maximumSupply,TMP_123(bool) = TMP_121 || TMP_122,TMP_124(None) = SOLIDITY_CALL require(bool)(TMP_123),isFinalized(bool) := True(bool),REF_62(uint256) = SOLIDITY_CALL balance(address)(this),TMP_125 = SEND dest:ethDepositAddress value:REF_62,TMP_126(None) = SOLIDITY_CALL require(bool)(TMP_125)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(! isFinalized)

IRs:
TMP_117 = UnaryType.BANG isFinalized 
TMP_118(None) = SOLIDITY_CALL require(bool)(TMP_117)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(msg.sender == ethDepositAddress)

IRs:
TMP_119(bool) = msg.sender == ethDepositAddress
TMP_120(None) = SOLIDITY_CALL require(bool)(TMP_119)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
require(bool)(now >= crowdsaleEnd || totalSupply == maximumSupply)

IRs:
TMP_121(bool) = now >= crowdsaleEnd
TMP_122(bool) = totalSupply == maximumSupply
TMP_123(bool) = TMP_121 || TMP_122
TMP_124(None) = SOLIDITY_CALL require(bool)(TMP_123)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
isFinalized = true

IRs:
isFinalized(bool) := True(bool)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
require(bool)(ethDepositAddress.send(this.balance))

IRs:
REF_62(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_125 = SEND dest:ethDepositAddress value:REF_62
TMP_126(None) = SOLIDITY_CALL require(bool)(TMP_125)""];
}
",0,0,1,0,require(bool)(! isFinalized);require(bool)(msg.sender == ethDepositAddress);require(bool)(now >= crowdsaleEnd || totalSupply == maximumSupply);isFinalized = true;require(bool)(ethDepositAddress.send(this.balance))
./0x58a687bb4a7a4220e65f9b6f913580e5bec4a7bc_ext.sol,EnergiPlus.getTokens,182,242,"tokens(uint256) := 0(uint256),bonus(uint256) := 0(uint256),countbonus(uint256) := 0(uint256),TMP_45(uint256) = 1000000000000000000 / 10,bonusCond1(uint256) := TMP_45(uint256),TMP_46(uint256) = 5000000000000000000 / 10,bonusCond2(uint256) := TMP_46(uint256),bonusCond3(uint256) := 1000000000000000000(uint256),TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_48(uint256) = TMP_47 / 1000000000000000000,tokens(uint256) := TMP_48(uint256),investor(address) := msg.sender(address),TMP_49(bool) = msg.value >= requestMinimum,TMP_50(bool) = now < deadline,TMP_51(bool) = TMP_49 && TMP_50,TMP_52(bool) = now < round1,TMP_53(bool) = TMP_51 && TMP_52,TMP_54(bool) = now < round2,TMP_55(bool) = TMP_53 && TMP_54,CONDITION TMP_55,TMP_56(bool) = msg.value >= bonusCond1,TMP_57(bool) = msg.value < bonusCond2,TMP_58(bool) = TMP_56 && TMP_57,CONDITION TMP_58,TMP_59(uint256) = tokens * 10,TMP_60(uint256) = TMP_59 / 100,countbonus(uint256) := TMP_60(uint256),TMP_61(bool) = msg.value >= bonusCond2,TMP_62(bool) = msg.value < bonusCond3,TMP_63(bool) = TMP_61 && TMP_62,CONDITION TMP_63,TMP_64(uint256) = tokens * 15,TMP_65(uint256) = TMP_64 / 100,countbonus(uint256) := TMP_65(uint256),TMP_66(bool) = msg.value >= bonusCond3,CONDITION TMP_66,TMP_67(uint256) = tokens * 35,TMP_68(uint256) = TMP_67 / 100,countbonus(uint256) := TMP_68(uint256),TMP_69(bool) = msg.value >= requestMinimum,TMP_70(bool) = now < deadline,TMP_71(bool) = TMP_69 && TMP_70,TMP_72(bool) = now > round1,TMP_73(bool) = TMP_71 && TMP_72,TMP_74(bool) = now < round2,TMP_75(bool) = TMP_73 && TMP_74,CONDITION TMP_75,TMP_76(bool) = msg.value >= bonusCond2,TMP_77(bool) = msg.value < bonusCond3,TMP_78(bool) = TMP_76 && TMP_77,CONDITION TMP_78,TMP_79(uint256) = tokens * 2,TMP_80(uint256) = TMP_79 / 100,countbonus(uint256) := TMP_80(uint256),TMP_81(bool) = msg.value >= bonusCond3,CONDITION TMP_81,TMP_82(uint256) = tokens * 3,TMP_83(uint256) = TMP_82 / 100,countbonus(uint256) := TMP_83(uint256),countbonus(uint256) := 0(uint256),TMP_84(uint256) = tokens + countbonus,bonus(uint256) := TMP_84(uint256),TMP_85(bool) = tokens == 0,CONDITION TMP_85,valdrop(uint256) := 500000000(uint256),REF_12(bool) -> Claimed[investor],TMP_86(bool) = REF_12 == False,TMP_87(bool) = progress0drop <= target0drop,TMP_88(bool) = TMP_86 && TMP_87,CONDITION TMP_88,TMP_89(bool) = INTERNAL_CALL, EnergiPlus.distr(address,uint256)(investor,valdrop),REF_13(bool) -> Claimed[investor],REF_13(bool) (->Claimed) := True(bool),TMP_90(uint256) := progress0drop(uint256),progress0drop(uint256) = progress0drop + 1,TMP_91(bool) = msg.value >= requestMinimum,TMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91),TMP_93(bool) = tokens > 0,TMP_94(bool) = msg.value >= requestMinimum,TMP_95(bool) = TMP_93 && TMP_94,CONDITION TMP_95,TMP_96(bool) = now >= deadline,TMP_97(bool) = now >= round1,TMP_98(bool) = TMP_96 && TMP_97,TMP_99(bool) = now < round2,TMP_100(bool) = TMP_98 && TMP_99,CONDITION TMP_100,TMP_101(bool) = INTERNAL_CALL, EnergiPlus.distr(address,uint256)(investor,tokens),TMP_102(bool) = msg.value >= bonusCond1,CONDITION TMP_102,TMP_103(bool) = INTERNAL_CALL, EnergiPlus.distr(address,uint256)(investor,bonus),TMP_104(bool) = INTERNAL_CALL, EnergiPlus.distr(address,uint256)(investor,tokens),TMP_105(bool) = msg.value >= requestMinimum,TMP_106(None) = SOLIDITY_CALL require(bool)(TMP_105),TMP_107(bool) = totalDistributed >= totalSupply,CONDITION TMP_107,distributionFinished(bool) := True(bool),Transfer dest:multisig value:msg.value,MODIFIER_CALL, EnergiPlus.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->53;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bonusCond1 = 1000000000000000000 / 10

IRs:
TMP_45(uint256) = 1000000000000000000 / 10
bonusCond1(uint256) := TMP_45(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bonusCond2 = 5000000000000000000 / 10

IRs:
TMP_46(uint256) = 5000000000000000000 / 10
bonusCond2(uint256) := TMP_46(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
bonusCond3 = 1000000000000000000

IRs:
bonusCond3(uint256) := 1000000000000000000(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_47(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_48(uint256) = TMP_47 / 1000000000000000000
tokens(uint256) := TMP_48(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now < round1 && now < round2

IRs:
TMP_49(bool) = msg.value >= requestMinimum
TMP_50(bool) = now < deadline
TMP_51(bool) = TMP_49 && TMP_50
TMP_52(bool) = now < round1
TMP_53(bool) = TMP_51 && TMP_52
TMP_54(bool) = now < round2
TMP_55(bool) = TMP_53 && TMP_54
CONDITION TMP_55""];
9->10[label=""True""];
9->19[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
msg.value >= bonusCond1 && msg.value < bonusCond2

IRs:
TMP_56(bool) = msg.value >= bonusCond1
TMP_57(bool) = msg.value < bonusCond2
TMP_58(bool) = TMP_56 && TMP_57
CONDITION TMP_58""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
countbonus = tokens * 10 / 100

IRs:
TMP_59(uint256) = tokens * 10
TMP_60(uint256) = TMP_59 / 100
countbonus(uint256) := TMP_60(uint256)""];
11->18;
12[label=""Node Type: IF 12

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_61(bool) = msg.value >= bonusCond2
TMP_62(bool) = msg.value < bonusCond3
TMP_63(bool) = TMP_61 && TMP_62
CONDITION TMP_63""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
countbonus = tokens * 15 / 100

IRs:
TMP_64(uint256) = tokens * 15
TMP_65(uint256) = TMP_64 / 100
countbonus(uint256) := TMP_65(uint256)""];
13->17;
14[label=""Node Type: IF 14

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_66(bool) = msg.value >= bonusCond3
CONDITION TMP_66""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
countbonus = tokens * 35 / 100

IRs:
TMP_67(uint256) = tokens * 35
TMP_68(uint256) = TMP_67 / 100
countbonus(uint256) := TMP_68(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->28;
19[label=""Node Type: IF 19

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now > round1 && now < round2

IRs:
TMP_69(bool) = msg.value >= requestMinimum
TMP_70(bool) = now < deadline
TMP_71(bool) = TMP_69 && TMP_70
TMP_72(bool) = now > round1
TMP_73(bool) = TMP_71 && TMP_72
TMP_74(bool) = now < round2
TMP_75(bool) = TMP_73 && TMP_74
CONDITION TMP_75""];
19->20[label=""True""];
19->26[label=""False""];
20[label=""Node Type: IF 20

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_76(bool) = msg.value >= bonusCond2
TMP_77(bool) = msg.value < bonusCond3
TMP_78(bool) = TMP_76 && TMP_77
CONDITION TMP_78""];
20->21[label=""True""];
20->22[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
countbonus = tokens * 2 / 100

IRs:
TMP_79(uint256) = tokens * 2
TMP_80(uint256) = TMP_79 / 100
countbonus(uint256) := TMP_80(uint256)""];
21->25;
22[label=""Node Type: IF 22

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_81(bool) = msg.value >= bonusCond3
CONDITION TMP_81""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
countbonus = tokens * 3 / 100

IRs:
TMP_82(uint256) = tokens * 3
TMP_83(uint256) = TMP_82 / 100
countbonus(uint256) := TMP_83(uint256)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->27;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
bonus = tokens + countbonus

IRs:
TMP_84(uint256) = tokens + countbonus
bonus(uint256) := TMP_84(uint256)""];
29->30;
30[label=""Node Type: IF 30

EXPRESSION:
tokens == 0

IRs:
TMP_85(bool) = tokens == 0
CONDITION TMP_85""];
30->31[label=""True""];
30->38[label=""False""];
31[label=""Node Type: NEW VARIABLE 31

EXPRESSION:
valdrop = 5e8

IRs:
valdrop(uint256) := 500000000(uint256)""];
31->32;
32[label=""Node Type: IF 32

EXPRESSION:
Claimed[investor] == false && progress0drop <= target0drop

IRs:
REF_12(bool) -> Claimed[investor]
TMP_86(bool) = REF_12 == False
TMP_87(bool) = progress0drop <= target0drop
TMP_88(bool) = TMP_86 && TMP_87
CONDITION TMP_88""];
32->33[label=""True""];
32->36[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
distr(investor,valdrop)

IRs:
TMP_89(bool) = INTERNAL_CALL, EnergiPlus.distr(address,uint256)(investor,valdrop)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
Claimed[investor] = true

IRs:
REF_13(bool) -> Claimed[investor]
REF_13(bool) (->Claimed) := True(bool)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
progress0drop ++

IRs:
TMP_90(uint256) := progress0drop(uint256)
progress0drop(uint256) = progress0drop + 1""];
35->37;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_91(bool) = msg.value >= requestMinimum
TMP_92(None) = SOLIDITY_CALL require(bool)(TMP_91)""];
36->37;
37[label=""Node Type: END_IF 37
""];
37->48;
38[label=""Node Type: IF 38

EXPRESSION:
tokens > 0 && msg.value >= requestMinimum

IRs:
TMP_93(bool) = tokens > 0
TMP_94(bool) = msg.value >= requestMinimum
TMP_95(bool) = TMP_93 && TMP_94
CONDITION TMP_95""];
38->39[label=""True""];
38->46[label=""False""];
39[label=""Node Type: IF 39

EXPRESSION:
now >= deadline && now >= round1 && now < round2

IRs:
TMP_96(bool) = now >= deadline
TMP_97(bool) = now >= round1
TMP_98(bool) = TMP_96 && TMP_97
TMP_99(bool) = now < round2
TMP_100(bool) = TMP_98 && TMP_99
CONDITION TMP_100""];
39->40[label=""True""];
39->41[label=""False""];
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_101(bool) = INTERNAL_CALL, EnergiPlus.distr(address,uint256)(investor,tokens)""];
40->45;
41[label=""Node Type: IF 41

EXPRESSION:
msg.value >= bonusCond1

IRs:
TMP_102(bool) = msg.value >= bonusCond1
CONDITION TMP_102""];
41->42[label=""True""];
41->43[label=""False""];
42[label=""Node Type: EXPRESSION 42

EXPRESSION:
distr(investor,bonus)

IRs:
TMP_103(bool) = INTERNAL_CALL, EnergiPlus.distr(address,uint256)(investor,bonus)""];
42->44;
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_104(bool) = INTERNAL_CALL, EnergiPlus.distr(address,uint256)(investor,tokens)""];
43->44;
44[label=""Node Type: END_IF 44
""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->47;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_105(bool) = msg.value >= requestMinimum
TMP_106(None) = SOLIDITY_CALL require(bool)(TMP_105)""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: IF 49

EXPRESSION:
totalDistributed >= totalSupply

IRs:
TMP_107(bool) = totalDistributed >= totalSupply
CONDITION TMP_107""];
49->50[label=""True""];
49->51[label=""False""];
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
multisig.transfer(msg.value)

IRs:
Transfer dest:multisig value:msg.value""];
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, EnergiPlus.canDistr()()""];
53->1;
}
",0,0,1,0,"canDistr();tokens = 0;bonus = 0;countbonus = 0;bonusCond1 = 1000000000000000000 / 10;bonusCond2 = 5000000000000000000 / 10;bonusCond3 = 1000000000000000000;tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;investor = msg.sender;msg.value >= requestMinimum && now < deadline && now < round1 && now < round2;msg.value >= bonusCond1 && msg.value < bonusCond2;msg.value >= requestMinimum && now < deadline && now > round1 && now < round2;countbonus = tokens * 10 / 100;msg.value >= bonusCond2 && msg.value < bonusCond3;;countbonus = tokens * 15 / 100;msg.value >= bonusCond3;;countbonus = tokens * 35 / 100;;;msg.value >= bonusCond2 && msg.value < bonusCond3;countbonus = 0;countbonus = tokens * 2 / 100;msg.value >= bonusCond3;;countbonus = tokens * 3 / 100;;;bonus = tokens + countbonus;tokens == 0;valdrop = 5e8;tokens > 0 && msg.value >= requestMinimum;Claimed[investor] == false && progress0drop <= target0drop;distr(investor,valdrop);require(bool)(msg.value >= requestMinimum);Claimed[investor] = true;progress0drop ++;;;now >= deadline && now >= round1 && now < round2;require(bool)(msg.value >= requestMinimum);distr(investor,tokens);msg.value >= bonusCond1;;distr(investor,bonus);distr(investor,tokens);;;totalDistributed >= totalSupply;distributionFinished = true;;multisig.transfer(msg.value)"
./0x184b8e35fea87e75498705ea96f2326db8ee2470_ext.sol,AirDrop.transferEthToOnwer,94,96,"REF_15(uint256) = SOLIDITY_CALL balance(address)(this),TMP_28 = SEND dest:owner value:REF_15,TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28),MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(owner.send(this.balance))

IRs:
REF_15(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_28 = SEND dest:owner value:REF_15
TMP_29(None) = SOLIDITY_CALL require(bool)(TMP_28)""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
2->1;
}
",0,0,1,0,onlyOwner();require(bool)(owner.send(this.balance))
./0xd9e982e827d19a9dca6fe607be4c52d0ff14a697_ext.sol,UserDataManager.registerNameCore,263,290,"REF_66(uint256) -> pIDxName_[_name],TMP_59(bool) = REF_66 != 0,CONDITION TMP_59,REF_67(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_68(bool) -> REF_67[_name],TMP_60(bool) = REF_68 == True,TMP_61(None) = SOLIDITY_CALL require(bool,string)(TMP_60,sorry that names already taken),REF_69(UserDataManager.Player) -> plyr_[_pID],REF_70(bytes32) -> REF_69.name,REF_70(bytes32) (->plyr_) := _name(bytes32),REF_71(uint256) -> pIDxName_[_name],REF_71(uint256) (->pIDxName_) := _pID(uint256),REF_72(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_73(bool) -> REF_72[_name],TMP_62(bool) = REF_73 == False,CONDITION TMP_62,REF_74(mapping(bytes32 => bool)) -> plyrNames_[_pID],REF_75(bool) -> REF_74[_name],REF_75(bool) (->plyrNames_) := True(bool),REF_76(UserDataManager.Player) -> plyr_[_pID],REF_77(uint256) -> REF_76.names,TMP_63(uint256) := REF_77(uint256),REF_77(-> plyr_) = REF_77 + 1,REF_78(mapping(uint256 => bytes32)) -> plyrNameList_[_pID],REF_79(UserDataManager.Player) -> plyr_[_pID],REF_80(uint256) -> REF_79.names,REF_81(bytes32) -> REF_78[REF_80],REF_81(bytes32) (->plyrNameList_) := _name(bytes32),TMP_64 = CONVERT this to address,TMP_65(uint256) = SOLIDITY_CALL balance(address)(TMP_64),Transfer dest:admin value:TMP_65,TMP_67(bool) = _all == True,CONDITION TMP_67,i(uint256) := 1(uint256),TMP_68(bool) = i <= gID_,CONDITION TMP_68,REF_83(UserDataManagerReceiverInterface) -> games_[i],HIGH_LEVEL_CALL, dest:REF_83(UserDataManagerReceiverInterface), function:receivePlayerInfo, arguments:['_pID', '_addr', '_name', '_affID']  ,TMP_70(uint256) := i(uint256),i(uint256) = i + 1,REF_85(UserDataManager.Player) -> plyr_[_affID],REF_86(address) -> REF_85.addr,REF_87(UserDataManager.Player) -> plyr_[_affID],REF_88(bytes32) -> REF_87.name,Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_86,REF_88,msg.value,now)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
pIDxName_[_name] != 0

IRs:
REF_66(uint256) -> pIDxName_[_name]
TMP_59(bool) = REF_66 != 0
CONDITION TMP_59""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(plyrNames_[_pID][_name] == true,sorry that names already taken)

IRs:
REF_67(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_68(bool) -> REF_67[_name]
TMP_60(bool) = REF_68 == True
TMP_61(None) = SOLIDITY_CALL require(bool,string)(TMP_60,sorry that names already taken)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
plyr_[_pID].name = _name

IRs:
REF_69(UserDataManager.Player) -> plyr_[_pID]
REF_70(bytes32) -> REF_69.name
REF_70(bytes32) (->plyr_) := _name(bytes32)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
pIDxName_[_name] = _pID

IRs:
REF_71(uint256) -> pIDxName_[_name]
REF_71(uint256) (->pIDxName_) := _pID(uint256)""];
5->6;
6[label=""Node Type: IF 6

EXPRESSION:
plyrNames_[_pID][_name] == false

IRs:
REF_72(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_73(bool) -> REF_72[_name]
TMP_62(bool) = REF_73 == False
CONDITION TMP_62""];
6->7[label=""True""];
6->10[label=""False""];
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
plyrNames_[_pID][_name] = true

IRs:
REF_74(mapping(bytes32 => bool)) -> plyrNames_[_pID]
REF_75(bool) -> REF_74[_name]
REF_75(bool) (->plyrNames_) := True(bool)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
plyr_[_pID].names ++

IRs:
REF_76(UserDataManager.Player) -> plyr_[_pID]
REF_77(uint256) -> REF_76.names
TMP_63(uint256) := REF_77(uint256)
REF_77(-> plyr_) = REF_77 + 1""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
plyrNameList_[_pID][plyr_[_pID].names] = _name

IRs:
REF_78(mapping(uint256 => bytes32)) -> plyrNameList_[_pID]
REF_79(UserDataManager.Player) -> plyr_[_pID]
REF_80(uint256) -> REF_79.names
REF_81(bytes32) -> REF_78[REF_80]
REF_81(bytes32) (->plyrNameList_) := _name(bytes32)""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
admin.transfer(address(this).balance)

IRs:
TMP_64 = CONVERT this to address
TMP_65(uint256) = SOLIDITY_CALL balance(address)(TMP_64)
Transfer dest:admin value:TMP_65""];
11->12;
12[label=""Node Type: IF 12

EXPRESSION:
_all == true

IRs:
TMP_67(bool) = _all == True
CONDITION TMP_67""];
12->15[label=""True""];
12->19[label=""False""];
13[label=""Node Type: BEGIN_LOOP 13
""];
13->16;
14[label=""Node Type: END_LOOP 14
""];
14->19;
15[label=""Node Type: NEW VARIABLE 15

EXPRESSION:
i = 1

IRs:
i(uint256) := 1(uint256)""];
15->13;
16[label=""Node Type: IF_LOOP 16

EXPRESSION:
i <= gID_

IRs:
TMP_68(bool) = i <= gID_
CONDITION TMP_68""];
16->17[label=""True""];
16->14[label=""False""];
17[label=""Node Type: EXPRESSION 17

EXPRESSION:
games_[i].receivePlayerInfo(_pID,_addr,_name,_affID)

IRs:
REF_83(UserDataManagerReceiverInterface) -> games_[i]
HIGH_LEVEL_CALL, dest:REF_83(UserDataManagerReceiverInterface), function:receivePlayerInfo, arguments:['_pID', '_addr', '_name', '_affID']  ""];
17->18;
18[label=""Node Type: EXPRESSION 18

EXPRESSION:
i ++

IRs:
TMP_70(uint256) := i(uint256)
i(uint256) = i + 1""];
18->16;
19[label=""Node Type: END_IF 19
""];
19->20;
20[label=""Node Type: EXPRESSION 20

EXPRESSION:
onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,msg.value,now)

IRs:
REF_85(UserDataManager.Player) -> plyr_[_affID]
REF_86(address) -> REF_85.addr
REF_87(UserDataManager.Player) -> plyr_[_affID]
REF_88(bytes32) -> REF_87.name
Emit onNewName(_pID,_addr,_name,_isNewPlayer,_affID,REF_86,REF_88,msg.value,now)""];
}
",0,0,1,0,"pIDxName_[_name] != 0;require(bool,string)(plyrNames_[_pID][_name] == true,sorry that names already taken);;plyr_[_pID].name = _name;pIDxName_[_name] = _pID;plyrNames_[_pID][_name] == false;plyrNames_[_pID][_name] = true;;plyr_[_pID].names ++;plyrNameList_[_pID][plyr_[_pID].names] = _name;admin.transfer(address(this).balance);_all == true;i = 1;;;i <= gID_;;games_[i].receivePlayerInfo(_pID,_addr,_name,_affID);i ++;onNewName(_pID,_addr,_name,_isNewPlayer,_affID,plyr_[_affID].addr,plyr_[_affID].name,msg.value,now)"
./0x92ccb32f34ca7abf1e0f5ba9b0167b607ea6b5ac_ext.sol,LO_QUIZ.Stop,28,30,"REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3,MODIFIER_CALL, LO_QUIZ.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, LO_QUIZ.isAdmin()()""];
2->1;
}
",0,0,1,0,isAdmin();msg.sender.transfer(this.balance)
./0xefcc5dcaba4a93046b5f5c24c1281c685154214c_ext.sol,CrypteloPreSale.refund,139,142,TMP_37 = SEND dest:_sender value:_amountWei,"digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
_sender.send(_amountWei)

IRs:
TMP_37 = SEND dest:_sender value:_amountWei""];
}
",0,0,1,0,_sender.send(_amountWei)
./0x56cd53067e5acd557dbbfb4c66580dfb9722962a_ext.sol,CryptoMoviesToken._payout,370,376,"TMP_95 = CONVERT 0 to address,TMP_96(bool) = _to == TMP_95,CONDITION TMP_96,REF_38(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:ceoAddress value:REF_38,REF_40(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:_to value:REF_40","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_to == address(0)

IRs:
TMP_95 = CONVERT 0 to address
TMP_96(bool) = _to == TMP_95
CONDITION TMP_96""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ceoAddress.transfer(this.balance)

IRs:
REF_38(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:ceoAddress value:REF_38""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_to.transfer(this.balance)

IRs:
REF_40(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:_to value:REF_40""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,_to == address(0);ceoAddress.transfer(this.balance);_to.transfer(this.balance);
./0x6d3543d4b11683847697f5b9a3a9d116cf13dedd_ext.sol,VideoPoker._uncreditUser,1183,1192,"REF_182(uint256) -> credits[_user],TMP_560(bool) = _amt > REF_182,TMP_561(bool) = _amt == 0,TMP_562(bool) = TMP_560 || TMP_561,CONDITION TMP_562,REF_183(uint256) -> credits[_user],_amt(uint256) := REF_183(uint256),TMP_563(bool) = _amt == 0,CONDITION TMP_563,REF_184(uint88) -> vars.totalCredits,TMP_564 = CONVERT _amt to uint88,REF_184(-> vars) = REF_184 - TMP_564,REF_185(uint256) -> credits[_user],REF_185(-> credits) = REF_185 - _amt,TMP_566(bool) = LOW_LEVEL_CALL, dest:_user, function:call, arguments:[] value:_amt ,TMP_567(None) = SOLIDITY_CALL require(bool)(TMP_566),Emit CreditsCashedout(now,_user,_amt)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: IF 1

EXPRESSION:
_amt > credits[_user] || _amt == 0

IRs:
REF_182(uint256) -> credits[_user]
TMP_560(bool) = _amt > REF_182
TMP_561(bool) = _amt == 0
TMP_562(bool) = TMP_560 || TMP_561
CONDITION TMP_562""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_amt = credits[_user]

IRs:
REF_183(uint256) -> credits[_user]
_amt(uint256) := REF_183(uint256)""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
_amt == 0

IRs:
TMP_563(bool) = _amt == 0
CONDITION TMP_563""];
4->5[label=""True""];
4->6[label=""False""];
5[label=""Node Type: RETURN 5
""];
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
vars.totalCredits -= uint88(_amt)

IRs:
REF_184(uint88) -> vars.totalCredits
TMP_564 = CONVERT _amt to uint88
REF_184(-> vars) = REF_184 - TMP_564""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
credits[_user] -= _amt

IRs:
REF_185(uint256) -> credits[_user]
REF_185(-> credits) = REF_185 - _amt""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
require(bool)(_user.call.value(_amt)())

IRs:
TMP_566(bool) = LOW_LEVEL_CALL, dest:_user, function:call, arguments:[] value:_amt 
TMP_567(None) = SOLIDITY_CALL require(bool)(TMP_566)""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
CreditsCashedout(now,_user,_amt)

IRs:
Emit CreditsCashedout(now,_user,_amt)""];
}
",0,0,1,0,"_amt > credits[_user] || _amt == 0;_amt = credits[_user];;_amt == 0;;;vars.totalCredits -= uint88(_amt);credits[_user] -= _amt;require(bool)(_user.call.value(_amt)());CreditsCashedout(now,_user,_amt)"
./0x7609a798cf9e86622364326f5d1e523a030e19b4_ext.sol,XenoxToken.withdraw,302,305,"wantAmount(uint256) := _wdamount(uint256),Transfer dest:owner value:wantAmount,MODIFIER_CALL, XenoxToken.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->3;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
wantAmount = _wdamount

IRs:
wantAmount(uint256) := _wdamount(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(wantAmount)

IRs:
Transfer dest:owner value:wantAmount""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, XenoxToken.onlyOwner()()""];
3->1;
}
",0,0,1,0,onlyOwner();wantAmount = _wdamount;owner.transfer(wantAmount)
./0xd0792ac0de7ef31197c5f452b21a34389ecc725f_ext.sol,CryptoWaterMargin.withdrawAmount,136,138,"Transfer dest:msg.sender value:_amount,MODIFIER_CALL, CryptoWaterMargin.onlyAdmins()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(_amount)

IRs:
Transfer dest:msg.sender value:_amount""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
onlyAdmins()

IRs:
MODIFIER_CALL, CryptoWaterMargin.onlyAdmins()()""];
2->1;
}
",0,0,1,0,onlyAdmins();msg.sender.transfer(_amount)
./0xb42fc86a49d6b772bb43cd031157d4aa557e387a_ext.sol,CrowdsaleToken.endIco,320,327,"REF_115(CrowdsaleToken.Stages) -> Stages.icoEnd,currentStage(CrowdsaleToken.Stages) := REF_115(CrowdsaleToken.Stages),TMP_122(bool) = remainingTokens > 0,CONDITION TMP_122,REF_116(uint256) -> balances[owner],REF_117(uint256) -> balances[owner],TMP_123(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_117', 'remainingTokens'] ,REF_116(uint256) (->balances) := TMP_123(uint256),TMP_124 = CONVERT this to address,TMP_125(uint256) = SOLIDITY_CALL balance(address)(TMP_124),Transfer dest:owner value:TMP_125","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
currentStage = Stages.icoEnd

IRs:
REF_115(CrowdsaleToken.Stages) -> Stages.icoEnd
currentStage(CrowdsaleToken.Stages) := REF_115(CrowdsaleToken.Stages)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
remainingTokens > 0

IRs:
TMP_122(bool) = remainingTokens > 0
CONDITION TMP_122""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[owner] = balances[owner].add(remainingTokens)

IRs:
REF_116(uint256) -> balances[owner]
REF_117(uint256) -> balances[owner]
TMP_123(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.add(uint256,uint256), arguments:['REF_117', 'remainingTokens'] 
REF_116(uint256) (->balances) := TMP_123(uint256)""];
3->4;
4[label=""Node Type: END_IF 4
""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_124 = CONVERT this to address
TMP_125(uint256) = SOLIDITY_CALL balance(address)(TMP_124)
Transfer dest:owner value:TMP_125""];
}
",0,0,1,0,currentStage = Stages.icoEnd;remainingTokens > 0;balances[owner] = balances[owner].add(remainingTokens);;owner.transfer(address(this).balance)
./0x1822435de9b923a7a8c4fbd2f6d0aa8f743d3010_ext.sol,BONDS.withdraw,292,303,"_customerAddress(address) := msg.sender(address),REF_101(uint256) -> ownerAccounts[_customerAddress],TMP_57(bool) = REF_101 > 0,TMP_58(None) = SOLIDITY_CALL require(bool)(TMP_57),REF_102(uint256) -> ownerAccounts[_customerAddress],_dividends(uint256) := REF_102(uint256),REF_103(uint256) -> ownerAccounts[_customerAddress],REF_103(uint256) (->ownerAccounts) := 0(uint256),Transfer dest:_customerAddress value:_dividends,Emit onWithdraw(_customerAddress,_dividends)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
_customerAddress = msg.sender

IRs:
_customerAddress(address) := msg.sender(address)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(ownerAccounts[_customerAddress] > 0)

IRs:
REF_101(uint256) -> ownerAccounts[_customerAddress]
TMP_57(bool) = REF_101 > 0
TMP_58(None) = SOLIDITY_CALL require(bool)(TMP_57)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
_dividends = ownerAccounts[_customerAddress]

IRs:
REF_102(uint256) -> ownerAccounts[_customerAddress]
_dividends(uint256) := REF_102(uint256)""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
ownerAccounts[_customerAddress] = 0

IRs:
REF_103(uint256) -> ownerAccounts[_customerAddress]
REF_103(uint256) (->ownerAccounts) := 0(uint256)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
_customerAddress.transfer(_dividends)

IRs:
Transfer dest:_customerAddress value:_dividends""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
onWithdraw(_customerAddress,_dividends)

IRs:
Emit onWithdraw(_customerAddress,_dividends)""];
}
",0,0,1,0,"_customerAddress = msg.sender;require(bool)(ownerAccounts[_customerAddress] > 0);_dividends = ownerAccounts[_customerAddress];ownerAccounts[_customerAddress] = 0;_customerAddress.transfer(_dividends);onWithdraw(_customerAddress,_dividends)"
./0xeef93ec835c7921038d55ee096671a94e961709b_ext.sol,RefundVault.close,632,637,"REF_251(RefundVault.State) -> State.Active,TMP_427(bool) = state == REF_251,TMP_428(None) = SOLIDITY_CALL require(bool)(TMP_427),REF_252(RefundVault.State) -> State.Closed,state(RefundVault.State) := REF_252(RefundVault.State),Emit Closed(),REF_254(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:wallet value:REF_254,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(state == State.Active)

IRs:
REF_251(RefundVault.State) -> State.Active
TMP_427(bool) = state == REF_251
TMP_428(None) = SOLIDITY_CALL require(bool)(TMP_427)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
state = State.Closed

IRs:
REF_252(RefundVault.State) -> State.Closed
state(RefundVault.State) := REF_252(RefundVault.State)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
Closed()

IRs:
Emit Closed()""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
wallet.transfer(this.balance)

IRs:
REF_254(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:wallet value:REF_254""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();require(bool)(state == State.Active);state = State.Closed;Closed();wallet.transfer(this.balance)
./0xaa3fbfaf03cd50e6a44d27d10eb14333d1c02e52_ext.sol,ETH_GAME.Stop,28,30,"REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3,MODIFIER_CALL, ETH_GAME.isAdmin()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->2;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
isAdmin()

IRs:
MODIFIER_CALL, ETH_GAME.isAdmin()()""];
2->1;
}
",0,0,1,0,isAdmin();msg.sender.transfer(this.balance)
./0xc398891b43f1b91158dca87c63a88b80d000c248_ext.sol,IBIT.getTokens,174,233,"tokens(uint256) := 0(uint256),bonus(uint256) := 0(uint256),countbonus(uint256) := 0(uint256),TMP_45(uint256) = 1000000000000000000 / 2,bonusCond1(uint256) := TMP_45(uint256),bonusCond2(uint256) := 1000000000000000000(uint256),bonusCond3(uint256) := 3000000000000000000(uint256),TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] ,TMP_47(uint256) = TMP_46 / 1000000000000000000,tokens(uint256) := TMP_47(uint256),investor(address) := msg.sender(address),TMP_48(bool) = msg.value >= requestMinimum,TMP_49(bool) = now < deadline,TMP_50(bool) = TMP_48 && TMP_49,TMP_51(bool) = now < round1,TMP_52(bool) = TMP_50 && TMP_51,TMP_53(bool) = now < round2,TMP_54(bool) = TMP_52 && TMP_53,CONDITION TMP_54,TMP_55(bool) = msg.value >= bonusCond1,TMP_56(bool) = msg.value < bonusCond2,TMP_57(bool) = TMP_55 && TMP_56,CONDITION TMP_57,TMP_58(uint256) = tokens * 10,TMP_59(uint256) = TMP_58 / 100,countbonus(uint256) := TMP_59(uint256),TMP_60(bool) = msg.value >= bonusCond2,TMP_61(bool) = msg.value < bonusCond3,TMP_62(bool) = TMP_60 && TMP_61,CONDITION TMP_62,TMP_63(uint256) = tokens * 50,TMP_64(uint256) = TMP_63 / 100,countbonus(uint256) := TMP_64(uint256),TMP_65(bool) = msg.value >= bonusCond3,CONDITION TMP_65,TMP_66(uint256) = tokens * 75,TMP_67(uint256) = TMP_66 / 100,countbonus(uint256) := TMP_67(uint256),TMP_68(bool) = msg.value >= requestMinimum,TMP_69(bool) = now < deadline,TMP_70(bool) = TMP_68 && TMP_69,TMP_71(bool) = now > round1,TMP_72(bool) = TMP_70 && TMP_71,TMP_73(bool) = now < round2,TMP_74(bool) = TMP_72 && TMP_73,CONDITION TMP_74,TMP_75(bool) = msg.value >= bonusCond2,TMP_76(bool) = msg.value < bonusCond3,TMP_77(bool) = TMP_75 && TMP_76,CONDITION TMP_77,TMP_78(uint256) = tokens * 25,TMP_79(uint256) = TMP_78 / 100,countbonus(uint256) := TMP_79(uint256),TMP_80(bool) = msg.value >= bonusCond3,CONDITION TMP_80,TMP_81(uint256) = tokens * 50,TMP_82(uint256) = TMP_81 / 100,countbonus(uint256) := TMP_82(uint256),countbonus(uint256) := 0(uint256),TMP_83(uint256) = tokens + countbonus,bonus(uint256) := TMP_83(uint256),TMP_84(bool) = tokens == 0,CONDITION TMP_84,valdrop(uint256) := 67000000000(uint256),REF_12(bool) -> Claimed[investor],TMP_85(bool) = REF_12 == False,TMP_86(bool) = progress0drop <= target0drop,TMP_87(bool) = TMP_85 && TMP_86,CONDITION TMP_87,TMP_88(bool) = INTERNAL_CALL, IBIT.distr(address,uint256)(investor,valdrop),REF_13(bool) -> Claimed[investor],REF_13(bool) (->Claimed) := True(bool),TMP_89(uint256) := progress0drop(uint256),progress0drop(uint256) = progress0drop + 1,TMP_90(bool) = msg.value >= requestMinimum,TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90),TMP_92(bool) = tokens > 0,TMP_93(bool) = msg.value >= requestMinimum,TMP_94(bool) = TMP_92 && TMP_93,CONDITION TMP_94,TMP_95(bool) = now >= deadline,TMP_96(bool) = now >= round1,TMP_97(bool) = TMP_95 && TMP_96,TMP_98(bool) = now < round2,TMP_99(bool) = TMP_97 && TMP_98,CONDITION TMP_99,TMP_100(bool) = INTERNAL_CALL, IBIT.distr(address,uint256)(investor,tokens),TMP_101(bool) = msg.value >= bonusCond1,CONDITION TMP_101,TMP_102(bool) = INTERNAL_CALL, IBIT.distr(address,uint256)(investor,bonus),TMP_103(bool) = INTERNAL_CALL, IBIT.distr(address,uint256)(investor,tokens),TMP_104(bool) = msg.value >= requestMinimum,TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104),TMP_106(bool) = totalDistributed >= totalSupply,CONDITION TMP_106,distributionFinished(bool) := True(bool),Transfer dest:multisig value:msg.value,MODIFIER_CALL, IBIT.canDistr()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->53;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
tokens = 0

IRs:
tokens(uint256) := 0(uint256)""];
1->2;
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
bonus = 0

IRs:
bonus(uint256) := 0(uint256)""];
2->3;
3[label=""Node Type: NEW VARIABLE 3

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
bonusCond1 = 1000000000000000000 / 2

IRs:
TMP_45(uint256) = 1000000000000000000 / 2
bonusCond1(uint256) := TMP_45(uint256)""];
4->5;
5[label=""Node Type: NEW VARIABLE 5

EXPRESSION:
bonusCond2 = 1000000000000000000

IRs:
bonusCond2(uint256) := 1000000000000000000(uint256)""];
5->6;
6[label=""Node Type: NEW VARIABLE 6

EXPRESSION:
bonusCond3 = 3000000000000000000

IRs:
bonusCond3(uint256) := 3000000000000000000(uint256)""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
tokens = tokensPerEth.mul(msg.value) / 1000000000000000000

IRs:
TMP_46(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.mul(uint256,uint256), arguments:['tokensPerEth', 'msg.value'] 
TMP_47(uint256) = TMP_46 / 1000000000000000000
tokens(uint256) := TMP_47(uint256)""];
7->8;
8[label=""Node Type: NEW VARIABLE 8

EXPRESSION:
investor = msg.sender

IRs:
investor(address) := msg.sender(address)""];
8->9;
9[label=""Node Type: IF 9

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now < round1 && now < round2

IRs:
TMP_48(bool) = msg.value >= requestMinimum
TMP_49(bool) = now < deadline
TMP_50(bool) = TMP_48 && TMP_49
TMP_51(bool) = now < round1
TMP_52(bool) = TMP_50 && TMP_51
TMP_53(bool) = now < round2
TMP_54(bool) = TMP_52 && TMP_53
CONDITION TMP_54""];
9->10[label=""True""];
9->19[label=""False""];
10[label=""Node Type: IF 10

EXPRESSION:
msg.value >= bonusCond1 && msg.value < bonusCond2

IRs:
TMP_55(bool) = msg.value >= bonusCond1
TMP_56(bool) = msg.value < bonusCond2
TMP_57(bool) = TMP_55 && TMP_56
CONDITION TMP_57""];
10->11[label=""True""];
10->12[label=""False""];
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
countbonus = tokens * 10 / 100

IRs:
TMP_58(uint256) = tokens * 10
TMP_59(uint256) = TMP_58 / 100
countbonus(uint256) := TMP_59(uint256)""];
11->18;
12[label=""Node Type: IF 12

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_60(bool) = msg.value >= bonusCond2
TMP_61(bool) = msg.value < bonusCond3
TMP_62(bool) = TMP_60 && TMP_61
CONDITION TMP_62""];
12->13[label=""True""];
12->14[label=""False""];
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
countbonus = tokens * 50 / 100

IRs:
TMP_63(uint256) = tokens * 50
TMP_64(uint256) = TMP_63 / 100
countbonus(uint256) := TMP_64(uint256)""];
13->17;
14[label=""Node Type: IF 14

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_65(bool) = msg.value >= bonusCond3
CONDITION TMP_65""];
14->15[label=""True""];
14->16[label=""False""];
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
countbonus = tokens * 75 / 100

IRs:
TMP_66(uint256) = tokens * 75
TMP_67(uint256) = TMP_66 / 100
countbonus(uint256) := TMP_67(uint256)""];
15->16;
16[label=""Node Type: END_IF 16
""];
16->17;
17[label=""Node Type: END_IF 17
""];
17->18;
18[label=""Node Type: END_IF 18
""];
18->28;
19[label=""Node Type: IF 19

EXPRESSION:
msg.value >= requestMinimum && now < deadline && now > round1 && now < round2

IRs:
TMP_68(bool) = msg.value >= requestMinimum
TMP_69(bool) = now < deadline
TMP_70(bool) = TMP_68 && TMP_69
TMP_71(bool) = now > round1
TMP_72(bool) = TMP_70 && TMP_71
TMP_73(bool) = now < round2
TMP_74(bool) = TMP_72 && TMP_73
CONDITION TMP_74""];
19->20[label=""True""];
19->26[label=""False""];
20[label=""Node Type: IF 20

EXPRESSION:
msg.value >= bonusCond2 && msg.value < bonusCond3

IRs:
TMP_75(bool) = msg.value >= bonusCond2
TMP_76(bool) = msg.value < bonusCond3
TMP_77(bool) = TMP_75 && TMP_76
CONDITION TMP_77""];
20->21[label=""True""];
20->22[label=""False""];
21[label=""Node Type: EXPRESSION 21

EXPRESSION:
countbonus = tokens * 25 / 100

IRs:
TMP_78(uint256) = tokens * 25
TMP_79(uint256) = TMP_78 / 100
countbonus(uint256) := TMP_79(uint256)""];
21->25;
22[label=""Node Type: IF 22

EXPRESSION:
msg.value >= bonusCond3

IRs:
TMP_80(bool) = msg.value >= bonusCond3
CONDITION TMP_80""];
22->23[label=""True""];
22->24[label=""False""];
23[label=""Node Type: EXPRESSION 23

EXPRESSION:
countbonus = tokens * 50 / 100

IRs:
TMP_81(uint256) = tokens * 50
TMP_82(uint256) = TMP_81 / 100
countbonus(uint256) := TMP_82(uint256)""];
23->24;
24[label=""Node Type: END_IF 24
""];
24->25;
25[label=""Node Type: END_IF 25
""];
25->27;
26[label=""Node Type: EXPRESSION 26

EXPRESSION:
countbonus = 0

IRs:
countbonus(uint256) := 0(uint256)""];
26->27;
27[label=""Node Type: END_IF 27
""];
27->28;
28[label=""Node Type: END_IF 28
""];
28->29;
29[label=""Node Type: EXPRESSION 29

EXPRESSION:
bonus = tokens + countbonus

IRs:
TMP_83(uint256) = tokens + countbonus
bonus(uint256) := TMP_83(uint256)""];
29->30;
30[label=""Node Type: IF 30

EXPRESSION:
tokens == 0

IRs:
TMP_84(bool) = tokens == 0
CONDITION TMP_84""];
30->31[label=""True""];
30->38[label=""False""];
31[label=""Node Type: NEW VARIABLE 31

EXPRESSION:
valdrop = 670e8

IRs:
valdrop(uint256) := 67000000000(uint256)""];
31->32;
32[label=""Node Type: IF 32

EXPRESSION:
Claimed[investor] == false && progress0drop <= target0drop

IRs:
REF_12(bool) -> Claimed[investor]
TMP_85(bool) = REF_12 == False
TMP_86(bool) = progress0drop <= target0drop
TMP_87(bool) = TMP_85 && TMP_86
CONDITION TMP_87""];
32->33[label=""True""];
32->36[label=""False""];
33[label=""Node Type: EXPRESSION 33

EXPRESSION:
distr(investor,valdrop)

IRs:
TMP_88(bool) = INTERNAL_CALL, IBIT.distr(address,uint256)(investor,valdrop)""];
33->34;
34[label=""Node Type: EXPRESSION 34

EXPRESSION:
Claimed[investor] = true

IRs:
REF_13(bool) -> Claimed[investor]
REF_13(bool) (->Claimed) := True(bool)""];
34->35;
35[label=""Node Type: EXPRESSION 35

EXPRESSION:
progress0drop ++

IRs:
TMP_89(uint256) := progress0drop(uint256)
progress0drop(uint256) = progress0drop + 1""];
35->37;
36[label=""Node Type: EXPRESSION 36

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_90(bool) = msg.value >= requestMinimum
TMP_91(None) = SOLIDITY_CALL require(bool)(TMP_90)""];
36->37;
37[label=""Node Type: END_IF 37
""];
37->48;
38[label=""Node Type: IF 38

EXPRESSION:
tokens > 0 && msg.value >= requestMinimum

IRs:
TMP_92(bool) = tokens > 0
TMP_93(bool) = msg.value >= requestMinimum
TMP_94(bool) = TMP_92 && TMP_93
CONDITION TMP_94""];
38->39[label=""True""];
38->46[label=""False""];
39[label=""Node Type: IF 39

EXPRESSION:
now >= deadline && now >= round1 && now < round2

IRs:
TMP_95(bool) = now >= deadline
TMP_96(bool) = now >= round1
TMP_97(bool) = TMP_95 && TMP_96
TMP_98(bool) = now < round2
TMP_99(bool) = TMP_97 && TMP_98
CONDITION TMP_99""];
39->40[label=""True""];
39->41[label=""False""];
40[label=""Node Type: EXPRESSION 40

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_100(bool) = INTERNAL_CALL, IBIT.distr(address,uint256)(investor,tokens)""];
40->45;
41[label=""Node Type: IF 41

EXPRESSION:
msg.value >= bonusCond1

IRs:
TMP_101(bool) = msg.value >= bonusCond1
CONDITION TMP_101""];
41->42[label=""True""];
41->43[label=""False""];
42[label=""Node Type: EXPRESSION 42

EXPRESSION:
distr(investor,bonus)

IRs:
TMP_102(bool) = INTERNAL_CALL, IBIT.distr(address,uint256)(investor,bonus)""];
42->44;
43[label=""Node Type: EXPRESSION 43

EXPRESSION:
distr(investor,tokens)

IRs:
TMP_103(bool) = INTERNAL_CALL, IBIT.distr(address,uint256)(investor,tokens)""];
43->44;
44[label=""Node Type: END_IF 44
""];
44->45;
45[label=""Node Type: END_IF 45
""];
45->47;
46[label=""Node Type: EXPRESSION 46

EXPRESSION:
require(bool)(msg.value >= requestMinimum)

IRs:
TMP_104(bool) = msg.value >= requestMinimum
TMP_105(None) = SOLIDITY_CALL require(bool)(TMP_104)""];
46->47;
47[label=""Node Type: END_IF 47
""];
47->48;
48[label=""Node Type: END_IF 48
""];
48->49;
49[label=""Node Type: IF 49

EXPRESSION:
totalDistributed >= totalSupply

IRs:
TMP_106(bool) = totalDistributed >= totalSupply
CONDITION TMP_106""];
49->50[label=""True""];
49->51[label=""False""];
50[label=""Node Type: EXPRESSION 50

EXPRESSION:
distributionFinished = true

IRs:
distributionFinished(bool) := True(bool)""];
50->51;
51[label=""Node Type: END_IF 51
""];
51->52;
52[label=""Node Type: EXPRESSION 52

EXPRESSION:
multisig.transfer(msg.value)

IRs:
Transfer dest:multisig value:msg.value""];
53[label=""Node Type: EXPRESSION 53

EXPRESSION:
canDistr()

IRs:
MODIFIER_CALL, IBIT.canDistr()()""];
53->1;
}
",0,0,1,0,"canDistr();tokens = 0;bonus = 0;countbonus = 0;bonusCond1 = 1000000000000000000 / 2;bonusCond2 = 1000000000000000000;bonusCond3 = 3000000000000000000;tokens = tokensPerEth.mul(msg.value) / 1000000000000000000;investor = msg.sender;msg.value >= requestMinimum && now < deadline && now < round1 && now < round2;msg.value >= bonusCond1 && msg.value < bonusCond2;msg.value >= requestMinimum && now < deadline && now > round1 && now < round2;countbonus = tokens * 10 / 100;msg.value >= bonusCond2 && msg.value < bonusCond3;;countbonus = tokens * 50 / 100;msg.value >= bonusCond3;;countbonus = tokens * 75 / 100;;;msg.value >= bonusCond2 && msg.value < bonusCond3;countbonus = 0;countbonus = tokens * 25 / 100;msg.value >= bonusCond3;;countbonus = tokens * 50 / 100;;;bonus = tokens + countbonus;tokens == 0;valdrop = 670e8;tokens > 0 && msg.value >= requestMinimum;Claimed[investor] == false && progress0drop <= target0drop;distr(investor,valdrop);require(bool)(msg.value >= requestMinimum);Claimed[investor] = true;progress0drop ++;;;now >= deadline && now >= round1 && now < round2;require(bool)(msg.value >= requestMinimum);distr(investor,tokens);msg.value >= bonusCond1;;distr(investor,bonus);distr(investor,tokens);;;totalDistributed >= totalSupply;distributionFinished = true;;multisig.transfer(msg.value)"
./0xdda80deeb2db6d63247b9be73bacd00184fbc83f_ext.sol,withdrawable.withdraw,130,136,"TMP_44 = CONVERT 0 to address,TMP_45(bool) = _to != TMP_44,TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45),Transfer dest:_to value:_amount,Emit WithdrawEther(_to,_amount),RETURN True,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(_to != address(0))

IRs:
TMP_44 = CONVERT 0 to address
TMP_45(bool) = _to != TMP_44
TMP_46(None) = SOLIDITY_CALL require(bool)(TMP_45)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_to.transfer(_amount)

IRs:
Transfer dest:_to value:_amount""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
WithdrawEther(_to,_amount)

IRs:
Emit WithdrawEther(_to,_amount)""];
3->4;
4[label=""Node Type: RETURN 4

EXPRESSION:
true

IRs:
RETURN True""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,"onlyOwner();require(bool)(_to != address(0));_to.transfer(_amount);WithdrawEther(_to,_amount);true"
./0xf122d58b7a4083f103b7336ab05b78d7c6a02a37_ext.sol,PresalePool.submitPool,288,296,"TMP_108(bool) = contractStage < 3,TMP_109(None) = SOLIDITY_CALL require(bool)(TMP_108),TMP_110(bool) = contributionMin <= amountInWei,REF_74(uint256) = SOLIDITY_CALL balance(address)(this),TMP_111(bool) = amountInWei <= REF_74,TMP_112(bool) = TMP_110 && TMP_111,TMP_113(None) = SOLIDITY_CALL require(bool)(TMP_112),REF_75(uint256) = SOLIDITY_CALL balance(address)(this),finalBalance(uint256) := REF_75([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E3149250>]),TMP_115(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.gas', '5000'] ,TMP_117(bool) = LOW_LEVEL_CALL, dest:receiverAddress, function:call, arguments:[] value:amountInWei gas:TMP_115,TMP_118(None) = SOLIDITY_CALL require(bool)(TMP_117),REF_80(uint256) = SOLIDITY_CALL balance(address)(this),TMP_119(bool) = REF_80 > 0,CONDITION TMP_119,REF_82(uint256) = SOLIDITY_CALL balance(address)(this),REF_83 -> LENGTH ethRefundAmount,TMP_121(uint256) := REF_83(uint256),TMP_122(uint256) = TMP_121 + 1,REF_83(uint256) (->ethRefundAmount) := TMP_122(uint256),REF_84(uint256) -> ethRefundAmount[TMP_121],REF_84(uint256) (->ethRefundAmount) := REF_82([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E31499D0>]),contractStage(uint8) := 3(uint256),Emit PoolSubmitted(receiverAddress,amountInWei),MODIFIER_CALL, PresalePool.onlyOwner()(),MODIFIER_CALL, PresalePool.noReentrancy()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(contractStage < 3)

IRs:
TMP_108(bool) = contractStage < 3
TMP_109(None) = SOLIDITY_CALL require(bool)(TMP_108)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(contributionMin <= amountInWei && amountInWei <= this.balance)

IRs:
TMP_110(bool) = contributionMin <= amountInWei
REF_74(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_111(bool) = amountInWei <= REF_74
TMP_112(bool) = TMP_110 && TMP_111
TMP_113(None) = SOLIDITY_CALL require(bool)(TMP_112)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
finalBalance = this.balance

IRs:
REF_75(uint256) = SOLIDITY_CALL balance(address)(this)
finalBalance(uint256) := REF_75([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E3149250>])""];
3->4;
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
require(bool)(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))())

IRs:
TMP_115(uint256) = LIBRARY_CALL, dest:SafeMath, function:SafeMath.sub(uint256,uint256), arguments:['msg.gas', '5000'] 
TMP_117(bool) = LOW_LEVEL_CALL, dest:receiverAddress, function:call, arguments:[] value:amountInWei gas:TMP_115
TMP_118(None) = SOLIDITY_CALL require(bool)(TMP_117)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
this.balance > 0

IRs:
REF_80(uint256) = SOLIDITY_CALL balance(address)(this)
TMP_119(bool) = REF_80 > 0
CONDITION TMP_119""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
ethRefundAmount.push(this.balance)

IRs:
REF_82(uint256) = SOLIDITY_CALL balance(address)(this)
REF_83 -> LENGTH ethRefundAmount
TMP_121(uint256) := REF_83(uint256)
TMP_122(uint256) = TMP_121 + 1
REF_83(uint256) (->ethRefundAmount) := TMP_122(uint256)
REF_84(uint256) -> ethRefundAmount[TMP_121]
REF_84(uint256) (->ethRefundAmount) := REF_82([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E31499D0>])""];
6->7;
7[label=""Node Type: END_IF 7
""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
contractStage = 3

IRs:
contractStage(uint8) := 3(uint256)""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
PoolSubmitted(receiverAddress,amountInWei)

IRs:
Emit PoolSubmitted(receiverAddress,amountInWei)""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, PresalePool.onlyOwner()()""];
10->11;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
noReentrancy()

IRs:
MODIFIER_CALL, PresalePool.noReentrancy()()""];
11->1;
}
",0,0,1,0,"onlyOwner();require(bool)(contractStage < 3);require(bool)(contributionMin <= amountInWei && amountInWei <= this.balance);finalBalance = this.balance;require(bool)(receiverAddress.call.value(amountInWei).gas(msg.gas.sub(5000))());this.balance > 0;ethRefundAmount.push(this.balance);;contractStage = 3;PoolSubmitted(receiverAddress,amountInWei);noReentrancy()"
./0xc3a684140448995f6abeb361c56110207da04d57_ext.sol,SignalsSociety.acceptMembership,87,106,"TMP_37(uint256) = INTERNAL_CALL, Memberships.getMembershipPrice(Memberships.Membership)(membership),TMP_38(uint256) = TMP_37 - discount,price(uint256) := TMP_38(uint256),REF_9(uint256) -> balances[account],TMP_39(bool) = REF_9 >= price,TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39),REF_10(uint256) -> balances[account],REF_10(-> balances) = REF_10 - price,TMP_41(bool) = reseller != 0,CONDITION TMP_41,Transfer dest:reseller value:comission,TMP_43(uint256) = price - comission,Transfer dest:owner value:TMP_43,Transfer dest:owner value:price,Emit MembershipPaid(account,membership,now),MODIFIER_CALL, Ownable.onlyBot()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->10;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
price = getMembershipPrice(membership) - discount

IRs:
TMP_37(uint256) = INTERNAL_CALL, Memberships.getMembershipPrice(Memberships.Membership)(membership)
TMP_38(uint256) = TMP_37 - discount
price(uint256) := TMP_38(uint256)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(balances[account] >= price)

IRs:
REF_9(uint256) -> balances[account]
TMP_39(bool) = REF_9 >= price
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
balances[account] -= price

IRs:
REF_10(uint256) -> balances[account]
REF_10(-> balances) = REF_10 - price""];
3->4;
4[label=""Node Type: IF 4

EXPRESSION:
reseller != 0x0

IRs:
TMP_41(bool) = reseller != 0
CONDITION TMP_41""];
4->5[label=""True""];
4->7[label=""False""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
reseller.transfer(comission)

IRs:
Transfer dest:reseller value:comission""];
5->6;
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
owner.transfer(price - comission)

IRs:
TMP_43(uint256) = price - comission
Transfer dest:owner value:TMP_43""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
owner.transfer(price)

IRs:
Transfer dest:owner value:price""];
7->8;
8[label=""Node Type: END_IF 8
""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
MembershipPaid(account,membership,now)

IRs:
Emit MembershipPaid(account,membership,now)""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
onlyBot()

IRs:
MODIFIER_CALL, Ownable.onlyBot()()""];
10->1;
}
",0,0,1,0,"onlyBot();price = getMembershipPrice(membership) - discount;require(bool)(balances[account] >= price);balances[account] -= price;reseller != 0x0;reseller.transfer(comission);owner.transfer(price);owner.transfer(price - comission);;MembershipPaid(account,membership,now)"
./0x46580533db92c418a79f91b46df70283daef7f99_ext.sol,MultipleArbitrableTransaction.executeRuling,651,671,"REF_208(MultipleArbitrableTransaction.Transaction) -> transactions[_transactionID],transaction(MultipleArbitrableTransaction.Transaction) := REF_208(MultipleArbitrableTransaction.Transaction),TMP_225(bool) = _ruling <= AMOUNT_OF_CHOICES,TMP_226(None) = SOLIDITY_CALL require(bool,string)(TMP_225,Invalid ruling.),TMP_227(bool) = _ruling == SENDER_WINS,CONDITION TMP_227,REF_209(address) -> transaction.sender,REF_211(uint256) -> transaction.senderFee,REF_212(uint256) -> transaction.amount,TMP_228(uint256) = REF_211 + REF_212,TMP_229 = SEND dest:REF_209 value:TMP_228,TMP_230(bool) = _ruling == RECEIVER_WINS,CONDITION TMP_230,REF_213(address) -> transaction.receiver,REF_215(uint256) -> transaction.receiverFee,REF_216(uint256) -> transaction.amount,TMP_231(uint256) = REF_215 + REF_216,TMP_232 = SEND dest:REF_213 value:TMP_231,REF_217(uint256) -> transaction.senderFee,REF_218(uint256) -> transaction.amount,TMP_233(uint256) = REF_217 + REF_218,TMP_234(uint256) = TMP_233 / 2,split_amount(uint256) := TMP_234(uint256),REF_219(address) -> transaction.sender,TMP_235 = SEND dest:REF_219 value:split_amount,REF_221(address) -> transaction.receiver,TMP_236 = SEND dest:REF_221 value:split_amount,REF_223(uint256) -> transaction.amount,REF_223(uint256) (->transaction) := 0(uint256),REF_224(uint256) -> transaction.senderFee,REF_224(uint256) (->transaction) := 0(uint256),REF_225(uint256) -> transaction.receiverFee,REF_225(uint256) (->transaction) := 0(uint256),REF_226(MultipleArbitrableTransaction.Status) -> transaction.status,REF_227(MultipleArbitrableTransaction.Status) -> Status.Resolved,REF_226(MultipleArbitrableTransaction.Status) (->transaction) := REF_227(MultipleArbitrableTransaction.Status)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: NEW VARIABLE 1

EXPRESSION:
transaction = transactions[_transactionID]

IRs:
REF_208(MultipleArbitrableTransaction.Transaction) -> transactions[_transactionID]
transaction(MultipleArbitrableTransaction.Transaction) := REF_208(MultipleArbitrableTransaction.Transaction)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool,string)(_ruling <= AMOUNT_OF_CHOICES,Invalid ruling.)

IRs:
TMP_225(bool) = _ruling <= AMOUNT_OF_CHOICES
TMP_226(None) = SOLIDITY_CALL require(bool,string)(TMP_225,Invalid ruling.)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
_ruling == SENDER_WINS

IRs:
TMP_227(bool) = _ruling == SENDER_WINS
CONDITION TMP_227""];
3->4[label=""True""];
3->5[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
transaction.sender.send(transaction.senderFee + transaction.amount)

IRs:
REF_209(address) -> transaction.sender
REF_211(uint256) -> transaction.senderFee
REF_212(uint256) -> transaction.amount
TMP_228(uint256) = REF_211 + REF_212
TMP_229 = SEND dest:REF_209 value:TMP_228""];
4->11;
5[label=""Node Type: IF 5

EXPRESSION:
_ruling == RECEIVER_WINS

IRs:
TMP_230(bool) = _ruling == RECEIVER_WINS
CONDITION TMP_230""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
transaction.receiver.send(transaction.receiverFee + transaction.amount)

IRs:
REF_213(address) -> transaction.receiver
REF_215(uint256) -> transaction.receiverFee
REF_216(uint256) -> transaction.amount
TMP_231(uint256) = REF_215 + REF_216
TMP_232 = SEND dest:REF_213 value:TMP_231""];
6->10;
7[label=""Node Type: NEW VARIABLE 7

EXPRESSION:
split_amount = (transaction.senderFee + transaction.amount) / 2

IRs:
REF_217(uint256) -> transaction.senderFee
REF_218(uint256) -> transaction.amount
TMP_233(uint256) = REF_217 + REF_218
TMP_234(uint256) = TMP_233 / 2
split_amount(uint256) := TMP_234(uint256)""];
7->8;
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
transaction.sender.send(split_amount)

IRs:
REF_219(address) -> transaction.sender
TMP_235 = SEND dest:REF_219 value:split_amount""];
8->9;
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
transaction.receiver.send(split_amount)

IRs:
REF_221(address) -> transaction.receiver
TMP_236 = SEND dest:REF_221 value:split_amount""];
9->10;
10[label=""Node Type: END_IF 10
""];
10->11;
11[label=""Node Type: END_IF 11
""];
11->12;
12[label=""Node Type: EXPRESSION 12

EXPRESSION:
transaction.amount = 0

IRs:
REF_223(uint256) -> transaction.amount
REF_223(uint256) (->transaction) := 0(uint256)""];
12->13;
13[label=""Node Type: EXPRESSION 13

EXPRESSION:
transaction.senderFee = 0

IRs:
REF_224(uint256) -> transaction.senderFee
REF_224(uint256) (->transaction) := 0(uint256)""];
13->14;
14[label=""Node Type: EXPRESSION 14

EXPRESSION:
transaction.receiverFee = 0

IRs:
REF_225(uint256) -> transaction.receiverFee
REF_225(uint256) (->transaction) := 0(uint256)""];
14->15;
15[label=""Node Type: EXPRESSION 15

EXPRESSION:
transaction.status = Status.Resolved

IRs:
REF_226(MultipleArbitrableTransaction.Status) -> transaction.status
REF_227(MultipleArbitrableTransaction.Status) -> Status.Resolved
REF_226(MultipleArbitrableTransaction.Status) (->transaction) := REF_227(MultipleArbitrableTransaction.Status)""];
}
",0,0,1,0,"transaction = transactions[_transactionID];require(bool,string)(_ruling <= AMOUNT_OF_CHOICES,Invalid ruling.);_ruling == SENDER_WINS;transaction.sender.send(transaction.senderFee + transaction.amount);_ruling == RECEIVER_WINS;;transaction.receiver.send(transaction.receiverFee + transaction.amount);split_amount = (transaction.senderFee + transaction.amount) / 2;;transaction.sender.send(split_amount);transaction.receiver.send(split_amount);transaction.amount = 0;transaction.senderFee = 0;transaction.receiverFee = 0;transaction.status = Status.Resolved"
./0x881f21d3e2d2d4f48d815f41bea8dbdcf0e24e50_ext.sol,DepositVault.withdrawTo,43,51,"TMP_10(bool) = INTERNAL_CALL, DepositVault.WithdrawalEnabled()(),CONDITION TMP_10,REF_1(uint256) -> Deposits[msg.sender],max(uint256) := REF_1(uint256),TMP_11(bool) = max > 0,TMP_12(bool) = amount <= max,TMP_13(bool) = TMP_11 && TMP_12,CONDITION TMP_13,Emit Withdrawal(to,amount),Transfer dest:to value:amount,MODIFIER_CALL, DepositVault.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->8;
1[label=""Node Type: IF 1

EXPRESSION:
WithdrawalEnabled()

IRs:
TMP_10(bool) = INTERNAL_CALL, DepositVault.WithdrawalEnabled()()
CONDITION TMP_10""];
1->2[label=""True""];
1->7[label=""False""];
2[label=""Node Type: NEW VARIABLE 2

EXPRESSION:
max = Deposits[msg.sender]

IRs:
REF_1(uint256) -> Deposits[msg.sender]
max(uint256) := REF_1(uint256)""];
2->3;
3[label=""Node Type: IF 3

EXPRESSION:
max > 0 && amount <= max

IRs:
TMP_11(bool) = max > 0
TMP_12(bool) = amount <= max
TMP_13(bool) = TMP_11 && TMP_12
CONDITION TMP_13""];
3->4[label=""True""];
3->6[label=""False""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
Withdrawal(to,amount)

IRs:
Emit Withdrawal(to,amount)""];
4->5;
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
to.transfer(amount)

IRs:
Transfer dest:to value:amount""];
5->6;
6[label=""Node Type: END_IF 6
""];
6->7;
7[label=""Node Type: END_IF 7
""];
8[label=""Node Type: EXPRESSION 8

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, DepositVault.onlyOwner()()""];
8->1;
}
",0,0,1,0,"onlyOwner();WithdrawalEnabled();max = Deposits[msg.sender];;max > 0 && amount <= max;Withdrawal(to,amount);;to.transfer(amount)"
./0x704079e823e42a936bbaac5163434c2515473836_ext.sol,CONUNDRUM.StopGame,35,41,"TMP_9(bool) = msg.sender == questionSender,TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9),REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_3","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == questionSender)

IRs:
TMP_9(bool) = msg.sender == questionSender
TMP_10(None) = SOLIDITY_CALL require(bool)(TMP_9)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_3""];
}
",0,0,1,0,require(bool)(msg.sender == questionSender);msg.sender.transfer(this.balance)
./0x0002325fcaaac6ebf1254a626589147bde1a2394_ext.sol,HorseyPilot.withdrawCeo,1160,1177,"TMP_365(bool) = toBeDistributed > 0,CONDITION TMP_365,INTERNAL_CALL, HorseyPilot._updateDistribution()(),REF_126(uint256) -> _cBalance[msg.sender],balance(uint256) := REF_126(uint256),TMP_367(bool) = balance > 0,TMP_368 = CONVERT this to address,TMP_369(uint256) = SOLIDITY_CALL balance(address)(TMP_368),TMP_370(bool) = TMP_369 >= balance,TMP_371(bool) = TMP_367 && TMP_370,CONDITION TMP_371,Transfer dest:destination value:balance,REF_128(uint256) -> _cBalance[msg.sender],REF_128(uint256) (->_cBalance) := 0(uint256),MODIFIER_CALL, HorseyPilot.onlyCLevelAccess()(),MODIFIER_CALL, HorseyPilot.validAddress(address)(destination)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->9;
1[label=""Node Type: IF 1

EXPRESSION:
toBeDistributed > 0

IRs:
TMP_365(bool) = toBeDistributed > 0
CONDITION TMP_365""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
_updateDistribution()

IRs:
INTERNAL_CALL, HorseyPilot._updateDistribution()()""];
2->3;
3[label=""Node Type: END_IF 3
""];
3->4;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
balance = _cBalance[msg.sender]

IRs:
REF_126(uint256) -> _cBalance[msg.sender]
balance(uint256) := REF_126(uint256)""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
balance > 0 && (address(this).balance >= balance)

IRs:
TMP_367(bool) = balance > 0
TMP_368 = CONVERT this to address
TMP_369(uint256) = SOLIDITY_CALL balance(address)(TMP_368)
TMP_370(bool) = TMP_369 >= balance
TMP_371(bool) = TMP_367 && TMP_370
CONDITION TMP_371""];
5->6[label=""True""];
5->8[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
destination.transfer(balance)

IRs:
Transfer dest:destination value:balance""];
6->7;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
_cBalance[msg.sender] = 0

IRs:
REF_128(uint256) -> _cBalance[msg.sender]
REF_128(uint256) (->_cBalance) := 0(uint256)""];
7->8;
8[label=""Node Type: END_IF 8
""];
9[label=""Node Type: EXPRESSION 9

EXPRESSION:
onlyCLevelAccess()

IRs:
MODIFIER_CALL, HorseyPilot.onlyCLevelAccess()()""];
9->10;
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
validAddress(destination)

IRs:
MODIFIER_CALL, HorseyPilot.validAddress(address)(destination)""];
10->1;
}
",0,0,1,0,onlyCLevelAccess();toBeDistributed > 0;_updateDistribution();;balance = _cBalance[msg.sender];balance > 0 && (address(this).balance >= balance);destination.transfer(balance);;_cBalance[msg.sender] = 0;validAddress(destination)
./0xf0344800bd3ffa687e4d780357961b28995a5f46_ext.sol,QUIZ_GAME.Play,5,14,"TMP_0(bool) = msg.sender == tx.origin,TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0),TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response),TMP_3(bool) = responseHash == TMP_2,TMP_4(bool) = msg.value > 1000000000000000000,TMP_5(bool) = TMP_3 && TMP_4,CONDITION TMP_5,REF_1(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:msg.sender value:REF_1","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == tx.origin)

IRs:
TMP_0(bool) = msg.sender == tx.origin
TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)""];
1->2;
2[label=""Node Type: IF 2

EXPRESSION:
responseHash == keccak256()(_response) && msg.value > 1000000000000000000

IRs:
TMP_2(bytes32) = SOLIDITY_CALL keccak256()(_response)
TMP_3(bool) = responseHash == TMP_2
TMP_4(bool) = msg.value > 1000000000000000000
TMP_5(bool) = TMP_3 && TMP_4
CONDITION TMP_5""];
2->3[label=""True""];
2->4[label=""False""];
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
msg.sender.transfer(this.balance)

IRs:
REF_1(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:msg.sender value:REF_1""];
3->4;
4[label=""Node Type: END_IF 4
""];
}
",0,0,1,0,require(bool)(msg.sender == tx.origin);responseHash == keccak256()(_response) && msg.value > 1000000000000000000;msg.sender.transfer(this.balance);
./0x658b3573f8222c2d792ff1199933a88680b12973_ext.sol,AccessService.withdraw,104,116,"TMP_37(bool) = msg.sender == addrFinance,TMP_38(bool) = msg.sender == addrAdmin,TMP_39(bool) = TMP_37 || TMP_38,TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39),TMP_41(bool) = _amount > 0,TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41),REF_0(uint256) = SOLIDITY_CALL balance(address)(this),balance(uint256) := REF_0([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E2A14580>]),TMP_43(bool) = _amount < balance,CONDITION TMP_43,Transfer dest:receiver value:_amount,REF_3(uint256) = SOLIDITY_CALL balance(address)(this),Transfer dest:receiver value:REF_3,TMP_46 = CONVERT 0 to address,TMP_47(bool) = _target == TMP_46,CONDITION TMP_47,receiver(address) := addrFinance(address),receiver(address) := _target(address)","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->1;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(msg.sender == addrFinance || msg.sender == addrAdmin)

IRs:
TMP_37(bool) = msg.sender == addrFinance
TMP_38(bool) = msg.sender == addrAdmin
TMP_39(bool) = TMP_37 || TMP_38
TMP_40(None) = SOLIDITY_CALL require(bool)(TMP_39)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
require(bool)(_amount > 0)

IRs:
TMP_41(bool) = _amount > 0
TMP_42(None) = SOLIDITY_CALL require(bool)(TMP_41)""];
2->9;
4[label=""Node Type: NEW VARIABLE 4

EXPRESSION:
balance = this.balance

IRs:
REF_0(uint256) = SOLIDITY_CALL balance(address)(this)
balance(uint256) := REF_0([<slither.core.solidity_types.elementary_type.ElementaryType object at 0x000001A9E2A14580>])""];
4->5;
5[label=""Node Type: IF 5

EXPRESSION:
_amount < balance

IRs:
TMP_43(bool) = _amount < balance
CONDITION TMP_43""];
5->6[label=""True""];
5->7[label=""False""];
6[label=""Node Type: EXPRESSION 6

EXPRESSION:
receiver.transfer(_amount)

IRs:
Transfer dest:receiver value:_amount""];
6->8;
7[label=""Node Type: EXPRESSION 7

EXPRESSION:
receiver.transfer(this.balance)

IRs:
REF_3(uint256) = SOLIDITY_CALL balance(address)(this)
Transfer dest:receiver value:REF_3""];
7->8;
8[label=""Node Type: END_IF 8
""];
9[label=""Node Type: IF 9

EXPRESSION:
_target == address(0)

IRs:
TMP_46 = CONVERT 0 to address
TMP_47(bool) = _target == TMP_46
CONDITION TMP_47""];
9->10[label=""True""];
9->11[label=""False""];
10[label=""Node Type: EXPRESSION 10

EXPRESSION:
receiver = addrFinance

IRs:
receiver(address) := addrFinance(address)""];
10->12;
11[label=""Node Type: EXPRESSION 11

EXPRESSION:
receiver = _target

IRs:
receiver(address) := _target(address)""];
11->12;
12[label=""Node Type: END_IF 12
""];
12->4;
}
",0,0,1,0,require(bool)(msg.sender == addrFinance || msg.sender == addrAdmin);require(bool)(_amount > 0);_target == address(0);balance = this.balance;_amount < balance;receiver.transfer(_amount);receiver.transfer(this.balance);;receiver = addrFinance;receiver = _target;
./0xc35d0837d49aa399022e133ba141b85d8809b137_ext.sol,FUS.safeWithdrawal,304,309,"TMP_97(bool) = _value == 0,CONDITION TMP_97,TMP_98 = CONVERT this to address,TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98),Transfer dest:owner value:TMP_99,Transfer dest:owner value:_value,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->5;
1[label=""Node Type: IF 1

EXPRESSION:
_value == 0

IRs:
TMP_97(bool) = _value == 0
CONDITION TMP_97""];
1->2[label=""True""];
1->3[label=""False""];
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
owner.transfer(address(this).balance)

IRs:
TMP_98 = CONVERT this to address
TMP_99(uint256) = SOLIDITY_CALL balance(address)(TMP_98)
Transfer dest:owner value:TMP_99""];
2->4;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
owner.transfer(_value)

IRs:
Transfer dest:owner value:_value""];
3->4;
4[label=""Node Type: END_IF 4
""];
5[label=""Node Type: EXPRESSION 5

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
5->1;
}
",0,0,1,0,onlyOwner();_value == 0;owner.transfer(address(this).balance);owner.transfer(_value);
./0x013183d8e0a14a843aa3bc170a29f959d9614d28_ext.sol,DetherBank.withdrawEth,193,197,"REF_21(uint256) -> ethTellerBalance[_from],TMP_61(bool) = REF_21 >= _amount,TMP_62(None) = SOLIDITY_CALL require(bool)(TMP_61),REF_22(uint256) -> ethTellerBalance[_from],REF_24(uint256) -> ethTellerBalance[_from],TMP_63(uint256) = INTERNAL_CALL, SafeMath.sub(uint256,uint256)(REF_24,_amount),REF_22(uint256) (->ethTellerBalance) := TMP_63(uint256),Transfer dest:_to value:_amount,MODIFIER_CALL, Ownable.onlyOwner()()","digraph{
0[label=""Node Type: ENTRY_POINT 0
""];
0->4;
1[label=""Node Type: EXPRESSION 1

EXPRESSION:
require(bool)(ethTellerBalance[_from] >= _amount)

IRs:
REF_21(uint256) -> ethTellerBalance[_from]
TMP_61(bool) = REF_21 >= _amount
TMP_62(None) = SOLIDITY_CALL require(bool)(TMP_61)""];
1->2;
2[label=""Node Type: EXPRESSION 2

EXPRESSION:
ethTellerBalance[_from] = SafeMath.sub(ethTellerBalance[_from],_amount)

IRs:
REF_22(uint256) -> ethTellerBalance[_from]
REF_24(uint256) -> ethTellerBalance[_from]
TMP_63(uint256) = INTERNAL_CALL, SafeMath.sub(uint256,uint256)(REF_24,_amount)
REF_22(uint256) (->ethTellerBalance) := TMP_63(uint256)""];
2->3;
3[label=""Node Type: EXPRESSION 3

EXPRESSION:
_to.transfer(_amount)

IRs:
Transfer dest:_to value:_amount""];
4[label=""Node Type: EXPRESSION 4

EXPRESSION:
onlyOwner()

IRs:
MODIFIER_CALL, Ownable.onlyOwner()()""];
4->1;
}
",0,0,1,0,"onlyOwner();require(bool)(ethTellerBalance[_from] >= _amount);ethTellerBalance[_from] = SafeMath.sub(ethTellerBalance[_from],_amount);_to.transfer(_amount)"
